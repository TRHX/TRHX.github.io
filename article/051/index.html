<!-- 
          _____                   _______                   _____          
          /\    \                 /::\    \                 /\    \         
         /::\    \               /::::\    \               /::\    \        
        /::::\    \             /::::::\    \             /::::\    \       
       /::::::\    \           /::::::::\    \           /::::::\    \      
      /:::/\:::\    \         /:::/~~\:::\    \         /:::/\:::\    \     
     /:::/__\:::\    \       /:::/    \:::\    \       /:::/__\:::\    \    
    /::::\   \:::\    \     /:::/    / \:::\    \     /::::\   \:::\    \   
   /::::::\   \:::\    \   /:::/____/   \:::\____\   /::::::\   \:::\    \  
  /:::/\:::\   \:::\ ___\ |:::|    |     |:::|    | /:::/\:::\   \:::\ ___\ 
 /:::/__\:::\   \:::|    ||:::|____|     |:::|    |/:::/__\:::\   \:::|    |
 \:::\   \:::\  /:::|____| \:::\    \   /:::/    / \:::\   \:::\  /:::|____|
  \:::\   \:::\/:::/    /   \:::\    \ /:::/    /   \:::\   \:::\/:::/    / 
   \:::\   \::::::/    /     \:::\    /:::/    /     \:::\   \::::::/    /  
    \:::\   \::::/    /       \:::\__/:::/    /       \:::\   \::::/    /   
     \:::\  /:::/    /         \::::::::/    /         \:::\  /:::/    /    
      \:::\/:::/    /           \::::::/    /           \:::\/:::/    /     
       \::::::/    /             \::::/    /             \::::::/    /      
        \::::/    /               \::/____/               \::::/    /       
         \::/____/                 ~~                      \::/____/        
          ~~                                                ~~              
                                                                            
                                WWW.ITBOB.CN
                                
                        有毛的叫程序猿，沒毛的叫程序员。
-->

<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Force https -->

    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">


<!-- Title -->
<title>逆向进阶，利用 AST 技术还原 JavaScript 混淆代码 - BOB&#39;S BLOG</title>

<!-- Icon -->
<link rel="icon" href="/img/favicon.ico">

<!-- Fonts -->
<link rel="preload" href="//fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Open+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" as="style" onload="this.onload=null, this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="//fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Open+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript>

<!-- Font Awesome -->
<!-- https://fontawesome.dashgame.com/ -->
<!-- <link rel="stylesheet" href="https://cdn.itbob.cn/css/font-awesome@5.6.3/all.min.css"> -->
<link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/5.15.4/css/all.min.css">
<!-- <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css"> -->


    <!-- KaTeX -->
    <!-- //cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css -->
    <link rel="preload" href="//cdn.itbob.cn/css/katex@0.12.0/katex.min.css" as="style" onload="this.onload=null, this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="//cdn.itbob.cn/css/katex@0.12.0/katex.min.css"></noscript>


<!-- Style -->

<link rel="stylesheet" href="/styles/main.css">

<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-pure@1.0.1/dist/main.css"> -->

<!-- Analytics -->

    
    
        <!-- Baidu Analytics -->
        <script defer>
            var _hmt = _hmt || [];
            (function () {
                var hm = document.createElement('script');
                hm.src = 'https://hm.baidu.com/hm.js?6ca34ddce088f8434f3c7509576819f2';
                var s = document.getElementsByTagName('script')[0];
                s.parentNode.insertBefore(hm, s);
            })();
        </script>
    


<!-- Busuanzi -->
<!-- <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> -->
<script async src="//cdn.itbob.cn/js/busuanzi@2.3/busuanzi.pure.mini.js"></script>

<!-- Typeit -->
<!-- https://www.typeitjs.com/ -->
<script src="//unpkg.com/typeit@8.7.0/dist/index.umd.js"></script>

<!-- Fancybox -->

    <link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css">
    <script src="//cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script>
    <script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"> </script>
    <script src="//cdn.itbob.cn/js/fancybox@3.5.7/fancybox.js"> </script>

<!-- <script>
  $('[data-fancybox="images"]').fancybox({//可选
    thumbs : {
      autoStart : true //缩略图
    }
  });
  $('[data-fancybox]').fancybox({//启用函数，必须
    protect: true //图片右键不能下载，可选
  });
</script> -->

<!-- Console -->
<script>
    function makeMulti (string) {
        let l = new String(string)
        l = l.substring(l.indexOf("/*") + 3, l.lastIndexOf("*/"))
        return l
    }
    let string = function () {
      /* 
          _____                   _______                   _____          
          /\    \                 /::\    \                 /\    \         
         /::\    \               /::::\    \               /::\    \        
        /::::\    \             /::::::\    \             /::::\    \       
       /::::::\    \           /::::::::\    \           /::::::\    \      
      /:::/\:::\    \         /:::/~~\:::\    \         /:::/\:::\    \     
     /:::/__\:::\    \       /:::/    \:::\    \       /:::/__\:::\    \    
    /::::\   \:::\    \     /:::/    / \:::\    \     /::::\   \:::\    \   
   /::::::\   \:::\    \   /:::/____/   \:::\____\   /::::::\   \:::\    \  
  /:::/\:::\   \:::\ ___\ |:::|    |     |:::|    | /:::/\:::\   \:::\ ___\ 
 /:::/__\:::\   \:::|    ||:::|____|     |:::|    |/:::/__\:::\   \:::|    |
 \:::\   \:::\  /:::|____| \:::\    \   /:::/    / \:::\   \:::\  /:::|____|
  \:::\   \:::\/:::/    /   \:::\    \ /:::/    /   \:::\   \:::\/:::/    / 
   \:::\   \::::::/    /     \:::\    /:::/    /     \:::\   \::::::/    /  
    \:::\   \::::/    /       \:::\__/:::/    /       \:::\   \::::/    /   
     \:::\  /:::/    /         \::::::::/    /         \:::\  /:::/    /    
      \:::\/:::/    /           \::::::/    /           \:::\/:::/    /     
       \::::::/    /             \::::/    /             \::::::/    /      
        \::::/    /               \::/____/               \::::/    /       
         \::/____/                 ~~                      \::/____/        
          ~~                                                ~~              
                                                                            
                                WWW.ITBOB.CN
                                
                        有毛的叫程序猿，沒毛的叫程序员。
      */
    }
    console.log(makeMulti(string));
    console.log("\n %c © ITBOB'S BLOG %c https://www.itbob.cn %c © ITRHX'S BLOG %c https://www.itrhx.com \n", "color: #fadfa3; background: #030307; padding:5px 0;", "background: #fadfa3; padding:5px 0;", "color: #fadfa3; background: #030307; padding:5px 0;", "background: #fadfa3; padding:5px 0;")
</script>

    <meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="BOB'S BLOG" type="application/atom+xml">
</head>
    <body>
        <div class="main gt-bg-theme-color-first">
            <div class="main-content">
                <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="/img/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first" id="typeitspan">
            <!-- BOB&#39;S BLOG -->
        </div>
    </a>
    <!-- <span id="typeitspan"></span> -->
    <script>
        new TypeIt('#typeitspan', {
        strings: "BOB'S BLOG",
        speed: 150, 
        afterComplete: function (instance) {
            instance.destroy();
        }
        }).go();
    </script>
    <button aria-label="Navbar Toggler" class="navbar-toggler" type="button" id="changeNavbar">
        <i class="gt-c-content-color-first" style="font-size: 18px;">
            <svg xmlns="https://www.w3.org/2000/svg" viewBox="0 0 448 512" height="18px" fill="currentColor">
                <path d="M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z" />
            </svg>
        </i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center; ">
            
                
                    <div class="nav-item">
                        <a href="/" class="menu gt-a-link" target="_self">首页</a>
                    </div>
                
            
                
                    <div class="nav-item">
                        <a href="/archives/" class="menu gt-a-link" target="_self">归档</a>
                    </div>
                
            
                
                    <div class="nav-item">
                        <a href="/tags/" class="menu gt-a-link" target="_self">标签</a>
                    </div>
                
            
                
                    <div class="nav-item">
                        <a href="/friends/" class="menu gt-a-link" target="_self">友链</a>
                    </div>
                
            
                
                    <div class="nav-item">
                        <a href="/about/" class="menu gt-a-link" target="_self">关于</a>
                    </div>
                
            
                
                    <div class="nav-item">
                        <a href="https://travellings.link" target="_blank">
                            <img src="https://cdn.itbob.cn/img/travelling.gif" class="nofancybox" alt="开往-友链接力" width="auto" height="25px">
                        </a>
                    </div>
                
            
        </div>
    </div>
</nav>

<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function() {
        let element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else { 
            element.style.display = 'none';
        }
    }
</script>

                <div class="post-container">
    <div class="post-detail gt-bg-theme-color-second gt-c-content-color-first">
        <article class="gt-post-content">
            <h1 class="post-title">逆向进阶，利用 AST 技术还原 JavaScript 混淆代码</h1>
            <div class="post-info">
                <time class="post-time gt-c-content-color-first">
                    <i class="fa fa-calendar-alt"></i> 首发于: 2022-04-25丨
                </time>
                <span id="busuanzi_container_page_pv">
                    <i class="fas fa-eye"></i> 阅读量: <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>丨
                </span>
                
                    <span class="post-count">
                        <i class="fa fa-keyboard"></i> 字数统计: 7.2k丨
                    </span>
                    <span class="post-count">
                        <i class="fa fa-hourglass-half"></i> 阅读时长: 30分丨
                    </span>
                
                
                    
                        <!-- <i class="fa fa-tag"></i> -->
                        <i class="fas fa-hashtag"></i>
                        <a href="/tags/%E7%88%AC%E8%99%AB/" class="post-tag">
                            爬虫</a>
                    
                        <!-- <i class="fa fa-tag"></i> -->
                        <i class="fas fa-hashtag"></i>
                        <a href="/tags/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/" class="post-tag">
                            JS 逆向理论</a>
                    
                
            </div>
            <hr>
            <div class="post-content gt-c-content-color-first">
                <p><img src="https://cdn.itbob.cn/img/cover/ast.png" alt="ast"></p>
<h2><span id="wen-zhang-mu-lu">文章目录</span></h2>
<hr>
<!-- toc -->
<ul>
<li><a href="#shi-me-shi-ast">什么是 AST</a></li>
<li><a href="#ast-zai-bian-yi-zhong-de-wei-zhi">AST 在编译中的位置</a>
<ul>
<li><a href="#ci-fa-fen-xi">词法分析</a></li>
<li><a href="#yu-fa-fen-xi">语法分析</a></li>
<li><a href="#dai-ma-sheng-cheng">代码生成</a></li>
</ul>
</li>
<li><a href="#babel-jian-jie">Babel 简介</a>
<ul>
<li><a href="#babel-core">@babel/core</a></li>
<li><a href="#babel-parser">@babel/parser</a></li>
<li><a href="#babel-generator">@babel/generator</a></li>
<li><a href="#babel-traverse">@babel/traverse</a></li>
<li><a href="#babel-types">@babel/types</a></li>
</ul>
</li>
<li><a href="#chang-jian-hun-yao-huan-yuan">常见混淆还原</a>
<ul>
<li><a href="#zi-fu-chuan-huan-yuan">字符串还原</a></li>
<li><a href="#biao-da-shi-huan-yuan">表达式还原</a></li>
<li><a href="#shan-chu-wei-shi-yong-bian-liang">删除未使用变量</a></li>
<li><a href="#shan-chu-rong-yu-luo-ji-dai-ma">删除冗余逻辑代码</a></li>
<li><a href="#switch-case-fan-kong-zhi-liu-ping-tan-hua">switch-case 反控制流平坦化</a></li>
</ul>
</li>
<li><a href="#can-kao-zi-liao">参考资料</a></li>
<li><a href="#end">END</a></li>
</ul>
<!-- tocstop -->
<hr>
<h2><span id="shi-me-shi-ast">什么是 AST</span></h2>
<p>AST（Abstract Syntax Tree），中文抽象语法树，简称语法树（Syntax Tree），是源代码的抽象语法结构的树状表现形式，树上的每个节点都表示源代码中的一种结构。语法树不是某一种编程语言独有的，JavaScript、Python、Java、Golang 等几乎所有编程语言都有语法树。</p>
<p>小时候我们得到一个玩具，总喜欢把玩具拆解成一个一个小零件，然后按照我们自己的想法，把零件重新组装起来，一个新玩具就诞生了。而 JavaScript 就像一台精妙运作的机器，通过 AST 解析，我们也可以像童年时拆解玩具一样，深入了解 JavaScript 这台机器的各个零部件，然后重新按照我们自己的意愿来组装。</p>
<p>AST 的用途很广，IDE 的语法高亮、代码检查、格式化、压缩、转译等，都需要先将代码转化成 AST 再进行后续的操作，ES5 和 ES6 语法差异，为了向后兼容，在实际应用中需要进行语法的转换，也会用到 AST。AST 并不是为了逆向而生，但做逆向学会了 AST，在解混淆时可以如鱼得水。</p>
<p>AST 有一个在线解析网站：<a target="_blank" rel="noopener" href="https://astexplorer.net/">https://astexplorer.net/</a> ，顶部可以选择语言、编译器、是否开启转化等，如下图所示，区域①是源代码，区域②是对应的 AST 语法树，区域③是转换代码，可以对语法树进行各种操作，区域④是转换后生成的新代码。图中原来的 Unicode 字符经过操作之后就变成了正常字符。</p>
<p>语法树没有单一的格式，选择不同的语言、不同的编译器，得到的结果也是不一样的，在 JavaScript 中，编译器有 Acorn、Espree、Esprima、Recast、Uglify-JS 等，使用最多的是 Babel，后续的学习也是以 Babel 为例。</p>
<p><img src="https://cdn.itbob.cn/img/article/051/01.png" alt="01"></p>
<h2><span id="ast-zai-bian-yi-zhong-de-wei-zhi">AST 在编译中的位置</span></h2>
<p>在编译原理中，编译器转换代码通常要经过三个步骤：词法分析（Lexical Analysis）、语法分析（Syntax Analysis）、代码生成（Code Generation），下图生动展示了这一过程：</p>
<p><img src="https://cdn.itbob.cn/img/article/051/02.png" alt="02"></p>
<h3><span id="ci-fa-fen-xi">词法分析</span></h3>
<p>词法分析阶段是编译过程的第一个阶段，这个阶段的任务是从左到右一个字符一个字符地读入源程序，然后根据构词规则识别单词，生成 token 符号流，比如 <code>isPanda('🐼')</code>，会被拆分成 <code>isPanda</code>，<code>(</code>，<code>'🐼'</code>，<code>)</code> 四部分，每部分都有不同的含义，可以将词法分析过程想象为不同类型标记的列表或数组。</p>
<p><img src="https://cdn.itbob.cn/img/article/051/03.gif" alt="03"></p>
<h3><span id="yu-fa-fen-xi">语法分析</span></h3>
<p>语法分析是编译过程的一个逻辑阶段，语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，比如“程序”，“语句”，“表达式”等，前面的例子中，<code>isPanda('🐼')</code> 就会被分析为一条表达语句 <code>ExpressionStatement</code>，<code>isPanda()</code> 就会被分析成一个函数表达式 <code>CallExpression</code>，<code>🐼</code> 就会被分析成一个变量 <code>Literal</code> 等，众多语法之间的依赖、嵌套关系，就构成了一个树状结构，即 AST 语法树。</p>
<p><img src="https://cdn.itbob.cn/img/article/051/04.gif" alt="04"></p>
<h3><span id="dai-ma-sheng-cheng">代码生成</span></h3>
<p>代码生成是最后一步，将 AST 语法树转换成可执行代码即可，在转换之前，我们可以直接操作语法树，进行增删改查等操作，例如，我们可以确定变量的声明位置、更改变量的值、删除某些节点等，我们将语句 <code>isPanda('🐼')</code> 修改为一个布尔类型的 <code>Literal</code>：<code>true</code>，语法树就有如下变化：</p>
<p><img src="https://cdn.itbob.cn/img/article/051/05.gif" alt="05"></p>
<h2><span id="babel-jian-jie">Babel 简介</span></h2>
<p>Babel 是一个 JavaScript 编译器，也可以说是一个解析库，Babel 中文网：<a target="_blank" rel="noopener" href="https://www.babeljs.cn/">https://www.babeljs.cn/</a> ，Babel 英文官网：<a target="_blank" rel="noopener" href="https://babeljs.io/">https://babeljs.io/</a> ，Babel 内置了很多分析 JavaScript 代码的方法，我们可以利用 Babel 将 JavaScript 代码转换成 AST 语法树，然后增删改查等操作之后，再转换成 JavaScript 代码。</p>
<p>Babel 包含的各种功能包、API、各方法可选参数等，都非常多，本文不一一列举，在实际使用过程中，应当多查询官方文档，或者参考文末给出的一些学习资料。Babel 的安装和其他 Node 包一样，需要哪个安装哪个即可，比如 <code>npm install @babel/core @babel/parser @babel/traverse @babel/generator</code></p>
<p>在做逆向解混淆中，主要用到了 Babel 的以下几个功能包，本文也仅介绍以下几个功能包：</p>
<ol>
<li><code>@babel/core</code>：Babel 编译器本身，提供了 babel 的编译 API；</li>
<li><code>@babel/parser</code>：将 JavaScript 代码解析成 AST 语法树；</li>
<li><code>@babel/traverse</code>：遍历、修改 AST 语法树的各个节点；</li>
<li><code>@babel/generator</code>：将 AST 还原成 JavaScript 代码；</li>
<li><code>@babel/types</code>：判断、验证节点的类型、构建新 AST 节点等。</li>
</ol>
<p><img src="https://cdn.itbob.cn/img/article/051/06.png" alt="06"></p>
<h3><span id="babel-core">@babel/core</span></h3>
<p>Babel 编译器本身，被拆分成了三个模块：<code>@babel/parser</code>、<code>@babel/traverse</code>、<code>@babel/generator</code>，比如以下方法的导入效果都是一样的：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>).parse;
<span class="hljs-keyword">const</span> parse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/core&quot;</span>).parse;

<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default
<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/core&quot;</span>).traverse</code></pre>
<h3><span id="babel-parser">@babel/parser</span></h3>
<p><code>@babel/parser</code> 可以将 JavaScript 代码解析成 AST 语法树，其中主要提供了两个方法：</p>
<ul>
<li><code>parser.parse(code, [&#123;options&#125;])</code>：解析一段 JavaScript 代码；</li>
<li><code>parser.parseExpression(code, [&#123;options&#125;])</code>：考虑到了性能问题，解析单个 JavaScript 表达式。</li>
</ul>
<p>部分可选参数 <code>options</code>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>allowImportExportEverywhere</code></td>
<td>默认 <code>import</code> 和 <code>export</code> 声明语句只能出现在程序的最顶层，设置为 <code>true</code> 则在任何地方都可以声明</td>
</tr>
<tr>
<td><code>allowReturnOutsideFunction</code></td>
<td>默认如果在顶层中使用 <code>return</code> 语句会引起错误，设置为 <code>true</code> 就不会报错</td>
</tr>
<tr>
<td><code>sourceType</code></td>
<td>默认为 <code>script</code>，当代码中含有 <code>import</code> 、<code>export</code> 等关键字时会报错，需要指定为 <code>module</code></td>
</tr>
<tr>
<td><code>errorRecovery</code></td>
<td>默认如果 babel 发现一些不正常的代码就会抛出错误，设置为 <code>true</code> 则会在保存解析错误的同时继续解析代码，错误的记录将被保存在最终生成的 AST 的 errors 属性中，当然如果遇到严重的错误，依然会终止解析</td>
</tr>
</tbody>
</table>
<p>举个例子看得比较清楚：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);

<span class="hljs-keyword">const</span> code = <span class="hljs-string">&quot;const a = 1;&quot;</span>;
<span class="hljs-keyword">const</span> ast = parser.parse(code, &#123;<span class="hljs-attr">sourceType</span>: <span class="hljs-string">&quot;module&quot;</span>&#125;)
<span class="hljs-built_in">console</span>.log(ast)</code></pre>
<p><code>&#123;sourceType: &quot;module&quot;&#125;</code> 演示了如何添加可选参数，输出的就是 AST 语法树，这和在线网站 <a target="_blank" rel="noopener" href="https://astexplorer.net/">https://astexplorer.net/</a> 解析出来的语法树是一样的：</p>
<p><img src="https://cdn.itbob.cn/img/article/051/07.png" alt="07"></p>
<h3><span id="babel-generator">@babel/generator</span></h3>
<p><code>@babel/generator</code> 可以将 AST 还原成 JavaScript 代码，提供了一个 <code>generate</code> 方法：<code>generate(ast, [&#123;options&#125;], code)</code>。</p>
<p>部分可选参数 <code>options</code>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>auxiliaryCommentBefore</code></td>
<td>在输出文件内容的头部添加注释块文字</td>
</tr>
<tr>
<td><code>auxiliaryCommentAfter</code></td>
<td>在输出文件内容的末尾添加注释块文字</td>
</tr>
<tr>
<td><code>comments</code></td>
<td>输出内容是否包含注释</td>
</tr>
<tr>
<td><code>compact</code></td>
<td>输出内容是否不添加空格，避免格式化</td>
</tr>
<tr>
<td><code>concise</code></td>
<td>输出内容是否减少空格使其更紧凑一些</td>
</tr>
<tr>
<td><code>minified</code></td>
<td>是否压缩输出代码</td>
</tr>
<tr>
<td><code>retainLines</code></td>
<td>尝试在输出代码中使用与源代码中相同的行号</td>
</tr>
</tbody>
</table>
<p>接着前面的例子，原代码是 <code>const a = 1;</code>，现在我们把 <code>a</code> 变量修改为 <code>b</code>，值 <code>1</code> 修改为 <code>2</code>，然后将 AST 还原生成新的 JS 代码：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);
<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default

<span class="hljs-keyword">const</span> code = <span class="hljs-string">&quot;const a = 1;&quot;</span>;
<span class="hljs-keyword">const</span> ast = parser.parse(code, &#123;<span class="hljs-attr">sourceType</span>: <span class="hljs-string">&quot;module&quot;</span>&#125;)
ast.program.body[<span class="hljs-number">0</span>].declarations[<span class="hljs-number">0</span>].id.name = <span class="hljs-string">&quot;b&quot;</span>
ast.program.body[<span class="hljs-number">0</span>].declarations[<span class="hljs-number">0</span>].init.value = <span class="hljs-number">2</span>
<span class="hljs-keyword">const</span> result = generate(ast, &#123;<span class="hljs-attr">minified</span>: <span class="hljs-literal">true</span>&#125;)

<span class="hljs-built_in">console</span>.log(result.code)</code></pre>
<p>最终输出的是 <code>const b=2;</code>，变量名和值都成功更改了，由于加了压缩处理，等号左右两边的空格也没了。</p>
<p>代码里 <code>&#123;minified: true&#125;</code> 演示了如何添加可选参数，这里表示压缩输出代码，<code>generate</code> 得到的 <code>result</code> 得到的是一个对象，其中的 <code>code</code> 属性才是最终的 JS 代码。</p>
<p>代码里 <code>ast.program.body[0].declarations[0].id.name</code> 是 a 在 AST 中的位置，<code>ast.program.body[0].declarations[0].init.value</code> 是 1 在 AST 中的位置，如下图所示：</p>
<p><img src="https://cdn.itbob.cn/img/article/051/08.png" alt="08"></p>
<h3><span id="babel-traverse">@babel/traverse</span></h3>
<p>当代码多了，我们不可能像前面那样挨个定位并修改，对于相同类型的节点，我们可以直接遍历所有节点来进行修改，这里就用到了 <code>@babel/traverse</code>，它通常和 <code>visitor</code> 一起使用，<code>visitor</code> 是一个对象，这个名字是可以随意取的，<code>visitor</code> 里可以定义一些方法来过滤节点，这里还是用一个例子来演示：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);
<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default
<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default

<span class="hljs-keyword">const</span> code = <span class="hljs-string">`</span>
<span class="hljs-string">const a = 1500;</span>
<span class="hljs-string">const b = 60;</span>
<span class="hljs-string">const c = &quot;hi&quot;;</span>
<span class="hljs-string">const d = 787;</span>
<span class="hljs-string">const e = &quot;1244&quot;;</span>
<span class="hljs-string">`</span>
<span class="hljs-keyword">const</span> ast = parser.parse(code)

<span class="hljs-keyword">const</span> visitor = &#123;
    <span class="hljs-function"><span class="hljs-title">NumericLiteral</span>(<span class="hljs-params">path</span>)</span>&#123;
        path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>
    &#125;,
    <span class="hljs-function"><span class="hljs-title">StringLiteral</span>(<span class="hljs-params">path</span>)</span>&#123;
        path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>
    &#125;
&#125;

traverse(ast, visitor)
<span class="hljs-keyword">const</span> result = generate(ast)
<span class="hljs-built_in">console</span>.log(result.code)</code></pre>
<p>这里的原始代码定义了 abcde 五个变量，其值有数字也有字符串，我们在 AST 中可以看到对应的类型为 <code>NumericLiteral</code> 和 <code>StringLiteral</code>：</p>
<p><img src="https://cdn.itbob.cn/img/article/051/09.png" alt="09"></p>
<p>然后我们声明了一个 <code>visitor</code> 对象，然后定义对应类型的处理方法，<code>traverse</code> 接收两个参数，第一个是 AST 对象，第二个是 <code>visitor</code>，当 <code>traverse</code> 遍历所有节点，遇到节点类型为 <code>NumericLiteral</code> 和 <code>StringLiteral</code> 时，就会调用 <code>visitor</code> 中对应的处理方法，<code>visitor</code> 中的方法会接收一个当前节点的 <code>path</code> 对象，该对象的类型是 <code>NodePath</code>，该对象有非常多的属性，以下介绍几种最常用的：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>toString()</code></td>
<td>当前路径的源码</td>
</tr>
<tr>
<td><code>node</code></td>
<td>当前路径的节点</td>
</tr>
<tr>
<td><code>parent</code></td>
<td>当前路径的父级节点</td>
</tr>
<tr>
<td><code>parentPath</code></td>
<td>当前路径的父级路径</td>
</tr>
<tr>
<td><code>type</code></td>
<td>当前路径的类型</td>
</tr>
</tbody>
</table>
<p>PS：<code>path</code> 对象除了有很多属性以外，还有很多方法，比如替换节点、删除节点、插入节点、寻找父级节点、获取同级节点、添加注释、判断节点类型等，可在需要时查询相关文档或查看源码，后续介绍 <code>@babel/types</code> 部分将会举部分例子来演示，以后的实战文章中也会有相关实例，篇幅有限本文不再细说。</p>
<p>因此在上面的代码中，<code>path.node.value</code> 就拿到了变量的值，然后我们就可以进一步对其进行修改了。以上代码运行后，所有数字都会加上100后再乘以2，所有字符串都会被替换成 <code>I Love JavaScript!</code>，结果如下：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">3200</span>;
<span class="hljs-keyword">const</span> b = <span class="hljs-number">320</span>;
<span class="hljs-keyword">const</span> c = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>;
<span class="hljs-keyword">const</span> d = <span class="hljs-number">1774</span>;
<span class="hljs-keyword">const</span> e = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>;</code></pre>
<p>如果多个类型的节点，处理的方式都一样，那么还可以使用 <code>|</code> 将所有节点连接成字符串，将同一个方法应用到所有节点：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;
    <span class="hljs-string">&quot;NumericLiteral|StringLiteral&quot;</span>(path) &#123;
        path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>
    &#125;
&#125;</code></pre>
<p><code>visitor</code> 对象有多种写法，以下几种写法的效果都是一样的：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;
    <span class="hljs-function"><span class="hljs-title">NumericLiteral</span>(<span class="hljs-params">path</span>)</span>&#123;
        path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>
    &#125;,
    <span class="hljs-function"><span class="hljs-title">StringLiteral</span>(<span class="hljs-params">path</span>)</span>&#123;
        path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>
    &#125;
&#125;</code></pre>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;
    <span class="hljs-attr">NumericLiteral</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>)</span>&#123;
        path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>
    &#125;,
    <span class="hljs-attr">StringLiteral</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>)</span>&#123;
        path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>
    &#125;
&#125;</code></pre>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;
    <span class="hljs-attr">NumericLiteral</span>: &#123;
        <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span> &#123;
            path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>
        &#125;
    &#125;,
    <span class="hljs-attr">StringLiteral</span>: &#123;
        <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span> &#123;
            path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>
        &#125;
    &#125;
&#125;</code></pre>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;
    <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (path.node.type === <span class="hljs-string">&quot;NumericLiteral&quot;</span>) &#123;
            path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>
        &#125;
        <span class="hljs-keyword">if</span> (path.node.type === <span class="hljs-string">&quot;StringLiteral&quot;</span>) &#123;
            path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>
        &#125;
    &#125;
&#125;</code></pre>
<p>以上几种写法中有用到了 <code>enter</code> 方法，在节点的遍历过程中，进入节点（enter）与退出（exit）节点都会访问一次节点，<code>traverse</code> 默认在进入节点时进行节点的处理，如果要在退出节点时处理，那么在 <code>visitor</code> 中就必须声明 <code>exit</code> 方法。</p>
<h3><span id="babel-types">@babel/types</span></h3>
<p><code>@babel/types</code> 主要用于构建新的 AST 节点，前面的示例代码为 <code>const a = 1;</code>，如果想要增加内容，比如变成 <code>const a = 1; const b = a * 5 + 1;</code>，就可以通过 <code>@babel/types</code> 来实现。</p>
<p>首先观察一下 AST 语法树，原语句只有一个 <code>VariableDeclaration</code> 节点，现在增加了一个：</p>
<p><img src="https://cdn.itbob.cn/img/article/051/10.png" alt="10"></p>
<p>那么我们的思路就是在遍历节点时，遍历到 <code>VariableDeclaration</code> 节点，就在其后面增加一个 <code>VariableDeclaration</code> 节点，生成  <code>VariableDeclaration</code> 节点，可以使用 <code>types.variableDeclaration()</code> 方法，在 types 中各种方法名称和我们在 AST 中看到的是一样的，只不过首字母是小写的，所以我们不需要知道所有方法的情况下，也能大致推断其方法名，只知道这个方法还不行，还得知道传入的参数是什么，可以查文档，不过这里推荐直接看源码，非常清晰明了，以 Pycharm 为例，按住 Ctrl 键，再点击方法名，就进到源码里了：</p>
<p><img src="https://cdn.itbob.cn/img/article/051/11.png" alt="11"></p>
<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">variableDeclaration</span>(<span class="hljs-params">kind: <span class="hljs-string">&quot;var&quot;</span> | <span class="hljs-string">&quot;let&quot;</span> | <span class="hljs-string">&quot;const&quot;</span>, declarations: <span class="hljs-built_in">Array</span>&lt;BabelNodeVariableDeclarator&gt;</span>)</span></code></pre>
<p>可以看到需要 <code>kind</code> 和 <code>declarations</code> 两个参数，其中 <code>declarations</code> 是 <code>VariableDeclarator</code> 类型的节点组成的列表，所以我们可以先写出以下 <code>visitor</code> 部分的代码，其中 <code>path.insertAfter()</code> 是在该节点之后插入新节点的意思：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;
    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;
        <span class="hljs-keyword">let</span> declaration = types.variableDeclaration(<span class="hljs-string">&quot;const&quot;</span>, [declarator])
        path.insertAfter(declaration)
    &#125;
&#125;</code></pre>
<p>接下来我们还需要进一步定义 <code>declarator</code>，也就是 <code>VariableDeclarator</code> 类型的节点，查询其源码如下：</p>
<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">variableDeclarator</span>(<span class="hljs-params">id: BabelNodeLVal, init?: BabelNodeExpression</span>)</span></code></pre>
<p>观察 AST，id 为 <code>Identifier</code> 对象，init 为 <code>BinaryExpression</code> 对象，如下图所示：</p>
<p><img src="https://cdn.itbob.cn/img/article/051/12.png" alt="12"></p>
<p>先来处理 id，可以使用 <code>types.identifier()</code> 方法来生成，其源码为 <code>function identifier(name: string)</code>，name 在这里就是 b 了，此时 <code>visitor</code> 代码就可以这么写：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;
    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;
        <span class="hljs-keyword">let</span> declarator = types.variableDeclarator(types.identifier(<span class="hljs-string">&quot;b&quot;</span>), init)
        <span class="hljs-keyword">let</span> declaration = types.variableDeclaration(<span class="hljs-string">&quot;const&quot;</span>, [declarator])
        path.insertAfter(declaration)
    &#125;
&#125;</code></pre>
<p>然后再来看 init 该如何定义，首先仍然是看 AST 结构：</p>
<p><img src="https://cdn.itbob.cn/img/article/051/13.png" alt="13"></p>
<p>init 为 <code>BinaryExpression</code> 对象，left 左边是 <code>BinaryExpression</code>，right 右边是 <code>NumericLiteral</code>，可以用 <code>types.binaryExpression()</code> 方法来生成 init，其源码如下：</p>
<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binaryExpression</span>(<span class="hljs-params"></span></span>
<span class="hljs-params"><span class="hljs-function">    operator: <span class="hljs-string">&quot;+&quot;</span> | <span class="hljs-string">&quot;-&quot;</span> | <span class="hljs-string">&quot;/&quot;</span> | <span class="hljs-string">&quot;%&quot;</span> | <span class="hljs-string">&quot;*&quot;</span> | <span class="hljs-string">&quot;**&quot;</span> | <span class="hljs-string">&quot;&amp;&quot;</span> | <span class="hljs-string">&quot;|&quot;</span> | <span class="hljs-string">&quot;&gt;&gt;&quot;</span> | <span class="hljs-string">&quot;&gt;&gt;&gt;&quot;</span> | <span class="hljs-string">&quot;&lt;&lt;&quot;</span> | <span class="hljs-string">&quot;^&quot;</span> | <span class="hljs-string">&quot;==&quot;</span> | <span class="hljs-string">&quot;===&quot;</span> | <span class="hljs-string">&quot;!=&quot;</span> | <span class="hljs-string">&quot;!==&quot;</span> | <span class="hljs-string">&quot;in&quot;</span> | <span class="hljs-string">&quot;instanceof&quot;</span> | <span class="hljs-string">&quot;&gt;&quot;</span> | <span class="hljs-string">&quot;&lt;&quot;</span> | <span class="hljs-string">&quot;&gt;=&quot;</span> | <span class="hljs-string">&quot;&lt;=&quot;</span>,</span></span>
<span class="hljs-params"><span class="hljs-function">    left: BabelNodeExpression | BabelNodePrivateName, </span></span>
<span class="hljs-params"><span class="hljs-function">    right: BabelNodeExpression</span></span>
<span class="hljs-params"><span class="hljs-function"></span>)</span></code></pre>
<p>此时 <code>visitor</code> 代码就可以这么写：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;
    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;
        <span class="hljs-keyword">let</span> init = types.binaryExpression(<span class="hljs-string">&quot;+&quot;</span>, left, right)
        <span class="hljs-keyword">let</span> declarator = types.variableDeclarator(types.identifier(<span class="hljs-string">&quot;b&quot;</span>), init)
        <span class="hljs-keyword">let</span> declaration = types.variableDeclaration(<span class="hljs-string">&quot;const&quot;</span>, [declarator])
        path.insertAfter(declaration)
    &#125;
&#125;</code></pre>
<p>然后继续构造 left 和 right，和前面的方法一样，观察 AST 语法树，查询对应方法应该传入的参数，层层嵌套，直到把所有的节点都构造完毕，最终的 <code>visitor</code> 代码应该是这样的：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;
    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;
        <span class="hljs-keyword">let</span> left = types.binaryExpression(<span class="hljs-string">&quot;*&quot;</span>, types.identifier(<span class="hljs-string">&quot;a&quot;</span>), types.numericLiteral(<span class="hljs-number">5</span>))
        <span class="hljs-keyword">let</span> right = types.numericLiteral(<span class="hljs-number">1</span>)
        <span class="hljs-keyword">let</span> init = types.binaryExpression(<span class="hljs-string">&quot;+&quot;</span>, left, right)
        <span class="hljs-keyword">let</span> declarator = types.variableDeclarator(types.identifier(<span class="hljs-string">&quot;b&quot;</span>), init)
        <span class="hljs-keyword">let</span> declaration = types.variableDeclaration(<span class="hljs-string">&quot;const&quot;</span>, [declarator])
        path.insertAfter(declaration)
        path.stop()
    &#125;
&#125;</code></pre>
<p>注意：<code>path.insertAfter()</code> 插入节点语句后面加了一句 <code>path.stop()</code>，表示插入完成后立即停止遍历当前节点和后续的子节点，添加的新节点也是 <code>VariableDeclaration</code>，如果不加停止语句的话，就会无限循环插入下去。</p>
<p>插入新节点后，再转换成 JavaScript 代码，就可以看到多了一行新代码，如下图所示：</p>
<p><img src="https://cdn.itbob.cn/img/article/051/14.png" alt="14"></p>
<h2><span id="chang-jian-hun-yao-huan-yuan">常见混淆还原</span></h2>
<p>了解了 AST 和 babel 后，就可以对 JavaScript 混淆代码进行还原了，以下是部分样例，带你进一步熟悉 babel 的各种操作。</p>
<h3><span id="zi-fu-chuan-huan-yuan">字符串还原</span></h3>
<p>文章开头的图中举了个例子，正常字符被换成了 Unicode 编码：</p>
<pre><code class="hljs javascript"><span class="hljs-built_in">console</span>[<span class="hljs-string">&#x27;\u006c\u006f\u0067&#x27;</span>](<span class="hljs-string">&#x27;\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u006f\u0072\u006c\u0064\u0021&#x27;</span>)</code></pre>
<p>观察 AST 结构：</p>
<p><img src="https://cdn.itbob.cn/img/article/051/15.png" alt="15"></p>
<p>我们发现 Unicode 编码对应的是 <code>raw</code>，而 <code>rawValue</code> 和 <code>value</code> 都是正常的，所以我们可以将 <code>raw</code> 替换成 <code>rawValue</code> 或 <code>value</code> 即可，需要注意的是引号的问题，本来是 <code>console[&quot;log&quot;]</code>，你还原后变成了 <code>console[log]</code>，自然会报错的，除了替换值以外，这里直接删除 extra 节点，或者删除 raw 值也是可以的，所以以下几种写法都可以还原代码：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);
<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default
<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default

<span class="hljs-keyword">const</span> code = <span class="hljs-string">`console[&#x27;\u006c\u006f\u0067&#x27;](&#x27;\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u006f\u0072\u006c\u0064\u0021&#x27;)`</span>
<span class="hljs-keyword">const</span> ast = parser.parse(code)

<span class="hljs-keyword">const</span> visitor = &#123;
    <span class="hljs-function"><span class="hljs-title">StringLiteral</span>(<span class="hljs-params">path</span>)</span> &#123;
        <span class="hljs-comment">// 以下方法均可</span>
        <span class="hljs-comment">// path.node.extra.raw = path.node.rawValue</span>
        <span class="hljs-comment">// path.node.extra.raw = &#x27;&quot;&#x27; + path.node.value + &#x27;&quot;&#x27;</span>
        <span class="hljs-comment">// delete path.node.extra</span>
        <span class="hljs-keyword">delete</span> path.node.extra.raw
    &#125;
&#125;

traverse(ast, visitor)
<span class="hljs-keyword">const</span> result = generate(ast)
<span class="hljs-built_in">console</span>.log(result.code)</code></pre>
<p>还原结果：</p>
<pre><code class="hljs javascript"><span class="hljs-built_in">console</span>[<span class="hljs-string">&quot;log&quot;</span>](<span class="hljs-string">&quot;Hello world!&quot;</span>);</code></pre>
<h3><span id="biao-da-shi-huan-yuan">表达式还原</span></h3>
<p>之前写过 <a target="_blank" rel="noopener" href="https://itrhx.blog.csdn.net/article/details/122057377">JSFuck 混淆的还原</a>，其中有介绍 <code>![]</code> 可表示 false，<code>!![]</code> 或者 <code>!+[]</code> 可表示 true，在一些混淆代码中，经常有这些操作，把简单的表达式复杂化，往往需要执行一下语句，才能得到真正的结果，示例代码如下：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = !![]+!![]+!![];
<span class="hljs-keyword">const</span> b = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">12.34</span> * <span class="hljs-number">2.12</span>)
<span class="hljs-keyword">const</span> c = <span class="hljs-number">10</span> &gt;&gt; <span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">1</span>
<span class="hljs-keyword">const</span> d = <span class="hljs-built_in">String</span>(<span class="hljs-number">21.3</span> + <span class="hljs-number">14</span> * <span class="hljs-number">1.32</span>)
<span class="hljs-keyword">const</span> e = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;1.893&quot;</span> + <span class="hljs-string">&quot;45.9088&quot;</span>)
<span class="hljs-keyword">const</span> f = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;23.2334&quot;</span> + <span class="hljs-string">&quot;21.89112&quot;</span>)
<span class="hljs-keyword">const</span> g = <span class="hljs-number">20</span> &lt; <span class="hljs-number">18</span> ? <span class="hljs-string">&#x27;未成年&#x27;</span> : <span class="hljs-string">&#x27;成年&#x27;</span></code></pre>
<p>想要执行语句，我们需要了解 <code>path.evaluate()</code> 方法，该方法会对 path 对象进行执行操作，自动计算出结果，返回一个对象，其中的 <code>confident</code> 属性表示置信度，<code>value</code> 表示计算结果，使用 <code>types.valueToNode()</code> 方法创建节点，使用 <code>path.replaceInline()</code> 方法将节点替换成计算结果生成的新节点，替换方法有一下几种：</p>
<ul>
<li><code>replaceWith</code>：用一个节点替换另一个节点；</li>
<li><code>replaceWithMultiple</code>：用多个节点替换另一个节点；</li>
<li><code>replaceWithSourceString</code>：将传入的源码字符串解析成对应 Node 后再替换，性能较差，不建议使用；</li>
<li><code>replaceInline</code>：用一个或多个节点替换另一个节点，相当于同时有了前两个函数的功能。</li>
</ul>
<p>对应的 AST 处理代码如下：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);
<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default
<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default
<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)

<span class="hljs-keyword">const</span> code = <span class="hljs-string">`</span>
<span class="hljs-string">const a = !![]+!![]+!![];</span>
<span class="hljs-string">const b = Math.floor(12.34 * 2.12)</span>
<span class="hljs-string">const c = 10 &gt;&gt; 3 &lt;&lt; 1</span>
<span class="hljs-string">const d = String(21.3 + 14 * 1.32)</span>
<span class="hljs-string">const e = parseInt(&quot;1.893&quot; + &quot;45.9088&quot;)</span>
<span class="hljs-string">const f = parseFloat(&quot;23.2334&quot; + &quot;21.89112&quot;)</span>
<span class="hljs-string">const g = 20 &lt; 18 ? &#x27;未成年&#x27; : &#x27;成年&#x27;</span>
<span class="hljs-string">`</span>
<span class="hljs-keyword">const</span> ast = parser.parse(code)

<span class="hljs-keyword">const</span> visitor = &#123;
    <span class="hljs-string">&quot;BinaryExpression|CallExpression|ConditionalExpression&quot;</span>(path) &#123;
        <span class="hljs-keyword">const</span> &#123;confident, value&#125; = path.evaluate()
        <span class="hljs-keyword">if</span> (confident)&#123;
            path.replaceInline(types.valueToNode(value))
        &#125;
    &#125;
&#125;

traverse(ast, visitor)
<span class="hljs-keyword">const</span> result = generate(ast)
<span class="hljs-built_in">console</span>.log(result.code)</code></pre>
<p>最终结果：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">3</span>;
<span class="hljs-keyword">const</span> b = <span class="hljs-number">26</span>;
<span class="hljs-keyword">const</span> c = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> d = <span class="hljs-string">&quot;39.78&quot;</span>;
<span class="hljs-keyword">const</span> e = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;1.89345.9088&quot;</span>);
<span class="hljs-keyword">const</span> f = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;23.233421.89112&quot;</span>);
<span class="hljs-keyword">const</span> g = <span class="hljs-string">&quot;\u6210\u5E74&quot;</span>;</code></pre>
<h3><span id="shan-chu-wei-shi-yong-bian-liang">删除未使用变量</span></h3>
<p>有时候代码里会有一些并没有使用到的多余变量，删除这些多余变量有助于更加高效的分析代码，示例代码如下：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> b = a * <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> c = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> d = b + <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> e = <span class="hljs-number">3</span>;
<span class="hljs-built_in">console</span>.log(d)</code></pre>
<p>删除多余变量，首先要了解 <code>NodePath</code> 中的 <code>scope</code>，<code>scope</code> 的作用主要是查找标识符的作用域、获取并修改标识符的所有引用等，删除未使用变量主要用到了 <code>scope.getBinding()</code> 方法，传入的值是当前节点能够引用到的标识符名称，返回的关键属性有以下几个：</p>
<ul>
<li><code>identifier</code>：标识符的 Node 对象；</li>
<li><code>path</code>：标识符的 NodePath 对象；</li>
<li><code>constant</code>：标识符是否为常量；</li>
<li><code>referenced</code>：标识符是否被引用；</li>
<li><code> references</code>：标识符被引用的次数；</li>
<li><code>constantViolations</code>：如果标识符被修改，则会存放所有修改该标识符节点的 Path 对象；</li>
<li><code>referencePaths</code>：如果标识符被引用，则会存放所有引用该标识符节点的 Path 对象。</li>
</ul>
<p>所以我们可以通过 <code>constantViolations</code>、<code>referenced</code>、<code>references</code>、<code>referencePaths</code> 多个参数来判断变量是否可以被删除，AST 处理代码如下：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);
<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default
<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default

<span class="hljs-keyword">const</span> code = <span class="hljs-string">`</span>
<span class="hljs-string">const a = 1;</span>
<span class="hljs-string">const b = a * 2;</span>
<span class="hljs-string">const c = 2;</span>
<span class="hljs-string">const d = b + 1;</span>
<span class="hljs-string">const e = 3;</span>
<span class="hljs-string">console.log(d)</span>
<span class="hljs-string">`</span>
<span class="hljs-keyword">const</span> ast = parser.parse(code)

<span class="hljs-keyword">const</span> visitor = &#123;
    <span class="hljs-function"><span class="hljs-title">VariableDeclarator</span>(<span class="hljs-params">path</span>)</span>&#123;
        <span class="hljs-keyword">const</span> binding = path.scope.getBinding(path.node.id.name);

        <span class="hljs-comment">// 如标识符被修改过，则不能进行删除动作。</span>
        <span class="hljs-keyword">if</span> (!binding || binding.constantViolations.length &gt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;

        <span class="hljs-comment">// 未被引用</span>
        <span class="hljs-keyword">if</span> (!binding.referenced) &#123;
            path.remove();
        &#125;

        <span class="hljs-comment">// 被引用次数为0</span>
        <span class="hljs-comment">// if (binding.references === 0) &#123;</span>
        <span class="hljs-comment">//     path.remove();</span>
        <span class="hljs-comment">// &#125;</span>

        <span class="hljs-comment">// 长度为0，变量没有被引用过</span>
        <span class="hljs-comment">// if (binding.referencePaths.length === 0) &#123;</span>
        <span class="hljs-comment">//     path.remove();</span>
        <span class="hljs-comment">// &#125;</span>
    &#125;
&#125;

traverse(ast, visitor)
<span class="hljs-keyword">const</span> result = generate(ast)
<span class="hljs-built_in">console</span>.log(result.code)</code></pre>
<p>处理后的代码（未使用的 b、c、e 变量已被删除）：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> b = a * <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> d = b + <span class="hljs-number">1</span>;
<span class="hljs-built_in">console</span>.log(d);</code></pre>
<h3><span id="shan-chu-rong-yu-luo-ji-dai-ma">删除冗余逻辑代码</span></h3>
<p>有时候为了增加逆向难度，会有很多嵌套的 if-else 语句，大量判断为假的冗余逻辑代码，同样可以利用 AST 将其删除掉，只留下判断为真的，示例代码如下：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> example = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">let</span> a;
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;
        a = <span class="hljs-number">1</span>;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) &#123;
            a = <span class="hljs-number">2</span>;
        &#125;
        <span class="hljs-keyword">else</span> &#123;
            a = <span class="hljs-number">3</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> a;
&#125;;</code></pre>
<p>观察 AST，判断条件对应的是 <code>test</code> 节点，if 对应的是 <code>consequent</code> 节点，else 对应的是 <code>alternate</code> 节点，如下图所示：</p>
<p><img src="https://cdn.itbob.cn/img/article/051/16.png" alt="16"></p>
<p>AST 处理思路以及代码：</p>
<ol>
<li>筛选出 <code>BooleanLiteral</code> 和 <code>NumericLiteral</code> 节点，取其对应的值，即 <code>path.node.test.value</code>；</li>
<li>判断 <code>value</code> 值为真，则将节点替换成 <code>consequent</code> 节点下的内容，即 <code>path.node.consequent.body</code>；</li>
<li>判断 <code>value</code> 值为假，则替换成 <code>alternate</code> 节点下的内容，即 <code>path.node.alternate.body</code>；</li>
<li>有的 if 语句可能没有写 else，也就没有 <code>alternate</code>，所以这种情况下判断 <code>value</code> 值为假，则直接移除该节点，即 <code>path.remove()</code></li>
</ol>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);
<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default
<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default
<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/types&#x27;</span>);

<span class="hljs-keyword">const</span> code = <span class="hljs-string">`</span>
<span class="hljs-string">const example = function () &#123;</span>
<span class="hljs-string">    let a;</span>
<span class="hljs-string">    if (false) &#123;</span>
<span class="hljs-string">        a = 1;</span>
<span class="hljs-string">    &#125; else &#123;</span>
<span class="hljs-string">        if (1) &#123;</span>
<span class="hljs-string">            a = 2;</span>
<span class="hljs-string">        &#125;</span>
<span class="hljs-string">        else &#123;</span>
<span class="hljs-string">            a = 3;</span>
<span class="hljs-string">        &#125;</span>
<span class="hljs-string">    &#125;</span>
<span class="hljs-string">    return a;</span>
<span class="hljs-string">&#125;;</span>
<span class="hljs-string">`</span>
<span class="hljs-keyword">const</span> ast = parser.parse(code)

<span class="hljs-keyword">const</span> visitor = &#123;
    <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (types.isBooleanLiteral(path.node.test) || types.isNumericLiteral(path.node.test)) &#123;
            <span class="hljs-keyword">if</span> (path.node.test.value) &#123;
                path.replaceInline(path.node.consequent.body);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">if</span> (path.node.alternate) &#123;
                    path.replaceInline(path.node.alternate.body);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    path.remove()
                &#125;
            &#125;
        &#125;
    &#125;
&#125;

traverse(ast, visitor)
<span class="hljs-keyword">const</span> result = generate(ast)
<span class="hljs-built_in">console</span>.log(result.code)</code></pre>
<p>处理结果：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> example = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">let</span> a;
  a = <span class="hljs-number">2</span>;
  <span class="hljs-keyword">return</span> a;
&#125;;</code></pre>
<h3><span id="switch-case-fan-kong-zhi-liu-ping-tan-hua">switch-case 反控制流平坦化</span></h3>
<p>控制流平坦化是混淆当中最常见的，通过 <code>if-else</code> 或者 <code>while-switch-case</code> 语句分解步骤，示例代码：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> _0x34e16a = <span class="hljs-string">&#x27;3,4,0,5,1,2&#x27;</span>[<span class="hljs-string">&#x27;split&#x27;</span>](<span class="hljs-string">&#x27;,&#x27;</span>);
<span class="hljs-keyword">let</span> _0x2eff02 = <span class="hljs-number">0x0</span>;
<span class="hljs-keyword">while</span> (!![]) &#123;
    <span class="hljs-keyword">switch</span> (_0x34e16a[_0x2eff02++]) &#123;
        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;0&#x27;</span>:
            <span class="hljs-keyword">let</span> _0x38cb15 = _0x4588f1 + _0x470e97;
            <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;1&#x27;</span>:
            <span class="hljs-keyword">let</span> _0x1e0e5e = _0x37b9f3[_0x50cee0(<span class="hljs-number">0x2e0</span>, <span class="hljs-number">0x2e8</span>, <span class="hljs-number">0x2e1</span>, <span class="hljs-number">0x2e4</span>)];
            <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;2&#x27;</span>:
            <span class="hljs-keyword">let</span> _0x35d732 = [_0x388d4b(-<span class="hljs-number">0x134</span>, -<span class="hljs-number">0x134</span>, -<span class="hljs-number">0x139</span>, -<span class="hljs-number">0x138</span>)](_0x38cb15 &gt;&gt; _0x4588f1);
            <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;3&#x27;</span>:
            <span class="hljs-keyword">let</span> _0x4588f1 = <span class="hljs-number">0x1</span>;
            <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;4&#x27;</span>:
            <span class="hljs-keyword">let</span> _0x470e97 = <span class="hljs-number">0x2</span>;
            <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;5&#x27;</span>:
            <span class="hljs-keyword">let</span> _0x37b9f3 = <span class="hljs-number">0x5</span> || _0x38cb15;
            <span class="hljs-keyword">continue</span>;
    &#125;
    <span class="hljs-keyword">break</span>;
&#125;</code></pre>
<p>AST 还原思路：</p>
<ol>
<li>获取控制流原始数组，将 <code>'3,4,0,5,1,2'['split'](',')</code> 之类的语句转化成 <code>['3','4','0','5','1','2']</code> 之类的数组，得到该数组之后，也可以选择把 split 语句对应的节点删除掉，因为最终代码里这条语句就没用了；</li>
<li>遍历第一步得到的控制流数组，依次取出每个值所对应的 case 节点；</li>
<li>定义一个数组，储存每个 case 节点 <code>consequent</code> 数组里面的内容，并删除 <code>continue</code> 语句对应的节点；</li>
<li>遍历完成后，将第三步的数组替换掉整个 while 节点，也就是 <code>WhileStatement</code>。</li>
</ol>
<p>不同思路，写法多样，对于如何获取控制流数组，可以有以下思路：</p>
<ol>
<li>获取到 <code>While</code> 语句节点，然后使用 <code>path.getAllPrevSiblings()</code> 方法获取其前面的所有兄弟节点，遍历每个兄弟节点，找到与 <code>switch()</code> 里面数组的变量名相同的节点，然后再取节点的值进行后续处理；</li>
<li>直接取 <code>switch()</code> 里面数组的变量名，然后使用 <code>scope.getBinding()</code> 方法获取到它绑定的节点，然后再取这个节点的值进行后续处理。</li>
</ol>
<p>所以 AST 处理代码就有两种写法，方法一：（code.js 即为前面的示例代码，为了方便操作，这里使用 fs 从文件中读取代码）</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);
<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default
<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default
<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);

<span class="hljs-keyword">const</span> code = fs.readFileSync(<span class="hljs-string">&quot;code.js&quot;</span>, &#123;<span class="hljs-attr">encoding</span>: <span class="hljs-string">&quot;utf-8&quot;</span>&#125;);
<span class="hljs-keyword">const</span> ast = parser.parse(code)

<span class="hljs-keyword">const</span> visitor = &#123;
    <span class="hljs-function"><span class="hljs-title">WhileStatement</span>(<span class="hljs-params">path</span>)</span> &#123;
        <span class="hljs-comment">// switch 节点</span>
        <span class="hljs-keyword">let</span> switchNode = path.node.body.body[<span class="hljs-number">0</span>];
        <span class="hljs-comment">// switch 语句内的控制流数组名，本例中是 _0x34e16a</span>
        <span class="hljs-keyword">let</span> arrayName = switchNode.discriminant.object.name;
        <span class="hljs-comment">// 获得所有 while 前面的兄弟节点，本例中获取到的是声明两个变量的节点，即 const _0x34e16a 和 let _0x2eff02</span>
        <span class="hljs-keyword">let</span> prevSiblings = path.getAllPrevSiblings();
        <span class="hljs-comment">// 定义缓存控制流数组</span>
        <span class="hljs-keyword">let</span> array = []
        <span class="hljs-comment">// forEach 方法遍历所有节点</span>
        prevSiblings.forEach(<span class="hljs-function"><span class="hljs-params">pervNode</span> =&gt;</span> &#123;
            <span class="hljs-keyword">let</span> &#123;id, init&#125; = pervNode.node.declarations[<span class="hljs-number">0</span>];
            <span class="hljs-comment">// 如果节点 id.name 与 switch 语句内的控制流数组名相同</span>
            <span class="hljs-keyword">if</span> (arrayName === id.name) &#123;
                <span class="hljs-comment">// 获取节点整个表达式的参数、分割方法、分隔符</span>
                <span class="hljs-keyword">let</span> object = init.callee.object.value;
                <span class="hljs-keyword">let</span> property = init.callee.property.value;
                <span class="hljs-keyword">let</span> argument = init.arguments[<span class="hljs-number">0</span>].value;
                <span class="hljs-comment">// 模拟执行 &#x27;3,4,0,5,1,2&#x27;[&#x27;split&#x27;](&#x27;,&#x27;) 语句</span>
                array = object[property](argument)
                <span class="hljs-comment">// 也可以直接取参数进行分割，方法不通用，比如分隔符换成 | 就不行了</span>
                <span class="hljs-comment">// array = init.callee.object.value.split(&#x27;,&#x27;);</span>
            &#125;
            <span class="hljs-comment">// 前面的兄弟节点就可以删除了</span>
            pervNode.remove();
        &#125;);

        <span class="hljs-comment">// 储存正确顺序的控制流语句</span>
        <span class="hljs-keyword">let</span> replace = [];
        <span class="hljs-comment">// 遍历控制流数组，按正确顺序取 case 内容</span>
        array.forEach(<span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;
                <span class="hljs-keyword">let</span> consequent = switchNode.cases[index].consequent;
                <span class="hljs-comment">// 如果最后一个节点是 continue 语句，则删除 ContinueStatement 节点</span>
                <span class="hljs-keyword">if</span> (types.isContinueStatement(consequent[consequent.length - <span class="hljs-number">1</span>])) &#123;
                    consequent.pop();
                &#125;
                <span class="hljs-comment">// concat 方法拼接多个数组，即正确顺序的 case 内容</span>
                replace = replace.concat(consequent);
            &#125;
        );
        <span class="hljs-comment">// 替换整个 while 节点，两种方法都可以</span>
        path.replaceWithMultiple(replace);
        <span class="hljs-comment">// path.replaceInline(replace);</span>
    &#125;
&#125;

traverse(ast, visitor)
<span class="hljs-keyword">const</span> result = generate(ast)
<span class="hljs-built_in">console</span>.log(result.code)</code></pre>
<p>方法二：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);
<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default
<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default
<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);

<span class="hljs-keyword">const</span> code = fs.readFileSync(<span class="hljs-string">&quot;code.js&quot;</span>, &#123;<span class="hljs-attr">encoding</span>: <span class="hljs-string">&quot;utf-8&quot;</span>&#125;);
<span class="hljs-keyword">const</span> ast = parser.parse(code)

<span class="hljs-keyword">const</span> visitor = &#123;
    <span class="hljs-function"><span class="hljs-title">WhileStatement</span>(<span class="hljs-params">path</span>)</span> &#123;
        <span class="hljs-comment">// switch 节点</span>
        <span class="hljs-keyword">let</span> switchNode = path.node.body.body[<span class="hljs-number">0</span>];
        <span class="hljs-comment">// switch 语句内的控制流数组名，本例中是 _0x34e16a</span>
        <span class="hljs-keyword">let</span> arrayName = switchNode.discriminant.object.name;
        <span class="hljs-comment">// 获取控制流数组绑定的节点</span>
        <span class="hljs-keyword">let</span> bindingArray = path.scope.getBinding(arrayName);
        <span class="hljs-comment">// 获取节点整个表达式的参数、分割方法、分隔符</span>
        <span class="hljs-keyword">let</span> init = bindingArray.path.node.init;
        <span class="hljs-keyword">let</span> object = init.callee.object.value;
        <span class="hljs-keyword">let</span> property = init.callee.property.value;
        <span class="hljs-keyword">let</span> argument = init.arguments[<span class="hljs-number">0</span>].value;
        <span class="hljs-comment">// 模拟执行 &#x27;3,4,0,5,1,2&#x27;[&#x27;split&#x27;](&#x27;,&#x27;) 语句</span>
        <span class="hljs-keyword">let</span> array = object[property](argument)
        <span class="hljs-comment">// 也可以直接取参数进行分割，方法不通用，比如分隔符换成 | 就不行了</span>
        <span class="hljs-comment">// let array = init.callee.object.value.split(&#x27;,&#x27;);</span>

        <span class="hljs-comment">// switch 语句内的控制流自增变量名，本例中是 _0x2eff02</span>
        <span class="hljs-keyword">let</span> autoIncrementName = switchNode.discriminant.property.argument.name;
        <span class="hljs-comment">// 获取控制流自增变量名绑定的节点</span>
        <span class="hljs-keyword">let</span> bindingAutoIncrement = path.scope.getBinding(autoIncrementName);
        <span class="hljs-comment">// 可选择的操作：删除控制流数组绑定的节点、自增变量名绑定的节点</span>
        bindingArray.path.remove();
        bindingAutoIncrement.path.remove();

        <span class="hljs-comment">// 储存正确顺序的控制流语句</span>
        <span class="hljs-keyword">let</span> replace = [];
        <span class="hljs-comment">// 遍历控制流数组，按正确顺序取 case 内容</span>
        array.forEach(<span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;
                <span class="hljs-keyword">let</span> consequent = switchNode.cases[index].consequent;
                <span class="hljs-comment">// 如果最后一个节点是 continue 语句，则删除 ContinueStatement 节点</span>
                <span class="hljs-keyword">if</span> (types.isContinueStatement(consequent[consequent.length - <span class="hljs-number">1</span>])) &#123;
                    consequent.pop();
                &#125;
                <span class="hljs-comment">// concat 方法拼接多个数组，即正确顺序的 case 内容</span>
                replace = replace.concat(consequent);
            &#125;
        );
        <span class="hljs-comment">// 替换整个 while 节点，两种方法都可以</span>
        path.replaceWithMultiple(replace);
        <span class="hljs-comment">// path.replaceInline(replace);</span>
    &#125;
&#125;

traverse(ast, visitor)
<span class="hljs-keyword">const</span> result = generate(ast)
<span class="hljs-built_in">console</span>.log(result.code)</code></pre>
<p>以上代码运行后，原来的 <code>switch-case</code> 控制流就被还原了，变成了按顺序一行一行的代码，更加简洁明了：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">let</span> _0x4588f1 = <span class="hljs-number">0x1</span>;
<span class="hljs-keyword">let</span> _0x470e97 = <span class="hljs-number">0x2</span>;
<span class="hljs-keyword">let</span> _0x38cb15 = _0x4588f1 + _0x470e97;
<span class="hljs-keyword">let</span> _0x37b9f3 = <span class="hljs-number">0x5</span> || _0x38cb15;
<span class="hljs-keyword">let</span> _0x1e0e5e = _0x37b9f3[_0x50cee0(<span class="hljs-number">0x2e0</span>, <span class="hljs-number">0x2e8</span>, <span class="hljs-number">0x2e1</span>, <span class="hljs-number">0x2e4</span>)];
<span class="hljs-keyword">let</span> _0x35d732 = [_0x388d4b(-<span class="hljs-number">0x134</span>, -<span class="hljs-number">0x134</span>, -<span class="hljs-number">0x139</span>, -<span class="hljs-number">0x138</span>)](_0x38cb15 &gt;&gt; _0x4588f1);</code></pre>
<h2><span id="can-kao-zi-liao">参考资料</span></h2>
<p>本文有参考以下资料，也是比较推荐的在线学习资料：</p>
<ul>
<li>Youtube 视频，Babel 入门：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=UeVq_U5obnE">https://www.youtube.com/watch?v=UeVq_U5obnE</a></li>
<li>官方手册 Babel Handbook：<a target="_blank" rel="noopener" href="https://github.com/jamiebuilds/babel-handbook">https://github.com/jamiebuilds/babel-handbook</a></li>
<li>非官方 Babel API 中文文档：<a target="_blank" rel="noopener" href="https://evilrecluse.top/Babel-traverse-api-doc/">https://evilrecluse.top/Babel-traverse-api-doc/</a></li>
</ul>
<h2><span id="end">END</span></h2>
<p>Babel 编译器国内的资料其实不是很多，多看源码、同时在线对照可视化的 AST 语法树，耐心一点儿一层一层分析即可，本文中的案例也只是最基本操作，实际遇到一些混淆还得视情况进行修改，比如需要加一些类型判断来限制等，后续会用实战来带领大家进一步熟悉解混淆当中的其他操作。</p>

            </div>
        </article>
    </div>
    <br>
    
        <div class="next-prev-post">
            
                <div class="prev-post">
                    <div class="prev gt-c-content-color-first">
                        上一篇：<a href="/article/052/" 
                            class="post-title gt-a-link">AST 脱混淆实战，某 ICP 备案号查询接口 jsjiami v6 分析</a>
                    </div>
                </div>
            
            
                <div class="next-post">
                    <div class="next gt-c-content-color-first">
                        下一篇：<a href="/article/050/" 
                            class="post-title gt-a-link">网洛者反爬练习平台第七题：JSVMPZL 初体验</a>
                    </div>
                </div>
            
        </div>
    
    

    
    <script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.18.0/js/md5.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script>

    <div id="gitalk-container"></div>

    <script>
    var gitalk = new Gitalk({
        clientID: 'd19a84b9d9a2ddb2c6b9',
        clientSecret: 'cec9feae5129a6106edc68ce06d167be8eb06021',
        repo: 'trhx.github.io',
        owner: 'TRHX',
        admin: ['TRHX'],
        id: md5(location.pathname),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false       // Facebook-like distraction free mode
    });
    gitalk.render('gitalk-container');
    </script>


    
</div>

                <div class="site-footer gt-c-content-color-first">
    <div class="footer-main">
        <!-- 建议保留版权信息或者添加主题信息到友链，感谢您的理解 -->
        <!-- 文件位置：layout/_includes/footer.ejs -->
        <!-- <span style="text-align: right; float: right;">
            Theme 
            <a href="https://github.com/renbaoshuo/hexo-theme-pure" target="_blank">Pure</a>
             | Powered by
            <a href="https://hexo.io" target="_blank">Hexo</a>
        </span>
        <span style="text-align: left;"></span> -->
        <span>
            <div class="itbob-github-badge">
                <span class="badge-subject">
                    <i class="fas fa-user"></i> UV
                </span>
                <span class="badge-value bg-pink" id="busuanzi_value_site_uv"></span>
            </div>
            <div class="itbob-github-badge">
                <span class="badge-subject">
                    <i class="fas fa-user-plus"></i> PV
                </span>
                <span class="badge-value bg-blue" id="busuanzi_value_site_pv"></span>
            </div>
            <div class="itbob-github-badge">
                <span class="badge-subject">
                    <i class="fa fa-keyboard"></i> Word Count
                </span>
                <span class="badge-value bg-firebrick post-count">296.8k</span>
            </div>
            <div class="itbob-github-badge">
                <span class="badge-subject">
                    <i class="fa fa-cog fa-spin"></i> Powered by
                </span>
                <span class="badge-value bg-brightgreen"><a href="https://hexo.io" target="_blank">Hexo</a></span>
            </div>
            <div class="itbob-github-badge">
                <span class="badge-subject">
                    <i class="fa fa-paper-plane"></i> Theme
                </span>
                <span class="badge-value bg-orange"><a href="https://github.com/renbaoshuo/hexo-theme-pure" target="_blank">Pure</a></span>
            </div>
        </span>
        <br/>
        <br/>

        <span style="text-align: center; float: center;">
            Copyright <i class="fa fa-copyright"></i> 2018 - <script>document.write(new Date().getFullYear());</script> <a href="https://www.itbob.cn/" target="_blank">ITBOB.CN</a> 丨
            <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">
                <i class="fab fa-creative-commons"></i>
                <i class="fab fa-creative-commons-by"></i>
                <i class="fab fa-creative-commons-nc"></i>
                <i class="fab fa-creative-commons-nd"></i>
            </a> 丨
            <!-- <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a> 丨 -->
            <span id="sitetime">正在载入网站运行时间...</span>
            <script>
                function siteTime(){
                    window.setTimeout("siteTime()", 1000);
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth()+1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    /* 
                    Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
                    year - 作为date对象的年份，为4位年份值
                    month - 0-11之间的整数，做为date对象的月份
                    day - 1-31之间的整数，做为date对象的天数
                    hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
                    minutes - 0-59之间的整数，做为date对象的分钟数
                    seconds - 0-59之间的整数，做为date对象的秒数
                    microseconds - 0-999之间的整数，做为date对象的毫秒数
                    */
                    var t1 = Date.UTC(2018,08,10,17,38,00); //北京时间2018-8-10 17:38:00
                    var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
                    var diff = t2-t1;
                    var diffYears = Math.floor(diff/years);
                    var diffDays = Math.floor((diff/days)-diffYears*365);
                    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
                    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
                    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
                    document.getElementById("sitetime").innerHTML="小破站已运行了 "
                    + "<font style='color:#FE3C65;font-weight:bold'>" + diffYears + "</font>" + " 年 "
                    + "<font style='color:#FFA500;font-weight:bold'>" + diffDays + "</font>" + " 天 "
                    + "<font style='color:#1DBF97;font-weight:bold'>" + diffHours + "</font>" + " 小时 "
                    + "<font style='color:#8A2BE2;font-weight:bold'>" + diffMinutes + "</font>" + " 分 "
                    + "<font style='color:#007EC6;font-weight:bold'>" + diffSeconds + "</font>" + " 秒 ";
                }
                siteTime();
            </script>
        </span>
        <br/>
        <br/>
        <span>
            <img src="https://cdn.itbob.cn/img/footer/icp.png" class="nofancybox" alt="ICP" style="width:auto; height:20px; margin-bottom:-4px"><a href="https://beian.miit.gov.cn/" target="_blank"> 鄂ICP备19003281号-7</a>丨
            <img src="https://cdn.itbob.cn/img/footer/moeicp.png" class="nofancybox" alt="MOE ICP" style="width:auto; height:18px; margin-bottom:-3.5px"><a href="https://icp.gov.moe/" target="_blank"> 萌ICP备20202022号</a>丨
            <img src="https://cdn.itbob.cn/img/footer/webify.png" class="nofancybox" alt="腾讯云开发 Webify" style="width:auto; height:25px; margin-bottom:-8px"><a href="https://webify.cloudbase.net/" target="_blank"> 云开发 Webify</a>丨
            <a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="https://cdn.itbob.cn/img/footer/upyun.png" class="nofancybox" alt="又拍云赞助云存储" style="width:auto; height:19px; margin-bottom:-4px"></a> 赞助CDN/COS服务丨
            <a href="https://www.foreverblog.cn/" target="_blank"><img src="https://cdn.itbob.cn/img/footer/foreverblog.png" class="nofancybox" alt="十年之约" style="width:auto; height:15px; margin-bottom:-2px"></a>
        </span>
    </div>
</div>

<!-- <div class="sidebar_wo" id="leimu">
    <img src="https://cdn.itbob.cn/img/footer/leimuA.png" class="nofancybox" alt="雷姆" 
    onmouseover="this.src='https://cdn.itbob.cn/img/footer/leimuB.png'" 
    onmouseout="this.src='https://cdn.itbob.cn/img/footer/leimuA.png'" title="回到底部">
</div>
<div class="sidebar_wo" id="lamu">
    <img src="https://cdn.itbob.cn/img/footer/lamuA.png" class="nofancybox" alt="雷姆" 
    onmouseover="this.src='https://cdn.itbob.cn/img/footer/lamuB.png'" 
    onmouseout="this.src='https://cdn.itbob.cn/img/footer/lamuA.png'" title="回到顶部">
</div> -->

<script>
    /* 拉姆蕾姆回到顶部或底部按钮 */
    $(function() {
        $("#leimu img").eq(0).click(function() {
            $("html,body").animate({scrollTop:$(document).height()},800);
            return false;
        });
        $("#lamu img").eq(0).click(function() {
            $("html,body").animate({scrollTop:0},800);
            return false;
        });
    });
</script>

            </div>
        </div>
        <!-- <a id="back-to-top" class="back-to-top show hl fa fa-arrow-up" href="javascript:void(0)" title="回到顶部"></a> -->
        <a id="back-to-top" class="back-to-top2" href="javascript:void(0)" title="回到顶部">
            <img class="nofancybox" src="https://cdn.itbob.cn/img/back_to_top.png"/>
        </a>
        <script>
            (function () {
                // When to show the scroll link
                // higher number = scroll link appears further down the page   
                var upperLimit = 100;
                
                // Our scroll link element
                var scrollElem = $('#back-to-top');
            
                // Scroll to top speed
                var scrollSpeed = 500;
            
                // Show and hide the scroll to top link based on scroll position   
                scrollElem.hide();
                $(window).scroll(function () {            
                    var scrollTop = $(document).scrollTop();       
                    if ( scrollTop > upperLimit ) {
                        $(scrollElem).stop().fadeTo(200, 1); // fade back in           
                    }else{       
                        $(scrollElem).stop().fadeTo(200, 0); // fade out
                    }
                });

                // Scroll to top animation on click
                $(scrollElem).click(function(){
                    $('html, body').animate({scrollTop:0}, scrollSpeed); return false;
                });
            })();
        </script>
    </body>
</html>