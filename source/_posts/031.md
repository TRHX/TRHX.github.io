---
layout: post
title: Python 数据分析三剑客之 Pandas（七）：合并数据集
date: 2020.06.21 20:58:52
updated: 2022.05.22 20:42:00
tags:
  - Pandas
  - 数据分析
categories: 数据分析
mathjax: true
feature: https://cdn.itbob.cn/img/thumbnail/pandas.png
---

Pandas 系列文章：

- [Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象](https://www.itbob.cn/article/025/)
- [Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作](https://www.itbob.cn/article/026/)
- [Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理](https://www.itbob.cn/article/027/)
- [Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引](https://www.itbob.cn/article/028/)
- [Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述](https://www.itbob.cn/article/029/)
- [Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并](https://www.itbob.cn/article/030/)
- [Python 数据分析三剑客之 Pandas（七）：合并数据集](https://www.itbob.cn/article/031/)
- [Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换](https://www.itbob.cn/article/032/)
- [Python 数据分析三剑客之 Pandas（九）：时间序列](https://www.itbob.cn/article/033/)
- [Python 数据分析三剑客之 Pandas（十）：数据读写](https://www.itbob.cn/article/034/)

---

专栏：

- NumPy 专栏：https://itrhx.blog.csdn.net/category_9780393.html
- Pandas 专栏：https://itrhx.blog.csdn.net/category_9780397.html
- Matplotlib 专栏：https://itrhx.blog.csdn.net/category_9780418.html

推荐学习资料与网站：

- NumPy 官方中文网：https://www.numpy.org.cn/
- Pandas 官方中文网：https://www.pypandas.cn/
- Matplotlib 官方中文网：https://www.matplotlib.org.cn/
- NumPy、Matplotlib、Pandas 速查表：https://github.com/TRHX/Python-quick-reference-table

---

```yaml
这里是一段防爬虫文本，请读者忽略。
本文原创首发于 CSDN，作者 TRHX。
博客首页：https://itrhx.blog.csdn.net/
本文链接：https://itrhx.blog.csdn.net/article/details/106830112
未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！
```

---

## <font color=#FF0000>【01x00】concat</font>

`pandas.concat` 可以沿着指定轴将多个对象堆叠到一起。

官方文档：[https://pandas.pydata.org/docs/reference/api/pandas.concat.html](https://pandas.pydata.org/docs/reference/api/pandas.concat.html)

基本语法：

```python
pandas.concat(objs: Union[Iterable[‘DataFrame’], Mapping[Optional[Hashable], ‘DataFrame’]],
			  axis='0',
			  join: str = "'outer'",
			  ignore_index: bool = 'False',
			  keys='None',
			  levels='None',
			  names='None',
			  verify_integrity: bool = 'False',
			  sort: bool = 'False',
			  copy: bool = 'True') → ’DataFrame’
```

```python
pandas.concat(objs: Union[Iterable[FrameOrSeriesUnion], Mapping[Optional[Hashable], FrameOrSeriesUnion]],
			  axis='0',
			  join: str = "'outer'",
			  ignore_index: bool = 'False',
			  keys='None',
			  levels='None',
			  names='None',
			  verify_integrity: bool = 'False',
			  sort: bool = 'False',
			  copy: bool = 'True') → FrameOrSeriesUnion
```

常用参数描述：

|  参数  |  描述  |
|  ------  |  ------  |
|  objs  |  Series 或 DataFrame 对象的序列或映射，要合并的对象  |
|  axis  |  沿指定轴合并，`0` or `‘index’`，`1` or `‘columns’`，只有在 DataFrame 中才有 `1` or `'columns’`  |
|  join  |  如何处理其他轴（或多个轴）上的索引，可取值：`‘inner’`，`‘outer’`（默认值）<br>`‘outer’`：当 axis = 0 时，列名相同的列会合并，其余列都保留（并集），空值填充；<br>`‘inner’`：当 axis = 0 时，列名相同的列会合并，其余列都舍弃（交集）  |
|  ignore_index  |  bool 类型，连接后的值是否使用原索引值，如果为 True，则索引将会是 0, 1, ..., n-1 |
|  keys  |  序列形式，默认 None，传递 keys 后，会构造一个层次索引，即 MultiIndex 对象，keys 为最外层索引  |
|  levels  |  用于构造 MultiIndex 的特定级别（唯一值）。未指定则将从键中推断出来  |
|  names  |  列表类型，为索引添加标签  |
|  verify_integrity  |  bool 类型，是否检查合并后的索引有无重复项，设置为 `True` 若有重复项则会报错  |
|  sort  |  当 `join='outer'` 时对列索引进行排序。当 `join='inner'` 时此操作无效  |

合并两个 Series 对象：

```python
>>> import pandas as pd
>>> obj1 = pd.Series(['a', 'b'])
>>> obj2 = pd.Series(['c', 'd'])
>>> pd.concat([obj1, obj2])
0    a
1    b
0    c
1    d
dtype: object
```

设置 `ignore_index=True`，放弃原有的索引值：

```python
>>> import pandas as pd
>>> obj1 = pd.Series(['a', 'b'])
>>> obj2 = pd.Series(['c', 'd'])
>>> pd.concat([obj1, obj2], ignore_index=True)
0    a
1    b
2    c
3    d
dtype: object
```

设置 `keys` 参数，添加最外层的索引：

```python
>>> import pandas as pd
>>> obj1 = pd.Series(['a', 'b'])
>>> obj2 = pd.Series(['c', 'd'])
>>> pd.concat([obj1, obj2], keys=['s1', 's2'])
s1  0    a
    1    b
s2  0    c
    1    d
dtype: object
```

设置 `names` 参数，为索引添加标签：

```python
>>> import pandas as pd
>>> obj1 = pd.Series(['a', 'b'])
>>> obj2 = pd.Series(['c', 'd'])
>>> pd.concat([obj1, obj2], keys=['s1', 's2'], names=['Series name', 'Row ID'])
Series name  Row ID
s1           0         a
             1         b
s2           0         c
             1         d
dtype: object
```

合并 `DataFrame` 对象：

```python
>>> import pandas as pd
>>> obj1 = pd.DataFrame([['a', 1], ['b', 2]], columns=['letter', 'number'])
>>> obj2 = pd.DataFrame([['c', 3], ['d', 4]], columns=['letter', 'number'])
>>> obj1
  letter  number
0      a       1
1      b       2
>>> 
>>> obj2
  letter  number
0      c       3
1      d       4
>>> 
>>> pd.concat([obj1, obj2])
  letter  number
0      a       1
1      b       2
0      c       3
1      d       4
```

合并 `DataFrame` 对象，不存在的值将会被 NaN 填充：

```python
>>> import pandas as pd
>>> obj1 = pd.DataFrame([['a', 1], ['b', 2]], columns=['letter', 'number'])
>>> obj2 = pd.DataFrame([['c', 3, 'cat'], ['d', 4, 'dog']], columns=['letter', 'number', 'animal'])
>>> obj1
  letter  number
0      a       1
1      b       2
>>> 
>>> obj2
  letter  number animal
0      c       3    cat
1      d       4    dog
>>> 
>>> pd.concat([obj1, obj2])
  letter  number animal
0      a       1    NaN
1      b       2    NaN
0      c       3    cat
1      d       4    dog
```

合并 `DataFrame` 对象，设置 `join="inner"` 不存在的列将会舍弃：

```python
>>> import pandas as pd
>>> obj1 = pd.DataFrame([['a', 1], ['b', 2]], columns=['letter', 'number'])
>>> obj2 = pd.DataFrame([['c', 3, 'cat'], ['d', 4, 'dog']], columns=['letter', 'number', 'animal'])
>>> obj1
  letter  number
0      a       1
1      b       2
>>> 
>>> obj2
  letter  number animal
0      c       3    cat
1      d       4    dog
>>> 
>>> pd.concat([obj1, obj2], join="inner")
  letter  number
0      a       1
1      b       2
0      c       3
1      d       4
```

合并 `DataFrame` 对象，设置 `axis=1` 沿 y 轴合并（增加列）：

```python
>>> import pandas as pd
>>> obj1 = pd.DataFrame([['a', 1], ['b', 2]], columns=['letter', 'number'])
>>> obj2 = pd.DataFrame([['bird', 'polly'], ['monkey', 'george']], columns=['animal', 'name'])
>>> obj1
  letter  number
0      a       1
1      b       2
>>> 
>>> obj2
   animal    name
0    bird   polly
1  monkey  george
>>> 
>>> pd.concat([obj1, obj2], axis=1)
  letter  number  animal    name
0      a       1    bird   polly
1      b       2  monkey  george
```

设置 `verify_integrity=True` ，检查新的索引是否有重复项，有重复项会报错：

```python
>>> import pandas as pd
>>> obj1 = pd.DataFrame([1], index=['a'])
>>> obj2 = pd.DataFrame([2], index=['a'])
>>> obj1
   0
a  1
>>> 
>>> obj2
   0
a  2
>>> 
>>> pd.concat([obj1, obj2], verify_integrity=True)
Traceback (most recent call last):
    ...
ValueError: Indexes have overlapping values: ['a']
```

设置 `sort=True`，会对列索引进行排序输出：

```python
>>> obj1 = pd.DataFrame([['a', 3], ['d', 2]], columns=['letter', 'number'])
>>> obj2 = pd.DataFrame([['c', 1, 'cat'], ['b', 4, 'dog']], columns=['letter', 'number', 'animal'])
>>> obj1
  letter  number
0      a       3
1      d       2
>>> 
>>> obj2
  letter  number animal
0      c       1    cat
1      b       4    dog
>>> 
>>> pd.concat([obj1, obj2], sort=True)
  animal letter  number
0    NaN      a       3
1    NaN      d       2
0    cat      c       1
1    dog      b       4
```

## <font color=#FF0000>【02x00】append</font>

Append 方法事实上是在一个 Series / DataFrame 对象后最追加另一个 Series / DataFrame 对象并返回一个新对象，不改变原对象的值。

基本语法：

- `Series.append(self, to_append, ignore_index=False, verify_integrity=False)`

- `DataFrame.append(self, other, ignore_index=False, verify_integrity=False, sort=False)`

官方文档：

- [https://pandas.pydata.org/docs/reference/api/pandas.Series.append.html](https://pandas.pydata.org/docs/reference/api/pandas.Series.append.html)

- [https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.append.html](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.append.html)

参数描述：

|  参数  |  描述  |
|  ------  |  ------  |
|  to_append / other  |  要追加的数据  |
|  ignore_index  |  bool 类型，连接后的值是否使用原索引值，如果为 True，则索引将会是 0, 1, ..., n-1 |
|  verify_integrity  |  bool 类型，是否检查合并后的索引有无重复项，设置为 `True` 若有重复项则会报错  |
|  sort  |  bool 类型，是否对列索引（columns）进行排序，默认 False  |

合并 Series 对象：

```python
>>> import pandas as pd
>>> obj1 = pd.Series([1, 2, 3])
>>> obj2 = pd.Series([4, 5, 6])
>>> obj3 = pd.Series([4, 5, 6], index=[3, 4, 5])
>>> obj1
0    1
1    2
2    3
dtype: int64
>>> 
>>> obj2
0    4
1    5
2    6
dtype: int64
>>> 
>>> obj3
3    4
4    5
5    6
dtype: int64
>>> 
>>> obj1.append(obj2)
0    1
1    2
2    3
0    4
1    5
2    6
dtype: int64
>>> 
>>> obj1.append(obj3)
0    1
1    2
2    3
3    4
4    5
5    6
dtype: int64
>>> 
>>> obj1.append(obj2, ignore_index=True)
0    1
1    2
2    3
3    4
4    5
5    6
dtype: int64
>>> 
>>> obj1.append(obj2, verify_integrity=True)
Traceback (most recent call last):
...
ValueError: Indexes have overlapping values: Int64Index([0, 1, 2], dtype='int64')
```

合并 DataFrame 对象：

```python
>>> import pandas as pd
>>> obj1 = pd.DataFrame([[1, 2], [3, 4]], columns=list('AB'))
>>> obj2 = pd.DataFrame([[5, 6], [7, 8]], columns=list('AB'))
>>> 
>>> obj1
   A  B
0  1  2
1  3  4
>>> 
>>> obj2
   A  B
0  5  6
1  7  8
>>> 
>>> obj1.append(obj2)
   A  B
0  1  2
1  3  4
0  5  6
1  7  8
>>> 
>>> obj1.append(obj2, ignore_index=True)
   A  B
0  1  2
1  3  4
2  5  6
3  7  8
```

以下虽然不是生成 DataFrames 的推荐方法，但演示了从多个数据源生成 DataFrames 的两种方法：

```python
>>> import pandas as pd
>>> obj = pd.DataFrame(columns=['A'])
>>> for i in range(5):
	obj = obj.append({'A': i}, ignore_index=True)

	
>>> obj
   A
0  0
1  1
2  2
3  3
4  4
```

```python
>>> import pandas as pd
>>> pd.concat([pd.DataFrame([i], columns=['A']) for i in range(5)], ignore_index=True)
   A
0  0
1  1
2  2
3  3
4  4
```

## <font color=#FF0000>【03x00】merge</font>

将不同的数据源进行合并是数据科学中常见的操作，这既包括将两个不同的数据集非常简单地拼接在一起，也包括用数据库那样的连接（join）与合并（merge）操作处理有重叠字段的数据集。Series 与DataFrame 都具备这类操作，Pandas 的函数与方法让数据合并变得快速简单。

数据集的合并（merge）或连接（join）运算是通过一个或多个键将行连接起来的。这些运算是关系型数据库（基于SQL）的核心。Pandas 的 merge 函数是对数据应用这些算法的主要切入点。

<font color=#FF0000> **`pandas.merge` 可根据一个或多个连接键将不同 DataFrame 中的行连接起来。**</font>

基本语法：

```python
pandas.merge(left,
			 right,
			 how: str = 'inner',
			 on=None,
			 left_on=None,
			 right_on=None,
			 left_index: bool = False,
			 right_index: bool = False,
			 sort: bool = False,
			 suffixes='_x', '_y',
			 copy: bool = True,
			 indicator: bool = False,
			 validate=None) → ’DataFrame’
```

官方文档：[https://pandas.pydata.org/docs/reference/api/pandas.merge.html](https://pandas.pydata.org/docs/reference/api/pandas.merge.html)

常见参数描述：

|  参数  |  描述  |
|  ------  |  ------  |
|  left  |  参与合并的左侧 DataFrame 对象  |
|  right  |  参与合并的右侧 DataFrame 对象  |
|  how  |  合并方式，默认 `'inner'`<br>`'inner'`：内连接，即使用两个对象中<font color=#FF0000>**都有**</font>的键（交集）；<br>`'outer'`：外连接，即使用两个对象中<font color=#FF0000>**所有**</font>的键（并集）；<br>`'left'`：左连接，即使用<font color=#FF0000>**左**</font>对象中所有的键；<br>`'right'`：右连接，即使用<font color=#FF0000>**右**</font>对象中所有的键；  |
|  on  |  用于连接的列名。必须存在于左右两个 Dataframe对象中<br>如果未指定，且其他连接键也未指定，则以 left 和 right 列名的交集作为连接键  |
|  left_on  |  左侧 DataFrame 对象中用作连接键的列  |
|  right_on  |  右侧 DataFrame 对象中用作连接键的列  |
|  left_index  |  bool 类型，是否使用左侧 DataFrame 对象中的索引（index）作为连接键，默认 False  |
|  right_index  |  bool 类型，是否使用右侧 DataFrame 对象中的索引（index）作为连接键，默认 False  |
|  sort  |  bool 类型，是否在结果中按顺序对连接键排序，默认 False。<br>如果为 False，则连接键的顺序取决于联接类型（how 关键字）  |
|  suffixes  |  字符串值元组，用于追加到重叠列名的末尾，默认为 `('_x', '_y')`。<br>例如，如果左右两个 DataFrame 对象都有 `data` 列时，则结果中就会出现 `data_x` 和 `data_y`  |

### <font color=#4876FF>【03x01】一对一连接</font>

<font color=#FF0000>**一对一连接是指两个 DataFrame 对象的列的值没有重复值。**</font>

如果不指定任何参数，调用 `merge` 方法，`merge` 就会将重叠的列的列名当做键来合并。

在下面的示例中，两个 DataFrame 对象都有一个列名为 `key` 的列，未指定按照哪一列来合并，`merge` 就会默认按照 `key` 来合并：

```python
>>> import pandas as pd
>>> obj1 = pd.DataFrame({'key': ['b', 'a', 'c'], 'data1': range(3)})
>>> obj2 = pd.DataFrame({'key': ['a', 'c', 'b'], 'data2': range(3)})
>>> obj1
  key  data1
0   b      0
1   a      1
2   c      2
>>> 
>>> obj2
  key  data2
0   a      0
1   c      1
2   b      2
>>> 
>>> pd.merge(obj1, obj2)
  key  data1  data2
0   b      0      2
1   a      1      0
2   c      2      1
```

### <font color=#4876FF>【03x02】多对一连接</font>

<font color=#FF0000>**多对一连接是指两个 DataFrame 对象中，有一个的列的值有重复值。**</font>通过多对一连接获得的结果，DataFrame  将会保留重复值。

```python
>>> import pandas as pd
>>> obj1 = pd.DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'a', 'b'], 'data1': range(7)})
>>> obj2 = pd.DataFrame({'key': ['a', 'b', 'd'], 'data2': range(3)})
>>> 
>>> obj1
  key  data1
0   b      0
1   b      1
2   a      2
3   c      3
4   a      4
5   a      5
6   b      6
>>> 
>>> obj2
  key  data2
0   a      0
1   b      1
2   d      2
>>> 
>>> pd.merge(obj1, obj2)
  key  data1  data2
0   b      0      1
1   b      1      1
2   b      6      1
3   a      2      0
4   a      4      0
5   a      5      0
```

### <font color=#4876FF>【03x03】多对多连接</font>

<font color=#FF0000>**多对多连接是指两个 DataFrame 对象中的列的值都有重复值。**</font>

```python
>>> import pandas as pd
>>> obj1 = pd.DataFrame({'key': ['a', 'b', 'b', 'c'], 'data1': range(4)})
>>> obj2 = pd.DataFrame({'key': ['a', 'a', 'b', 'b', 'c', 'c'], 'data2': range(6)})
>>> obj1
  key  data1
0   a      0
1   b      1
2   b      2
3   c      3
>>> 
>>> obj2
  key  data2
0   a      0
1   a      1
2   b      2
3   b      3
4   c      4
5   c      5
>>> 
>>> pd.merge(obj1, obj2)
  key  data1  data2
0   a      0      0
1   a      0      1
2   b      1      2
3   b      1      3
4   b      2      2
5   b      2      3
6   c      3      4
7   c      3      5
```

---

```yaml
这里是一段防爬虫文本，请读者忽略。
本文原创首发于 CSDN，作者 TRHX。
博客首页：https://itrhx.blog.csdn.net/
本文链接：https://itrhx.blog.csdn.net/article/details/106830112
未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！
```

---

### <font color=#4876FF>【03x04】参数 on / left_on / right_on</font>

参数 `on` 用于指定按照某一列来进行合并，若不指定该参数，则会默认按照重叠的列的列名当做键来合并：

```python
>>> import pandas as pd
>>> obj1 = pd.DataFrame({'key': ['b', 'a', 'c'], 'data1': range(3)})
>>> obj2 = pd.DataFrame({'key': ['a', 'c', 'b'], 'data2': range(3)})
>>> obj1
  key  data1
0   b      0
1   a      1
2   c      2
>>> 
>>> obj2
  key  data2
0   a      0
1   c      1
2   b      2
>>> 
>>> pd.merge(obj1, obj2, on='key')
  key  data1  data2
0   b      0      2
1   a      1      0
2   c      2      1
```

如果要根据多个键进行合并，传入一个由列名组成的列表即可：

```python
>>> import pandas as pd
>>> left = pd.DataFrame({'key1': ['foo', 'foo', 'bar'],
			 'key2': ['one', 'two', 'one'],
			 'lval': [1, 2, 3]})
>>> right = pd.DataFrame({'key1': ['foo', 'foo', 'bar', 'bar'],
			  'key2': ['one', 'one', 'one', 'two'],
			  'rval': [4, 5, 6, 7]})
>>> left
  key1 key2  lval
0  foo  one     1
1  foo  two     2
2  bar  one     3
>>> 
>>> right
  key1 key2  rval
0  foo  one     4
1  foo  one     5
2  bar  one     6
3  bar  two     7
>>> 
>>> pd.merge(left, right, on=['key1', 'key2'])
  key1 key2  lval  rval
0  foo  one     1     4
1  foo  one     1     5
2  bar  one     3     6
```


如果两个对象的列名不同，就可以使用 `left_on`、`right_on` 参数分别进行指定：

```python
>>> import pandas as pd
>>> obj1 = pd.DataFrame({'lkey': ['b', 'b', 'a', 'c', 'a', 'a', 'b'], 'data1': range(7)})
>>> obj2 = pd.DataFrame({'rkey': ['a', 'b', 'd'], 'data2': range(3)})
>>> obj1
  lkey  data1
0    b      0
1    b      1
2    a      2
3    c      3
4    a      4
5    a      5
6    b      6
>>> 
>>> obj2
  rkey  data2
0    a      0
1    b      1
2    d      2
>>> 
>>> pd.merge(obj1, obj2, left_on='lkey', right_on='rkey')
  lkey  data1 rkey  data2
0    b      0    b      1
1    b      1    b      1
2    b      6    b      1
3    a      2    a      0
4    a      4    a      0
5    a      5    a      0
```

### <font color=#4876FF>【03x05】参数 how</font>

在前面的示例中，结果里面 c 和 d 以及与之相关的数据消失了。默认情况下，`merge` 做的是内连接（`'inner'`），结果中的键是交集。其他方式还有：`'left'`、`'right'`、`'outer'`，含义如下：

- `'inner'`：内连接，即使用两个对象中<font color=#FF0000>**都有**</font>的键（交集）；
- `'outer'`：外连接，即使用两个对象中<font color=#FF0000>**所有**</font>的键（并集）；
- `'left'`：左连接，即使用<font color=#FF0000>**左**</font>对象中所有的键；
- `'right'`：右连接，即使用<font color=#FF0000>**右**</font>对象中所有的键；

```python
>>> import pandas as pd
>>> obj1 = pd.DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'a', 'b'], 'data1': range(7)})
>>> obj2 = pd.DataFrame({'key': ['a', 'b', 'd'], 'data2': range(3)})
>>> obj1
  key  data1
0   b      0
1   b      1
2   a      2
3   c      3
4   a      4
5   a      5
6   b      6
>>> 
>>> obj2
  key  data2
0   a      0
1   b      1
2   d      2
>>> 
>>> pd.merge(obj1, obj2, on='key', how='inner')
  key  data1  data2
0   b      0      1
1   b      1      1
2   b      6      1
3   a      2      0
4   a      4      0
5   a      5      0
>>> 
>>> pd.merge(obj1, obj2, on='key', how='outer')
  key  data1  data2
0   b    0.0    1.0
1   b    1.0    1.0
2   b    6.0    1.0
3   a    2.0    0.0
4   a    4.0    0.0
5   a    5.0    0.0
6   c    3.0    NaN
7   d    NaN    2.0
>>> 
>>> pd.merge(obj1, obj2, on='key', how='left')
  key  data1  data2
0   b      0    1.0
1   b      1    1.0
2   a      2    0.0
3   c      3    NaN
4   a      4    0.0
5   a      5    0.0
6   b      6    1.0
>>> 
>>> pd.merge(obj1, obj2, on='key', how='right')
  key  data1  data2
0   b    0.0      1
1   b    1.0      1
2   b    6.0      1
3   a    2.0      0
4   a    4.0      0
5   a    5.0      0
6   d    NaN      2
```

### <font color=#4876FF>【03x06】参数 suffixes</font>

`suffixes` 参数用于指定附加到左右两个 DataFrame 对象的重叠列名上的字符串：
 
在以下示例中，选择按照 `key1` 进行合并，而两个 DataFrame 对象都包含 `key2` 列，如果未指定 `suffixes` 参数，则默认会为两个对象的 `key2` 加上 `_x` 和 `_y`，以便区分它们，如果指定了 `suffixes` 参数，就会按照添加指定的后缀：


```python
>>> import pandas as pd
>>> left = pd.DataFrame({'key1': ['foo', 'foo', 'bar'],
			 'key2': ['one', 'two', 'one'],
			 'lval': [1, 2, 3]})
>>> right = pd.DataFrame({'key1': ['foo', 'foo', 'bar', 'bar'],
			  'key2': ['one', 'one', 'one', 'two'],
			  'rval': [4, 5, 6, 7]})
>>> left
  key1 key2  lval
0  foo  one     1
1  foo  two     2
2  bar  one     3
>>> 
>>> right
  key1 key2  rval
0  foo  one     4
1  foo  one     5
2  bar  one     6
3  bar  two     7
>>> 
>>> pd.merge(left, right, on='key1')
  key1 key2_x  lval key2_y  rval
0  foo    one     1    one     4
1  foo    one     1    one     5
2  foo    two     2    one     4
3  foo    two     2    one     5
4  bar    one     3    one     6
5  bar    one     3    two     7
>>> 
>>> pd.merge(left, right, on='key1', suffixes=('_left', '_right'))
  key1 key2_left  lval key2_right  rval
0  foo       one     1        one     4
1  foo       one     1        one     5
2  foo       two     2        one     4
3  foo       two     2        one     5
4  bar       one     3        one     6
5  bar       one     3        two     7
```

### <font color=#4876FF>【03x07】参数 left_index / right_index</font>

有时候，DataFrame 中的连接键位于其索引中。在这种情况下，可以使用 `left_index=True` 或`right_index=True`（或两个都传）以说明索引应该被用作连接键。这种方法称为按索引连接，在 Pandas 中还有个 `join` 方法可以实现这个功能。

在以下示例中，按照 left 的 key 列进行连接，而 right 对象的连接键位于其索引中，因此要指定 `right_index=True`：

```python
>>> import pandas as pd
>>> left = pd.DataFrame({'key': ['a', 'b', 'a', 'a', 'b', 'c'], 'value': range(6)})
>>> right = pd.DataFrame({'group_val': [3.5, 7]}, index=['a', 'b'])
>>> left
  key  value
0   a      0
1   b      1
2   a      2
3   a      3
4   b      4
5   c      5
>>> 
>>> right
   group_val
a        3.5
b        7.0
>>> 
>>> pd.merge(left, right, left_on='key', right_index=True)
  key  value  group_val
0   a      0        3.5
2   a      2        3.5
3   a      3        3.5
1   b      1        7.0
4   b      4        7.0
```

## <font color=#FF0000>【04x00】join</font>

join 方法只适用于 DataFrame 对象，Series 对象没有该方法，该方法用于连接另一个 DataFrame 对象的列（columns）。

基本语法：`DataFrame.join(self, other, on=None, how='left', lsuffix='', rsuffix='', sort=False) → ’DataFrame’`

参数描述：

|  参数  |  描述  |
|  ------  |  ------  |
|  other  |  另一个 DataFrame、Series 或 DataFrame 列表对象  |
|  on  |  列名称，或者列名称组成的列表、元组，连接的列  |
|  how  |  合并方式，默认 `'left'`<br>`'inner'`：内连接，即使用两个对象中<font color=#FF0000>**都有**</font>的键（交集）；<br>`'outer'`：外连接，即使用两个对象中<font color=#FF0000>**所有**</font>的键（并集）；<br>`'left'`：左连接，即使用<font color=#FF0000>**左**</font>对象中所有的键；<br>`'right'`：右连接，即使用<font color=#FF0000>**右**</font>对象中所有的键；  |
|  lsuffix  |  当两个对象有相同的列名时，合并后左边数据列名的后缀  |
|  rsuffix  |  当两个对象有相同的列名时，合并后右边数据列名的后缀  |
|  sort  |  bool 类型，是否在结果中按顺序对连接键排序，默认 False。<br>如果为 False，则连接键的顺序取决于联接类型（how 关键字）  |

使用 `lsuffix` 和 `rsuffix` 参数：

```python
>>> import pandas as pd
>>> obj = pd.DataFrame({'key': ['K0', 'K1', 'K2', 'K3', 'K4', 'K5'],
			'A': ['A0', 'A1', 'A2', 'A3', 'A4', 'A5']})
>>> other = pd.DataFrame({'key': ['K0', 'K1', 'K2'],
			  'B': ['B0', 'B1', 'B2']})
>>> obj
  key   A
0  K0  A0
1  K1  A1
2  K2  A2
3  K3  A3
4  K4  A4
5  K5  A5
>>> 
>>> other
  key   B
0  K0  B0
1  K1  B1
2  K2  B2
>>> 
>>> obj.join(other, lsuffix='_1', rsuffix='_2')
  key_1   A key_2    B
0    K0  A0    K0   B0
1    K1  A1    K1   B1
2    K2  A2    K2   B2
3    K3  A3   NaN  NaN
4    K4  A4   NaN  NaN
5    K5  A5   NaN  NaN
```

如果右表的索引是左表的某一列的值，这时可以将右表的索引和左表的列对齐合并这样的灵活方式进行合并：

```python
>>> import pandas as pd
>>> obj = pd.DataFrame({'A': ['A0', 'A1', 'A2', 'A3'], 'B': ['B0', 'B1', 'B2', 'B3'],'key': ['K0', 'K1', 'K0', 'K1']})
>>> other = pd.DataFrame({'C': ['C0', 'C1'],'D': ['D0', 'D1']},index=['K0', 'K1'])
>>> obj
    A   B key
0  A0  B0  K0
1  A1  B1  K1
2  A2  B2  K0
3  A3  B3  K1
>>> 
>>> other
     C   D
K0  C0  D0
K1  C1  D1
>>> 
>>> obj.join(other, on='key')
    A   B key   C   D
0  A0  B0  K0  C0  D0
1  A1  B1  K1  C1  D1
2  A2  B2  K0  C0  D0
3  A3  B3  K1  C1  D1
```

## <font color=#FF0000>【05x00】四种方法的区别</font>

- `concat`：可用于两个或多个 Series 或 DataFrame 对象间，通过 `axis` 参数指定按照行方向（增加行）或列方向（增加列）进合并操作，默认行合并（增加行），取并集；

- `append`：在一个 Series 或 DataFrame 对象后最追加另一个 Series 或 DataFrame 对象并返回一个新对象，不改变原对象的值。只能按行合并（增加行）。

- `merge`：只能对两个 DataFrame 对象进行合并，一般按照列方向（增加列）进行合并操作，按照行方向合并一般用 join 方法代替，默认列合并（增加列），取交集；

- `join`：只能对两个 DataFrame 对象进行合并，按照列方向（增加列）进行合并操作，默认左连接。

---

```yaml
这里是一段防爬虫文本，请读者忽略。
本文原创首发于 CSDN，作者 TRHX。
博客首页：https://itrhx.blog.csdn.net/
本文链接：https://itrhx.blog.csdn.net/article/details/106830112
未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！
```

---
