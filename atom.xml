<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ITBOB&#39;S BLOG</title>
  
  <subtitle>一入 IT 深似海 从此学习无绝期</subtitle>
  <link href="https://www.itbob.cn/atom.xml" rel="self"/>
  
  <link href="https://www.itbob.cn/"/>
  <updated>2022-05-22T12:49:00.000Z</updated>
  <id>https://www.itbob.cn/</id>
  
  <author>
    <name>BOB</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 数据结构之栈的实现</title>
    <link href="https://www.itbob.cn/article/038/"/>
    <id>https://www.itbob.cn/article/038/</id>
    <published>2020-11-30T06:48:05.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈的概念"><a href="#栈的概念" class="headerlink" title="栈的概念"></a>栈的概念</h2><p>栈（stack）又名堆栈，栈是一种线性数据结构，用先进后出或者是后进先出的方式存储数据，栈中数据的插入删除操作都是在栈的顶端进行，这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p><p><img src="https://img-blog.csdnimg.cn/20201101205308521.png" alt="01"></p><hr><h2 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h2><p>元素后进先出（Last in First Out，LIFO）</p><hr><h2 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h2><ul><li><font color=#FF0000><strong>push(item)</strong></font>：进栈（向栈顶添加元素）</li><li><font color=#FF0000><strong>pop()</strong></font>：出栈（删除栈顶元素）</li><li><font color=#FF0000><strong>top()</strong></font>：查看栈顶元素</li><li><font color=#FF0000><strong>empty()</strong></font>：判断栈是否为空</li></ul><hr><h2 id="Python-实现栈"><a href="#Python-实现栈" class="headerlink" title="Python 实现栈"></a>Python 实现栈</h2><p>栈并不是 Python 的内建类型，在必要的时候可以使用列表来模拟基于数组的栈。如果将列表的末尾看作是栈的顶，列表方法 <code>append()</code> 就是将元素压入到栈中（进栈），而列表方法 <code>pop()</code> 会删除并返回栈顶的元素（出栈），列表索引的方式 <code>arr[-1]</code> 可以查看栈顶元素。具体代码实现如下：</p><pre><code class="python">class Stack:    def __init__(self):        self.stack = []    def push(self, item):        self.stack.append(item)    def pop(self):        if self.empty():            return None        else:            return self.stack.pop()    def top(self):        if self.empty():            return None        else:            return self.stack[-1]    def empty(self):        return len(self.stack) == 0</code></pre><hr><h2 id="栈的简单应用：括号匹配问题"><a href="#栈的简单应用：括号匹配问题" class="headerlink" title="栈的简单应用：括号匹配问题"></a>栈的简单应用：括号匹配问题</h2><p><font color=#2DAF8B><strong>问题描述：</strong></font></p><p>给定一个字符串，字符串中只包含小括号 <code>()</code>、中括号 <code>[]</code>、大括号 <code>&#123;&#125;</code>，求该字符串中的括号是否匹配。匹配规则：成对出现或者左右对称出现，例如：</p><p><font color=#FF0000><strong>()[]{}</strong></font>：匹配；<font color=#FF0000><strong>{[()]}</strong></font>：匹配；<font color=#FF0000><strong>({}]</strong></font>：不匹配；<font color=#FF0000><strong>()]</strong></font>：不匹配；<font color=#FF0000><strong>({)}</strong></font>：不匹配</p><p><font color=#2DAF8B><strong>通过栈来解决：</strong></font></p><p>有字符串 <font color=#FF0000><strong>()[{}]</strong></font>，依次取每个括号，只要是左括号就进栈，只要是右括号就判断栈顶是否为对应的左括号，具体步骤如下：</p><ul><li><strong>①</strong> 遇到左小括号 <font color=#FF0000><strong>(</strong></font>，执行进栈操作；</li><li><strong>②</strong> 遇到右小括号 <font color=#FF0000><strong>)</strong></font>，判断此时栈顶是否为左小括号 <font color=#FF0000><strong>(</strong></font>，是则让左小括号 <font color=#FF0000><strong>(</strong></font> 出栈，此时栈为空;</li><li><strong>③</strong> 遇到左中括号 <font color=#FF0000><strong>[</strong></font>，执行进栈操作；</li><li><strong>④</strong> 遇到左大括号 <font color=#FF0000><strong>{</strong></font>，执行进栈操作；</li><li><strong>⑤</strong> 遇到右大括号 <font color=#FF0000><strong>}</strong></font>，判断此时栈顶是否为左大括号 <font color=#FF0000><strong>{</strong></font>，是则让左大括号 <font color=#FF0000><strong>{</strong></font> 出栈，此时栈为空；</li><li><strong>⑥</strong> 遇到右中括号 <font color=#FF0000><strong>]</strong></font>，判断此时栈顶是否为左中括号 <font color=#FF0000><strong>[</strong></font>，是则让左中括号 <font color=#FF0000><strong>[</strong></font> 出栈，此时栈为空；</li><li><strong>⑦</strong> 判断最终的栈是否为空，是则表示匹配，不是则表示不匹配。其中第 <strong>② ⑤ ⑥</strong> 步中，若判断为不是，则直接表示不匹配。</li></ul><p><font color=#2DAF8B><strong>Python 代码实现：</strong></font></p><pre><code class="python">class Stack:    def __init__(self):        self.stack = []    def push(self, item):        self.stack.append(item)    def pop(self):        if self.empty():            return None        else:            return self.stack.pop()    def top(self):        if self.empty():            return None        else:            return self.stack[-1]    def empty(self):        return len(self.stack) == 0def brackets_match(s):    match_dict = &#123;&#39;&#125;&#39;: &#39;&#123;&#39;, &#39;]&#39;: &quot;[&quot;, &#39;)&#39;: &#39;(&#39;&#125;    stack = Stack()    for ch in s:        if ch in [&#39;(&#39;, &#39;[&#39;, &#39;&#123;&#39;]:    # 如果为左括号，则执行进栈操作            stack.push(ch)        else:                        # 如果为右括号            if stack.empty():        # 如果栈为空，则不匹配，即多了一个右括号，没有左括号匹配                return False            elif stack.top() == match_dict[ch]:  # 如果栈顶的元素为对应的左括号，则让栈顶出栈                stack.pop()            else:                    # 如果栈顶元素不是对应的左括号，则不匹配                return False    if stack.empty():                # 最后的栈如果为空，则匹配，否则不匹配        return True    else:        return Falseprint(brackets_match(&#39;[&#123;()&#125;()&#123;()&#125;[](&#123;&#125;)&#123;&#125;]&#39;))print(brackets_match(&#39;()[&#123;&#125;]&#39;))print(brackets_match(&#39;(&#123;)&#125;&#39;))print(brackets_match(&#39;[]&#125;&#39;))</code></pre><p>输出结果：</p><pre><code class="python">TrueTrueFalseFalse</code></pre><hr><h2 id="栈的简单应用：倒序输出一组元素"><a href="#栈的简单应用：倒序输出一组元素" class="headerlink" title="栈的简单应用：倒序输出一组元素"></a>栈的简单应用：倒序输出一组元素</h2><p>把元素存入栈，再顺序取出：</p><pre><code class="python">class Stack:    def __init__(self):        self.stack = []    def push(self, item):        self.stack.append(item)    def pop(self):        if self.empty():            return None        else:            return self.stack.pop()    def top(self):        if self.empty():            return None        else:            return self.stack[-1]    def empty(self):        return len(self.stack) == 0def reverse_list(s):    stack = Stack()    for ch in s:        stack.push(ch)    new_list = []    while not stack.empty():        new_list.append(stack.pop())    return new_listprint(reverse_list([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;]))</code></pre><p>输出结果：</p><pre><code class="python">[&#39;E&#39;, &#39;D&#39;, &#39;C&#39;, &#39;B&#39;, &#39;A&#39;]</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;栈的概念&quot;&gt;&lt;a href=&quot;#栈的概念&quot; class=&quot;headerlink&quot; title=&quot;栈的概念&quot;&gt;&lt;/a&gt;栈的概念&lt;/h2&gt;&lt;p&gt;栈（stack）又名堆栈，栈是一种线性数据结构，用先进后出或者是后进先出的方式存储数据，栈中数据的插入删除操作都是在栈的顶端</summary>
      
    
    
    
    <category term="算法" scheme="https://www.itbob.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="算法" scheme="https://www.itbob.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python 算法之递归与尾递归，斐波那契数列以及汉诺塔的实现</title>
    <link href="https://www.itbob.cn/article/037/"/>
    <id>https://www.itbob.cn/article/037/</id>
    <published>2020-10-28T14:05:13.000Z</published>
    <updated>2022-05-22T12:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递归概念"><a href="#递归概念" class="headerlink" title="递归概念"></a>递归概念</h2><p><font color=#ff0000><strong>递归</strong></font>：程序调用自身的编程技巧称为递归（ recursion）。用一种通俗的话来说就是自己调用自己，它通常把一个大型复杂的问题层层转化为一个与原问题相似的、但是规模较小的问题来求解，当问题小到一定规模的时候，需要一个递归出口返回。递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。</p><p><font color=#ff0000><strong>递归函数</strong></font>：在编程语言中，函数直接或间接调用函数本身，则该函数称为递归函数；在数学上的定义如下：对于某一函数 $f(x)$，其定义域是集合 A，那么若对于 A 集合中的某一个值 $X_0$，其函数值 $f(x_0)$ 由 $f(f(x_0))$ 决定，那么就称 $f(x)$ 为递归函数。</p><hr><h2 id="递归要素"><a href="#递归要素" class="headerlink" title="递归要素"></a>递归要素</h2><ul><li><p>递归必须包含一个基本的出口（结束条件），否则就会无限递归，最终导致栈溢出；</p></li><li><p>递归必须包含一个可以分解的问题，例如要想求得 $fact(n)$，就需要用 $n * fact(n-1)$；</p></li><li><p>递归必须必须要向着递归出口靠近，例如每次递归调用都会 $n-1$，向着递归出口 $n == 0$ 靠近。</p></li></ul><hr><h2 id="递归与迭代的区别"><a href="#递归与迭代的区别" class="headerlink" title="递归与迭代的区别"></a>递归与迭代的区别</h2><ul><li><p><font color=#ff0000><strong>递归（recursion）</strong></font>：递归则是一步一步往前递推，直到递归基础，寻找一条路径， 然后再由前向后计算。（A调用A）</p></li><li><p><font color=#ff0000><strong>迭代（iteration）</strong></font>：迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值，因此迭代是从前往后计算的。（A重复调用B）</p></li></ul><hr><h2 id="示例一：阶乘"><a href="#示例一：阶乘" class="headerlink" title="示例一：阶乘"></a>示例一：阶乘</h2><p>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且 0 的阶乘为 1。即 $n!=1×2×3×…×(n-1)×n$，以递归方式定义：$n!=(n-1)!×n$</p><pre><code class="python">def factorial(n):    if n == 0:        return 1    else:        return n * factorial(n-1)</code></pre><hr><h2 id="示例二：斐波那契数列"><a href="#示例二：斐波那契数列" class="headerlink" title="示例二：斐波那契数列"></a>示例二：斐波那契数列</h2><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家莱昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”。</p><p>有一个数列：0、1、1、2、3、5、8、13、21、34、55、89…，这个数列从第3项开始，每一项都等于前两项之和。以递推的方法定义：$F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N^*）$</p><pre><code class="python">def fibonacc(n):    if n == 1 or n == 2:        return 1    else:        return fibonacc(n-1) + fibonacc(n-2)</code></pre><p>以上方法的时间复杂度为$O(2^n)$，稍微大一点的数都会算很久，有一个简单的解决方案，使用 <code>lru_cache</code> 缓存装饰器，缓存一些中间结果：</p><pre><code class="python">from functools import lru_cache# 缓存斐波那契函数已经计算出的结果，最多占用1024字节内存@lru_cache(maxsize=1024)def fibonacc(n):    if n == 1 or n == 2:        return 1    else:        return fibonacc(n-1) + fibonacc(n-2)</code></pre><p>另外还有更加节省时间和空间的方法：</p><pre><code class="python">def fibonacc(n, current=0, next=1):    if n == 0:        return current    else:        return fibonacc(n-1, next, current+next)</code></pre><hr><h2 id="示例三：汉诺塔问题"><a href="#示例三：汉诺塔问题" class="headerlink" title="示例三：汉诺塔问题"></a>示例三：汉诺塔问题</h2><p>汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。64片黄金圆盘移动完毕之日，就是世界毁灭之时。</p><p><img src="https://img-blog.csdnimg.cn/20201028204105893.gif" alt="01汉诺塔"></p><p>对于 n 个盘子，移动步骤如下：</p><ul><li>把 n-1 个盘子由 A 经过 C 移动到 B</li><li>把最后一个盘子移动到 C</li><li>把 n-1 个盘子由 B 经过 A 移动到 C</li></ul><p><img src="https://img-blog.csdnimg.cn/20201028220237371.png" alt="02汉诺塔"></p><p>递归代码实现：</p><pre><code class="python">def hanoi(n, a, b, c):                                # n 个盘子，a，b，c三个柱子    if n &gt; 0:        hanoi(n-1, a, c, b)                           # 把 n-1 个盘子由 a 经过 c 移动到 b        print(&#39;moving from &#123;0&#125; to &#123;1&#125;&#39;.format(a, c))  # 把最后一个盘子移动到 c        hanoi(n-1, b, a, c)                           # 把 n-1 个盘子由 b 经过 a 移动到 c</code></pre><p>示例：</p><pre><code class="python">def hanoi(n, a, b, c):    if n &gt; 0:        hanoi(n-1, a, c, b)        print(&#39;moving from &#123;0&#125; to &#123;1&#125;&#39;.format(a, c))        hanoi(n-1, b, a, c)hanoi(3, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;)</code></pre><pre><code class="python">moving from A to Cmoving from A to Bmoving from C to Bmoving from A to Cmoving from B to Amoving from B to Cmoving from A to C</code></pre><hr><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。通俗来讲就是递归调用放在了函数的最后。</p><pre><code class="python"># 一般递归def func(n):    if n &gt; 0:        func(n-1)        print(n)# 一般递归def func(n):    if n &gt; 0:        return func(n-1) + n# 尾递归def func(n):    a = n    if n &gt; 0:        a += 1        print(a, n)        return func(n-1)</code></pre><p>对于普通的递归，每一级递归都产生了新的局部变量，必须创建新的调用栈，随着递归深度的增加，创建的栈越来越多，容易造成爆栈。</p><pre><code class="python">def normal_recursion(n):    if n == 1:        return 1    else:        return n + normal_recursion(n-1)</code></pre><p><code>normal_recursion(5)</code> 执行：</p><pre><code class="python">normal_recursion(5)5 + normal_recursion(4)5 + 4 + normal_recursion(3)5 + 4 + 3 + normal_recursion(2)5 + 4 + 3 + 2 + normal_recursion(1)5 + 4 + 3 + 35 + 4 + 65 + 1015</code></pre><p>尾递归基于函数的尾调用，每一级调用直接返回递归函数更新调用栈，没有新局部变量的产生，类似迭代的实现。</p><pre><code class="python">def tail_recursion(n, total=0):    if n == 0:        return total    else:        return tail_recursion(n-1, total+n)</code></pre><p><code>normal_recursion(5)</code> 执行：</p><pre><code class="python">tail_recursion(5, 0)tail_recursion(4, 5)tail_recursion(3, 9)tail_recursion(2, 12)tail_recursion(1, 14)tail_recursion(0, 15)15</code></pre><p>在 Python，Java，Pascal 等语言中是无法实现尾递归优化的，所以采用了 for，while，goto 等特殊结构以迭代的方式来代替尾递归。</p><hr><h2 id="Python-中尾递归的解决方案"><a href="#Python-中尾递归的解决方案" class="headerlink" title="Python 中尾递归的解决方案"></a>Python 中尾递归的解决方案</h2><p>使用普通的递归来实现斐波那契数列的计算，代码段如下：</p><pre><code class="python">def fibonacc(n, current=0, next=1):    if n == 0:        return current    else:        return fibonacc(n-1, next, current+next)a = fibonacc(1000)print(a)</code></pre><p>此时会报错，因为超过了最大递归深度（默认深度900-1000左右）：</p><pre><code class="python">Traceback (most recent call last):  File &quot;F:/PycharmProjects/algorithm/fibonacc_test.py&quot;, line 57, in &lt;module&gt;    a = fibonacc(1000)  File &quot;F:/PycharmProjects/algorithm/fibonacc_test.py&quot;, line 47, in fibonacc    return fibonacc(n-1, next, current+next)  File &quot;F:/PycharmProjects/algorithm/fibonacc_test.py&quot;, line 47, in fibonacc    return fibonacc(n-1, next, current+next)  File &quot;F:/PycharmProjects/algorithm/fibonacc_test.py&quot;, line 47, in fibonacc    return fibonacc(n-1, next, current+next)  [Previous line repeated 995 more times]  File &quot;F:/PycharmProjects/algorithm/fibonacc_test.py&quot;, line 44, in fibonacc    if n == 0:RecursionError: maximum recursion depth exceeded in comparison</code></pre><p>如果是递归深度不是很大的情况，可以手动重设递归深度来解决：</p><pre><code class="python">import syssys.setrecursionlimit(10000)  # 递归深度设置为 10000</code></pre><p>如果递归深度非常大，那么就可以采用尾递归优化，但是 Python 官方是并不支持尾递归的（不知道为啥），然而这难不到广大的程序员们，早在 2006 年 <a href="https://code.activestate.com/recipes/users/2792865/">Crutcher Dunnavant</a> 就想出了一个解决办法，实现一个 <code>tail_call_optimized</code> 装饰器，原文链接：<a href="https://code.activestate.com/recipes/474088/">https://code.activestate.com/recipes/474088/</a>，原代码是 Python 2.4 实现的，用 Python 3.x 实现如下：</p><pre><code class="python"># This program shows off a python decorator# which implements tail call optimization. It# does this by throwing an exception if it is# it&#39;s own grandparent, and catching such# exceptions to recall the stack.import sysclass TailRecurseException(BaseException):    def __init__(self, args, kwargs):        self.args = args        self.kwargs = kwargsdef tail_call_optimized(g):    &quot;&quot;&quot;    This function decorates a function with tail call    optimization. It does this by throwing an exception    if it is it&#39;s own grandparent, and catching such    exceptions to fake the tail call optimization.    This function fails if the decorated5    function recurses in a non-tail context.    &quot;&quot;&quot;    def func(*args, **kwargs):        f = sys._getframe()        if f.f_back and f.f_back.f_back and f.f_back.f_back.f_code == f.f_code:            raise TailRecurseException(args, kwargs)        else:            while 1:                try:                    return g(*args, **kwargs)                except TailRecurseException as e:                    args = e.args                    kwargs = e.kwargs    func.__doc__ = g.__doc__    return func</code></pre><p>使用该装饰器再来实现比较大的斐波那契数列的计算：</p><pre><code class="python">@tail_call_optimizeddef fibonacc(n, current=0, next=1):    if n == 0:        return current    else:        return fibonacc(n-1, next, current+next)a = fibonacc(1000)print(a)</code></pre><p>输出结果：</p><pre><code class="python">43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875</code></pre><p><code>tail_call_optimized</code> 实现尾递归优化的原理：当递归函数被该装饰器修饰后，递归调用在装饰器while循环内部进行，每当产生新的递归调用栈帧时，<code>f.f_back.f_back.f_code == f.f_code:</code> 就捕获当前尾调用函数的参数，并抛出异常，从而销毁递归栈并使用捕获的参数手动调用递归函数，所以递归的过程中始终只存在一个栈帧对象，达到优化的目的。</p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX•鲍勃。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/109322815未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;递归概念&quot;&gt;&lt;a href=&quot;#递归概念&quot; class=&quot;headerlink&quot; title=&quot;递归概念&quot;&gt;&lt;/a&gt;递归概念&lt;/h2&gt;&lt;p&gt;&lt;font color=#ff0000&gt;&lt;strong&gt;递归&lt;/strong&gt;&lt;/font&gt;：程序调用自身的编程技巧称为递归</summary>
      
    
    
    
    <category term="算法" scheme="https://www.itbob.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="算法" scheme="https://www.itbob.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python 实现十大经典排序算法</title>
    <link href="https://www.itbob.cn/article/036/"/>
    <id>https://www.itbob.cn/article/036/</id>
    <published>2020-10-23T16:12:00.000Z</published>
    <updated>2022-05-22T12:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考资料：<a href="https://www.bilibili.com/video/BV1mp4y1D7UP">https://www.bilibili.com/video/BV1mp4y1D7UP</a></li><li>本文动图演示来源：<a href="https://visualgo.net/">https://visualgo.net/</a></li></ul><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/108987300未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a><font color=#FF0000>排序算法分类</font></h2><ul><li><font color=#FF0000><strong>内部排序</strong></font>：指在排序期间，元素全部存放在内存中的排序，常见的内部排序算法有：<strong>冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、基数排序</strong>等。</li><li><font color=#FF0000><strong>外部排序</strong></font>：指在排序期间，元素无法完全全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序；</li><li><font color=#FF0000><strong>比较类排序</strong></font>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li><li><font color=#FF0000><strong>非比较类排序</strong></font>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 常见的非比较类排序算法有：<strong>基数排序、计数排序、桶排序</strong>等</li></ul><hr><p>一般情况下，内部排序算法在执行过程中都要进行两种操作：比较和移动。通过比较两个关键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。但是，并非所有的内部排序算法都要基于比较操作。</p><p>每种排序算法都有各自的优缺点，适合在不同的环境下使用，就其全面性能而言，很难提出一种被认为是最好的算法。<font color=#FF0000><strong>通常可以将排序算法分为插入排序、交换排序、选择排序、归并排序和基数排序五大类</strong></font>，内部排序算法的性能取决于算法的时间复杂度和空间复杂度，而时间复杂度一般是由比较和移动的次数决定的。</p><hr><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/01.png" alt="01"></p><table><thead><tr><th>排序算法</th><th>时间复杂度（平均）</th><th>时间复杂度（最好）</th><th>时间复杂度（最坏）</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$$ O(n^2) $$</td><td>$$ O(n) $$</td><td>$$ O(n^2) $$</td><td>$$ O(1) $$</td><td>稳定</td></tr><tr><td>选择排序</td><td>$$ O(n^2) $$</td><td>$$ O(n^2) $$</td><td>$$ O(n^2) $$</td><td>$$ O(1) $$</td><td>不稳定</td></tr><tr><td>插入排序</td><td>$$ O(n^2) $$</td><td>$$ O(n) $$</td><td>$$ O(n^2) $$</td><td>$$ O(1) $$</td><td>稳定</td></tr><tr><td>希尔排序</td><td>$$ O(nlogn) $$</td><td>$$ O(nlog^2n) $$</td><td>$$ O(nlog^2n) $$</td><td>$$ O(1) $$</td><td>不稳定</td></tr><tr><td>归并排序</td><td>$$ O(nlogn) $$</td><td>$$ O(nlogn) $$</td><td>$$ O(nlogn) $$</td><td>$$ O(n) $$</td><td>稳定</td></tr><tr><td>快速排序</td><td>$$ O(nlogn) $$</td><td>$$ O(nlogn) $$</td><td>$$ O(n^2) $$</td><td>$$ O(logn) $$</td><td>不稳定</td></tr><tr><td>堆排序</td><td>$$ O(nlogn) $$</td><td>$$ O(nlogn) $$</td><td>$$ O(nlogn) $$</td><td>$$ O(1) $$</td><td>不稳定</td></tr><tr><td>计数排序</td><td>$$ O(n+k) $$</td><td>$$ O(n+k) $$</td><td>$$ O(n+k) $$</td><td>$$ O(k) $$</td><td>稳定</td></tr><tr><td>桶排序</td><td>$$ O(n+k) $$</td><td>$$ O(n+k) $$</td><td>$$ O(n^2) $$</td><td>$$ O(n+k) $$</td><td>稳定</td></tr><tr><td>基数排序</td><td>$$ O(n*k) $$</td><td>$$ O(n*k) $$</td><td>$$ O(n*k) $$</td><td>$$ O(n+k) $$</td><td>稳定</td></tr></tbody></table><p><strong>稳定性</strong>：排序后 2 个相等键值的顺序和排序之前它们的顺序是否相同。例：如果 a 原本在 b 前面，且 a=b，排序之后 a 仍然在 b 的前面，则表示具有稳定性。</p><p>常见时间复杂度大小比较：</p><p>$$<br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt;…&lt; O(2^n)&lt;O (n!)<br>$$</p><hr><h2 id="一、冒泡排序（Bubble-Sort）"><a href="#一、冒泡排序（Bubble-Sort）" class="headerlink" title="一、冒泡排序（Bubble Sort）"></a><font color=#FF0000>一、冒泡排序（Bubble Sort）</font></h2><h3 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h3><p>重复地走访要排序的元素，依次比较两个相邻的元素，如果顺序（如从大到小）错误就把他们交换过来。走访元素的工作是重复地进行，直到没有相邻元素需要交换，也就是说该元素列已经排序完成。冒泡的意思其实就是每一轮冒泡一个最大的元素就会通过不断比较和交换相邻元素使它转移到最右边。</p><p>假如有 10 个小盆友从左到右站成一排，个头不等。老师想让他们按照个头从低到高站好，于是他开始喊口号。 每喊一次，从第一个小盆友开始，相邻的小朋友如果身高不是正序就会两两调换，就这样第一轮个头最高的排到了最右边（冒泡到最右边），第二轮依次这么来，从第一个小朋友开始两两交换，这样次高的小盆友又排到了倒数第二个位置。依次类推。</p><h3 id="2、步骤"><a href="#2、步骤" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li><strong>②</strong> 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li><strong>③</strong> 针对所有的元素重复步骤 <strong>①</strong> ~ <strong>②</strong>，除了最后一个元素，直到排序完成。</li></ul><h3 id="3、动画演示"><a href="#3、动画演示" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/02%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="02冒泡排序"></p><h3 id="4、代码实现"><a href="#4、代码实现" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def bubbleSort(arr):    for i in range(len(arr)-1):         # 循环第 i 趟        for j in range(len(arr)-i-1):   # j 为下标            if arr[j] &gt; arr[j+1]:       # 如果这个数大于后面的数就交换两者的位置                arr[j], arr[j+1] = arr[j+1], arr[j]    return arr</code></pre><p>冒泡排序还有一种优化算法，就是立一个 flag，当某一趟序列遍历中元素没有发生交换，则证明该序列已经有序，就不再进行后续的排序。动画演示里就是改进后的算法，改进后的代码如下：</p><pre><code class="python">def bubbleSort(arr):    for i in range(len(arr)-1):         # 循环第 i 趟    flag = False        for j in range(len(arr)-i-1):   # j 为下标            if arr[j] &gt; arr[j+1]:       # 如果这个数大于后面的数就交换两者的位置                arr[j], arr[j+1] = arr[j+1], arr[j]                flag = True        if not flag:            return    return arr</code></pre><p>冒泡排序最快的情况：当输入的数据是正序时；最慢的情况：当输入的数据是反序时。</p><h3 id="5、具体示例"><a href="#5、具体示例" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><p>未改进版本：</p><pre><code class="python">def bubble_sort(arr):    for i in range(len(arr)-1):         # 循环第 i 趟        for j in range(len(arr)-i-1):   # j 为下标            if arr[j] &gt; arr[j+1]:       # 如果这个数大于后面的数就交换两者的位置                arr[j], arr[j+1] = arr[j+1], arr[j]        print(arr)                      # 每一趟比较完了就打印一次arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]bubble_sort(arr)</code></pre><pre><code class="python">[3, 38, 5, 44, 15, 36, 26, 27, 2, 46, 4, 19, 47, 48, 50][3, 5, 38, 15, 36, 26, 27, 2, 44, 4, 19, 46, 47, 48, 50][3, 5, 15, 36, 26, 27, 2, 38, 4, 19, 44, 46, 47, 48, 50][3, 5, 15, 26, 27, 2, 36, 4, 19, 38, 44, 46, 47, 48, 50][3, 5, 15, 26, 2, 27, 4, 19, 36, 38, 44, 46, 47, 48, 50][3, 5, 15, 2, 26, 4, 19, 27, 36, 38, 44, 46, 47, 48, 50][3, 5, 2, 15, 4, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][3, 2, 5, 4, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</code></pre><p>改进版本：</p><pre><code class="python">def bubble_sort(arr):    for i in range(len(arr)-1):         # 循环第 i 趟        flag = False        for j in range(len(arr)-i-1):   # j 为下标            if arr[j] &gt; arr[j+1]:       # 如果这个数大于后面的数就交换两者的位置                arr[j], arr[j+1] = arr[j+1], arr[j]                flag = True        if not flag:            return        print(arr)                      # 每一趟比较完了就打印一次arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]bubble_sort(arr)</code></pre><pre><code class="python">[3, 38, 5, 44, 15, 36, 26, 27, 2, 46, 4, 19, 47, 48, 50][3, 5, 38, 15, 36, 26, 27, 2, 44, 4, 19, 46, 47, 48, 50][3, 5, 15, 36, 26, 27, 2, 38, 4, 19, 44, 46, 47, 48, 50][3, 5, 15, 26, 27, 2, 36, 4, 19, 38, 44, 46, 47, 48, 50][3, 5, 15, 26, 2, 27, 4, 19, 36, 38, 44, 46, 47, 48, 50][3, 5, 15, 2, 26, 4, 19, 27, 36, 38, 44, 46, 47, 48, 50][3, 5, 2, 15, 4, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][3, 2, 5, 4, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</code></pre><hr><h2 id="二、选择排序（Selection-Sort）"><a href="#二、选择排序（Selection-Sort）" class="headerlink" title="二、选择排序（Selection Sort）"></a><font color=#FF0000>二、选择排序（Selection Sort）</font></h2><h3 id="1、原理-1"><a href="#1、原理-1" class="headerlink" title="1、原理"></a>1、原理</h3><p>第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。可以理解为 一个 0 到 n-1 的迭代，每次向后查找选择一个最小的元素。选择排序是不稳定的排序方法。</p><p>假如有 10 个小盆友从左到右站成一排，个头不等。老师想让他们按照个头从低到高站好，我们从第一个开始，从头到尾找一个个头最小的小盆友，然后把它和第一个小盆友交换。 然后从第二个小盆友开始采取同样的策略，这样一圈下来小盆友就是有序的了。</p><h3 id="2、步骤-1"><a href="#2、步骤-1" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；</li><li><strong>②</strong> 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；</li><li><strong>③</strong> 重复步骤 <strong>②</strong>，直到所有元素均排序完毕。</li></ul><h3 id="3、动画演示-1"><a href="#3、动画演示-1" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/03%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="03选择排序"></p><h3 id="4、代码实现-1"><a href="#4、代码实现-1" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><p>Python 代码：</p><pre><code class="python">def selection_sort(arr):    for i in range(len(arr)-1):          # 循环第 i 趟        min_index = i                    # 记录最小数的下标        for j in range(i+1, len(arr)):   # j 为下标            if arr[j] &lt; arr[min_index]:  # 如果这个数小于记录的最小数，则更新最小数的下标                min_index = j        arr[i], arr[min_index] = arr[min_index], arr[i]  # 将 i 位置的数（已排序序列的末尾的数）和最小数进行交换    return arr</code></pre><h3 id="5、具体示例-1"><a href="#5、具体示例-1" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def selection_sort(arr):    for i in range(len(arr)-1):          # 循环第 i 趟        min_index = i                    # 记录最小数的下标        for j in range(i+1, len(arr)):   # j 为下标            if arr[j] &lt; arr[min_index]:  # 如果这个数小于记录的最小数，则更新最小数的下标                min_index = j        arr[i], arr[min_index] = arr[min_index], arr[i]  # 将 i 位置的数（已排序序列的末尾的数）和最小数进行交换        print(arr)                       # 每一趟比较完了就打印一次arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]selection_sort(arr)</code></pre><pre><code class="python">[2, 44, 38, 5, 47, 15, 36, 26, 27, 3, 46, 4, 19, 50, 48][2, 3, 38, 5, 47, 15, 36, 26, 27, 44, 46, 4, 19, 50, 48][2, 3, 4, 5, 47, 15, 36, 26, 27, 44, 46, 38, 19, 50, 48][2, 3, 4, 5, 47, 15, 36, 26, 27, 44, 46, 38, 19, 50, 48][2, 3, 4, 5, 15, 47, 36, 26, 27, 44, 46, 38, 19, 50, 48][2, 3, 4, 5, 15, 19, 36, 26, 27, 44, 46, 38, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 36, 27, 44, 46, 38, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 44, 46, 38, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 44, 46, 38, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 46, 44, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</code></pre><hr><h2 id="三、插入排序（Insertion-Sort）"><a href="#三、插入排序（Insertion-Sort）" class="headerlink" title="三、插入排序（Insertion Sort）"></a><font color=#FF0000>三、插入排序（Insertion Sort）</font></h2><h3 id="1、原理-2"><a href="#1、原理-2" class="headerlink" title="1、原理"></a>1、原理</h3><p>插入排序一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法。它的基本思想是将一个记录插入到已经排好序的有序表中，从而形成一个新的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素进行遍历，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。</p><p>插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。拿在左手上的牌总是排序好的，原来这些牌是桌子上牌堆中顶部的牌。</p><h3 id="2、步骤-2"><a href="#2、步骤-2" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 从第一个元素开始，该元素可以认为已经被排序；</li><li><strong>②</strong> 取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li><strong>③</strong> 如果该元素（已排序的）大于新元素，将该元素往右移到下一位置，重复该步骤，直到找到已排序的元素小于或者等于新元素的位置；</li><li><strong>④</strong> 将新元素插入到步骤 <strong>③</strong> 找到的位置的后面；</li><li><strong>⑤</strong> 重复步骤 <strong>②</strong> ~ <strong>④</strong>。</li></ul><h3 id="3、动画演示-2"><a href="#3、动画演示-2" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/04%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="04插入排序"></p><h3 id="4、代码实现-2"><a href="#4、代码实现-2" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def insertion_sort(arr):    for i in range(1, len(arr)):    # 将 i 看做摸到的牌的下标        tmp = arr[i]                # 将摸到的牌储存到 tmp        j = i-1                     # 将 j 看做手里的牌的下标        while j &gt;= 0 and arr[j] &gt; tmp:  # 如果手里的牌大于摸到的牌            arr[j+1] = arr[j]       # 将手里的牌往右移一个位置（将手里的牌赋值给下一个位置）            j -= 1                  # 将手里的牌的下标减 1，再次准备与摸到的牌进行比较        arr[j+1] = tmp              # 将摸到的牌插入到 j+1 位置    return arr</code></pre><h3 id="5、具体示例-2"><a href="#5、具体示例-2" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def insertion_sort(arr):    for i in range(1, len(arr)):    # 将 i 看做摸到的牌的下标        tmp = arr[i]                # 将摸到的牌储存到 tmp        j = i-1                     # 将 j 看做手里的牌的下标        while j &gt;= 0 and arr[j] &gt; tmp:  # 如果手里的牌大于摸到的牌            arr[j+1] = arr[j]       # 将手里的牌往右移一个位置（将手里的牌赋值给下一个位置）            j -= 1                  # 将手里的牌的下标减 1，再次准备与摸到的牌进行比较        arr[j+1] = tmp              # 将摸到的牌插入到 j+1 位置        print(arr)                  # 每一趟比较完了就打印一次arr = [0, 9, 8, 7, 1, 2, 3, 4, 5, 6]insertion_sort(arr)</code></pre><pre><code class="python">[0, 9, 8, 7, 1, 2, 3, 4, 5, 6]  # 手里第一张牌为 0，摸到 9，此时 i=1，j=0，0 比 9 小，将 9 插到索引 j+1=1 处。[0, 8, 9, 7, 1, 2, 3, 4, 5, 6]  # 手里的牌为 0，9，摸到 8，此时 i=2，j=1，9 比 8 大，将 9 右移一个位置，j-1=0，将 8 插到 j+1=1 处[0, 7, 8, 9, 1, 2, 3, 4, 5, 6][0, 1, 7, 8, 9, 2, 3, 4, 5, 6][0, 1, 2, 7, 8, 9, 3, 4, 5, 6][0, 1, 2, 3, 7, 8, 9, 4, 5, 6][0, 1, 2, 3, 4, 7, 8, 9, 5, 6][0, 1, 2, 3, 4, 5, 7, 8, 9, 6][0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><hr><h2 id="四、希尔排序（Shell-Sort）"><a href="#四、希尔排序（Shell-Sort）" class="headerlink" title="四、希尔排序（Shell Sort）"></a><font color=#FF0000>四、希尔排序（Shell Sort）</font></h2><h3 id="1、原理-3"><a href="#1、原理-3" class="headerlink" title="1、原理"></a>1、原理</h3><p>希尔排序是插入排序的一种更高效的改进版本，是一种分组插入排序算法，又称缩小增量排序（Diminishing Increment Sort），希尔排序是非稳定排序算法。该方法因 D.L.Shell 于 1959 年提出而得名。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h3 id="2、步骤-3"><a href="#2、步骤-3" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> n 为数组长度，首先取一个整数 <strong>d1=n/2</strong>，将元素分为 <strong>d1</strong> 个组，每组相邻量元素之间距离为 <strong>d1-1</strong>，在各组内进行直接插入排序；</li><li><strong>②</strong> 取第二个整数 <strong>d2=d1/2</strong>，重复步骤 <strong>①</strong> 分组排序过程，直到 <strong>di=1</strong>，即所有元素在同一组内进行直接插入排序。</li></ul><p>PS：希尔排序每趟并不使某些元素有序，而是使整体数据越来越接近有序；最后一趟排序使得所有数据有序。</p><h3 id="3、动画演示-3"><a href="#3、动画演示-3" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/05%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt="05希尔排序"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/06%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt="06希尔排序"></p><h3 id="4、代码实现-3"><a href="#4、代码实现-3" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def insertion_sort_gap(arr, gap):     # 将 gap 看做隔 gap 个距离摸一张牌，而不是依次按照顺序摸牌    for i in range(gap, len(arr)):    # 将 i 看做摸到的牌的下标        tmp = arr[i]                  # 将摸到的牌储存到 tmp        j = i-gap                     # 将 j 看做手里的牌的下标        while j &gt;= 0 and arr[j] &gt; tmp:  # 如果手里的牌大于摸到的牌            arr[j+gap] = arr[j]         # 将手里的牌往右移一个位置（将手里的牌赋值给下一个位置）            j -= gap                    # 将手里的牌的下标减 gap，再次准备与摸到的牌进行比较        arr[j+gap] = tmp                # 将摸到的牌插入到 j+gap 位置def shell_sort(arr):    d = len(arr) // 2                   # 第一次分组    while d &gt;= 1:        insertion_sort_gap(arr, d)      # 调用插入排序        d //= 2                         # 整除 2 后再次分组    return arr</code></pre><p>也可以不使用两个函数，写在一起即可：</p><pre><code class="python">def shell_sort(arr):    d = len(arr) // 2                   # 第一次分组    while d &gt;= 1:                       # 将 d 看做隔 d 个距离摸一张牌，而不是依次按照顺序摸牌        for i in range(d, len(arr)):    # 将 i 看做摸到的牌的下标            tmp = arr[i]                # 将摸到的牌储存到 tmp            j = i - d                   # 将 j 看做手里的牌的下标            while j &gt;= 0 and arr[j] &gt; tmp:   # 如果手里的牌大于摸到的牌                arr[j + d] = arr[j]          # 将手里的牌往右移一个位置（将手里的牌赋值给下一个位置）                j -= d                       # 将手里的牌的下标减 d，再次准备与摸到的牌进行比较            arr[j + d] = tmp                 # 将摸到的牌插入到 j+d 位置        d //= 2                              # 整除 2 后再次分组    return arr</code></pre><h3 id="5、具体示例-3"><a href="#5、具体示例-3" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def insertion_sort_gap(arr, gap):     # 将 gap 看做隔 gap 个距离摸一张牌，而不是依次按照顺序摸牌    for i in range(gap, len(arr)):    # 将 i 看做摸到的牌的下标        tmp = arr[i]                  # 将摸到的牌储存到 tmp        j = i-gap                     # 将 j 看做手里的牌的下标        while j &gt;= 0 and arr[j] &gt; tmp:  # 如果手里的牌大于摸到的牌            arr[j+gap] = arr[j]         # 将手里的牌往右移一个位置（将手里的牌赋值给下一个位置）            j -= gap                    # 将手里的牌的下标减 gap，再次准备与摸到的牌进行比较        arr[j+gap] = tmp                # 将摸到的牌插入到 j+gap 位置def shell_sort(arr):    d = len(arr) // 2                   # 第一次分组    while d &gt;= 1:        insertion_sort_gap(arr, d)      # 调用插入排序        print(arr)                      # 每一轮排序后打印一次        d //= 2                         # 整除 2 后再次分组arr = [5, 7, 4, 6, 3, 1, 2, 9, 8]shell_sort(arr)</code></pre><pre><code class="python">[3, 1, 2, 6, 5, 7, 4, 9, 8][2, 1, 3, 6, 4, 7, 5, 9, 8][1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><pre><code class="python">def shell_sort(arr):    d = len(arr) // 2                   # 第一次分组    while d &gt;= 1:                       # 将 d 看做隔 d 个距离摸一张牌，而不是依次按照顺序摸牌        for i in range(d, len(arr)):    # 将 i 看做摸到的牌的下标            tmp = arr[i]                # 将摸到的牌储存到 tmp            j = i - d                   # 将 j 看做手里的牌的下标            while j &gt;= 0 and arr[j] &gt; tmp:   # 如果手里的牌大于摸到的牌                arr[j + d] = arr[j]          # 将手里的牌往右移一个位置（将手里的牌赋值给下一个位置）                j -= d                       # 将手里的牌的下标减 d，再次准备与摸到的牌进行比较            arr[j + d] = tmp                 # 将摸到的牌插入到 j+d 位置        print(arr)                           # 每一轮排序后打印一次        d //= 2                              # 整除 2 后再次分组arr = [5, 7, 4, 6, 3, 1, 2, 9, 8]shell_sort(arr)</code></pre><pre><code class="python">[3, 1, 2, 6, 5, 7, 4, 9, 8][2, 1, 3, 6, 4, 7, 5, 9, 8][1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><hr><h2 id="五、归并排序（Merge-Sort）"><a href="#五、归并排序（Merge-Sort）" class="headerlink" title="五、归并排序（Merge Sort）"></a><font color=#FF0000>五、归并排序（Merge Sort）</font></h2><h3 id="1、原理-4"><a href="#1、原理-4" class="headerlink" title="1、原理"></a>1、原理</h3><p>归并的概念：假设一个列表分为两段，其中每一段都是有序列表，现在将该两段合并为一个有序列表，这种操作称为一次归并。</p><p>归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/08.png" alt="08"></p><h3 id="2、步骤-4"><a href="#2、步骤-4" class="headerlink" title="2、步骤"></a>2、步骤</h3><p><font color=#ff0000><strong>归并的基本步骤：</strong></font></p><ul><li><strong>①</strong> 申请空间，使其大小为<strong>两个已经排序序列之和</strong>，该空间用来存放合并后的序列；</li><li><strong>②</strong> 设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li><strong>③</strong> 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li><strong>④</strong> 重复步骤 <strong>③</strong> 直到某一指针达到序列尾；</li><li><strong>⑤</strong> 将另一序列剩下的所有元素直接复制到合并序列尾。</li></ul><p><font color=#ff0000><strong>归并排序的步骤：</strong></font></p><ul><li><strong>①</strong> 分解：将列表越分越小，直至分成一个元素，终止条件：一个元素是有序的。</li><li><strong>②</strong> 合并：不断将两个有序列表进行归并，列表越来越大，直到所有序列归并完毕。</li></ul><h3 id="3、动画演示-4"><a href="#3、动画演示-4" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/07%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="07归并排序"></p><h3 id="4、代码实现-4"><a href="#4、代码实现-4" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def merge(arr, low, mid, high):    # low 和 high 为整个数组的第一个和最后一个位置索引，mid 为中间位置索引    # i 和 j 为指针，最初位置分别为两个有序序列的起始位置    # ltmp 用来存放合并后的序列    i = low    j = mid+1    ltmp = []    while i &lt;= mid and j &lt;= high:  # 只要左右两边都有数        if arr[i] &lt; arr[j]:        # 当左边的数小于右边的数            ltmp.append(arr[i])    # 将左边的数存入 ltmp            i += 1                 # 左边的指针往右移一位        else:                      # 当右边的数小于左边的数            ltmp.append(arr[j])    # 将右边的数存入 ltmp            j += 1                 # 右边的指针往右移一位    # 上面的 while 语句执行完后，左边或者右边没有数了    while i &lt;= mid:                # 当左边还有数的时候        ltmp.append(arr[i])        # 将左边剩下的数全部存入 ltmp        i += 1    while j &lt;= high:               # 当右边还有数的时候        ltmp.append(arr[j])        # 将右边剩下的数全部存入 ltmp        j += 1    arr[low:high+1] = ltmp         # 将排序后的数组写回原数组def merge_sort(arr, low, high):       # low 和 high 为整个数组的第一个和最后一个位置索引    if low &lt; high:                    # 至少有两个元素        mid = (low + high) // 2        merge_sort(arr, low, mid)     # 把左边递归分解        merge_sort(arr, mid+1, high)  # 把右边递归分解        merge(arr, low, mid, high)    # 做归并</code></pre><h3 id="5、具体示例-4"><a href="#5、具体示例-4" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def merge(arr, low, mid, high):    # low 和 high 为整个数组的第一个和最后一个位置索引，mid 为中间位置索引    # i 和 j 为指针，最初位置分别为两个有序序列的起始位置    # ltmp 用来存放合并后的序列    i = low    j = mid+1    ltmp = []    while i &lt;= mid and j &lt;= high:  # 只要左右两边都有数        if arr[i] &lt; arr[j]:        # 当左边的数小于右边的数            ltmp.append(arr[i])    # 将左边的数存入 ltmp            i += 1                 # 左边的指针往右移一位        else:                      # 当右边的数小于左边的数            ltmp.append(arr[j])    # 将右边的数存入 ltmp            j += 1                 # 右边的指针往右移一位    # 上面的 while 语句执行完后，左边或者右边没有数了    while i &lt;= mid:                # 当左边还有数的时候        ltmp.append(arr[i])        # 将左边剩下的数全部存入 ltmp        i += 1    while j &lt;= high:               # 当右边还有数的时候        ltmp.append(arr[j])        # 将右边剩下的数全部存入 ltmp        j += 1    arr[low:high+1] = ltmp         # 将排序后的数组写回原数组def merge_sort(arr, low, high):       # low 和 high 为整个数组的第一个和最后一个位置索引    if low &lt; high:                    # 至少有两个元素        mid = (low + high) // 2        merge_sort(arr, low, mid)     # 把左边递归分解        merge_sort(arr, mid+1, high)  # 把右边递归分解        merge(arr, low, mid, high)    # 做归并        print(arr)                    # 每一次归并打印一次arr = [7, 1, 3, 2, 6, 9, 4]merge_sort(arr, 0, len(arr)-1)</code></pre><pre><code class="python">[1, 7, 3, 2, 6, 9, 4][1, 7, 2, 3, 6, 9, 4][1, 2, 3, 7, 6, 9, 4][1, 2, 3, 7, 6, 9, 4][1, 2, 3, 7, 4, 6, 9][1, 2, 3, 4, 6, 7, 9]</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/108987300未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="六、快速排序（Quick-Sort）"><a href="#六、快速排序（Quick-Sort）" class="headerlink" title="六、快速排序（Quick Sort）"></a><font color=#FF0000>六、快速排序（Quick Sort）</font></h2><h3 id="1、原理-5"><a href="#1、原理-5" class="headerlink" title="1、原理"></a>1、原理</h3><p>快速排序是对冒泡排序的一种改进。顾名思义快速排序就是快，而且效率高！它是处理大数据最快的排序算法之一了。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h3 id="2、步骤-5"><a href="#2、步骤-5" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 从数列中挑出一个元素，称为 “基准值”;</li><li><strong>②</strong> 重新排序数列，所有元素比基准值小的放在基准值的左边，比基准值大的放在基准值的右边（相同的数可以到任一边）。在这个分区退出之后，该基准值就处于数列的中间位置。这个称为分区（partition）操作，也可以称为一次归位操作，归位操作的过程见下动图；</li><li><strong>③</strong> 递归地把小于基准值元素的子数列和大于基准值元素的子数列按照步骤 <strong>① ②</strong> 排序。</li></ul><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/09%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="09快速排序"></p><h3 id="3、动画演示-5"><a href="#3、动画演示-5" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/10%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="10快速排序"></p><h3 id="4、代码实现-5"><a href="#4、代码实现-5" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def partition(arr, left, right):    # 归位操作，left，right 分别为数组左边和右边的位置索引    tmp = arr[left]    while left &lt; right:        while left &lt; right and arr[right] &gt;= tmp:  # 从右边找比 tmp 小的数，如果比 tmp 大，则移动指针            right -= 1                             # 将指针左移一个位置        arr[left] = arr[right]                     # 将右边的值写到左边的空位上        while left &lt; right and arr[left] &lt;= tmp:   # 从左边找比 tmp 大的数，如果比 tmp 小，则移动指针            left += 1                              # 将指针右移一个位置        arr[right] = arr[left]                     # 将左边的值写到右边的空位上    arr[left] = tmp                                # 把 tmp 归位    return left                   # 返回 left，right 都可以，目的是便于后面的递归操作对左右两部分进行排序def quick_sort(arr, left, right):          # 快速排序    if left &lt; right:        mid = partition(arr, left, right)        quick_sort(arr, left, mid-1)       # 对左半部分进行归位操作        quick_sort(arr, mid+1, right)      # 对右半部分进行归位操作    return arr</code></pre><h3 id="5、具体示例-5"><a href="#5、具体示例-5" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def partition(arr, left, right):    # 归位操作，left，right 分别为数组左边和右边的位置索引    tmp = arr[left]    while left &lt; right:        while left &lt; right and arr[right] &gt;= tmp:  # 从右边找比 tmp 小的数，如果比 tmp 大，则移动指针            right -= 1                             # 将指针左移一个位置        arr[left] = arr[right]                     # 将右边的值写到左边的空位上        while left &lt; right and arr[left] &lt;= tmp:   # 从左边找比 tmp 大的数，如果比 tmp 小，则移动指针            left += 1                              # 将指针右移一个位置        arr[right] = arr[left]                     # 将左边的值写到右边的空位上    arr[left] = tmp                                # 把 tmp 归位    return left                   # 返回 left，right 都可以，目的是便于后面的递归操作对左右两部分进行排序def quick_sort(arr, left, right):    if left &lt; right:        mid = partition(arr, left, right)        print(arr)                         # 每次归位后打印一次        quick_sort(arr, left, mid-1)       # 对左半部分进行归位操作        quick_sort(arr, mid+1, right)      # 对右半部分进行归位操作arr = [5, 7, 4, 6, 3, 1, 2, 9, 8]quick_sort(arr, 0, len(arr)-1)</code></pre><pre><code class="python">[2, 1, 4, 3, 5, 6, 7, 9, 8][1, 2, 4, 3, 5, 6, 7, 9, 8][1, 2, 3, 4, 5, 6, 7, 9, 8][1, 2, 3, 4, 5, 6, 7, 9, 8][1, 2, 3, 4, 5, 6, 7, 9, 8][1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><hr><h2 id="七、堆排序（Heap-Sort）"><a href="#七、堆排序（Heap-Sort）" class="headerlink" title="七、堆排序（Heap Sort）"></a><font color=#FF0000>七、堆排序（Heap Sort）</font></h2><h3 id="1、原理-6"><a href="#1、原理-6" class="headerlink" title="1、原理"></a>1、原理</h3><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><ul><li>堆：一种特殊的完全二叉树结构</li><li>大根堆：一棵完全二叉树，满足任一节点都比其孩子节点大</li><li>小根堆：一棵完全二叉树，满足任一节点都比其孩子节点小</li></ul><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/11%E5%A0%86%E6%8E%92%E5%BA%8F.png" alt="11堆排序"></p><h3 id="2、步骤-6"><a href="#2、步骤-6" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li>① 构建堆：将待排序序列构建成一个堆 H[0……n-1]，从最后一个非叶子结点开始，从左至右，从下至上进行调整。根据升序或降序需求选择大顶堆或小顶堆；</li><li>② 此时的堆顶元素，为最大或者最小元素；</li><li>③ 把堆顶元素和堆尾元素互换，调整堆，重新使堆有序；</li><li>④ 此时堆顶元素为第二大元素；</li><li>⑤ 重复以上步骤，直到堆变空。</li></ul><h3 id="3、动画演示-6"><a href="#3、动画演示-6" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/12%E6%9E%84%E5%BB%BA%E5%A0%86.gif" alt="12构建堆"></p><p>堆构建完成后再进行推排序：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/13%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="13堆排序"></p><h3 id="4、代码实现-6"><a href="#4、代码实现-6" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def sift(arr, low, high):    &quot;&quot;&quot;    :param li: 列表    :param low: 堆的根节点位置    :param high: 堆的最后一个元素的位置    &quot;&quot;&quot;    i = low                 # i最开始指向根节点    j = 2 * i + 1           # j开始是左孩子    tmp = arr[low]          # 把堆顶存起来    while j &lt;= high:        # 只要j位置有数        if j + 1 &lt;= high and arr[j+1] &gt; arr[j]:   # 如果右孩子有并且比较大            j = j + 1       # j指向右孩子        if arr[j] &gt; tmp:            arr[i] = arr[j]            i = j           # 往下看一层            j = 2 * i + 1        else:               # tmp更大，把tmp放到i的位置上            arr[i] = tmp    # 把tmp放到某一级领导位置上            break    else:        arr[i] = tmp        # 把tmp放到叶子节点上def heap_sort(arr):    n = len(arr)    for i in range((n-2)//2, -1, -1):   # i表示建堆的时候调整的部分的根的下标        sift(arr, i, n-1)    # 建堆完成    for i in range(n-1, -1, -1):        # i 指向当前堆的最后一个元素        arr[0], arr[i] = arr[i], arr[0]        sift(arr, 0, i - 1)             # i-1是新的high    return arr</code></pre><h3 id="5、具体示例-6"><a href="#5、具体示例-6" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def sift(arr, low, high):    &quot;&quot;&quot;    :param li: 列表    :param low: 堆的根节点位置    :param high: 堆的最后一个元素的位置    &quot;&quot;&quot;    i = low                 # i最开始指向根节点    j = 2 * i + 1           # j开始是左孩子    tmp = arr[low]          # 把堆顶存起来    while j &lt;= high:        # 只要j位置有数        if j + 1 &lt;= high and arr[j+1] &gt; arr[j]:   # 如果右孩子有并且比较大            j = j + 1       # j指向右孩子        if arr[j] &gt; tmp:            arr[i] = arr[j]            i = j           # 往下看一层            j = 2 * i + 1        else:               # tmp更大，把tmp放到i的位置上            arr[i] = tmp    # 把tmp放到某一级领导位置上            break    else:        arr[i] = tmp        # 把tmp放到叶子节点上def heap_sort(arr):    n = len(arr)    print(&#39;建堆过程：&#39;)    print(arr)    for i in range((n-2)//2, -1, -1):   # i表示建堆的时候调整的部分的根的下标        sift(arr, i, n-1)        print(arr)    # 建堆完成    print(&#39;堆排序过程：&#39;)    print(arr)    for i in range(n-1, -1, -1):        # i 指向当前堆的最后一个元素        arr[0], arr[i] = arr[i], arr[0]        sift(arr, 0, i - 1)             # i-1是新的high        print(arr)arr = [2, 7, 26, 25, 19, 17, 1, 90, 3, 36]heap_sort(arr)</code></pre><pre><code class="python">建堆过程：[2, 7, 26, 25, 19, 17, 1, 90, 3, 36][2, 7, 26, 25, 36, 17, 1, 90, 3, 19][2, 7, 26, 90, 36, 17, 1, 25, 3, 19][2, 7, 26, 90, 36, 17, 1, 25, 3, 19][2, 90, 26, 25, 36, 17, 1, 7, 3, 19][90, 36, 26, 25, 19, 17, 1, 7, 3, 2]堆排序过程：[90, 36, 26, 25, 19, 17, 1, 7, 3, 2][36, 25, 26, 7, 19, 17, 1, 2, 3, 90][26, 25, 17, 7, 19, 3, 1, 2, 36, 90][25, 19, 17, 7, 2, 3, 1, 26, 36, 90][19, 7, 17, 1, 2, 3, 25, 26, 36, 90][17, 7, 3, 1, 2, 19, 25, 26, 36, 90][7, 2, 3, 1, 17, 19, 25, 26, 36, 90][3, 2, 1, 7, 17, 19, 25, 26, 36, 90][2, 1, 3, 7, 17, 19, 25, 26, 36, 90][1, 2, 3, 7, 17, 19, 25, 26, 36, 90][1, 2, 3, 7, 17, 19, 25, 26, 36, 90]</code></pre><hr><h2 id="八、计数排序（Counting-Sort）"><a href="#八、计数排序（Counting-Sort）" class="headerlink" title="八、计数排序（Counting Sort）"></a><font color=#FF0000>八、计数排序（Counting Sort）</font></h2><h3 id="1、原理-7"><a href="#1、原理-7" class="headerlink" title="1、原理"></a>1、原理</h3><p>计数排序是一个非基于比较的排序算法，它的优势在于在对一定范围内的整数排序时，它的复杂度为 Ο(n+k)，其中 k 是整数的范围，快于任何比较排序算法。计数排序是一种牺牲空间换取时间的做法。计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，<strong>计数排序要求输入的数据必须是有确定范围的整数。</strong></p><h3 id="2、步骤-7"><a href="#2、步骤-7" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 找到待排序列表中的最大值 k，开辟一个长度为 k+1 的计数列表，计数列表中的值都为 0。</li><li><strong>②</strong> 遍历待排序列表，如果遍历到的元素值为 i，则计数列表中索引 i 的值加1。</li><li><strong>③</strong> 遍历完整个待排序列表，计数列表中索引 i 的值 j 表示 i 的个数为 j，统计出待排序列表中每个值的数量。</li><li><strong>④</strong> 创建一个新列表（也可以清空原列表，在原列表中添加），遍历计数列表，依次在新列表中添加 j 个 i，新列表就是排好序后的列表，整个过程没有比较待排序列表中的数据大小。</li></ul><h3 id="3、动画演示-7"><a href="#3、动画演示-7" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/14%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="14计数排序"></p><h3 id="4、代码实现-7"><a href="#4、代码实现-7" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def count_sort(arr):    if len(arr) &lt; 2:                       # 如果数组长度小于 2 则直接返回        return arr    max_num = max(arr)    count = [0 for _ in range(max_num+1)]  # 开辟一个计数列表    for val in arr:        count[val] += 1    arr.clear()                        # 原数组清空    for ind, val in enumerate(count):  # 遍历值和下标（值的数量）        for i in range(val):            arr.append(ind)    return arr</code></pre><h3 id="5、具体示例-7"><a href="#5、具体示例-7" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def count_sort(arr):    if len(arr) &lt; 2:                       # 如果数组长度小于 2 则直接返回        return arr    max_num = max(arr)    count = [0 for _ in range(max_num+1)]  # 开辟一个计数列表    for val in arr:        count[val] += 1    arr.clear()                        # 原数组清空    for ind, val in enumerate(count):  # 遍历值和下标（值的数量）        for i in range(val):            arr.append(ind)    return arrarr = [2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2]sorted_arr = count_sort(arr)print(sorted_arr)</code></pre><pre><code class="python">[1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]</code></pre><hr><h2 id="九、桶排序（Bucket-Sort）"><a href="#九、桶排序（Bucket-Sort）" class="headerlink" title="九、桶排序（Bucket Sort）"></a><font color=#FF0000>九、桶排序（Bucket Sort）</font></h2><h3 id="1、原理-8"><a href="#1、原理-8" class="headerlink" title="1、原理"></a>1、原理</h3><p>桶排序又叫箱排序，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。</p><p>桶排序也是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ul><li>在额外空间充足的情况下，尽量增大桶的数量；</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中。</li></ul><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><ul><li>最快情况：当输入的数据可以均匀的分配到每一个桶中；</li><li>最慢情况：当输入的数据被分配到了同一个桶中。</li></ul><h3 id="2、步骤-8"><a href="#2、步骤-8" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 创建一个定量的数组当作空桶子；</li><li><strong>②</strong> 遍历序列，把元素一个一个放到对应的桶子去；</li><li><strong>③</strong> 对每个不是空的桶子进行排序；</li><li><strong>④</strong> 从不是空的桶子里把元素再放回原来的序列中。</li></ul><h3 id="3、动画演示-8"><a href="#3、动画演示-8" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p>（动图来源于@五分钟学算法，侵删）</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/15%E6%A1%B6%E6%8E%92%E5%BA%8F.gif" alt="15桶排序"></p><h3 id="4、代码实现-8"><a href="#4、代码实现-8" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def bucket_sort(arr):    max_num = max(arr)    n = len(arr)    buckets = [[] for _ in range(n)]         # 创建桶    for var in arr:        i = min(var // (max_num // n), n-1)  # i 表示 var 放到几号桶里        buckets[i].append(var)               # 把 var 加到桶里边        # 保持桶内的顺序        for j in range(len(buckets[i])-1, 0, -1):            if buckets[i][j] &lt; buckets[i][j-1]:                buckets[i][j], buckets[i][j-1] = buckets[i][j-1], buckets[i][j]            else:                break    sorted_arr = []    for buc in buckets:        sorted_arr.extend(buc)    return sorted_arr</code></pre><h3 id="5、具体示例-8"><a href="#5、具体示例-8" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def bucket_sort(arr):    max_num = max(arr)    n = len(arr)    buckets = [[] for _ in range(n)]         # 创建桶    for var in arr:        i = min(var // (max_num // n), n-1)  # i 表示 var 放到几号桶里        buckets[i].append(var)               # 把 var 加到桶里边        # 保持桶内的顺序        for j in range(len(buckets[i])-1, 0, -1):            if buckets[i][j] &lt; buckets[i][j-1]:                buckets[i][j], buckets[i][j-1] = buckets[i][j-1], buckets[i][j]            else:                break    sorted_arr = []    for buc in buckets:        sorted_arr.extend(buc)    return sorted_arrarr = [7, 12, 56, 23, 19, 33, 35, 42, 42, 2, 8, 22, 39, 26, 17]sorted_arr = bucket_sort(arr)print(sorted_arr)</code></pre><pre><code class="python">[2, 7, 8, 12, 17, 19, 22, 23, 26, 33, 35, 39, 42, 42, 56]</code></pre><hr><h2 id="十、基数排序（Radix-Sort）"><a href="#十、基数排序（Radix-Sort）" class="headerlink" title="十、基数排序（Radix Sort）"></a><font color=#FF0000>十、基数排序（Radix Sort）</font></h2><h3 id="1、原理-9"><a href="#1、原理-9" class="headerlink" title="1、原理"></a>1、原理</h3><p>基数排序属于分配式排序，是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p>基数排序、计数排序、桶排序三种排序算法都利用了桶的概念，但对桶的使用方法上是有明显差异的：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值。</li></ul><h3 id="2、步骤-9"><a href="#2、步骤-9" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 取数组中的最大数，并取得位数；</li><li><strong>②</strong> 从最低位开始，依次进行一次排序；</li><li><strong>③</strong> 从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li></ul><h3 id="3、动画演示-9"><a href="#3、动画演示-9" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/16%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="16基数排序"></p><h3 id="4、代码实现-9"><a href="#4、代码实现-9" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def radix_sort(li):    max_num = max(li)      # 最大值 9-&gt;1次循环, 99-&gt;2次循环, 888-&gt;3次循环, 10000-&gt;5次循环    it = 0    while 10 ** it &lt;= max_num:        buckets = [[] for _ in range(10)]        for var in li:            # var=987, it=1, 987//10-&gt;98, 98%10-&gt;8; it=2, 987//100-&gt;9, 9%10=9            digit = (var // 10 ** it) % 10   # 依次取一位数            buckets[digit].append(var)        # 分桶完成        li.clear()        for buc in buckets:            li.extend(buc)        it += 1            # 把数重新写回 li    return arr</code></pre><h3 id="5、具体示例-9"><a href="#5、具体示例-9" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def radix_sort(li):    max_num = max(li)      # 最大值 9-&gt;1次循环, 99-&gt;2次循环, 888-&gt;3次循环, 10000-&gt;5次循环    it = 0    while 10 ** it &lt;= max_num:        buckets = [[] for _ in range(10)]        for var in li:            # var=987, it=1, 987//10-&gt;98, 98%10-&gt;8; it=2, 987//100-&gt;9, 9%10=9            digit = (var // 10 ** it) % 10   # 依次取一位数            buckets[digit].append(var)        # 分桶完成        li.clear()        for buc in buckets:            li.extend(buc)        it += 1            # 把数重新写回 li    return arrarr = [3221, 1, 10, 9680, 577, 9420, 7, 5622, 4793, 2030, 3138, 82, 2599, 743, 4127]sorted_arr = radix_sort(arr)print(sorted_arr)</code></pre><pre><code class="python">[1, 7, 10, 82, 577, 743, 2030, 2599, 3138, 3221, 4127, 4793, 5622, 9420, 9680]</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/108987300未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;参考资料：&lt;a href=&quot;https://www.bilibili.com/video/BV1mp4y1D7UP&quot;&gt;https://www.bilibili.com/video/BV1mp4y1D7UP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文动图演示来源：&lt;a hre</summary>
      
    
    
    
    <category term="算法" scheme="https://www.itbob.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="算法" scheme="https://www.itbob.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>COVID-19 肺炎疫情数据实时监控（python 爬虫 + pyecharts 数据可视化 + wordcloud 词云图）</title>
    <link href="https://www.itbob.cn/article/035/"/>
    <id>https://www.itbob.cn/article/035/</id>
    <published>2020-07-06T04:49:35.000Z</published>
    <updated>2022-05-22T12:46:00.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/107140534未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】前言"><a href="#【1x00】前言" class="headerlink" title="【1x00】前言"></a><font color=#FF0000>【1x00】前言</font></h2><p>本来两三个月之前就想搞个疫情数据实时数据展示的，由于各种不可抗拒因素一而再再而三的鸽了，最近终于抽空写了一个，数据是用 Python 爬取的<a href="https://voice.baidu.com/act/newpneumonia/newpneumonia/">百度疫情实时大数据报告</a>，请求库用的 requests，解析用的 Xpath 语法，词云用的 wordcloud 库，数据可视化用 pyecharts 绘制的地图和折线图，数据储存在 Excel 表格里面，使用 openpyxl 对表格进行处理。</p><p>本程序实现了累计确诊地图展示和每日数据变化折线图展示，其他更多数据的获取和展示均可在程序中进行拓展，可以将程序部署在服务器上，设置定时运行，即可实时展示数据，pyecharts 绘图模块也可以整合到 Web 框架（Django、Flask等）中使用。</p><p>在获取数据时有<font color=#FF0000><strong>全球</strong></font>和<font color=#FF0000><strong>境外</strong></font>两个概念，全球包含中国，境外不包含中国，后期绘制的四个图：中国累计确诊地图、全球累计确诊地图（包含中国）、中国每日数据折线图、境外每日数据折线图（不包含中国）。</p><p><font color=#FF0000><strong>注意项：直接向该网页发送请求获取的响应中，没有每个国家的每日数据，该数据获取的地址是：<a href="https://voice.baidu.com/newpneumonia/get?target=trend&isCaseIn=1&stage=publish">https://voice.baidu.com/newpneumonia/get?target=trend&amp;isCaseIn=1&amp;stage=publish</a></strong></font></p><ul><li><strong>预览地址</strong>：<del><a href="http://cov.itrhx.com/">http://cov.itrhx.com/</a></del>（已失效）</li><li><strong>数据来源</strong>：<a href="https://voice.baidu.com/act/newpneumonia/newpneumonia/">https://voice.baidu.com/act/newpneumonia/newpneumonia/</a></li><li><strong>pyecharts 文档</strong>：<a href="https://pyecharts.org/">https://pyecharts.org/</a></li><li><strong>openpyxl 文档</strong>：<a href="https://openpyxl.readthedocs.io/">https://openpyxl.readthedocs.io/</a></li><li><strong>wordcloud 文档</strong>：<a href="http://amueller.github.io/word_cloud/">http://amueller.github.io/word_cloud/</a></li></ul><h2 id="【2x00】思维导图"><a href="#【2x00】思维导图" class="headerlink" title="【2x00】思维导图"></a><font color=#FF0000>【2x00】思维导图</font></h2><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/01.png" alt="01"></p><h2 id="【3x00】数据结构分析"><a href="#【3x00】数据结构分析" class="headerlink" title="【3x00】数据结构分析"></a><font color=#FF0000>【3x00】数据结构分析</font></h2><p>通过查看百度的疫情数据页面，可以看到很多整齐的数据，猜测就是疫情相关的数据，保存该页面，对其进行格式化，很容易可以分析出所有的数据都在 <code>&lt;script type=&quot;application/json&quot; id=&quot;captain-config&quot;&gt;&lt;/script&gt;</code> 里面，其中 title 里面是一些 Unicode 编码，将其转为中文后更容易得到不同的分类数据。</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/02.png" alt="02"></p><p>由于数据繁多，可以将数据主体部分提取出来，删除一些重复项和其他杂项，留下数据大体位置并分析数据结构，便于后期的数据提取，经过处理后的数据大致结构如下：</p><pre><code class="json">&lt;script type=&quot;application/json&quot; id=&quot;captain-config&quot;&gt;    &#123;        &quot;component&quot;: [            &#123;                &quot;mapLastUpdatedTime&quot;: &quot;2020.07.05 16:13&quot;,        // 国内疫情数据最后更新时间                &quot;caseList&quot;: [                                    // caseList 列表，每一个元素是一个字典                    &#123;                        &quot;confirmed&quot;: &quot;1&quot;,                        // 每个字典包含中国每个省的每一项疫情数据                        &quot;died&quot;: &quot;0&quot;,                        &quot;crued&quot;: &quot;1&quot;,                        &quot;relativeTime&quot;: &quot;1593792000&quot;,                        &quot;confirmedRelative&quot;: &quot;0&quot;,                        &quot;diedRelative&quot;: &quot;0&quot;,                        &quot;curedRelative&quot;: &quot;0&quot;,                        &quot;curConfirm&quot;: &quot;0&quot;,                        &quot;curConfirmRelative&quot;: &quot;0&quot;,                        &quot;icuDisable&quot;: &quot;1&quot;,                        &quot;area&quot;: &quot;西藏&quot;,                        &quot;subList&quot;: [                            // subList 列表，每一个元素是一个字典                            &#123;                                &quot;city&quot;: &quot;拉萨&quot;,                 // 每个字典包含该省份对应的每个城市疫情数据                                &quot;confirmed&quot;: &quot;1&quot;,                                &quot;died&quot;: &quot;0&quot;,                                &quot;crued&quot;: &quot;1&quot;,                                &quot;confirmedRelative&quot;: &quot;0&quot;,                                &quot;curConfirm&quot;: &quot;0&quot;,                                &quot;cityCode&quot;: &quot;100&quot;                            &#125;                        ]                    &#125;                ],                &quot;caseOutsideList&quot;: [                           // caseOutsideList 列表，每一个元素是一个字典                    &#123;                        &quot;confirmed&quot;: &quot;241419&quot;,                 // 每个字典包含各国的每一项疫情数据                        &quot;died&quot;: &quot;34854&quot;,                        &quot;crued&quot;: &quot;191944&quot;,                        &quot;relativeTime&quot;: &quot;1593792000&quot;,                        &quot;confirmedRelative&quot;: &quot;223&quot;,                        &quot;curConfirm&quot;: &quot;14621&quot;,                        &quot;icuDisable&quot;: &quot;1&quot;,                        &quot;area&quot;: &quot;意大利&quot;,                        &quot;subList&quot;: [                          // subList 列表，每一个元素是一个字典                            &#123;                                &quot;city&quot;: &quot;伦巴第&quot;,              // 每个字典包含每个国家对应的每个城市疫情数据                                &quot;confirmed&quot;: &quot;94318&quot;,                                &quot;died&quot;: &quot;16691&quot;,                                &quot;crued&quot;: &quot;68201&quot;,                                &quot;curConfirm&quot;: &quot;9426&quot;                            &#125;                        ]                    &#125;                ],                &quot;summaryDataIn&quot;: &#123;                           // summaryDataIn 国内总的疫情数据                    &quot;confirmed&quot;: &quot;85307&quot;,                    &quot;died&quot;: &quot;4648&quot;,                    &quot;cured&quot;: &quot;80144&quot;,                    &quot;asymptomatic&quot;: &quot;99&quot;,                    &quot;asymptomaticRelative&quot;: &quot;7&quot;,                    &quot;unconfirmed&quot;: &quot;7&quot;,                    &quot;relativeTime&quot;: &quot;1593792000&quot;,                    &quot;confirmedRelative&quot;: &quot;19&quot;,                    &quot;unconfirmedRelative&quot;: &quot;1&quot;,                    &quot;curedRelative&quot;: &quot;27&quot;,                    &quot;diedRelative&quot;: &quot;0&quot;,                    &quot;icu&quot;: &quot;6&quot;,                    &quot;icuRelative&quot;: &quot;0&quot;,                    &quot;overseasInput&quot;: &quot;1931&quot;,                    &quot;unOverseasInputCumulative&quot;: &quot;83375&quot;,                    &quot;overseasInputRelative&quot;: &quot;6&quot;,                    &quot;unOverseasInputNewAdd&quot;: &quot;13&quot;,                    &quot;curConfirm&quot;: &quot;515&quot;,                    &quot;curConfirmRelative&quot;: &quot;-8&quot;,                    &quot;icuDisable&quot;: &quot;1&quot;                &#125;,                &quot;summaryDataOut&quot;: &#123;                           // summaryDataOut 国外总的疫情数据                    &quot;confirmed&quot;: &quot;11302569&quot;,                    &quot;died&quot;: &quot;528977&quot;,                    &quot;curConfirm&quot;: &quot;4410601&quot;,                    &quot;cured&quot;: &quot;6362991&quot;,                    &quot;confirmedRelative&quot;: &quot;206165&quot;,                    &quot;curedRelative&quot;: &quot;190018&quot;,                    &quot;diedRelative&quot;: &quot;4876&quot;,                    &quot;curConfirmRelative&quot;: &quot;11271&quot;,                    &quot;relativeTime&quot;: &quot;1593792000&quot;                &#125;,                &quot;trend&quot;: &#123;                                    // trend 字典，包含国内每日的疫情数据                    &quot;updateDate&quot;: [],                         // 日期                    &quot;list&quot;: [                                 // list 列表，每项数据及其对应的值                        &#123;                            &quot;name&quot;: &quot;确诊&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;疑似&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;治愈&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;死亡&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;新增确诊&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;新增疑似&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;新增治愈&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;新增死亡&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;累计境外输入&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;新增境外输入&quot;,                            &quot;data&quot;: []                        &#125;                    ]                &#125;,                &quot;foreignLastUpdatedTime&quot;: &quot;2020.07.05 16:13&quot;,       // 国外疫情数据最后更新时间                &quot;globalList&quot;: [                                     // globalList 列表，每一个元素是一个字典                    &#123;                        &quot;area&quot;: &quot;亚洲&quot;,                              // 按照不同洲进行分类                        &quot;subList&quot;: [                                // subList 列表，每个洲各个国家的疫情数据                            &#123;                                &quot;died&quot;: &quot;52&quot;,                                &quot;confirmed&quot;: &quot;6159&quot;,                                &quot;crued&quot;: &quot;4809&quot;,                                &quot;curConfirm&quot;: &quot;1298&quot;,                                &quot;confirmedRelative&quot;: &quot;0&quot;,                                &quot;relativeTime&quot;: &quot;1593792000&quot;,                                &quot;country&quot;: &quot;塔吉克斯坦&quot;                            &#125;                        ],                        &quot;died&quot;: &quot;56556&quot;,                            // 每个洲总的疫情数据                        &quot;crued&quot;: &quot;1625562&quot;,                        &quot;confirmed&quot;: &quot;2447873&quot;,                        &quot;curConfirm&quot;: &quot;765755&quot;,                        &quot;confirmedRelative&quot;: &quot;60574&quot;                    &#125;,                    &#123;                        &quot;area&quot;: &quot;其他&quot;,                             // 其他特殊区域疫情数据                        &quot;subList&quot;: [                            &#123;                                &quot;died&quot;: &quot;13&quot;,                                &quot;confirmed&quot;: &quot;712&quot;,                                &quot;crued&quot;: &quot;651&quot;,                                &quot;curConfirm&quot;: &quot;48&quot;,                                &quot;confirmedRelative&quot;: &quot;0&quot;,                                &quot;relativeTime&quot;: &quot;1593792000&quot;,                                &quot;country&quot;: &quot;钻石公主号邮轮&quot;                            &#125;                        ],                        &quot;died&quot;: &quot;13&quot;,                              // 其他特殊区域疫情总的数据                        &quot;crued&quot;: &quot;651&quot;,                        &quot;confirmed&quot;: &quot;712&quot;,                        &quot;curConfirm&quot;: &quot;48&quot;,                        &quot;confirmedRelative&quot;: &quot;0&quot;                    &#125;,                    &#123;                        &quot;area&quot;: &quot;热门&quot;,                            // 热门国家疫情数据                        &quot;subList&quot;: [                            &#123;                                &quot;died&quot;: &quot;5206&quot;,                                &quot;confirmed&quot;: &quot;204610&quot;,                                &quot;crued&quot;: &quot;179492&quot;,                                &quot;curConfirm&quot;: &quot;19912&quot;,                                &quot;confirmedRelative&quot;: &quot;1172&quot;,                                &quot;relativeTime&quot;: &quot;1593792000&quot;,                                &quot;country&quot;: &quot;土耳其&quot;                            &#125;                        ],                        &quot;died&quot;: &quot;528967&quot;,                         // 热门国家疫情总的数据                        &quot;crued&quot;: &quot;6362924&quot;,                        &quot;confirmed&quot;: &quot;11302357&quot;,                        &quot;confirmedRelative&quot;: &quot;216478&quot;,                        &quot;curConfirm&quot;: &quot;4410466&quot;                    &#125;],                &quot;allForeignTrend&quot;: &#123;                            // allForeignTrend 字典，包含国外每日的疫情数据                        &quot;updateDate&quot;: [],                       // 日期                        &quot;list&quot;: [                               // list 列表，每项数据及其对应的值                            &#123;                                &quot;name&quot;: &quot;累计确诊&quot;,                                &quot;data&quot;: []                            &#125;,                            &#123;                                &quot;name&quot;: &quot;治愈&quot;,                                &quot;data&quot;: []                            &#125;,                            &#123;                                &quot;name&quot;: &quot;死亡&quot;,                                &quot;data&quot;: []                            &#125;,                            &#123;                                &quot;name&quot;: &quot;现有确诊&quot;,                                &quot;data&quot;: []                            &#125;,                            &#123;                                &quot;name&quot;: &quot;新增确诊&quot;,                                &quot;data&quot;: []                            &#125;                        ]                    &#125;,                &quot;topAddCountry&quot;: [                    // 确诊增量最高的国家                        &#123;                            &quot;name&quot;: &quot;美国&quot;,                            &quot;value&quot;: 53162                        &#125;                    ],                &quot;topOverseasInput&quot;: [                // 境外输入最多的省份                    &#123;                        &quot;name&quot;: &quot;黑龙江&quot;,                        &quot;value&quot;: 386                    &#125;                ]            &#125;        ]    &#125;&lt;/script&gt;</code></pre><h2 id="【4x00】主函数-main"><a href="#【4x00】主函数-main" class="headerlink" title="【4x00】主函数 main()"></a><font color=#FF0000>【4x00】主函数 main()</font></h2><p>分别将数据获取、词云图绘制、地图绘制写入三个文件：<code>data_get()</code>、<code>data_wordcloud()</code>、<code>data_map()</code>，然后使用一个主函数文件 main.py 来调用这三个文件里面的函数。</p><pre><code class="python">import data_getimport data_wordcloudimport data_mapdata_dict = data_get.init()data_get.china_total_data(data_dict)data_get.global_total_data(data_dict)data_get.china_daily_data(data_dict)data_get.foreign_daily_data(data_dict)data_wordcloud.china_wordcloud()data_wordcloud.global_wordcloud()data_map.all_map()</code></pre><h2 id="【5x00】数据获取模块-data-get"><a href="#【5x00】数据获取模块-data-get" class="headerlink" title="【5x00】数据获取模块 data_get"></a><font color=#FF0000>【5x00】数据获取模块 data_get</font></h2><h3 id="【5x01】初始化函数-init"><a href="#【5x01】初始化函数-init" class="headerlink" title="【5x01】初始化函数 init()"></a><font color="#4876FF">【5x01】初始化函数 init()</font></h3><p>使用 xpath 语法 <code>//script[@id=&quot;captain-config&quot;]/text()</code> 提取里面的值，利用 <code>json.loads</code> 方法将其转换为字典对象，以便后续的其他函数调用。</p><pre><code class="python">def init():    headers = &#123;        &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.13 Safari/537.36&#39;    &#125;    url = &#39;https://voice.baidu.com/act/newpneumonia/newpneumonia/&#39;    response = requests.get(url=url, headers=headers)    tree = etree.HTML(response.text)    dict1 = tree.xpath(&#39;//script[@id=&quot;captain-config&quot;]/text()&#39;)    print(type(dict1[0]))    dict2 = json.loads(dict1[0])    return dict2</code></pre><h3 id="【5x02】中国总数据-china-total-data"><a href="#【5x02】中国总数据-china-total-data" class="headerlink" title="【5x02】中国总数据 china_total_data()"></a><font color="#4876FF">【5x02】中国总数据 china_total_data()</font></h3><pre><code class="python">def china_total_data(data):    &quot;&quot;&quot;    1、中国省/直辖市/自治区/行政区疫情数据    省/直辖市/自治区/行政区：area    现有确诊：    curConfirm    累计确诊：    confirmed    累计治愈：    crued    累计死亡：    died    现有确诊增量： curConfirmRelative    累计确诊增量： confirmedRelative    累计治愈增量： curedRelative    累计死亡增量： diedRelative    &quot;&quot;&quot;    wb = openpyxl.Workbook()            # 创建工作簿    ws_china = wb.active                # 获取工作表    ws_china.title = &quot;中国省份疫情数据&quot;   # 命名工作表    ws_china.append([&#39;省/直辖市/自治区/行政区&#39;, &#39;现有确诊&#39;, &#39;累计确诊&#39;, &#39;累计治愈&#39;,                     &#39;累计死亡&#39;, &#39;现有确诊增量&#39;, &#39;累计确诊增量&#39;,                     &#39;累计治愈增量&#39;, &#39;累计死亡增量&#39;])    china = data[&#39;component&#39;][0][&#39;caseList&#39;]    for province in china:        ws_china.append([province[&#39;area&#39;],                        province[&#39;curConfirm&#39;],                        province[&#39;confirmed&#39;],                        province[&#39;crued&#39;],                        province[&#39;died&#39;],                        province[&#39;curConfirmRelative&#39;],                        province[&#39;confirmedRelative&#39;],                        province[&#39;curedRelative&#39;],                        province[&#39;diedRelative&#39;]])    &quot;&quot;&quot;    2、中国城市疫情数据    城市：city    现有确诊：curConfirm    累计确诊：confirmed    累计治愈：crued    累计死亡：died    累计确诊增量：confirmedRelative    &quot;&quot;&quot;    ws_city = wb.create_sheet(&#39;中国城市疫情数据&#39;)    ws_city.append([&#39;城市&#39;, &#39;现有确诊&#39;, &#39;累计确诊&#39;,                    &#39;累计治愈&#39;, &#39;累计死亡&#39;, &#39;累计确诊增量&#39;])    for province in china:        for city in province[&#39;subList&#39;]:            # 某些城市没有 curConfirm 数据，则将其设置为 0，crued 和 died 为空时，替换成 0            if &#39;curConfirm&#39; not in city:                city[&#39;curConfirm&#39;] = &#39;0&#39;            if city[&#39;crued&#39;] == &#39;&#39;:                city[&#39;crued&#39;] = &#39;0&#39;            if city[&#39;died&#39;] == &#39;&#39;:                city[&#39;died&#39;] = &#39;0&#39;            ws_city.append([city[&#39;city&#39;], &#39;0&#39;, city[&#39;confirmed&#39;],                           city[&#39;crued&#39;], city[&#39;died&#39;], city[&#39;confirmedRelative&#39;]])    &quot;&quot;&quot;    3、中国疫情数据更新时间：mapLastUpdatedTime    &quot;&quot;&quot;    time_domestic = data[&#39;component&#39;][0][&#39;mapLastUpdatedTime&#39;]    ws_time = wb.create_sheet(&#39;中国疫情数据更新时间&#39;)    ws_time.column_dimensions[&#39;A&#39;].width = 22  # 调整列宽    ws_time.append([&#39;中国疫情数据更新时间&#39;])    ws_time.append([time_domestic])    wb.save(&#39;COVID-19-China.xlsx&#39;)    print(&#39;中国疫情数据已保存至 COVID-19-China.xlsx！&#39;)</code></pre><h3 id="【5x03】全球总数据-global-total-data"><a href="#【5x03】全球总数据-global-total-data" class="headerlink" title="【5x03】全球总数据 global_total_data()"></a><font color="#4876FF">【5x03】全球总数据 global_total_data()</font></h3><p>全球总数据在提取完成后，进行地图绘制时发现并没有中国的数据，因此在写入全球数据时注意要单独将中国的数据插入 Excel 中。</p><pre><code class="python">def global_total_data(data):    &quot;&quot;&quot;    1、全球各国疫情数据    国家：country    现有确诊：curConfirm    累计确诊：confirmed    累计治愈：crued    累计死亡：died    累计确诊增量：confirmedRelative    &quot;&quot;&quot;    wb = openpyxl.Workbook()    ws_global = wb.active    ws_global.title = &quot;全球各国疫情数据&quot;    # 按照国家保存数据    countries = data[&#39;component&#39;][0][&#39;caseOutsideList&#39;]    ws_global.append([&#39;国家&#39;, &#39;现有确诊&#39;, &#39;累计确诊&#39;, &#39;累计治愈&#39;, &#39;累计死亡&#39;, &#39;累计确诊增量&#39;])    for country in countries:        ws_global.append([country[&#39;area&#39;],                          country[&#39;curConfirm&#39;],                          country[&#39;confirmed&#39;],                          country[&#39;crued&#39;],                          country[&#39;died&#39;],                          country[&#39;confirmedRelative&#39;]])    # 按照洲保存数据    continent = data[&#39;component&#39;][0][&#39;globalList&#39;]    for area in continent:        ws_foreign = wb.create_sheet(area[&#39;area&#39;] + &#39;疫情数据&#39;)        ws_foreign.append([&#39;国家&#39;, &#39;现有确诊&#39;, &#39;累计确诊&#39;, &#39;累计治愈&#39;, &#39;累计死亡&#39;, &#39;累计确诊增量&#39;])        for country in area[&#39;subList&#39;]:            ws_foreign.append([country[&#39;country&#39;],                               country[&#39;curConfirm&#39;],                               country[&#39;confirmed&#39;],                               country[&#39;crued&#39;],                               country[&#39;died&#39;],                               country[&#39;confirmedRelative&#39;]])    # 在“全球各国疫情数据”和“亚洲疫情数据”两张表中写入中国疫情数据    ws1, ws2 = wb[&#39;全球各国疫情数据&#39;], wb[&#39;亚洲疫情数据&#39;]    original_data = data[&#39;component&#39;][0][&#39;summaryDataIn&#39;]    add_china_data = [&#39;中国&#39;,                      original_data[&#39;curConfirm&#39;],                      original_data[&#39;confirmed&#39;],                      original_data[&#39;cured&#39;],                      original_data[&#39;died&#39;],                      original_data[&#39;confirmedRelative&#39;]]    ws1.append(add_china_data)    ws2.append(add_china_data)    &quot;&quot;&quot;    2、全球疫情数据更新时间：foreignLastUpdatedTime    &quot;&quot;&quot;    time_foreign = data[&#39;component&#39;][0][&#39;foreignLastUpdatedTime&#39;]    ws_time = wb.create_sheet(&#39;全球疫情数据更新时间&#39;)    ws_time.column_dimensions[&#39;A&#39;].width = 22  # 调整列宽    ws_time.append([&#39;全球疫情数据更新时间&#39;])    ws_time.append([time_foreign])    wb.save(&#39;COVID-19-Global.xlsx&#39;)    print(&#39;全球疫情数据已保存至 COVID-19-Global.xlsx！&#39;)</code></pre><h3 id="【5x04】中国每日数据-china-daily-data"><a href="#【5x04】中国每日数据-china-daily-data" class="headerlink" title="【5x04】中国每日数据 china_daily_data()"></a><font color="#4876FF">【5x04】中国每日数据 china_daily_data()</font></h3><pre><code class="python">def china_daily_data(data):    &quot;&quot;&quot;    i_dict = data[&#39;component&#39;][0][&#39;trend&#39;]    i_dict[&#39;updateDate&#39;]：日期    i_dict[&#39;list&#39;][0]：确诊    i_dict[&#39;list&#39;][1]：疑似    i_dict[&#39;list&#39;][2]：治愈    i_dict[&#39;list&#39;][3]：死亡    i_dict[&#39;list&#39;][4]：新增确诊    i_dict[&#39;list&#39;][5]：新增疑似    i_dict[&#39;list&#39;][6]：新增治愈    i_dict[&#39;list&#39;][7]：新增死亡    i_dict[&#39;list&#39;][8]：累计境外输入    i_dict[&#39;list&#39;][9]：新增境外输入    &quot;&quot;&quot;    ccd_dict = data[&#39;component&#39;][0][&#39;trend&#39;]    update_date = ccd_dict[&#39;updateDate&#39;]              # 日期    china_confirmed = ccd_dict[&#39;list&#39;][0][&#39;data&#39;]     # 每日累计确诊数据    china_crued = ccd_dict[&#39;list&#39;][2][&#39;data&#39;]         # 每日累计治愈数据    china_died = ccd_dict[&#39;list&#39;][3][&#39;data&#39;]          # 每日累计死亡数据    wb = openpyxl.load_workbook(&#39;COVID-19-China.xlsx&#39;)    # 写入每日累计确诊数据    ws_china_confirmed = wb.create_sheet(&#39;中国每日累计确诊数据&#39;)    ws_china_confirmed.append([&#39;日期&#39;, &#39;数据&#39;])    for data in zip(update_date, china_confirmed):        ws_china_confirmed.append(data)    # 写入每日累计治愈数据    ws_china_crued = wb.create_sheet(&#39;中国每日累计治愈数据&#39;)    ws_china_crued.append([&#39;日期&#39;, &#39;数据&#39;])    for data in zip(update_date, china_crued):        ws_china_crued.append(data)    # 写入每日累计死亡数据    ws_china_died = wb.create_sheet(&#39;中国每日累计死亡数据&#39;)    ws_china_died.append([&#39;日期&#39;, &#39;数据&#39;])    for data in zip(update_date, china_died):        ws_china_died.append(data)    wb.save(&#39;COVID-19-China.xlsx&#39;)    print(&#39;中国每日累计确诊/治愈/死亡数据已保存至 COVID-19-China.xlsx！&#39;)</code></pre><h3 id="【5x05】境外每日数据-foreign-daily-data"><a href="#【5x05】境外每日数据-foreign-daily-data" class="headerlink" title="【5x05】境外每日数据 foreign_daily_data()"></a><font color="#4876FF">【5x05】境外每日数据 foreign_daily_data()</font></h3><pre><code class="python">def foreign_daily_data(data):    &quot;&quot;&quot;    te_dict = data[&#39;component&#39;][0][&#39;allForeignTrend&#39;]    te_dict[&#39;updateDate&#39;]：日期    te_dict[&#39;list&#39;][0]：累计确诊    te_dict[&#39;list&#39;][1]：治愈    te_dict[&#39;list&#39;][2]：死亡    te_dict[&#39;list&#39;][3]：现有确诊    te_dict[&#39;list&#39;][4]：新增确诊    &quot;&quot;&quot;    te_dict = data[&#39;component&#39;][0][&#39;allForeignTrend&#39;]    update_date = te_dict[&#39;updateDate&#39;]                # 日期    foreign_confirmed = te_dict[&#39;list&#39;][0][&#39;data&#39;]     # 每日累计确诊数据    foreign_crued = te_dict[&#39;list&#39;][1][&#39;data&#39;]         # 每日累计治愈数据    foreign_died = te_dict[&#39;list&#39;][2][&#39;data&#39;]          # 每日累计死亡数据    wb = openpyxl.load_workbook(&#39;COVID-19-Global.xlsx&#39;)    # 写入每日累计确诊数据    ws_foreign_confirmed = wb.create_sheet(&#39;境外每日累计确诊数据&#39;)    ws_foreign_confirmed.append([&#39;日期&#39;, &#39;数据&#39;])    for data in zip(update_date, foreign_confirmed):        ws_foreign_confirmed.append(data)    # 写入累计治愈数据    ws_foreign_crued = wb.create_sheet(&#39;境外每日累计治愈数据&#39;)    ws_foreign_crued.append([&#39;日期&#39;, &#39;数据&#39;])    for data in zip(update_date, foreign_crued):        ws_foreign_crued.append(data)    # 写入累计死亡数据    ws_foreign_died = wb.create_sheet(&#39;境外每日累计死亡数据&#39;)    ws_foreign_died.append([&#39;日期&#39;, &#39;数据&#39;])    for data in zip(update_date, foreign_died):        ws_foreign_died.append(data)    wb.save(&#39;COVID-19-Global.xlsx&#39;)    print(&#39;境外每日累计确诊/治愈/死亡数据已保存至 COVID-19-Global.xlsx！&#39;)</code></pre><h2 id="【6x00】词云图绘制模块-data-wordcloud"><a href="#【6x00】词云图绘制模块-data-wordcloud" class="headerlink" title="【6x00】词云图绘制模块 data_wordcloud"></a><font color=#FF0000>【6x00】词云图绘制模块 data_wordcloud</font></h2><h3 id="【6x01】中国累计确诊词云图-foreign-daily-data"><a href="#【6x01】中国累计确诊词云图-foreign-daily-data" class="headerlink" title="【6x01】中国累计确诊词云图 foreign_daily_data()"></a><font color="#4876FF">【6x01】中国累计确诊词云图 foreign_daily_data()</font></h3><pre><code class="python">def china_wordcloud():    wb = openpyxl.load_workbook(&#39;COVID-19-China.xlsx&#39;)  # 获取已有的xlsx文件    ws_china = wb[&#39;中国省份疫情数据&#39;]                     # 获取中国省份疫情数据表    ws_china.delete_rows(1)                             # 删除第一行    china_dict = &#123;&#125;                                     # 将省份及其累计确诊按照键值对形式储存在字典中    for data in ws_china.values:        china_dict[data[0]] = int(data[2])    word_cloud = wordcloud.WordCloud(font_path=&#39;C:/Windows/Fonts/simsun.ttc&#39;,                                     background_color=&#39;#CDC9C9&#39;,                                     min_font_size=15,                                     width=900, height=500)    word_cloud.generate_from_frequencies(china_dict)    word_cloud.to_file(&#39;WordCloud-China.png&#39;)    print(&#39;中国省份疫情词云图绘制完毕！&#39;)</code></pre><h3 id="【6x02】全球累计确诊词云图-foreign-daily-data"><a href="#【6x02】全球累计确诊词云图-foreign-daily-data" class="headerlink" title="【6x02】全球累计确诊词云图 foreign_daily_data()"></a><font color="#4876FF">【6x02】全球累计确诊词云图 foreign_daily_data()</font></h3><pre><code class="python">def global_wordcloud():    wb = openpyxl.load_workbook(&#39;COVID-19-Global.xlsx&#39;)    ws_global = wb[&#39;全球各国疫情数据&#39;]    ws_global.delete_rows(1)    global_dict = &#123;&#125;    for data in ws_global.values:        global_dict[data[0]] = int(data[2])    word_cloud = wordcloud.WordCloud(font_path=&#39;C:/Windows/Fonts/simsun.ttc&#39;,                                     background_color=&#39;#CDC9C9&#39;,                                     width=900, height=500)    word_cloud.generate_from_frequencies(global_dict)    word_cloud.to_file(&#39;WordCloud-Global.png&#39;)    print(&#39;全球各国疫情词云图绘制完毕！&#39;)</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/107140534未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【7x00】地图绘制模块-data-map"><a href="#【7x00】地图绘制模块-data-map" class="headerlink" title="【7x00】地图绘制模块 data_map"></a><font color=#FF0000>【7x00】地图绘制模块 data_map</font></h2><h3 id="【7x01】中国累计确诊地图-china-total-map"><a href="#【7x01】中国累计确诊地图-china-total-map" class="headerlink" title="【7x01】中国累计确诊地图 china_total_map()"></a><font color="#4876FF">【7x01】中国累计确诊地图 china_total_map()</font></h3><pre><code class="python">def china_total_map():    wb = openpyxl.load_workbook(&#39;COVID-19-China.xlsx&#39;)  # 获取已有的xlsx文件    ws_time = wb[&#39;中国疫情数据更新时间&#39;]                   # 获取文件中中国疫情数据更新时间表    ws_data = wb[&#39;中国省份疫情数据&#39;]                      # 获取文件中中国省份疫情数据表    ws_data.delete_rows(1)                              # 删除第一行    province = []                                       # 省份    curconfirm = []                                     # 累计确诊    for data in ws_data.values:        province.append(data[0])        curconfirm.append(data[2])    time_china = ws_time[&#39;A2&#39;].value                    # 更新时间    # 设置分级颜色    pieces = [        &#123;&#39;max&#39;: 0, &#39;min&#39;: 0, &#39;label&#39;: &#39;0&#39;, &#39;color&#39;: &#39;#FFFFFF&#39;&#125;,        &#123;&#39;max&#39;: 9, &#39;min&#39;: 1, &#39;label&#39;: &#39;1-9&#39;, &#39;color&#39;: &#39;#FFE5DB&#39;&#125;,        &#123;&#39;max&#39;: 99, &#39;min&#39;: 10, &#39;label&#39;: &#39;10-99&#39;, &#39;color&#39;: &#39;#FF9985&#39;&#125;,        &#123;&#39;max&#39;: 999, &#39;min&#39;: 100, &#39;label&#39;: &#39;100-999&#39;, &#39;color&#39;: &#39;#F57567&#39;&#125;,        &#123;&#39;max&#39;: 9999, &#39;min&#39;: 1000, &#39;label&#39;: &#39;1000-9999&#39;, &#39;color&#39;: &#39;#E64546&#39;&#125;,        &#123;&#39;max&#39;: 99999, &#39;min&#39;: 10000, &#39;label&#39;: &#39;≧10000&#39;, &#39;color&#39;: &#39;#B80909&#39;&#125;    ]    # 绘制地图    ct_map = (        Map()        .add(series_name=&#39;累计确诊人数&#39;, data_pair=[list(z) for z in zip(province, curconfirm)], maptype=&quot;china&quot;)        .set_global_opts(            title_opts=opts.TitleOpts(title=&quot;中国疫情数据（累计确诊）&quot;,                                      subtitle=&#39;数据更新至：&#39; + time_china + &#39;\n\n来源：百度疫情实时大数据报告&#39;),            visualmap_opts=opts.VisualMapOpts(max_=300, is_piecewise=True, pieces=pieces)        )    )    return ct_map</code></pre><h3 id="【7x02】全球累计确诊地图-global-total-map"><a href="#【7x02】全球累计确诊地图-global-total-map" class="headerlink" title="【7x02】全球累计确诊地图 global_total_map()"></a><font color="#4876FF">【7x02】全球累计确诊地图 global_total_map()</font></h3><pre><code class="python">def global_total_map():    wb = openpyxl.load_workbook(&#39;COVID-19-Global.xlsx&#39;)    ws_time = wb[&#39;全球疫情数据更新时间&#39;]    ws_data = wb[&#39;全球各国疫情数据&#39;]    ws_data.delete_rows(1)    country = []                        # 国家    curconfirm = []                     # 累计确诊    for data in ws_data.values:        country.append(data[0])        curconfirm.append(data[2])    time_global = ws_time[&#39;A2&#39;].value   # 更新时间    # 国家名称中英文映射表    name_map = &#123;          &quot;Somalia&quot;: &quot;索马里&quot;,          &quot;Liechtenstein&quot;: &quot;列支敦士登&quot;,          &quot;Morocco&quot;: &quot;摩洛哥&quot;,          &quot;W. Sahara&quot;: &quot;西撒哈拉&quot;,          &quot;Serbia&quot;: &quot;塞尔维亚&quot;,          &quot;Afghanistan&quot;: &quot;阿富汗&quot;,          &quot;Angola&quot;: &quot;安哥拉&quot;,          &quot;Albania&quot;: &quot;阿尔巴尼亚&quot;,          &quot;Andorra&quot;: &quot;安道尔共和国&quot;,          &quot;United Arab Emirates&quot;: &quot;阿拉伯联合酋长国&quot;,          &quot;Argentina&quot;: &quot;阿根廷&quot;,          &quot;Armenia&quot;: &quot;亚美尼亚&quot;,          &quot;Australia&quot;: &quot;澳大利亚&quot;,          &quot;Austria&quot;: &quot;奥地利&quot;,          &quot;Azerbaijan&quot;: &quot;阿塞拜疆&quot;,          &quot;Burundi&quot;: &quot;布隆迪&quot;,          &quot;Belgium&quot;: &quot;比利时&quot;,          &quot;Benin&quot;: &quot;贝宁&quot;,          &quot;Burkina Faso&quot;: &quot;布基纳法索&quot;,          &quot;Bangladesh&quot;: &quot;孟加拉国&quot;,          &quot;Bulgaria&quot;: &quot;保加利亚&quot;,          &quot;Bahrain&quot;: &quot;巴林&quot;,          &quot;Bahamas&quot;: &quot;巴哈马&quot;,          &quot;Bosnia and Herz.&quot;: &quot;波斯尼亚和黑塞哥维那&quot;,          &quot;Belarus&quot;: &quot;白俄罗斯&quot;,          &quot;Belize&quot;: &quot;伯利兹&quot;,          &quot;Bermuda&quot;: &quot;百慕大&quot;,          &quot;Bolivia&quot;: &quot;玻利维亚&quot;,          &quot;Brazil&quot;: &quot;巴西&quot;,          &quot;Barbados&quot;: &quot;巴巴多斯&quot;,          &quot;Brunei&quot;: &quot;文莱&quot;,          &quot;Bhutan&quot;: &quot;不丹&quot;,          &quot;Botswana&quot;: &quot;博茨瓦纳&quot;,          &quot;Central African Rep.&quot;: &quot;中非共和国&quot;,          &quot;Canada&quot;: &quot;加拿大&quot;,          &quot;Switzerland&quot;: &quot;瑞士&quot;,          &quot;Chile&quot;: &quot;智利&quot;,          &quot;China&quot;: &quot;中国&quot;,          &quot;Côte d&#39;Ivoire&quot;: &quot;科特迪瓦&quot;,          &quot;Cameroon&quot;: &quot;喀麦隆&quot;,          &quot;Dem. Rep. Congo&quot;: &quot;刚果（布）&quot;,          &quot;Congo&quot;: &quot;刚果（金）&quot;,          &quot;Colombia&quot;: &quot;哥伦比亚&quot;,          &quot;Cape Verde&quot;: &quot;佛得角&quot;,          &quot;Costa Rica&quot;: &quot;哥斯达黎加&quot;,          &quot;Cuba&quot;: &quot;古巴&quot;,          &quot;N. Cyprus&quot;: &quot;北塞浦路斯&quot;,          &quot;Cyprus&quot;: &quot;塞浦路斯&quot;,          &quot;Czech Rep.&quot;: &quot;捷克&quot;,          &quot;Germany&quot;: &quot;德国&quot;,          &quot;Djibouti&quot;: &quot;吉布提&quot;,          &quot;Denmark&quot;: &quot;丹麦&quot;,          &quot;Dominican Rep.&quot;: &quot;多米尼加&quot;,          &quot;Algeria&quot;: &quot;阿尔及利亚&quot;,          &quot;Ecuador&quot;: &quot;厄瓜多尔&quot;,          &quot;Egypt&quot;: &quot;埃及&quot;,          &quot;Eritrea&quot;: &quot;厄立特里亚&quot;,          &quot;Spain&quot;: &quot;西班牙&quot;,          &quot;Estonia&quot;: &quot;爱沙尼亚&quot;,          &quot;Ethiopia&quot;: &quot;埃塞俄比亚&quot;,          &quot;Finland&quot;: &quot;芬兰&quot;,          &quot;Fiji&quot;: &quot;斐济&quot;,          &quot;France&quot;: &quot;法国&quot;,          &quot;Gabon&quot;: &quot;加蓬&quot;,          &quot;United Kingdom&quot;: &quot;英国&quot;,          &quot;Georgia&quot;: &quot;格鲁吉亚&quot;,          &quot;Ghana&quot;: &quot;加纳&quot;,          &quot;Guinea&quot;: &quot;几内亚&quot;,          &quot;Gambia&quot;: &quot;冈比亚&quot;,          &quot;Guinea-Bissau&quot;: &quot;几内亚比绍&quot;,          &quot;Eq. Guinea&quot;: &quot;赤道几内亚&quot;,          &quot;Greece&quot;: &quot;希腊&quot;,          &quot;Grenada&quot;: &quot;格林纳达&quot;,          &quot;Greenland&quot;: &quot;格陵兰岛&quot;,          &quot;Guatemala&quot;: &quot;危地马拉&quot;,          &quot;Guam&quot;: &quot;关岛&quot;,          &quot;Guyana&quot;: &quot;圭亚那合作共和国&quot;,          &quot;Honduras&quot;: &quot;洪都拉斯&quot;,          &quot;Croatia&quot;: &quot;克罗地亚&quot;,          &quot;Haiti&quot;: &quot;海地&quot;,          &quot;Hungary&quot;: &quot;匈牙利&quot;,          &quot;Indonesia&quot;: &quot;印度尼西亚&quot;,          &quot;India&quot;: &quot;印度&quot;,          &quot;Br. Indian Ocean Ter.&quot;: &quot;英属印度洋领土&quot;,          &quot;Ireland&quot;: &quot;爱尔兰&quot;,          &quot;Iran&quot;: &quot;伊朗&quot;,          &quot;Iraq&quot;: &quot;伊拉克&quot;,          &quot;Iceland&quot;: &quot;冰岛&quot;,          &quot;Israel&quot;: &quot;以色列&quot;,          &quot;Italy&quot;: &quot;意大利&quot;,          &quot;Jamaica&quot;: &quot;牙买加&quot;,          &quot;Jordan&quot;: &quot;约旦&quot;,          &quot;Japan&quot;: &quot;日本&quot;,          &quot;Siachen Glacier&quot;: &quot;锡亚琴冰川&quot;,          &quot;Kazakhstan&quot;: &quot;哈萨克斯坦&quot;,          &quot;Kenya&quot;: &quot;肯尼亚&quot;,          &quot;Kyrgyzstan&quot;: &quot;吉尔吉斯斯坦&quot;,          &quot;Cambodia&quot;: &quot;柬埔寨&quot;,          &quot;Korea&quot;: &quot;韩国&quot;,          &quot;Kuwait&quot;: &quot;科威特&quot;,          &quot;Lao PDR&quot;: &quot;老挝&quot;,          &quot;Lebanon&quot;: &quot;黎巴嫩&quot;,          &quot;Liberia&quot;: &quot;利比里亚&quot;,          &quot;Libya&quot;: &quot;利比亚&quot;,          &quot;Sri Lanka&quot;: &quot;斯里兰卡&quot;,          &quot;Lesotho&quot;: &quot;莱索托&quot;,          &quot;Lithuania&quot;: &quot;立陶宛&quot;,          &quot;Luxembourg&quot;: &quot;卢森堡&quot;,          &quot;Latvia&quot;: &quot;拉脱维亚&quot;,          &quot;Moldova&quot;: &quot;摩尔多瓦&quot;,          &quot;Madagascar&quot;: &quot;马达加斯加&quot;,          &quot;Mexico&quot;: &quot;墨西哥&quot;,          &quot;Macedonia&quot;: &quot;马其顿&quot;,          &quot;Mali&quot;: &quot;马里&quot;,          &quot;Malta&quot;: &quot;马耳他&quot;,          &quot;Myanmar&quot;: &quot;缅甸&quot;,          &quot;Montenegro&quot;: &quot;黑山&quot;,          &quot;Mongolia&quot;: &quot;蒙古国&quot;,          &quot;Mozambique&quot;: &quot;莫桑比克&quot;,          &quot;Mauritania&quot;: &quot;毛里塔尼亚&quot;,          &quot;Mauritius&quot;: &quot;毛里求斯&quot;,          &quot;Malawi&quot;: &quot;马拉维&quot;,          &quot;Malaysia&quot;: &quot;马来西亚&quot;,          &quot;Namibia&quot;: &quot;纳米比亚&quot;,          &quot;New Caledonia&quot;: &quot;新喀里多尼亚&quot;,          &quot;Niger&quot;: &quot;尼日尔&quot;,          &quot;Nigeria&quot;: &quot;尼日利亚&quot;,          &quot;Nicaragua&quot;: &quot;尼加拉瓜&quot;,          &quot;Netherlands&quot;: &quot;荷兰&quot;,          &quot;Norway&quot;: &quot;挪威&quot;,          &quot;Nepal&quot;: &quot;尼泊尔&quot;,          &quot;New Zealand&quot;: &quot;新西兰&quot;,          &quot;Oman&quot;: &quot;阿曼&quot;,          &quot;Pakistan&quot;: &quot;巴基斯坦&quot;,          &quot;Panama&quot;: &quot;巴拿马&quot;,          &quot;Peru&quot;: &quot;秘鲁&quot;,          &quot;Philippines&quot;: &quot;菲律宾&quot;,          &quot;Papua New Guinea&quot;: &quot;巴布亚新几内亚&quot;,          &quot;Poland&quot;: &quot;波兰&quot;,          &quot;Puerto Rico&quot;: &quot;波多黎各&quot;,          &quot;Dem. Rep. Korea&quot;: &quot;朝鲜&quot;,          &quot;Portugal&quot;: &quot;葡萄牙&quot;,          &quot;Paraguay&quot;: &quot;巴拉圭&quot;,          &quot;Palestine&quot;: &quot;巴勒斯坦&quot;,          &quot;Qatar&quot;: &quot;卡塔尔&quot;,          &quot;Romania&quot;: &quot;罗马尼亚&quot;,          &quot;Russia&quot;: &quot;俄罗斯&quot;,          &quot;Rwanda&quot;: &quot;卢旺达&quot;,          &quot;Saudi Arabia&quot;: &quot;沙特阿拉伯&quot;,          &quot;Sudan&quot;: &quot;苏丹&quot;,          &quot;S. Sudan&quot;: &quot;南苏丹&quot;,          &quot;Senegal&quot;: &quot;塞内加尔&quot;,          &quot;Singapore&quot;: &quot;新加坡&quot;,          &quot;Solomon Is.&quot;: &quot;所罗门群岛&quot;,          &quot;Sierra Leone&quot;: &quot;塞拉利昂&quot;,          &quot;El Salvador&quot;: &quot;萨尔瓦多&quot;,          &quot;Suriname&quot;: &quot;苏里南&quot;,          &quot;Slovakia&quot;: &quot;斯洛伐克&quot;,          &quot;Slovenia&quot;: &quot;斯洛文尼亚&quot;,          &quot;Sweden&quot;: &quot;瑞典&quot;,          &quot;Swaziland&quot;: &quot;斯威士兰&quot;,          &quot;Seychelles&quot;: &quot;塞舌尔&quot;,          &quot;Syria&quot;: &quot;叙利亚&quot;,          &quot;Chad&quot;: &quot;乍得&quot;,          &quot;Togo&quot;: &quot;多哥&quot;,          &quot;Thailand&quot;: &quot;泰国&quot;,          &quot;Tajikistan&quot;: &quot;塔吉克斯坦&quot;,          &quot;Turkmenistan&quot;: &quot;土库曼斯坦&quot;,          &quot;Timor-Leste&quot;: &quot;东帝汶&quot;,          &quot;Tonga&quot;: &quot;汤加&quot;,          &quot;Trinidad and Tobago&quot;: &quot;特立尼达和多巴哥&quot;,          &quot;Tunisia&quot;: &quot;突尼斯&quot;,          &quot;Turkey&quot;: &quot;土耳其&quot;,          &quot;Tanzania&quot;: &quot;坦桑尼亚&quot;,          &quot;Uganda&quot;: &quot;乌干达&quot;,          &quot;Ukraine&quot;: &quot;乌克兰&quot;,          &quot;Uruguay&quot;: &quot;乌拉圭&quot;,          &quot;United States&quot;: &quot;美国&quot;,          &quot;Uzbekistan&quot;: &quot;乌兹别克斯坦&quot;,          &quot;Venezuela&quot;: &quot;委内瑞拉&quot;,          &quot;Vietnam&quot;: &quot;越南&quot;,          &quot;Vanuatu&quot;: &quot;瓦努阿图&quot;,          &quot;Yemen&quot;: &quot;也门&quot;,          &quot;South Africa&quot;: &quot;南非&quot;,          &quot;Zambia&quot;: &quot;赞比亚&quot;,          &quot;Zimbabwe&quot;: &quot;津巴布韦&quot;,          &quot;Aland&quot;: &quot;奥兰群岛&quot;,          &quot;American Samoa&quot;: &quot;美属萨摩亚&quot;,          &quot;Fr. S. Antarctic Lands&quot;: &quot;南极洲&quot;,          &quot;Antigua and Barb.&quot;: &quot;安提瓜和巴布达&quot;,          &quot;Comoros&quot;: &quot;科摩罗&quot;,          &quot;Curaçao&quot;: &quot;库拉索岛&quot;,          &quot;Cayman Is.&quot;: &quot;开曼群岛&quot;,          &quot;Dominica&quot;: &quot;多米尼加&quot;,          &quot;Falkland Is.&quot;: &quot;福克兰群岛马尔维纳斯&quot;,          &quot;Faeroe Is.&quot;: &quot;法罗群岛&quot;,          &quot;Micronesia&quot;: &quot;密克罗尼西亚&quot;,          &quot;Heard I. and McDonald Is.&quot;: &quot;赫德岛和麦克唐纳群岛&quot;,          &quot;Isle of Man&quot;: &quot;曼岛&quot;,          &quot;Jersey&quot;: &quot;泽西岛&quot;,          &quot;Kiribati&quot;: &quot;基里巴斯&quot;,          &quot;Saint Lucia&quot;: &quot;圣卢西亚&quot;,          &quot;N. Mariana Is.&quot;: &quot;北马里亚纳群岛&quot;,          &quot;Montserrat&quot;: &quot;蒙特塞拉特&quot;,          &quot;Niue&quot;: &quot;纽埃&quot;,          &quot;Palau&quot;: &quot;帕劳&quot;,          &quot;Fr. Polynesia&quot;: &quot;法属波利尼西亚&quot;,          &quot;S. Geo. and S. Sandw. Is.&quot;: &quot;南乔治亚岛和南桑威奇群岛&quot;,          &quot;Saint Helena&quot;: &quot;圣赫勒拿&quot;,          &quot;St. Pierre and Miquelon&quot;: &quot;圣皮埃尔和密克隆群岛&quot;,          &quot;São Tomé and Principe&quot;: &quot;圣多美和普林西比&quot;,          &quot;Turks and Caicos Is.&quot;: &quot;特克斯和凯科斯群岛&quot;,          &quot;St. Vin. and Gren.&quot;: &quot;圣文森特和格林纳丁斯&quot;,          &quot;U.S. Virgin Is.&quot;: &quot;美属维尔京群岛&quot;,          &quot;Samoa&quot;: &quot;萨摩亚&quot;        &#125;    pieces = [        &#123;&#39;max&#39;: 0, &#39;min&#39;: 0, &#39;label&#39;: &#39;0&#39;, &#39;color&#39;: &#39;#FFFFFF&#39;&#125;,        &#123;&#39;max&#39;: 49, &#39;min&#39;: 1, &#39;label&#39;: &#39;1-49&#39;, &#39;color&#39;: &#39;#FFE5DB&#39;&#125;,        &#123;&#39;max&#39;: 99, &#39;min&#39;: 50, &#39;label&#39;: &#39;50-99&#39;, &#39;color&#39;: &#39;#FFC4B3&#39;&#125;,        &#123;&#39;max&#39;: 999, &#39;min&#39;: 100, &#39;label&#39;: &#39;100-999&#39;, &#39;color&#39;: &#39;#FF9985&#39;&#125;,        &#123;&#39;max&#39;: 9999, &#39;min&#39;: 1000, &#39;label&#39;: &#39;1000-9999&#39;, &#39;color&#39;: &#39;#F57567&#39;&#125;,        &#123;&#39;max&#39;: 99999, &#39;min&#39;: 10000, &#39;label&#39;: &#39;10000-99999&#39;, &#39;color&#39;: &#39;#E64546&#39;&#125;,        &#123;&#39;max&#39;: 999999, &#39;min&#39;: 100000, &#39;label&#39;: &#39;100000-999999&#39;, &#39;color&#39;: &#39;#B80909&#39;&#125;,        &#123;&#39;max&#39;: 9999999, &#39;min&#39;: 1000000, &#39;label&#39;: &#39;≧1000000&#39;, &#39;color&#39;: &#39;#8A0808&#39;&#125;    ]    gt_map = (        Map()        .add(series_name=&#39;累计确诊人数&#39;, data_pair=[list(z) for z in zip(country, curconfirm)], maptype=&quot;world&quot;, name_map=name_map, is_map_symbol_show=False)        .set_series_opts(label_opts=opts.LabelOpts(is_show=False))        .set_global_opts(            title_opts=opts.TitleOpts(title=&quot;全球疫情数据（累计确诊）&quot;,                                      subtitle=&#39;数据更新至：&#39; + time_global + &#39;\n\n来源：百度疫情实时大数据报告&#39;),            visualmap_opts=opts.VisualMapOpts(max_=300, is_piecewise=True, pieces=pieces),        )    )    return gt_map</code></pre><h3 id="【7x03】中国每日数据折线图-china-daily-map"><a href="#【7x03】中国每日数据折线图-china-daily-map" class="headerlink" title="【7x03】中国每日数据折线图 china_daily_map()"></a><font color="#4876FF">【7x03】中国每日数据折线图 china_daily_map()</font></h3><pre><code class="python">def china_daily_map():    wb = openpyxl.load_workbook(&#39;COVID-19-China.xlsx&#39;)    ws_china_confirmed = wb[&#39;中国每日累计确诊数据&#39;]    ws_china_crued = wb[&#39;中国每日累计治愈数据&#39;]    ws_china_died = wb[&#39;中国每日累计死亡数据&#39;]    ws_china_confirmed.delete_rows(1)    ws_china_crued.delete_rows(1)    ws_china_died.delete_rows(1)    x_date = []               # 日期    y_china_confirmed = []    # 每日累计确诊    y_china_crued = []        # 每日累计治愈    y_china_died = []         # 每日累计死亡    for china_confirmed in ws_china_confirmed.values:        y_china_confirmed.append(china_confirmed[1])    for china_crued in ws_china_crued.values:        x_date.append(china_crued[0])        y_china_crued.append(china_crued[1])    for china_died in ws_china_died.values:        y_china_died.append(china_died[1])    fi_map = (        Line(init_opts=opts.InitOpts(height=&#39;420px&#39;))            .add_xaxis(xaxis_data=x_date)            .add_yaxis(            series_name=&quot;中国累计确诊数据&quot;,            y_axis=y_china_confirmed,            label_opts=opts.LabelOpts(is_show=False),        )            .add_yaxis(            series_name=&quot;中国累计治愈趋势&quot;,            y_axis=y_china_crued,            label_opts=opts.LabelOpts(is_show=False),        )            .add_yaxis(            series_name=&quot;中国累计死亡趋势&quot;,            y_axis=y_china_died,            label_opts=opts.LabelOpts(is_show=False),        )            .set_global_opts(            title_opts=opts.TitleOpts(title=&quot;中国每日累计确诊/治愈/死亡趋势&quot;),            legend_opts=opts.LegendOpts(pos_bottom=&quot;bottom&quot;, orient=&#39;horizontal&#39;),            tooltip_opts=opts.TooltipOpts(trigger=&quot;axis&quot;),            yaxis_opts=opts.AxisOpts(                type_=&quot;value&quot;,                axistick_opts=opts.AxisTickOpts(is_show=True),                splitline_opts=opts.SplitLineOpts(is_show=True),            ),            xaxis_opts=opts.AxisOpts(type_=&quot;category&quot;, boundary_gap=False),        )    )    return fi_map</code></pre><h3 id="【7x04】境外每日数据折线图-foreign-daily-map"><a href="#【7x04】境外每日数据折线图-foreign-daily-map" class="headerlink" title="【7x04】境外每日数据折线图 foreign_daily_map()"></a><font color="#4876FF">【7x04】境外每日数据折线图 foreign_daily_map()</font></h3><pre><code class="python">def foreign_daily_map():    wb = openpyxl.load_workbook(&#39;COVID-19-Global.xlsx&#39;)    ws_foreign_confirmed = wb[&#39;境外每日累计确诊数据&#39;]    ws_foreign_crued = wb[&#39;境外每日累计治愈数据&#39;]    ws_foreign_died = wb[&#39;境外每日累计死亡数据&#39;]    ws_foreign_confirmed.delete_rows(1)    ws_foreign_crued.delete_rows(1)    ws_foreign_died.delete_rows(1)    x_date = []                # 日期    y_foreign_confirmed = []   # 累计确诊    y_foreign_crued = []       # 累计治愈    y_foreign_died = []        # 累计死亡    for foreign_confirmed in ws_foreign_confirmed.values:        y_foreign_confirmed.append(foreign_confirmed[1])    for foreign_crued in ws_foreign_crued.values:        x_date.append(foreign_crued[0])        y_foreign_crued.append(foreign_crued[1])    for foreign_died in ws_foreign_died.values:        y_foreign_died.append(foreign_died[1])    fte_map = (        Line(init_opts=opts.InitOpts(height=&#39;420px&#39;))            .add_xaxis(xaxis_data=x_date)            .add_yaxis(            series_name=&quot;境外累计确诊趋势&quot;,            y_axis=y_foreign_confirmed,            label_opts=opts.LabelOpts(is_show=False),        )            .add_yaxis(            series_name=&quot;境外累计治愈趋势&quot;,            y_axis=y_foreign_crued,            label_opts=opts.LabelOpts(is_show=False),        )            .add_yaxis(            series_name=&quot;境外累计死亡趋势&quot;,            y_axis=y_foreign_died,            label_opts=opts.LabelOpts(is_show=False),        )            .set_global_opts(            title_opts=opts.TitleOpts(title=&quot;境外每日累计确诊/治愈/死亡趋势&quot;),            legend_opts=opts.LegendOpts(pos_bottom=&quot;bottom&quot;, orient=&#39;horizontal&#39;),            tooltip_opts=opts.TooltipOpts(trigger=&quot;axis&quot;),            yaxis_opts=opts.AxisOpts(                type_=&quot;value&quot;,                axistick_opts=opts.AxisTickOpts(is_show=True),                splitline_opts=opts.SplitLineOpts(is_show=True),            ),            xaxis_opts=opts.AxisOpts(type_=&quot;category&quot;, boundary_gap=False),        )    )    return fte_map</code></pre><h2 id="【8x00】结果截图"><a href="#【8x00】结果截图" class="headerlink" title="【8x00】结果截图"></a><font color=#FF0000>【8x00】结果截图</font></h2><h3 id="【8x01】数据储存-Excel"><a href="#【8x01】数据储存-Excel" class="headerlink" title="【8x01】数据储存 Excel"></a><font color="#4876FF">【8x01】数据储存 Excel</font></h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/03.png" alt="03"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/04.png" alt="04"></p><h3 id="【8x02】词云图"><a href="#【8x02】词云图" class="headerlink" title="【8x02】词云图"></a><font color="#4876FF">【8x02】词云图</font></h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/05.png" alt="05"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/06.png" alt="06"></p><h3 id="【8x03】地图-折线图"><a href="#【8x03】地图-折线图" class="headerlink" title="【8x03】地图 + 折线图"></a><font color="#4876FF">【8x03】地图 + 折线图</font></h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/07.png" alt="07"></p><h2 id="【9x00】完整代码"><a href="#【9x00】完整代码" class="headerlink" title="【9x00】完整代码"></a><font color=#FF0000>【9x00】完整代码</font></h2><p>预览地址：<del><a href="http://cov.itrhx.com/">http://cov.itrhx.com/</a></del>（已失效）<br>完整代码地址（点亮 star 有 buff 加成）：<a href="https://github.com/TRHX/Python3-Spider-Practice">https://github.com/TRHX/Python3-Spider-Practice</a><br>爬虫实战专栏（持续更新）：<a href="https://itrhx.blog.csdn.net/article/category/9351278">https://itrhx.blog.csdn.net/article/category/9351278</a></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/107140534未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code class=&quot;yaml&quot;&gt;这里是一段防爬虫文本，请读者忽略。
本文原创首发于 CSDN，作者 TRHX。
博客首页：https://itrhx.blog.csdn.net/
本文链接：https://itrhx.blog.csdn.net/article/d</summary>
      
    
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="肺炎疫情" scheme="https://www.itbob.cn/tags/%E8%82%BA%E7%82%8E%E7%96%AB%E6%83%85/"/>
    
    <category term="COVID-19" scheme="https://www.itbob.cn/tags/COVID-19/"/>
    
    <category term="数据可视化" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据分析三剑客之 Pandas（十）：数据读写</title>
    <link href="https://www.itbob.cn/article/034/"/>
    <id>https://www.itbob.cn/article/034/</id>
    <published>2020-06-26T14:54:56.000Z</published>
    <updated>2022-05-22T12:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106963135未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】读取数据"><a href="#【01x00】读取数据" class="headerlink" title="【01x00】读取数据"></a><font color=#FF0000>【01x00】读取数据</font></h2><p>Pandas 提供了一些用于将表格型数据读取为 DataFrame 对象的函数。常见方法如下：</p><p>Pandas 官方对 IO 工具的介绍：<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html">https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html</a></p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>read_csv</td><td>从文件、URL、文件型对象中加载带分隔符的数据。默认分隔符为逗号</td></tr><tr><td>read_table</td><td>从文件、URL、文件型对象中加载带分隔符的数据。默认分隔符为制表符（<code>&#39;\t&#39;</code>）</td></tr><tr><td>read_fwf</td><td>读取定宽列格式数据（没有分隔符）</td></tr><tr><td>read_clipboard</td><td>读取剪贴板中的数据，可以看做 read_table 的剪贴板版本。在将网页转换为表格时很有用</td></tr><tr><td>read_excel</td><td>从 Excel XLS 或 XLSX file 读取表格数据</td></tr><tr><td>read_hdf</td><td>读取 pandas写的 HDF5 文件</td></tr><tr><td>read_html</td><td>读取 HTML 文档中的所有表格</td></tr><tr><td>read_json</td><td>读取 JSON（ JavaScript Object Notation）字符串中的数据</td></tr><tr><td>read_msgpack</td><td>读取二进制格式编码的 pandas 数据（Pandas v1.0.0 中已删除对 msgpack 的支持，建议使用 <a href="https://pandas.pydata.org/docs/user_guide/io.html#io-msgpack">pyarrow</a>）</td></tr><tr><td>read_pickle</td><td>读取 Python pickle 格式中存储的任意对象</td></tr><tr><td>read_sas</td><td>读取存储于 SAS 系统自定义存储格式的 SAS 数据集</td></tr><tr><td>read_sql</td><td>（使用 SQLAlchemy）读取 SQL 查询结果为 pandas 的 DataFrame</td></tr><tr><td>read_stata</td><td>读取 Stata 文件格式的数据集</td></tr><tr><td>read_feather</td><td>读取 Feather 二进制格式文件</td></tr></tbody></table><p>以下以 read_csv 和 read_table 为例，它们的参数多达 50 多个，具体可参见官方文档：</p><p>read_csv：<a href="https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html">https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html</a></p><p>read_table：<a href="https://pandas.pydata.org/docs/reference/api/pandas.read_table.html">https://pandas.pydata.org/docs/reference/api/pandas.read_table.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>path</td><td>表示文件系统位置、URL、文件型对象的字符串</td></tr><tr><td>sep / delimiter</td><td>用于对行中各字段进行拆分的字符序列或正则表达式</td></tr><tr><td>header</td><td>用作列名的行号，默认为 0（第一行），如果没有 header 行就应该设置为 None</td></tr><tr><td>index_col</td><td>用作行索引的列编号或列名。可以是单个名称、数字或由多个名称、数字组成的列表（层次化索引）</td></tr><tr><td>names</td><td>用于结果的列名列表，结合 header=None</td></tr><tr><td>skiprows</td><td>需要忽略的行数（从文件开始处算起），或需要跳过的行号列表（从0开始）</td></tr><tr><td>na_values</td><td>指定一组值，将该组值设置为 NaN（缺失值）</td></tr><tr><td>comment</td><td>用于将注释信息从行尾拆分出去的字符（一个或多个）</td></tr><tr><td>parse_dates</td><td>尝试将数据解析为日期，默认为 False。如果为 True，则尝试解析所有列。此外，还可以指定需要解析的一组列号或列名。<br>如果列表的元素为列表或元组，就会将多个列组合到一起再进行日期解析工作（例如，日期、时间分别位于两个列中）</td></tr><tr><td>keep_date_col</td><td>如果连接多列解析日期，则保持参与连接的列。默认为 False</td></tr><tr><td>converters</td><td>由列号 / 列名跟函数之间的映射关系组成的字典。例如，<code>&#123;&#39;foo&#39;: f&#125;</code> 会对 foo 列的所有值应用函数 f</td></tr><tr><td>dayfirst</td><td>当解析有歧义的日期时，将其看做国际格式（例如，7/6/2012 —&gt; June 7,2012），默认为 Fase</td></tr><tr><td>date_parser</td><td>用于解析日期的函数</td></tr><tr><td>nrows</td><td>需要读取的行数（从文件开始处算起）</td></tr><tr><td>iterator</td><td>返回一个 TextParser 以便逐块读取文件</td></tr><tr><td>chunksize</td><td>文件块的大小（用于迭代）</td></tr><tr><td>skip_footer</td><td>需要忽略的行数（从文件末尾处算起）</td></tr><tr><td>verbose</td><td>打印各种解析器输出信息，比如“非数值列中缺失值的数量”等</td></tr><tr><td>encoding</td><td>用于 unicode 的文本编码格式。例如，“utf-8” 表示用 UTF-8 编码的文本</td></tr><tr><td>squeeze</td><td>如果数据经解析后仅含一列，则返回 Series</td></tr><tr><td>thousands</td><td>千分位分隔符，如 <code>,</code> 或 <code>.</code></td></tr></tbody></table><h3 id="【01x01】简单示例"><a href="#【01x01】简单示例" class="headerlink" title="【01x01】简单示例"></a><font color=#4876FF>【01x01】简单示例</font></h3><p>首先创建一个 test1.csv 文件：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/01.png" alt="01"></p><p>使用 read_csv 方法将其读出为一个 DataFrame 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test1.csv&#39;)&gt;&gt;&gt; obj   a   b   c   d message0  1   2   3   4   hello1  5   6   7   8   world2  9  10  11  12  python&gt;&gt;&gt; &gt;&gt;&gt; type(obj)&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</code></pre><p>前面的 csv 文件是以逗号分隔的，可以使用 read_table 方法并指定分隔符来读取：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.read_table(r&#39;C:\Users\TanRe\Desktop\test1.csv&#39;, sep=&#39;,&#39;)&gt;&gt;&gt; obj   a   b   c   d message0  1   2   3   4   hello1  5   6   7   8   world2  9  10  11  12  python</code></pre><h3 id="【01x02】header-names-定制列标签"><a href="#【01x02】header-names-定制列标签" class="headerlink" title="【01x02】header / names 定制列标签"></a><font color=#4876FF>【01x02】header / names 定制列标签</font></h3><p>以上示例中第一行为列标签，如果没有单独定义列标签，使用 read_csv 方法也会默认将第一行当作列标签：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/02.png" alt="02"></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test2.csv&#39;)&gt;&gt;&gt; obj   1   2   3   4   hello0  5   6   7   8   world1  9  10  11  12  python</code></pre><p>避免以上情况，可以设置 <code>header=None</code>，Pandas 会为其自动分配列标签：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test2.csv&#39;, header=None)   0   1   2   3       40  1   2   3   4   hello1  5   6   7   8   world2  9  10  11  12  python</code></pre><p>也可以使用 <code>names</code> 参数自定义列标签，传递的是一个列表：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test2.csv&#39;, names=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;message&#39;])   a   b   c   d message0  1   2   3   4   hello1  5   6   7   8   world2  9  10  11  12  python</code></pre><h3 id="【01x03】index-col-指定列为行索引"><a href="#【01x03】index-col-指定列为行索引" class="headerlink" title="【01x03】index_col 指定列为行索引"></a><font color=#4876FF>【01x03】index_col 指定列为行索引</font></h3><p><code>index_col</code> 参数可以指定某一列作为 DataFrame 的行索引，传递的参数是列名称，在以下示例中，会将列名为 <code>message</code> 的列作为 DataFrame 的行索引：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/03.png" alt="03"></p><pre><code class="python">&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test2.csv&#39;,                 names=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;message&#39;],                 index_col=&#39;message&#39;)         a   b   c   dmessage               hello    1   2   3   4world    5   6   7   8python   9  10  11  12</code></pre><p>如果需要构造多层索引的 DataFrame 对象，则只需传入由列编号或列名组成的列表即可：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/04.png" alt="04"></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test3.csv&#39;, index_col=[&#39;key1&#39;, &#39;key2&#39;])           value1  value2key1 key2                one  a          1       2     b          3       4     c          5       6     d          7       8two  a          9      10     b         11      12     c         13      14     d         15      16</code></pre><h3 id="【01x04】sep-指定分隔符"><a href="#【01x04】sep-指定分隔符" class="headerlink" title="【01x04】sep 指定分隔符"></a><font color=#4876FF>【01x04】sep 指定分隔符</font></h3><p>在 read_table 中，sep 参数用于接收分隔符，如果遇到不是用固定的分隔符去分隔字段的，也可以传递一个正则表达式作为 read_table 的分隔符，如下面的 txt 文件数据之间是由不同的空白字符间隔开的：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/05.png" alt="05"></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.read_table(r&#39;C:\Users\TanRe\Desktop\test1.txt&#39;, sep=&#39;\s+&#39;)            A         B         Caaa -0.264438 -1.026059 -0.619500bbb  0.927272  0.302904 -0.032399ccc -0.264273 -0.386314 -0.217601ddd -0.871858 -0.348382  1.100491</code></pre><h3 id="【01x05】skiprows-忽略行"><a href="#【01x05】skiprows-忽略行" class="headerlink" title="【01x05】skiprows 忽略行"></a><font color=#4876FF>【01x05】skiprows 忽略行</font></h3><p>skiprows    参数可用于设置需要忽略的行数，或需要跳过的行号列表，在下面的示例中，读取文件时选择跳过第1、3、4行（索引值分别为0、2、3）：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/06.png" alt="06"></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test4.csv&#39;, skiprows=[0, 2, 3])   a   b   c   d message0  1   2   3   4   hello1  5   6   7   8   world2  9  10  11  12  python</code></pre><h3 id="【01x06】na-values-设置缺失值"><a href="#【01x06】na-values-设置缺失值" class="headerlink" title="【01x06】na_values 设置缺失值"></a><font color=#4876FF>【01x06】na_values 设置缺失值</font></h3><p>当文件中出现了空字符串或者 NA 值，Pandas 会将其标记成 NaN（缺失值），同样也可以使用 <code>isnull</code> 方法来判断结果值是否为缺失值：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/07.png" alt="07"></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; obj  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt; &gt;&gt;&gt; pd.isnull(obj)   something      a      b      c      d  message0      False  False  False  False  False     True1      False  False  False   True  False    False2      False  False  False  False  False    False</code></pre><p><code>na_values</code> 方法可以传递一组值，将这组值设置为缺失值，如果传递的为字典对象，则字典的各值将被设置为 NaN：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; obj1  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt; &gt;&gt;&gt; obj2 = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;, na_values=[&#39;1&#39;, &#39;12&#39;])&gt;&gt;&gt; obj2  something    a   b     c    d message0       one  NaN   2   3.0  4.0     NaN1       two  5.0   6   NaN  8.0   world2     three  9.0  10  11.0  NaN  python&gt;&gt;&gt; &gt;&gt;&gt; sentinels = &#123;&#39;message&#39;: [&#39;python&#39;, &#39;world&#39;], &#39;something&#39;: [&#39;two&#39;]&#125;&gt;&gt;&gt; obj3 = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;, na_values=sentinels)&gt;&gt;&gt; obj3  something  a   b     c   d  message0       one  1   2   3.0   4      NaN1       NaN  5   6   NaN   8      NaN2     three  9  10  11.0  12      NaN</code></pre><h3 id="【01x07】nrows-chunksize-行与块"><a href="#【01x07】nrows-chunksize-行与块" class="headerlink" title="【01x07】nrows / chunksize 行与块"></a><font color=#4876FF>【01x07】nrows / chunksize 行与块</font></h3><p>以下 test6.csv 文件中包含 50 行数据：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/08.png" alt="08"></p><p>可以设置 <code>pd.options.display.max_rows</code> 来紧凑地显示指定行数的数据：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.options.display.max_rows = 10&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test6.csv&#39;)         one       two     three      four key0   0.467976 -0.038649 -0.295344 -1.824726   L1  -0.358893  1.404453  0.704965 -0.200638   B2  -0.501840  0.659254 -0.421691 -0.057688   G3   0.204886  1.074134  1.388361 -0.982404   R4   0.354628 -0.133116  0.283763 -0.837063   Q..       ...       ...       ...       ...  ..45  2.311896 -0.417070 -1.409599 -0.515821   L46 -0.479893 -0.633419  0.745152 -0.646038   E47  0.523331  0.787112  0.486066  1.093156   K48 -0.362559  0.598894 -1.843201  0.887292   G49 -0.096376 -1.012999 -0.657431 -0.573315   0[50 rows x 5 columns]</code></pre><p>通过 nrows 参数可以读取指定行数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test6.csv&#39;, nrows=5)        one       two     three      four key0  0.467976 -0.038649 -0.295344 -1.824726   L1 -0.358893  1.404453  0.704965 -0.200638   B2 -0.501840  0.659254 -0.421691 -0.057688   G3  0.204886  1.074134  1.388361 -0.982404   R4  0.354628 -0.133116  0.283763 -0.837063   Q</code></pre><p>要逐块读取文件，可以指定 chunksize（行数）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; chunker = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test6.csv&#39;, chunksize=50)&gt;&gt;&gt; chunker&lt;pandas.io.parsers.TextFileReader object at 0x07A20D60&gt;</code></pre><p>返回的 TextParser 对象，可以根据 chunksize 对文件进行逐块迭代。以下示例中，对 test6.csv 文件数据进行迭代处理，将值计数聚合到 “key” 列中：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; chunker = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test6.csv&#39;, chunksize=50)&gt;&gt;&gt; tot = pd.Series([], dtype=&#39;float64&#39;)&gt;&gt;&gt; for piece in chunker:    tot = tot.add(piece[&#39;key&#39;].value_counts(), fill_value=0)&gt;&gt;&gt; tot = tot.sort_values(ascending=False)&gt;&gt;&gt; tot[:10]G    6.0E    5.0B    5.0L    5.00    5.0K    4.0A    4.0R    4.0C    2.0Q    2.0dtype: float64</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106963135未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【02x00】写入数据"><a href="#【02x00】写入数据" class="headerlink" title="【02x00】写入数据"></a><font color=#FF0000>【02x00】写入数据</font></h2><p>Pandas 提供了一些用于将表格型数据读取为 DataFrame 对象的函数。常见方法如下：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>to_csv</td><td>将对象写入逗号分隔值（csv）文件</td></tr><tr><td>to_clipboard</td><td>将对象复制到系统剪贴板</td></tr><tr><td>to_excel</td><td>将对象写入 Excel 工作表</td></tr><tr><td>to_hdf</td><td>使用 HDFStore 将包含的数据写入 HDF5 文件</td></tr><tr><td>to_html</td><td>将 DataFrame 呈现为 HTML 表格</td></tr><tr><td>to_json</td><td>将对象转换为 JSON（ JavaScript Object Notation）字符串</td></tr><tr><td>to_msgpack</td><td>将对象写入二进制格式编码的文件（Pandas v1.0.0 中已删除对 msgpack 的支持，建议使用 <a href="https://pandas.pydata.org/docs/user_guide/io.html#io-msgpack">pyarrow</a>）</td></tr><tr><td>to_pickle</td><td>Pickle（序列化）对象到文件</td></tr><tr><td>to_sql</td><td>将存储在 DataFrame 中的数据写入 SQL 数据库</td></tr><tr><td>to_stata</td><td>将 DataFrame 对象导出为 Stata 格式</td></tr><tr><td>to_feather</td><td>将 DataFrames 写入 Feather 二进制格式文件</td></tr></tbody></table><p>以下以 to_csv 为例，它的参数同样多达 50 多个，具体可参见官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_csv.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_csv.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.to_csv.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.to_csv.html</a></p></li></ul><h3 id="【02x01】简单示例"><a href="#【02x01】简单示例" class="headerlink" title="【02x01】简单示例"></a><font color=#4876FF>【02x01】简单示例</font></h3><p>以之前的 test5.csv 文件为例，先读出数据，再将数据写入另外的文件：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; data  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt; &gt;&gt;&gt; data.to_csv(r&#39;C:\Users\TanRe\Desktop\out1.csv&#39;)</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/09.png" alt="09"></p><h3 id="【02x02】sep-指定分隔符"><a href="#【02x02】sep-指定分隔符" class="headerlink" title="【02x02】sep 指定分隔符"></a><font color=#4876FF>【02x02】sep 指定分隔符</font></h3><p>sep 参数可用于其他分隔符：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; data  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt;&gt;&gt;&gt; data.to_csv(r&#39;C:\Users\TanRe\Desktop\out2.csv&#39;, sep=&#39;|&#39;)</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/10.png" alt="10"></p><h3 id="【02x03】na-rep-替换缺失值"><a href="#【02x03】na-rep-替换缺失值" class="headerlink" title="【02x03】na_rep 替换缺失值"></a><font color=#4876FF>【02x03】na_rep 替换缺失值</font></h3><p>na_rep 参数可将缺失值（NaN）替换成其他字符串：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; data  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt; &gt;&gt;&gt; data.to_csv(r&#39;C:\Users\TanRe\Desktop\out3.csv&#39;, na_rep=&#39;X&#39;)</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/11.png" alt="11"></p><h3 id="【02x04】index-header-行与列标签"><a href="#【02x04】index-header-行与列标签" class="headerlink" title="【02x04】index / header 行与列标签"></a><font color=#4876FF>【02x04】index / header 行与列标签</font></h3><p>设置 <code>index=False</code>, <code>header=False</code>，可以禁用行标签与列标签：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; data  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt; &gt;&gt;&gt; data.to_csv(r&#39;C:\Users\TanRe\Desktop\out4.csv&#39;, index=False, header=False)</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/12.png" alt="12"></p><p>还可以传入列表来重新设置列标签：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; data  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt; &gt;&gt;&gt; data.to_csv(r&#39;C:\Users\TanRe\Desktop\out5.csv&#39;, header=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;])</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/13.png" alt="13"></p><h3 id="【02x05】columns-指定列"><a href="#【02x05】columns-指定列" class="headerlink" title="【02x05】columns 指定列"></a><font color=#4876FF>【02x05】columns 指定列</font></h3><p>可以通过设置 columns 参数，只写入部分列，并按照指定顺序排序：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; data  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt;&gt;&gt;&gt; data.to_csv(r&#39;C:\Users\TanRe\Desktop\out6.csv&#39;, columns=[&#39;c&#39;, &#39;b&#39;, &#39;a&#39;])</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/14.png" alt="14"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106963135未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Pandas 系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itbob.cn/article/025/&quot;&gt;Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象&lt;/a&gt;&lt;/li&gt;</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.itbob.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="数据分析" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="Pandas" scheme="https://www.itbob.cn/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据分析三剑客之 Pandas（九）：时间序列</title>
    <link href="https://www.itbob.cn/article/033/"/>
    <id>https://www.itbob.cn/article/033/</id>
    <published>2020-06-25T13:55:49.000Z</published>
    <updated>2022-05-22T12:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106947061未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】时间序列"><a href="#【01x00】时间序列" class="headerlink" title="【01x00】时间序列"></a><font color=#FF0000>【01x00】时间序列</font></h2><p>官网对于时间序列的介绍：<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html">https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html</a></p><p>时间序列（time series）是一种重要的结构化数据形式，应用于多个领域，包括金融学、经济学、生态学、神经科学、物理学等。在多个时间点观察或测量到的任何事物都可以形成一段时间序列。很多时间序列是固定频率的，也就是说，数据点是根据某种规律定期出现的（比如每15秒、每5分钟、每月出现一次）。时间序列也可以是不定期的，没有固定的时间单位或单位之间的偏移量。时间序列数据的意义取决于具体的应用场景，主要有以下几种：</p><ul><li><p><font color=#4169E1><strong>时间戳（timestamp），表示某个具体的时间点，例如 2020-6-24 15:30；</strong></font></p></li><li><p><font color=#4169E1><strong>固定周期（period），表示某个时间周期，例如 2020-01；</strong></font></p></li><li><p><font color=#4169E1><strong>时间间隔（timedelta），持续时间，即两个日期或时间之间的差异。</strong></font></p></li><li><p><font color=#FFA500><strong>针对时间戳数据，Pandas 提供了 Timestamp 类型。它本质上是 Python 的原生 datetime 类型的替代品，但是在性能更好的 numpy.datetime64 类型的基础上创建。对应的索引数据结构是 DatetimeIndex。</strong></font></p></li><li><p><font color=#FFA500><strong>针对时间周期数据，Pandas 提供了 Period 类型。这是利用 numpy.datetime64 类型将固定频率的时间间隔进行编码。对应的索引数据结构是 PeriodIndex。</strong></font></p></li><li><p><font color=#FFA500><strong>针对时间增量或持续时间，Pandas 提供了 Timedelta 类型。Timedelta 是一种代替 Python 原生datetime.timedelta 类型的高性能数据结构，同样是基于 numpy.timedelta64 类型。对应的索引数据结构是 TimedeltaIndex。</strong></font></p></li></ul><h2 id="【02x00】Timestamp-时间戳"><a href="#【02x00】Timestamp-时间戳" class="headerlink" title="【02x00】Timestamp 时间戳"></a><font color=#FF0000>【02x00】Timestamp 时间戳</font></h2><h3 id="【02x01】pandas-Timestamp"><a href="#【02x01】pandas-Timestamp" class="headerlink" title="【02x01】pandas.Timestamp"></a><font color=#4876FF>【02x01】pandas.Timestamp</font></h3><p>在 pandas 中，<code>pandas.Timestamp</code> 方法用来代替 Python 中的 <code>datetime.datetime</code> 方法。</p><p>Timestamp 与 Python 的 Datetime 等效，在大多数情况下都可以互换。 此类型用于组成 DatetimeIndex 以及 Pandas 中其他面向时间序列的数据结构。</p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Timestamp.html">https://pandas.pydata.org/docs/reference/api/pandas.Timestamp.html</a></p><p>基本语法：</p><pre><code class="python">class pandas.Timestamp(ts_input=&lt;object object&gt;,                        freq=None, tz=None, unit=None,                        year=None, month=None, day=None,                        hour=None, minute=None, second=None,                        microsecond=None, nanosecond=None, tzinfo=None)</code></pre><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>ts_input</td><td>要转换为时间戳的对象，可以是 datetime-like，str，int，float 类型</td></tr><tr><td>freq</td><td>时间戳将具有的偏移量，可以是 str，日期偏移量类型，取值参见<a href="#t4">【02x02】freq 频率部分取值</a></td></tr><tr><td>tz</td><td>时间戳将具有的时区</td></tr><tr><td>unit</td><td>如果 ts_input 是整数或浮点数，该参数用于设置其单位（D、s、ms、us、ns）</td></tr></tbody></table><p>简单示例：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Timestamp(&#39;2017-01-01T12&#39;)Timestamp(&#39;2017-01-01 12:00:00&#39;)</code></pre><p>设置 <code>unit=&#39;s&#39;</code>，即待转换对象单位为秒：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Timestamp(1513393355.5, unit=&#39;s&#39;)Timestamp(&#39;2017-12-16 03:02:35.500000&#39;)</code></pre><p>使用 <code>tz</code> 参数设置时区：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Timestamp(1513393355, unit=&#39;s&#39;, tz=&#39;US/Pacific&#39;)Timestamp(&#39;2017-12-15 19:02:35-0800&#39;, tz=&#39;US/Pacific&#39;)</code></pre><p>单独设置年月日：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Timestamp(year=2020, month=6, day=24, hour=12)Timestamp(&#39;2020-06-24 12:00:00&#39;)</code></pre><h3 id="【02x02】freq-频率部分取值"><a href="#【02x02】freq-频率部分取值" class="headerlink" title="【02x02】freq 频率部分取值"></a><font color=#4876FF>【02x02】freq 频率部分取值</font></h3><p>完整取值参见官方文档：<a href="https://pandas.pydata.org/docs/user_guide/timeseries.html#timeseries-offset-aliases">https://pandas.pydata.org/docs/user_guide/timeseries.html#timeseries-offset-aliases</a></p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>D</td><td>Day</td><td>每日历日</td></tr><tr><td>B</td><td>BusinessDay</td><td>每工作日</td></tr><tr><td>H</td><td>Hour</td><td>每小时</td></tr><tr><td>T 或 min</td><td>Minute</td><td>每分</td></tr><tr><td>S</td><td>Second</td><td>每秒</td></tr><tr><td>L 或 ms</td><td>Milli</td><td>每毫秒（即每千分之一秒）</td></tr><tr><td>U</td><td>Micro</td><td>每微秒（即每百万分之一秒）</td></tr><tr><td>M</td><td>MonthEnd</td><td>每月最后一个日历日</td></tr><tr><td>BM</td><td>BusinessMonthEnd</td><td>每月最后一个工作日</td></tr><tr><td>MS</td><td>MonthBegin</td><td>每月第一个日历日</td></tr><tr><td>BMS</td><td>BusinessMonthBegin</td><td>每月第一个工作日</td></tr><tr><td>W-MON、W-TUE…</td><td>Week</td><td>从指定的星期几（MON、TUE、 WED、THU、FR、SAT、SUN）开始算起，每周</td></tr><tr><td>WoM-1MON、WOM-2MON…</td><td>WeekOfMonth</td><td>产生每月第一、第二、第三或第四周的星期几。例如，WoM-3FRI 表示每月第3个星期五</td></tr><tr><td>Q-JAN、Q-FEB…</td><td>QuarterEnd</td><td>对于以指定月份（JAN、FEB、MAR、APR、MAY、JUN、JUL、AUG、SEP、OCT、NOV、DEC）结束的年度，每季度最后一月的最后个日历日</td></tr><tr><td>BQ-JAN、BQ-FEB…</td><td>BusinessQuarterEnd</td><td>对于以指定月份结束的年度，每季度最后一月的最后一个工作日</td></tr><tr><td>QS-JAN、QS-FEB…</td><td>QuarterBegin</td><td>对于以指定月份结束的年度，每季度最后一月的第一个日历日</td></tr><tr><td>BQS-JAN、 BQS-FEB…</td><td>BusinessQuarterBegin</td><td>对于以指定月份结束的年度，每季度最后一月的第一个工作日</td></tr><tr><td>A-JAN、A-FEB…</td><td>YearEnd</td><td>每年指定月份（JAN、FEB、MAR、APR、MAY、JUN、JUL、AUG、SEP、 OCT、NOV、DEC）的最后一个日历日</td></tr><tr><td>BA-JAN、BA-FEB…</td><td>BusinessYearEnd</td><td>每年指定月份的最后一个工作日</td></tr><tr><td>AS-JAN、AS-FEB…</td><td>YearBegin</td><td>每年指定月份的第一个历日日</td></tr><tr><td>BAS-JAN、BAS-FEB…</td><td>BusinessYearBegin</td><td>每年指定月份的第一个工作日</td></tr></tbody></table><h3 id="【02x03】to-datetime"><a href="#【02x03】to-datetime" class="headerlink" title="【02x03】to_datetime"></a><font color=#4876FF>【02x03】to_datetime</font></h3><p>在 Python 中，datetime 库提供了日期和时间处理方法，利用 <code>str</code> 或 <code>strftime</code> 方法可以将 datetime 对象转化成字符串，具体用法可参见<a href="https://blog.csdn.net/qq_36759224/article/details/104427220">【Python 标准库学习】日期和时间处理库 — datetime</a>。</p><pre><code class="python">&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; stamp = datetime(2020, 6, 24)&gt;&gt;&gt; stampdatetime.datetime(2020, 6, 24, 0, 0)&gt;&gt;&gt;&gt;&gt;&gt; str(stamp)&#39;2020-06-24 00:00:00&#39;&gt;&gt;&gt; &gt;&gt;&gt; stamp.strftime(&#39;%Y-%m-%d&#39;)&#39;2020-06-24&#39;</code></pre><p><font color=#FF0000><strong>在 pandas 中 to_datetime 方法可以将字符串解析成多种不同的 Timestamp（时间戳） 对象：</strong></font></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; datestrs = &#39;2011-07-06 12:00:00&#39;&gt;&gt;&gt; type(datestrs)&lt;class &#39;str&#39;&gt;&gt;&gt;&gt; &gt;&gt;&gt; pd.to_datetime(datestrs)Timestamp(&#39;2011-07-06 12:00:00&#39;)</code></pre><p>基本语法：</p><pre><code class="python">pandas.to_datetime(arg, errors=&#39;raise&#39;, dayfirst=False,                    yearfirst=False, utc=None, format=None,                    exact=True, unit=None, infer_datetime_format=False,                    origin=&#39;unix&#39;, cache=True)</code></pre><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html">https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>arg</td><td>要转换为日期时间的对象，可以接受 int, float, str, datetime, list, tuple, 1-d array, Series DataFrame/dict-like 类型</td></tr><tr><td>errors</td><td>如果字符串不满足时间戳的形式，是否会发生异常<br><code>ignore</code>：不引发异常，返回原始输入；<code>raise</code>：无效解析将引发异常（默认）；<code>coerce</code>：无效解析将被设置为NaT</td></tr><tr><td>dayfirst</td><td>bool 类型，默认 False，如果 arg 是 str 或列表，是否首先解析为日期<br>例如 dayfirst 为 True，<code>10/11/12</code> 被解析为 <code>2012-11-10</code>，为 False 则解析为 <code>2012-10-11</code></td></tr><tr><td>yearfirst</td><td>bool 类型，默认 False，如果 arg 是 str 或列表，是否首先解析为年份<br>例如 dayfirst 为 True，<code>10/11/12</code> 被解析为 <code>2010-11-12</code>，为 False 则解析为 <code>2012-10-11</code><br>如果 dayfirst 和 yearfirst 都为 True，则优先 yearfirst</td></tr><tr><td>utc</td><td>bool 类型，是否转换为协调世界时，默认 None</td></tr><tr><td>format</td><td>格式化时间，如 <code>21/2/20 16:10</code> 使用 <code>%d/%m/%y %H:%M</code> 会被解析为 <code>2020-02-21 16:10:00</code><br>符号含义常见文章：<a href="https://blog.csdn.net/qq_36759224/article/details/104427220">【Python 标准库学习】日期和时间处理库 — datetime</a> 或者<a href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior">官方文档</a></td></tr><tr><td>exact</td><td>如果为 True，则需要精确的格式匹配。如果为 False，则允许格式与目标字符串中的任何位置匹配</td></tr><tr><td>unit</td><td>如果 arg 是整数或浮点数，该参数用于设置其单位（D、s、ms、us、ns）</td></tr></tbody></table><p>简单应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;year&#39;: [2015, 2016], &#39;month&#39;: [2, 3], &#39;day&#39;: [4, 5]&#125;)&gt;&gt;&gt; obj   year  month  day0  2015      2    41  2016      3    5&gt;&gt;&gt; &gt;&gt;&gt; pd.to_datetime(obj)0   2015-02-041   2016-03-05dtype: datetime64[ns]</code></pre><p>设置 <code>format</code> 和 <code>errors</code> 参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.to_datetime(&#39;13000101&#39;, format=&#39;%Y%m%d&#39;, errors=&#39;ignore&#39;)datetime.datetime(1300, 1, 1, 0, 0)&gt;&gt;&gt; &gt;&gt;&gt; pd.to_datetime(&#39;13000101&#39;, format=&#39;%Y%m%d&#39;, errors=&#39;coerce&#39;)NaT&gt;&gt;&gt; &gt;&gt;&gt; pd.to_datetime(&#39;13000101&#39;, format=&#39;%Y%m%d&#39;, errors=&#39;raise&#39;)Traceback (most recent call last):...pandas._libs.tslibs.np_datetime.OutOfBoundsDatetime: Out of bounds nanosecond timestamp: 1300-01-01 00:00:00</code></pre><p>设置 <code>unit</code> 参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.to_datetime(1490195805, unit=&#39;s&#39;)Timestamp(&#39;2017-03-22 15:16:45&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.to_datetime(1490195805433502912, unit=&#39;ns&#39;)Timestamp(&#39;2017-03-22 15:16:45.433502912&#39;)</code></pre><h3 id="【02x04】date-range"><a href="#【02x04】date-range" class="headerlink" title="【02x04】date_range"></a><font color=#4876FF>【02x04】date_range</font></h3><p><code>pandas.date_range</code> 方法可用于根据指定的频率生成指定长度的 DatetimeIndex。</p><p>基本语法：</p><pre><code class="python">pandas.date_range(start=None, end=None, periods=None, freq=None,                   tz=None, normalize=False, name=None, closed=None,                   **kwargs) → pandas.core.indexes.datetimes.DatetimeIndex</code></pre><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.date_range.html">https://pandas.pydata.org/docs/reference/api/pandas.date_range.html</a></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>开始日期</td></tr><tr><td>end</td><td>结束日期</td></tr><tr><td>periods</td><td>int 类型，要生成的时段数（天）</td></tr><tr><td>freq</td><td>频率字符串，即按照某种特定的频率来生成日期，取值参见<a href="#t4">【02x02】freq 频率部分取值</a></td></tr><tr><td>tz</td><td>设置时区，例如 “Asia/Hong_Kong”</td></tr><tr><td>normalize</td><td>bool 类型，默认 False，是否在生成日期之前对其进行规范化（仅保留年月日）</td></tr><tr><td>name</td><td>结果 DatetimeIndex 的名称</td></tr><tr><td>closed</td><td><code>None</code>：默认值，同时保留开始日期和结束日期<br><code>&#39;left&#39;</code>：保留开始日期，不保留结束日期<br><code>&#39;right&#39;</code>：保留结束日期，不保留开始日期</td></tr></tbody></table><p>简单示例：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, end=&#39;1/08/2018&#39;)DatetimeIndex([&#39;2018-01-01&#39;, &#39;2018-01-02&#39;, &#39;2018-01-03&#39;, &#39;2018-01-04&#39;,               &#39;2018-01-05&#39;, &#39;2018-01-06&#39;, &#39;2018-01-07&#39;, &#39;2018-01-08&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</code></pre><p>指定 <code>periods</code> 参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(start=&#39;2012-04-01&#39;, periods=20)DatetimeIndex([&#39;2012-04-01&#39;, &#39;2012-04-02&#39;, &#39;2012-04-03&#39;, &#39;2012-04-04&#39;,               &#39;2012-04-05&#39;, &#39;2012-04-06&#39;, &#39;2012-04-07&#39;, &#39;2012-04-08&#39;,               &#39;2012-04-09&#39;, &#39;2012-04-10&#39;, &#39;2012-04-11&#39;, &#39;2012-04-12&#39;,               &#39;2012-04-13&#39;, &#39;2012-04-14&#39;, &#39;2012-04-15&#39;, &#39;2012-04-16&#39;,               &#39;2012-04-17&#39;, &#39;2012-04-18&#39;, &#39;2012-04-19&#39;, &#39;2012-04-20&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.date_range(end=&#39;2012-06-01&#39;, periods=20)DatetimeIndex([&#39;2012-05-13&#39;, &#39;2012-05-14&#39;, &#39;2012-05-15&#39;, &#39;2012-05-16&#39;,               &#39;2012-05-17&#39;, &#39;2012-05-18&#39;, &#39;2012-05-19&#39;, &#39;2012-05-20&#39;,               &#39;2012-05-21&#39;, &#39;2012-05-22&#39;, &#39;2012-05-23&#39;, &#39;2012-05-24&#39;,               &#39;2012-05-25&#39;, &#39;2012-05-26&#39;, &#39;2012-05-27&#39;, &#39;2012-05-28&#39;,               &#39;2012-05-29&#39;, &#39;2012-05-30&#39;, &#39;2012-05-31&#39;, &#39;2012-06-01&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)&gt;&gt;&gt;&gt;&gt;&gt; pd.date_range(start=&#39;2018-04-24&#39;, end=&#39;2018-04-27&#39;, periods=3)DatetimeIndex([&#39;2018-04-24 00:00:00&#39;, &#39;2018-04-25 12:00:00&#39;, &#39;2018-04-27 00:00:00&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=None)&gt;&gt;&gt;&gt;&gt;&gt; pd.date_range(start=&#39;2018-04-24&#39;, end=&#39;2018-04-28&#39;, periods=3)DatetimeIndex([&#39;2018-04-24&#39;, &#39;2018-04-26&#39;, &#39;2018-04-28&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</code></pre><p>指定 <code>freq=&#39;M&#39;</code> 会按照每月最后一个日历日的频率生成日期，指定 <code>freq=&#39;3M&#39;</code> 会每隔3个月按照每月最后一个日历日的频率生成日期：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, periods=5, freq=&#39;M&#39;)DatetimeIndex([&#39;2018-01-31&#39;, &#39;2018-02-28&#39;, &#39;2018-03-31&#39;, &#39;2018-04-30&#39;,               &#39;2018-05-31&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, periods=5, freq=&#39;3M&#39;)DatetimeIndex([&#39;2018-01-31&#39;, &#39;2018-04-30&#39;, &#39;2018-07-31&#39;, &#39;2018-10-31&#39;,               &#39;2019-01-31&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;3M&#39;)&gt;&gt;&gt; </code></pre><p>使用 <code>tz</code> 参数设置时区：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, periods=5, tz=&#39;Asia/Tokyo&#39;)DatetimeIndex([&#39;2018-01-01 00:00:00+09:00&#39;, &#39;2018-01-02 00:00:00+09:00&#39;,               &#39;2018-01-03 00:00:00+09:00&#39;, &#39;2018-01-04 00:00:00+09:00&#39;,               &#39;2018-01-05 00:00:00+09:00&#39;],              dtype=&#39;datetime64[ns, Asia/Tokyo]&#39;, freq=&#39;D&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.date_range(start=&#39;6/24/2020&#39;, periods=5, tz=&#39;Asia/Hong_Kong&#39;)DatetimeIndex([&#39;2020-06-24 00:00:00+08:00&#39;, &#39;2020-06-25 00:00:00+08:00&#39;,               &#39;2020-06-26 00:00:00+08:00&#39;, &#39;2020-06-27 00:00:00+08:00&#39;,               &#39;2020-06-28 00:00:00+08:00&#39;],              dtype=&#39;datetime64[ns, Asia/Hong_Kong]&#39;, freq=&#39;D&#39;)</code></pre><p>设置 <code>normalize</code> 参数，在生成时间戳之前对其进行格式化操作：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(&#39;2020-06-24 12:56:31&#39;, periods=5, normalize=True)DatetimeIndex([&#39;2020-06-24&#39;, &#39;2020-06-25&#39;, &#39;2020-06-26&#39;, &#39;2020-06-27&#39;,               &#39;2020-06-28&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</code></pre><p>设置 <code>closed</code> 参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(start=&#39;2020-06-20&#39;, end=&#39;2020-06-24&#39;, closed=None)DatetimeIndex([&#39;2020-06-20&#39;, &#39;2020-06-21&#39;, &#39;2020-06-22&#39;, &#39;2020-06-23&#39;,               &#39;2020-06-24&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.date_range(start=&#39;2020-06-20&#39;, end=&#39;2020-06-24&#39;, closed=&#39;left&#39;)DatetimeIndex([&#39;2020-06-20&#39;, &#39;2020-06-21&#39;, &#39;2020-06-22&#39;, &#39;2020-06-23&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.date_range(start=&#39;2020-06-20&#39;, end=&#39;2020-06-24&#39;, closed=&#39;right&#39;)DatetimeIndex([&#39;2020-06-21&#39;, &#39;2020-06-22&#39;, &#39;2020-06-23&#39;, &#39;2020-06-24&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</code></pre><h3 id="【02x05】索引与切片"><a href="#【02x05】索引与切片" class="headerlink" title="【02x05】索引与切片"></a><font color=#4876FF>【02x05】索引与切片</font></h3><p>Pandas 最基本的时间序列类型就是以时间戳（通常以 Python 字符串或 datatime 对象表示）为索引的Series，这些 datetime 对象实际上是被放在 DatetimeIndex 中的，可以使用类似 pandas.Series 对象的切片方法对其进行索引：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; dates = [datetime(2011, 1, 2), datetime(2011, 1, 5),             datetime(2011, 1, 7), datetime(2011, 1, 8),             datetime(2011, 1, 10), datetime(2011, 1, 12)]&gt;&gt;&gt; obj = pd.Series(np.random.randn(6), index=dates)&gt;&gt;&gt; &gt;&gt;&gt; obj2011-01-02   -0.4071102011-01-05   -0.1866612011-01-07   -0.7310802011-01-08    0.8609702011-01-10    1.9299732011-01-12   -0.168599dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.indexDatetimeIndex([&#39;2011-01-02&#39;, &#39;2011-01-05&#39;, &#39;2011-01-07&#39;, &#39;2011-01-08&#39;,               &#39;2011-01-10&#39;, &#39;2011-01-12&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=None)&gt;&gt;&gt;&gt;&gt;&gt; obj.index[0]Timestamp(&#39;2011-01-02 00:00:00&#39;)&gt;&gt;&gt; &gt;&gt;&gt; obj.index[0:3]DatetimeIndex([&#39;2011-01-02&#39;, &#39;2011-01-05&#39;, &#39;2011-01-07&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</code></pre><p>另外还可以传入一个可以被解释为日期的字符串，或者只需传入“年”或“年月”即可轻松选取数据的切片：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series(np.random.randn(1000), index=pd.date_range(&#39;1/1/2000&#39;, periods=1000))&gt;&gt;&gt; obj2000-01-01   -1.1422842000-01-02    1.1987852000-01-03    2.4669092000-01-04   -0.0867282000-01-05   -0.978437                ...   2002-09-22   -0.2522402002-09-23    0.1485612002-09-24   -1.3304092002-09-25   -0.6734712002-09-26   -0.253271Freq: D, Length: 1000, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;26/9/2002&#39;]-0.25327100684233356&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;2002&#39;]2002-01-01    1.0587152002-01-02    0.9008592002-01-03    1.9935082002-01-04   -0.1032112002-01-05   -0.950090                ...   2002-09-22   -0.2522402002-09-23    0.1485612002-09-24   -1.3304092002-09-25   -0.6734712002-09-26   -0.253271Freq: D, Length: 269, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;2002-09&#39;]2002-09-01   -0.9955282002-09-02    0.5015282002-09-03   -0.4867532002-09-04   -1.0839062002-09-05    1.4589752002-09-06   -1.3316852002-09-07    0.1953382002-09-08   -0.4296132002-09-09    1.1258232002-09-10    1.6070512002-09-11    0.5303872002-09-12   -0.0159382002-09-13    1.7810432002-09-14   -0.2771232002-09-15    0.3445692002-09-16   -1.0108102002-09-17    0.4630012002-09-18    1.8836362002-09-19    0.2745202002-09-20    0.6241842002-09-21   -1.2030572002-09-22   -0.2522402002-09-23    0.1485612002-09-24   -1.3304092002-09-25   -0.6734712002-09-26   -0.253271Freq: D, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;20/9/2002&#39;:&#39;26/9/2002&#39;]2002-09-20    0.6241842002-09-21   -1.2030572002-09-22   -0.2522402002-09-23    0.1485612002-09-24   -1.3304092002-09-25   -0.6734712002-09-26   -0.253271Freq: D, dtype: float64</code></pre><h3 id="【02x06】移动数据与数据偏移"><a href="#【02x06】移动数据与数据偏移" class="headerlink" title="【02x06】移动数据与数据偏移"></a><font color=#4876FF>【02x06】移动数据与数据偏移</font></h3><p>移动（shifting）指的是沿着时间轴将数据前移或后移。Series 和 DataFrame 都有一个 shift 方法用于执行单纯的前移或后移操作，保持索引不变：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series(np.random.randn(4),            index=pd.date_range(&#39;1/1/2000&#39;, periods=4, freq=&#39;M&#39;))&gt;&gt;&gt; obj2000-01-31   -0.1002172000-02-29    1.1778342000-03-31   -0.6443532000-04-30   -1.954679Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.shift(2)2000-01-31         NaN2000-02-29         NaN2000-03-31   -0.1002172000-04-30    1.177834Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.shift(-2)2000-01-31   -0.6443532000-02-29   -1.9546792000-03-31         NaN2000-04-30         NaNFreq: M, dtype: float64</code></pre><p>因为简单的移位操作不会修改索引，所以部分数据会被丢弃并引入 NaN（缺失值）。因此，如果频率已知，则可以将其传给 shift 以便实现对时间戳进行位移而不是对数据进行简单位移：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series(np.random.randn(4),            index=pd.date_range(&#39;1/1/2000&#39;, periods=4, freq=&#39;M&#39;))&gt;&gt;&gt; obj2000-01-31   -0.1002172000-02-29    1.1778342000-03-31   -0.6443532000-04-30   -1.954679Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.shift(2, freq=&#39;M&#39;)2000-03-31   -0.1002172000-04-30    1.1778342000-05-31   -0.6443532000-06-30   -1.954679Freq: M, dtype: float64</code></pre><p>Pandas 中的频率是由一个基础频率（base frequency）和一个乘数组成的。基础频率通常以一个字符串别名表示，比如 <code>&quot;M&quot;</code> 表示每月，<code>&quot;H&quot;</code> 表示每小时。对于每个基础频率，都有一个被称为日期偏移量（date offset）的对象与之对应。例如，按小时计算的频率可以用 <code>Hour</code> 类表示：</p><pre><code class="python">&gt;&gt;&gt; from pandas.tseries.offsets import Hour, Minute&gt;&gt;&gt; hour = Hour()&gt;&gt;&gt; hour&lt;Hour&gt;&gt;&gt;&gt; &gt;&gt;&gt; four_hours = Hour(4)&gt;&gt;&gt; four_hours&lt;4 * Hours&gt;</code></pre><p>一般来说，无需明确创建这样的对象，只需使用诸如 <code>&quot;H&quot;</code> 或 <code>&quot;4H&quot;</code> 这样的字符串别名即可。在基础频率前面放上一个整数即可创建倍数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(&#39;2000-01-01&#39;, &#39;2000-01-03 23:59&#39;, freq=&#39;4h&#39;)DatetimeIndex([&#39;2000-01-01 00:00:00&#39;, &#39;2000-01-01 04:00:00&#39;,               &#39;2000-01-01 08:00:00&#39;, &#39;2000-01-01 12:00:00&#39;,               &#39;2000-01-01 16:00:00&#39;, &#39;2000-01-01 20:00:00&#39;,               &#39;2000-01-02 00:00:00&#39;, &#39;2000-01-02 04:00:00&#39;,               &#39;2000-01-02 08:00:00&#39;, &#39;2000-01-02 12:00:00&#39;,               &#39;2000-01-02 16:00:00&#39;, &#39;2000-01-02 20:00:00&#39;,               &#39;2000-01-03 00:00:00&#39;, &#39;2000-01-03 04:00:00&#39;,               &#39;2000-01-03 08:00:00&#39;, &#39;2000-01-03 12:00:00&#39;,               &#39;2000-01-03 16:00:00&#39;, &#39;2000-01-03 20:00:00&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;4H&#39;)</code></pre><p>大部分偏移量对象都可通过加法进行连接：</p><pre><code class="python">&gt;&gt;&gt; from pandas.tseries.offsets import Hour, Minute&gt;&gt;&gt; Hour(2) + Minute(30)&lt;150 * Minutes&gt;</code></pre><p>对于 <code>freq</code> 参数也可以传入频率字符串（如 <code>&quot;2h30min&quot;</code>），这种字符串可以被高效地解析为等效的表达式：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(&#39;2000-01-01&#39;, periods=10, freq=&#39;1h30min&#39;)DatetimeIndex([&#39;2000-01-01 00:00:00&#39;, &#39;2000-01-01 01:30:00&#39;,               &#39;2000-01-01 03:00:00&#39;, &#39;2000-01-01 04:30:00&#39;,               &#39;2000-01-01 06:00:00&#39;, &#39;2000-01-01 07:30:00&#39;,               &#39;2000-01-01 09:00:00&#39;, &#39;2000-01-01 10:30:00&#39;,               &#39;2000-01-01 12:00:00&#39;, &#39;2000-01-01 13:30:00&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;90T&#39;)</code></pre><p>这种偏移量还可以用在 datetime 或 Timestamp 对象上：</p><pre><code class="python">&gt;&gt;&gt; from pandas.tseries.offsets import Day, MonthEnd&gt;&gt;&gt; now = datetime(2011, 11, 17)&gt;&gt;&gt; now + 3 * Day()Timestamp(&#39;2011-11-20 00:00:00&#39;)</code></pre><p>如果加的是锚点偏移量，比如 MonthEnd，第一次增量会将原日期向前滚动到符合频率规则的下一个日期：</p><pre><code class="python">&gt;&gt;&gt; from pandas.tseries.offsets import Day, MonthEnd&gt;&gt;&gt; now = datetime(2011, 11, 17)&gt;&gt;&gt; now + MonthEnd()Timestamp(&#39;2011-11-30 00:00:00&#39;)&gt;&gt;&gt; now + MonthEnd(2)Timestamp(&#39;2011-12-31 00:00:00&#39;)</code></pre><p>通过锚点偏移量的 rollforward 和 rollback 方法，可明确地将日期向前或向后滚动：</p><pre><code class="python">&gt;&gt;&gt; from pandas.tseries.offsets import Day, MonthEnd&gt;&gt;&gt; now = datetime(2011, 11, 17)&gt;&gt;&gt; offset = MonthEnd()&gt;&gt;&gt; offset.rollforward(now)Timestamp(&#39;2011-11-30 00:00:00&#39;)&gt;&gt;&gt; offset.rollback(now)Timestamp(&#39;2011-10-31 00:00:00&#39;)</code></pre><p>与 <code>groupby</code> 方法结合使用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; from pandas.tseries.offsets import Day, MonthEnd&gt;&gt;&gt; obj = pd.Series(np.random.randn(20),            index=pd.date_range(&#39;1/15/2000&#39;, periods=20, freq=&#39;4d&#39;))&gt;&gt;&gt; obj2000-01-15   -0.5917292000-01-19   -0.7758442000-01-23   -0.7456032000-01-27   -0.0764392000-01-31    1.7964172000-02-04   -0.5003492000-02-08    0.5158512000-02-12   -0.3441712000-02-16    0.4196572000-02-20    0.3072882000-02-24    0.1151132000-02-28   -0.3625852000-03-03    1.0748922000-03-07    1.1113662000-03-11    0.9499102000-03-15   -1.5357272000-03-19    0.5459442000-03-23   -0.8101392000-03-27   -1.2606272000-03-31   -0.128403Freq: 4D, dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; offset = MonthEnd()&gt;&gt;&gt; obj.groupby(offset.rollforward).mean()2000-01-31   -0.0786402000-02-29    0.0215432000-03-31   -0.006598dtype: float64</code></pre><h3 id="【02x07】时区处理"><a href="#【02x07】时区处理" class="headerlink" title="【02x07】时区处理"></a><font color=#4876FF>【02x07】时区处理</font></h3><p>在 Python 中，时区信息来自第三方库 pytz，使用 <code>pytz.common_timezones</code> 方法可以查看所有的时区名称，使用 <code>pytz.timezone</code> 方法从 pytz 中获取时区对象：</p><pre><code class="python">&gt;&gt;&gt; import pytz&gt;&gt;&gt; pytz.common_timezones[&#39;Africa/Abidjan&#39;, &#39;Africa/Accra&#39;, &#39;Africa/Addis_Ababa&#39;, ..., &#39;UTC&#39;]&gt;&gt;&gt;&gt;&gt;&gt; tz = pytz.timezone(&#39;Asia/Shanghai&#39;)&gt;&gt;&gt; tz&lt;DstTzInfo &#39;Asia/Shanghai&#39; LMT+8:06:00 STD&gt;  # 表示与 UTC 时间相差8小时6分</code></pre><p>在 <code>date_range</code> 方法中，<code>tz</code> 参数用于指定时区，默认为 None，可以使用 <code>tz_localize</code> 方法将其进行本地化时区转换，如下示例中，将无时区转本地化 UTC 时区：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; rng = pd.date_range(&#39;3/9/2012 9:30&#39;, periods=6, freq=&#39;D&#39;)&gt;&gt;&gt; ts = pd.Series(np.random.randn(len(rng)), index=rng)&gt;&gt;&gt; ts2012-03-09 09:30:00   -1.5279132012-03-10 09:30:00   -1.1161012012-03-11 09:30:00    0.3593582012-03-12 09:30:00   -0.4759202012-03-13 09:30:00   -0.3365702012-03-14 09:30:00   -1.075952Freq: D, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; print(ts.index.tz)None&gt;&gt;&gt; &gt;&gt;&gt; ts_utc = ts.tz_localize(&#39;UTC&#39;)&gt;&gt;&gt; ts_utc2012-03-09 09:30:00+00:00   -1.5279132012-03-10 09:30:00+00:00   -1.1161012012-03-11 09:30:00+00:00    0.3593582012-03-12 09:30:00+00:00   -0.4759202012-03-13 09:30:00+00:00   -0.3365702012-03-14 09:30:00+00:00   -1.075952Freq: D, dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; ts_utc.indexDatetimeIndex([&#39;2012-03-09 09:30:00+00:00&#39;, &#39;2012-03-10 09:30:00+00:00&#39;,               &#39;2012-03-11 09:30:00+00:00&#39;, &#39;2012-03-12 09:30:00+00:00&#39;,               &#39;2012-03-13 09:30:00+00:00&#39;, &#39;2012-03-14 09:30:00+00:00&#39;],              dtype=&#39;datetime64[ns, UTC]&#39;, freq=&#39;D&#39;)</code></pre><p>时间序列被本地化到某个特定时区后，就可以用 <code>tz_convert</code> 方法将其转换到别的时区了：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; rng = pd.date_range(&#39;3/9/2012 9:30&#39;, periods=6, freq=&#39;D&#39;)&gt;&gt;&gt; ts = pd.Series(np.random.randn(len(rng)), index=rng)&gt;&gt;&gt; ts2012-03-09 09:30:00    0.4803032012-03-10 09:30:00   -1.4610392012-03-11 09:30:00   -1.5127492012-03-12 09:30:00   -2.1854212012-03-13 09:30:00    1.6578452012-03-14 09:30:00    0.175633Freq: D, dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; ts.tz_localize(&#39;UTC&#39;).tz_convert(&#39;Asia/Shanghai&#39;)2012-03-09 17:30:00+08:00    0.4803032012-03-10 17:30:00+08:00   -1.4610392012-03-11 17:30:00+08:00   -1.5127492012-03-12 17:30:00+08:00   -2.1854212012-03-13 17:30:00+08:00    1.6578452012-03-14 17:30:00+08:00    0.175633Freq: D, dtype: float64</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106947061未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【03x00】period-固定时期"><a href="#【03x00】period-固定时期" class="headerlink" title="【03x00】period 固定时期"></a><font color=#FF0000>【03x00】period 固定时期</font></h2><h3 id="【03x01】pandas-Period"><a href="#【03x01】pandas-Period" class="headerlink" title="【03x01】pandas.Period"></a><font color=#4876FF>【03x01】pandas.Period</font></h3><p>固定时期（period）表示的是时间区间，比如数日、数月、数季、数年等。Period 类所表示的就是这种数据类型，其构造函数需要用到一个字符串或整数。</p><p>基本语法：</p><pre><code class="python">class pandas.Period(value=None, freq=None, ordinal=None,                     year=None, month=None, quarter=None,                     day=None, hour=None, minute=None, second=None)</code></pre><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Period.html">https://pandas.pydata.org/docs/reference/api/pandas.Period.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>时间段</td></tr><tr><td>freq</td><td>时间戳将具有的偏移量，可以是 str，日期偏移量类型，取值参见<a href="#t4">【02x02】freq 频率部分取值</a></td></tr></tbody></table><p>以下示例中，Period 对象表示的是从2020年1月1日到2020年12月31日之间的整段时间</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Period(2020, freq=&#39;A-DEC&#39;)Period(&#39;2020&#39;, &#39;A-DEC&#39;)</code></pre><p>利用加减法对其按照频率进行位移：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Period(2020, freq=&#39;A-DEC&#39;)&gt;&gt;&gt; objPeriod(&#39;2020&#39;, &#39;A-DEC&#39;)&gt;&gt;&gt; &gt;&gt;&gt; obj + 5Period(&#39;2025&#39;, &#39;A-DEC&#39;)&gt;&gt;&gt; &gt;&gt;&gt; obj - 5Period(&#39;2015&#39;, &#39;A-DEC&#39;)</code></pre><p>PeriodIndex 类保存了一组 Period，它可以在任何 pandas 数据结构中被用作轴索引：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; rng = [pd.Period(&#39;2000-01&#39;), pd.Period(&#39;2000-02&#39;), pd.Period(&#39;2000-03&#39;),            pd.Period(&#39;2000-04&#39;), pd.Period(&#39;2000-05&#39;), pd.Period(&#39;2000-06&#39;)]&gt;&gt;&gt; obj = pd.Series(np.random.randn(6), index=rng)&gt;&gt;&gt; obj2000-01    0.2290922000-02    1.5154982000-03   -0.3344012000-04   -0.4926812000-05   -2.0128182000-06    0.338804Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.indexPeriodIndex([&#39;2000-01&#39;, &#39;2000-02&#39;, &#39;2000-03&#39;, &#39;2000-04&#39;, &#39;2000-05&#39;, &#39;2000-06&#39;], dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)</code></pre><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; values = [&#39;2001Q3&#39;, &#39;2002Q2&#39;, &#39;2003Q1&#39;]&gt;&gt;&gt; index = pd.PeriodIndex(values, freq=&#39;Q-DEC&#39;)&gt;&gt;&gt; indexPeriodIndex([&#39;2001Q3&#39;, &#39;2002Q2&#39;, &#39;2003Q1&#39;], dtype=&#39;period[Q-DEC]&#39;, freq=&#39;Q-DEC&#39;)&gt;&gt;&gt; </code></pre><h3 id="【03x02】period-range"><a href="#【03x02】period-range" class="headerlink" title="【03x02】period_range"></a><font color=#4876FF>【03x02】period_range</font></h3><p><code>pandas.period_range</code> 方法可根据指定的频率生成指定长度的 PeriodIndex。</p><p>基本语法：</p><p><code>pandas.period_range(start=None, end=None, periods=None, freq=None, name=None) → pandas.core.indexes.period.PeriodIndex</code></p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.period_range.html">https://pandas.pydata.org/docs/reference/api/pandas.period_range.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>起始日期</td></tr><tr><td>end</td><td>结束日期</td></tr><tr><td>periods</td><td>要生成的时段数</td></tr><tr><td>freq</td><td>时间戳将具有的偏移量，可以是 str，日期偏移量类型，取值参见<a href="#t4">【02x02】freq 频率部分取值</a></td></tr><tr><td>name</td><td>结果 PeriodIndex 对象名称</td></tr></tbody></table><p>简单应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.period_range(start=&#39;2019-01-01&#39;, end=&#39;2020-01-01&#39;, freq=&#39;M&#39;)PeriodIndex([&#39;2019-01&#39;, &#39;2019-02&#39;, &#39;2019-03&#39;, &#39;2019-04&#39;, &#39;2019-05&#39;, &#39;2019-06&#39;,             &#39;2019-07&#39;, &#39;2019-08&#39;, &#39;2019-09&#39;, &#39;2019-10&#39;, &#39;2019-11&#39;, &#39;2019-12&#39;,             &#39;2020-01&#39;],            dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)&gt;&gt;&gt;&gt;&gt;&gt; pd.period_range(start=pd.Period(&#39;2017Q1&#39;, freq=&#39;Q&#39;),                    end=pd.Period(&#39;2017Q2&#39;, freq=&#39;Q&#39;), freq=&#39;M&#39;)PeriodIndex([&#39;2017-03&#39;, &#39;2017-04&#39;, &#39;2017-05&#39;, &#39;2017-06&#39;], dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)</code></pre><h3 id="【03x03】asfreq-时期频率转换"><a href="#【03x03】asfreq-时期频率转换" class="headerlink" title="【03x03】asfreq 时期频率转换"></a><font color=#4876FF>【03x03】asfreq 时期频率转换</font></h3><p>Period 和 PeriodIndex 对象都可以通过 asfreq 方法被转换成别的频率。</p><p>基本语法：<code>PeriodIndex.asfreq(self, *args, **kwargs)</code></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>freq</td><td>新的频率（偏移量），取值参见<a href="#t4">【02x02】freq 频率部分取值</a></td></tr><tr><td>how</td><td>按照开始或者结束对齐，<code>&#39;E&#39;</code> or <code>&#39;END&#39;</code> or <code>&#39;FINISH&#39;</code>；<code>&#39;S&#39;</code> or <code>&#39;START&#39;</code> or <code>&#39;BEGIN&#39;</code></td></tr></tbody></table><p>应用示例：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pidx = pd.period_range(&#39;2010-01-01&#39;, &#39;2015-01-01&#39;, freq=&#39;A&#39;)&gt;&gt;&gt; pidxPeriodIndex([&#39;2010&#39;, &#39;2011&#39;, &#39;2012&#39;, &#39;2013&#39;, &#39;2014&#39;, &#39;2015&#39;], dtype=&#39;period[A-DEC]&#39;, freq=&#39;A-DEC&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pidx.asfreq(&#39;M&#39;)PeriodIndex([&#39;2010-12&#39;, &#39;2011-12&#39;, &#39;2012-12&#39;, &#39;2013-12&#39;, &#39;2014-12&#39;, &#39;2015-12&#39;], dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pidx.asfreq(&#39;M&#39;, how=&#39;S&#39;)PeriodIndex([&#39;2010-01&#39;, &#39;2011-01&#39;, &#39;2012-01&#39;, &#39;2013-01&#39;, &#39;2014-01&#39;, &#39;2015-01&#39;], dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)</code></pre><h3 id="【03x04】to-period-与-to-timestamp"><a href="#【03x04】to-period-与-to-timestamp" class="headerlink" title="【03x04】to_period 与 to_timestamp()"></a><font color=#4876FF>【03x04】to_period 与 to_timestamp()</font></h3><p><code>to_period</code> 方法可以将 Timestamp（时间戳） 转换为 Period（固定时期）；</p><p><code>to_timestamp</code> 方法可以将 Period（固定时期）转换为 Timestamp（时间戳） 。</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; rng = pd.date_range(&#39;2000-01-01&#39;, periods=3, freq=&#39;M&#39;)&gt;&gt;&gt; ts = pd.Series(np.random.randn(3), index=rng)&gt;&gt;&gt; ts2000-01-31    0.2207592000-02-29   -0.1082212000-03-31    0.819433Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; pts = ts.to_period()&gt;&gt;&gt; pts2000-01    0.2207592000-02   -0.1082212000-03    0.819433Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; pts2 = pts.to_timestamp()&gt;&gt;&gt; pts22000-01-01    0.2207592000-02-01   -0.1082212000-03-01    0.819433Freq: MS, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; ts.indexDatetimeIndex([&#39;2000-01-31&#39;, &#39;2000-02-29&#39;, &#39;2000-03-31&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pts.indexPeriodIndex([&#39;2000-01&#39;, &#39;2000-02&#39;, &#39;2000-03&#39;], dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pts2.indexDatetimeIndex([&#39;2000-01-01&#39;, &#39;2000-02-01&#39;, &#39;2000-03-01&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;MS&#39;)</code></pre><h2 id="【04x00】timedelta-时间间隔"><a href="#【04x00】timedelta-时间间隔" class="headerlink" title="【04x00】timedelta 时间间隔"></a><font color=#FF0000>【04x00】timedelta 时间间隔</font></h2><h3 id="【04x01】pandas-Timedelta"><a href="#【04x01】pandas-Timedelta" class="headerlink" title="【04x01】pandas.Timedelta"></a><font color=#4876FF>【04x01】pandas.Timedelta</font></h3><p>Timedelta 表示持续时间，即两个日期或时间之间的差。</p><p>Timedelta 相当于 Python 的 datetime.timedelta，在大多数情况下两者可以互换。</p><p>基本语法：<code>class pandas.Timedelta(value=&lt;object object&gt;, unit=None, **kwargs)</code></p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Timedelta.html">https://pandas.pydata.org/docs/reference/api/pandas.Timedelta.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>传入的值，可以是 Timedelta，timedelta，np.timedelta64，string 或 integer 对象</td></tr><tr><td>unit</td><td>用于设置 value 的单位，具体取值参见官方文档</td></tr></tbody></table><p>表示两个 datetime 对象之间的时间差：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.to_datetime(&#39;2020-6-24&#39;) - pd.to_datetime(&#39;2016-1-1&#39;)Timedelta(&#39;1636 days 00:00:00&#39;)</code></pre><p>通过字符串传递参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Timedelta(&#39;3 days 3 hours 3 minutes 30 seconds&#39;)Timedelta(&#39;3 days 03:03:30&#39;)</code></pre><p>通过整数传递参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Timedelta(5,unit=&#39;h&#39;)Timedelta(&#39;0 days 05:00:00&#39;)</code></pre><p>获取属性：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Timedelta(&#39;3 days 3 hours 3 minutes 30 seconds&#39;)&gt;&gt;&gt; objTimedelta(&#39;3 days 03:03:30&#39;)&gt;&gt;&gt; &gt;&gt;&gt; obj.days3&gt;&gt;&gt; obj.seconds11010</code></pre><h3 id="【04x02】to-timedelta"><a href="#【04x02】to-timedelta" class="headerlink" title="【04x02】to_timedelta"></a><font color=#4876FF>【04x02】to_timedelta</font></h3><p>to_timedelta 方法可以将传入的对象转换成 timedelta 对象。</p><p>基本语法：<code>pandas.to_timedelta(arg, unit=&#39;ns&#39;, errors=&#39;raise&#39;)</code></p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.to_timedelta.html">https://pandas.pydata.org/docs/reference/api/pandas.to_timedelta.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>arg</td><td>要转换为 timedelta 的对象，可以是 str，timedelta，list-like 或 Series 对象</td></tr><tr><td>unit</td><td>用于设置 arg 的单位，具体取值参见官方文档</td></tr><tr><td>errors</td><td>如果 arg 不满足时间戳的形式，是否会发生异常<br><code>ignore</code>：不引发异常，返回原始输入；<code>raise</code>：无效解析将引发异常（默认）；<code>coerce</code>：无效解析将被设置为NaT</td></tr></tbody></table><p>将单个字符串解析为 timedelta 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.to_timedelta(&#39;1 days 06:05:01.00003&#39;)Timedelta(&#39;1 days 06:05:01.000030&#39;)&gt;&gt;&gt;&gt;&gt;&gt; pd.to_timedelta(&#39;15.5us&#39;)Timedelta(&#39;0 days 00:00:00.000015&#39;)</code></pre><p>将字符串列表或数组解析为  timedelta 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.to_timedelta([&#39;1 days 06:05:01.00003&#39;, &#39;15.5us&#39;, &#39;nan&#39;])TimedeltaIndex([&#39;1 days 06:05:01.000030&#39;, &#39;0 days 00:00:00.000015&#39;, NaT], dtype=&#39;timedelta64[ns]&#39;, freq=None)</code></pre><p>指定 <code>unit</code> 参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.to_timedelta(np.arange(5), unit=&#39;s&#39;)TimedeltaIndex([&#39;00:00:00&#39;, &#39;00:00:01&#39;, &#39;00:00:02&#39;, &#39;00:00:03&#39;, &#39;00:00:04&#39;], dtype=&#39;timedelta64[ns]&#39;, freq=None)&gt;&gt;&gt; &gt;&gt;&gt; pd.to_timedelta(np.arange(5), unit=&#39;d&#39;)TimedeltaIndex([&#39;0 days&#39;, &#39;1 days&#39;, &#39;2 days&#39;, &#39;3 days&#39;, &#39;4 days&#39;], dtype=&#39;timedelta64[ns]&#39;, freq=None)</code></pre><h3 id="【04x03】timedelta-range"><a href="#【04x03】timedelta-range" class="headerlink" title="【04x03】timedelta_range"></a><font color=#4876FF>【04x03】timedelta_range</font></h3><p><code>timedelta_range</code> 方法可根据指定的频率生成指定长度的 TimedeltaIndex。</p><p>基本语法：</p><pre><code class="python">pandas.timedelta_range(start=None, end=None, periods=None,                       freq=None, name=None, closed=None) → pandas.core.indexes.timedeltas.TimedeltaIndex</code></pre><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.timedelta_range.html">https://pandas.pydata.org/docs/reference/api/pandas.timedelta_range.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>开始日期</td></tr><tr><td>end</td><td>结束日期</td></tr><tr><td>periods</td><td>int 类型，要生成的时段数</td></tr><tr><td>freq</td><td>频率字符串，即按照某种特定的频率来生成日期，取值参见<a href="#t4">【02x02】freq 频率部分取值</a></td></tr><tr><td>name</td><td>结果 TimedeltaIndex 的名称</td></tr><tr><td>closed</td><td><code>None</code>：默认值，同时保留开始日期和结束日期<br><code>&#39;left&#39;</code>：保留开始日期，不保留结束日期<br><code>&#39;right&#39;</code>：保留结束日期，不保留开始日期</td></tr></tbody></table><p>应用示例：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.timedelta_range(start=&#39;1 day&#39;, periods=4)TimedeltaIndex([&#39;1 days&#39;, &#39;2 days&#39;, &#39;3 days&#39;, &#39;4 days&#39;], dtype=&#39;timedelta64[ns]&#39;, freq=&#39;D&#39;)</code></pre><p>closed 参数指定保留哪个端点。默认保留两个端点：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.timedelta_range(start=&#39;1 day&#39;, periods=4, closed=&#39;right&#39;)TimedeltaIndex([&#39;2 days&#39;, &#39;3 days&#39;, &#39;4 days&#39;], dtype=&#39;timedelta64[ns]&#39;, freq=&#39;D&#39;)</code></pre><p>freq 参数指定 TimedeltaIndex 的频率。只接受固定频率，非固定频率如 <code>&#39;M&#39;</code> 将会报错：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.timedelta_range(start=&#39;1 day&#39;, end=&#39;2 days&#39;, freq=&#39;6H&#39;)TimedeltaIndex([&#39;1 days 00:00:00&#39;, &#39;1 days 06:00:00&#39;, &#39;1 days 12:00:00&#39;,                &#39;1 days 18:00:00&#39;, &#39;2 days 00:00:00&#39;],               dtype=&#39;timedelta64[ns]&#39;, freq=&#39;6H&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.timedelta_range(start=&#39;1 day&#39;, end=&#39;2 days&#39;, freq=&#39;M&#39;)Traceback (most recent call last):...ValueError: &lt;MonthEnd&gt; is a non-fixed frequency</code></pre><h2 id="【05x00】重采样及频率转换"><a href="#【05x00】重采样及频率转换" class="headerlink" title="【05x00】重采样及频率转换"></a><font color=#FF0000>【05x00】重采样及频率转换</font></h2><p>重采样（resampling）指的是将时间序列从一个频率转换到另一个频率的处理过程。将高频率数据聚合到低频率称为降采样（downsampling），而将低频率数据转换到高频率则称为升采样（upsampling）。并不是所有的重采样都能被划分到这两个大类中。例如，将 W-WED（每周三）转换为 W-FRI 既不是降采样也不是升采样。</p><p>Pandas 中提供了 resample 方法来帮助我们实现重采样。Pandas 对象都带有一个 resample 方法，它是各种频率转换工作的主力函数。</p><p>基本语法：</p><pre><code class="python">Series.resample(self, rule, axis=0,                 closed: Union[str, NoneType] = None,                 label: Union[str, NoneType] = None,                 convention: str = &#39;start&#39;,                 kind: Union[str, NoneType] = None,                 loffset=None, base: int = 0,                 on=None, level=None)</code></pre><pre><code class="python">DataFrame.resample(self, rule, axis=0,                    closed: Union[str, NoneType] = None,                    label: Union[str, NoneType] = None,                    convention: str = &#39;start&#39;,                    kind: Union[str, NoneType] = None,                    loffset=None, base: int = 0,                    on=None, level=None)</code></pre><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>rule</td><td></td></tr><tr><td>axis</td><td>重采样的轴，默认 0</td></tr><tr><td>closed</td><td>在重采样中，各时间段的哪一端是闭合（即包含）的，<br>除 <code>&#39;M&#39;</code>、<code>&#39;A&#39;</code>、<code>&#39;Q&#39;</code>、<code>&#39;BM&#39;</code>、<code>&#39;BA&#39;</code>、<code>&#39;BQ&#39;</code> 和 <code>&#39;W&#39;</code> 默认值为 ‘right’ 外，其他默认值为 ‘left‘</td></tr><tr><td>label</td><td>在重采样中，如何设置聚合值的标签， right 或 left，默认为 None，<br>例如，9:30 到 9:35 之间的这 5 分钟会被标记为 9:30 或 9:35</td></tr><tr><td>convention</td><td>仅用于 PeriodIndex（固定时期），对周期进行重采样，<code>&#39;start&#39;</code> or <code>&#39;s&#39;</code>，<code>&#39;end&#39;</code> or <code>&#39;e&#39;</code></td></tr><tr><td>on</td><td>对于 DataFrame 对象，可用该参数指定重采样后的数据的 index（行索引） 为原数据中的某列</td></tr><tr><td>level</td><td>对于具有层级索引（MultiIndex）的 DataFrame 对象，可以使用该参数来指定需要在哪个级别上进行重新采样</td></tr></tbody></table><p>将序列重采样到三分钟的频率，并将每个频率的值相加：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; series.resample(&#39;3T&#39;).sum()2000-01-01 00:00:00     32000-01-01 00:03:00    122000-01-01 00:06:00    21Freq: 3T, dtype: int64</code></pre><p>设置 <code>label=&#39;right&#39;</code>，即每个索引 index 会使用靠右侧（较大值）的标签：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; series.resample(&#39;3T&#39;, label=&#39;right&#39;).sum()2000-01-01 00:03:00     32000-01-01 00:06:00    122000-01-01 00:09:00    21Freq: 3T, dtype: int64</code></pre><p>设置 <code>closed=&#39;right&#39;</code>，即结果中会包含原数据中最右侧（较大）的值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; series.resample(&#39;3T&#39;, label=&#39;right&#39;, closed=&#39;right&#39;).sum()2000-01-01 00:00:00     02000-01-01 00:03:00     62000-01-01 00:06:00    152000-01-01 00:09:00    15Freq: 3T, dtype: int64</code></pre><p>以下示例将序列重采样到30秒的频率，<code>asfreq()[0:5]</code> 用于选择前5行数据：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; series.resample(&#39;30S&#39;).asfreq()[0:5]2000-01-01 00:00:00    0.02000-01-01 00:00:30    NaN2000-01-01 00:01:00    1.02000-01-01 00:01:30    NaN2000-01-01 00:02:00    2.0Freq: 30S, dtype: float64</code></pre><p>使用 <code>pad</code> 方法向后填充缺失值（NaN）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; series.resample(&#39;30S&#39;).pad()[0:5]2000-01-01 00:00:00    02000-01-01 00:00:30    02000-01-01 00:01:00    12000-01-01 00:01:30    12000-01-01 00:02:00    2Freq: 30S, dtype: int64</code></pre><p>使用 <code>bfill</code> 方法向前填充缺失值（NaN）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; series.resample(&#39;30S&#39;).bfill()[0:5]2000-01-01 00:00:00    02000-01-01 00:00:30    12000-01-01 00:01:00    12000-01-01 00:01:30    22000-01-01 00:02:00    2Freq: 30S, dtype: int64</code></pre><p>通过 <code>apply</code> 方法传递自定义函数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; def custom_resampler(array_like):    return np.sum(array_like) + 5&gt;&gt;&gt; series.resample(&#39;3T&#39;).apply(custom_resampler)2000-01-01 00:00:00     82000-01-01 00:03:00    172000-01-01 00:06:00    26Freq: 3T, dtype: int64</code></pre><p>convention 参数的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; s = pd.Series([1, 2], index=pd.period_range(&#39;2012-01-01&#39;, freq=&#39;A&#39;, periods=2))&gt;&gt;&gt; s2012    12013    2Freq: A-DEC, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; s.resample(&#39;Q&#39;, convention=&#39;start&#39;).asfreq()2012Q1    1.02012Q2    NaN2012Q3    NaN2012Q4    NaN2013Q1    2.02013Q2    NaN2013Q3    NaN2013Q4    NaNFreq: Q-DEC, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; s.resample(&#39;Q&#39;, convention=&#39;end&#39;).asfreq()2012Q4    1.02013Q1    NaN2013Q2    NaN2013Q3    NaN2013Q4    2.0Freq: Q-DEC, dtype: float64</code></pre><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; q = pd.Series([1, 2, 3, 4], index=pd.period_range(&#39;2018-01-01&#39;, freq=&#39;Q&#39;, periods=4))&gt;&gt;&gt; q2018Q1    12018Q2    22018Q3    32018Q4    4Freq: Q-DEC, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; q.resample(&#39;M&#39;, convention=&#39;end&#39;).asfreq()2018-03    1.02018-04    NaN2018-05    NaN2018-06    2.02018-07    NaN2018-08    NaN2018-09    3.02018-10    NaN2018-11    NaN2018-12    4.0Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; q.resample(&#39;M&#39;, convention=&#39;start&#39;).asfreq()2018-01    1.02018-02    NaN2018-03    NaN2018-04    2.02018-05    NaN2018-06    NaN2018-07    3.02018-08    NaN2018-09    NaN2018-10    4.02018-11    NaN2018-12    NaNFreq: M, dtype: float64</code></pre><p>对于 DataFrame 对象，可以使用关键字 on 来指定原数据中的某列为重采样后数据的行索引：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; d = dict(&#123;&#39;price&#39;: [10, 11, 9, 13, 14, 18, 17, 19],                &#39;volume&#39;: [50, 60, 40, 100, 50, 100, 40, 50]&#125;)&gt;&gt;&gt; df = pd.DataFrame(d)&gt;&gt;&gt; df[&#39;week_starting&#39;] = pd.date_range(&#39;01/01/2018&#39;, periods=8, freq=&#39;W&#39;)&gt;&gt;&gt; df   price  volume week_starting0     10      50    2018-01-071     11      60    2018-01-142      9      40    2018-01-213     13     100    2018-01-284     14      50    2018-02-045     18     100    2018-02-116     17      40    2018-02-187     19      50    2018-02-25&gt;&gt;&gt; &gt;&gt;&gt; df.resample(&#39;M&#39;, on=&#39;week_starting&#39;).mean()               price  volumeweek_starting               2018-01-31     10.75    62.52018-02-28     17.00    60.0</code></pre><p>对于具有层级索引（MultiIndex）的 DataFrame 对象，可以使用关键字 <code>level</code> 来指定需要在哪个级别上进行重新采样：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; days = pd.date_range(&#39;1/1/2000&#39;, periods=4, freq=&#39;D&#39;)&gt;&gt;&gt; d2 = dict(&#123;&#39;price&#39;: [10, 11, 9, 13, 14, 18, 17, 19],                  &#39;volume&#39;: [50, 60, 40, 100, 50, 100, 40, 50]&#125;)&gt;&gt;&gt; df2 = pd.DataFrame(d2, index=pd.MultiIndex.from_product([days, [&#39;morning&#39;, &#39;afternoon&#39;]]))&gt;&gt;&gt; df2                      price  volume2000-01-01 morning       10      50           afternoon     11      602000-01-02 morning        9      40           afternoon     13     1002000-01-03 morning       14      50           afternoon     18     1002000-01-04 morning       17      40           afternoon     19      50&gt;&gt;&gt; &gt;&gt;&gt; df2.resample(&#39;D&#39;, level=0).sum()            price  volume2000-01-01     21     1102000-01-02     22     1402000-01-03     32     1502000-01-04     36      90</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106947061未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Pandas 系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itbob.cn/article/025/&quot;&gt;Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象&lt;/a&gt;&lt;/li&gt;</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.itbob.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="数据分析" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="Pandas" scheme="https://www.itbob.cn/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据分析三剑客之 Pandas（八）：数据重塑/重复数据处理/数据替换</title>
    <link href="https://www.itbob.cn/article/032/"/>
    <id>https://www.itbob.cn/article/032/</id>
    <published>2020-06-22T12:59:15.000Z</published>
    <updated>2022-05-22T12:43:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106900748未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】数据重塑"><a href="#【01x00】数据重塑" class="headerlink" title="【01x00】数据重塑"></a><font color=#FF0000>【01x00】数据重塑</font></h2><p>有许多用于重新排列表格型数据的基础运算。这些函数也称作重塑（reshape）或轴向旋转（pivot）运算。重塑层次化索引主要有以下两个方法：</p><ul><li><p><code>stack</code>：将数据的列转换成行；</p></li><li><p><code>unstack</code>：将数据的行转换成列。</p></li></ul><h3 id="【01x01】stack"><a href="#【01x01】stack" class="headerlink" title="【01x01】stack"></a><font color=#4876FF>【01x01】stack</font></h3><p><code>stack</code> 方法用于将数据的列转换成为行；</p><p>基本语法：<code>DataFrame.stack(self, level=-1, dropna=True)</code></p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.stack.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.stack.html</a></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>level</td><td>从列转换到行，指定不同层级的列索引或列标签、由列索引或列标签组成的数组，默认-1</td></tr><tr><td>dropna</td><td>bool 类型，是否删除重塑后数据中所有值为 NaN 的行，默认 True</td></tr></tbody></table><p>单层列（Single level columns）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame([[0, 1], [2, 3]], index=[&#39;cat&#39;, &#39;dog&#39;], columns=[&#39;weight&#39;, &#39;height&#39;])&gt;&gt;&gt; obj     weight  heightcat       0       1dog       2       3&gt;&gt;&gt; &gt;&gt;&gt; obj.stack()cat  weight    0     height    1dog  weight    2     height    3dtype: int64</code></pre><p>多层列（Multi level columns）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; multicol = pd.MultiIndex.from_tuples([(&#39;weight&#39;, &#39;kg&#39;), (&#39;weight&#39;, &#39;pounds&#39;)])&gt;&gt;&gt; obj = pd.DataFrame([[1, 2], [2, 4]], index=[&#39;cat&#39;, &#39;dog&#39;], columns=multicol)&gt;&gt;&gt; obj    weight               kg poundscat      1      2dog      2      4&gt;&gt;&gt; &gt;&gt;&gt; obj.stack()            weightcat kg           1    pounds       2dog kg           2    pounds       4</code></pre><p>缺失值填充：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; multicol = pd.MultiIndex.from_tuples([(&#39;weight&#39;, &#39;kg&#39;), (&#39;height&#39;, &#39;m&#39;)])&gt;&gt;&gt; obj = pd.DataFrame([[1.0, 2.0], [3.0, 4.0]], index=[&#39;cat&#39;, &#39;dog&#39;], columns=multicol)&gt;&gt;&gt; obj    weight height        kg      mcat    1.0    2.0dog    3.0    4.0&gt;&gt;&gt; &gt;&gt;&gt; obj.stack()        height  weightcat kg     NaN     1.0    m      2.0     NaNdog kg     NaN     3.0    m      4.0     NaN</code></pre><p>通过 <code>level</code> 参数指定不同层级的轴进行重塑：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; multicol = pd.MultiIndex.from_tuples([(&#39;weight&#39;, &#39;kg&#39;), (&#39;height&#39;, &#39;m&#39;)])&gt;&gt;&gt; obj = pd.DataFrame([[1.0, 2.0], [3.0, 4.0]], index=[&#39;cat&#39;, &#39;dog&#39;], columns=multicol)&gt;&gt;&gt; obj    weight height        kg      mcat    1.0    2.0dog    3.0    4.0&gt;&gt;&gt; &gt;&gt;&gt; obj.stack(level=0)             kg    mcat height  NaN  2.0    weight  1.0  NaNdog height  NaN  4.0    weight  3.0  NaN&gt;&gt;&gt; &gt;&gt;&gt; obj.stack(level=1)        height  weightcat kg     NaN     1.0    m      2.0     NaNdog kg     NaN     3.0    m      4.0     NaN&gt;&gt;&gt;&gt;&gt;&gt; obj.stack(level=[0, 1])cat  height  m     2.0     weight  kg    1.0dog  height  m     4.0     weight  kg    3.0dtype: float64</code></pre><p>对于重塑后的数据，若有一行的值均为 NaN，则默认会被删除，可以设置 <code>dropna=False</code> 来保留缺失值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; multicol = pd.MultiIndex.from_tuples([(&#39;weight&#39;, &#39;kg&#39;), (&#39;height&#39;, &#39;m&#39;)])&gt;&gt;&gt; obj = pd.DataFrame([[None, 1.0], [2.0, 3.0]], index=[&#39;cat&#39;, &#39;dog&#39;], columns=multicol)&gt;&gt;&gt; obj    weight height        kg      mcat    NaN    1.0dog    2.0    3.0&gt;&gt;&gt; &gt;&gt;&gt; obj.stack(dropna=False)        height  weightcat kg     NaN     NaN    m      1.0     NaNdog kg     NaN     2.0    m      3.0     NaN&gt;&gt;&gt; &gt;&gt;&gt; obj.stack(dropna=True)        height  weightcat m      1.0     NaNdog kg     NaN     2.0    m      3.0     NaN</code></pre><h3 id="【01x02】unstack"><a href="#【01x02】unstack" class="headerlink" title="【01x02】unstack"></a><font color=#4876FF>【01x02】unstack</font></h3><p><code>unstack</code>：将数据的行转换成列。</p><p>基本语法：</p><ul><li><p><code>Series.unstack(self, level=-1, fill_value=None)</code></p></li><li><p><code>DataFrame.unstack(self, level=-1, fill_value=None)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.unstack.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.unstack.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.unstack.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.unstack.html</a></p></li></ul><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>level</td><td>从行转换到列，指定不同层级的行索引，默认-1</td></tr><tr><td>fill_value</td><td>用于替换 NaN 的值</td></tr></tbody></table><p>在 Series 对象中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 2, 3, 4], index=pd.MultiIndex.from_product([[&#39;one&#39;, &#39;two&#39;], [&#39;a&#39;, &#39;b&#39;]]))&gt;&gt;&gt; objone  a    1     b    2two  a    3     b    4dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.unstack()     a  bone  1  2two  3  4&gt;&gt;&gt; &gt;&gt;&gt; obj.unstack(level=0)   one  twoa    1    3b    2    4</code></pre><p>和 <code>stack</code> 方法类似，如果值不存在将会引入缺失值（NaN）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.Series([0, 1, 2, 3], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obj2 = pd.Series([4, 5, 6], index=[&#39;c&#39;, &#39;d&#39;, &#39;e&#39;])&gt;&gt;&gt; obj3 = pd.concat([obj1, obj2], keys=[&#39;one&#39;, &#39;two&#39;])&gt;&gt;&gt; obj3one  a    0     b    1     c    2     d    3two  c    4     d    5     e    6dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj3.unstack()       a    b    c    d    eone  0.0  1.0  2.0  3.0  NaNtwo  NaN  NaN  4.0  5.0  6.0</code></pre><p>在 DataFrame 对象中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.arange(6).reshape((2, 3)),               index=pd.Index([&#39;Ohio&#39;,&#39;Colorado&#39;], name=&#39;state&#39;),               columns=pd.Index([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;],               name=&#39;number&#39;))&gt;&gt;&gt; objnumber    one  two  threestate                    Ohio        0    1      2Colorado    3    4      5&gt;&gt;&gt; &gt;&gt;&gt; obj2 = obj.stack()&gt;&gt;&gt; obj2state     numberOhio      one       0          two       1          three     2Colorado  one       3          two       4          three     5dtype: int32&gt;&gt;&gt; &gt;&gt;&gt; obj3 = pd.DataFrame(&#123;&#39;left&#39;: obj2, &#39;right&#39;: obj2 + 5&#125;,            columns=pd.Index([&#39;left&#39;, &#39;right&#39;], name=&#39;side&#39;))&gt;&gt;&gt; obj3side             left  rightstate    number             Ohio     one        0      5         two        1      6         three      2      7Colorado one        3      8         two        4      9         three      5     10&gt;&gt;&gt; &gt;&gt;&gt; obj3.unstack(&#39;state&#39;)side   left          right         state  Ohio Colorado  Ohio Coloradonumber                             one       0        3     5        8two       1        4     6        9three     2        5     7       10&gt;&gt;&gt; &gt;&gt;&gt; obj3.unstack(&#39;state&#39;).stack(&#39;side&#39;)state         Colorado  Ohionumber side                 one    left          3     0       right         8     5two    left          4     1       right         9     6three  left          5     2       right        10     7</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106900748未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【02x00】重复数据处理"><a href="#【02x00】重复数据处理" class="headerlink" title="【02x00】重复数据处理"></a><font color=#FF0000>【02x00】重复数据处理</font></h2><ul><li><p><code>duplicated</code>：判断是否为重复值；</p></li><li><p><code>drop_duplicates</code>：删除重复值。</p></li></ul><h3 id="【02x01】duplicated"><a href="#【02x01】duplicated" class="headerlink" title="【02x01】duplicated"></a><font color=#4876FF>【02x01】duplicated</font></h3><p><code>duplicated</code> 方法可以判断值是否为重复数据。</p><p>基本语法：</p><ul><li><p><code>Series.duplicated(self, keep=&#39;first&#39;)</code></p></li><li><p><code>DataFrame.duplicated(self, subset: Union[Hashable, Sequence[Hashable], NoneType] = None, keep: Union[str, bool] = &#39;first&#39;) → ’Series’</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.duplicated.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.duplicated.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.duplicated.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.duplicated.html</a></p></li></ul><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>keep</td><td>标记重复项的方法，默认 <code>&#39;first&#39;</code><br><code>&#39;first&#39;</code>：将非重复项和第一个重复项标记为 False，其他重复项标记为 True<br><code>&#39;last&#39;</code>：将非重复项和最后一个重复项标记为 False，其他重复项标记为 True<br><code>False</code>：将所有重复项标记为 True，非重复项标记为 False</td></tr><tr><td>subset</td><td>列标签或标签序列，在 DataFrame 对象中才有此参数，<br>用于指定某列，仅标记该列的重复项，默认情况下将考虑所有列</td></tr></tbody></table><p>默认情况下，对于每组重复的值，第一个出现的重复值标记为 False，其他重复项标记为 True，非重复项标记为 False，相当于 <code>keep=&#39;first&#39;</code>：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;])&gt;&gt;&gt; obj0      lama1       cow2      lama3    beetle4      lamadtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.duplicated()0    False1    False2     True3    False4     Truedtype: bool&gt;&gt;&gt;&gt;&gt;&gt; obj.duplicated(keep=&#39;first&#39;)0    False1    False2     True3    False4     Truedtype: bool</code></pre><p>设置 <code>keep=&#39;last&#39;</code>，将每组非重复项和最后一次出现的重复项标记为 False，其他重复项标记为 True，设置 <code>keep=False</code>，则所有重复项均为 True，其他值为 False：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;])&gt;&gt;&gt; obj0      lama1       cow2      lama3    beetle4      lamadtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.duplicated(keep=&#39;last&#39;)0     True1    False2     True3    False4    Falsedtype: bool&gt;&gt;&gt; &gt;&gt;&gt; obj.duplicated(keep=False)0     True1    False2     True3    False4     Truedtype: bool</code></pre><p>在 DataFrame 对象中，subset 参数用于指定某列，仅标记该列的重复项，默认情况下将考虑所有列：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;data1&#39; : [&#39;a&#39;] * 4 + [&#39;b&#39;] * 4,                       &#39;data2&#39; : np.random.randint(0, 4, 8)&#125;)&gt;&gt;&gt; obj  data1  data20     a      01     a      02     a      03     a      34     b      35     b      36     b      07     b      2&gt;&gt;&gt; &gt;&gt;&gt; obj.duplicated()0    False1     True2     True3    False4    False5     True6    False7    Falsedtype: bool&gt;&gt;&gt; &gt;&gt;&gt; obj.duplicated(subset=&#39;data1&#39;)0    False1     True2     True3     True4    False5     True6     True7     Truedtype: bool&gt;&gt;&gt; &gt;&gt;&gt; obj.duplicated(subset=&#39;data2&#39;, keep=&#39;last&#39;)0     True1     True2     True3     True4     True5    False6    False7    Falsedtype: bool</code></pre><h3 id="【02x02】drop-duplicates"><a href="#【02x02】drop-duplicates" class="headerlink" title="【02x02】drop_duplicates"></a><font color=#4876FF>【02x02】drop_duplicates</font></h3><p><code>drop_duplicates</code> 方法会返回一个删除了重复值的序列。</p><p>基本语法：</p><pre><code class="python">Series.drop_duplicates(self, keep=&#39;first&#39;, inplace=False)</code></pre><pre><code class="python">DataFrame.drop_duplicates(self,                          subset: Union[Hashable, Sequence[Hashable], NoneType] = None,                          keep: Union[str, bool] = &#39;first&#39;,                          inplace: bool = False,                          ignore_index: bool = False) → Union[ForwardRef(‘DataFrame’), NoneType]</code></pre><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.drop_duplicates.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.drop_duplicates.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.drop_duplicates.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.drop_duplicates.html</a></p></li></ul><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>keep</td><td>删除重复项的方法，默认 <code>&#39;first&#39;</code><br><code>&#39;first&#39;</code>：保留非重复项和第一个重复项，其他重复项标记均删除<br><code>&#39;last&#39;</code>：保留非重复项和最后一个重复项，其他重复项删除<br><code>False</code>：将所有重复项删除，非重复项保留</td></tr><tr><td>inplace</td><td>是否返回删除重复项后的值，默认 False，若设置为 True，则不返回值，直接改变原数据</td></tr><tr><td>subset</td><td>列标签或标签序列，在 DataFrame 对象中才有此参数，<br>用于指定某列，仅标记该列的重复项，默认情况下将考虑所有列</td></tr><tr><td>ignore_index</td><td>bool 类型，在 DataFrame 对象中才有此参数，是否忽略原对象的轴标记，<br>默认 False，如果为 True，则新对象的索引将是 0, 1, 2, …, n-1</td></tr></tbody></table><p>keep 参数的使用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;, &#39;hippo&#39;], name=&#39;animal&#39;)&gt;&gt;&gt; obj0      lama1       cow2      lama3    beetle4      lama5     hippoName: animal, dtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.drop_duplicates()0      lama1       cow3    beetle5     hippoName: animal, dtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.drop_duplicates(keep=&#39;last&#39;)1       cow3    beetle4      lama5     hippoName: animal, dtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.drop_duplicates(keep=False)1       cow3    beetle5     hippoName: animal, dtype: object</code></pre><p>如果设置 <code>inplace=True</code>，则不会返回任何值，但原对象的值已被改变：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.Series([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;, &#39;hippo&#39;], name=&#39;animal&#39;)&gt;&gt;&gt; obj10      lama1       cow2      lama3    beetle4      lama5     hippoName: animal, dtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj2 = obj1.drop_duplicates()&gt;&gt;&gt; obj2          # 有返回值0      lama1       cow3    beetle5     hippoName: animal, dtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj3 = obj1.drop_duplicates(inplace=True)&gt;&gt;&gt; obj3         # 无返回值&gt;&gt;&gt;&gt;&gt;&gt; obj1         # 原对象的值已改变0      lama1       cow3    beetle5     hippoName: animal, dtype: object</code></pre><p>在 DataFrame 对象中的使用：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;data1&#39; : [&#39;a&#39;] * 4 + [&#39;b&#39;] * 4,                       &#39;data2&#39; : np.random.randint(0, 4, 8)&#125;)&gt;&gt;&gt; obj  data1  data20     a      21     a      12     a      13     a      24     b      15     b      26     b      07     b      0&gt;&gt;&gt; &gt;&gt;&gt; obj.drop_duplicates()  data1  data20     a      21     a      14     b      15     b      26     b      0&gt;&gt;&gt; &gt;&gt;&gt; obj.drop_duplicates(subset=&#39;data2&#39;)  data1  data20     a      21     a      16     b      0&gt;&gt;&gt; &gt;&gt;&gt; obj.drop_duplicates(subset=&#39;data2&#39;, ignore_index=True)  data1  data20     a      21     a      12     b      0</code></pre><h2 id="【03x00】数据替换"><a href="#【03x00】数据替换" class="headerlink" title="【03x00】数据替换"></a><font color=#FF0000>【03x00】数据替换</font></h2><h3 id="【03x01】replace"><a href="#【03x01】replace" class="headerlink" title="【03x01】replace"></a><font color=#4876FF>【03x01】replace</font></h3><p><code>replace</code> 方法可以根据值的内容进行替换。</p><p>基本语法：</p><ul><li><p><code>Series.replace(self, to_replace=None, value=None, inplace=False, limit=None, regex=False, method=&#39;pad&#39;)</code></p></li><li><p><code>DataFrame.replace(self, to_replace=None, value=None, inplace=False, limit=None, regex=False, method=&#39;pad&#39;)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.replace.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.replace.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.replace.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.replace.html</a></p></li></ul><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>to_replace</td><td>找到要替换值的方法，可以是：字符串、正则表达式、列表、字典、整数、浮点数、Series 对象或者 None<br>使用不同参数的区别参见官方文档</td></tr><tr><td>value</td><td>用于替换匹配项的值， 对于 DataFrame，可以使用字典的值来指定每列要使用的值，<br>还允许使用此类对象的正则表达式，字符串和列表或字典</td></tr><tr><td>inplace</td><td>bool 类型，是否直接改变原数据且不返回值，默认 False</td></tr><tr><td>regex</td><td>bool 类型或者与 to_replace 相同的类型，<br>当 to_replace 参数为正则表达式时，regex 应为 True，或者直接使用该参数代替 to_replace</td></tr></tbody></table><p><code>to_replace</code> 和 <code>value</code> 参数只传入一个值，单个值替换单个值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([0, 1, 2, 3, 4])&gt;&gt;&gt; obj0    01    12    23    34    4dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.replace(0, 5)0    51    12    23    34    4dtype: int64</code></pre><p><code>to_replace</code> 传入多个值，<code>value</code> 传入一个值，多个值替换一个值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([0, 1, 2, 3, 4])&gt;&gt;&gt; obj0    01    12    23    34    4dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.replace([0, 1, 2, 3], 4)0    41    42    43    44    4dtype: int64</code></pre><p><code>to_replace</code> 和 <code>value</code> 参数都传入多个值，多个值替换多个值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([0, 1, 2, 3, 4])&gt;&gt;&gt; obj0    01    12    23    34    4dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.replace([0, 1, 2, 3], [4, 3, 2, 1])0    41    32    23    14    4dtype: int64</code></pre><p><code>to_replace</code> 传入字典：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;A&#39;: [0, 1, 2, 3, 4],            &#39;B&#39;: [5, 6, 7, 8, 9],            &#39;C&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]&#125;)&gt;&gt;&gt; obj   A  B  C0  0  5  a1  1  6  b2  2  7  c3  3  8  d4  4  9  e&gt;&gt;&gt; &gt;&gt;&gt; obj.replace(0, 5)   A  B  C0  5  5  a1  1  6  b2  2  7  c3  3  8  d4  4  9  e&gt;&gt;&gt; &gt;&gt;&gt; obj.replace(&#123;0: 10, 1: 100&#125;)     A  B  C0   10  5  a1  100  6  b2    2  7  c3    3  8  d4    4  9  e&gt;&gt;&gt; &gt;&gt;&gt; obj.replace(&#123;&#39;A&#39;: 0, &#39;B&#39;: 5&#125;, 100)     A    B  C0  100  100  a1    1    6  b2    2    7  c3    3    8  d4    4    9  e&gt;&gt;&gt; obj.replace(&#123;&#39;A&#39;: &#123;0: 100, 4: 400&#125;&#125;)     A  B  C0  100  5  a1    1  6  b2    2  7  c3    3  8  d4  400  9  e</code></pre><p><code>to_replace</code> 传入正则表达式：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;A&#39;: [&#39;bat&#39;, &#39;foo&#39;, &#39;bait&#39;],            &#39;B&#39;: [&#39;abc&#39;, &#39;bar&#39;, &#39;xyz&#39;]&#125;)&gt;&gt;&gt; obj      A    B0   bat  abc1   foo  bar2  bait  xyz&gt;&gt;&gt; &gt;&gt;&gt; obj.replace(to_replace=r&#39;^ba.$&#39;, value=&#39;new&#39;, regex=True)      A    B0   new  abc1   foo  new2  bait  xyz&gt;&gt;&gt; &gt;&gt;&gt; obj.replace(&#123;&#39;A&#39;: r&#39;^ba.$&#39;&#125;, &#123;&#39;A&#39;: &#39;new&#39;&#125;, regex=True)      A    B0   new  abc1   foo  bar2  bait  xyz&gt;&gt;&gt; &gt;&gt;&gt; obj.replace(regex=r&#39;^ba.$&#39;, value=&#39;new&#39;)      A    B0   new  abc1   foo  new2  bait  xyz&gt;&gt;&gt; &gt;&gt;&gt; obj.replace(regex=&#123;r&#39;^ba.$&#39;: &#39;new&#39;, &#39;foo&#39;: &#39;xyz&#39;&#125;)      A    B0   new  abc1   xyz  new2  bait  xyz&gt;&gt;&gt; &gt;&gt;&gt; obj.replace(regex=[r&#39;^ba.$&#39;, &#39;foo&#39;], value=&#39;new&#39;)      A    B0   new  abc1   new  new2  bait  xyz</code></pre><h3 id="【03x02】where"><a href="#【03x02】where" class="headerlink" title="【03x02】where"></a><font color=#4876FF>【03x02】where</font></h3><p><code>where</code> 方法用于替换条件为 False 的值。</p><p>基本语法：</p><ul><li><p><code>Series.where(self, cond, other=nan, inplace=False, axis=None, level=None, errors=&#39;raise&#39;, try_cast=False)</code></p></li><li><p><code>DataFrame.where(self, cond, other=nan, inplace=False, axis=None, level=None, errors=&#39;raise&#39;, try_cast=False)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.where.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.where.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.where.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.where.html</a></p></li></ul><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>cond</td><td>替换条件，如果 cond 为 True，则保留原始值。如果为 False，则替换为来自 other 的相应值</td></tr><tr><td>other</td><td>替换值，如果 cond 为 False，则替换为来自该参数的相应值</td></tr><tr><td>inplace</td><td>bool 类型，是否直接改变原数据且不返回值，默认 False</td></tr></tbody></table><p>在 Series 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series(range(5))&gt;&gt;&gt; obj0    01    12    23    34    4dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.where(obj &gt; 0)0    NaN1    1.02    2.03    3.04    4.0dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.where(obj &gt; 1, 10)0    101    102     23     34     4dtype: int64</code></pre><p>在 DataFrame 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(np.arange(10).reshape(-1, 2), columns=[&#39;A&#39;, &#39;B&#39;])&gt;&gt;&gt; obj   A  B0  0  11  2  32  4  53  6  74  8  9&gt;&gt;&gt; &gt;&gt;&gt; m = obj % 3 == 0&gt;&gt;&gt; obj.where(m, -obj)   A  B0  0 -11 -2  32 -4 -53  6 -74 -8  9&gt;&gt;&gt; &gt;&gt;&gt; obj.where(m, -obj) == np.where(m, obj, -obj)      A     B0  True  True1  True  True2  True  True3  True  True4  True  True</code></pre><h3 id="【03x03】mask"><a href="#【03x03】mask" class="headerlink" title="【03x03】mask"></a><font color=#4876FF>【03x03】mask</font></h3><p><code>mask</code> 方法与 <code>where</code> 方法相反，<code>mask</code> 用于替换条件为 False 的值。</p><p>基本语法：</p><ul><li><p><code>Series.mask(self, cond, other=nan, inplace=False, axis=None, level=None, errors=&#39;raise&#39;, try_cast=False)</code></p></li><li><p><code>DataFrame.mask(self, cond, other=nan, inplace=False, axis=None, level=None, errors=&#39;raise&#39;, try_cast=False)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.mask.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.mask.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mask.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mask.html</a></p></li></ul><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>cond</td><td>替换条件，如果 cond 为 False，则保留原始值。如果为 True，则替换为来自 other 的相应值</td></tr><tr><td>other</td><td>替换值，如果 cond 为 False，则替换为来自该参数的相应值</td></tr><tr><td>inplace</td><td>bool 类型，是否直接改变原数据且不返回值，默认 False</td></tr></tbody></table><p>在 Series 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series(range(5))&gt;&gt;&gt; obj0    01    12    23    34    4dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.mask(obj &gt; 0)0    0.01    NaN2    NaN3    NaN4    NaNdtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.mask(obj &gt; 1, 10)0     01     12    103    104    10dtype: int64</code></pre><p>在 DataFrame 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(np.arange(10).reshape(-1, 2), columns=[&#39;A&#39;, &#39;B&#39;])&gt;&gt;&gt; obj   A  B0  0  11  2  32  4  53  6  74  8  9&gt;&gt;&gt; &gt;&gt;&gt; m = obj % 3 == 0&gt;&gt;&gt; &gt;&gt;&gt; obj.mask(m, -obj)   A  B0  0  11  2 -32  4  53 -6  74  8 -9&gt;&gt;&gt; &gt;&gt;&gt; obj.where(m, -obj) == obj.mask(~m, -obj)      A     B0  True  True1  True  True2  True  True3  True  True4  True  True</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106900748未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Pandas 系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itbob.cn/article/025/&quot;&gt;Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象&lt;/a&gt;&lt;/li&gt;</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.itbob.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="数据分析" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="Pandas" scheme="https://www.itbob.cn/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据分析三剑客之 Pandas（七）：合并数据集</title>
    <link href="https://www.itbob.cn/article/031/"/>
    <id>https://www.itbob.cn/article/031/</id>
    <published>2020-06-21T12:58:52.000Z</published>
    <updated>2022-05-22T12:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106830112未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】concat"><a href="#【01x00】concat" class="headerlink" title="【01x00】concat"></a><font color=#FF0000>【01x00】concat</font></h2><p><code>pandas.concat</code> 可以沿着指定轴将多个对象堆叠到一起。</p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.concat.html">https://pandas.pydata.org/docs/reference/api/pandas.concat.html</a></p><p>基本语法：</p><pre><code class="python">pandas.concat(objs: Union[Iterable[‘DataFrame’], Mapping[Optional[Hashable], ‘DataFrame’]],              axis=&#39;0&#39;,              join: str = &quot;&#39;outer&#39;&quot;,              ignore_index: bool = &#39;False&#39;,              keys=&#39;None&#39;,              levels=&#39;None&#39;,              names=&#39;None&#39;,              verify_integrity: bool = &#39;False&#39;,              sort: bool = &#39;False&#39;,              copy: bool = &#39;True&#39;) → ’DataFrame’</code></pre><pre><code class="python">pandas.concat(objs: Union[Iterable[FrameOrSeriesUnion], Mapping[Optional[Hashable], FrameOrSeriesUnion]],              axis=&#39;0&#39;,              join: str = &quot;&#39;outer&#39;&quot;,              ignore_index: bool = &#39;False&#39;,              keys=&#39;None&#39;,              levels=&#39;None&#39;,              names=&#39;None&#39;,              verify_integrity: bool = &#39;False&#39;,              sort: bool = &#39;False&#39;,              copy: bool = &#39;True&#39;) → FrameOrSeriesUnion</code></pre><p>常用参数描述：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>objs</td><td>Series 或 DataFrame 对象的序列或映射，要合并的对象</td></tr><tr><td>axis</td><td>沿指定轴合并，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>join</td><td>如何处理其他轴（或多个轴）上的索引，可取值：<code>‘inner’</code>，<code>‘outer’</code>（默认值）<br><code>‘outer’</code>：当 axis = 0 时，列名相同的列会合并，其余列都保留（并集），空值填充；<br><code>‘inner’</code>：当 axis = 0 时，列名相同的列会合并，其余列都舍弃（交集）</td></tr><tr><td>ignore_index</td><td>bool 类型，连接后的值是否使用原索引值，如果为 True，则索引将会是 0, 1, …, n-1</td></tr><tr><td>keys</td><td>序列形式，默认 None，传递 keys 后，会构造一个层次索引，即 MultiIndex 对象，keys 为最外层索引</td></tr><tr><td>levels</td><td>用于构造 MultiIndex 的特定级别（唯一值）。未指定则将从键中推断出来</td></tr><tr><td>names</td><td>列表类型，为索引添加标签</td></tr><tr><td>verify_integrity</td><td>bool 类型，是否检查合并后的索引有无重复项，设置为 <code>True</code> 若有重复项则会报错</td></tr><tr><td>sort</td><td>当 <code>join=&#39;outer&#39;</code> 时对列索引进行排序。当 <code>join=&#39;inner&#39;</code> 时此操作无效</td></tr></tbody></table><p>合并两个 Series 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.Series([&#39;a&#39;, &#39;b&#39;])&gt;&gt;&gt; obj2 = pd.Series([&#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; pd.concat([obj1, obj2])0    a1    b0    c1    ddtype: object</code></pre><p>设置 <code>ignore_index=True</code>，放弃原有的索引值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.Series([&#39;a&#39;, &#39;b&#39;])&gt;&gt;&gt; obj2 = pd.Series([&#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; pd.concat([obj1, obj2], ignore_index=True)0    a1    b2    c3    ddtype: object</code></pre><p>设置 <code>keys</code> 参数，添加最外层的索引：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.Series([&#39;a&#39;, &#39;b&#39;])&gt;&gt;&gt; obj2 = pd.Series([&#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; pd.concat([obj1, obj2], keys=[&#39;s1&#39;, &#39;s2&#39;])s1  0    a    1    bs2  0    c    1    ddtype: object</code></pre><p>设置 <code>names</code> 参数，为索引添加标签：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.Series([&#39;a&#39;, &#39;b&#39;])&gt;&gt;&gt; obj2 = pd.Series([&#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; pd.concat([obj1, obj2], keys=[&#39;s1&#39;, &#39;s2&#39;], names=[&#39;Series name&#39;, &#39;Row ID&#39;])Series name  Row IDs1           0         a             1         bs2           0         c             1         ddtype: object</code></pre><p>合并 <code>DataFrame</code> 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame([[&#39;a&#39;, 1], [&#39;b&#39;, 2]], columns=[&#39;letter&#39;, &#39;number&#39;])&gt;&gt;&gt; obj2 = pd.DataFrame([[&#39;c&#39;, 3], [&#39;d&#39;, 4]], columns=[&#39;letter&#39;, &#39;number&#39;])&gt;&gt;&gt; obj1  letter  number0      a       11      b       2&gt;&gt;&gt; &gt;&gt;&gt; obj2  letter  number0      c       31      d       4&gt;&gt;&gt; &gt;&gt;&gt; pd.concat([obj1, obj2])  letter  number0      a       11      b       20      c       31      d       4</code></pre><p>合并 <code>DataFrame</code> 对象，不存在的值将会被 NaN 填充：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame([[&#39;a&#39;, 1], [&#39;b&#39;, 2]], columns=[&#39;letter&#39;, &#39;number&#39;])&gt;&gt;&gt; obj2 = pd.DataFrame([[&#39;c&#39;, 3, &#39;cat&#39;], [&#39;d&#39;, 4, &#39;dog&#39;]], columns=[&#39;letter&#39;, &#39;number&#39;, &#39;animal&#39;])&gt;&gt;&gt; obj1  letter  number0      a       11      b       2&gt;&gt;&gt; &gt;&gt;&gt; obj2  letter  number animal0      c       3    cat1      d       4    dog&gt;&gt;&gt; &gt;&gt;&gt; pd.concat([obj1, obj2])  letter  number animal0      a       1    NaN1      b       2    NaN0      c       3    cat1      d       4    dog</code></pre><p>合并 <code>DataFrame</code> 对象，设置 <code>join=&quot;inner&quot;</code> 不存在的列将会舍弃：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame([[&#39;a&#39;, 1], [&#39;b&#39;, 2]], columns=[&#39;letter&#39;, &#39;number&#39;])&gt;&gt;&gt; obj2 = pd.DataFrame([[&#39;c&#39;, 3, &#39;cat&#39;], [&#39;d&#39;, 4, &#39;dog&#39;]], columns=[&#39;letter&#39;, &#39;number&#39;, &#39;animal&#39;])&gt;&gt;&gt; obj1  letter  number0      a       11      b       2&gt;&gt;&gt; &gt;&gt;&gt; obj2  letter  number animal0      c       3    cat1      d       4    dog&gt;&gt;&gt; &gt;&gt;&gt; pd.concat([obj1, obj2], join=&quot;inner&quot;)  letter  number0      a       11      b       20      c       31      d       4</code></pre><p>合并 <code>DataFrame</code> 对象，设置 <code>axis=1</code> 沿 y 轴合并（增加列）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame([[&#39;a&#39;, 1], [&#39;b&#39;, 2]], columns=[&#39;letter&#39;, &#39;number&#39;])&gt;&gt;&gt; obj2 = pd.DataFrame([[&#39;bird&#39;, &#39;polly&#39;], [&#39;monkey&#39;, &#39;george&#39;]], columns=[&#39;animal&#39;, &#39;name&#39;])&gt;&gt;&gt; obj1  letter  number0      a       11      b       2&gt;&gt;&gt; &gt;&gt;&gt; obj2   animal    name0    bird   polly1  monkey  george&gt;&gt;&gt; &gt;&gt;&gt; pd.concat([obj1, obj2], axis=1)  letter  number  animal    name0      a       1    bird   polly1      b       2  monkey  george</code></pre><p>设置 <code>verify_integrity=True</code> ，检查新的索引是否有重复项，有重复项会报错：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame([1], index=[&#39;a&#39;])&gt;&gt;&gt; obj2 = pd.DataFrame([2], index=[&#39;a&#39;])&gt;&gt;&gt; obj1   0a  1&gt;&gt;&gt; &gt;&gt;&gt; obj2   0a  2&gt;&gt;&gt; &gt;&gt;&gt; pd.concat([obj1, obj2], verify_integrity=True)Traceback (most recent call last):    ...ValueError: Indexes have overlapping values: [&#39;a&#39;]</code></pre><p>设置 <code>sort=True</code>，会对列索引进行排序输出：</p><pre><code class="python">&gt;&gt;&gt; obj1 = pd.DataFrame([[&#39;a&#39;, 3], [&#39;d&#39;, 2]], columns=[&#39;letter&#39;, &#39;number&#39;])&gt;&gt;&gt; obj2 = pd.DataFrame([[&#39;c&#39;, 1, &#39;cat&#39;], [&#39;b&#39;, 4, &#39;dog&#39;]], columns=[&#39;letter&#39;, &#39;number&#39;, &#39;animal&#39;])&gt;&gt;&gt; obj1  letter  number0      a       31      d       2&gt;&gt;&gt; &gt;&gt;&gt; obj2  letter  number animal0      c       1    cat1      b       4    dog&gt;&gt;&gt; &gt;&gt;&gt; pd.concat([obj1, obj2], sort=True)  animal letter  number0    NaN      a       31    NaN      d       20    cat      c       11    dog      b       4</code></pre><h2 id="【02x00】append"><a href="#【02x00】append" class="headerlink" title="【02x00】append"></a><font color=#FF0000>【02x00】append</font></h2><p>Append 方法事实上是在一个 Series / DataFrame 对象后最追加另一个 Series / DataFrame 对象并返回一个新对象，不改变原对象的值。</p><p>基本语法：</p><ul><li><p><code>Series.append(self, to_append, ignore_index=False, verify_integrity=False)</code></p></li><li><p><code>DataFrame.append(self, other, ignore_index=False, verify_integrity=False, sort=False)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.append.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.append.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.append.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.append.html</a></p></li></ul><p>参数描述：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>to_append / other</td><td>要追加的数据</td></tr><tr><td>ignore_index</td><td>bool 类型，连接后的值是否使用原索引值，如果为 True，则索引将会是 0, 1, …, n-1</td></tr><tr><td>verify_integrity</td><td>bool 类型，是否检查合并后的索引有无重复项，设置为 <code>True</code> 若有重复项则会报错</td></tr><tr><td>sort</td><td>bool 类型，是否对列索引（columns）进行排序，默认 False</td></tr></tbody></table><p>合并 Series 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.Series([1, 2, 3])&gt;&gt;&gt; obj2 = pd.Series([4, 5, 6])&gt;&gt;&gt; obj3 = pd.Series([4, 5, 6], index=[3, 4, 5])&gt;&gt;&gt; obj10    11    22    3dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj20    41    52    6dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj33    44    55    6dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj1.append(obj2)0    11    22    30    41    52    6dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj1.append(obj3)0    11    22    33    44    55    6dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj1.append(obj2, ignore_index=True)0    11    22    33    44    55    6dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj1.append(obj2, verify_integrity=True)Traceback (most recent call last):...ValueError: Indexes have overlapping values: Int64Index([0, 1, 2], dtype=&#39;int64&#39;)</code></pre><p>合并 DataFrame 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame([[1, 2], [3, 4]], columns=list(&#39;AB&#39;))&gt;&gt;&gt; obj2 = pd.DataFrame([[5, 6], [7, 8]], columns=list(&#39;AB&#39;))&gt;&gt;&gt; &gt;&gt;&gt; obj1   A  B0  1  21  3  4&gt;&gt;&gt; &gt;&gt;&gt; obj2   A  B0  5  61  7  8&gt;&gt;&gt; &gt;&gt;&gt; obj1.append(obj2)   A  B0  1  21  3  40  5  61  7  8&gt;&gt;&gt; &gt;&gt;&gt; obj1.append(obj2, ignore_index=True)   A  B0  1  21  3  42  5  63  7  8</code></pre><p>以下虽然不是生成 DataFrames 的推荐方法，但演示了从多个数据源生成 DataFrames 的两种方法：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(columns=[&#39;A&#39;])&gt;&gt;&gt; for i in range(5):    obj = obj.append(&#123;&#39;A&#39;: i&#125;, ignore_index=True)    &gt;&gt;&gt; obj   A0  01  12  23  34  4</code></pre><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.concat([pd.DataFrame([i], columns=[&#39;A&#39;]) for i in range(5)], ignore_index=True)   A0  01  12  23  34  4</code></pre><h2 id="【03x00】merge"><a href="#【03x00】merge" class="headerlink" title="【03x00】merge"></a><font color=#FF0000>【03x00】merge</font></h2><p>将不同的数据源进行合并是数据科学中常见的操作，这既包括将两个不同的数据集非常简单地拼接在一起，也包括用数据库那样的连接（join）与合并（merge）操作处理有重叠字段的数据集。Series 与DataFrame 都具备这类操作，Pandas 的函数与方法让数据合并变得快速简单。</p><p>数据集的合并（merge）或连接（join）运算是通过一个或多个键将行连接起来的。这些运算是关系型数据库（基于SQL）的核心。Pandas 的 merge 函数是对数据应用这些算法的主要切入点。</p><p><font color=#FF0000> <strong><code>pandas.merge</code> 可根据一个或多个连接键将不同 DataFrame 中的行连接起来。</strong></font></p><p>基本语法：</p><pre><code class="python">pandas.merge(left,             right,             how: str = &#39;inner&#39;,             on=None,             left_on=None,             right_on=None,             left_index: bool = False,             right_index: bool = False,             sort: bool = False,             suffixes=&#39;_x&#39;, &#39;_y&#39;,             copy: bool = True,             indicator: bool = False,             validate=None) → ’DataFrame’</code></pre><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.merge.html">https://pandas.pydata.org/docs/reference/api/pandas.merge.html</a></p><p>常见参数描述：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>参与合并的左侧 DataFrame 对象</td></tr><tr><td>right</td><td>参与合并的右侧 DataFrame 对象</td></tr><tr><td>how</td><td>合并方式，默认 <code>&#39;inner&#39;</code><br><code>&#39;inner&#39;</code>：内连接，即使用两个对象中<font color=#FF0000><strong>都有</strong></font>的键（交集）；<br><code>&#39;outer&#39;</code>：外连接，即使用两个对象中<font color=#FF0000><strong>所有</strong></font>的键（并集）；<br><code>&#39;left&#39;</code>：左连接，即使用<font color=#FF0000><strong>左</strong></font>对象中所有的键；<br><code>&#39;right&#39;</code>：右连接，即使用<font color=#FF0000><strong>右</strong></font>对象中所有的键；</td></tr><tr><td>on</td><td>用于连接的列名。必须存在于左右两个 Dataframe对象中<br>如果未指定，且其他连接键也未指定，则以 left 和 right 列名的交集作为连接键</td></tr><tr><td>left_on</td><td>左侧 DataFrame 对象中用作连接键的列</td></tr><tr><td>right_on</td><td>右侧 DataFrame 对象中用作连接键的列</td></tr><tr><td>left_index</td><td>bool 类型，是否使用左侧 DataFrame 对象中的索引（index）作为连接键，默认 False</td></tr><tr><td>right_index</td><td>bool 类型，是否使用右侧 DataFrame 对象中的索引（index）作为连接键，默认 False</td></tr><tr><td>sort</td><td>bool 类型，是否在结果中按顺序对连接键排序，默认 False。<br>如果为 False，则连接键的顺序取决于联接类型（how 关键字）</td></tr><tr><td>suffixes</td><td>字符串值元组，用于追加到重叠列名的末尾，默认为 <code>(&#39;_x&#39;, &#39;_y&#39;)</code>。<br>例如，如果左右两个 DataFrame 对象都有 <code>data</code> 列时，则结果中就会出现 <code>data_x</code> 和 <code>data_y</code></td></tr></tbody></table><h3 id="【03x01】一对一连接"><a href="#【03x01】一对一连接" class="headerlink" title="【03x01】一对一连接"></a><font color=#4876FF>【03x01】一对一连接</font></h3><p><font color=#FF0000><strong>一对一连接是指两个 DataFrame 对象的列的值没有重复值。</strong></font></p><p>如果不指定任何参数，调用 <code>merge</code> 方法，<code>merge</code> 就会将重叠的列的列名当做键来合并。</p><p>在下面的示例中，两个 DataFrame 对象都有一个列名为 <code>key</code> 的列，未指定按照哪一列来合并，<code>merge</code> 就会默认按照 <code>key</code> 来合并：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;b&#39;, &#39;a&#39;, &#39;c&#39;], &#39;data1&#39;: range(3)&#125;)&gt;&gt;&gt; obj2 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;c&#39;, &#39;b&#39;], &#39;data2&#39;: range(3)&#125;)&gt;&gt;&gt; obj1  key  data10   b      01   a      12   c      2&gt;&gt;&gt; &gt;&gt;&gt; obj2  key  data20   a      01   c      12   b      2&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(obj1, obj2)  key  data1  data20   b      0      21   a      1      02   c      2      1</code></pre><h3 id="【03x02】多对一连接"><a href="#【03x02】多对一连接" class="headerlink" title="【03x02】多对一连接"></a><font color=#4876FF>【03x02】多对一连接</font></h3><p><font color=#FF0000><strong>多对一连接是指两个 DataFrame 对象中，有一个的列的值有重复值。</strong></font>通过多对一连接获得的结果，DataFrame  将会保留重复值。</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;], &#39;data1&#39;: range(7)&#125;)&gt;&gt;&gt; obj2 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;d&#39;], &#39;data2&#39;: range(3)&#125;)&gt;&gt;&gt; &gt;&gt;&gt; obj1  key  data10   b      01   b      12   a      23   c      34   a      45   a      56   b      6&gt;&gt;&gt; &gt;&gt;&gt; obj2  key  data20   a      01   b      12   d      2&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(obj1, obj2)  key  data1  data20   b      0      11   b      1      12   b      6      13   a      2      04   a      4      05   a      5      0</code></pre><h3 id="【03x03】多对多连接"><a href="#【03x03】多对多连接" class="headerlink" title="【03x03】多对多连接"></a><font color=#4876FF>【03x03】多对多连接</font></h3><p><font color=#FF0000><strong>多对多连接是指两个 DataFrame 对象中的列的值都有重复值。</strong></font></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;], &#39;data1&#39;: range(4)&#125;)&gt;&gt;&gt; obj2 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;], &#39;data2&#39;: range(6)&#125;)&gt;&gt;&gt; obj1  key  data10   a      01   b      12   b      23   c      3&gt;&gt;&gt; &gt;&gt;&gt; obj2  key  data20   a      01   a      12   b      23   b      34   c      45   c      5&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(obj1, obj2)  key  data1  data20   a      0      01   a      0      12   b      1      23   b      1      34   b      2      25   b      2      36   c      3      47   c      3      5</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106830112未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h3 id="【03x04】参数-on-left-on-right-on"><a href="#【03x04】参数-on-left-on-right-on" class="headerlink" title="【03x04】参数 on / left_on / right_on"></a><font color=#4876FF>【03x04】参数 on / left_on / right_on</font></h3><p>参数 <code>on</code> 用于指定按照某一列来进行合并，若不指定该参数，则会默认按照重叠的列的列名当做键来合并：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;b&#39;, &#39;a&#39;, &#39;c&#39;], &#39;data1&#39;: range(3)&#125;)&gt;&gt;&gt; obj2 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;c&#39;, &#39;b&#39;], &#39;data2&#39;: range(3)&#125;)&gt;&gt;&gt; obj1  key  data10   b      01   a      12   c      2&gt;&gt;&gt; &gt;&gt;&gt; obj2  key  data20   a      01   c      12   b      2&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(obj1, obj2, on=&#39;key&#39;)  key  data1  data20   b      0      21   a      1      02   c      2      1</code></pre><p>如果要根据多个键进行合并，传入一个由列名组成的列表即可：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; left = pd.DataFrame(&#123;&#39;key1&#39;: [&#39;foo&#39;, &#39;foo&#39;, &#39;bar&#39;],             &#39;key2&#39;: [&#39;one&#39;, &#39;two&#39;, &#39;one&#39;],             &#39;lval&#39;: [1, 2, 3]&#125;)&gt;&gt;&gt; right = pd.DataFrame(&#123;&#39;key1&#39;: [&#39;foo&#39;, &#39;foo&#39;, &#39;bar&#39;, &#39;bar&#39;],              &#39;key2&#39;: [&#39;one&#39;, &#39;one&#39;, &#39;one&#39;, &#39;two&#39;],              &#39;rval&#39;: [4, 5, 6, 7]&#125;)&gt;&gt;&gt; left  key1 key2  lval0  foo  one     11  foo  two     22  bar  one     3&gt;&gt;&gt; &gt;&gt;&gt; right  key1 key2  rval0  foo  one     41  foo  one     52  bar  one     63  bar  two     7&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(left, right, on=[&#39;key1&#39;, &#39;key2&#39;])  key1 key2  lval  rval0  foo  one     1     41  foo  one     1     52  bar  one     3     6</code></pre><p>如果两个对象的列名不同，就可以使用 <code>left_on</code>、<code>right_on</code> 参数分别进行指定：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame(&#123;&#39;lkey&#39;: [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;], &#39;data1&#39;: range(7)&#125;)&gt;&gt;&gt; obj2 = pd.DataFrame(&#123;&#39;rkey&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;d&#39;], &#39;data2&#39;: range(3)&#125;)&gt;&gt;&gt; obj1  lkey  data10    b      01    b      12    a      23    c      34    a      45    a      56    b      6&gt;&gt;&gt; &gt;&gt;&gt; obj2  rkey  data20    a      01    b      12    d      2&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(obj1, obj2, left_on=&#39;lkey&#39;, right_on=&#39;rkey&#39;)  lkey  data1 rkey  data20    b      0    b      11    b      1    b      12    b      6    b      13    a      2    a      04    a      4    a      05    a      5    a      0</code></pre><h3 id="【03x05】参数-how"><a href="#【03x05】参数-how" class="headerlink" title="【03x05】参数 how"></a><font color=#4876FF>【03x05】参数 how</font></h3><p>在前面的示例中，结果里面 c 和 d 以及与之相关的数据消失了。默认情况下，<code>merge</code> 做的是内连接（<code>&#39;inner&#39;</code>），结果中的键是交集。其他方式还有：<code>&#39;left&#39;</code>、<code>&#39;right&#39;</code>、<code>&#39;outer&#39;</code>，含义如下：</p><ul><li><code>&#39;inner&#39;</code>：内连接，即使用两个对象中<font color=#FF0000><strong>都有</strong></font>的键（交集）；</li><li><code>&#39;outer&#39;</code>：外连接，即使用两个对象中<font color=#FF0000><strong>所有</strong></font>的键（并集）；</li><li><code>&#39;left&#39;</code>：左连接，即使用<font color=#FF0000><strong>左</strong></font>对象中所有的键；</li><li><code>&#39;right&#39;</code>：右连接，即使用<font color=#FF0000><strong>右</strong></font>对象中所有的键；</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;], &#39;data1&#39;: range(7)&#125;)&gt;&gt;&gt; obj2 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;d&#39;], &#39;data2&#39;: range(3)&#125;)&gt;&gt;&gt; obj1  key  data10   b      01   b      12   a      23   c      34   a      45   a      56   b      6&gt;&gt;&gt; &gt;&gt;&gt; obj2  key  data20   a      01   b      12   d      2&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(obj1, obj2, on=&#39;key&#39;, how=&#39;inner&#39;)  key  data1  data20   b      0      11   b      1      12   b      6      13   a      2      04   a      4      05   a      5      0&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(obj1, obj2, on=&#39;key&#39;, how=&#39;outer&#39;)  key  data1  data20   b    0.0    1.01   b    1.0    1.02   b    6.0    1.03   a    2.0    0.04   a    4.0    0.05   a    5.0    0.06   c    3.0    NaN7   d    NaN    2.0&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(obj1, obj2, on=&#39;key&#39;, how=&#39;left&#39;)  key  data1  data20   b      0    1.01   b      1    1.02   a      2    0.03   c      3    NaN4   a      4    0.05   a      5    0.06   b      6    1.0&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(obj1, obj2, on=&#39;key&#39;, how=&#39;right&#39;)  key  data1  data20   b    0.0      11   b    1.0      12   b    6.0      13   a    2.0      04   a    4.0      05   a    5.0      06   d    NaN      2</code></pre><h3 id="【03x06】参数-suffixes"><a href="#【03x06】参数-suffixes" class="headerlink" title="【03x06】参数 suffixes"></a><font color=#4876FF>【03x06】参数 suffixes</font></h3><p><code>suffixes</code> 参数用于指定附加到左右两个 DataFrame 对象的重叠列名上的字符串：</p><p>在以下示例中，选择按照 <code>key1</code> 进行合并，而两个 DataFrame 对象都包含 <code>key2</code> 列，如果未指定 <code>suffixes</code> 参数，则默认会为两个对象的 <code>key2</code> 加上 <code>_x</code> 和 <code>_y</code>，以便区分它们，如果指定了 <code>suffixes</code> 参数，就会按照添加指定的后缀：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; left = pd.DataFrame(&#123;&#39;key1&#39;: [&#39;foo&#39;, &#39;foo&#39;, &#39;bar&#39;],             &#39;key2&#39;: [&#39;one&#39;, &#39;two&#39;, &#39;one&#39;],             &#39;lval&#39;: [1, 2, 3]&#125;)&gt;&gt;&gt; right = pd.DataFrame(&#123;&#39;key1&#39;: [&#39;foo&#39;, &#39;foo&#39;, &#39;bar&#39;, &#39;bar&#39;],              &#39;key2&#39;: [&#39;one&#39;, &#39;one&#39;, &#39;one&#39;, &#39;two&#39;],              &#39;rval&#39;: [4, 5, 6, 7]&#125;)&gt;&gt;&gt; left  key1 key2  lval0  foo  one     11  foo  two     22  bar  one     3&gt;&gt;&gt; &gt;&gt;&gt; right  key1 key2  rval0  foo  one     41  foo  one     52  bar  one     63  bar  two     7&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(left, right, on=&#39;key1&#39;)  key1 key2_x  lval key2_y  rval0  foo    one     1    one     41  foo    one     1    one     52  foo    two     2    one     43  foo    two     2    one     54  bar    one     3    one     65  bar    one     3    two     7&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(left, right, on=&#39;key1&#39;, suffixes=(&#39;_left&#39;, &#39;_right&#39;))  key1 key2_left  lval key2_right  rval0  foo       one     1        one     41  foo       one     1        one     52  foo       two     2        one     43  foo       two     2        one     54  bar       one     3        one     65  bar       one     3        two     7</code></pre><h3 id="【03x07】参数-left-index-right-index"><a href="#【03x07】参数-left-index-right-index" class="headerlink" title="【03x07】参数 left_index / right_index"></a><font color=#4876FF>【03x07】参数 left_index / right_index</font></h3><p>有时候，DataFrame 中的连接键位于其索引中。在这种情况下，可以使用 <code>left_index=True</code> 或<code>right_index=True</code>（或两个都传）以说明索引应该被用作连接键。这种方法称为按索引连接，在 Pandas 中还有个 <code>join</code> 方法可以实现这个功能。</p><p>在以下示例中，按照 left 的 key 列进行连接，而 right 对象的连接键位于其索引中，因此要指定 <code>right_index=True</code>：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; left = pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;], &#39;value&#39;: range(6)&#125;)&gt;&gt;&gt; right = pd.DataFrame(&#123;&#39;group_val&#39;: [3.5, 7]&#125;, index=[&#39;a&#39;, &#39;b&#39;])&gt;&gt;&gt; left  key  value0   a      01   b      12   a      23   a      34   b      45   c      5&gt;&gt;&gt; &gt;&gt;&gt; right   group_vala        3.5b        7.0&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(left, right, left_on=&#39;key&#39;, right_index=True)  key  value  group_val0   a      0        3.52   a      2        3.53   a      3        3.51   b      1        7.04   b      4        7.0</code></pre><h2 id="【04x00】join"><a href="#【04x00】join" class="headerlink" title="【04x00】join"></a><font color=#FF0000>【04x00】join</font></h2><p>join 方法只适用于 DataFrame 对象，Series 对象没有该方法，该方法用于连接另一个 DataFrame 对象的列（columns）。</p><p>基本语法：<code>DataFrame.join(self, other, on=None, how=&#39;left&#39;, lsuffix=&#39;&#39;, rsuffix=&#39;&#39;, sort=False) → ’DataFrame’</code></p><p>参数描述：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>other</td><td>另一个 DataFrame、Series 或 DataFrame 列表对象</td></tr><tr><td>on</td><td>列名称，或者列名称组成的列表、元组，连接的列</td></tr><tr><td>how</td><td>合并方式，默认 <code>&#39;left&#39;</code><br><code>&#39;inner&#39;</code>：内连接，即使用两个对象中<font color=#FF0000><strong>都有</strong></font>的键（交集）；<br><code>&#39;outer&#39;</code>：外连接，即使用两个对象中<font color=#FF0000><strong>所有</strong></font>的键（并集）；<br><code>&#39;left&#39;</code>：左连接，即使用<font color=#FF0000><strong>左</strong></font>对象中所有的键；<br><code>&#39;right&#39;</code>：右连接，即使用<font color=#FF0000><strong>右</strong></font>对象中所有的键；</td></tr><tr><td>lsuffix</td><td>当两个对象有相同的列名时，合并后左边数据列名的后缀</td></tr><tr><td>rsuffix</td><td>当两个对象有相同的列名时，合并后右边数据列名的后缀</td></tr><tr><td>sort</td><td>bool 类型，是否在结果中按顺序对连接键排序，默认 False。<br>如果为 False，则连接键的顺序取决于联接类型（how 关键字）</td></tr></tbody></table><p>使用 <code>lsuffix</code> 和 <code>rsuffix</code> 参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;key&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;, &#39;K3&#39;, &#39;K4&#39;, &#39;K5&#39;],            &#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;, &#39;A4&#39;, &#39;A5&#39;]&#125;)&gt;&gt;&gt; other = pd.DataFrame(&#123;&#39;key&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;],              &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;]&#125;)&gt;&gt;&gt; obj  key   A0  K0  A01  K1  A12  K2  A23  K3  A34  K4  A45  K5  A5&gt;&gt;&gt; &gt;&gt;&gt; other  key   B0  K0  B01  K1  B12  K2  B2&gt;&gt;&gt; &gt;&gt;&gt; obj.join(other, lsuffix=&#39;_1&#39;, rsuffix=&#39;_2&#39;)  key_1   A key_2    B0    K0  A0    K0   B01    K1  A1    K1   B12    K2  A2    K2   B23    K3  A3   NaN  NaN4    K4  A4   NaN  NaN5    K5  A5   NaN  NaN</code></pre><p>如果右表的索引是左表的某一列的值，这时可以将右表的索引和左表的列对齐合并这样的灵活方式进行合并：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;], &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;],&#39;key&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K0&#39;, &#39;K1&#39;]&#125;)&gt;&gt;&gt; other = pd.DataFrame(&#123;&#39;C&#39;: [&#39;C0&#39;, &#39;C1&#39;],&#39;D&#39;: [&#39;D0&#39;, &#39;D1&#39;]&#125;,index=[&#39;K0&#39;, &#39;K1&#39;])&gt;&gt;&gt; obj    A   B key0  A0  B0  K01  A1  B1  K12  A2  B2  K03  A3  B3  K1&gt;&gt;&gt; &gt;&gt;&gt; other     C   DK0  C0  D0K1  C1  D1&gt;&gt;&gt; &gt;&gt;&gt; obj.join(other, on=&#39;key&#39;)    A   B key   C   D0  A0  B0  K0  C0  D01  A1  B1  K1  C1  D12  A2  B2  K0  C0  D03  A3  B3  K1  C1  D1</code></pre><h2 id="【05x00】四种方法的区别"><a href="#【05x00】四种方法的区别" class="headerlink" title="【05x00】四种方法的区别"></a><font color=#FF0000>【05x00】四种方法的区别</font></h2><ul><li><p><code>concat</code>：可用于两个或多个 Series 或 DataFrame 对象间，通过 <code>axis</code> 参数指定按照行方向（增加行）或列方向（增加列）进合并操作，默认行合并（增加行），取并集；</p></li><li><p><code>append</code>：在一个 Series 或 DataFrame 对象后最追加另一个 Series 或 DataFrame 对象并返回一个新对象，不改变原对象的值。只能按行合并（增加行）。</p></li><li><p><code>merge</code>：只能对两个 DataFrame 对象进行合并，一般按照列方向（增加列）进行合并操作，按照行方向合并一般用 join 方法代替，默认列合并（增加列），取交集；</p></li><li><p><code>join</code>：只能对两个 DataFrame 对象进行合并，按照列方向（增加列）进行合并操作，默认左连接。</p></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106830112未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Pandas 系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itbob.cn/article/025/&quot;&gt;Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象&lt;/a&gt;&lt;/li&gt;</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.itbob.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="数据分析" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="Pandas" scheme="https://www.itbob.cn/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂/应用/合并</title>
    <link href="https://www.itbob.cn/article/030/"/>
    <id>https://www.itbob.cn/article/030/</id>
    <published>2020-06-17T15:02:33.000Z</published>
    <updated>2022-05-22T12:41:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106804881未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】GroupBy-机制"><a href="#【01x00】GroupBy-机制" class="headerlink" title="【01x00】GroupBy 机制"></a><font color=#FF0000>【01x00】GroupBy 机制</font></h2><p>对数据集进行分组并对各组应用一个函数（无论是聚合还是转换），通常是数据分析工作中的重要环节。在将数据集加载、融合、准备好之后，通常就是计算分组统计或生成透视表。Pandas 提供了一个灵活高效的 GroupBy 功能，虽然“分组”（group by）这个名字是借用 SQL 数据库语言的命令，但其理念引用发明 R 语言 frame 的 Hadley Wickham 的观点可能更合适：分裂（Split）、应用（Apply）和组合（Combine）。</p><p>分组运算过程：Split —&gt; Apply —&gt; Combine</p><ul><li>分裂（Split）：根据某些标准将数据分组；</li><li>应用（Apply）：对每个组独立应用一个函数；</li><li>合并（Combine）：把每个分组的计算结果合并起来。</li></ul><p>官方介绍：<a href="https://pandas.pydata.org/docs/user_guide/groupby.html">https://pandas.pydata.org/docs/user_guide/groupby.html</a></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A84/01.png" alt="01"></p><h2 id="【02x00】GroupBy-对象"><a href="#【02x00】GroupBy-对象" class="headerlink" title="【02x00】GroupBy 对象"></a><font color=#FF0000>【02x00】GroupBy 对象</font></h2><p>常见的 GroupBy 对象：Series.groupby、DataFrame.groupby，基本语法如下：</p><pre><code class="python">Series.groupby(self,               by=None,               axis=0,               level=None,               as_index: bool = True,               sort: bool = True,               group_keys: bool = True,               squeeze: bool = False,               observed: bool = False) → ’groupby_generic.SeriesGroupBy’</code></pre><pre><code class="python">DataFrame.groupby(self,                  by=None,                  axis=0,                  level=None,                  as_index: bool = True,                  sort: bool = True,                  group_keys: bool = True,                  squeeze: bool = False,                  observed: bool = False) → ’groupby_generic.DataFrameGroupBy’</code></pre><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.groupby.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.groupby.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html</a></p></li></ul><p>常用参数解释如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>by</td><td>映射、函数、标签或标签列表，用于确定分组依据的分组。如果 by 是函数，则会在对象索引的每个值上调用它。 <br>如果传递了 dict 或 Series，则将使用 Series 或 dict 的值来确定组（将 Series 的值首先对齐；请参见.align() 方法）。<br> 如果传递了 ndarray，则按原样使用这些值来确定组。标签或标签列表可以按自身中的列传递给分组。 注意，元组被解释为（单个）键</td></tr><tr><td>axis</td><td>沿指定轴拆分，默认 <code>0</code>，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>level</td><td>如果轴是  MultiIndex（层次结构），则按特定层级进行分组，默认 None</td></tr><tr><td>as_index</td><td>bool 类型，默认 True，对于聚合输出，返回以组标签为索引的对象。仅与 DataFrame 输入相关。<br><code>as_index=False</code> 实际上是“SQL样式”分组输出</td></tr><tr><td>sort</td><td>bool 类型，默认 True，对组键排序。关闭此选项可获得更好的性能。注：这不影响每组的观察顺序。Groupby 保留每个组中行的顺序</td></tr><tr><td>group_keys</td><td>bool 类型，默认 True，调用 apply 方法时，是否将组键（keys）添加到索引（ index）以标识块</td></tr><tr><td>squeeze</td><td>bool 类型，默认 False，如果可能，减少返回类型的维度，否则返回一致的类型</td></tr></tbody></table><p>groupby() 进行分组，GroupBy 对象没有进行实际运算，只是包含分组的中间数据，示例如下：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randn(8),    &#39;data2&#39;: np.random.randn(8)&#125;&gt;&gt;&gt; &gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj  key1   key2     data1     data20    a    one -0.804160 -0.8689051    b    one -0.086990  0.3257412    a    two  0.757992  0.5411013    b  three -0.281435  0.0978414    a    two  0.817757 -0.6436995    b    two -0.462760 -0.3211966    a    one -0.403699  0.6021387    a  three  0.883940 -0.850526&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;)&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x03CDB7C0&gt;&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;data1&#39;].groupby(obj[&#39;key1&#39;])&lt;pandas.core.groupby.generic.SeriesGroupBy object at 0x03CDB748&gt;</code></pre><h2 id="【03x00】GroupBy-Split-数据分裂"><a href="#【03x00】GroupBy-Split-数据分裂" class="headerlink" title="【03x00】GroupBy Split 数据分裂"></a><font color=#FF0000>【03x00】GroupBy Split 数据分裂</font></h2><h3 id="【03x01】分组运算"><a href="#【03x01】分组运算" class="headerlink" title="【03x01】分组运算"></a><font color=#4876FF>【03x01】分组运算</font></h3><p>前面通过 <code>groupby()</code> 方法获得了一个 GroupBy 对象，它实际上还没有进行任何计算，只是含有一些有关分组键 <code>obj[&#39;key1&#39;]</code> 的中间数据而已。换句话说，该对象已经有了接下来对各分组执行运算所需的一切信息。例如，我们可以调用 GroupBy 的 <code>mean()</code> 方法来计算分组平均值，<code>size()</code> 方法返回每个分组的元素个数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randn(8),    &#39;data2&#39;: np.random.randn(8)&#125;&gt;&gt;&gt; &gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj  key1   key2     data1     data20    a    one -0.544099 -0.6140791    b    one  2.193712  0.1010052    a    two -0.004683  0.8827703    b  three  0.312858  1.7321054    a    two  0.011089  0.0895875    b    two  0.292165  1.3276386    a    one -1.433291 -0.2389717    a  three -0.004724 -2.117326&gt;&gt;&gt; &gt;&gt;&gt; grouped1 = obj.groupby(&#39;key1&#39;)&gt;&gt;&gt; grouped2 = obj[&#39;data1&#39;].groupby(obj[&#39;key1&#39;])&gt;&gt;&gt; &gt;&gt;&gt; grouped1.mean()         data1     data2key1                    a    -0.395142 -0.399604b     0.932912  1.053583&gt;&gt;&gt; &gt;&gt;&gt; grouped2.mean()key1a   -0.395142b    0.932912Name: data1, dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; grouped1.size()key1a    5b    3dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; grouped2.size()key1a    5b    3Name: data1, dtype: int64</code></pre><h3 id="【03x02】按类型按列分组"><a href="#【03x02】按类型按列分组" class="headerlink" title="【03x02】按类型按列分组"></a><font color=#4876FF>【03x02】按类型按列分组</font></h3><p><code>groupby()</code> 方法 <code>axis</code> 参数默认是 0，通过设置也可以在其他任何轴上进行分组，也支持按照类型（dtype）进行分组：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randn(8),    &#39;data2&#39;: np.random.randn(8)&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj  key1   key2     data1     data20    a    one -0.607009  1.9483011    b    one  0.150818 -0.0250952    a    two -2.086024  0.3581643    b  three  0.446061  1.7087974    a    two  0.745457 -0.9809485    b    two  0.981877  2.1593276    a    one  0.804480 -0.4996617    a  three  0.112884  0.004367&gt;&gt;&gt; &gt;&gt;&gt; obj.dtypeskey1      objectkey2      objectdata1    float64data2    float64dtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(obj.dtypes, axis=1).size()float64    2object     2dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(obj.dtypes, axis=1).sum()    float64  object0  1.341291    aone1  0.125723    bone2 -1.727860    atwo3  2.154858  bthree4 -0.235491    atwo5  3.141203    btwo6  0.304819    aone7  0.117251  athree</code></pre><h3 id="【03x03】自定义分组"><a href="#【03x03】自定义分组" class="headerlink" title="【03x03】自定义分组"></a><font color=#4876FF>【03x03】自定义分组</font></h3><p><code>groupby()</code> 方法中可以一次传入多个数组的列表，也可以自定义一组分组键。也可以通过一个字典、一个函数，或者按照索引层级进行分组。</p><p>传入多个数组的列表：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randn(8),    &#39;data2&#39;: np.random.randn(8)&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj  key1   key2     data1     data20    a    one -0.841652  0.6880551    b    one  0.510042 -0.5611712    a    two -0.418862 -0.1459833    b  three -1.104698  0.5631584    a    two  0.329527 -0.8931085    b    two  0.753653 -0.3425206    a    one -0.882527 -1.1213297    a  three  1.726794  0.160244&gt;&gt;&gt; &gt;&gt;&gt; means = obj[&#39;data1&#39;].groupby([obj[&#39;key1&#39;], obj[&#39;key2&#39;]]).mean()&gt;&gt;&gt; meanskey1  key2 a     one     -0.862090      three    1.726794      two     -0.044667b     one      0.510042      three   -1.104698      two      0.753653Name: data1, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; means.unstack()key2       one     three       twokey1                              a    -0.862090  1.726794 -0.044667b     0.510042 -1.104698  0.753653</code></pre><p>自定义分组键：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;key1&#39; : [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;two&#39;, &#39;one&#39;, &#39;two&#39;, &#39;one&#39;],    &#39;data1&#39; : np.random.randn(5),    &#39;data2&#39; : np.random.randn(5)&#125;)&gt;&gt;&gt; obj  key1 key2     data1     data20    a  one -0.024003  0.3504801    a  two -0.767534 -0.1004262    b  one -0.594983 -1.9455803    b  two -0.374482  0.8175924    a  one  0.755452 -0.137759&gt;&gt;&gt; &gt;&gt;&gt; states = np.array([&#39;Wuhan&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;, &#39;Wuhan&#39;, &#39;Wuhan&#39;])&gt;&gt;&gt; years = np.array([2005, 2005, 2006, 2005, 2006])&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;data1&#39;].groupby([states, years]).mean()Beijing  2005   -0.767534         2006   -0.594983Wuhan    2005   -0.199242         2006    0.755452Name: data1, dtype: float64</code></pre><h4 id="【03x03x01】字典分组"><a href="#【03x03x01】字典分组" class="headerlink" title="【03x03x01】字典分组"></a><font color=#FFA500>【03x03x01】字典分组</font></h4><p>通过字典进行分组：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.random.randint(1, 10, (5,5)),    columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;],    index=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])&gt;&gt;&gt; obj   a  b  c  d  eA  1  4  7  1  9B  8  2  4  7  8C  9  8  2  5  1D  2  4  2  8  3E  7  5  7  2  3&gt;&gt;&gt; &gt;&gt;&gt; obj_dict = &#123;&#39;a&#39;:&#39;Python&#39;, &#39;b&#39;:&#39;Python&#39;, &#39;c&#39;:&#39;Java&#39;, &#39;d&#39;:&#39;C++&#39;, &#39;e&#39;:&#39;Java&#39;&#125;&gt;&gt;&gt; obj.groupby(obj_dict, axis=1).size()C++       1Java      2Python    2dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(obj_dict, axis=1).count()   C++  Java  PythonA    1     2       2B    1     2       2C    1     2       2D    1     2       2E    1     2       2&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(obj_dict, axis=1).sum()   C++  Java  PythonA    1    16       5B    7    12      10C    5     3      17D    8     5       6E    2    10      12</code></pre><h4 id="【03x03x02】函数分组"><a href="#【03x03x02】函数分组" class="headerlink" title="【03x03x02】函数分组"></a><font color=#FFA500>【03x03x02】函数分组</font></h4><p>通过函数进行分组：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.random.randint(1, 10, (5,5)),        columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;],        index=[&#39;AA&#39;, &#39;BBB&#39;, &#39;CC&#39;, &#39;D&#39;, &#39;EE&#39;])&gt;&gt;&gt; obj     a  b  c  d  eAA   3  9  5  8  2BBB  1  4  2  2  6CC   9  2  4  7  6D    2  5  5  7  1EE   8  8  8  2  2&gt;&gt;&gt; &gt;&gt;&gt; def group_key(idx):        &quot;&quot;&quot;            idx 为列索引或行索引        &quot;&quot;&quot;        return len(idx)&gt;&gt;&gt; obj.groupby(group_key).size()    # 等价于 obj.groupby(len).size()1    12    33    1dtype: int64</code></pre><h4 id="【03x03x03】索引层级分组"><a href="#【03x03x03】索引层级分组" class="headerlink" title="【03x03x03】索引层级分组"></a><font color=#FFA500>【03x03x03】索引层级分组</font></h4><p>通过不同索引层级进行分组：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; columns = pd.MultiIndex.from_arrays([[&#39;Python&#39;, &#39;Java&#39;, &#39;Python&#39;, &#39;Java&#39;, &#39;Python&#39;],    [&#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;B&#39;]], names=[&#39;language&#39;, &#39;index&#39;])&gt;&gt;&gt; obj = pd.DataFrame(np.random.randint(1, 10, (5, 5)), columns=columns)&gt;&gt;&gt; objlanguage Python Java Python Java Pythonindex         A    A      B    C      B0             7    1      9    8      51             4    5      4    5      62             4    3      1    9      53             6    6      3    8      14             7    9      2    8      2&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(level=&#39;language&#39;, axis=1).sum()language  Java  Python0            9      211           10      142           12      103           14      104           17      11&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(level=&#39;index&#39;, axis=1).sum()index   A   B  C0       8  14  81       9  10  52       7   6  93      12   4  84      16   4  8</code></pre><h3 id="【03x04】分组迭代"><a href="#【03x04】分组迭代" class="headerlink" title="【03x04】分组迭代"></a><font color=#4876FF>【03x04】分组迭代</font></h3><p>GroupBy 对象支持迭代，对于单层分组，可以产生一组二元元组，由分组名和数据块组成：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randn(8),    &#39;data2&#39;: np.random.randn(8)&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj  key1   key2     data1     data20    a    one -1.088762  0.6685041    b    one  0.275500  0.7878442    a    two -0.108417 -0.4912963    b  three  0.019524 -0.3633904    a    two  0.453612  0.7969995    b    two  1.982858  1.5018776    a    one  1.101132 -1.9283627    a  three  0.524775 -1.205842&gt;&gt;&gt; &gt;&gt;&gt; for group_name, group_data in obj.groupby(&#39;key1&#39;):    print(group_name)    print(group_data)    a  key1   key2     data1     data20    a    one -1.088762  0.6685042    a    two -0.108417 -0.4912964    a    two  0.453612  0.7969996    a    one  1.101132 -1.9283627    a  three  0.524775 -1.205842b  key1   key2     data1     data21    b    one  0.275500  0.7878443    b  three  0.019524 -0.3633905    b    two  1.982858  1.501877</code></pre><p>对于多层分组，元组的第一个元素将会是由键值组成的元组，第二个元素为数据块：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randn(8),    &#39;data2&#39;: np.random.randn(8)&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj  key1   key2     data1     data20    a    one -1.088762  0.6685041    b    one  0.275500  0.7878442    a    two -0.108417 -0.4912963    b  three  0.019524 -0.3633904    a    two  0.453612  0.7969995    b    two  1.982858  1.5018776    a    one  1.101132 -1.9283627    a  three  0.524775 -1.205842&gt;&gt;&gt; &gt;&gt;&gt; for group_name, group_data in obj.groupby([&#39;key1&#39;, &#39;key2&#39;]):    print(group_name)    print(group_data)    (&#39;a&#39;, &#39;one&#39;)  key1 key2     data1     data20    a  one -1.088762  0.6685046    a  one  1.101132 -1.928362(&#39;a&#39;, &#39;three&#39;)  key1   key2     data1     data27    a  three  0.524775 -1.205842(&#39;a&#39;, &#39;two&#39;)  key1 key2     data1     data22    a  two -0.108417 -0.4912964    a  two  0.453612  0.796999(&#39;b&#39;, &#39;one&#39;)  key1 key2   data1     data21    b  one  0.2755  0.787844(&#39;b&#39;, &#39;three&#39;)  key1   key2     data1    data23    b  three  0.019524 -0.36339(&#39;b&#39;, &#39;two&#39;)  key1 key2     data1     data25    b  two  1.982858  1.501877</code></pre><h3 id="【03x05】对象转换"><a href="#【03x05】对象转换" class="headerlink" title="【03x05】对象转换"></a><font color=#4876FF>【03x05】对象转换</font></h3><p>GroupBy 对象支持转换成列表或字典：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randn(8),    &#39;data2&#39;: np.random.randn(8)&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj  key1   key2     data1     data20    a    one -0.607009  1.9483011    b    one  0.150818 -0.0250952    a    two -2.086024  0.3581643    b  three  0.446061  1.7087974    a    two  0.745457 -0.9809485    b    two  0.981877  2.1593276    a    one  0.804480 -0.4996617    a  three  0.112884  0.004367&gt;&gt;&gt; &gt;&gt;&gt; grouped = obj.groupby(&#39;key1&#39;)&gt;&gt;&gt; list(grouped)[(&#39;a&#39;,   key1   key2     data1     data20    a    one -0.607009  1.9483012    a    two -2.086024  0.3581644    a    two  0.745457 -0.9809486    a    one  0.804480 -0.4996617    a  three  0.112884  0.004367),(&#39;b&#39;,   key1   key2     data1     data21    b    one  0.150818 -0.0250953    b  three  0.446061  1.7087975    b    two  0.981877  2.159327)]&gt;&gt;&gt;&gt;&gt;&gt; dict(list(grouped))&#123;&#39;a&#39;:   key1   key2     data1     data20    a    one -0.607009  1.9483012    a    two -2.086024  0.3581644    a    two  0.745457 -0.9809486    a    one  0.804480 -0.4996617    a  three  0.112884  0.004367,&#39;b&#39;:   key1   key2     data1     data21    b    one  0.150818 -0.0250953    b  three  0.446061  1.7087975    b    two  0.981877  2.159327&#125;</code></pre><h2 id="【04x00】GroupBy-Apply-数据应用"><a href="#【04x00】GroupBy-Apply-数据应用" class="headerlink" title="【04x00】GroupBy Apply 数据应用"></a><font color=#FF0000>【04x00】GroupBy Apply 数据应用</font></h2><p>聚合指的是任何能够从数组产生标量值的数据转换过程，常用于对分组后的数据进行计算</p><h3 id="【04x01】聚合函数"><a href="#【04x01】聚合函数" class="headerlink" title="【04x01】聚合函数"></a><font color=#4876FF>【04x01】聚合函数</font></h3><p>之前的例子已经用过一些内置的聚合函数，比如 mean、count、min 以及 sum 等。常见的聚合运算如下表所示：</p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/groupby.html">https://pandas.pydata.org/docs/reference/groupby.html</a></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>count</td><td>非NA值的数量</td></tr><tr><td>describe</td><td>针对Series或各DataFrame列计算汇总统计</td></tr><tr><td>min</td><td>计算最小值</td></tr><tr><td>max</td><td>计算最大值</td></tr><tr><td>argmin</td><td>计算能够获取到最小值的索引位置（整数）</td></tr><tr><td>argmax</td><td>计算能够获取到最大值的索引位置（整数）</td></tr><tr><td>idxmin</td><td>计算能够获取到最小值的索引值</td></tr><tr><td>idxmax</td><td>计算能够获取到最大值的索引值</td></tr><tr><td>quantile</td><td>计算样本的分位数（0到1）</td></tr><tr><td>sum</td><td>值的总和</td></tr><tr><td>mean</td><td>值的平均数</td></tr><tr><td>median</td><td>值的算术中位数（50%分位数）</td></tr><tr><td>mad</td><td>根据平均值计算平均绝对离差</td></tr><tr><td>var</td><td>样本值的方差</td></tr><tr><td>std</td><td>样本值的标准差</td></tr></tbody></table><p>应用示例：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randint(1,10, 8),    &#39;data2&#39;: np.random.randint(1,10, 8)&#125;&gt;&gt;&gt; obj = pd.DataFrame(obj)&gt;&gt;&gt; obj  key1   key2  data1  data20    a    one      9      71    b    one      5      92    a    two      2      43    b  three      3      44    a    two      5      15    b    two      5      96    a    one      1      87    a  three      2      4&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).sum()      data1  data2key1              a        19     24b        13     22&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).max()     key2  data1  data2key1                   a     two      9      8b     two      5      9&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).min()     key2  data1  data2key1                   a     one      1      1b     one      3      4&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).mean()         data1     data2key1                    a     3.800000  4.800000b     4.333333  7.333333&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).size()key1a    5b    3dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).count()      key2  data1  data2key1                    a        5      5      5b        3      3      3&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).describe()     data1                                ... data2                         count      mean       std  min  25%  ...   min  25%  50%  75%  maxkey1                                      ...                          a      5.0  3.800000  3.271085  1.0  2.0  ...   1.0  4.0  4.0  7.0  8.0b      3.0  4.333333  1.154701  3.0  4.0  ...   4.0  6.5  9.0  9.0  9.0[2 rows x 16 columns]</code></pre><h3 id="【04x02】自定义函数"><a href="#【04x02】自定义函数" class="headerlink" title="【04x02】自定义函数"></a><font color=#4876FF>【04x02】自定义函数</font></h3><p>如果自带的内置函数满足不了我们的要求，则可以自定义一个聚合函数，然后传入 <code>GroupBy.agg(func)</code> 或 <code>GroupBy.aggregate(func) </code> 方法中即可。func 的参数为 groupby 索引对应的记录。</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randint(1,10, 8),    &#39;data2&#39;: np.random.randint(1,10, 8)&#125;&gt;&gt;&gt; obj = pd.DataFrame(obj)&gt;&gt;&gt; obj  key1   key2  data1  data20    a    one      9      71    b    one      5      92    a    two      2      43    b  three      3      44    a    two      5      15    b    two      5      96    a    one      1      87    a  three      2      4&gt;&gt;&gt; &gt;&gt;&gt; def peak_range(df):    return df.max() - df.min()&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).agg(peak_range)      data1  data2key1              a         8      7b         2      5&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).agg(lambda df : df.max() - df.min())      data1  data2key1              a         8      7b         2      5</code></pre><h3 id="【04x03】对不同列作用不同函数"><a href="#【04x03】对不同列作用不同函数" class="headerlink" title="【04x03】对不同列作用不同函数"></a><font color=#4876FF>【04x03】对不同列作用不同函数</font></h3><p>使用字典可以对不同列作用不同的聚合函数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randint(1,10, 8),    &#39;data2&#39;: np.random.randint(1,10, 8)&#125;&gt;&gt;&gt; obj = pd.DataFrame(obj)&gt;&gt;&gt; obj  key1   key2  data1  data20    a    one      9      71    b    one      5      92    a    two      2      43    b  three      3      44    a    two      5      15    b    two      5      96    a    one      1      87    a  three      2      4&gt;&gt;&gt; &gt;&gt;&gt; dict1 = &#123;&#39;data1&#39;:&#39;mean&#39;, &#39;data2&#39;:&#39;sum&#39;&#125;&gt;&gt;&gt; dict2 = &#123;&#39;data1&#39;:[&#39;mean&#39;,&#39;max&#39;], &#39;data2&#39;:&#39;sum&#39;&#125;&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).agg(dict1)         data1  data2key1                 a     3.800000     24b     4.333333     22&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).agg(dict2)         data1     data2          mean max   sumkey1                    a     3.800000   9    24b     4.333333   5    22</code></pre><h3 id="【04x04】GroupBy-apply"><a href="#【04x04】GroupBy-apply" class="headerlink" title="【04x04】GroupBy.apply()"></a><font color=#4876FF>【04x04】GroupBy.apply()</font></h3><p><code>apply()</code> 方法会将待处理的对象拆分成多个片段，然后对各片段调用传入的函数，最后尝试将各片段组合到一起。</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;A&#39;:[&#39;bob&#39;,&#39;sos&#39;,&#39;bob&#39;,&#39;sos&#39;,&#39;bob&#39;,&#39;sos&#39;,&#39;bob&#39;,&#39;bob&#39;],              &#39;B&#39;:[&#39;one&#39;,&#39;one&#39;,&#39;two&#39;,&#39;three&#39;,&#39;two&#39;,&#39;two&#39;,&#39;one&#39;,&#39;three&#39;],              &#39;C&#39;:[3,1,4,1,5,9,2,6],              &#39;D&#39;:[1,2,3,4,5,6,7,8]&#125;)&gt;&gt;&gt; obj     A      B  C  D0  bob    one  3  11  sos    one  1  22  bob    two  4  33  sos  three  1  44  bob    two  5  55  sos    two  9  66  bob    one  2  77  bob  three  6  8&gt;&gt;&gt; &gt;&gt;&gt; grouped = obj.groupby(&#39;A&#39;)&gt;&gt;&gt; for name, group in grouped:    print(name)    print(group)    bob     A      B  C  D0  bob    one  3  12  bob    two  4  34  bob    two  5  56  bob    one  2  77  bob  three  6  8sos     A      B  C  D1  sos    one  1  23  sos  three  1  45  sos    two  9  6&gt;&gt;&gt; &gt;&gt;&gt; grouped.apply(lambda x:x.describe())  # 对 bob 和 sos 两组数据使用 describe 方法                  C         DA                            bob count  5.000000  5.000000    mean   4.000000  4.800000    std    1.581139  2.863564    min    2.000000  1.000000    25%    3.000000  3.000000    50%    4.000000  5.000000    75%    5.000000  7.000000    max    6.000000  8.000000sos count  3.000000  3.000000    mean   3.666667  4.000000    std    4.618802  2.000000    min    1.000000  2.000000    25%    1.000000  3.000000    50%    1.000000  4.000000    75%    5.000000  5.000000    max    9.000000  6.000000&gt;&gt;&gt;&gt;&gt;&gt; grouped.apply(lambda x:x.min())  # # 对 bob 和 sos 两组数据使用 min 方法       A    B  C  DA                  bob  bob  one  2  1sos  sos  one  1  2</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106804881未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Pandas 系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itbob.cn/article/025/&quot;&gt;Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象&lt;/a&gt;&lt;/li&gt;</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.itbob.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="数据分析" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="Pandas" scheme="https://www.itbob.cn/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</title>
    <link href="https://www.itbob.cn/article/029/"/>
    <id>https://www.itbob.cn/article/029/</id>
    <published>2020-06-16T13:15:28.000Z</published>
    <updated>2022-05-22T12:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106788501未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】统计计算"><a href="#【01x00】统计计算" class="headerlink" title="【01x00】统计计算"></a><font color=#FF0000>【01x00】统计计算</font></h2><p>Pandas 对象拥有一组常用的数学和统计方法。它们大部分都属于约简和汇总统计，用于从 Series 中提取单个值（如 sum 或 mean）或从 DataFrame 的行或列中提取一个 Series。跟对应的 NumPy 数组方法相比，它们都是基于没有缺失数据的假设而构建的。</p><h3 id="【01x01】sum-求和"><a href="#【01x01】sum-求和" class="headerlink" title="【01x01】sum() 求和"></a><font color=#4876FF>【01x01】sum() 求和</font></h3><p><code>sum()</code> 方法用于返回指定轴的和，相当于 <code>numpy.sum()</code>。</p><p>在 Series 和 DataFrame 中的基本语法如下：</p><ul><li><p><code>Series.sum(self, axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs)</code></p></li><li><p><code>DataFrame.sum(self, axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.sum.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.sum.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sum.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sum.html</a></p></li></ul><p>常用参数描述如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>axis</td><td>指定轴求和，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>skipna</td><td>bool 类型，求和时是否排除缺失值（NA/null），默认 True</td></tr><tr><td>level</td><td>如果轴是 MultiIndex（层次结构），则沿指定层次求和</td></tr></tbody></table><p>在 Series 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([    [&#39;warm&#39;, &#39;warm&#39;, &#39;cold&#39;, &#39;cold&#39;],    [&#39;dog&#39;, &#39;falcon&#39;, &#39;fish&#39;, &#39;spider&#39;]],    names=[&#39;blooded&#39;, &#39;animal&#39;])&gt;&gt;&gt; obj = pd.Series([4, 2, 0, 8], name=&#39;legs&#39;, index=idx)&gt;&gt;&gt; objblooded  animalwarm     dog       4         falcon    2cold     fish      0         spider    8Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.sum()14&gt;&gt;&gt; &gt;&gt;&gt; obj.sum(level=&#39;blooded&#39;)bloodedwarm    6cold    8Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.sum(level=0)bloodedwarm    6cold    8Name: legs, dtype: int64</code></pre><p>在 DataFrame 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1.4, np.nan], [7.1, -4.5],    [np.nan, np.nan], [0.75, -1.3]],    index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;],    columns=[&#39;one&#39;, &#39;two&#39;])&gt;&gt;&gt; obj    one  twoa  1.40  NaNb  7.10 -4.5c   NaN  NaNd  0.75 -1.3&gt;&gt;&gt; &gt;&gt;&gt; obj.sum()one    9.25two   -5.80dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.sum(axis=1)a    1.40b    2.60c    0.00d   -0.55dtype: float64</code></pre><h3 id="【01x02】min-最小值"><a href="#【01x02】min-最小值" class="headerlink" title="【01x02】min() 最小值"></a><font color=#4876FF>【01x02】min() 最小值</font></h3><p><code>min()</code> 方法用于返回指定轴的最小值。</p><p>在 Series 和 DataFrame 中的基本语法如下：</p><ul><li><p><code>Series.min(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs)</code></p></li><li><p><code>DataFrame.min(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.min.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.min.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.min.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.min.html</a></p></li></ul><p>常用参数描述如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>axis</td><td>指定轴求最小值，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>skipna</td><td>bool 类型，求最小值时是否排除缺失值（NA/null），默认 True</td></tr><tr><td>level</td><td>如果轴是 MultiIndex（层次结构），则沿指定层次求最小值</td></tr></tbody></table><p>在 Series 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([    [&#39;warm&#39;, &#39;warm&#39;, &#39;cold&#39;, &#39;cold&#39;],    [&#39;dog&#39;, &#39;falcon&#39;, &#39;fish&#39;, &#39;spider&#39;]],    names=[&#39;blooded&#39;, &#39;animal&#39;])&gt;&gt;&gt; obj = pd.Series([4, 2, 0, 8], name=&#39;legs&#39;, index=idx)&gt;&gt;&gt; objblooded  animalwarm     dog       4         falcon    2cold     fish      0         spider    8Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.min()0&gt;&gt;&gt; &gt;&gt;&gt; obj.min(level=&#39;blooded&#39;)bloodedwarm    2cold    0Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.min(level=0)bloodedwarm    2cold    0Name: legs, dtype: int64</code></pre><p>在 DataFrame 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1.4, np.nan], [7.1, -4.5],    [np.nan, np.nan], [0.75, -1.3]],    index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;],columns=[&#39;one&#39;, &#39;two&#39;])&gt;&gt;&gt; obj    one  twoa  1.40  NaNb  7.10 -4.5c   NaN  NaNd  0.75 -1.3&gt;&gt;&gt; &gt;&gt;&gt; obj.min()one    0.75two   -4.50dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.min(axis=1)a    1.4b   -4.5c    NaNd   -1.3dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.min(axis=&#39;columns&#39;, skipna=False)a    NaNb   -4.5c    NaNd   -1.3dtype: float64</code></pre><h3 id="【01x03】max-最大值"><a href="#【01x03】max-最大值" class="headerlink" title="【01x03】max() 最大值"></a><font color=#4876FF>【01x03】max() 最大值</font></h3><p><code>max()</code> 方法用于返回指定轴的最大值。</p><p>在 Series 和 DataFrame 中的基本语法如下：</p><ul><li><p><code>Series.max(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs)</code></p></li><li><p><code>DataFrame.max(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.max.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.max.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.max.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.max.html</a></p></li></ul><p>常用参数描述如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>axis</td><td>指定轴求最大值，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>skipna</td><td>bool 类型，求最大值时是否排除缺失值（NA/null），默认 True</td></tr><tr><td>level</td><td>如果轴是 MultiIndex（层次结构），则沿指定层次求最大值</td></tr></tbody></table><p>在 Series 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([    [&#39;warm&#39;, &#39;warm&#39;, &#39;cold&#39;, &#39;cold&#39;],    [&#39;dog&#39;, &#39;falcon&#39;, &#39;fish&#39;, &#39;spider&#39;]],    names=[&#39;blooded&#39;, &#39;animal&#39;])&gt;&gt;&gt; obj = pd.Series([4, 2, 0, 8], name=&#39;legs&#39;, index=idx)&gt;&gt;&gt; objblooded  animalwarm     dog       4         falcon    2cold     fish      0         spider    8Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.max()8&gt;&gt;&gt; &gt;&gt;&gt; obj.max(level=&#39;blooded&#39;)bloodedwarm    4cold    8Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.max(level=0)bloodedwarm    4cold    8Name: legs, dtype: int64</code></pre><p>在 DataFrame 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1.4, np.nan], [7.1, -4.5],    [np.nan, np.nan], [0.75, -1.3]],    index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;],columns=[&#39;one&#39;, &#39;two&#39;])&gt;&gt;&gt; obj    one  twoa  1.40  NaNb  7.10 -4.5c   NaN  NaNd  0.75 -1.3&gt;&gt;&gt; &gt;&gt;&gt; obj.max()one    7.1two   -1.3dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.max(axis=1)a    1.40b    7.10c     NaNd    0.75dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.max(axis=&#39;columns&#39;, skipna=False)a     NaNb    7.10c     NaNd    0.75dtype: float64</code></pre><h3 id="【01x04】mean-平均值"><a href="#【01x04】mean-平均值" class="headerlink" title="【01x04】mean() 平均值"></a><font color=#4876FF>【01x04】mean() 平均值</font></h3><p><code>mean()</code> 方法用于返回指定轴的平均值。</p><p>在 Series 和 DataFrame 中的基本语法如下：</p><ul><li><p><code>Series.mean(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs)</code></p></li><li><p><code>DataFrame.mean(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.mean.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.mean.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mean.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mean.html</a></p></li></ul><p>常用参数描述如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>axis</td><td>指定轴求平均值，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>skipna</td><td>bool 类型，求平均值时是否排除缺失值（NA/null），默认 True</td></tr><tr><td>level</td><td>如果轴是 MultiIndex（层次结构），则沿指定层次求平均值</td></tr></tbody></table><p>在 Series 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([    [&#39;warm&#39;, &#39;warm&#39;, &#39;cold&#39;, &#39;cold&#39;],    [&#39;dog&#39;, &#39;falcon&#39;, &#39;fish&#39;, &#39;spider&#39;]],    names=[&#39;blooded&#39;, &#39;animal&#39;])&gt;&gt;&gt; obj = pd.Series([4, 2, 0, 8], name=&#39;legs&#39;, index=idx)&gt;&gt;&gt; objblooded  animalwarm     dog       4         falcon    2cold     fish      0         spider    8Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.mean()3.5&gt;&gt;&gt; &gt;&gt;&gt; obj.mean(level=&#39;blooded&#39;)bloodedwarm    3cold    4Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.mean(level=0)bloodedwarm    3cold    4Name: legs, dtype: int64</code></pre><p>在 DataFrame 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1.4, np.nan], [7.1, -4.5],    [np.nan, np.nan], [0.75, -1.3]],    index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;],columns=[&#39;one&#39;, &#39;two&#39;])&gt;&gt;&gt; obj    one  twoa  1.40  NaNb  7.10 -4.5c   NaN  NaNd  0.75 -1.3&gt;&gt;&gt; &gt;&gt;&gt; obj.mean()one    3.083333two   -2.900000dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.mean(axis=1)a    1.400b    1.300c      NaNd   -0.275dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.mean(axis=&#39;columns&#39;, skipna=False)a      NaNb    1.300c      NaNd   -0.275dtype: float64</code></pre><h3 id="【01x05】idxmin-最小值索引"><a href="#【01x05】idxmin-最小值索引" class="headerlink" title="【01x05】idxmin() 最小值索引"></a><font color=#4876FF>【01x05】idxmin() 最小值索引</font></h3><p><code>idxmin()</code> 方法用于返回最小值的索引。</p><p>在 Series 和 DataFrame 中的基本语法如下：</p><ul><li><p><code>Series.idxmin(self, axis=0, skipna=True, *args, **kwargs)</code></p></li><li><p><code>DataFrame.idxmin(self, axis=0, skipna=True)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.idxmin.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.idxmin.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.idxmin.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.idxmin.html</a></p></li></ul><p>常用参数描述如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>axis</td><td>指定轴，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>skipna</td><td>bool 类型，是否排除缺失值（NA/null），默认 True</td></tr></tbody></table><p>在 Series 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([    [&#39;warm&#39;, &#39;warm&#39;, &#39;cold&#39;, &#39;cold&#39;],    [&#39;dog&#39;, &#39;falcon&#39;, &#39;fish&#39;, &#39;spider&#39;]],    names=[&#39;blooded&#39;, &#39;animal&#39;])&gt;&gt;&gt; obj = pd.Series([4, 2, 0, 8], name=&#39;legs&#39;, index=idx)&gt;&gt;&gt; objblooded  animalwarm     dog       4         falcon    2cold     fish      0         spider    8Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.idxmin()(&#39;cold&#39;, &#39;fish&#39;)</code></pre><p>在 DataFrame 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1.4, np.nan], [7.1, -4.5],    [np.nan, np.nan], [0.75, -1.3]],    index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;],columns=[&#39;one&#39;, &#39;two&#39;])&gt;&gt;&gt; obj    one  twoa  1.40  NaNb  7.10 -4.5c   NaN  NaNd  0.75 -1.3&gt;&gt;&gt; &gt;&gt;&gt; obj.idxmin()one    dtwo    bdtype: object</code></pre><h3 id="【01x06】idxmax-最大值索引"><a href="#【01x06】idxmax-最大值索引" class="headerlink" title="【01x06】idxmax() 最大值索引"></a><font color=#4876FF>【01x06】idxmax() 最大值索引</font></h3><p><code>idxmax()</code> 方法用于返回最大值的索引。</p><p>在 Series 和 DataFrame 中的基本语法如下：</p><ul><li><p><code>Series.idxmax(self, axis=0, skipna=True, *args, **kwargs)</code></p></li><li><p><code>DataFrame.idxmax(self, axis=0, skipna=True)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.idxmax.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.idxmax.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.idxmax.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.idxmax.html</a></p></li></ul><p>常用参数描述如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>axis</td><td>指定轴，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>skipna</td><td>bool 类型，是否排除缺失值（NA/null），默认 True</td></tr></tbody></table><p>在 Series 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([    [&#39;warm&#39;, &#39;warm&#39;, &#39;cold&#39;, &#39;cold&#39;],    [&#39;dog&#39;, &#39;falcon&#39;, &#39;fish&#39;, &#39;spider&#39;]],    names=[&#39;blooded&#39;, &#39;animal&#39;])&gt;&gt;&gt; obj = pd.Series([4, 2, 0, 8], name=&#39;legs&#39;, index=idx)&gt;&gt;&gt; objblooded  animalwarm     dog       4         falcon    2cold     fish      0         spider    8Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.idxmax()(&#39;cold&#39;, &#39;spider&#39;)</code></pre><p>在 DataFrame 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1.4, np.nan], [7.1, -4.5],    [np.nan, np.nan], [0.75, -1.3]],    index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;],columns=[&#39;one&#39;, &#39;two&#39;])&gt;&gt;&gt; obj    one  twoa  1.40  NaNb  7.10 -4.5c   NaN  NaNd  0.75 -1.3&gt;&gt;&gt; &gt;&gt;&gt; obj.idxmax()one    btwo    ddtype: object</code></pre><h2 id="【02x00】统计描述"><a href="#【02x00】统计描述" class="headerlink" title="【02x00】统计描述"></a><font color=#FF0000>【02x00】统计描述</font></h2><p><code>describe()</code> 方法用于快速综合统计结果：计数、均值、标准差、最大最小值、四分位数等。还可以通过参数来设置需要忽略或者包含的统计选项。</p><p>在 Series 和 DataFrame 中的基本语法如下：</p><ul><li><p><code>Series.describe(self: ~ FrameOrSeries, percentiles=None, include=None, exclude=None)</code></p></li><li><p><code>DataFrame.describe(self: ~ FrameOrSeries, percentiles=None, include=None, exclude=None) </code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.describe.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.describe.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.describe.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.describe.html</a></p></li></ul><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>percentiles</td><td>数字列表，可选项，要包含在输出中的百分比。所有值都应介于 0 和 1 之间。默认值为 [.25、.5、.75]，即返回第 25、50 和 75 个百分点</td></tr><tr><td>include</td><td>要包含在结果中的数据类型，数据类型列表，默认 None，具体取值类型参见官方文档</td></tr><tr><td>exclude</td><td>要从结果中忽略的数据类型，数据类型列表，默认 None，具体取值类型参见官方文档</td></tr></tbody></table><p>描述数字形式的 Series 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 2, 3])&gt;&gt;&gt; obj0    11    22    3dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.describe()count    3.0mean     2.0std      1.0min      1.025%      1.550%      2.075%      2.5max      3.0dtype: float64</code></pre><p>分类描述：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;])&gt;&gt;&gt; obj0    a1    a2    b3    cdtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.describe()count     4unique    3top       afreq      2dtype: object</code></pre><p>描述时间戳：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj  = pd.Series([    np.datetime64(&quot;2000-01-01&quot;),    np.datetime64(&quot;2010-01-01&quot;),    np.datetime64(&quot;2010-01-01&quot;)    ])&gt;&gt;&gt; obj0   2000-01-011   2010-01-012   2010-01-01dtype: datetime64[ns]&gt;&gt;&gt; &gt;&gt;&gt; obj.describe()count                       3unique                      2top       2010-01-01 00:00:00freq                        2first     2000-01-01 00:00:00last      2010-01-01 00:00:00dtype: object</code></pre><p>描述 DataFrame 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;categorical&#39;: pd.Categorical([&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]), &#39;numeric&#39;: [1, 2, 3], &#39;object&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&#125;)&gt;&gt;&gt; obj  categorical  numeric object0           d        1      a1           e        2      b2           f        3      c&gt;&gt;&gt; &gt;&gt;&gt; obj.describe()       numericcount      3.0mean       2.0std        1.0min        1.025%        1.550%        2.075%        2.5max        3.0</code></pre><p>不考虑数据类型，显示所有描述：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;categorical&#39;: pd.Categorical([&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]), &#39;numeric&#39;: [1, 2, 3], &#39;object&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&#125;)&gt;&gt;&gt; obj  categorical  numeric object0           d        1      a1           e        2      b2           f        3      c&gt;&gt;&gt; &gt;&gt;&gt; obj.describe(include=&#39;all&#39;)       categorical  numeric objectcount            3      3.0      3unique           3      NaN      3top              f      NaN      cfreq             1      NaN      1mean           NaN      2.0    NaNstd            NaN      1.0    NaNmin            NaN      1.0    NaN25%            NaN      1.5    NaN50%            NaN      2.0    NaN75%            NaN      2.5    NaNmax            NaN      3.0    NaN</code></pre><p>仅包含 category 列：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;categorical&#39;: pd.Categorical([&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]), &#39;numeric&#39;: [1, 2, 3], &#39;object&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&#125;)&gt;&gt;&gt; obj  categorical  numeric object0           d        1      a1           e        2      b2           f        3      c&gt;&gt;&gt; &gt;&gt;&gt; obj.describe(include=[&#39;category&#39;])       categoricalcount            3unique           3top              ffreq             1</code></pre><h2 id="【03x00】常用统计方法"><a href="#【03x00】常用统计方法" class="headerlink" title="【03x00】常用统计方法"></a><font color=#FF0000>【03x00】常用统计方法</font></h2><p>其他常用统计方法参见下表：</p><table><thead><tr><th>方法</th><th>描述</th><th>官方文档</th></tr></thead><tbody><tr><td>count</td><td>非NA值的数量</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.count.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.count.html">DataFrame</a></td></tr><tr><td>describe</td><td>针对Series或各DataFrame列计算汇总统计</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.describe.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.describe.html">DataFrame</a></td></tr><tr><td>min</td><td>计算最小值</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.min.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.min.html">DataFrame</a></td></tr><tr><td>max</td><td>计算最大值</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.max.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.max.html">DataFrame</a></td></tr><tr><td>argmin</td><td>计算能够获取到最小值的索引位置（整数）</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.argmin.html">Series</a></td></tr><tr><td>argmax</td><td>计算能够获取到最大值的索引位置（整数）</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.argmax.html">Series</a></td></tr><tr><td>idxmin</td><td>计算能够获取到最小值的索引值</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.idxmin.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.idxmin.html">DataFrame</a></td></tr><tr><td>idxmax</td><td>计算能够获取到最大值的索引值</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.idxmax.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.idxmax.html">DataFrame</a></td></tr><tr><td>quantile</td><td>计算样本的分位数（0到1）</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.quantile.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.quantile.html">DataFrame</a></td></tr><tr><td>sum</td><td>值的总和</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.sum.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sum.html">DataFrame</a></td></tr><tr><td>mean</td><td>值的平均数</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.mean.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mean.html">DataFrame</a></td></tr><tr><td>median</td><td>值的算术中位数（50%分位数）</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.median.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.median.html">DataFrame</a></td></tr><tr><td>mad</td><td>根据平均值计算平均绝对离差</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.mad.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mad.html">DataFrame</a></td></tr><tr><td>var</td><td>样本值的方差</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.var.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.var.html">DataFrame</a></td></tr><tr><td>std</td><td>样本值的标准差</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.std.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.std.html">DataFrame</a></td></tr></tbody></table><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106788501未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Pandas 系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itbob.cn/article/025/&quot;&gt;Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象&lt;/a&gt;&lt;/li&gt;</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.itbob.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="数据分析" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="Pandas" scheme="https://www.itbob.cn/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据分析三剑客之 Pandas（四）：函数应用/映射/排序和层级索引</title>
    <link href="https://www.itbob.cn/article/028/"/>
    <id>https://www.itbob.cn/article/028/</id>
    <published>2020-06-15T12:27:32.000Z</published>
    <updated>2022-05-22T12:39:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106758103未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】函数应用和映射"><a href="#【01x00】函数应用和映射" class="headerlink" title="【01x00】函数应用和映射"></a><font color=#FF0000>【01x00】函数应用和映射</font></h2><p>Pandas 可直接使用 NumPy 的 ufunc（元素级数组方法） 函数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.random.randn(5,4) - 1)&gt;&gt;&gt; obj          0         1         2         30 -0.228107  1.377709 -1.096528 -2.0510011 -2.477144 -0.500013 -0.040695 -0.2674522 -0.485999 -1.232930 -0.390701 -1.9479843 -0.839161 -0.702802 -1.756359 -1.8731494  0.853121 -1.540105  0.621614 -0.583360&gt;&gt;&gt; &gt;&gt;&gt; np.abs(obj)          0         1         2         30  0.228107  1.377709  1.096528  2.0510011  2.477144  0.500013  0.040695  0.2674522  0.485999  1.232930  0.390701  1.9479843  0.839161  0.702802  1.756359  1.8731494  0.853121  1.540105  0.621614  0.583360</code></pre><p>函数映射：在 Pandas 中 <code>apply</code> 方法可以将函数应用到列或行上，可以通过设置 axis 参数来指定行或列，默认 axis = 0，即按列映射：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.random.randn(5,4) - 1)&gt;&gt;&gt; obj          0         1         2         30 -0.707028 -0.755552 -2.196480 -0.5296761 -0.772668  0.127485 -2.015699 -0.2836542  0.248200 -1.940189 -1.068028 -1.7517373 -0.872904 -0.465371 -1.327951 -2.8831604 -0.092664  0.258351 -1.010747 -2.313039&gt;&gt;&gt; &gt;&gt;&gt; obj.apply(lambda x : x.max())0    0.2482001    0.2583512   -1.0107473   -0.283654dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; obj.apply(lambda x : x.max(), axis=1)0   -0.5296761    0.1274852    0.2482003   -0.4653714    0.258351dtype: float64</code></pre><p>另外还可以通过 <code>applymap</code> 将函数映射到每个数据上：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.random.randn(5,4) - 1)&gt;&gt;&gt; obj          0         1         2         30 -0.772463 -1.597008 -3.196100 -1.9484861 -1.765108 -1.646421 -0.687175 -0.4017822  0.275699 -3.115184 -1.429063 -1.0756103 -0.251734 -0.448399 -3.077677 -0.2946744 -1.495896 -1.689729 -0.560376 -1.808794&gt;&gt;&gt; &gt;&gt;&gt; obj.applymap(lambda x : &#39;%.2f&#39; % x)       0      1      2      30  -0.77  -1.60  -3.20  -1.951  -1.77  -1.65  -0.69  -0.402   0.28  -3.12  -1.43  -1.083  -0.25  -0.45  -3.08  -0.294  -1.50  -1.69  -0.56  -1.81</code></pre><h2 id="【02x00】排序"><a href="#【02x00】排序" class="headerlink" title="【02x00】排序"></a><font color=#FF0000>【02x00】排序</font></h2><h3 id="【02x01】sort-index-索引排序"><a href="#【02x01】sort-index-索引排序" class="headerlink" title="【02x01】sort_index() 索引排序"></a><font color=#4876FF>【02x01】sort_index() 索引排序</font></h3><p>根据条件对数据集排序（sorting）也是一种重要的内置运算。要对行或列索引进行排序（按字典顺序），可使用 <code>sort_index</code> 方法，它将返回一个已排序的新对象。</p><p>在 Series 和 DataFrame 中的基本语法如下：</p><pre><code class="python">Series.sort_index(self,                  axis=0,                  level=None,                  ascending=True,                  inplace=False,                  kind=&#39;quicksort&#39;,                  na_position=&#39;last&#39;,                  sort_remaining=True,                  ignore_index: bool = False)</code></pre><pre><code class="python">DataFrame.sort_index(self,                     axis=0,                     level=None,                     ascending=True,                     inplace=False,                     kind=&#39;quicksort&#39;,                     na_position=&#39;last&#39;,                     sort_remaining=True,                     ignore_index: bool = False)</code></pre><p>官方文档：</p><ul><li><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.sort_index.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.sort_index.html</a></li><li><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_index.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_index.html</a></li></ul><p>常用参数描述如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>axis</td><td>指定轴排序，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>ascending</td><td>为 <code>True</code>时升序排序（默认），为 <code>False</code>时降序排序</td></tr><tr><td>kind</td><td>排序方法，<code>quicksort</code>：快速排序（默认）；<code>&#39;mergesort’</code>：归并排序；<code>&#39;heapsort&#39;</code>：堆排序；具体可参见 <a href="https://numpy.org/doc/stable/reference/generated/numpy.sort.html">numpy.sort()</a></td></tr></tbody></table><p>在 Series 中的应用（按照索引 index 排序）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series(range(4), index=[&#39;d&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;])&gt;&gt;&gt; objd    0a    1b    2c    3dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.sort_index()a    1b    2c    3d    0dtype: int64</code></pre><p>在 DataFrame 中的应用（可按照索引 index 或列标签 columns 排序）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(np.arange(8).reshape((2, 4)), index=[&#39;three&#39;, &#39;one&#39;], columns=[&#39;d&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;])&gt;&gt;&gt; obj       d  a  b  cthree  0  1  2  3one    4  5  6  7&gt;&gt;&gt; &gt;&gt;&gt; obj.sort_index()       d  a  b  cone    4  5  6  7three  0  1  2  3&gt;&gt;&gt; &gt;&gt;&gt; obj.sort_index(axis=1)       a  b  c  dthree  1  2  3  0one    5  6  7  4&gt;&gt;&gt; &gt;&gt;&gt; obj.sort_index(axis=1, ascending=False)       d  c  b  athree  0  3  2  1one    4  7  6  5</code></pre><h3 id="【02x02】sort-values-按值排序"><a href="#【02x02】sort-values-按值排序" class="headerlink" title="【02x02】sort_values() 按值排序"></a><font color=#4876FF>【02x02】sort_values() 按值排序</font></h3><p>在 Series 和 DataFrame 中的基本语法如下：</p><pre><code class="python">Series.sort_values(self,                   axis=0,                   ascending=True,                   inplace=False,                   kind=&#39;quicksort&#39;,                   na_position=&#39;last&#39;,                   ignore_index=False)</code></pre><pre><code class="python">DataFrame.sort_values(self,                      by,                      axis=0,                      ascending=True,                      inplace=False,                      kind=&#39;quicksort&#39;,                      na_position=&#39;last&#39;,                      ignore_index=False)</code></pre><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.sort_values.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.sort_values.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_values.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_values.html</a></p></li></ul><p>常用参数描述如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>by</td><td>DataFrame 中的必须参数，指定列的值进行排序，Series 中没有此参数</td></tr><tr><td>axis</td><td>指定轴排序，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>ascending</td><td>为 <code>True</code>时升序排序（默认），为 <code>False</code>时降序排序</td></tr><tr><td>kind</td><td>排序方法，<code>quicksort</code>：快速排序（默认）；<code>&#39;mergesort’</code>：归并排序；<code>&#39;heapsort&#39;</code>：堆排序；具体可参见 <a href="https://numpy.org/doc/stable/reference/generated/numpy.sort.html">numpy.sort()</a></td></tr></tbody></table><p>在 Series 中的应用，按照值排序，如果有缺失值，默认都会被放到 Series 的末尾：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([4, 7, -3, 2])&gt;&gt;&gt; obj0    41    72   -33    2dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.sort_values()2   -33    20    41    7dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj = pd.Series([4, np.nan, 7, np.nan, -3, 2])&gt;&gt;&gt; obj0    4.01    NaN2    7.03    NaN4   -3.05    2.0dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.sort_values()4   -3.05    2.00    4.02    7.01    NaN3    NaNdtype: float64</code></pre><p>在 DataFrame 中的应用，有时候可能希望根据一个或多个列中的值进行排序。将一个或多个列的名字传递给 <code>sort_values()</code> 的 <code>by</code> 参数即可达到该目的，当传递多个列时，首先会对第一列进行排序，若第一列有相同的值，再根据第二列进行排序，依次类推：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;a&#39;: [4, 4, -3, 2], &#39;b&#39;: [0, 1, 0, 1], &#39;c&#39;: [6, 4, 1, 3]&#125;)&gt;&gt;&gt; obj   a  b  c0  4  0  61  4  1  42 -3  0  13  2  1  3&gt;&gt;&gt; &gt;&gt;&gt; obj.sort_values(by=&#39;c&#39;)   a  b  c2 -3  0  13  2  1  31  4  1  40  4  0  6&gt;&gt;&gt; &gt;&gt;&gt; obj.sort_values(by=&#39;c&#39;, ascending=False)   a  b  c0  4  0  61  4  1  43  2  1  32 -3  0  1&gt;&gt;&gt;&gt;&gt;&gt; obj.sort_values(by=[&#39;a&#39;, &#39;b&#39;])   a  b  c2 -3  0  13  2  1  30  4  0  61  4  1  4</code></pre><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;a&#39;: [4, 4, -3, 2], &#39;b&#39;: [0, 1, 0, 1], &#39;c&#39;: [6, 4, 1, 3]&#125;, index=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])&gt;&gt;&gt; obj   a  b  cA  4  0  6B  4  1  4C -3  0  1D  2  1  3&gt;&gt;&gt; &gt;&gt;&gt; obj.sort_values(by=&#39;B&#39;, axis=1)   b  a  cA  0  4  6B  1  4  4C  0 -3  1D  1  2  3</code></pre><h3 id="【02x03】rank-返回排序后元素索引"><a href="#【02x03】rank-返回排序后元素索引" class="headerlink" title="【02x03】rank() 返回排序后元素索引"></a><font color=#4876FF>【02x03】rank() 返回排序后元素索引</font></h3><p>rank() 函数会返回一个对象，对象的值是原对象经过排序后的索引值，即下标。</p><p>在 Series 和 DataFrame 中的基本语法如下：</p><pre><code class="python">Series.rank(self: ~ FrameOrSeries,            axis=0,            method: str = &#39;average&#39;,            numeric_only: Union[bool, NoneType] = None,            na_option: str = &#39;keep&#39;,            ascending: bool = True,            pct: bool = False)</code></pre><pre><code class="python">DataFrame.rank(self: ~ FrameOrSeries,               axis=0,               method: str = &#39;average&#39;,               numeric_only: Union[bool, NoneType] = None,               na_option: str = &#39;keep&#39;,               ascending: bool = True,               pct: bool = False)</code></pre><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.rank.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.rank.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.rank.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.rank.html</a></p></li></ul><p>常用参数描述如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>axis</td><td>指定轴排序，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>method</td><td>有相同值时，如何处理：<br><code>‘average’</code>：默认值，去两个相同索引的平均值；<code>‘min’</code>：取两个相同索引的最小值；<br><code>‘max’</code>：取两个相同索引的最大值；<code>‘first’</code>：按照出现的先后顺序；<br><code>‘dense’</code>：和 <code>&#39;min&#39;</code> 差不多，但是各组之间总是+1的，不太好解释，可以看后面的示例</td></tr><tr><td>ascending</td><td>为 <code>True</code>时升序排序（默认），为 <code>False</code>时降序排序</td></tr></tbody></table><p>在 Series 中的应用，按照值排序，如果有缺失值，默认都会被放到 Series 的末尾：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([7, -5, 7, 4, 2, 0, 4])&gt;&gt;&gt; obj0    71   -52    73    44    25    06    4dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.rank()0    6.5  # 第 0 个和第 2 个值从小到大排名分别为 6 和 7，默认取平均值，即 6.51    1.02    6.53    4.5  # 第 3 个和第 6 个值从小到大排名分别为 4 和 5，默认取平均值，即 4.54    3.05    2.06    4.5dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.rank(method=&#39;first&#39;)0    6.0  # 第 0 个和第 2 个值从小到大排名分别为 6 和 7，按照第一次出现排序，分别为 6 和 71    1.02    7.03    4.0  # 第 3 个和第 6 个值从小到大排名分别为 4 和 5，按照第一次出现排序，分别为 4 和 54    3.05    2.06    5.0dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.rank(method=&#39;dense&#39;)0    5.0  # 第 0 个和第 2 个值从小到大排名分别为 6 和 7，按照最小值排序，但 dense 规定间隔为 1 所以为 51    1.02    5.03    4.0  # 第 3 个和第 6 个值从小到大排名分别为 4 和 5，按照最小值排序，即 44    3.05    2.06    4.0dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.rank(method=&#39;min&#39;)0    6.0  # 第 0 个和第 2 个值从小到大排名分别为 6 和 7，按照最小值排序，即 61    1.02    6.03    4.0  # 第 3 个和第 6 个值从小到大排名分别为 4 和 5，按照最小值排序，即 44    3.05    2.06    4.0dtype: float64</code></pre><p>在 DataFrame 中可以使用 axis 参数来指定轴：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;b&#39;: [4.3, 7, -3, 2], &#39;a&#39;: [0, 1, 0, 1], &#39;c&#39;: [-2, 5, 8, -2.5]&#125;)&gt;&gt;&gt; obj     b  a    c0  4.3  0 -2.01  7.0  1  5.02 -3.0  0  8.03  2.0  1 -2.5&gt;&gt;&gt; &gt;&gt;&gt; obj.rank()     b    a    c0  3.0  1.5  2.01  4.0  3.5  3.02  1.0  1.5  4.03  2.0  3.5  1.0&gt;&gt;&gt; &gt;&gt;&gt; obj.rank(axis=&#39;columns&#39;)     b    a    c0  3.0  2.0  1.01  3.0  1.0  2.02  1.0  2.0  3.03  3.0  2.0  1.0</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106758103未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【03x00】层级索引"><a href="#【03x00】层级索引" class="headerlink" title="【03x00】层级索引"></a><font color=#FF0000>【03x00】层级索引</font></h2><h3 id="【03x01】认识层级索引"><a href="#【03x01】认识层级索引" class="headerlink" title="【03x01】认识层级索引"></a><font color=#4876FF>【03x01】认识层级索引</font></h3><p>以下示例将创建一个 Series 对象， 索引 Index 由两个子 list 组成，第一个子 list 是外层索引，第二个 list 是内层索引：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series(np.random.randn(12),index=[[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;, &#39;c&#39;, &#39;d&#39;, &#39;d&#39;, &#39;d&#39;], [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2]])&gt;&gt;&gt; obja  0   -0.201536   1   -0.629058   2    0.766716b  0   -1.255831   1   -0.483727   2   -0.018653c  0    0.788787   1    1.010097   2   -0.187258d  0    1.242363   1   -0.822011   2   -0.085682dtype: float64</code></pre><h3 id="【03x02】MultiIndex-索引对象"><a href="#【03x02】MultiIndex-索引对象" class="headerlink" title="【03x02】MultiIndex 索引对象"></a><font color=#4876FF>【03x02】MultiIndex 索引对象</font></h3><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.MultiIndex.html">https://pandas.pydata.org/docs/reference/api/pandas.MultiIndex.html</a></p><p>尝试打印上面示例中 Series 的索引类型，会得到一个 MultiIndex 对象，MultiIndex 对象的 <font color=#FF0000>levels</font> 属性表示两个层级中分别有那些标签，<font color=#FF0000>codes</font> 属性表示每个位置分别是什么标签，如下所示：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series(np.random.randn(12),index=[[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;, &#39;c&#39;, &#39;d&#39;, &#39;d&#39;, &#39;d&#39;], [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2]])&gt;&gt;&gt; obja  0    0.035946   1   -0.867215   2   -0.053355b  0   -0.986616   1    0.026071   2   -0.048394c  0    0.251274   1    0.217790   2    1.137674d  0   -1.245178   1    1.234972   2   -0.035624dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; type(obj.index)&lt;class &#39;pandas.core.indexes.multi.MultiIndex&#39;&gt;&gt;&gt;&gt; &gt;&gt;&gt; obj.indexMultiIndex([(&#39;a&#39;, 0),            (&#39;a&#39;, 1),            (&#39;a&#39;, 2),            (&#39;b&#39;, 0),            (&#39;b&#39;, 1),            (&#39;b&#39;, 2),            (&#39;c&#39;, 0),            (&#39;c&#39;, 1),            (&#39;c&#39;, 2),            (&#39;d&#39;, 0),            (&#39;d&#39;, 1),            (&#39;d&#39;, 2)],           )&gt;&gt;&gt; obj.index.levelsFrozenList([[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], [0, 1, 2]])&gt;&gt;&gt;&gt;&gt;&gt; obj.index.codesFrozenList([[0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2]])</code></pre><p>通常可以使用 <code>from_arrays()</code> 方法来将数组对象转换为 MultiIndex 索引对象：</p><pre><code class="python">&gt;&gt;&gt; arrays = [[1, 1, 2, 2], [&#39;red&#39;, &#39;blue&#39;, &#39;red&#39;, &#39;blue&#39;]]&gt;&gt;&gt; pd.MultiIndex.from_arrays(arrays, names=(&#39;number&#39;, &#39;color&#39;))MultiIndex([(1,  &#39;red&#39;),            (1, &#39;blue&#39;),            (2,  &#39;red&#39;),            (2, &#39;blue&#39;)],           names=[&#39;number&#39;, &#39;color&#39;])</code></pre><p>其他常用方法见下表（更多方法参见官方文档）：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>from_arrays(arrays[, sortorder, names])</td><td>将数组转换为 MultiIndex</td></tr><tr><td>from_tuples(tuples[, sortorder, names])</td><td>将元组列表转换为 MultiIndex</td></tr><tr><td>from_product(iterables[, sortorder, names])</td><td>将多个可迭代的笛卡尔积转换成 MultiIndex</td></tr><tr><td>from_frame(df[, sortorder, names])</td><td>将 DataFrame 对象转换为 MultiIndex</td></tr><tr><td>set_levels(self, levels[, level, inplace, …])</td><td>为 MultiIndex 设置新的 levels</td></tr><tr><td>set_codes(self, codes[, level, inplace, …])</td><td>为 MultiIndex 设置新的 codes</td></tr><tr><td>sortlevel(self[, level, ascending, …])</td><td>根据 level 进行排序</td></tr><tr><td>droplevel(self[, level])</td><td>删除指定的 level</td></tr><tr><td>swaplevel(self[, i, j])</td><td>交换 level i 与 level i，即交换外层索引与内层索引</td></tr></tbody></table><h3 id="【03x03】提取值"><a href="#【03x03】提取值" class="headerlink" title="【03x03】提取值"></a><font color=#4876FF>【03x03】提取值</font></h3><p>对于这种有多层索引的对象，如果只传入一个参数，则会对外层索引进行提取，其中包含对应所有的内层索引，如果传入两个参数，则第一个参数表示外层索引，第二个参数表示内层索引，示例如下：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series(np.random.randn(12),index=[[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;, &#39;c&#39;, &#39;d&#39;, &#39;d&#39;, &#39;d&#39;], [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2]])&gt;&gt;&gt; obja  0    0.550202   1    0.328784   2    1.422690b  0   -1.333477   1   -0.933809   2   -0.326541c  0    0.663686   1    0.943393   2    0.273106d  0    1.354037   1   -2.312847   2   -2.343777dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;b&#39;]0   -1.3334771   -0.9338092   -0.326541dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; obj[&#39;b&#39;, 1]-0.9338094811708413&gt;&gt;&gt; &gt;&gt;&gt; obj[:, 2]a    1.422690b   -0.326541c    0.273106d   -2.343777dtype: float64</code></pre><h3 id="【03x04】交换分层与排序"><a href="#【03x04】交换分层与排序" class="headerlink" title="【03x04】交换分层与排序"></a><font color=#4876FF>【03x04】交换分层与排序</font></h3><p>MultiIndex 对象的 <code>swaplevel()</code> 方法可以交换外层与内层索引，<code>sortlevel()</code> 方法会先对外层索引进行排序，再对内层索引进行排序，默认是升序，如果设置 <code>ascending</code> 参数为 False 则会降序排列，示例如下：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series(np.random.randn(12),index=[[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;, &#39;c&#39;, &#39;d&#39;, &#39;d&#39;, &#39;d&#39;], [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2]])&gt;&gt;&gt; obja  0   -0.110215   1    0.193075   2   -1.101706b  0   -1.325743   1    0.528418   2   -0.127081c  0   -0.733822   1    1.665262   2    0.127073d  0    1.262022   1   -1.170518   2    0.966334dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.swaplevel()0  a   -0.1102151  a    0.1930752  a   -1.1017060  b   -1.3257431  b    0.5284182  b   -0.1270810  c   -0.7338221  c    1.6652622  c    0.1270730  d    1.2620221  d   -1.1705182  d    0.966334dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.swaplevel().index.sortlevel()(MultiIndex([(0, &#39;a&#39;),            (0, &#39;b&#39;),            (0, &#39;c&#39;),            (0, &#39;d&#39;),            (1, &#39;a&#39;),            (1, &#39;b&#39;),            (1, &#39;c&#39;),            (1, &#39;d&#39;),            (2, &#39;a&#39;),            (2, &#39;b&#39;),            (2, &#39;c&#39;),            (2, &#39;d&#39;)],           ), array([ 0,  3,  6,  9,  1,  4,  7, 10,  2,  5,  8, 11], dtype=int32))</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106758103未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Pandas 系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itbob.cn/article/025/&quot;&gt;Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象&lt;/a&gt;&lt;/li&gt;</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.itbob.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="数据分析" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="Pandas" scheme="https://www.itbob.cn/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</title>
    <link href="https://www.itbob.cn/article/027/"/>
    <id>https://www.itbob.cn/article/027/</id>
    <published>2020-06-14T14:42:53.000Z</published>
    <updated>2022-05-22T12:38:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106743778未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】Pandas-算术运算"><a href="#【01x00】Pandas-算术运算" class="headerlink" title="【01x00】Pandas 算术运算"></a><font color=#FF0000>【01x00】Pandas 算术运算</font></h2><p>Pandas 继承了 NumPy 的功能，NumPy 的基本能力之一是快速对每个元素进行运算，既包括基本算术运算（加、减、乘、除），也包括更复杂的运算（三角函数、指数函数和对数函数等）。具体可以参考 NumPy 系列文章。</p><h3 id="【01x01】使用-NumPy-通用函数"><a href="#【01x01】使用-NumPy-通用函数" class="headerlink" title="【01x01】使用 NumPy 通用函数"></a><font color=#4876FF>【01x01】使用 NumPy 通用函数</font></h3><p>因为 Pandas 是建立在 NumPy 基础之上的，所以 NumPy 的通用函数同样适用于 Pandas 的 Series 和 DataFrame 对象，如下所示：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; rng = np.random.RandomState(42)&gt;&gt;&gt; ser = pd.Series(rng.randint(0, 10, 4))&gt;&gt;&gt; ser0    61    32    73    4dtype: int32&gt;&gt;&gt; &gt;&gt;&gt; obj = pd.DataFrame(rng.randint(0, 10, (3, 4)), columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])&gt;&gt;&gt; obj   A  B  C  D0  6  9  2  61  7  4  3  72  7  2  5  4</code></pre><p>使用 NumPy 通用函数，生成的结果是另一个保留索引的 Pandas 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; rng = np.random.RandomState(42)&gt;&gt;&gt; ser = pd.Series(rng.randint(0, 10, 4))&gt;&gt;&gt; ser0    61    32    73    4dtype: int32&gt;&gt;&gt; &gt;&gt;&gt; np.exp(ser)0     403.4287931      20.0855372    1096.6331583      54.598150dtype: float64</code></pre><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(rng.randint(0, 10, (3, 4)), columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])&gt;&gt;&gt; np.sin(obj * np.pi / 4)          A             B         C             D0 -1.000000  7.071068e-01  1.000000 -1.000000e+001 -0.707107  1.224647e-16  0.707107 -7.071068e-012 -0.707107  1.000000e+00 -0.707107  1.224647e-16</code></pre><h3 id="【01x02】数据对齐"><a href="#【01x02】数据对齐" class="headerlink" title="【01x02】数据对齐"></a><font color=#4876FF>【01x02】数据对齐</font></h3><p>Pandas 最重要的一个功能是，它可以对不同索引的对象进行算术运算。在将对象相加时，如果存在不同的索引对，则结果的索引就是该索引对的并集。自动的数据对齐操作会在不重叠的索引处引入缺失值，即 <font color=#FF0000>NaN</font>，缺失值会在算术运算过程中传播。</p><p>Series 对象的数据对齐操作：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.Series([7.3, -2.5, 3.4, 1.5], index=[&#39;a&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;])&gt;&gt;&gt; obj2 = pd.Series([-2.1, 3.6, -1.5, 4, 3.1], index=[&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;])&gt;&gt;&gt; obj1a    7.3c   -2.5d    3.4e    1.5dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj2a   -2.1c    3.6e   -1.5f    4.0g    3.1dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; obj1 + obj2a    5.2c    1.1d    NaNe    0.0f    NaNg    NaNdtype: float64</code></pre><p>DataFrame 对象的数据对齐操作会同时发生在行和列上：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame(np.arange(9.).reshape((3, 3)), columns=list(&#39;bcd&#39;), index=[&#39;Ohio&#39;, &#39;Texas&#39;, &#39;Colorado&#39;])&gt;&gt;&gt; obj2 = pd.DataFrame(np.arange(12.).reshape((4, 3)), columns=list(&#39;bde&#39;), index=[&#39;Utah&#39;, &#39;Ohio&#39;, &#39;Texas&#39;, &#39;Oregon&#39;])&gt;&gt;&gt; obj1            b    c    dOhio      0.0  1.0  2.0Texas     3.0  4.0  5.0Colorado  6.0  7.0  8.0&gt;&gt;&gt; &gt;&gt;&gt; obj2          b     d     eUtah    0.0   1.0   2.0Ohio    3.0   4.0   5.0Texas   6.0   7.0   8.0Oregon  9.0  10.0  11.0&gt;&gt;&gt; &gt;&gt;&gt; obj1 + obj2            b   c     d   eColorado  NaN NaN   NaN NaNOhio      3.0 NaN   6.0 NaNOregon    NaN NaN   NaN NaNTexas     9.0 NaN  12.0 NaNUtah      NaN NaN   NaN NaN</code></pre><h3 id="【01x03】DataFrame-与-Series-之间的运算"><a href="#【01x03】DataFrame-与-Series-之间的运算" class="headerlink" title="【01x03】DataFrame 与 Series 之间的运算"></a><font color=#4876FF>【01x03】DataFrame 与 Series 之间的运算</font></h3><p>首先回忆 NumPy 中的广播（参见：<a href="https://itrhx.blog.csdn.net/article/details/104988137">《Python 数据分析三剑客之 NumPy（二）：数组索引 / 切片 / 广播 / 拼接 / 分割》</a>），跟不同维度的 NumPy 数组一样，DataFrame 和 Series 之间算术运算也是有明确规定的。首先回忆一下 NumPy 中不同维度的数组之间的运算：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.arange(12.).reshape((3, 4))&gt;&gt;&gt; arrarray([[ 0.,  1.,  2.,  3.],       [ 4.,  5.,  6.,  7.],       [ 8.,  9., 10., 11.]])&gt;&gt;&gt; &gt;&gt;&gt; arr[0]array([0., 1., 2., 3.])&gt;&gt;&gt; &gt;&gt;&gt; arr - arr[0]array([[0., 0., 0., 0.],       [4., 4., 4., 4.],       [8., 8., 8., 8.]])</code></pre><p>可以看到每一行都进行了减法运算，这正是 NumPy 中的广播，而 DataFrame 与 Series 之间的运算也类似，默认情况下，DataFrame 和 Series 之间的算术运算会将 Series 的索引匹配到 DataFrame 的列，然后沿着行一直向下广播：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; frame = pd.DataFrame(np.arange(12.).reshape((4, 3)), columns=list(&#39;bde&#39;), index=[&#39;AA&#39;, &#39;BB&#39;, &#39;CC&#39;, &#39;DD&#39;])&gt;&gt;&gt; frame      b     d     eAA  0.0   1.0   2.0BB  3.0   4.0   5.0CC  6.0   7.0   8.0DD  9.0  10.0  11.0&gt;&gt;&gt; &gt;&gt;&gt; series = frame.iloc[0]&gt;&gt;&gt; seriesb    0.0d    1.0e    2.0Name: AA, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; frame - series      b    d    eAA  0.0  0.0  0.0BB  3.0  3.0  3.0CC  6.0  6.0  6.0DD  9.0  9.0  9.0</code></pre><p>如果某个索引值在 DataFrame 的列或 Series 的索引中找不到，则参与运算的两个对象就会被重新索引以形成并集：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; frame = pd.DataFrame(np.arange(12.).reshape((4, 3)), columns=list(&#39;bde&#39;), index=[&#39;AA&#39;, &#39;BB&#39;, &#39;CC&#39;, &#39;DD&#39;])&gt;&gt;&gt; frame      b     d     eAA  0.0   1.0   2.0BB  3.0   4.0   5.0CC  6.0   7.0   8.0DD  9.0  10.0  11.0&gt;&gt;&gt; &gt;&gt;&gt; series = pd.Series(range(3), index=[&#39;b&#39;, &#39;e&#39;, &#39;f&#39;])&gt;&gt;&gt; seriesb    0e    1f    2dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; frame + series      b   d     e   fAA  0.0 NaN   3.0 NaNBB  3.0 NaN   6.0 NaNCC  6.0 NaN   9.0 NaNDD  9.0 NaN  12.0 NaN</code></pre><p>如果希望匹配行且在列上广播，则必须使用算术运算方法，在方法中传入的轴（axis）就是希望匹配的轴。在下例中，我们的目的是匹配 DataFrame 的行索引（axis=’index’ or axis=0）并进行广播：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; frame = pd.DataFrame(np.arange(12.).reshape((4, 3)), columns=list(&#39;bde&#39;), index=[&#39;AA&#39;, &#39;BB&#39;, &#39;CC&#39;, &#39;DD&#39;])&gt;&gt;&gt; frame      b     d     eAA  0.0   1.0   2.0BB  3.0   4.0   5.0CC  6.0   7.0   8.0DD  9.0  10.0  11.0&gt;&gt;&gt; &gt;&gt;&gt; series = frame[&#39;d&#39;]&gt;&gt;&gt; seriesAA     1.0BB     4.0CC     7.0DD    10.0Name: d, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; frame.sub(series, axis=&#39;index&#39;)      b    d    eAA -1.0  0.0  1.0BB -1.0  0.0  1.0CC -1.0  0.0  1.0DD -1.0  0.0  1.0</code></pre><h3 id="【01x04】Pandas-算术方法"><a href="#【01x04】Pandas-算术方法" class="headerlink" title="【01x04】Pandas 算术方法"></a><font color=#4876FF>【01x04】Pandas 算术方法</font></h3><p>完整的 Pandas 算术方法见下表：</p><table><thead><tr><th>方法</th><th>副本</th><th>描述</th></tr></thead><tbody><tr><td>add()</td><td>radd()</td><td>加法（+）</td></tr><tr><td>sub()、subtract()</td><td>rsub()</td><td>减法（-）</td></tr><tr><td>mul()、multiply()</td><td>rmul()</td><td>乘法（*）</td></tr><tr><td>pow()</td><td>rpow()</td><td>指数（**）</td></tr><tr><td>truediv()、div()、divide()</td><td>rdiv()</td><td>除法（/）</td></tr><tr><td>floordiv()</td><td>rfloordiv()</td><td>底除（//）</td></tr><tr><td>mod()</td><td>rmod()</td><td>求余（%）</td></tr></tbody></table><p>副本均为原方法前加了个 <code>r</code>，它会翻转参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(np.arange(12.).reshape((3, 4)), columns=list(&#39;abcd&#39;))&gt;&gt;&gt; obj     a    b     c     d0  0.0  1.0   2.0   3.01  4.0  5.0   6.0   7.02  8.0  9.0  10.0  11.0&gt;&gt;&gt; &gt;&gt;&gt; 1 / obj       a         b         c         d0    inf  1.000000  0.500000  0.3333331  0.250  0.200000  0.166667  0.1428572  0.125  0.111111  0.100000  0.090909&gt;&gt;&gt; &gt;&gt;&gt; obj.rdiv(1)       a         b         c         d0    inf  1.000000  0.500000  0.3333331  0.250  0.200000  0.166667  0.1428572  0.125  0.111111  0.100000  0.090909</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106743778未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【02x00】处理缺失值"><a href="#【02x00】处理缺失值" class="headerlink" title="【02x00】处理缺失值"></a><font color=#FF0000>【02x00】处理缺失值</font></h2><p>在现实中遇到的数据很少是干净整齐的，许多数据集都会有数据缺失的现象，缺失值主要有三种形式：null、NaN（NAN，nan） 或 NA。</p><h3 id="【02x01】fill-value-指定值与缺失值进行运算"><a href="#【02x01】fill-value-指定值与缺失值进行运算" class="headerlink" title="【02x01】fill_value() 指定值与缺失值进行运算"></a><font color=#4876FF>【02x01】fill_value() 指定值与缺失值进行运算</font></h3><p>使用 <code>add</code>, <code>sub</code>, <code>div</code>, <code>mul</code> 等算术方法时，通过 <code>fill_value</code> 指定填充值，未对齐的数据将和填充值做运算。</p><p>Series 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.Series([1, 2, 3, 4, 5])&gt;&gt;&gt; obj2 = pd.Series([6, 7])&gt;&gt;&gt; &gt;&gt;&gt; obj10    11    22    33    44    5dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj20    61    7dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj1.add(obj2)0    7.01    9.02    NaN3    NaN4    NaNdtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj1.add(obj2, fill_value=-1)0    7.01    9.02    2.03    3.04    4.0dtype: float64</code></pre><p>DataFrame 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj1 = pd.DataFrame(np.arange(12.).reshape((3, 4)), columns=list(&#39;abcd&#39;))&gt;&gt;&gt; obj2 = pd.DataFrame(np.arange(20.).reshape((4, 5)), columns=list(&#39;abcde&#39;))&gt;&gt;&gt; &gt;&gt;&gt; obj2.loc[1, &#39;b&#39;] = np.nan&gt;&gt;&gt; &gt;&gt;&gt; obj1     a    b     c     d0  0.0  1.0   2.0   3.01  4.0  5.0   6.0   7.02  8.0  9.0  10.0  11.0&gt;&gt;&gt; &gt;&gt;&gt; obj2      a     b     c     d     e0   0.0   1.0   2.0   3.0   4.01   5.0   NaN   7.0   8.0   9.02  10.0  11.0  12.0  13.0  14.03  15.0  16.0  17.0  18.0  19.0&gt;&gt;&gt; &gt;&gt;&gt; obj1 + obj2      a     b     c     d   e0   0.0   2.0   4.0   6.0 NaN1   9.0   NaN  13.0  15.0 NaN2  18.0  20.0  22.0  24.0 NaN3   NaN   NaN   NaN   NaN NaN&gt;&gt;&gt; &gt;&gt;&gt; obj1.add(obj2, fill_value=10)      a     b     c     d     e0   0.0   2.0   4.0   6.0  14.01   9.0  15.0  13.0  15.0  19.02  18.0  20.0  22.0  24.0  24.03  25.0  26.0  27.0  28.0  29.0</code></pre><h3 id="【02x02】isnull-notnull-判断缺失值"><a href="#【02x02】isnull-notnull-判断缺失值" class="headerlink" title="【02x02】isnull() / notnull() 判断缺失值"></a><font color=#4876FF>【02x02】isnull() / notnull() 判断缺失值</font></h3><p><code>isnull()</code>：为缺失值时为 <code>True</code>，否则为 <code>False</code>；</p><p><code>notnull()</code> 为缺失值时为 <code>False</code>，否则为 <code>True</code>。</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, np.nan, &#39;hello&#39;, None])&gt;&gt;&gt; obj0        11      NaN2    hello3     Nonedtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.isnull()0    False1     True2    False3     Truedtype: bool&gt;&gt;&gt; &gt;&gt;&gt; obj.notnull()0     True1    False2     True3    Falsedtype: bool</code></pre><h3 id="【02x03】dropna-删除缺失值"><a href="#【02x03】dropna-删除缺失值" class="headerlink" title="【02x03】dropna() 删除缺失值"></a><font color=#4876FF>【02x03】dropna() 删除缺失值</font></h3><p><code>dropna()</code> 方法用于返回一个删除了缺失值的新 Series 或 DataFrame 对象。</p><p>在 Series 对象当中，<code>dropna()</code> 方法的语法如下（其他参数用法可参考在 DataFrame 中的应用）：</p><p><code>Series.dropna(self, axis=0, inplace=False, how=None)</code></p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.dropna.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.dropna.html</a></p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, np.nan, &#39;hello&#39;, None])&gt;&gt;&gt; obj0        11      NaN2    hello3     Nonedtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.dropna()0        12    hellodtype: object</code></pre><p>在 DataFrame 对象中，<code>dropna()</code> 方法的语法如下：</p><p><code>DataFrame.dropna(self, axis=0, how=&#39;any&#39;, thresh=None, subset=None, inplace=False)</code></p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.dropna.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.dropna.html</a></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>axis</td><td>确定是否删除包含缺失值的行或列<br><code>0</code> 或 <code>&#39;index&#39;</code>：删除包含缺失值的行。<code>1</code> 或 <code>&#39;columns&#39;</code>：删除包含缺失值的列</td></tr><tr><td>how</td><td><code>&#39;any&#39;</code>：如果存在任何NA值，则删除该行或列。<code>&#39;all&#39;</code>：如果所有值都是NA，则删除该行或列</td></tr><tr><td>thresh</td><td>设置行或列中<strong>非缺失值</strong>的最小数量</td></tr></tbody></table><p>不传递任何参数，将会删除任何包含缺失值的整行数据：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1, np.nan, 2], [2, 3, 5], [np.nan, 4, 6]])&gt;&gt;&gt; obj     0    1  20  1.0  NaN  21  2.0  3.0  52  NaN  4.0  6&gt;&gt;&gt; &gt;&gt;&gt; obj.dropna()     0    1  21  2.0  3.0  5</code></pre><p>指定 axis 参数，删除包含缺失值的行或列：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1, np.nan, 2], [2, 3, 5], [np.nan, 4, 6]])&gt;&gt;&gt; obj     0    1  20  1.0  NaN  21  2.0  3.0  52  NaN  4.0  6&gt;&gt;&gt; &gt;&gt;&gt; obj.dropna(axis=&#39;columns&#39;)   20  21  52  6</code></pre><p>指定 how 参数，<code>&#39;any&#39;</code>：如果存在任何NA值，则删除该行或列。<code>&#39;all&#39;</code>：如果所有值都是NA，则删除该行或列：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1, np.nan, 2, np.nan], [2, 3, 5, np.nan], [np.nan, 4, 6, np.nan]])&gt;&gt;&gt; obj     0    1  2   30  1.0  NaN  2 NaN1  2.0  3.0  5 NaN2  NaN  4.0  6 NaN&gt;&gt;&gt; obj.dropna(axis=&#39;columns&#39;, how=&#39;all&#39;)     0    1  20  1.0  NaN  21  2.0  3.0  52  NaN  4.0  6</code></pre><p>指定 thresh 参数，设置行或列中<font color=#FF0000><strong>非缺失值</strong></font>的最小数量，以下示例中，第一行和第三行只有两个非缺失值，所以会被删除：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1, np.nan, 2, np.nan], [2, 3, 5, np.nan], [np.nan, 4, 6, np.nan]])&gt;&gt;&gt; obj     0    1  2   30  1.0  NaN  2 NaN1  2.0  3.0  5 NaN2  NaN  4.0  6 NaN&gt;&gt;&gt;&gt;&gt;&gt; obj.dropna(axis=&#39;rows&#39;, thresh=3)     0    1  2   31  2.0  3.0  5 NaN</code></pre><h3 id="【02x04】fillna-填充缺失值"><a href="#【02x04】fillna-填充缺失值" class="headerlink" title="【02x04】fillna() 填充缺失值"></a><font color=#4876FF>【02x04】fillna() 填充缺失值</font></h3><p><code>fillna()</code> 方法可以将缺失值替换成有效的数值。</p><p>在 Series 对象中，<code>fillna()</code> 方法的语法如下：</p><p><code>Series.fillna(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None)</code></p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.fillna.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.fillna.html</a></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>用于填充的值（例如 0），或者是一个 dict / Series / DataFrame 值<br>指定要用于每个 index（对于 Series）或column（对于 DataFrame）的值<br>不在dict / Series / DataFrame中的值将不被填充。此值不能是列表</td></tr><tr><td>method</td><td>填充方法：<code>None</code><br><code>‘pad’</code> / <code>‘ffill’</code>：将上一个有效观测值向前传播到下一个有效观测值<br><code>‘backfill’</code> / <code>‘bfill’</code>：使用下一个有效观察值来填补空白</td></tr><tr><td>axis</td><td><code>0</code> or <code>‘index’</code>，要填充缺失值的轴</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, np.nan, 2, None, 3], index=list(&#39;abcde&#39;))&gt;&gt;&gt; obja    1.0b    NaNc    2.0d    NaNe    3.0dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.fillna(0)a    1.0b    0.0c    2.0d    0.0e    3.0dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.fillna(method=&#39;ffill&#39;)a    1.0b    1.0c    2.0d    2.0e    3.0dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.fillna(method=&#39;bfill&#39;)a    1.0b    2.0c    2.0d    3.0e    3.0dtype: float64</code></pre><p>在 DataFrame 对象中，<code>fillna()</code> 方法的语法如下：</p><p><code>DataFrame.fillna(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None)</code></p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.fillna.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.fillna.html</a></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>用于填充的值（例如 0），或者是一个 dict / Series / DataFrame 值<br>指定要用于每个 index（对于 Series）或column（对于 DataFrame）的值<br>不在dict / Series / DataFrame中的值将不被填充。此值不能是列表</td></tr><tr><td>method</td><td>填充方法：<code>None</code><br><code>‘pad’</code> / <code>‘ffill’</code>：将上一个有效观测值向前传播到下一个有效观测值<br><code>‘backfill’</code> / <code>‘bfill’</code>：使用下一个有效观察值来填补空白</td></tr><tr><td>axis</td><td><code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，要填充缺失值的轴</td></tr></tbody></table><p>在 DataFrame 对象中的用法和在 Series 对象中的用法大同小异，只不过 axis 参数多了一个选择：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1, np.nan, 2, np.nan], [2, 3, 5, np.nan], [np.nan, 4, 6, np.nan]])&gt;&gt;&gt; obj     0    1  2   30  1.0  NaN  2 NaN1  2.0  3.0  5 NaN2  NaN  4.0  6 NaN&gt;&gt;&gt; &gt;&gt;&gt; obj.fillna(method=&#39;ffill&#39;, axis=1)     0    1    2    30  1.0  1.0  2.0  2.01  2.0  3.0  5.0  5.02  NaN  4.0  6.0  6.0</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106743778未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Pandas 系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itbob.cn/article/025/&quot;&gt;Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象&lt;/a&gt;&lt;/li&gt;</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.itbob.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="数据分析" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="Pandas" scheme="https://www.itbob.cn/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</title>
    <link href="https://www.itbob.cn/article/026/"/>
    <id>https://www.itbob.cn/article/026/</id>
    <published>2020-06-13T14:19:53.000Z</published>
    <updated>2022-05-22T12:38:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106698307未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h1 id="【1】Index-索引对象"><a href="#【1】Index-索引对象" class="headerlink" title="【1】Index 索引对象"></a><font color=#FF0000>【1】Index 索引对象</font></h1><p> Series 和 DataFrame 中的索引都是 Index 对象，为了保证数据的安全，索引对象是不可变的，如果尝试更改索引就会报错；常见的 Index 种类有：索引（Index），整数索引（Int64Index），层级索引（MultiIndex），时间戳类型（DatetimeIndex）。</p><p>一下代码演示了 Index 索引对象和其不可变的性质：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obj.indexIndex([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=&#39;object&#39;)&gt;&gt;&gt; type(obj.index)&lt;class &#39;pandas.core.indexes.base.Index&#39;&gt;&gt;&gt;&gt; obj.index[0] = &#39;e&#39;Traceback (most recent call last):  File &quot;&lt;pyshell#28&gt;&quot;, line 1, in &lt;module&gt;    obj.index[0] = &#39;e&#39;  File &quot;C:\Users\...\base.py&quot;, line 3909, in __setitem__    raise TypeError(&quot;Index does not support mutable operations&quot;)TypeError: Index does not support mutable operations</code></pre><table><tr><td bgcolor="#FFA500"><font size="5" color="#fff">index 索引对象常用属性</font></td></tr></table><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.html">https://pandas.pydata.org/docs/reference/api/pandas.Index.html</a></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>T</td><td>转置</td></tr><tr><td>array</td><td>index 的数组形式，常见<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.array.html">官方文档</a></td></tr><tr><td>dtype</td><td>返回基础数据的 dtype 对象</td></tr><tr><td>hasnans</td><td>是否有 NaN（缺失值）</td></tr><tr><td>inferred_type</td><td>返回一个字符串，表示 index 的类型</td></tr><tr><td>is_monotonic</td><td>判断 index 是否是递增的</td></tr><tr><td>is_monotonic_decreasing</td><td>判断 index 是否单调递减</td></tr><tr><td>is_monotonic_increasing</td><td>判断 index 是否单调递增</td></tr><tr><td>is_unique</td><td>index 是否没有重复值</td></tr><tr><td>nbytes</td><td>返回 index 中的字节数</td></tr><tr><td>ndim</td><td>index 的维度</td></tr><tr><td>nlevels</td><td>Number of levels.</td></tr><tr><td>shape</td><td>返回一个元组，表示 index 的形状</td></tr><tr><td>size</td><td>index 的大小</td></tr><tr><td>values</td><td>返回 index 中的值 / 数组</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obj.indexIndex([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=&#39;object&#39;)&gt;&gt;&gt; &gt;&gt;&gt; obj.index.array&lt;PandasArray&gt;[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]Length: 4, dtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.index.dtypedtype(&#39;O&#39;)&gt;&gt;&gt; &gt;&gt;&gt; obj.index.hasnansFalse&gt;&gt;&gt;&gt;&gt;&gt; obj.index.inferred_type&#39;string&#39;&gt;&gt;&gt; &gt;&gt;&gt; obj.index.is_monotonicTrue&gt;&gt;&gt;&gt;&gt;&gt; obj.index.is_monotonic_decreasingFalse&gt;&gt;&gt; &gt;&gt;&gt; obj.index.is_monotonic_increasingTrue&gt;&gt;&gt; &gt;&gt;&gt; obj.index.is_uniqueTrue&gt;&gt;&gt; &gt;&gt;&gt; obj.index.nbytes16&gt;&gt;&gt;&gt;&gt;&gt; obj.index.ndim1&gt;&gt;&gt;&gt;&gt;&gt; obj.index.nlevels1&gt;&gt;&gt;&gt;&gt;&gt; obj.index.shape(4,)&gt;&gt;&gt; &gt;&gt;&gt; obj.index.size4&gt;&gt;&gt; &gt;&gt;&gt; obj.index.valuesarray([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=object)</code></pre><table><tr><td bgcolor="#FFA500"><font size="5" color="#fff">index 索引对象常用方法</font></td></tr></table><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.html">https://pandas.pydata.org/docs/reference/api/pandas.Index.html</a></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>all(self, *args, **kwargs)</td><td>判断所有元素是否为真，有 0 会被视为 False</td></tr><tr><td>any(self, *args, **kwargs)</td><td>判断是否至少有一个元素为真，均为 0 会被视为 False</td></tr><tr><td>append(self, other)</td><td>连接另一个 index，产生一个新的 index</td></tr><tr><td>argmax(self[, axis, skipna])</td><td>返回 index 中最大值的索引值</td></tr><tr><td>argmin(self[, axis, skipna])</td><td>返回 index 中最小值的索引值</td></tr><tr><td>argsort(self, *args, **kwargs)</td><td>对 index 从小到大排序，返回排序后的元素在原 index 中的索引值</td></tr><tr><td>delete(self, loc)</td><td>删除指定索引位置的元素，返回删除后的新 index</td></tr><tr><td>difference(self, other[, sort])</td><td>在第一个 index 中删除第二个 index 中的元素，即差集</td></tr><tr><td>drop(self, labels[, errors])</td><td>在原 index 中删除传入的值</td></tr><tr><td>drop_duplicates(self[, keep])</td><td>删除重复值，keep 参数可选值如下：<br><code>‘first’</code>：保留第一次出现的重复项；<br><code>‘last’</code>：保留最后一次出现的重复项；<br><code>False</code>：不保留重复项</td></tr><tr><td>duplicated(self[, keep])</td><td>判断是否为重复值，keep 参数可选值如下：<br><code>‘first’</code>：第一次重复的为 False，其他为 True；<br><code>‘last’</code>：最后一次重复的为 False，其他为 True；<br><code>False</code>：所有重复的均为 True</td></tr><tr><td>dropna(self[, how])</td><td>删除缺失值，即 NaN</td></tr><tr><td>fillna(self[, value, downcast])</td><td>用指定值填充缺失值，即 NaN</td></tr><tr><td>equals(self, other)</td><td>判断两个  index 是否相同</td></tr><tr><td>insert(self, loc, item)</td><td>将元素插入到指定索引处，返回新的 index</td></tr><tr><td>intersection(self, other[, sort])</td><td>返回两个 index 的交集</td></tr><tr><td>isna(self)</td><td>检测 index 元素是否为缺失值，即 NaN</td></tr><tr><td>isnull(self)</td><td>检测 index 元素是否为缺失值，即 NaN</td></tr><tr><td>max(self[, axis, skipna])</td><td>返回 index 的最大值</td></tr><tr><td>min(self[, axis, skipna])</td><td>返回 index 的最小值</td></tr><tr><td>union(self, other[, sort])</td><td>返回两个 index 的并集</td></tr><tr><td>unique(self[, level])</td><td>返回 index 中的唯一值，相当于去除重复值</td></tr></tbody></table><ul><li><p><code>all(self, *args, **kwargs)</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.all.html">官方文档</a>】</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([1, 2, 3]).all()True&gt;&gt;&gt;&gt;&gt;&gt; pd.Index([0, 1, 2]).all()False</code></pre></li><li><p><code>any(self, *args, **kwargs)</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.any.html">官方文档</a>】</p></li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([0, 0, 1]).any()True&gt;&gt;&gt;&gt;&gt;&gt; pd.Index([0, 0, 0]).any()False</code></pre><ul><li><code>append(self, other)</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.append.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]).append(pd.Index([1, 2, 3]))Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2, 3], dtype=&#39;object&#39;)</code></pre><ul><li><code>argmax(self[, axis, skipna])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.argmax.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([5, 2, 3, 9, 1]).argmax()3</code></pre><ul><li><code>argmin(self[, axis, skipna])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.argmin.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([5, 2, 3, 9, 1]).argmin()4</code></pre><ul><li><code>argsort(self, *args, **kwargs)</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.argsort.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([5, 2, 3, 9, 1]).argsort()array([4, 1, 2, 0, 3], dtype=int32)</code></pre><ul><li><code>delete(self, loc)</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.delete.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([5, 2, 3, 9, 1]).delete(0)Int64Index([2, 3, 9, 1], dtype=&#39;int64&#39;)</code></pre><ul><li><code>difference(self, other[, sort])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.difference.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx1 = pd.Index([2, 1, 3, 4])&gt;&gt;&gt; idx2 = pd.Index([3, 4, 5, 6])&gt;&gt;&gt; idx1.difference(idx2)Int64Index([1, 2], dtype=&#39;int64&#39;)&gt;&gt;&gt; idx1.difference(idx2, sort=False)Int64Index([2, 1], dtype=&#39;int64&#39;)</code></pre><ul><li><code>drop(self, labels[, errors])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.drop.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([5, 2, 3, 9, 1]).drop([2, 1])Int64Index([5, 3, 9], dtype=&#39;int64&#39;)</code></pre><ul><li><code>drop_duplicates(self[, keep])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.drop_duplicates.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx = pd.Index([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;, &#39;hippo&#39;])&gt;&gt;&gt; idx.drop_duplicates(keep=&#39;first&#39;)Index([&#39;lama&#39;, &#39;cow&#39;, &#39;beetle&#39;, &#39;hippo&#39;], dtype=&#39;object&#39;)&gt;&gt;&gt; idx.drop_duplicates(keep=&#39;last&#39;)Index([&#39;cow&#39;, &#39;beetle&#39;, &#39;lama&#39;, &#39;hippo&#39;], dtype=&#39;object&#39;)&gt;&gt;&gt; idx.drop_duplicates(keep=False)Index([&#39;cow&#39;, &#39;beetle&#39;, &#39;hippo&#39;], dtype=&#39;object&#39;)</code></pre><ul><li>duplicated(self[, keep]) 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.duplicated.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx = pd.Index([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;])&gt;&gt;&gt; idx.duplicated()array([False, False,  True, False,  True])&gt;&gt;&gt; idx.duplicated(keep=&#39;first&#39;)array([False, False,  True, False,  True])&gt;&gt;&gt; idx.duplicated(keep=&#39;last&#39;)array([ True, False,  True, False, False])&gt;&gt;&gt; idx.duplicated(keep=False)array([ True, False,  True, False,  True])</code></pre><ul><li><code>dropna(self[, how])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.dropna.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([2, 5, np.NaN, 6, np.NaN, np.NaN]).dropna()Float64Index([2.0, 5.0, 6.0], dtype=&#39;float64&#39;)</code></pre><ul><li><code>fillna(self[, value, downcast])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.fillna.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([2, 5, np.NaN, 6, np.NaN, np.NaN]).fillna(5)Float64Index([2.0, 5.0, 5.0, 6.0, 5.0, 5.0], dtype=&#39;float64&#39;)</code></pre><ul><li><code>equals(self, other)</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.equals.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx1 = pd.Index([5, 2, 3, 9, 1])&gt;&gt;&gt; idx2 = pd.Index([5, 2, 3, 9, 1])&gt;&gt;&gt; idx1.equals(idx2)True&gt;&gt;&gt; &gt;&gt;&gt; idx1 = pd.Index([5, 2, 3, 9, 1])&gt;&gt;&gt; idx2 = pd.Index([5, 2, 4, 9, 1])&gt;&gt;&gt; idx1.equals(idx2)False</code></pre><ul><li><code>intersection(self, other[, sort])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.intersection.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx1 = pd.Index([1, 2, 3, 4])&gt;&gt;&gt; idx2 = pd.Index([3, 4, 5, 6])&gt;&gt;&gt; idx1.intersection(idx2)Int64Index([3, 4], dtype=&#39;int64&#39;)</code></pre><ul><li><code>insert(self, loc, item)</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.insert.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([5, 2, 3, 9, 1]).insert(2, &#39;A&#39;)Index([5, 2, &#39;A&#39;, 3, 9, 1], dtype=&#39;object&#39;)</code></pre><ul><li><code>isna(self)</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.isna.html">官方文档</a>】、<code>isnull(self)</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.isnull.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([2, 5, np.NaN, 6, np.NaN, np.NaN]).isna()array([False, False,  True, False,  True,  True])&gt;&gt;&gt; pd.Index([2, 5, np.NaN, 6, np.NaN, np.NaN]).isnull()array([False, False,  True, False,  True,  True])</code></pre><ul><li><code>max(self[, axis, skipna])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.max.html">官方文档</a>】、<code>min(self[, axis, skipna])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.min.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([5, 2, 3, 9, 1]).max()9&gt;&gt;&gt; pd.Index([5, 2, 3, 9, 1]).min()1</code></pre><ul><li><code>union(self, other[, sort])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.union.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx1 = pd.Index([1, 2, 3, 4])&gt;&gt;&gt; idx2 = pd.Index([3, 4, 5, 6])&gt;&gt;&gt; idx1.union(idx2)Int64Index([1, 2, 3, 4, 5, 6], dtype=&#39;int64&#39;)</code></pre><ul><li><code>unique(self[, level])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.unique.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([5, 1, 3, 5, 1]).unique()Int64Index([5, 1, 3], dtype=&#39;int64&#39;)</code></pre><h1 id="【2】Pandas-一般索引"><a href="#【2】Pandas-一般索引" class="headerlink" title="【2】Pandas 一般索引"></a><font color=#FF0000>【2】Pandas 一般索引</font></h1><p>由于在 Pandas 中，由于有一些更高级的索引操作，比如重新索引，层级索引等，因此将一般的切片索引、花式索引、布尔索引等归纳为一般索引。</p><h2 id="【2-1】Series-索引"><a href="#【2-1】Series-索引" class="headerlink" title="【2.1】Series 索引"></a><font color=#4876FF>【2.1】Series 索引</font></h2><h3 id="【2-1-1】head-tail"><a href="#【2-1-1】head-tail" class="headerlink" title="【2.1.1】head() / tail()"></a><font color=#FFA500>【2.1.1】head() / tail()</font></h3><p><code>Series.head()</code> 和 <code>Series.tail()</code> 方法可以获取的前五行和后五行数据，如果向 head() / tail() 里面传入参数，则会获取指定行：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series(np.random.randn(8))&gt;&gt;&gt; obj0   -0.6434371   -0.3656522   -0.9665543   -0.0361274    1.0460955   -2.0483626   -1.8655517    1.344728dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.head()0   -0.6434371   -0.3656522   -0.9665543   -0.0361274    1.046095dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.head(3)0   -0.6434371   -0.3656522   -0.966554dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; obj.tail()3    1.2212214   -1.3734965    1.0328436    0.0297347   -1.861485dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; obj.tail(3)5    1.0328436    0.0297347   -1.861485dtype: float64</code></pre><h3 id="【2-1-2】行索引"><a href="#【2-1-2】行索引" class="headerlink" title="【2.1.2】行索引"></a><font color=#FFA500>【2.1.2】行索引</font></h3><p>Pandas 中可以按照位置进行索引，也可以按照索引名（index）进行索引，也可以用 Python 字典的表达式和方法来获取值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obja    1b    5c   -8d    2dtype: int64&gt;&gt;&gt; obj[&#39;c&#39;]-8&gt;&gt;&gt; obj[2]-8&gt;&gt;&gt; &#39;b&#39; in objTrue&gt;&gt;&gt; obj.keys()Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=&#39;object&#39;)&gt;&gt;&gt; list(obj.items())[(&#39;a&#39;, 1), (&#39;b&#39;, 5), (&#39;c&#39;, -8), (&#39;d&#39;, 2)]</code></pre><h3 id="【2-1-3】切片索引"><a href="#【2-1-3】切片索引" class="headerlink" title="【2.1.3】切片索引"></a><font color=#FFA500>【2.1.3】切片索引</font></h3><p>切片的方法有两种：按位置切片和按索引名（index）切片，注意：按位置切片时，<font color=#FF0000><strong>不包含</strong></font>终止索引；按索引名（index）切片时，<font color=#FF0000><strong>包含</strong></font>终止索引。</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obja    1b    5c   -8d    2dtype: int64&gt;&gt;&gt;&gt;&gt;&gt; obj[1:3]b    5c   -8dtype: int64&gt;&gt;&gt;&gt;&gt;&gt; obj[0:3:2]a    1c   -8dtype: int64&gt;&gt;&gt;&gt;&gt;&gt; obj[&#39;b&#39;:&#39;d&#39;]b    5c   -8d    2dtype: int64</code></pre><h3 id="【2-1-4】花式索引"><a href="#【2-1-4】花式索引" class="headerlink" title="【2.1.4】花式索引"></a><font color=#FFA500>【2.1.4】花式索引</font></h3><p>所谓的花式索引，就是间隔索引、不连续的索引，传递一个由索引名（index）或者位置参数组成的<font color=#FF0000><strong>列表</strong></font>来一次性获得多个元素：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obja    1b    5c   -8d    2dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj[[0, 2]]a    1c   -8dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj[[&#39;a&#39;, &#39;c&#39;, &#39;d&#39;]]a    1c   -8d    2dtype: int64</code></pre><h3 id="【2-1-5】布尔索引"><a href="#【2-1-5】布尔索引" class="headerlink" title="【2.1.5】布尔索引"></a><font color=#FFA500>【2.1.5】布尔索引</font></h3><p>可以通过一个布尔数组来索引目标数组，即通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2, -3], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;])&gt;&gt;&gt; obja    1b    5c   -8d    2e   -3dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj[obj &gt; 0]a    1b    5d    2dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj &gt; 0a     Trueb     Truec    Falsed     Truee    Falsedtype: bool</code></pre><h2 id="【2-2】DataFrame-索引"><a href="#【2-2】DataFrame-索引" class="headerlink" title="【2.2】DataFrame 索引"></a><font color=#4876FF>【2.2】DataFrame 索引</font></h2><h3 id="【2-2-1】head-tail"><a href="#【2-2-1】head-tail" class="headerlink" title="【2.2.1】head() / tail()"></a><font color=#FFA500>【2.2.1】head() / tail()</font></h3><p>和 Series 一样，<code>DataFrame.head()</code> 和 <code>DataFrame.tail()</code> 方法同样可以获取 DataFrame 的前五行和后五行数据，如果向 head() / tail() 里面传入参数，则会获取指定行：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.random.randn(8,4), columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obj          a         b         c         d0 -1.399390  0.521596 -0.869613  0.5066211 -0.748562 -0.364952  0.188399 -1.4025662  1.378776 -1.476480  0.361635  0.4511343 -0.206405 -1.188609  3.002599  0.5636504  0.993289  1.133748  1.177549 -2.5622865 -0.482157  1.069293  1.143983 -1.3030796 -1.199154  0.220360  0.801838 -0.1045337 -1.359816 -2.092035  2.003530 -0.151812&gt;&gt;&gt; &gt;&gt;&gt; obj.head()          a         b         c         d0 -1.399390  0.521596 -0.869613  0.5066211 -0.748562 -0.364952  0.188399 -1.4025662  1.378776 -1.476480  0.361635  0.4511343 -0.206405 -1.188609  3.002599  0.5636504  0.993289  1.133748  1.177549 -2.562286&gt;&gt;&gt; &gt;&gt;&gt; obj.head(3)          a         b         c         d0 -1.399390  0.521596 -0.869613  0.5066211 -0.748562 -0.364952  0.188399 -1.4025662  1.378776 -1.476480  0.361635  0.451134&gt;&gt;&gt;&gt;&gt;&gt; obj.tail()          a         b         c         d3 -0.206405 -1.188609  3.002599  0.5636504  0.993289  1.133748  1.177549 -2.5622865 -0.482157  1.069293  1.143983 -1.3030796 -1.199154  0.220360  0.801838 -0.1045337 -1.359816 -2.092035  2.003530 -0.151812&gt;&gt;&gt; &gt;&gt;&gt; obj.tail(3)          a         b         c         d5 -0.482157  1.069293  1.143983 -1.3030796 -1.199154  0.220360  0.801838 -0.1045337 -1.359816 -2.092035  2.003530 -0.151812</code></pre><h3 id="【2-2-2】列索引"><a href="#【2-2-2】列索引" class="headerlink" title="【2.2.2】列索引"></a><font color=#FFA500>【2.2.2】列索引</font></h3><p>DataFrame 可以按照列标签（columns）来进行列索引：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.random.randn(7,2), columns = [&#39;a&#39;, &#39;b&#39;])&gt;&gt;&gt; obj          a         b0 -1.198795  0.9283781 -2.878230  0.0146502  2.267475  0.3709523  0.639340 -1.3010414 -1.953444  0.1489345 -0.445225  0.4596326  0.097109 -2.592833&gt;&gt;&gt;&gt;&gt;&gt; obj[&#39;a&#39;]0   -1.1987951   -2.8782302    2.2674753    0.6393404   -1.9534445   -0.4452256    0.097109Name: a, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj[[&#39;a&#39;]]          a0 -1.1987951 -2.8782302  2.2674753  0.6393404 -1.9534445 -0.4452256  0.097109&gt;&gt;&gt; &gt;&gt;&gt; type(obj[&#39;a&#39;])&lt;class &#39;pandas.core.series.Series&#39;&gt;&gt;&gt;&gt; type(obj[[&#39;a&#39;]])&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</code></pre><h3 id="【2-2-3】切片索引"><a href="#【2-2-3】切片索引" class="headerlink" title="【2.2.3】切片索引"></a><font color=#FFA500>【2.2.3】切片索引</font></h3><p>DataFrame 中的切片索引是针对行来操作的，切片的方法有两种：按位置切片和按索引名（index）切片，注意：按位置切片时，不包含终止索引；按索引名（index）切片时，包含终止索引。</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = np.random.randn(5,4)&gt;&gt;&gt; index = [&#39;I1&#39;, &#39;I2&#39;, &#39;I3&#39;, &#39;I4&#39;, &#39;I5&#39;]&gt;&gt;&gt; columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]&gt;&gt;&gt; obj = pd.DataFrame(data, index, columns)&gt;&gt;&gt; obj           a         b         c         dI1  0.828676 -1.663337  1.753632  1.432487I2  0.368138  0.222166  0.902764 -1.436186I3  2.285615 -2.415175 -1.344456 -0.502214I4  3.224288 -0.500268  1.293596 -1.235549I5 -0.938833 -0.804433 -0.170047 -0.566766&gt;&gt;&gt; &gt;&gt;&gt; obj[0:3]           a         b         c         dI1  0.828676 -1.663337  1.753632  1.432487I2  0.368138  0.222166  0.902764 -1.436186I3  2.285615 -2.415175 -1.344456 -0.502214&gt;&gt;&gt;&gt;&gt;&gt; obj[0:4:2]           a         b         c         dI1 -0.042168  1.437354 -1.114545  0.830790I3  0.241506  0.018984 -0.499151 -1.190143&gt;&gt;&gt;&gt;&gt;&gt; obj[&#39;I2&#39;:&#39;I4&#39;]           a         b         c         dI2  0.368138  0.222166  0.902764 -1.436186I3  2.285615 -2.415175 -1.344456 -0.502214I4  3.224288 -0.500268  1.293596 -1.235549</code></pre><h3 id="【2-2-4】花式索引"><a href="#【2-2-4】花式索引" class="headerlink" title="【2.2.4】花式索引"></a><font color=#FFA500>【2.2.4】花式索引</font></h3><p>和 Series 一样，所谓的花式索引，就是间隔索引、不连续的索引，传递一个由列名（columns）组成的<font color=#FF0000><strong>列表</strong></font>来一次性获得多列元素：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = np.random.randn(5,4)&gt;&gt;&gt; index = [&#39;I1&#39;, &#39;I2&#39;, &#39;I3&#39;, &#39;I4&#39;, &#39;I5&#39;]&gt;&gt;&gt; columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]&gt;&gt;&gt; obj = pd.DataFrame(data, index, columns)&gt;&gt;&gt; obj           a         b         c         dI1 -1.083223 -0.182874 -0.348460 -1.572120I2 -0.205206 -0.251931  1.180131  0.847720I3 -0.980379  0.325553 -0.847566 -0.882343I4 -0.638228 -0.282882 -0.624997 -0.245980I5 -0.229769  1.002930 -0.226715 -0.916591&gt;&gt;&gt; &gt;&gt;&gt; obj[[&#39;a&#39;, &#39;d&#39;]]           a         dI1 -1.083223 -1.572120I2 -0.205206  0.847720I3 -0.980379 -0.882343I4 -0.638228 -0.245980I5 -0.229769 -0.916591</code></pre><h3 id="【2-2-5】布尔索引"><a href="#【2-2-5】布尔索引" class="headerlink" title="【2.2.5】布尔索引"></a><font color=#FFA500>【2.2.5】布尔索引</font></h3><p>可以通过一个布尔数组来索引目标数组，即通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = np.random.randn(5,4)&gt;&gt;&gt; index = [&#39;I1&#39;, &#39;I2&#39;, &#39;I3&#39;, &#39;I4&#39;, &#39;I5&#39;]&gt;&gt;&gt; columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]&gt;&gt;&gt; obj = pd.DataFrame(data, index, columns)&gt;&gt;&gt; obj           a         b         c         dI1 -0.602984 -0.135716  0.999689 -0.339786I2  0.911130 -0.092485 -0.914074 -0.279588I3  0.849606 -0.420055 -1.240389 -0.179297I4  0.249986 -1.250668  0.329416 -1.105774I5 -0.743816  0.430647 -0.058126 -0.337319&gt;&gt;&gt; &gt;&gt;&gt; obj[obj &gt; 0]           a         b         c   dI1       NaN       NaN  0.999689 NaNI2  0.911130       NaN       NaN NaNI3  0.849606       NaN       NaN NaNI4  0.249986       NaN  0.329416 NaNI5       NaN  0.430647       NaN NaN&gt;&gt;&gt; &gt;&gt;&gt; obj &gt; 0        a      b      c      dI1  False  False   True  FalseI2   True  False  False  FalseI3   True  False  False  FalseI4   True  False   True  FalseI5  False   True  False  False</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106698307未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h1 id="【3】索引器：loc-和-iloc"><a href="#【3】索引器：loc-和-iloc" class="headerlink" title="【3】索引器：loc 和 iloc"></a><font color=#FF0000>【3】索引器：loc 和 iloc</font></h1><p>loc 是标签索引、iloc 是位置索引，注意：在 Pandas1.0.0 之前还有 ix 方法（即可按标签也可按位置索引），在 Pandas1.0.0 之后已被移除。</p><h2 id="【3-1】loc-标签索引"><a href="#【3-1】loc-标签索引" class="headerlink" title="【3.1】loc 标签索引"></a><font color=#4876FF>【3.1】loc 标签索引</font></h2><p>loc 标签索引，即根据 index 和 columns 来选择数据。</p><h3 id="【3-1-1】Series-loc"><a href="#【3-1-1】Series-loc" class="headerlink" title="【3.1.1】Series.loc"></a><font color=#FFA500>【3.1.1】Series.loc</font></h3><p>在 Series 中，允许输入：</p><ul><li>单个标签，例如 <code>5</code> 或 <code>&#39;a&#39;</code>，（注意，<code>5</code> 是 index 的名称，而不是位置索引）；</li><li>标签列表或数组，例如 <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>；</li><li>带有标签的切片对象，例如 <code>&#39;a&#39;:&#39;f&#39;</code>。</li></ul><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.loc.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.loc.html</a></p><pre><code class="python">&gt;&gt;&gt; import pandas as np&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obja    1b    5c   -8d    2dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.loc[&#39;a&#39;]1&gt;&gt;&gt; &gt;&gt;&gt; obj.loc[&#39;a&#39;:&#39;c&#39;]a    1b    5c   -8dtype: int64&gt;&gt;&gt;&gt;&gt;&gt; obj.loc[[&#39;a&#39;, &#39;d&#39;]]a    1d    2dtype: int64</code></pre><h3 id="【3-1-2】DataFrame-loc"><a href="#【3-1-2】DataFrame-loc" class="headerlink" title="【3.1.2】DataFrame.loc"></a><font color=#FFA500>【3.1.2】DataFrame.loc</font></h3><p>在 DataFrame 中，第一个参数索引<font color=#FF0000><strong>行</strong></font>，第二个参数是索引<font color=#FF0000><strong>列</strong></font>，允许输入的格式和 Series 大同小异。</p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html</a></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])&gt;&gt;&gt; obj   A  B  Ca  1  2  3b  4  5  6c  7  8  9&gt;&gt;&gt; &gt;&gt;&gt; obj.loc[&#39;a&#39;]A    1B    2C    3Name: a, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.loc[&#39;a&#39;:&#39;c&#39;]   A  B  Ca  1  2  3b  4  5  6c  7  8  9&gt;&gt;&gt; &gt;&gt;&gt; obj.loc[[&#39;a&#39;, &#39;c&#39;]]   A  B  Ca  1  2  3c  7  8  9&gt;&gt;&gt; &gt;&gt;&gt; obj.loc[&#39;b&#39;, &#39;B&#39;]5&gt;&gt;&gt; obj.loc[&#39;b&#39;, &#39;A&#39;:&#39;C&#39;]A    4B    5C    6Name: b, dtype: int64</code></pre><h2 id="【3-2】iloc-位置索引"><a href="#【3-2】iloc-位置索引" class="headerlink" title="【3.2】iloc 位置索引"></a><font color=#4876FF>【3.2】iloc 位置索引</font></h2><p>作用和 loc 一样，不过是基于索引的编号来索引，即根据 index 和 columns 的位置编号来选择数据。</p><h3 id="【3-2-1】Series-iloc"><a href="#【3-2-1】Series-iloc" class="headerlink" title="【3.2.1】Series.iloc"></a><font color=#FFA500>【3.2.1】Series.iloc</font></h3><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.iloc.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.iloc.html</a></p><p>在 Series 中，允许输入：</p><ul><li>整数，例如 <code>5</code>；</li><li>整数列表或数组，例如 <code>[4, 3, 0]</code>；</li><li>具有整数的切片对象，例如 <code>1:7</code>。</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as np&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obja    1b    5c   -8d    2dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.iloc[1]5&gt;&gt;&gt; &gt;&gt;&gt; obj.iloc[0:2]a    1b    5dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.iloc[[0, 1, 3]]a    1b    5d    2dtype: int64</code></pre><h3 id="【3-2-2】DataFrame-iloc"><a href="#【3-2-2】DataFrame-iloc" class="headerlink" title="【3.2.2】DataFrame.iloc"></a><font color=#FFA500>【3.2.2】DataFrame.iloc</font></h3><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html</a></p><p>在 DataFrame 中，第一个参数索引<font color=#FF0000><strong>行</strong></font>，第二个参数是索引<font color=#FF0000><strong>列</strong></font>，允许输入的格式和 Series 大同小异：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])&gt;&gt;&gt; obj   A  B  Ca  1  2  3b  4  5  6c  7  8  9&gt;&gt;&gt; &gt;&gt;&gt; obj.iloc[1]A    4B    5C    6Name: b, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.iloc[0:2]   A  B  Ca  1  2  3b  4  5  6&gt;&gt;&gt; &gt;&gt;&gt; obj.iloc[[0, 2]]   A  B  Ca  1  2  3c  7  8  9&gt;&gt;&gt; &gt;&gt;&gt; obj.iloc[1, 2]6&gt;&gt;&gt; &gt;&gt;&gt; obj.iloc[1, 0:2]A    4B    5Name: b, dtype: int64</code></pre><h1 id="【4】Pandas-重新索引"><a href="#【4】Pandas-重新索引" class="headerlink" title="【4】Pandas 重新索引"></a><font color=#FF0000>【4】Pandas 重新索引</font></h1><p>Pandas 对象的一个重要方法是 reindex，其作用是创建一个新对象，它的数据符合新的索引。以 <code>DataFrame.reindex</code> 为例（Series 类似），基本语法如下：</p><p><code>DataFrame.reindex(self, labels=None, index=None, columns=None, axis=None, method=None, copy=True, level=None, fill_value=nan, limit=None, tolerance=None)</code></p><p>部分参数描述如下：（完整参数解释参见<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.reindex.html">官方文档</a>）</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>index</td><td>用作索引的新序列，既可以是 index 实例，也可以是其他序列型的 Python 数据结构</td></tr><tr><td>method</td><td>插值（填充）方式，取值如下：<br><code>None</code>：不填补空白；<br><code>pad / ffill</code>：将上一个有效的观测值向前传播到下一个有效的观测值；<br><code>backfill / bfill</code>：使用下一个有效观察值来填补空白；<br><code>nearest</code>：使用最近的有效观测值来填补空白。</td></tr><tr><td>fill_value</td><td>在重新索引的过程中，需要引入缺失值时使用的替代值</td></tr><tr><td>limit</td><td>前向或后向填充时的最大填充量</td></tr><tr><td>tolerance</td><td>向前或向后填充时，填充不准确匹配项的最大间距（绝对值距离）</td></tr><tr><td>level</td><td>在 Multilndex 的指定级别上匹配简单索引，否则选其子集</td></tr><tr><td>copy</td><td>默认为 True，无论如何都复制；如果为 False，则新旧相等就不复制</td></tr></tbody></table><p>reindex 将会根据新索引进行重排。如果某个索引值当前不存在，就引入缺失值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([4.5, 7.2, -5.3, 3.6], index=[&#39;d&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;])&gt;&gt;&gt; objd    4.5b    7.2a   -5.3c    3.6dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj2 = obj.reindex([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;])&gt;&gt;&gt; obj2a   -5.3b    7.2c    3.6d    4.5e    NaNdtype: float64</code></pre><p>对于时间序列这样的有序数据，重新索引时可能需要做一些插值处理。method 选项即可达到此目的，例如，使用 ffill 可以实现前向值填充：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([&#39;blue&#39;, &#39;purple&#39;, &#39;yellow&#39;], index=[0, 2, 4])&gt;&gt;&gt; obj0      blue2    purple4    yellowdtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj2 = obj.reindex(range(6), method=&#39;ffill&#39;)&gt;&gt;&gt; obj20      blue1      blue2    purple3    purple4    yellow5    yellowdtype: object</code></pre><p>借助 DataFrame，reindex可以修改（行）索引和列。只传递一个序列时，会重新索引结果的行：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.arange(9).reshape((3, 3)), index=[&#39;a&#39;, &#39;c&#39;, &#39;d&#39;], columns=[&#39;Ohio&#39;, &#39;Texas&#39;, &#39;California&#39;])&gt;&gt;&gt; obj   Ohio  Texas  Californiaa     0      1           2c     3      4           5d     6      7           8&gt;&gt;&gt; &gt;&gt;&gt; obj2 = obj.reindex([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obj2   Ohio  Texas  Californiaa   0.0    1.0         2.0b   NaN    NaN         NaNc   3.0    4.0         5.0d   6.0    7.0         8.0</code></pre><p>列可以用 columns 关键字重新索引：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.arange(9).reshape((3, 3)), index=[&#39;a&#39;, &#39;c&#39;, &#39;d&#39;], columns=[&#39;Ohio&#39;, &#39;Texas&#39;, &#39;California&#39;])&gt;&gt;&gt; obj   Ohio  Texas  Californiaa     0      1           2c     3      4           5d     6      7           8&gt;&gt;&gt; &gt;&gt;&gt; states = [&#39;Texas&#39;, &#39;Utah&#39;, &#39;California&#39;]&gt;&gt;&gt; obj.reindex(columns=states)   Texas  Utah  Californiaa      1   NaN           2c      4   NaN           5d      7   NaN           8</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106698307未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Pandas 系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itbob.cn/article/025/&quot;&gt;Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象&lt;/a&gt;&lt;/li&gt;</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.itbob.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="数据分析" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="Pandas" scheme="https://www.itbob.cn/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</title>
    <link href="https://www.itbob.cn/article/025/"/>
    <id>https://www.itbob.cn/article/025/</id>
    <published>2020-06-11T12:39:54.000Z</published>
    <updated>2022-05-22T12:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106676693未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】了解-Pandas"><a href="#【01x00】了解-Pandas" class="headerlink" title="【01x00】了解 Pandas"></a><font color=#FF0000>【01x00】了解 Pandas</font></h2><p><a href="https://pandas.pydata.org/">Pandas</a> 是 <a href="https://www.python.org/">Python</a> 的一个数据分析包，是基于 <a href="https://numpy.org/">NumPy</a> 构建的，最初由 <a href="https://www.aqr.com/">AQR Capital Management</a> 于 2008 年 4 月开发，并于 2009 年底开源出来，目前由专注于 <a href="https://www.python.org/">Python</a> 数据包开发的 <a href="https://pydata.org/">PyData</a> 开发团队继续开发和维护，属于 <a href="https://pydata.org/">PyData</a> 项目的一部分。</p><p><a href="https://pandas.pydata.org/">Pandas</a> 最初被作为金融数据分析工具而开发出来，因此，<a href="https://pandas.pydata.org/">Pandas</a> 为时间序列分析提供了很好的支持。<font color=#FFA500><strong>Pandas 的名称来自于面板数据（panel data）和 Python 数据分析（data analysis）</strong></font>。panel data 是经济学中关于多维数据集的一个术语，在 <a href="https://pandas.pydata.org/">Pandas</a> 中也提供了 panel 的数据类型。</p><p><a href="https://pandas.pydata.org/">Pandas</a> 经常和其它工具一同使用，如数值计算工具 <a href="https://numpy.org/">NumPy</a> 和 <a href="https://www.scipy.org/">SciPy</a>，分析库 <a href="https://www.statsmodels.org/">statsmodels</a> 和 <a href="https://scikit-learn.org/">scikit-learn</a>，数据可视化库 <a href="https://matplotlib.org/">Matplotlib</a> 等，虽然 <a href="https://pandas.pydata.org/">Pandas</a> 采用了大量的 NumPy 编码风格，但二者最大的不同是 <font color=#FFA500><strong>Pandas 是专门为处理表格和混杂数据设计的。而 NumPy 更适合处理统一的数值数组数据。</strong></font></p><hr><p>【以下对 Pandas 的解释翻译自官方文档：<a href="https://pandas.pydata.org/docs/getting_started/overview.html#package-overview">https://pandas.pydata.org/docs/getting_started/overview.html#package-overview</a>】</p><hr><p>Pandas 是 Python 的核心数据分析支持库，提供了快速、灵活、明确的数据结构，旨在简单、直观地处理关系型、标记型数据。Pandas 的目标是成为 Python 数据分析实践与实战的必备高级工具，其长远目标是成为<strong>最强大、最灵活、可以支持任何语言的开源数据分析工具</strong>。经过多年不懈的努力，Pandas 离这个目标已经越来越近了。</p><p>Pandas 适用于处理以下类型的数据：</p><ul><li>与 SQL 或 Excel 表类似的，含异构列的表格数据;</li><li>有序和无序（非固定频率）的时间序列数据;</li><li>带行列标签的矩阵数据，包括同构或异构型数据;</li><li>任意其它形式的观测、统计数据集, 数据转入 Pandas 数据结构时不必事先标记。</li></ul><p>Pandas 的主要数据结构是 <a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.html#pandas.Series">Series</a>（一维数据）与 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html#pandas.DataFrame">DataFrame</a>（二维数据），这两种数据结构足以处理- 金融、统计、社会科学、工程等领域里的大多数典型用例。对于 R 语言用户，<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html#pandas.DataFrame">DataFrame</a> 提供了比 R 语言 <code>data.frame</code> 更丰富的功能。Pandas 基于 <a href="https://www.numpy.org/">NumPy</a> 开发，可以与其它第三方科学计算支持库完美集成。</p><p>Pandas 就像一把万能瑞士军刀，下面仅列出了它的部分优势 ：</p><ul><li>处理浮点与非浮点数据里的<strong>缺失数据</strong>，表示为 NaN；</li><li>大小可变：<strong>插入或删除</strong> DataFrame 等多维对象的列；</li><li>自动、显式<strong>数据对齐</strong>：显式地将对象与一组标签对齐，也可以忽略标签，在 Series、DataFrame 计算时自动与数据对齐；</li><li>强大、灵活的<strong>分组</strong>（group by）功能：<strong>拆分-应用-组合</strong>数据集，聚合、转换数据；</li><li>把 Python 和 NumPy 数据结构里不规则、不同索引的数据<strong>轻松地转换</strong>为 DataFrame 对象；</li><li>基于智能标签，对大型数据集进行<strong>切片、花式索引、子集分解</strong>等操作；</li><li>直观地<strong>合并</strong>和<strong>连接</strong>数据集；</li><li>灵活地<strong>重塑</strong>和<strong>旋转</strong>数据集；</li><li>轴支持<strong>分层</strong>标签（每个刻度可能有多个标签）；</li><li>强大的 IO 工具，读取平面文件（CSV 等支持分隔符的文件）、Excel 文件、数据库等来源的数据，以及从超快 <strong>HDF5 格式</strong>保存 / 加载数据；</li><li><strong>时间序列</strong>：支持日期范围生成、频率转换、移动窗口统计、移动窗口线性回归、日期位移等时间序列功能。</li></ul><p>这些功能主要是为了解决其它编程语言、科研环境的痛点。处理数据一般分为几个阶段：数据整理与清洗、数据分析与建模、数据可视化与制表，Pandas 是处理数据的理想工具。</p><p>其它说明：</p><ul><li>Pandas 速度很快。Pandas 的很多底层算法都用 <a href="https://cython.org/">Cython</a> 优化过。然而，为了保持通用性，必然要牺牲一些性能，如果专注某一功能，完全可以开发出比 Pandas 更快的专用工具。</li><li>Pandas 是 <a href="https://www.statsmodels.org/stable/index.html">statsmodels</a> 的依赖项，因此，Pandas 也是 Python 中统计计算生态系统的重要组成部分。</li><li>Pandas 已广泛应用于金融领域。</li></ul><h2 id="【02x00】Pandas-数据结构"><a href="#【02x00】Pandas-数据结构" class="headerlink" title="【02x00】Pandas 数据结构"></a><font color=#FF0000>【02x00】Pandas 数据结构</font></h2><p>Pandas 的主要数据结构是 <a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.html#pandas.Series">Series</a>（带标签的一维同构数组）与 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html#pandas.DataFrame">DataFrame</a>（带标签的，大小可变的二维异构表格）。</p><p>Pandas 数据结构就像是低维数据的容器。比如，DataFrame 是 Series 的容器，Series 则是标量的容器。使用这种方式，可以在容器中以字典的形式插入或删除对象。</p><p>此外，通用 API 函数的默认操作要顾及时间序列与截面数据集的方向。当使用 Ndarray 存储二维或三维数据时，编写函数要注意数据集的方向，这对用户来说是一种负担；如果不考虑 C 或 Fortran 中连续性对性能的影响，一般情况下，不同的轴在程序里其实没有什么区别。Pandas 里，轴的概念主要是为了给数据赋予更直观的语义，即用更恰当的方式表示数据集的方向。这样做可以让用户编写数据转换函数时，少费点脑子。</p><p>处理 DataFrame 等表格数据时，对比 Numpy，<strong>index</strong>（行）或 <strong>columns</strong>（列）比 <strong>axis 0</strong> 和 <strong>axis 1</strong> 更直观。用这种方式迭代 DataFrame 的列，代码更易读易懂：</p><pre><code class="python">for col in df.columns:    series = df[col]    # do something with series</code></pre><h2 id="【03x00】Series-对象"><a href="#【03x00】Series-对象" class="headerlink" title="【03x00】Series 对象"></a><font color=#FF0000>【03x00】Series 对象</font></h2><p>Series 是带标签的一维数组，可存储整数、浮点数、字符串、Python 对象等类型的数据。轴标签统称为索引。调用 pandas.Series 函数即可创建 Series，基本语法如下：</p><p><code>pandas.Series(data=None[, index=None, dtype=None, name=None, copy=False, fastpath=False])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>data</td><td>数组类型，可迭代的，字典或标量值，存储在序列中的数据</td></tr><tr><td>index</td><td>索引（数据标签），值必须是可哈希的，并且具有与数据相同的长度，<br>允许使用非唯一索引值。如果未提供，将默认为RangeIndex（0，1，2，…，n）</td></tr><tr><td>dtype</td><td>输出系列的数据类型。可选项，如果未指定，则将从数据中推断，具体参考官网 <a href="https://pandas.pydata.org/docs/getting_started/basics.html#dtypes">dtypes</a> 介绍</td></tr><tr><td>name</td><td>str 类型，可选项，给 Series 命名</td></tr><tr><td>copy</td><td>bool 类型，可选项，默认 False，是否复制输入数据</td></tr></tbody></table><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A79/01.png" alt="01"></p><h3 id="【03x01】通过-list-构建-Series"><a href="#【03x01】通过-list-构建-Series" class="headerlink" title="【03x01】通过 list 构建 Series"></a><font color=#4876FF>【03x01】通过 list 构建 Series</font></h3><p>一般情况下我们只会用到 data 和 index 参数，可以通过 list（列表） 构建 Series，示例如下：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2])&gt;&gt;&gt; obj0    11    52   -83    2dtype: int64</code></pre><p>由于我们没有为数据指定索引，于是会自动创建一个 0 到 N-1（N 为数据的长度）的整数型索引，左边一列是自动创建的索引（index），右边一列是数据（data）。</p><p>此外，还可以自定义索引（index）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obja    1b    5c   -8d    2dtype: int64</code></pre><p>索引（index）也可以通过赋值的方式就地修改：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obja    1b    5c   -8d    2dtype: int64&gt;&gt;&gt; obj.index = [&#39;Bob&#39;, &#39;Steve&#39;, &#39;Jeff&#39;, &#39;Ryan&#39;]&gt;&gt;&gt; objBob      1Steve    5Jeff    -8Ryan     2dtype: int64</code></pre><h3 id="【03x02】通过-dict-构建-Series"><a href="#【03x02】通过-dict-构建-Series" class="headerlink" title="【03x02】通过 dict 构建 Series"></a><font color=#4876FF>【03x02】通过 dict 构建 Series</font></h3><p>通过 字典（dict） 构建 Series，字典的键（key）会作为索引（index），字典的值（value）会作为数据（data），示例如下：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;Beijing&#39;: 21530000, &#39;Shanghai&#39;: 24280000, &#39;Wuhan&#39;: 11210000, &#39;Zhejiang&#39;: 58500000&#125;&gt;&gt;&gt; obj = pd.Series(data)&gt;&gt;&gt; objBeijing     21530000Shanghai    24280000Wuhan       11210000Zhejiang    58500000dtype: int64</code></pre><p>如果你想按照某个特定的顺序输出结果，可以传入排好序的字典的键以改变顺序：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;Beijing&#39;: 21530000, &#39;Shanghai&#39;: 24280000, &#39;Wuhan&#39;: 11210000, &#39;Zhejiang&#39;: 58500000&#125;&gt;&gt;&gt; cities = [&#39;Guangzhou&#39;, &#39;Wuhan&#39;, &#39;Zhejiang&#39;, &#39;Shanghai&#39;]&gt;&gt;&gt; obj = pd.Series(data, index=cities)&gt;&gt;&gt; objGuangzhou           NaNWuhan        11210000.0Zhejiang     58500000.0Shanghai     24280000.0dtype: float64</code></pre><p><font color=#FF0000><strong>注意：data 为字典，且未设置 index 参数时：</strong></font></p><ul><li><font color=#FF0000><strong>如果 Python &gt;= 3.6 且 Pandas &gt;= 0.23，Series 按字典的插入顺序排序索引。</strong></font></li><li><font color=#FF0000>**如果 Python &lt; 3.6 或 Pandas &lt; 0.23，Series 按字母顺序排序索引。**</font></li></ul><h3 id="【03x03】获取其数据和索引"><a href="#【03x03】获取其数据和索引" class="headerlink" title="【03x03】获取其数据和索引"></a><font color=#4876FF>【03x03】获取其数据和索引</font></h3><p>我们可以通过 Series 的 values 和 index 属性获取其数据和索引对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obj.valuesarray([ 1,  5, -8,  2], dtype=int64)&gt;&gt;&gt; obj.indexIndex([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=&#39;object&#39;)</code></pre><h3 id="【03x04】通过索引获取数据"><a href="#【03x04】通过索引获取数据" class="headerlink" title="【03x04】通过索引获取数据"></a><font color=#4876FF>【03x04】通过索引获取数据</font></h3><p>与普通 NumPy 数组相比，Pandas 可以通过索引的方式选取 Series 中的单个或一组值，获取一组值时，传入的是一个列表，列表中的元素是索引值，另外还可以通过索引来修改其对应的值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obja    1b    5c   -8d    2dtype: int64&gt;&gt;&gt; obj[&#39;a&#39;]1&gt;&gt;&gt; obj[&#39;a&#39;] = 3&gt;&gt;&gt; obj[[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]]a    3b    5c   -8dtype: int64</code></pre><h3 id="【03x05】使用函数运算"><a href="#【03x05】使用函数运算" class="headerlink" title="【03x05】使用函数运算"></a><font color=#4876FF>【03x05】使用函数运算</font></h3><p>在 Pandas 中可以使用 NumPy 函数或类似 NumPy 的运算（如根据布尔型数组进行过滤、标量乘法、应用数学函数等）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obj[obj &gt; 0]a    1b    5d    2dtype: int64&gt;&gt;&gt; obj * 2a     2b    10c   -16d     4dtype: int64&gt;&gt;&gt; np.exp(obj)a      2.718282b    148.413159c      0.000335d      7.389056dtype: float64</code></pre><p>除了这些运算函数以外，还可以将 Series 看成是一个定长的有序字典，因为它是索引值到数据值的一个映射。它可以用在许多原本需要字典参数的函数中：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; &#39;a&#39; in objTrue&gt;&gt;&gt; &#39;e&#39; in objFalse</code></pre><p>和 NumPy 类似，Pandas 中也有 NaN（即非数字，not a number），在 Pandas 中，它用于表示缺失值，Pandas 的 isnull 和 notnull 函数可用于检测缺失数据：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series([np.NaN, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obja    NaNb    5.0c   -8.0d    2.0dtype: float64&gt;&gt;&gt; pd.isnull(obj)a     Trueb    Falsec    Falsed    Falsedtype: bool&gt;&gt;&gt; pd.notnull(obj)a    Falseb     Truec     Trued     Truedtype: bool&gt;&gt;&gt; obj.isnull()a     Trueb    Falsec    Falsed    Falsedtype: bool&gt;&gt;&gt; obj.notnull()a    Falseb     Truec     Trued     Truedtype: bool</code></pre><h3 id="【03x06】name-属性"><a href="#【03x06】name-属性" class="headerlink" title="【03x06】name 属性"></a><font color=##4876FF>【03x06】name 属性</font></h3><p>可以在 <code>pandas.Series</code> 方法中为 Series 对象指定一个 name：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;Beijing&#39;: 21530000, &#39;Shanghai&#39;: 24280000, &#39;Wuhan&#39;: 11210000, &#39;Zhejiang&#39;: 58500000&#125;&gt;&gt;&gt; obj = pd.Series(data, name=&#39;population&#39;)&gt;&gt;&gt; objBeijing     21530000Shanghai    24280000Wuhan       11210000Zhejiang    58500000Name: population, dtype: int64</code></pre><p>也可以通过 name 和 index.name 属性为 Series 对象和其索引指定 name：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;Beijing&#39;: 21530000, &#39;Shanghai&#39;: 24280000, &#39;Wuhan&#39;: 11210000, &#39;Zhejiang&#39;: 58500000&#125;&gt;&gt;&gt; obj = pd.Series(data)&gt;&gt;&gt; obj.name = &#39;population&#39;&gt;&gt;&gt; obj.index.name = &#39;cities&#39;&gt;&gt;&gt; objcitiesBeijing     21530000Shanghai    24280000Wuhan       11210000Zhejiang    58500000Name: population, dtype: int64</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106676693未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【04x00】DataFrame-对象"><a href="#【04x00】DataFrame-对象" class="headerlink" title="【04x00】DataFrame 对象"></a><font color=#FF0000>【04x00】DataFrame 对象</font></h2><p>DataFrame 是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）。DataFrame 既有行索引也有列索引，它可以被看做由 Series 组成的字典（共用同一个索引）。DataFrame 中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）。</p><ul><li>类似多维数组/表格数据 (如Excel、R 语言中的 data.frame)；</li><li>每列数据可以是不同的类型；</li><li>索引包括列索引和行索引</li></ul><p>基本语法如下：</p><p><code>pandas.DataFrame(data=None, index: Optional[Collection] = None, columns: Optional[Collection] = None, dtype: Union[str, numpy.dtype, ExtensionDtype, None] = None, copy: bool = False)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>data</td><td>ndarray 对象（结构化或同类的）、可迭代的或者字典形式，存储在序列中的数据</td></tr><tr><td>index</td><td>数组类型，索引（数据标签），如果未提供，将默认为 RangeIndex（0，1，2，…，n）</td></tr><tr><td>columns</td><td>列标签。如果未提供，则将默认为 RangeIndex（0、1、2、…、n）</td></tr><tr><td>dtype</td><td>输出系列的数据类型。可选项，如果未指定，则将从数据中推断，具体参考官网 <a href="https://pandas.pydata.org/docs/getting_started/basics.html#dtypes">dtypes</a> 介绍</td></tr><tr><td>copy</td><td>bool 类型，可选项，默认 False，是否复制输入数据，仅影响 DataFrame/2d ndarray 输入</td></tr></tbody></table><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A79/02.png" alt="02"></p><h3 id="【03x01】通过-ndarray-构建-DataFrame"><a href="#【03x01】通过-ndarray-构建-DataFrame" class="headerlink" title="【03x01】通过 ndarray 构建 DataFrame"></a><font color=#4876FF>【03x01】通过 ndarray 构建 DataFrame</font></h3><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = np.random.randn(5,3)&gt;&gt;&gt; dataarray([[-2.16231157,  0.44967198, -0.73131523],       [ 1.18982913,  0.94670798,  0.82973421],       [-1.57680831, -0.99732066,  0.96432   ],       [-0.77483149, -1.23802881,  0.44061227],       [ 1.77666419,  0.24931983, -1.12960153]])&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj          0         1         20 -2.162312  0.449672 -0.7313151  1.189829  0.946708  0.8297342 -1.576808 -0.997321  0.9643203 -0.774831 -1.238029  0.4406124  1.776664  0.249320 -1.129602</code></pre><p>指定索引（index）和列标签（columns），和 Series 对象类似，可以在构建的时候添加索引和标签，也可以直接通过赋值的方式就地修改：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = np.random.randn(5,3)&gt;&gt;&gt; index = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]&gt;&gt;&gt; columns = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]&gt;&gt;&gt; obj = pd.DataFrame(data, index, columns)&gt;&gt;&gt; obj          A         B         Ca -1.042909 -0.238236 -1.050308b  0.587079  0.739683 -0.233624c -0.451254 -0.638496  1.708807d -0.620158 -1.875929 -0.432382e -1.093815  0.396965 -0.759479&gt;&gt;&gt;&gt;&gt;&gt; obj.index = [&#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;, &#39;A4&#39;, &#39;A5&#39;]&gt;&gt;&gt; obj.columns = [&#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;]&gt;&gt;&gt; obj          B1        B2        B3A1 -1.042909 -0.238236 -1.050308A2  0.587079  0.739683 -0.233624A3 -0.451254 -0.638496  1.708807A4 -0.620158 -1.875929 -0.432382A5 -1.093815  0.396965 -0.759479</code></pre><h3 id="【03x02】通过-dict-构建-DataFrame"><a href="#【03x02】通过-dict-构建-DataFrame" class="headerlink" title="【03x02】通过 dict 构建 DataFrame"></a><font color=#4876FF>【03x02】通过 dict 构建 DataFrame</font></h3><p>通过 字典（dict） 构建 DataFrame，字典的键（key）会作为列标签（columns），字典的值（value）会作为数据（data），示例如下：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;city&#39;: [&#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;],        &#39;year&#39;: [2017, 2018, 2019, 2017, 2018, 2019],        &#39;people&#39;: [10892900, 11081000, 11212000, 21707000, 21542000, 21536000]&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj      city  year    people0    Wuhan  2017  108929001    Wuhan  2018  110810002    Wuhan  2019  112120003  Beijing  2017  217070004  Beijing  2018  215420005  Beijing  2019  21536000</code></pre><p>如果指定了列序列，则 DataFrame 的列就会按照指定顺序进行排列，如果传入的列在数据中找不到，就会在结果中产生缺失值（NaN）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;city&#39;: [&#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;],        &#39;year&#39;: [2017, 2018, 2019, 2017, 2018, 2019],        &#39;people&#39;: [10892900, 11081000, 11212000, 21707000, 21542000, 21536000]&#125;&gt;&gt;&gt; pd.DataFrame(data)      city  year    people0    Wuhan  2017  108929001    Wuhan  2018  110810002    Wuhan  2019  112120003  Beijing  2017  217070004  Beijing  2018  215420005  Beijing  2019  21536000&gt;&gt;&gt; pd.DataFrame(data, columns=[&#39;year&#39;, &#39;city&#39;, &#39;people&#39;])   year     city    people0  2017    Wuhan  108929001  2018    Wuhan  110810002  2019    Wuhan  112120003  2017  Beijing  217070004  2018  Beijing  215420005  2019  Beijing  21536000&gt;&gt;&gt; pd.DataFrame(data, columns=[&#39;year&#39;, &#39;city&#39;, &#39;people&#39;, &#39;money&#39;])   year     city    people money0  2017    Wuhan  10892900   NaN1  2018    Wuhan  11081000   NaN2  2019    Wuhan  11212000   NaN3  2017  Beijing  21707000   NaN4  2018  Beijing  21542000   NaN5  2019  Beijing  21536000   NaN</code></pre><p><font color=#FF0000><strong>注意：data 为字典，且未设置 columns 参数时：</strong></font></p><ul><li><p><font color=#FF0000><strong>Python &gt; = 3.6 且 Pandas &gt; = 0.23，DataFrame 的列按字典的插入顺序排序。</strong></font></p></li><li><p><font color=#FF0000>**Python &lt; 3.6 或 Pandas &lt; 0.23，DataFrame 的列按字典键的字母排序。**</font></p></li></ul><h3 id="【03x03】获取其数据和索引-1"><a href="#【03x03】获取其数据和索引-1" class="headerlink" title="【03x03】获取其数据和索引"></a><font color=#4876FF>【03x03】获取其数据和索引</font></h3><p>和 Series 一样，DataFrame 也可以通过其 values 和 index 属性获取其数据和索引对象：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;city&#39;: [&#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;],    &#39;year&#39;: [2017, 2018, 2019, 2017, 2018, 2019],        &#39;people&#39;: [10892900, 11081000, 11212000, 21707000, 21542000, 21536000]&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj.indexRangeIndex(start=0, stop=6, step=1)&gt;&gt;&gt; obj.valuesarray([[&#39;Wuhan&#39;, 2017, 10892900],       [&#39;Wuhan&#39;, 2018, 11081000],       [&#39;Wuhan&#39;, 2019, 11212000],       [&#39;Beijing&#39;, 2017, 21707000],       [&#39;Beijing&#39;, 2018, 21542000],       [&#39;Beijing&#39;, 2019, 21536000]], dtype=object)</code></pre><h3 id="【03x04】通过索引获取数据-1"><a href="#【03x04】通过索引获取数据-1" class="headerlink" title="【03x04】通过索引获取数据"></a><font color=#4876FF>【03x04】通过索引获取数据</font></h3><p>通过类似字典标记的方式或属性的方式，可以将 DataFrame 的列获取为一个 Series 对象；</p><p>行也可以通过位置或名称的方式进行获取，比如用 loc 属性；</p><p>对于特别大的 DataFrame，有一个 head 方法可以选取前五行数据。</p><p>用法示例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;city&#39;: [&#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;],    &#39;year&#39;: [2017, 2018, 2019, 2017, 2018, 2019],        &#39;people&#39;: [10892900, 11081000, 11212000, 21707000, 21542000, 21536000]&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj      city  year    people0    Wuhan  2017  108929001    Wuhan  2018  110810002    Wuhan  2019  112120003  Beijing  2017  217070004  Beijing  2018  215420005  Beijing  2019  21536000&gt;&gt;&gt;&gt;&gt;&gt; obj[&#39;city&#39;]0      Wuhan1      Wuhan2      Wuhan3    Beijing4    Beijing5    BeijingName: city, dtype: object&gt;&gt;&gt;&gt;&gt;&gt; obj.year0    20171    20182    20193    20174    20185    2019Name: year, dtype: int64&gt;&gt;&gt;&gt;&gt;&gt; type(obj.year)&lt;class &#39;pandas.core.series.Series&#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt; obj.loc[2]city         Wuhanyear          2019people    11212000Name: 2, dtype: object&gt;&gt;&gt;&gt;&gt;&gt; obj.head()      city  year    people0    Wuhan  2017  108929001    Wuhan  2018  110810002    Wuhan  2019  112120003  Beijing  2017  217070004  Beijing  2018  21542000</code></pre><h3 id="【03x05】修改列的值"><a href="#【03x05】修改列的值" class="headerlink" title="【03x05】修改列的值"></a><font color=#4876FF>【03x05】修改列的值</font></h3><p>列可以通过赋值的方式进行修改。在下面示例中，分别给”money”列赋上一个标量值和一组值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = &#123;&#39;city&#39;: [&#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;],        &#39;year&#39;: [2017, 2018, 2019, 2017, 2018, 2019],        &#39;people&#39;: [10892900, 11081000, 11212000, 21707000, 21542000, 21536000],        &#39;money&#39;:[np.NaN, np.NaN, np.NaN, np.NaN, np.NaN, np.NaN]&#125;&gt;&gt;&gt; obj = pd.DataFrame(data, index=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;])&gt;&gt;&gt; obj      city  year    people  moneyA    Wuhan  2017  10892900    NaNB    Wuhan  2018  11081000    NaNC    Wuhan  2019  11212000    NaND  Beijing  2017  21707000    NaNE  Beijing  2018  21542000    NaNF  Beijing  2019  21536000    NaN&gt;&gt;&gt;&gt;&gt;&gt; obj[&#39;money&#39;] = 6666666666&gt;&gt;&gt; obj      city  year    people       moneyA    Wuhan  2017  10892900  6666666666B    Wuhan  2018  11081000  6666666666C    Wuhan  2019  11212000  6666666666D  Beijing  2017  21707000  6666666666E  Beijing  2018  21542000  6666666666F  Beijing  2019  21536000  6666666666&gt;&gt;&gt;&gt;&gt;&gt; obj[&#39;money&#39;] = np.arange(100000000, 700000000, 100000000)&gt;&gt;&gt; obj      city  year    people      moneyA    Wuhan  2017  10892900  100000000B    Wuhan  2018  11081000  200000000C    Wuhan  2019  11212000  300000000D  Beijing  2017  21707000  400000000E  Beijing  2018  21542000  500000000F  Beijing  2019  21536000  600000000</code></pre><p>将列表或数组赋值给某个列时，其长度必须跟 DataFrame 的长度相匹配。如果赋值的是一个 Series，就会精确匹配 DataFrame 的索引：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = &#123;&#39;city&#39;: [&#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;],        &#39;year&#39;: [2017, 2018, 2019, 2017, 2018, 2019],        &#39;people&#39;: [10892900, 11081000, 11212000, 21707000, 21542000, 21536000],        &#39;money&#39;:[np.NaN, np.NaN, np.NaN, np.NaN, np.NaN, np.NaN]&#125;&gt;&gt;&gt; obj = pd.DataFrame(data, index=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;])&gt;&gt;&gt; obj      city  year    people  moneyA    Wuhan  2017  10892900    NaNB    Wuhan  2018  11081000    NaNC    Wuhan  2019  11212000    NaND  Beijing  2017  21707000    NaNE  Beijing  2018  21542000    NaNF  Beijing  2019  21536000    NaN&gt;&gt;&gt; &gt;&gt;&gt; new_data = pd.Series([5670000000, 6890000000, 7890000000], index=[&#39;A&#39;, &#39;C&#39;, &#39;E&#39;])&gt;&gt;&gt; obj[&#39;money&#39;] = new_data&gt;&gt;&gt; obj      city  year    people         moneyA    Wuhan  2017  10892900  5.670000e+09B    Wuhan  2018  11081000           NaNC    Wuhan  2019  11212000  6.890000e+09D  Beijing  2017  21707000           NaNE  Beijing  2018  21542000  7.890000e+09F  Beijing  2019  21536000           NaN</code></pre><h3 id="【03x06】增加-删除列"><a href="#【03x06】增加-删除列" class="headerlink" title="【03x06】增加 / 删除列"></a><font color=#4876FF>【03x06】增加 / 删除列</font></h3><p>为不存在的列赋值会创建出一个新列，关键字 del 用于删除列：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;city&#39;: [&#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;],    &#39;year&#39;: [2017, 2018, 2019, 2017, 2018, 2019],        &#39;people&#39;: [10892900, 11081000, 11212000, 21707000, 21542000, 21536000]&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj      city  year    people0    Wuhan  2017  108929001    Wuhan  2018  110810002    Wuhan  2019  112120003  Beijing  2017  217070004  Beijing  2018  215420005  Beijing  2019  21536000&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;northern&#39;] = obj[&#39;city&#39;] == &#39;Beijing&#39;&gt;&gt;&gt; obj      city  year    people  northern0    Wuhan  2017  10892900     False1    Wuhan  2018  11081000     False2    Wuhan  2019  11212000     False3  Beijing  2017  21707000      True4  Beijing  2018  21542000      True5  Beijing  2019  21536000      True&gt;&gt;&gt; &gt;&gt;&gt; del obj[&#39;northern&#39;]&gt;&gt;&gt; obj      city  year    people0    Wuhan  2017  108929001    Wuhan  2018  110810002    Wuhan  2019  112120003  Beijing  2017  217070004  Beijing  2018  215420005  Beijing  2019  21536000</code></pre><h3 id="【03x07】name-属性"><a href="#【03x07】name-属性" class="headerlink" title="【03x07】name 属性"></a><font color=##4876FF>【03x07】name 属性</font></h3><p>可以通过 index.name 和 columns.name 属性设置索引（index）和列标签（columns）的 name，注意 DataFrame 对象是没有 name 属性的：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;city&#39;: [&#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;],        &#39;year&#39;: [2017, 2018, 2019, 2017, 2018, 2019],        &#39;people&#39;: [10892900, 11081000, 11212000, 21707000, 21542000, 21536000]&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj.index.name = &#39;index&#39;&gt;&gt;&gt; obj.columns.name = &#39;columns&#39;&gt;&gt;&gt; objcolumns     city  year    peopleindex                           0          Wuhan  2017  108929001          Wuhan  2018  110810002          Wuhan  2019  112120003        Beijing  2017  217070004        Beijing  2018  215420005        Beijing  2019  21536000</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106676693未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Pandas 系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itbob.cn/article/025/&quot;&gt;Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象&lt;/a&gt;&lt;/li&gt;</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.itbob.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="数据分析" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="Pandas" scheme="https://www.itbob.cn/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据分析三剑客之 Matplotlib（十一）：最常用最有价值的 50 个图表【译文】</title>
    <link href="https://www.itbob.cn/article/024/"/>
    <id>https://www.itbob.cn/article/024/</id>
    <published>2020-06-09T08:13:49.000Z</published>
    <updated>2022-05-22T12:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Matplotlib 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/014/">Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</a></li><li><a href="https://www.itbob.cn/article/015/">Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/016/">Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/017/">Python 数据分析三剑客之 Matplotlib（四）：线性图的绘制</a></li><li><a href="https://www.itbob.cn/article/018/">Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制</a></li><li><a href="https://www.itbob.cn/article/019/">Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制</a></li><li><a href="https://www.itbob.cn/article/020/">Python 数据分析三剑客之 Matplotlib（七）：饼状图的绘制</a></li><li><a href="https://www.itbob.cn/article/021/">Python 数据分析三剑客之 Matplotlib（八）：等高线 / 等值线图的绘制</a></li><li><a href="https://www.itbob.cn/article/022/">Python 数据分析三剑客之 Matplotlib（九）：极区图 / 极坐标图 / 雷达图的绘制</a></li><li><a href="https://www.itbob.cn/article/023/">Python 数据分析三剑客之 Matplotlib（十）：3D 图的绘制</a></li><li><a href="https://www.itbob.cn/article/024/">Python 数据分析三剑客之 Matplotlib（十一）：最热门最常用的 50 个图表</a>【译文】</li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><blockquote><p>翻译丨<a href="https://itrhx.blog.csdn.net/">TRHX</a><br>作者丨<a href="https://www.machinelearningplus.com/author/selva86/">Selva Prabhakaran</a><br>原文丨<a href="https://www.machinelearningplus.com/plots/top-50-matplotlib-visualizations-the-master-plots-python/">《Top 50 matplotlib Visualizations – The Master Plots (with full python code)》</a></p></blockquote><hr><blockquote><p>★ 本文中的示例原作者使用的编辑器为 Jupyter Notebook；<br>★ 译者使用 PyCharm 测试原文中有部分代码不太准确，部分已进行修改，对应有注释说明；<br>★ 运行本文代码，需要安装 Matplotlib 和 Seaborn 等可视化库，其他的一些辅助可视化库已在代码部分作标注；<br>★ 示例中用到的数据均储存在作者的 GitHub：<a href="https://github.com/selva86/datasets">https://github.com/selva86/datasets</a>，因此运行程序可能需要FQ；<br>★ 译者英文水平有限，若遇到翻译模糊的词建议参考原文来理解。<br>★ 本文50个示例代码已打包为 .py 文件，可直接下载：<a href="https://download.csdn.net/download/qq_36759224/12507219">https://download.csdn.net/download/qq_36759224/12507219</a></p></blockquote><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本译文首发于 CSDN，作者 Selva Prabhakaran，译者 TRHX。本文链接：https://itrhx.blog.csdn.net/article/details/106558131原文链接：https://www.machinelearningplus.com/plots/top-50-matplotlib-visualizations-the-master-plots-python/</code></pre><hr><h2 id="【1x00】介绍（Introduction）"><a href="#【1x00】介绍（Introduction）" class="headerlink" title="【1x00】介绍（Introduction）"></a><font color=#FF0000>【1x00】介绍（Introduction）</font></h2><p>在数据分析和可视化中最常用的、最有价值的前 50 个 Matplotlib 图表。这些图表会让你懂得在不同情况下合理使用 Python 的 Matplotlib 和 Seaborn 库来达到数据可视化效果。</p><p>这些图表根据可视化目标的 7 个不同情景进行分组。 例如，如果要想象两个变量之间的关系，请查看“关联”部分下的图表。 或者，如果您想要显示值如何随时间变化，请查看“变化”部分，依此类推。</p><p>有效图表的重要特征：</p><ul><li>在不歪曲事实的情况下传达正确和必要的信息；</li><li>设计简单，不必太费力就能理解它；</li><li>从审美角度支持信息而不是掩盖信息；</li><li>信息没有超负荷。</li></ul><h2 id="【2x00】准备工作（Setup）"><a href="#【2x00】准备工作（Setup）" class="headerlink" title="【2x00】准备工作（Setup）"></a><font color=#FF0000>【2x00】准备工作（Setup）</font></h2><p>在代码运行前先引入下面的基本设置，当然，个别图表可能会重新定义显示要素。</p><pre><code class="python"># !pip install brewer2mplimport numpy as npimport pandas as pdimport matplotlib as mplimport matplotlib.pyplot as pltimport seaborn as snsimport warnings; warnings.filterwarnings(action=&#39;once&#39;)large = 22; med = 16; small = 12params = &#123;&#39;axes.titlesize&#39;: large,          &#39;legend.fontsize&#39;: med,          &#39;figure.figsize&#39;: (16, 10),          &#39;axes.labelsize&#39;: med,          &#39;axes.titlesize&#39;: med,          &#39;xtick.labelsize&#39;: med,          &#39;ytick.labelsize&#39;: med,          &#39;figure.titlesize&#39;: large&#125;plt.rcParams.update(params)plt.style.use(&#39;seaborn-whitegrid&#39;)sns.set_style(&quot;white&quot;)%matplotlib inline# Versionprint(mpl.__version__)  #&gt; 3.0.0print(sns.__version__)  #&gt; 0.9.0</code></pre><h2 id="【3x00】关联（Correlation）"><a href="#【3x00】关联（Correlation）" class="headerlink" title="【3x00】关联（Correlation） "></a><font color=#FF0000>【3x00】关联（Correlation） </font></h2><p>关联图用于可视化两个或多个变量之间的关系。也就是说，一个变量相对于另一个变量如何变化。</p><h3 id="【01】散点图（Scatter-plot）"><a href="#【01】散点图（Scatter-plot）" class="headerlink" title="【01】散点图（Scatter plot）"></a><font color=##4876FF>【01】散点图（Scatter plot）</font></h3><p>散点图是研究两个变量之间关系的经典和基本的绘图。如果数据中有多个组，则可能需要以不同的颜色显示每个组。在 Matplotlib 中，您可以使用 <code>plt.scatterplot()</code> 方便地执行此操作。</p><pre><code class="python"># Import dataset midwest = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/midwest_filter.csv&quot;)# Prepare Data # Create as many colors as there are unique midwest[&#39;category&#39;]categories = np.unique(midwest[&#39;category&#39;])colors = [plt.cm.tab10(i/float(len(categories)-1)) for i in range(len(categories))]# Draw Plot for Each Categoryplt.figure(figsize=(16, 10), dpi= 80, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)for i, category in enumerate(categories):    plt.scatter(&#39;area&#39;, &#39;poptotal&#39;,                data=midwest.loc[midwest.category==category, :],                s=20, cmap=colors[i], label=str(category))# 原文 c=colors[i] 已修改为 cmap=colors[i]# Decorationsplt.gca().set(xlim=(0.0, 0.1), ylim=(0, 90000),              xlabel=&#39;Area&#39;, ylabel=&#39;Population&#39;)plt.xticks(fontsize=12); plt.yticks(fontsize=12)plt.title(&quot;Scatterplot of Midwest Area vs Population&quot;, fontsize=22)plt.legend(fontsize=12)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/01.png" alt="01"></p><h3 id="【02】带边界的气泡图（Bubble-plot-with-Encircling）"><a href="#【02】带边界的气泡图（Bubble-plot-with-Encircling）" class="headerlink" title="【02】带边界的气泡图（Bubble plot with Encircling）"></a><font color=##4876FF>【02】带边界的气泡图（Bubble plot with Encircling）</font></h3><p>有时候您想在一个边界内显示一组点来强调它们的重要性。在本例中，您将从被包围的数据中获取记录，并将其传递给下面的代码中描述的 <code>encircle()</code>。</p><pre><code class="python">from matplotlib import patchesfrom scipy.spatial import ConvexHullimport warnings; warnings.simplefilter(&#39;ignore&#39;)sns.set_style(&quot;white&quot;)# Step 1: Prepare Datamidwest = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/midwest_filter.csv&quot;)# As many colors as there are unique midwest[&#39;category&#39;]categories = np.unique(midwest[&#39;category&#39;])colors = [plt.cm.tab10(i/float(len(categories)-1)) for i in range(len(categories))]# Step 2: Draw Scatterplot with unique color for each categoryfig = plt.figure(figsize=(16, 10), dpi=80, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)for i, category in enumerate(categories):    plt.scatter(&#39;area&#39;, &#39;poptotal&#39;, data=midwest.loc[midwest.category == category, :], s=&#39;dot_size&#39;, cmap=colors[i], label=str(category), edgecolors=&#39;black&#39;, linewidths=.5)# 原文 c=colors[i] 已修改为 cmap=colors[i]# Step 3: Encircling# https://stackoverflow.com/questions/44575681/how-do-i-encircle-different-data-sets-in-scatter-plotdef encircle(x,y, ax=None, **kw):    if not ax: ax = plt.gca()    p = np.c_[x, y]    hull = ConvexHull(p)    poly = plt.Polygon(p[hull.vertices, :], **kw)    ax.add_patch(poly)# Select data to be encircledmidwest_encircle_data = midwest.loc[midwest.state==&#39;IN&#39;, :]# Draw polygon surrounding verticesencircle(midwest_encircle_data.area, midwest_encircle_data.poptotal, ec=&quot;k&quot;, fc=&quot;gold&quot;, alpha=0.1)encircle(midwest_encircle_data.area, midwest_encircle_data.poptotal, ec=&quot;firebrick&quot;, fc=&quot;none&quot;, linewidth=1.5)# Step 4: Decorationsplt.gca().set(xlim=(0.0, 0.1), ylim=(0, 90000),              xlabel=&#39;Area&#39;, ylabel=&#39;Population&#39;)plt.xticks(fontsize=12); plt.yticks(fontsize=12)plt.title(&quot;Bubble Plot with Encircling&quot;, fontsize=22)plt.legend(fontsize=12)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/02.png" alt="02"></p><h3 id="【03】带线性回归最佳拟合线的散点图（Scatter-plot-with-linear-regression-line-of-best-fit）"><a href="#【03】带线性回归最佳拟合线的散点图（Scatter-plot-with-linear-regression-line-of-best-fit）" class="headerlink" title="【03】带线性回归最佳拟合线的散点图（Scatter plot with linear regression line of best fit）"></a><font color=##4876FF>【03】带线性回归最佳拟合线的散点图（Scatter plot with linear regression line of best fit）</font></h3><p>如果你想了解两个变量之间是如何变化的，那么最佳拟合线就是常用的方法。下图显示了数据中不同组之间的最佳拟合线的差异。若要禁用分组并只为整个数据集绘制一条最佳拟合线，请从 <code>sns.lmplot()</code> 方法中删除 <code>hue =&#39;cyl&#39;</code> 参数。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/mpg_ggplot2.csv&quot;)df_select = df.loc[df.cyl.isin([4, 8]), :]# Plotsns.set_style(&quot;white&quot;)gridobj = sns.lmplot(x=&quot;displ&quot;, y=&quot;hwy&quot;, hue=&quot;cyl&quot;, data=df_select,                     height=7, aspect=1.6, robust=True, palette=&#39;tab10&#39;,                     scatter_kws=dict(s=60, linewidths=.7, edgecolors=&#39;black&#39;))# Decorationsgridobj.set(xlim=(0.5, 7.5), ylim=(0, 50))plt.title(&quot;Scatterplot with line of best fit grouped by number of cylinders&quot;, fontsize=20)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/03.png" alt="03"></p><p>针对每一组数据绘制线性回归线（Each regression line in its own column），可以通过在 <code>sns.lmplot()</code> 中设置 <code>col=groupingcolumn</code> 参数来实现，如下：</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/mpg_ggplot2.csv&quot;)df_select = df.loc[df.cyl.isin([4, 8]), :]# Each line in its own columnsns.set_style(&quot;white&quot;)gridobj = sns.lmplot(x=&quot;displ&quot;, y=&quot;hwy&quot;,                     data=df_select,                     height=7,                     robust=True,                     palette=&#39;Set1&#39;,                     col=&quot;cyl&quot;,                     scatter_kws=dict(s=60, linewidths=.7, edgecolors=&#39;black&#39;))# Decorationsgridobj.set(xlim=(0.5, 7.5), ylim=(0, 50))plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/04.png" alt="04"></p><h3 id="【04】抖动图（Jittering-with-stripplot）"><a href="#【04】抖动图（Jittering-with-stripplot）" class="headerlink" title="【04】抖动图（Jittering with stripplot）"></a><font color=##4876FF>【04】抖动图（Jittering with stripplot）</font></h3><p>通常，多个数据点具有完全相同的 X 和 Y 值。 此时多个点绘制会重叠并隐藏。为避免这种情况，可以将数据点稍微抖动，以便可以直观地看到它们。 使用 <code>seaborn</code> 库的 <code>stripplot()</code> 方法可以很方便的实现这个功能。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/mpg_ggplot2.csv&quot;)# Draw Stripplotfig, ax = plt.subplots(figsize=(16,10), dpi= 80)sns.stripplot(df.cty, df.hwy, jitter=0.25, size=8, ax=ax, linewidth=.5)# Decorationsplt.title(&#39;Use jittered plots to avoid overlapping of points&#39;, fontsize=22)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/05.png" alt="05"></p><h3 id="【05】计数图（Counts-Plot）"><a href="#【05】计数图（Counts-Plot）" class="headerlink" title="【05】计数图（Counts Plot）"></a><font color=##4876FF>【05】计数图（Counts Plot）</font></h3><p>避免点重叠问题的另一个选择是根据点的位置增加点的大小。所以，点的大小越大，它周围的点就越集中。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/mpg_ggplot2.csv&quot;)df_counts = df.groupby([&#39;hwy&#39;, &#39;cty&#39;]).size().reset_index(name=&#39;counts&#39;)# Draw Stripplotfig, ax = plt.subplots(figsize=(16,10), dpi= 80)    # 原文代码# sns.stripplot(df_counts.cty, df_counts.hwy, size=df_counts.counts*2, ax=ax)# 纠正代码sns.stripplot(df_counts.cty, df_counts.hwy, sizes=df_counts.counts*2, ax=ax)# Decorationsplt.title(&#39;Counts Plot - Size of circle is bigger as more points overlap&#39;, fontsize=22)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/06.png" alt="06"></p><h3 id="【06】边缘直方图（Marginal-Histogram）"><a href="#【06】边缘直方图（Marginal-Histogram）" class="headerlink" title="【06】边缘直方图（Marginal Histogram）"></a><font color=##4876FF>【06】边缘直方图（Marginal Histogram）</font></h3><p>边缘直方图是具有沿 X 和 Y 轴变量的直方图。 这用于可视化 X 和 Y 之间的关系以及单独的 X 和 Y 的单变量分布。 这种图经常用于探索性数据分析（EDA）。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/mpg_ggplot2.csv&quot;)# Create Fig and gridspecfig = plt.figure(figsize=(16, 10), dpi= 80)grid = plt.GridSpec(4, 4, hspace=0.5, wspace=0.2)# Define the axesax_main = fig.add_subplot(grid[:-1, :-1])ax_right = fig.add_subplot(grid[:-1, -1], xticklabels=[], yticklabels=[])ax_bottom = fig.add_subplot(grid[-1, 0:-1], xticklabels=[], yticklabels=[])# Scatterplot on main axax_main.scatter(&#39;displ&#39;, &#39;hwy&#39;, s=df.cty*4, c=df.manufacturer.astype(&#39;category&#39;).cat.codes, alpha=.9, data=df, cmap=&quot;tab10&quot;, edgecolors=&#39;gray&#39;, linewidths=.5)# histogram on the rightax_bottom.hist(df.displ, 40, histtype=&#39;stepfilled&#39;, orientation=&#39;vertical&#39;, color=&#39;deeppink&#39;)ax_bottom.invert_yaxis()# histogram in the bottomax_right.hist(df.hwy, 40, histtype=&#39;stepfilled&#39;, orientation=&#39;horizontal&#39;, color=&#39;deeppink&#39;)# Decorationsax_main.set(title=&#39;Scatterplot with Histograms \n displ vs hwy&#39;, xlabel=&#39;displ&#39;, ylabel=&#39;hwy&#39;)ax_main.title.set_fontsize(20)for item in ([ax_main.xaxis.label, ax_main.yaxis.label] + ax_main.get_xticklabels() + ax_main.get_yticklabels()):    item.set_fontsize(14)xlabels = ax_main.get_xticks().tolist()ax_main.set_xticklabels(xlabels)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/07.png" alt="07"></p><h3 id="【07】边缘箱形图（Marginal-Boxplot）"><a href="#【07】边缘箱形图（Marginal-Boxplot）" class="headerlink" title="【07】边缘箱形图（Marginal Boxplot）"></a><font color=##4876FF>【07】边缘箱形图（Marginal Boxplot）</font></h3><p>边缘箱形图与边缘直方图具有相似的用途。 然而，箱线图有助于精确定位 X 和 Y 的中位数、第25和第75百分位数。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/mpg_ggplot2.csv&quot;)# Create Fig and gridspecfig = plt.figure(figsize=(16, 10), dpi= 80)grid = plt.GridSpec(4, 4, hspace=0.5, wspace=0.2)# Define the axesax_main = fig.add_subplot(grid[:-1, :-1])ax_right = fig.add_subplot(grid[:-1, -1], xticklabels=[], yticklabels=[])ax_bottom = fig.add_subplot(grid[-1, 0:-1], xticklabels=[], yticklabels=[])# Scatterplot on main axax_main.scatter(&#39;displ&#39;, &#39;hwy&#39;, s=df.cty*5, c=df.manufacturer.astype(&#39;category&#39;).cat.codes, alpha=.9, data=df, cmap=&quot;Set1&quot;, edgecolors=&#39;black&#39;, linewidths=.5)# Add a graph in each partsns.boxplot(df.hwy, ax=ax_right, orient=&quot;v&quot;)sns.boxplot(df.displ, ax=ax_bottom, orient=&quot;h&quot;)# Decorations ------------------# Remove x axis name for the boxplotax_bottom.set(xlabel=&#39;&#39;)ax_right.set(ylabel=&#39;&#39;)# Main Title, Xlabel and YLabelax_main.set(title=&#39;Scatterplot with Histograms \n displ vs hwy&#39;, xlabel=&#39;displ&#39;, ylabel=&#39;hwy&#39;)# Set font size of different componentsax_main.title.set_fontsize(20)for item in ([ax_main.xaxis.label, ax_main.yaxis.label] + ax_main.get_xticklabels() + ax_main.get_yticklabels()):    item.set_fontsize(14)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/08.png" alt="08"></p><h3 id="【08】相关图（Correllogram）"><a href="#【08】相关图（Correllogram）" class="headerlink" title="【08】相关图（Correllogram）"></a><font color=##4876FF>【08】相关图（Correllogram）</font></h3><p>相关图用于直观地查看给定数据帧（或二维数组）中所有可能的数值变量对之间的相关性度量。</p><pre><code class="python"># Import Datasetdf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mtcars.csv&quot;)# Plotplt.figure(figsize=(12, 10), dpi=80)sns.heatmap(df.corr(), xticklabels=df.corr().columns, yticklabels=df.corr().columns, cmap=&#39;RdYlGn&#39;, center=0, annot=True)# Decorationsplt.title(&#39;Correlogram of mtcars&#39;, fontsize=22)plt.xticks(fontsize=12)plt.yticks(fontsize=12)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/09.png" alt="09"></p><h3 id="【09】成对图（Pairwise-Plot）"><a href="#【09】成对图（Pairwise-Plot）" class="headerlink" title="【09】成对图（Pairwise Plot）"></a><font color=##4876FF>【09】成对图（Pairwise Plot）</font></h3><p>成对图是探索性分析中最受欢迎的一种方法，用来理解所有可能的数值变量对之间的关系。它是二元分析的必备工具。</p><pre><code class="python"># Load Datasetdf = sns.load_dataset(&#39;iris&#39;)# Plotplt.figure(figsize=(10, 8), dpi=80)sns.pairplot(df, kind=&quot;scatter&quot;, hue=&quot;species&quot;, plot_kws=dict(s=80, edgecolor=&quot;white&quot;, linewidth=2.5))plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/10.png" alt="10"></p><pre><code class="python"># Load Datasetdf = sns.load_dataset(&#39;iris&#39;)# Plotplt.figure(figsize=(10, 8), dpi=80)sns.pairplot(df, kind=&quot;reg&quot;, hue=&quot;species&quot;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/11.png" alt="11"></p><h2 id="【4x00】偏差（Deviation）"><a href="#【4x00】偏差（Deviation）" class="headerlink" title="【4x00】偏差（Deviation）"></a><font color=#FF0000>【4x00】偏差（Deviation）</font></h2><h3 id="【10】发散型条形图（Diverging-Bars）"><a href="#【10】发散型条形图（Diverging-Bars）" class="headerlink" title="【10】发散型条形图（Diverging Bars）"></a><font color=##4876FF>【10】发散型条形图（Diverging Bars）</font></h3><p>如果您想根据单个指标查看项目的变化情况，并可视化此差异的顺序和数量，那么散型条形图是一个很好的工具。 它有助于快速区分数据组的性能，并且非常直观，并且可以立即传达这一点。</p><pre><code class="python"># Prepare Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mtcars.csv&quot;)x = df.loc[:, [&#39;mpg&#39;]]df[&#39;mpg_z&#39;] = (x - x.mean())/x.std()df[&#39;colors&#39;] = [&#39;red&#39; if x &lt; 0 else &#39;green&#39; for x in df[&#39;mpg_z&#39;]]df.sort_values(&#39;mpg_z&#39;, inplace=True)df.reset_index(inplace=True)# Draw plotplt.figure(figsize=(14,10), dpi= 80)plt.hlines(y=df.index, xmin=0, xmax=df.mpg_z, color=df.colors, alpha=0.4, linewidth=5)# Decorationsplt.gca().set(ylabel=&#39;$Model$&#39;, xlabel=&#39;$Mileage$&#39;)plt.yticks(df.index, df.cars, fontsize=12)plt.title(&#39;Diverging Bars of Car Mileage&#39;, fontdict=&#123;&#39;size&#39;:20&#125;)plt.grid(linestyle=&#39;--&#39;, alpha=0.5)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/12.png" alt="12"></p><h3 id="【11】发散型文本图（Diverging-Texts）"><a href="#【11】发散型文本图（Diverging-Texts）" class="headerlink" title="【11】发散型文本图（Diverging Texts）"></a><font color=##4876FF>【11】发散型文本图（Diverging Texts）</font></h3><p>发散型文本图与发散型条形图相似，如果你希望以一种美观的方式显示图表中每个项目的值，就可以使用这种方法。</p><pre><code class="python"># Prepare Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mtcars.csv&quot;)x = df.loc[:, [&#39;mpg&#39;]]df[&#39;mpg_z&#39;] = (x - x.mean())/x.std()df[&#39;colors&#39;] = [&#39;red&#39; if x &lt; 0 else &#39;green&#39; for x in df[&#39;mpg_z&#39;]]df.sort_values(&#39;mpg_z&#39;, inplace=True)df.reset_index(inplace=True)# Draw plotplt.figure(figsize=(14, 14), dpi=80)plt.hlines(y=df.index, xmin=0, xmax=df.mpg_z)for x, y, tex in zip(df.mpg_z, df.index, df.mpg_z):    t = plt.text(x, y, round(tex, 2), horizontalalignment=&#39;right&#39; if x &lt; 0 else &#39;left&#39;,                 verticalalignment=&#39;center&#39;, fontdict=&#123;&#39;color&#39;:&#39;red&#39; if x &lt; 0 else &#39;green&#39;, &#39;size&#39;:14&#125;)# Decorationsplt.yticks(df.index, df.cars, fontsize=12)plt.title(&#39;Diverging Text Bars of Car Mileage&#39;, fontdict=&#123;&#39;size&#39;:20&#125;)plt.grid(linestyle=&#39;--&#39;, alpha=0.5)plt.xlim(-2.5, 2.5)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/13.png" alt="13"></p><h3 id="【12】发散型散点图（Diverging-Dot-Plot）"><a href="#【12】发散型散点图（Diverging-Dot-Plot）" class="headerlink" title="【12】发散型散点图（Diverging Dot Plot）"></a><font color=##4876FF>【12】发散型散点图（Diverging Dot Plot）</font></h3><p>发散型散点图类似于发散型条形图。 但是，与发散型条形图相比，没有条形会减少组之间的对比度和差异。</p><pre><code class="python"># Prepare Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mtcars.csv&quot;)x = df.loc[:, [&#39;mpg&#39;]]df[&#39;mpg_z&#39;] = (x - x.mean())/x.std()df[&#39;colors&#39;] = [&#39;red&#39; if x &lt; 0 else &#39;darkgreen&#39; for x in df[&#39;mpg_z&#39;]]df.sort_values(&#39;mpg_z&#39;, inplace=True)df.reset_index(inplace=True)# Draw plotplt.figure(figsize=(14, 16), dpi=80)plt.scatter(df.mpg_z, df.index, s=450, alpha=.6, color=df.colors)for x, y, tex in zip(df.mpg_z, df.index, df.mpg_z):    t = plt.text(x, y, round(tex, 1), horizontalalignment=&#39;center&#39;,                 verticalalignment=&#39;center&#39;, fontdict=&#123;&#39;color&#39;: &#39;white&#39;&#125;)# Decorations# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(.3)plt.gca().spines[&quot;bottom&quot;].set_alpha(.3)plt.gca().spines[&quot;right&quot;].set_alpha(.3)plt.gca().spines[&quot;left&quot;].set_alpha(.3)plt.yticks(df.index, df.cars)plt.title(&#39;Diverging Dotplot of Car Mileage&#39;, fontdict=&#123;&#39;size&#39;: 20&#125;)plt.xlabel(&#39;$Mileage$&#39;)plt.grid(linestyle=&#39;--&#39;, alpha=0.5)plt.xlim(-2.5, 2.5)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/14.png" alt="14"></p><h3 id="【13】带标记的发散型棒棒糖图（Diverging-Lollipop-Chart-with-Markers）"><a href="#【13】带标记的发散型棒棒糖图（Diverging-Lollipop-Chart-with-Markers）" class="headerlink" title="【13】带标记的发散型棒棒糖图（Diverging Lollipop Chart with Markers）"></a><font color=##4876FF>【13】带标记的发散型棒棒糖图（Diverging Lollipop Chart with Markers）</font></h3><p>带有标记的棒棒糖提供了一种灵活的方式，强调您想要引起注意的任何重要数据点并在图表中适当地给出推理。</p><pre><code class="python"># Prepare Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mtcars.csv&quot;)x = df.loc[:, [&#39;mpg&#39;]]df[&#39;mpg_z&#39;] = (x - x.mean())/x.std()df[&#39;colors&#39;] = &#39;black&#39;# color fiat differentlydf.loc[df.cars == &#39;Fiat X1-9&#39;, &#39;colors&#39;] = &#39;darkorange&#39;df.sort_values(&#39;mpg_z&#39;, inplace=True)df.reset_index(inplace=True)# Draw plotimport matplotlib.patches as patchesplt.figure(figsize=(14, 16), dpi=80)plt.hlines(y=df.index, xmin=0, xmax=df.mpg_z, color=df.colors, alpha=0.4, linewidth=1)plt.scatter(df.mpg_z, df.index, color=df.colors, s=[600 if x == &#39;Fiat X1-9&#39; else 300 for x in df.cars], alpha=0.6)plt.yticks(df.index, df.cars)plt.xticks(fontsize=12)# Annotateplt.annotate(&#39;Mercedes Models&#39;, xy=(0.0, 11.0), xytext=(1.0, 11), xycoords=&#39;data&#39;,            fontsize=15, ha=&#39;center&#39;, va=&#39;center&#39;,            bbox=dict(boxstyle=&#39;square&#39;, fc=&#39;firebrick&#39;),            arrowprops=dict(arrowstyle=&#39;-[, widthB=2.0, lengthB=1.5&#39;, lw=2.0, color=&#39;steelblue&#39;), color=&#39;white&#39;)# Add Patchesp1 = patches.Rectangle((-2.0, -1), width=.3, height=3, alpha=.2, facecolor=&#39;red&#39;)p2 = patches.Rectangle((1.5, 27), width=.8, height=5, alpha=.2, facecolor=&#39;green&#39;)plt.gca().add_patch(p1)plt.gca().add_patch(p2)# Decorateplt.title(&#39;Diverging Bars of Car Mileage&#39;, fontdict=&#123;&#39;size&#39;: 20&#125;)plt.grid(linestyle=&#39;--&#39;, alpha=0.5)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/15.png" alt="15"></p><h3 id="【14】面积图（Area-Chart）"><a href="#【14】面积图（Area-Chart）" class="headerlink" title="【14】面积图（Area Chart）"></a><font color=##4876FF>【14】面积图（Area Chart）</font></h3><p>通过对轴和线之间的区域进行着色，面积图不仅强调波峰和波谷，还强调波峰和波谷的持续时间。 高点持续时间越长，线下面积越大。</p><pre><code class="python">import numpy as npimport pandas as pd# Prepare Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/economics.csv&quot;, parse_dates=[&#39;date&#39;]).head(100)x = np.arange(df.shape[0])y_returns = (df.psavert.diff().fillna(0)/df.psavert.shift(1)).fillna(0) * 100# Plotplt.figure(figsize=(16, 10), dpi=80)plt.fill_between(x[1:], y_returns[1:], 0, where=y_returns[1:] &gt;= 0, facecolor=&#39;green&#39;, interpolate=True, alpha=0.7)plt.fill_between(x[1:], y_returns[1:], 0, where=y_returns[1:] &lt;= 0, facecolor=&#39;red&#39;, interpolate=True, alpha=0.7)# Annotateplt.annotate(&#39;Peak \n1975&#39;, xy=(94.0, 21.0), xytext=(88.0, 28),             bbox=dict(boxstyle=&#39;square&#39;, fc=&#39;firebrick&#39;),             arrowprops=dict(facecolor=&#39;steelblue&#39;, shrink=0.05), fontsize=15, color=&#39;white&#39;)# Decorationsxtickvals = [str(m)[:3].upper()+&quot;-&quot;+str(y) for y, m in zip(df.date.dt.year, df.date.dt.month_name())]plt.gca().set_xticks(x[::6])plt.gca().set_xticklabels(xtickvals[::6], rotation=90, fontdict=&#123;&#39;horizontalalignment&#39;: &#39;center&#39;, &#39;verticalalignment&#39;: &#39;center_baseline&#39;&#125;)plt.ylim(-35, 35)plt.xlim(1, 100)plt.title(&quot;Month Economics Return %&quot;, fontsize=22)plt.ylabel(&#39;Monthly returns %&#39;)plt.grid(alpha=0.5)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/16.png" alt="16"></p><h2 id="【5x00】排序（Ranking）"><a href="#【5x00】排序（Ranking）" class="headerlink" title="【5x00】排序（Ranking）"></a><font color=#FF0000>【5x00】排序（Ranking）</font></h2><h3 id="【15】有序条形图（Ordered-Bar-Chart）"><a href="#【15】有序条形图（Ordered-Bar-Chart）" class="headerlink" title="【15】有序条形图（Ordered Bar Chart）"></a><font color=##4876FF>【15】有序条形图（Ordered Bar Chart）</font></h3><p>有序条形图有效地传达了项目的排序顺序。在图表上方添加度量标准的值，用户就可以从图表本身获得精确的信息。</p><pre><code class="python"># Prepare Datadf_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)df = df_raw[[&#39;cty&#39;, &#39;manufacturer&#39;]].groupby(&#39;manufacturer&#39;).apply(lambda x: x.mean())df.sort_values(&#39;cty&#39;, inplace=True)df.reset_index(inplace=True)# Draw plotimport matplotlib.patches as patchesfig, ax = plt.subplots(figsize=(16,10), facecolor=&#39;white&#39;, dpi= 80)ax.vlines(x=df.index, ymin=0, ymax=df.cty, color=&#39;firebrick&#39;, alpha=0.7, linewidth=20)# Annotate Textfor i, cty in enumerate(df.cty):    ax.text(i, cty+0.5, round(cty, 1), horizontalalignment=&#39;center&#39;)# Title, Label, Ticks and Ylimax.set_title(&#39;Bar Chart for Highway Mileage&#39;, fontdict=&#123;&#39;size&#39;:22&#125;)ax.set(ylabel=&#39;Miles Per Gallon&#39;, ylim=(0, 30))plt.xticks(df.index, df.manufacturer.str.upper(), rotation=60, horizontalalignment=&#39;right&#39;, fontsize=12)# Add patches to color the X axis labelsp1 = patches.Rectangle((.57, -0.005), width=.33, height=.13, alpha=.1, facecolor=&#39;green&#39;, transform=fig.transFigure)p2 = patches.Rectangle((.124, -0.005), width=.446, height=.13, alpha=.1, facecolor=&#39;red&#39;, transform=fig.transFigure)fig.add_artist(p1)fig.add_artist(p2)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/17.png" alt="17"></p><h3 id="【16】棒棒糖图（Lollipop-Chart）"><a href="#【16】棒棒糖图（Lollipop-Chart）" class="headerlink" title="【16】棒棒糖图（Lollipop Chart）"></a><font color=##4876FF>【16】棒棒糖图（Lollipop Chart）</font></h3><p>棒棒糖图表以一种视觉上令人愉悦的方式提供与有序条形图类似的目的。</p><pre><code class="python"># Prepare Datadf_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)df = df_raw[[&#39;cty&#39;, &#39;manufacturer&#39;]].groupby(&#39;manufacturer&#39;).apply(lambda x: x.mean())df.sort_values(&#39;cty&#39;, inplace=True)df.reset_index(inplace=True)# Draw plotfig, ax = plt.subplots(figsize=(16, 10), dpi=80)ax.vlines(x=df.index, ymin=0, ymax=df.cty, color=&#39;firebrick&#39;, alpha=0.7, linewidth=2)ax.scatter(x=df.index, y=df.cty, s=75, color=&#39;firebrick&#39;, alpha=0.7)# Title, Label, Ticks and Ylimax.set_title(&#39;Lollipop Chart for Highway Mileage&#39;, fontdict=&#123;&#39;size&#39;: 22&#125;)ax.set_ylabel(&#39;Miles Per Gallon&#39;)ax.set_xticks(df.index)ax.set_xticklabels(df.manufacturer.str.upper(), rotation=60, fontdict=&#123;&#39;horizontalalignment&#39;: &#39;right&#39;, &#39;size&#39;: 12&#125;)ax.set_ylim(0, 30)# Annotatefor row in df.itertuples():    ax.text(row.Index, row.cty+.5, s=round(row.cty, 2), horizontalalignment=&#39;center&#39;, verticalalignment=&#39;bottom&#39;, fontsize=14)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/18.png" alt="18"></p><h3 id="【17】点图（Dot-Plot）"><a href="#【17】点图（Dot-Plot）" class="headerlink" title="【17】点图（Dot Plot）"></a><font color=##4876FF>【17】点图（Dot Plot）</font></h3><p>点图可以表示项目的排名顺序。由于它是沿水平轴对齐的，所以可以更容易地看到点之间的距离。</p><pre><code class="python"># Prepare Datadf_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)df = df_raw[[&#39;cty&#39;, &#39;manufacturer&#39;]].groupby(&#39;manufacturer&#39;).apply(lambda x: x.mean())df.sort_values(&#39;cty&#39;, inplace=True)df.reset_index(inplace=True)# Draw plotfig, ax = plt.subplots(figsize=(16, 10), dpi=80)ax.hlines(y=df.index, xmin=11, xmax=26, color=&#39;gray&#39;, alpha=0.7, linewidth=1, linestyles=&#39;dashdot&#39;)ax.scatter(y=df.index, x=df.cty, s=75, color=&#39;firebrick&#39;, alpha=0.7)# Title, Label, Ticks and Ylimax.set_title(&#39;Dot Plot for Highway Mileage&#39;, fontdict=&#123;&#39;size&#39;: 22&#125;)ax.set_xlabel(&#39;Miles Per Gallon&#39;)ax.set_yticks(df.index)ax.set_yticklabels(df.manufacturer.str.title(), fontdict=&#123;&#39;horizontalalignment&#39;: &#39;right&#39;&#125;)ax.set_xlim(10, 27)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/19.png" alt="19"></p><h3 id="【18】坡度图（Slope-Chart）"><a href="#【18】坡度图（Slope-Chart）" class="headerlink" title="【18】坡度图（Slope Chart）"></a><font color=##4876FF>【18】坡度图（Slope Chart）</font></h3><p>坡度图最适合比较给定人员/项目的“前”和“后”位置。</p><pre><code class="python">import matplotlib.lines as mlines# Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/gdppercap.csv&quot;)left_label = [str(c) + &#39;, &#39; + str(round(y)) for c, y in zip(df.continent, df[&#39;1952&#39;])]right_label = [str(c) + &#39;, &#39; + str(round(y)) for c, y in zip(df.continent, df[&#39;1957&#39;])]klass = [&#39;red&#39; if (y1 - y2) &lt; 0 else &#39;green&#39; for y1, y2 in zip(df[&#39;1952&#39;], df[&#39;1957&#39;])]# draw line# https://stackoverflow.com/questions/36470343/how-to-draw-a-line-with-matplotlib/36479941def newline(p1, p2, color=&#39;black&#39;):    ax = plt.gca()    l = mlines.Line2D([p1[0], p2[0]], [p1[1], p2[1]], color=&#39;red&#39; if p1[1] - p2[1] &gt; 0 else &#39;green&#39;, marker=&#39;o&#39;,                      markersize=6)    ax.add_line(l)    return lfig, ax = plt.subplots(1, 1, figsize=(14, 14), dpi=80)# Vertical Linesax.vlines(x=1, ymin=500, ymax=13000, color=&#39;black&#39;, alpha=0.7, linewidth=1, linestyles=&#39;dotted&#39;)ax.vlines(x=3, ymin=500, ymax=13000, color=&#39;black&#39;, alpha=0.7, linewidth=1, linestyles=&#39;dotted&#39;)# Pointsax.scatter(y=df[&#39;1952&#39;], x=np.repeat(1, df.shape[0]), s=10, color=&#39;black&#39;, alpha=0.7)ax.scatter(y=df[&#39;1957&#39;], x=np.repeat(3, df.shape[0]), s=10, color=&#39;black&#39;, alpha=0.7)# Line Segmentsand Annotationfor p1, p2, c in zip(df[&#39;1952&#39;], df[&#39;1957&#39;], df[&#39;continent&#39;]):    newline([1, p1], [3, p2])    ax.text(1 - 0.05, p1, c + &#39;, &#39; + str(round(p1)), horizontalalignment=&#39;right&#39;, verticalalignment=&#39;center&#39;,            fontdict=&#123;&#39;size&#39;: 14&#125;)    ax.text(3 + 0.05, p2, c + &#39;, &#39; + str(round(p2)), horizontalalignment=&#39;left&#39;, verticalalignment=&#39;center&#39;,            fontdict=&#123;&#39;size&#39;: 14&#125;)# &#39;Before&#39; and &#39;After&#39; Annotationsax.text(1 - 0.05, 13000, &#39;BEFORE&#39;, horizontalalignment=&#39;right&#39;, verticalalignment=&#39;center&#39;,        fontdict=&#123;&#39;size&#39;: 18, &#39;weight&#39;: 700&#125;)ax.text(3 + 0.05, 13000, &#39;AFTER&#39;, horizontalalignment=&#39;left&#39;, verticalalignment=&#39;center&#39;,        fontdict=&#123;&#39;size&#39;: 18, &#39;weight&#39;: 700&#125;)# Decorationax.set_title(&quot;Slopechart: Comparing GDP Per Capita between 1952 vs 1957&quot;, fontdict=&#123;&#39;size&#39;: 22&#125;)ax.set(xlim=(0, 4), ylim=(0, 14000), ylabel=&#39;Mean GDP Per Capita&#39;)ax.set_xticks([1, 3])ax.set_xticklabels([&quot;1952&quot;, &quot;1957&quot;])plt.yticks(np.arange(500, 13000, 2000), fontsize=12)# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(.0)plt.gca().spines[&quot;bottom&quot;].set_alpha(.0)plt.gca().spines[&quot;right&quot;].set_alpha(.0)plt.gca().spines[&quot;left&quot;].set_alpha(.0)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/20.png" alt="20"></p><h3 id="【19】哑铃图（Dumbbell-Plot）"><a href="#【19】哑铃图（Dumbbell-Plot）" class="headerlink" title="【19】哑铃图（Dumbbell Plot）"></a><font color=##4876FF>【19】哑铃图（Dumbbell Plot）</font></h3><p>哑铃图传达了各种项目的“前”和“后”位置以及项目的等级顺序。如果您希望可视化特定项目/计划对不同对象的影响，那么它非常有用。</p><pre><code class="python">import matplotlib.lines as mlines# Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/health.csv&quot;)df.sort_values(&#39;pct_2014&#39;, inplace=True)df.reset_index(inplace=True)# Func to draw line segmentdef newline(p1, p2, color=&#39;black&#39;):    ax = plt.gca()    l = mlines.Line2D([p1[0], p2[0]], [p1[1], p2[1]], color=&#39;skyblue&#39;)    ax.add_line(l)    return l# Figure and Axesfig, ax = plt.subplots(1, 1, figsize=(14, 14), facecolor=&#39;#f7f7f7&#39;, dpi=80)# Vertical Linesax.vlines(x=.05, ymin=0, ymax=26, color=&#39;black&#39;, alpha=1, linewidth=1, linestyles=&#39;dotted&#39;)ax.vlines(x=.10, ymin=0, ymax=26, color=&#39;black&#39;, alpha=1, linewidth=1, linestyles=&#39;dotted&#39;)ax.vlines(x=.15, ymin=0, ymax=26, color=&#39;black&#39;, alpha=1, linewidth=1, linestyles=&#39;dotted&#39;)ax.vlines(x=.20, ymin=0, ymax=26, color=&#39;black&#39;, alpha=1, linewidth=1, linestyles=&#39;dotted&#39;)# Pointsax.scatter(y=df[&#39;index&#39;], x=df[&#39;pct_2013&#39;], s=50, color=&#39;#0e668b&#39;, alpha=0.7)ax.scatter(y=df[&#39;index&#39;], x=df[&#39;pct_2014&#39;], s=50, color=&#39;#a3c4dc&#39;, alpha=0.7)# Line Segmentsfor i, p1, p2 in zip(df[&#39;index&#39;], df[&#39;pct_2013&#39;], df[&#39;pct_2014&#39;]):    newline([p1, i], [p2, i])# Decorationax.set_facecolor(&#39;#f7f7f7&#39;)ax.set_title(&quot;Dumbell Chart: Pct Change - 2013 vs 2014&quot;, fontdict=&#123;&#39;size&#39;: 22&#125;)ax.set(xlim=(0, .25), ylim=(-1, 27), ylabel=&#39;Mean GDP Per Capita&#39;)ax.set_xticks([.05, .1, .15, .20])ax.set_xticklabels([&#39;5%&#39;, &#39;15%&#39;, &#39;20%&#39;, &#39;25%&#39;])ax.set_xticklabels([&#39;5%&#39;, &#39;15%&#39;, &#39;20%&#39;, &#39;25%&#39;])plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/21.png" alt="21"></p><h2 id="【6x00】分布（Distribution）"><a href="#【6x00】分布（Distribution）" class="headerlink" title="【6x00】分布（Distribution）"></a><font color=#FF0000>【6x00】分布（Distribution）</font></h2><h3 id="【20】连续变量的直方图（Histogram-for-Continuous-Variable）"><a href="#【20】连续变量的直方图（Histogram-for-Continuous-Variable）" class="headerlink" title="【20】连续变量的直方图（Histogram for Continuous Variable）"></a><font color=##4876FF>【20】连续变量的直方图（Histogram for Continuous Variable）</font></h3><p>连续变量的直方图显示给定变量的频率分布。下面的图表基于分类变量对频率条进行分组，从而更深入地了解连续变量和分类变量。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Prepare datax_var = &#39;displ&#39;groupby_var = &#39;class&#39;df_agg = df.loc[:, [x_var, groupby_var]].groupby(groupby_var)vals = [df[x_var].values.tolist() for i, df in df_agg]# Drawplt.figure(figsize=(16, 9), dpi=80)colors = [plt.cm.Spectral(i / float(len(vals) - 1)) for i in range(len(vals))]n, bins, patches = plt.hist(vals, 30, stacked=True, density=False, color=colors[:len(vals)])# Decorationplt.legend(&#123;group: col for group, col in zip(np.unique(df[groupby_var]).tolist(), colors[:len(vals)])&#125;)plt.title(f&quot;Stacked Histogram of $&#123;x_var&#125;$ colored by $&#123;groupby_var&#125;$&quot;, fontsize=22)plt.xlabel(x_var)plt.ylabel(&quot;Frequency&quot;)plt.ylim(0, 25)plt.xticks(ticks=bins[::3], labels=[round(b, 1) for b in bins[::3]])plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/22.png" alt="22"></p><h3 id="【21】分类变量的直方图（Histogram-for-Categorical-Variable）"><a href="#【21】分类变量的直方图（Histogram-for-Categorical-Variable）" class="headerlink" title="【21】分类变量的直方图（Histogram for Categorical Variable）"></a><font color=##4876FF>【21】分类变量的直方图（Histogram for Categorical Variable）</font></h3><p>分类变量的直方图显示该变量的频率分布。通过给条形图上色，您可以将分布与表示颜色的另一个类型变量相关联。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Prepare datax_var = &#39;manufacturer&#39;groupby_var = &#39;class&#39;df_agg = df.loc[:, [x_var, groupby_var]].groupby(groupby_var)vals = [df[x_var].values.tolist() for i, df in df_agg]# Drawplt.figure(figsize=(16, 9), dpi=80)colors = [plt.cm.Spectral(i / float(len(vals) - 1)) for i in range(len(vals))]n, bins, patches = plt.hist(vals, df[x_var].unique().__len__(), stacked=True, density=False, color=colors[:len(vals)])# Decorationplt.legend(&#123;group: col for group, col in zip(np.unique(df[groupby_var]).tolist(), colors[:len(vals)])&#125;)plt.title(f&quot;Stacked Histogram of $&#123;x_var&#125;$ colored by $&#123;groupby_var&#125;$&quot;, fontsize=22)plt.xlabel(x_var)plt.ylabel(&quot;Frequency&quot;)plt.ylim(0, 40)plt.xticks(ticks=bins, labels=np.unique(df[x_var]).tolist(), rotation=90, horizontalalignment=&#39;left&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/23.png" alt="23"></p><h3 id="【22】密度图（Density-Plot）"><a href="#【22】密度图（Density-Plot）" class="headerlink" title="【22】密度图（Density Plot）"></a><font color=##4876FF>【22】密度图（Density Plot）</font></h3><p>密度图是连续变量分布可视化的常用工具。通过按“response”变量对它们进行分组，您可以检查 X 和 Y 之间的关系。如果出于代表性目的来描述城市里程分布如何随气缸数而变化，请参见下面的情况。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Draw Plotplt.figure(figsize=(16, 10), dpi=80)sns.kdeplot(df.loc[df[&#39;cyl&#39;] == 4, &quot;cty&quot;], shade=True, color=&quot;g&quot;, label=&quot;Cyl=4&quot;, alpha=.7)sns.kdeplot(df.loc[df[&#39;cyl&#39;] == 5, &quot;cty&quot;], shade=True, color=&quot;deeppink&quot;, label=&quot;Cyl=5&quot;, alpha=.7)sns.kdeplot(df.loc[df[&#39;cyl&#39;] == 6, &quot;cty&quot;], shade=True, color=&quot;dodgerblue&quot;, label=&quot;Cyl=6&quot;, alpha=.7)sns.kdeplot(df.loc[df[&#39;cyl&#39;] == 8, &quot;cty&quot;], shade=True, color=&quot;orange&quot;, label=&quot;Cyl=8&quot;, alpha=.7)# Decorationplt.title(&#39;Density Plot of City Mileage by n_Cylinders&#39;, fontsize=22)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/24.png" alt="24"></p><h3 id="【23】直方图密度曲线（Density-Curves-with-Histogram）"><a href="#【23】直方图密度曲线（Density-Curves-with-Histogram）" class="headerlink" title="【23】直方图密度曲线（Density Curves with Histogram）"></a><font color=##4876FF>【23】直方图密度曲线（Density Curves with Histogram）</font></h3><p>具有直方图的密度曲线将两个图所传达的信息集合在一起，因此您可以将它们都放在一个图形中，而不是放在两个图形中。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Draw Plotplt.figure(figsize=(13, 10), dpi=80)sns.distplot(df.loc[df[&#39;class&#39;] == &#39;compact&#39;, &quot;cty&quot;], color=&quot;dodgerblue&quot;, label=&quot;Compact&quot;, hist_kws=&#123;&#39;alpha&#39;: .7&#125;,             kde_kws=&#123;&#39;linewidth&#39;: 3&#125;)sns.distplot(df.loc[df[&#39;class&#39;] == &#39;suv&#39;, &quot;cty&quot;], color=&quot;orange&quot;, label=&quot;SUV&quot;, hist_kws=&#123;&#39;alpha&#39;: .7&#125;,             kde_kws=&#123;&#39;linewidth&#39;: 3&#125;)sns.distplot(df.loc[df[&#39;class&#39;] == &#39;minivan&#39;, &quot;cty&quot;], color=&quot;g&quot;, label=&quot;minivan&quot;, hist_kws=&#123;&#39;alpha&#39;: .7&#125;,             kde_kws=&#123;&#39;linewidth&#39;: 3&#125;)plt.ylim(0, 0.35)# Decorationplt.title(&#39;Density Plot of City Mileage by Vehicle Type&#39;, fontsize=22)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/25.png" alt="25"></p><h3 id="【24】山峰叠峦图-欢乐图（Joy-Plot）"><a href="#【24】山峰叠峦图-欢乐图（Joy-Plot）" class="headerlink" title="【24】山峰叠峦图 / 欢乐图（Joy Plot）"></a><font color=##4876FF>【24】山峰叠峦图 / 欢乐图（Joy Plot）</font></h3><p>Joy Plot 允许不同组的密度曲线重叠，这是一种很好的可视化方法，可以直观地显示大量分组之间的关系。它看起来赏心悦目，清楚地传达了正确的信息。它可以使用基于 <code>matplotlib</code> 的 <code>joypy</code> 包轻松构建。</p><p>【译者 TRHX 注：Joy Plot 看起来就像是山峰叠峦，山峦起伏，层次分明，但取名为 Joy，欢乐的意思，所以不太好翻译，在使用该方法时要先安装 joypy 库】</p><pre><code class="python"># !pip install joypy# Import Dataimport joypy# 原文没有 import joypy，译者 TRHX 添加mpg = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Draw Plotplt.figure(figsize=(16, 10), dpi=80)fig, axes = joypy.joyplot(mpg, column=[&#39;hwy&#39;, &#39;cty&#39;], by=&quot;class&quot;, ylim=&#39;own&#39;, figsize=(14, 10))# Decorationplt.title(&#39;Joy Plot of City and Highway Mileage by Class&#39;, fontsize=22)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/26.png" alt="26"></p><h3 id="【25】分布式点图（Distributed-Dot-Plot）"><a href="#【25】分布式点图（Distributed-Dot-Plot）" class="headerlink" title="【25】分布式点图（Distributed Dot Plot）"></a><font color=##4876FF>【25】分布式点图（Distributed Dot Plot）</font></h3><p>分布点图显示按组分割的点的单变量分布。点越暗，数据点在该区域的集中程度就越高。通过对中值进行不同的着色，这些组的真实位置立即变得明显。</p><pre><code class="python">import matplotlib.patches as mpatches# Prepare Datadf_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)cyl_colors = &#123;4: &#39;tab:red&#39;, 5: &#39;tab:green&#39;, 6: &#39;tab:blue&#39;, 8: &#39;tab:orange&#39;&#125;df_raw[&#39;cyl_color&#39;] = df_raw.cyl.map(cyl_colors)# Mean and Median city mileage by makedf = df_raw[[&#39;cty&#39;, &#39;manufacturer&#39;]].groupby(&#39;manufacturer&#39;).apply(lambda x: x.mean())df.sort_values(&#39;cty&#39;, ascending=False, inplace=True)df.reset_index(inplace=True)df_median = df_raw[[&#39;cty&#39;, &#39;manufacturer&#39;]].groupby(&#39;manufacturer&#39;).apply(lambda x: x.median())# Draw horizontal linesfig, ax = plt.subplots(figsize=(16, 10), dpi=80)ax.hlines(y=df.index, xmin=0, xmax=40, color=&#39;gray&#39;, alpha=0.5, linewidth=.5, linestyles=&#39;dashdot&#39;)# Draw the Dotsfor i, make in enumerate(df.manufacturer):    df_make = df_raw.loc[df_raw.manufacturer == make, :]    # 原文代码    # ax.scatter(y=np.repeat(i, df_make.shape[0]), x=&#39;cty&#39;, data=df_make, s=75, edgecolors=&#39;gray&#39;, c=&#39;w&#39;, alpha=0.5)    # 纠正代码    ax.scatter(y=list(np.repeat(i, df_make.shape[0])), x=&#39;cty&#39;, data=df_make, s=75, edgecolors=&#39;gray&#39;, c=&#39;w&#39;, alpha=0.5)    ax.scatter(y=i, x=&#39;cty&#39;, data=df_median.loc[df_median.index == make, :], s=75, c=&#39;firebrick&#39;)# Annotateax.text(33, 13, &quot;$red \; dots \; are \; the \: median$&quot;, fontdict=&#123;&#39;size&#39;: 12&#125;, color=&#39;firebrick&#39;)# Decorationsred_patch = plt.plot([], [], marker=&quot;o&quot;, ms=10, ls=&quot;&quot;, mec=None, color=&#39;firebrick&#39;, label=&quot;Median&quot;)plt.legend(handles=red_patch)ax.set_title(&#39;Distribution of City Mileage by Make&#39;, fontdict=&#123;&#39;size&#39;: 22&#125;)ax.set_xlabel(&#39;Miles Per Gallon (City)&#39;, alpha=0.7)ax.set_yticks(df.index)ax.set_yticklabels(df.manufacturer.str.title(), fontdict=&#123;&#39;horizontalalignment&#39;: &#39;right&#39;&#125;, alpha=0.7)ax.set_xlim(1, 40)plt.xticks(alpha=0.7)plt.gca().spines[&quot;top&quot;].set_visible(False)plt.gca().spines[&quot;bottom&quot;].set_visible(False)plt.gca().spines[&quot;right&quot;].set_visible(False)plt.gca().spines[&quot;left&quot;].set_visible(False)plt.grid(axis=&#39;both&#39;, alpha=.4, linewidth=.1)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/27.png" alt="27"></p><h3 id="【26】箱形图（Box-Plot）"><a href="#【26】箱形图（Box-Plot）" class="headerlink" title="【26】箱形图（Box Plot）"></a><font color=##4876FF>【26】箱形图（Box Plot）</font></h3><p>箱形图是可视化分布的一种好方法，同时牢记中位数，第 25 个第 75 个四分位数和离群值。 但是，在解释方框的大小时需要小心，这可能会扭曲该组中包含的点数。 因此，手动提供每个框中的观察次数可以帮助克服此缺点。</p><p>例如，左侧的前两个框，尽管它们分别具有 5 和 47 个 obs，但是却具有相同大小， 因此，有必要写下该组中的观察数。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Draw Plotplt.figure(figsize=(13, 10), dpi=80)sns.boxplot(x=&#39;class&#39;, y=&#39;hwy&#39;, data=df, notch=False)# Add N Obs inside boxplot (optional)def add_n_obs(df, group_col, y):    medians_dict = &#123;grp[0]: grp[1][y].median() for grp in df.groupby(group_col)&#125;    xticklabels = [x.get_text() for x in plt.gca().get_xticklabels()]    n_obs = df.groupby(group_col)[y].size().values    for (x, xticklabel), n_ob in zip(enumerate(xticklabels), n_obs):        plt.text(x, medians_dict[xticklabel] * 1.01, &quot;#obs : &quot; + str(n_ob), horizontalalignment=&#39;center&#39;,                 fontdict=&#123;&#39;size&#39;: 14&#125;, color=&#39;white&#39;)add_n_obs(df, group_col=&#39;class&#39;, y=&#39;hwy&#39;)# Decorationplt.title(&#39;Box Plot of Highway Mileage by Vehicle Class&#39;, fontsize=22)plt.ylim(10, 40)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/28.png" alt="28"></p><h3 id="【27】点-箱形图（Dot-Box-Plot）"><a href="#【27】点-箱形图（Dot-Box-Plot）" class="headerlink" title="【27】点 + 箱形图（Dot + Box Plot）"></a><font color=##4876FF>【27】点 + 箱形图（Dot + Box Plot）</font></h3><p>点 + 箱形图传达类似于分组的箱形图信息。此外，这些点还提供了每组中有多少数据点的含义。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Draw Plotplt.figure(figsize=(13,10), dpi= 80)sns.boxplot(x=&#39;class&#39;, y=&#39;hwy&#39;, data=df, hue=&#39;cyl&#39;)sns.stripplot(x=&#39;class&#39;, y=&#39;hwy&#39;, data=df, color=&#39;black&#39;, size=3, jitter=1)for i in range(len(df[&#39;class&#39;].unique())-1):    plt.vlines(i+.5, 10, 45, linestyles=&#39;solid&#39;, colors=&#39;gray&#39;, alpha=0.2)# Decorationplt.title(&#39;Box Plot of Highway Mileage by Vehicle Class&#39;, fontsize=22)plt.legend(title=&#39;Cylinders&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/29.png" alt="29"></p><h3 id="【28】小提琴图（Violin-Plot）"><a href="#【28】小提琴图（Violin-Plot）" class="headerlink" title="【28】小提琴图（Violin Plot）"></a><font color=##4876FF>【28】小提琴图（Violin Plot）</font></h3><p>小提琴图是箱形图在视觉上令人愉悦的替代品。 小提琴的形状或面积取决于它所持有的观察次数。 但是，小提琴图可能更难以阅读，并且在专业设置中不常用。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Draw Plotplt.figure(figsize=(13, 10), dpi=80)sns.violinplot(x=&#39;class&#39;, y=&#39;hwy&#39;, data=df, scale=&#39;width&#39;, inner=&#39;quartile&#39;)# Decorationplt.title(&#39;Violin Plot of Highway Mileage by Vehicle Class&#39;, fontsize=22)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/30.png" alt="30"></p><h3 id="【29】人口金字塔图（Population-Pyramid）"><a href="#【29】人口金字塔图（Population-Pyramid）" class="headerlink" title="【29】人口金字塔图（Population Pyramid）"></a><font color=##4876FF>【29】人口金字塔图（Population Pyramid）</font></h3><p>人口金字塔可用于显示按体积排序的组的分布。或者它也可以用于显示人口的逐级过滤，因为它是用来显示有多少人通过一个营销漏斗（Marketing Funnel）的每个阶段。</p><pre><code class="python"># Read datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/email_campaign_funnel.csv&quot;)# Draw Plotplt.figure(figsize=(13, 10), dpi=80)group_col = &#39;Gender&#39;order_of_bars = df.Stage.unique()[::-1]colors = [plt.cm.Spectral(i / float(len(df[group_col].unique()) - 1)) for i in range(len(df[group_col].unique()))]for c, group in zip(colors, df[group_col].unique()):    sns.barplot(x=&#39;Users&#39;, y=&#39;Stage&#39;, data=df.loc[df[group_col] == group, :], order=order_of_bars, color=c, label=group)# Decorationsplt.xlabel(&quot;$Users$&quot;)plt.ylabel(&quot;Stage of Purchase&quot;)plt.yticks(fontsize=12)plt.title(&quot;Population Pyramid of the Marketing Funnel&quot;, fontsize=22)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/31.png" alt="31"></p><h3 id="【30】分类图（Categorical-Plots）"><a href="#【30】分类图（Categorical-Plots）" class="headerlink" title="【30】分类图（Categorical Plots）"></a><font color=##4876FF>【30】分类图（Categorical Plots）</font></h3><p>由 <code>seaborn</code> 库提供的分类图可用于可视化彼此相关的两个或更多分类变量的计数分布。</p><pre><code class="python"># Load Datasettitanic = sns.load_dataset(&quot;titanic&quot;)# Plotg = sns.catplot(&quot;alive&quot;, col=&quot;deck&quot;, col_wrap=4,                data=titanic[titanic.deck.notnull()],                kind=&quot;count&quot;, height=3.5, aspect=.8,                palette=&#39;tab20&#39;)# 译者 TRHX 注释掉了这一行代码# fig.suptitle(&#39;sf&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/32.png" alt="32"></p><pre><code class="python"># Load Datasettitanic = sns.load_dataset(&quot;titanic&quot;)# Plotsns.catplot(x=&quot;age&quot;, y=&quot;embark_town&quot;,            hue=&quot;sex&quot;, col=&quot;class&quot;,            data=titanic[titanic.embark_town.notnull()],            orient=&quot;h&quot;, height=5, aspect=1, palette=&quot;tab10&quot;,            kind=&quot;violin&quot;, dodge=True, cut=0, bw=.2)# 译者 TRHX 添加了这行代码plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/33.png" alt="33"></p><h2 id="【7x00】组成（Composition）"><a href="#【7x00】组成（Composition）" class="headerlink" title="【7x00】组成（Composition）"></a><font color=#FF0000>【7x00】组成（Composition）</font></h2><h3 id="【31】华夫饼图（Waffle-Chart）"><a href="#【31】华夫饼图（Waffle-Chart）" class="headerlink" title="【31】华夫饼图（Waffle Chart）"></a><font color=##4876FF>【31】华夫饼图（Waffle Chart）</font></h3><p>华夫饼图可以使用 <code>pywaffle</code> 包创建，用于显示较大群体中的组的组成。</p><p>【译者 TRHX 注：在使用该方法时要先安装 pywaffle 库】</p><pre><code class="python"># ! pip install pywaffle# Reference: https://stackoverflow.com/questions/41400136/how-to-do-waffle-charts-in-python-square-piechartfrom pywaffle import Waffle# Importdf_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Prepare Datadf = df_raw.groupby(&#39;class&#39;).size().reset_index(name=&#39;counts&#39;)n_categories = df.shape[0]colors = [plt.cm.inferno_r(i / float(n_categories)) for i in range(n_categories)]# Draw Plot and Decoratefig = plt.figure(    FigureClass=Waffle,    plots=&#123;        &#39;111&#39;: &#123;            &#39;values&#39;: df[&#39;counts&#39;],            &#39;labels&#39;: [&quot;&#123;0&#125; (&#123;1&#125;)&quot;.format(n[0], n[1]) for n in df[[&#39;class&#39;, &#39;counts&#39;]].itertuples()],            &#39;legend&#39;: &#123;&#39;loc&#39;: &#39;upper left&#39;, &#39;bbox_to_anchor&#39;: (1.05, 1), &#39;fontsize&#39;: 12&#125;,            &#39;title&#39;: &#123;&#39;label&#39;: &#39;# Vehicles by Class&#39;, &#39;loc&#39;: &#39;center&#39;, &#39;fontsize&#39;: 18&#125;        &#125;,    &#125;,    rows=7,    colors=colors,    figsize=(16, 9))# 译者 TRHX 添加了这行代码plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/34.png" alt="34"></p><pre><code class="python"># ! pip install pywafflefrom pywaffle import Waffle# Import# 译者 TRHX 取消注释了这行代码df_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Prepare Data# By Class Datadf_class = df_raw.groupby(&#39;class&#39;).size().reset_index(name=&#39;counts_class&#39;)n_categories = df_class.shape[0]colors_class = [plt.cm.Set3(i / float(n_categories)) for i in range(n_categories)]# By Cylinders Datadf_cyl = df_raw.groupby(&#39;cyl&#39;).size().reset_index(name=&#39;counts_cyl&#39;)n_categories = df_cyl.shape[0]colors_cyl = [plt.cm.Spectral(i / float(n_categories)) for i in range(n_categories)]# By Make Datadf_make = df_raw.groupby(&#39;manufacturer&#39;).size().reset_index(name=&#39;counts_make&#39;)n_categories = df_make.shape[0]colors_make = [plt.cm.tab20b(i / float(n_categories)) for i in range(n_categories)]# Draw Plot and Decoratefig = plt.figure(    FigureClass=Waffle,    plots=&#123;        &#39;311&#39;: &#123;            &#39;values&#39;: df_class[&#39;counts_class&#39;],            &#39;labels&#39;: [&quot;&#123;1&#125;&quot;.format(n[0], n[1]) for n in df_class[[&#39;class&#39;, &#39;counts_class&#39;]].itertuples()],            &#39;legend&#39;: &#123;&#39;loc&#39;: &#39;upper left&#39;, &#39;bbox_to_anchor&#39;: (1.05, 1), &#39;fontsize&#39;: 12, &#39;title&#39;: &#39;Class&#39;&#125;,            &#39;title&#39;: &#123;&#39;label&#39;: &#39;# Vehicles by Class&#39;, &#39;loc&#39;: &#39;center&#39;, &#39;fontsize&#39;: 18&#125;,            &#39;colors&#39;: colors_class        &#125;,        &#39;312&#39;: &#123;            &#39;values&#39;: df_cyl[&#39;counts_cyl&#39;],            &#39;labels&#39;: [&quot;&#123;1&#125;&quot;.format(n[0], n[1]) for n in df_cyl[[&#39;cyl&#39;, &#39;counts_cyl&#39;]].itertuples()],            &#39;legend&#39;: &#123;&#39;loc&#39;: &#39;upper left&#39;, &#39;bbox_to_anchor&#39;: (1.05, 1), &#39;fontsize&#39;: 12, &#39;title&#39;: &#39;Cyl&#39;&#125;,            &#39;title&#39;: &#123;&#39;label&#39;: &#39;# Vehicles by Cyl&#39;, &#39;loc&#39;: &#39;center&#39;, &#39;fontsize&#39;: 18&#125;,            &#39;colors&#39;: colors_cyl        &#125;,        &#39;313&#39;: &#123;            &#39;values&#39;: df_make[&#39;counts_make&#39;],            &#39;labels&#39;: [&quot;&#123;1&#125;&quot;.format(n[0], n[1]) for n in df_make[[&#39;manufacturer&#39;, &#39;counts_make&#39;]].itertuples()],            &#39;legend&#39;: &#123;&#39;loc&#39;: &#39;upper left&#39;, &#39;bbox_to_anchor&#39;: (1.05, 1), &#39;fontsize&#39;: 12, &#39;title&#39;: &#39;Manufacturer&#39;&#125;,            &#39;title&#39;: &#123;&#39;label&#39;: &#39;# Vehicles by Make&#39;, &#39;loc&#39;: &#39;center&#39;, &#39;fontsize&#39;: 18&#125;,            &#39;colors&#39;: colors_make        &#125;    &#125;,    rows=9,    figsize=(16, 14))# 译者 TRHX 添加了这行代码plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/35.png" alt="35"></p><h3 id="【32】饼图（Pie-Chart）"><a href="#【32】饼图（Pie-Chart）" class="headerlink" title="【32】饼图（Pie Chart）"></a><font color=##4876FF>【32】饼图（Pie Chart）</font></h3><p>饼图是显示组成的经典方法。然而，现在一般不宜使用，因为馅饼部分的面积有时会产生误导。因此，如果要使用饼图，强烈建议您显式地记下饼图每个部分的百分比或数字。</p><pre><code class="python"># Importdf_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Prepare Datadf = df_raw.groupby(&#39;class&#39;).size()# Make the plot with pandas&#39;&#39;&#39;原代码：df.plot(kind=&#39;pie&#39;, subplots=True, figsize=(8, 8), dpi=80)译者 TRHX 删除了 dpi= 80&#39;&#39;&#39;df.plot(kind=&#39;pie&#39;, subplots=True, figsize=(8, 8))plt.title(&quot;Pie Chart of Vehicle Class - Bad&quot;)plt.ylabel(&quot;&quot;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/36.png" alt="36"></p><pre><code class="python"># Importdf_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Prepare Datadf = df_raw.groupby(&#39;class&#39;).size().reset_index(name=&#39;counts&#39;)# Draw Plotfig, ax = plt.subplots(figsize=(12, 7), subplot_kw=dict(aspect=&quot;equal&quot;), dpi=80)data = df[&#39;counts&#39;]categories = df[&#39;class&#39;]explode = [0, 0, 0, 0, 0, 0.1, 0]def func(pct, allvals):    absolute = int(pct / 100. * np.sum(allvals))    return &quot;&#123;:.1f&#125;% (&#123;:d&#125; )&quot;.format(pct, absolute)wedges, texts, autotexts = ax.pie(data,                                  autopct=lambda pct: func(pct, data),                                  textprops=dict(color=&quot;w&quot;),                                  colors=plt.cm.Dark2.colors,                                  startangle=140,                                  explode=explode)# Decorationax.legend(wedges, categories, title=&quot;Vehicle Class&quot;, loc=&quot;center left&quot;, bbox_to_anchor=(1, 0, 0.5, 1))plt.setp(autotexts, size=10, weight=700)ax.set_title(&quot;Class of Vehicles: Pie Chart&quot;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/37.png" alt="37"></p><h3 id="【33】矩阵树形图（Treemap）"><a href="#【33】矩阵树形图（Treemap）" class="headerlink" title="【33】矩阵树形图（Treemap）"></a><font color=##4876FF>【33】矩阵树形图（Treemap）</font></h3><p>矩阵树形图类似于饼图，它可以更好地完成工作而不会误导每个组的贡献。</p><p>【译者 TRHX 注：在使用该方法时要先安装 squarify 库】</p><pre><code class="python"># pip install squarifyimport squarify# Import Datadf_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Prepare Datadf = df_raw.groupby(&#39;class&#39;).size().reset_index(name=&#39;counts&#39;)labels = df.apply(lambda x: str(x[0]) + &quot;\n (&quot; + str(x[1]) + &quot;)&quot;, axis=1)sizes = df[&#39;counts&#39;].values.tolist()colors = [plt.cm.Spectral(i / float(len(labels))) for i in range(len(labels))]# Draw Plotplt.figure(figsize=(12, 8), dpi=80)squarify.plot(sizes=sizes, label=labels, color=colors, alpha=.8)# Decorateplt.title(&#39;Treemap of Vechile Class&#39;)plt.axis(&#39;off&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/38.png" alt="38"></p><h3 id="【34】条形图（Bar-Chart）"><a href="#【34】条形图（Bar-Chart）" class="headerlink" title="【34】条形图（Bar Chart）"></a><font color=##4876FF>【34】条形图（Bar Chart）</font></h3><p>条形图是一种基于计数或任何给定度量的可视化项的经典方法。在下面的图表中，我为每个项目使用了不同的颜色，但您通常可能希望为所有项目选择一种颜色，除非您按组对它们进行着色。颜色名称存储在下面代码中的 <code>all_colors</code> 中。您可以通过在 <code>plt.plot()</code> 中设置 <code>color</code> 参数来更改条形的颜色。</p><pre><code class="python">import random# Import Datadf_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Prepare Datadf = df_raw.groupby(&#39;manufacturer&#39;).size().reset_index(name=&#39;counts&#39;)n = df[&#39;manufacturer&#39;].unique().__len__()+1all_colors = list(plt.cm.colors.cnames.keys())random.seed(100)c = random.choices(all_colors, k=n)# Plot Barsplt.figure(figsize=(16,10), dpi= 80)plt.bar(df[&#39;manufacturer&#39;], df[&#39;counts&#39;], color=c, width=.5)for i, val in enumerate(df[&#39;counts&#39;].values):    plt.text(i, val, float(val), horizontalalignment=&#39;center&#39;, verticalalignment=&#39;bottom&#39;, fontdict=&#123;&#39;fontweight&#39;:500, &#39;size&#39;:12&#125;)# Decorationplt.gca().set_xticklabels(df[&#39;manufacturer&#39;], rotation=60, horizontalalignment= &#39;right&#39;)plt.title(&quot;Number of Vehicles by Manaufacturers&quot;, fontsize=22)plt.ylabel(&#39;# Vehicles&#39;)plt.ylim(0, 45)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/39.png" alt="39"></p><h2 id="【8x00】变化（Change）"><a href="#【8x00】变化（Change）" class="headerlink" title="【8x00】变化（Change）"></a><font color=#FF0000>【8x00】变化（Change）</font></h2><h3 id="【35】时间序列图（Time-Series-Plot）"><a href="#【35】时间序列图（Time-Series-Plot）" class="headerlink" title="【35】时间序列图（Time Series Plot）"></a><font color=##4876FF>【35】时间序列图（Time Series Plot）</font></h3><p>时间序列图用于可视化给定指标随时间的变化。在这里你可以看到 1949 年到 1969 年间的航空客运量是如何变化的。</p><pre><code class="python"># Import Datadf = pd.read_csv(&#39;https://github.com/selva86/datasets/raw/master/AirPassengers.csv&#39;)# Draw Plotplt.figure(figsize=(16, 10), dpi=80)plt.plot(&#39;date&#39;, &#39;traffic&#39;, data=df, color=&#39;tab:red&#39;)# Decorationplt.ylim(50, 750)xtick_location = df.index.tolist()[::12]xtick_labels = [x[-4:] for x in df.date.tolist()[::12]]plt.xticks(ticks=xtick_location, labels=xtick_labels, rotation=0, fontsize=12, horizontalalignment=&#39;center&#39;, alpha=.7)plt.yticks(fontsize=12, alpha=.7)plt.title(&quot;Air Passengers Traffic (1949 - 1969)&quot;, fontsize=22)plt.grid(axis=&#39;both&#39;, alpha=.3)# Remove bordersplt.gca().spines[&quot;top&quot;].set_alpha(0.0)plt.gca().spines[&quot;bottom&quot;].set_alpha(0.3)plt.gca().spines[&quot;right&quot;].set_alpha(0.0)plt.gca().spines[&quot;left&quot;].set_alpha(0.3)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/40.png" alt="40"></p><h3 id="【36】带波峰和波谷注释的时间序列图（Time-Series-with-Peaks-and-Troughs-Annotated）"><a href="#【36】带波峰和波谷注释的时间序列图（Time-Series-with-Peaks-and-Troughs-Annotated）" class="headerlink" title="【36】带波峰和波谷注释的时间序列图（Time Series with Peaks and Troughs Annotated）"></a><font color=##4876FF>【36】带波峰和波谷注释的时间序列图（Time Series with Peaks and Troughs Annotated）</font></h3><p>下面的时间序列绘制了所有的波峰和波谷，并注释了所选特殊事件的发生。</p><pre><code class="python"># Import Datadf = pd.read_csv(&#39;https://github.com/selva86/datasets/raw/master/AirPassengers.csv&#39;)# Get the Peaks and Troughsdata = df[&#39;traffic&#39;].valuesdoublediff = np.diff(np.sign(np.diff(data)))peak_locations = np.where(doublediff == -2)[0] + 1doublediff2 = np.diff(np.sign(np.diff(-1 * data)))trough_locations = np.where(doublediff2 == -2)[0] + 1# Draw Plotplt.figure(figsize=(16, 10), dpi=80)plt.plot(&#39;date&#39;, &#39;traffic&#39;, data=df, color=&#39;tab:blue&#39;, label=&#39;Air Traffic&#39;)plt.scatter(df.date[peak_locations], df.traffic[peak_locations], marker=mpl.markers.CARETUPBASE, color=&#39;tab:green&#39;,            s=100, label=&#39;Peaks&#39;)plt.scatter(df.date[trough_locations], df.traffic[trough_locations], marker=mpl.markers.CARETDOWNBASE, color=&#39;tab:red&#39;,            s=100, label=&#39;Troughs&#39;)# Annotatefor t, p in zip(trough_locations[1::5], peak_locations[::3]):    plt.text(df.date[p], df.traffic[p] + 15, df.date[p], horizontalalignment=&#39;center&#39;, color=&#39;darkgreen&#39;)    plt.text(df.date[t], df.traffic[t] - 35, df.date[t], horizontalalignment=&#39;center&#39;, color=&#39;darkred&#39;)# Decorationplt.ylim(50, 750)xtick_location = df.index.tolist()[::6]xtick_labels = df.date.tolist()[::6]plt.xticks(ticks=xtick_location, labels=xtick_labels, rotation=90, fontsize=12, alpha=.7)plt.title(&quot;Peak and Troughs of Air Passengers Traffic (1949 - 1969)&quot;, fontsize=22)plt.yticks(fontsize=12, alpha=.7)# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(.0)plt.gca().spines[&quot;bottom&quot;].set_alpha(.3)plt.gca().spines[&quot;right&quot;].set_alpha(.0)plt.gca().spines[&quot;left&quot;].set_alpha(.3)plt.legend(loc=&#39;upper left&#39;)plt.grid(axis=&#39;y&#39;, alpha=.3)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/41.png" alt="41"></p><h3 id="【37】自相关-ACF-和部分自相关-PACF-图（Autocorrelation-ACF-and-Partial-Autocorrelation-PACF-Plot）"><a href="#【37】自相关-ACF-和部分自相关-PACF-图（Autocorrelation-ACF-and-Partial-Autocorrelation-PACF-Plot）" class="headerlink" title="【37】自相关 (ACF) 和部分自相关 (PACF) 图（Autocorrelation (ACF) and Partial Autocorrelation (PACF) Plot）"></a><font color=##4876FF>【37】自相关 (ACF) 和部分自相关 (PACF) 图（Autocorrelation (ACF) and Partial Autocorrelation (PACF) Plot）</font></h3><p>自相关图（ACF图）显示了时间序列与其自身滞后的相关性。 每条垂直线（在自相关图上）表示系列与滞后 0 之间的滞后的相关性。图中的蓝色阴影区域是显著性级别。 那些位于蓝线之上的滞后是显著的滞后。</p><p>那么如何解释呢？</p><p>对于航空乘客来说，我们看到超过 14 个滞后已经越过蓝线，因此意义重大。这意味着，14 年前的航空客运量对今天的交通量产生了影响。 </p><p>另一方面，部分自相关图（PACF）显示了任何给定滞后（时间序列）相对于当前序列的自相关，但消除了中间滞后的贡献。</p><pre><code class="python">from statsmodels.graphics.tsaplots import plot_acf, plot_pacf# Import Datadf = pd.read_csv(&#39;https://github.com/selva86/datasets/raw/master/AirPassengers.csv&#39;)# Draw Plotfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6), dpi=80)plot_acf(df.traffic.tolist(), ax=ax1, lags=50)plot_pacf(df.traffic.tolist(), ax=ax2, lags=20)# Decorate# lighten the bordersax1.spines[&quot;top&quot;].set_alpha(.3); ax2.spines[&quot;top&quot;].set_alpha(.3)ax1.spines[&quot;bottom&quot;].set_alpha(.3); ax2.spines[&quot;bottom&quot;].set_alpha(.3)ax1.spines[&quot;right&quot;].set_alpha(.3); ax2.spines[&quot;right&quot;].set_alpha(.3)ax1.spines[&quot;left&quot;].set_alpha(.3); ax2.spines[&quot;left&quot;].set_alpha(.3)# font size of tick labelsax1.tick_params(axis=&#39;both&#39;, labelsize=12)ax2.tick_params(axis=&#39;both&#39;, labelsize=12)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/42.png" alt="42"></p><h3 id="【38】交叉相关图（Cross-Correlation-plot）"><a href="#【38】交叉相关图（Cross-Correlation-plot）" class="headerlink" title="【38】交叉相关图（Cross Correlation plot）"></a><font color=##4876FF>【38】交叉相关图（Cross Correlation plot）</font></h3><p>交叉相关图显示了两个时间序列相互之间的滞后。</p><pre><code class="python">import statsmodels.tsa.stattools as stattools# Import Datadf = pd.read_csv(&#39;https://github.com/selva86/datasets/raw/master/mortality.csv&#39;)x = df[&#39;mdeaths&#39;]y = df[&#39;fdeaths&#39;]# Compute Cross Correlationsccs = stattools.ccf(x, y)[:100]nlags = len(ccs)# Compute the Significance level# ref: https://stats.stackexchange.com/questions/3115/cross-correlation-significance-in-r/3128#3128conf_level = 2 / np.sqrt(nlags)# Draw Plotplt.figure(figsize=(12, 7), dpi=80)plt.hlines(0, xmin=0, xmax=100, color=&#39;gray&#39;)  # 0 axisplt.hlines(conf_level, xmin=0, xmax=100, color=&#39;gray&#39;)plt.hlines(-conf_level, xmin=0, xmax=100, color=&#39;gray&#39;)plt.bar(x=np.arange(len(ccs)), height=ccs, width=.3)# Decorationplt.title(&#39;$Cross\; Correlation\; Plot:\; mdeaths\; vs\; fdeaths$&#39;, fontsize=22)plt.xlim(0, len(ccs))plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/43.png" alt="43"></p><h3 id="【39】时间序列分解图（Time-Series-Decomposition-Plot）"><a href="#【39】时间序列分解图（Time-Series-Decomposition-Plot）" class="headerlink" title="【39】时间序列分解图（Time Series Decomposition Plot）"></a><font color=##4876FF>【39】时间序列分解图（Time Series Decomposition Plot）</font></h3><p>时间序列分解图将时间序列分解为趋势、季节和残差分量。</p><pre><code class="python">from statsmodels.tsa.seasonal import seasonal_decomposefrom dateutil.parser import parse# Import Datadf = pd.read_csv(&#39;https://github.com/selva86/datasets/raw/master/AirPassengers.csv&#39;)dates = pd.DatetimeIndex([parse(d).strftime(&#39;%Y-%m-01&#39;) for d in df[&#39;date&#39;]])df.set_index(dates, inplace=True)# Decomposeresult = seasonal_decompose(df[&#39;traffic&#39;], model=&#39;multiplicative&#39;)# Plotplt.rcParams.update(&#123;&#39;figure.figsize&#39;: (10, 10)&#125;)result.plot().suptitle(&#39;Time Series Decomposition of Air Passengers&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/44.png" alt="44"></p><h3 id="【40】多重时间序列（Multiple-Time-Series）"><a href="#【40】多重时间序列（Multiple-Time-Series）" class="headerlink" title="【40】多重时间序列（Multiple Time Series）"></a><font color=##4876FF>【40】多重时间序列（Multiple Time Series）</font></h3><p>您可以在同一图表上绘制多个测量相同值的时间序列，如下所示。</p><pre><code class="python"># Import Datadf = pd.read_csv(&#39;https://github.com/selva86/datasets/raw/master/mortality.csv&#39;)# Define the upper limit, lower limit, interval of Y axis and colorsy_LL = 100y_UL = int(df.iloc[:, 1:].max().max() * 1.1)y_interval = 400mycolors = [&#39;tab:red&#39;, &#39;tab:blue&#39;, &#39;tab:green&#39;, &#39;tab:orange&#39;]# Draw Plot and Annotatefig, ax = plt.subplots(1, 1, figsize=(16, 9), dpi=80)columns = df.columns[1:]for i, column in enumerate(columns):    plt.plot(df.date.values, df[column].values, lw=1.5, color=mycolors[i])    plt.text(df.shape[0] + 1, df[column].values[-1], column, fontsize=14, color=mycolors[i])# Draw Tick linesfor y in range(y_LL, y_UL, y_interval):    plt.hlines(y, xmin=0, xmax=71, colors=&#39;black&#39;, alpha=0.3, linestyles=&quot;--&quot;, lw=0.5)# Decorationsplt.tick_params(axis=&quot;both&quot;, which=&quot;both&quot;, bottom=False, top=False,                labelbottom=True, left=False, right=False, labelleft=True)# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(.3)plt.gca().spines[&quot;bottom&quot;].set_alpha(.3)plt.gca().spines[&quot;right&quot;].set_alpha(.3)plt.gca().spines[&quot;left&quot;].set_alpha(.3)plt.title(&#39;Number of Deaths from Lung Diseases in the UK (1974-1979)&#39;, fontsize=22)plt.yticks(range(y_LL, y_UL, y_interval), [str(y) for y in range(y_LL, y_UL, y_interval)], fontsize=12)plt.xticks(range(0, df.shape[0], 12), df.date.values[::12], horizontalalignment=&#39;left&#39;, fontsize=12)plt.ylim(y_LL, y_UL)plt.xlim(-2, 80)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/45.png" alt="45"></p><h3 id="【41】使用次要的-Y-轴来绘制不同范围的图形（Plotting-with-different-scales-using-secondary-Y-axis）"><a href="#【41】使用次要的-Y-轴来绘制不同范围的图形（Plotting-with-different-scales-using-secondary-Y-axis）" class="headerlink" title="【41】使用次要的 Y 轴来绘制不同范围的图形（Plotting with different scales using secondary Y axis）"></a><font color=##4876FF>【41】使用次要的 Y 轴来绘制不同范围的图形（Plotting with different scales using secondary Y axis）</font></h3><p>如果要显示在同一时间点测量两个不同数量的两个时间序列，则可以在右侧的次要 Y 轴上再绘制第二个系列。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/economics.csv&quot;)x = df[&#39;date&#39;]y1 = df[&#39;psavert&#39;]y2 = df[&#39;unemploy&#39;]# Plot Line1 (Left Y Axis)fig, ax1 = plt.subplots(1, 1, figsize=(16, 9), dpi=80)ax1.plot(x, y1, color=&#39;tab:red&#39;)# Plot Line2 (Right Y Axis)ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axisax2.plot(x, y2, color=&#39;tab:blue&#39;)# Decorations# ax1 (left Y axis)ax1.set_xlabel(&#39;Year&#39;, fontsize=20)ax1.tick_params(axis=&#39;x&#39;, rotation=0, labelsize=12)ax1.set_ylabel(&#39;Personal Savings Rate&#39;, color=&#39;tab:red&#39;, fontsize=20)ax1.tick_params(axis=&#39;y&#39;, rotation=0, labelcolor=&#39;tab:red&#39;)ax1.grid(alpha=.4)# ax2 (right Y axis)ax2.set_ylabel(&quot;# Unemployed (1000&#39;s)&quot;, color=&#39;tab:blue&#39;, fontsize=20)ax2.tick_params(axis=&#39;y&#39;, labelcolor=&#39;tab:blue&#39;)ax2.set_xticks(np.arange(0, len(x), 60))ax2.set_xticklabels(x[::60], rotation=90, fontdict=&#123;&#39;fontsize&#39;: 10&#125;)ax2.set_title(&quot;Personal Savings Rate vs Unemployed: Plotting in Secondary Y Axis&quot;, fontsize=22)fig.tight_layout()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/46.png" alt="46"></p><h3 id="【42】带误差带的时间序列（Time-Series-with-Error-Bands）"><a href="#【42】带误差带的时间序列（Time-Series-with-Error-Bands）" class="headerlink" title="【42】带误差带的时间序列（Time Series with Error Bands）"></a><font color=##4876FF>【42】带误差带的时间序列（Time Series with Error Bands）</font></h3><p>如果您有一个时间序列数据集，其中每个时间点（日期/时间戳）有多个观测值，则可以构造具有误差带的时间序列。下面您可以看到一些基于一天中不同时间的订单的示例。还有一个关于45天内到达的订单数量的例子。</p><p>在这种方法中，订单数量的平均值用白线表示。并计算95%的置信区间，并围绕平均值绘制。</p><pre><code class="python">from scipy.stats import sem# Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/user_orders_hourofday.csv&quot;)df_mean = df.groupby(&#39;order_hour_of_day&#39;).quantity.mean()df_se = df.groupby(&#39;order_hour_of_day&#39;).quantity.apply(sem).mul(1.96)# Plotplt.figure(figsize=(16, 10), dpi=80)plt.ylabel(&quot;# Orders&quot;, fontsize=16)x = df_mean.indexplt.plot(x, df_mean, color=&quot;white&quot;, lw=2)plt.fill_between(x, df_mean - df_se, df_mean + df_se, color=&quot;#3F5D7D&quot;)# Decorations# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(0)plt.gca().spines[&quot;bottom&quot;].set_alpha(1)plt.gca().spines[&quot;right&quot;].set_alpha(0)plt.gca().spines[&quot;left&quot;].set_alpha(1)plt.xticks(x[::2], [str(d) for d in x[::2]], fontsize=12)plt.title(&quot;User Orders by Hour of Day (95% confidence)&quot;, fontsize=22)plt.xlabel(&quot;Hour of Day&quot;)s, e = plt.gca().get_xlim()plt.xlim(s, e)# Draw Horizontal Tick linesfor y in range(8, 20, 2):    plt.hlines(y, xmin=s, xmax=e, colors=&#39;black&#39;, alpha=0.5, linestyles=&quot;--&quot;, lw=0.5)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/47.png" alt="47"></p><pre><code class="python">&quot;Data Source: https://www.kaggle.com/olistbr/brazilian-ecommerce#olist_orders_dataset.csv&quot;from dateutil.parser import parsefrom scipy.stats import sem# Import Datadf_raw = pd.read_csv(&#39;https://raw.githubusercontent.com/selva86/datasets/master/orders_45d.csv&#39;,                     parse_dates=[&#39;purchase_time&#39;, &#39;purchase_date&#39;])# Prepare Data: Daily Mean and SE Bandsdf_mean = df_raw.groupby(&#39;purchase_date&#39;).quantity.mean()df_se = df_raw.groupby(&#39;purchase_date&#39;).quantity.apply(sem).mul(1.96)# Plotplt.figure(figsize=(16, 10), dpi=80)plt.ylabel(&quot;# Daily Orders&quot;, fontsize=16)x = [d.date().strftime(&#39;%Y-%m-%d&#39;) for d in df_mean.index]plt.plot(x, df_mean, color=&quot;white&quot;, lw=2)plt.fill_between(x, df_mean - df_se, df_mean + df_se, color=&quot;#3F5D7D&quot;)# Decorations# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(0)plt.gca().spines[&quot;bottom&quot;].set_alpha(1)plt.gca().spines[&quot;right&quot;].set_alpha(0)plt.gca().spines[&quot;left&quot;].set_alpha(1)plt.xticks(x[::6], [str(d) for d in x[::6]], fontsize=12)plt.title(&quot;Daily Order Quantity of Brazilian Retail with Error Bands (95% confidence)&quot;, fontsize=20)# Axis limitss, e = plt.gca().get_xlim()plt.xlim(s, e - 2)plt.ylim(4, 10)# Draw Horizontal Tick linesfor y in range(5, 10, 1):    plt.hlines(y, xmin=s, xmax=e, colors=&#39;black&#39;, alpha=0.5, linestyles=&quot;--&quot;, lw=0.5)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/48.png" alt="48"></p><h3 id="【43】堆积面积图（Stacked-Area-Chart）"><a href="#【43】堆积面积图（Stacked-Area-Chart）" class="headerlink" title="【43】堆积面积图（Stacked Area Chart）"></a><font color=##4876FF>【43】堆积面积图（Stacked Area Chart）</font></h3><p>堆积面积图提供了多个时间序列的贡献程度的可视化表示，以便相互比较。</p><pre><code class="python"># Import Datadf = pd.read_csv(&#39;https://raw.githubusercontent.com/selva86/datasets/master/nightvisitors.csv&#39;)# Decide Colorsmycolors = [&#39;tab:red&#39;, &#39;tab:blue&#39;, &#39;tab:green&#39;, &#39;tab:orange&#39;, &#39;tab:brown&#39;, &#39;tab:grey&#39;, &#39;tab:pink&#39;, &#39;tab:olive&#39;]# Draw Plot and Annotatefig, ax = plt.subplots(1, 1, figsize=(16, 9), dpi=80)columns = df.columns[1:]labs = columns.values.tolist()# Prepare datax = df[&#39;yearmon&#39;].values.tolist()y0 = df[columns[0]].values.tolist()y1 = df[columns[1]].values.tolist()y2 = df[columns[2]].values.tolist()y3 = df[columns[3]].values.tolist()y4 = df[columns[4]].values.tolist()y5 = df[columns[5]].values.tolist()y6 = df[columns[6]].values.tolist()y7 = df[columns[7]].values.tolist()y = np.vstack([y0, y2, y4, y6, y7, y5, y1, y3])# Plot for each columnlabs = columns.values.tolist()ax = plt.gca()ax.stackplot(x, y, labels=labs, colors=mycolors, alpha=0.8)# Decorationsax.set_title(&#39;Night Visitors in Australian Regions&#39;, fontsize=18)ax.set(ylim=[0, 100000])ax.legend(fontsize=10, ncol=4)plt.xticks(x[::5], fontsize=10, horizontalalignment=&#39;center&#39;)plt.yticks(np.arange(10000, 100000, 20000), fontsize=10)plt.xlim(x[0], x[-1])# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(0)plt.gca().spines[&quot;bottom&quot;].set_alpha(.3)plt.gca().spines[&quot;right&quot;].set_alpha(0)plt.gca().spines[&quot;left&quot;].set_alpha(.3)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/49.png" alt="49"></p><h3 id="【44】未堆积面积图（Area-Chart-UnStacked）"><a href="#【44】未堆积面积图（Area-Chart-UnStacked）" class="headerlink" title="【44】未堆积面积图（Area Chart UnStacked）"></a><font color=##4876FF>【44】未堆积面积图（Area Chart UnStacked）</font></h3><p>未堆积的面积图用于可视化两个或多个序列彼此之间的进度（起伏）。在下面的图表中，你可以清楚地看到，随着失业持续时间的中位数增加，个人储蓄率是如何下降的。未堆积面积图很好地展示了这一现象。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/economics.csv&quot;)# Prepare Datax = df[&#39;date&#39;].values.tolist()y1 = df[&#39;psavert&#39;].values.tolist()y2 = df[&#39;uempmed&#39;].values.tolist()mycolors = [&#39;tab:red&#39;, &#39;tab:blue&#39;, &#39;tab:green&#39;, &#39;tab:orange&#39;, &#39;tab:brown&#39;, &#39;tab:grey&#39;, &#39;tab:pink&#39;, &#39;tab:olive&#39;]columns = [&#39;psavert&#39;, &#39;uempmed&#39;]# Draw Plotfig, ax = plt.subplots(1, 1, figsize=(16, 9), dpi=80)ax.fill_between(x, y1=y1, y2=0, label=columns[1], alpha=0.5, color=mycolors[1], linewidth=2)ax.fill_between(x, y1=y2, y2=0, label=columns[0], alpha=0.5, color=mycolors[0], linewidth=2)# Decorationsax.set_title(&#39;Personal Savings Rate vs Median Duration of Unemployment&#39;, fontsize=18)ax.set(ylim=[0, 30])ax.legend(loc=&#39;best&#39;, fontsize=12)plt.xticks(x[::50], fontsize=10, horizontalalignment=&#39;center&#39;)plt.yticks(np.arange(2.5, 30.0, 2.5), fontsize=10)plt.xlim(-10, x[-1])# Draw Tick linesfor y in np.arange(2.5, 30.0, 2.5):    plt.hlines(y, xmin=0, xmax=len(x), colors=&#39;black&#39;, alpha=0.3, linestyles=&quot;--&quot;, lw=0.5)# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(0)plt.gca().spines[&quot;bottom&quot;].set_alpha(.3)plt.gca().spines[&quot;right&quot;].set_alpha(0)plt.gca().spines[&quot;left&quot;].set_alpha(.3)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/50.png" alt="50"></p><h3 id="【45】日历热力图（Calendar-Heat-Map）"><a href="#【45】日历热力图（Calendar-Heat-Map）" class="headerlink" title="【45】日历热力图（Calendar Heat Map）"></a><font color=##4876FF>【45】日历热力图（Calendar Heat Map）</font></h3><p>与时间序列相比，日历地图是另一种基于时间的数据可视化的不太受欢迎的方法。虽然在视觉上很吸引人，但数值并不十分明显。然而，它能很好地描绘极端值和假日效果。</p><p>【译者 TRHX 注：在使用该方法时要先安装 calmap 库】</p><pre><code class="python">import matplotlib as mplimport calmap# Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/yahoo.csv&quot;, parse_dates=[&#39;date&#39;])df.set_index(&#39;date&#39;, inplace=True)# Plotplt.figure(figsize=(16, 10), dpi=80)calmap.calendarplot(df[&#39;2014&#39;][&#39;VIX.Close&#39;], fig_kws=&#123;&#39;figsize&#39;: (16, 10)&#125;,                    yearlabel_kws=&#123;&#39;color&#39;: &#39;black&#39;, &#39;fontsize&#39;: 14&#125;, subplot_kws=&#123;&#39;title&#39;: &#39;Yahoo Stock Prices&#39;&#125;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/51.png" alt="51"></p><h3 id="【46】季节图（Seasonal-Plot）"><a href="#【46】季节图（Seasonal-Plot）" class="headerlink" title="【46】季节图（Seasonal Plot）"></a><font color=##4876FF>【46】季节图（Seasonal Plot）</font></h3><p>季节图可用于比较上一季度同一天（年/月/周等）时间序列的表现。</p><pre><code class="python">from dateutil.parser import parse# Import Datadf = pd.read_csv(&#39;https://github.com/selva86/datasets/raw/master/AirPassengers.csv&#39;)# Prepare datadf[&#39;year&#39;] = [parse(d).year for d in df.date]df[&#39;month&#39;] = [parse(d).strftime(&#39;%b&#39;) for d in df.date]years = df[&#39;year&#39;].unique()# 译者 TRHX 添加了该行代码df.rename(columns=&#123;&#39;value&#39;: &#39;traffic&#39;&#125;, inplace=True)# Draw Plotmycolors = [&#39;tab:red&#39;, &#39;tab:blue&#39;, &#39;tab:green&#39;, &#39;tab:orange&#39;, &#39;tab:brown&#39;, &#39;tab:grey&#39;, &#39;tab:pink&#39;, &#39;tab:olive&#39;,            &#39;deeppink&#39;, &#39;steelblue&#39;, &#39;firebrick&#39;, &#39;mediumseagreen&#39;]plt.figure(figsize=(16, 10), dpi=80)for i, y in enumerate(years):    plt.plot(&#39;month&#39;, &#39;traffic&#39;, data=df.loc[df.year == y, :], color=mycolors[i], label=y)    plt.text(df.loc[df.year == y, :].shape[0] - .9, df.loc[df.year == y, &#39;traffic&#39;][-1:].values[0], y, fontsize=12,             color=mycolors[i])# Decorationplt.ylim(50, 750)plt.xlim(-0.3, 11)plt.ylabel(&#39;$Air Traffic$&#39;)plt.yticks(fontsize=12, alpha=.7)plt.title(&quot;Monthly Seasonal Plot: Air Passengers Traffic (1949 - 1969)&quot;, fontsize=22)plt.grid(axis=&#39;y&#39;, alpha=.3)# Remove bordersplt.gca().spines[&quot;top&quot;].set_alpha(0.0)plt.gca().spines[&quot;bottom&quot;].set_alpha(0.5)plt.gca().spines[&quot;right&quot;].set_alpha(0.0)plt.gca().spines[&quot;left&quot;].set_alpha(0.5)# plt.legend(loc=&#39;upper right&#39;, ncol=2, fontsize=12)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/52.png" alt="52"></p><h2 id="【9x00】分组（-Groups）"><a href="#【9x00】分组（-Groups）" class="headerlink" title="【9x00】分组（ Groups）"></a><font color=#FF0000>【9x00】分组（ Groups）</font></h2><h3 id="【47】树状图（Dendrogram）"><a href="#【47】树状图（Dendrogram）" class="headerlink" title="【47】树状图（Dendrogram）"></a><font color=##4876FF>【47】树状图（Dendrogram）</font></h3><p>树状图根据给定的距离度量将相似的点组合在一起，并根据点的相似性将它们组织成树状链接。</p><pre><code class="python">import scipy.cluster.hierarchy as shc# Import Datadf = pd.read_csv(&#39;https://raw.githubusercontent.com/selva86/datasets/master/USArrests.csv&#39;)# Plotplt.figure(figsize=(16, 10), dpi=80)plt.title(&quot;USArrests Dendograms&quot;, fontsize=22)dend = shc.dendrogram(shc.linkage(df[[&#39;Murder&#39;, &#39;Assault&#39;, &#39;UrbanPop&#39;, &#39;Rape&#39;]], method=&#39;ward&#39;), labels=df.State.values,                      color_threshold=100)plt.xticks(fontsize=12)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/53.png" alt="53"></p><h3 id="【48】聚类图（Cluster-Plot）"><a href="#【48】聚类图（Cluster-Plot）" class="headerlink" title="【48】聚类图（Cluster Plot）"></a><font color=##4876FF>【48】聚类图（Cluster Plot）</font></h3><p>聚类图可以用来划分属于同一个聚类的点。下面是一个基于 USArrests 数据集将美国各州分成 5 组的代表性示例。这个聚类图使用 ‘murder’ 和 ‘assault’ 作为 X 轴和 Y 轴。或者，您可以将第一个主元件用作 X 轴和 Y 轴。</p><p>【译者 TRHX 注：在使用该方法时要先安装 sklearn 库】</p><pre><code class="python">from sklearn.cluster import AgglomerativeClusteringfrom scipy.spatial import ConvexHull# Import Datadf = pd.read_csv(&#39;https://raw.githubusercontent.com/selva86/datasets/master/USArrests.csv&#39;)# Agglomerative Clusteringcluster = AgglomerativeClustering(n_clusters=5, affinity=&#39;euclidean&#39;, linkage=&#39;ward&#39;)cluster.fit_predict(df[[&#39;Murder&#39;, &#39;Assault&#39;, &#39;UrbanPop&#39;, &#39;Rape&#39;]])# Plotplt.figure(figsize=(14, 10), dpi=80)plt.scatter(df.iloc[:, 0], df.iloc[:, 1], c=cluster.labels_, cmap=&#39;tab10&#39;)# Encircledef encircle(x, y, ax=None, **kw):    if not ax: ax = plt.gca()    p = np.c_[x, y]    hull = ConvexHull(p)    poly = plt.Polygon(p[hull.vertices,:], **kw)    ax.add_patch(poly)# Draw polygon surrounding verticesencircle(df.loc[cluster.labels_ == 0, &#39;Murder&#39;], df.loc[cluster.labels_ == 0, &#39;Assault&#39;], ec=&quot;k&quot;, fc=&quot;gold&quot;, alpha=0.2, linewidth=0)encircle(df.loc[cluster.labels_ == 1, &#39;Murder&#39;], df.loc[cluster.labels_ == 1, &#39;Assault&#39;], ec=&quot;k&quot;, fc=&quot;tab:blue&quot;, alpha=0.2, linewidth=0)encircle(df.loc[cluster.labels_ == 2, &#39;Murder&#39;], df.loc[cluster.labels_ == 2, &#39;Assault&#39;], ec=&quot;k&quot;, fc=&quot;tab:red&quot;, alpha=0.2, linewidth=0)encircle(df.loc[cluster.labels_ == 3, &#39;Murder&#39;], df.loc[cluster.labels_ == 3, &#39;Assault&#39;], ec=&quot;k&quot;, fc=&quot;tab:green&quot;, alpha=0.2, linewidth=0)encircle(df.loc[cluster.labels_ == 4, &#39;Murder&#39;], df.loc[cluster.labels_ == 4, &#39;Assault&#39;], ec=&quot;k&quot;, fc=&quot;tab:orange&quot;, alpha=0.2, linewidth=0)# Decorationsplt.xlabel(&#39;Murder&#39;); plt.xticks(fontsize=12)plt.ylabel(&#39;Assault&#39;); plt.yticks(fontsize=12)plt.title(&#39;Agglomerative Clustering of USArrests (5 Groups)&#39;, fontsize=22)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/54.png" alt="54"></p><h3 id="【49】安德鲁斯曲线（Andrews-Curve）"><a href="#【49】安德鲁斯曲线（Andrews-Curve）" class="headerlink" title="【49】安德鲁斯曲线（Andrews Curve）"></a><font color=##4876FF>【49】安德鲁斯曲线（Andrews Curve）</font></h3><p>安德鲁斯曲线有助于可视化是否存在基于给定分组的数值特征的固有分组。如果特征（数据集中的列）不能帮助区分组（cyl），则行将不会像下图所示被很好地分隔开。</p><pre><code class="python">from pandas.plotting import andrews_curves# Importdf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mtcars.csv&quot;)df.drop([&#39;cars&#39;, &#39;carname&#39;], axis=1, inplace=True)# Plotplt.figure(figsize=(12, 9), dpi=80)andrews_curves(df, &#39;cyl&#39;, colormap=&#39;Set1&#39;)# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(0)plt.gca().spines[&quot;bottom&quot;].set_alpha(.3)plt.gca().spines[&quot;right&quot;].set_alpha(0)plt.gca().spines[&quot;left&quot;].set_alpha(.3)plt.title(&#39;Andrews Curves of mtcars&#39;, fontsize=22)plt.xlim(-3, 3)plt.grid(alpha=0.3)plt.xticks(fontsize=12)plt.yticks(fontsize=12)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/55.png" alt="55"></p><h3 id="【50】平行坐标图（Parallel-Coordinates）"><a href="#【50】平行坐标图（Parallel-Coordinates）" class="headerlink" title="【50】平行坐标图（Parallel Coordinates）"></a><font color=##4876FF>【50】平行坐标图（Parallel Coordinates）</font></h3><p>平行坐标有助于可视化功能是否有助于有效地隔离组。如果一个分离受到影响，则该特征可能在预测该组时非常有用。</p><pre><code class="python">from pandas.plotting import parallel_coordinates# Import Datadf_final = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/diamonds_filter.csv&quot;)# Plotplt.figure(figsize=(12, 9), dpi=80)parallel_coordinates(df_final, &#39;cut&#39;, colormap=&#39;Dark2&#39;)# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(0)plt.gca().spines[&quot;bottom&quot;].set_alpha(.3)plt.gca().spines[&quot;right&quot;].set_alpha(0)plt.gca().spines[&quot;left&quot;].set_alpha(.3)plt.title(&#39;Parallel Coordinated of Diamonds&#39;, fontsize=22)plt.grid(alpha=0.3)plt.xticks(fontsize=12)plt.yticks(fontsize=12)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/56.png" alt="56"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本译文首发于 CSDN，作者 Selva Prabhakaran，译者 TRHX。本文链接：https://itrhx.blog.csdn.net/article/details/106558131原文链接：https://www.machinelearningplus.com/plots/top-50-matplotlib-visualizations-the-master-plots-python/</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Matplotlib 系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itbob.cn/article/014/&quot;&gt;Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.itbob.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="Matplotlib" scheme="https://www.itbob.cn/tags/Matplotlib/"/>
    
    <category term="数据分析" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据分析三剑客之 Matplotlib（十）：3D 图的绘制</title>
    <link href="https://www.itbob.cn/article/023/"/>
    <id>https://www.itbob.cn/article/023/</id>
    <published>2020-06-07T16:00:08.000Z</published>
    <updated>2022-05-22T12:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Matplotlib 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/014/">Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</a></li><li><a href="https://www.itbob.cn/article/015/">Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/016/">Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/017/">Python 数据分析三剑客之 Matplotlib（四）：线性图的绘制</a></li><li><a href="https://www.itbob.cn/article/018/">Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制</a></li><li><a href="https://www.itbob.cn/article/019/">Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制</a></li><li><a href="https://www.itbob.cn/article/020/">Python 数据分析三剑客之 Matplotlib（七）：饼状图的绘制</a></li><li><a href="https://www.itbob.cn/article/021/">Python 数据分析三剑客之 Matplotlib（八）：等高线 / 等值线图的绘制</a></li><li><a href="https://www.itbob.cn/article/022/">Python 数据分析三剑客之 Matplotlib（九）：极区图 / 极坐标图 / 雷达图的绘制</a></li><li><a href="https://www.itbob.cn/article/023/">Python 数据分析三剑客之 Matplotlib（十）：3D 图的绘制</a></li><li><a href="https://www.itbob.cn/article/024/">Python 数据分析三剑客之 Matplotlib（十一）：最热门最常用的 50 个图表</a>【译文】</li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106558131未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】了解-mplot3d-Toolkit"><a href="#【01x00】了解-mplot3d-Toolkit" class="headerlink" title="【01x00】了解 mplot3d Toolkit"></a><font color=#FF0000>【01x00】了解 mplot3d Toolkit</font></h2><p>mplot3d Toolkit 即 mplot3d 工具包，在 matplotlib 中使用 mplot3d 工具包可以绘制 3D 图。</p><p>mplot3d 官方文档：<a href="https://matplotlib.org/tutorials/toolkits/mplot3d.html">https://matplotlib.org/tutorials/toolkits/mplot3d.html</a></p><p>在 matplotlib 中，figure 为画布，axes 为绘图区，<code>fig.add_subplot()</code>、<code>plt.subplot()</code> 方法均可以创建子图，在绘制 3D 图时，某些 2D 图的参数也适用于 3D 图，在本文的示例中，可能会用到的一些没有具体解释的函数或者参数，其用法均可在前面的系列文章中找到：</p><ul><li><p><a href="https://itrhx.blog.csdn.net/article/details/105638122">《Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件》</a> </p></li><li><p><a href="https://itrhx.blog.csdn.net/article/details/105828049">《Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性》</a></p></li><li><p><a href="https://itrhx.blog.csdn.net/article/details/105828143">《Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性》</a></p></li></ul><p><font color=#FF0000><strong>绘制 3D 图的步骤：创建 Axes3D 对象，然后调用 Axes3D 的不同方法来绘制不同类型的 3D 图。以下介绍三种 Axes3D 对象创建的方法。</strong></font></p><h3 id="【01x01】Axes3D-对象创建方法一：Axes3D-fig"><a href="#【01x01】Axes3D-对象创建方法一：Axes3D-fig" class="headerlink" title="【01x01】Axes3D 对象创建方法一：Axes3D(fig)"></a><font color=##4876FF>【01x01】Axes3D 对象创建方法一：Axes3D(fig)</font></h3><p>在 Matplotlib 1.0.0 版本中，绘制 3D 图需要先导入 Axes3D 包，获取 figure 画布对象 fig 后，通过 Axes3D(fig) 方法来创建 Axes3D 对象，具体方法如下：</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3D# 获取 figure 画布并创建 Axes3D 对象fig = plt.figure()ax = Axes3D(fig)# 数据坐标z = np.linspace(0, 15, 1000)x = np.sin(z)y = np.cos(z)# 绘制线性图ax.plot(x, y, z)plt.show()</code></pre><h3 id="【01x02】Axes3D-对象创建方法二：add-subplot"><a href="#【01x02】Axes3D-对象创建方法二：add-subplot" class="headerlink" title="【01x02】Axes3D 对象创建方法二：add_subplot"></a><font color=##4876FF>【01x02】Axes3D 对象创建方法二：add_subplot</font></h3><p>在 Matplotlib 3.2.0 版本中，绘制 3D 图可以通过创建子图，然后指定 projection 参数 为 3d 即可，返回的 ax 为 Axes3D 对象，以下两种方法均可：</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as plt# 获取 figure 画布并通过子图创建 Axes3D 对象fig = plt.figure()ax = fig.add_subplot(111, projection=&#39;3d&#39;)# 数据坐标z = np.linspace(0, 15, 1000)x = np.sin(z)y = np.cos(z)# 绘制线性图ax.plot(x, y, z)plt.show()</code></pre><pre><code class="python">import numpy as npimport matplotlib.pyplot as plt# 通过子图创建 Axes3D 对象ax = plt.subplot(111, projection=&#39;3d&#39;)# 数据坐标z = np.linspace(0, 15, 1000)x = np.sin(z)y = np.cos(z)# 绘制线性图ax.plot(x, y, z)plt.show()</code></pre><h3 id="【01x03】Axes3D-对象创建方法三：gca"><a href="#【01x03】Axes3D-对象创建方法三：gca" class="headerlink" title="【01x03】Axes3D 对象创建方法三：gca"></a><font color=##4876FF>【01x03】Axes3D 对象创建方法三：gca</font></h3><p>除了以上两种方法以外，还可以先获取画布对象 fig，再通过 <code>fig.gca()</code> 方法获取当前绘图区（gca = Get Current Axes），然后指定 projection 参数 为 3d 即可，返回的 ax 为 Axes3D 对象。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as plt# 依次获取画布和绘图区并创建 Axes3D 对象fig = plt.figure()ax = fig.gca(projection=&#39;3d&#39;)# 数据坐标z = np.linspace(0, 15, 1000)x = np.sin(z)y = np.cos(z)# 绘制线性图ax.plot(x, y, z)plt.show()</code></pre><p>以上三种方法运行结果均为下图：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/01.png" alt="01"></p><h2 id="【02x00】cmap-与-colorbar"><a href="#【02x00】cmap-与-colorbar" class="headerlink" title="【02x00】cmap 与 colorbar"></a><font color=#FF0000>【02x00】cmap 与 colorbar</font></h2><p>默认情况下，散点图、线性图、曲面图等将以纯色着色，但可以通过提供 cmap 参数支持颜色映射。cmap 参数用于设置一些特殊的颜色组合，如渐变色等，参数取值通常为 Colormap 中的值，具体取值可参见下图：</p><p>官方文档：<a href="https://matplotlib.org/tutorials/colors/colormaps.html">https://matplotlib.org/tutorials/colors/colormaps.html</a></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/02.png" alt="02"></p><p>如果使用了 cmap 参数，则可以使用 <code>pyplot.colorbar()</code> 函数来绘制一个色条，即颜色对照条。</p><p>基本语法：<code>matplotlib.pyplot.colorbar([mappable=None, cax=None, ax=None, **kw])</code></p><p>部分参数解释如下表，其他参数，如长度，宽度等请参考<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.colorbar.html">官方文档</a>。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>mappable</td><td>要设置色条的图像对象，该参数对于 <code>Figure.colorbar</code> 方法是必需的，但对于 <code>pyplot.colorbar</code> 函数是可选的</td></tr><tr><td>cax</td><td>可选项，要绘制色条的轴</td></tr><tr><td>ax</td><td>可选项，设置色条的显示位置，通常在一个画布上有多个子图时使用</td></tr><tr><td>**kw</td><td>可选项，其他关键字参数，参考<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.colorbar.html">官方文档</a></td></tr></tbody></table><h2 id="【03x00】3D-线性图：Axes3D-plot"><a href="#【03x00】3D-线性图：Axes3D-plot" class="headerlink" title="【03x00】3D 线性图：Axes3D.plot"></a><font color=#FF0000>【03x00】3D 线性图：Axes3D.plot</font></h2><p>基本方法：<code>Axes3D.plot(xs, ys[, zs, zdir=&#39;z&#39;, *args, **kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>xs</td><td>一维数组，点的 x 轴坐标</td></tr><tr><td>ys</td><td>一维数组，点的 y 轴坐标</td></tr><tr><td>zs</td><td>一维数组，可选项，点的 z 轴坐标</td></tr><tr><td>zdir</td><td>可选项，在 3D 轴上绘制 2D 数据时，数据必须以 xs，ys 的形式传递，<br>若此时将 zdir 设置为 ‘y’，数据将会被绘制到 x-z 轴平面上，默认为 ‘z’</td></tr><tr><td>**kwargs</td><td>其他关键字参数，可选项，可参见 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.plot.html">matplotlib.axes.Axes.plot</a></td></tr></tbody></table><pre><code class="python">import numpy as npimport matplotlib.pyplot as plt# 设置中文显示plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 依次获取画布和绘图区并创建 Axes3D 对象fig = plt.figure()ax = fig.gca(projection=&#39;3d&#39;)# 第一条3D线性图数据theta = np.linspace(-4 * np.pi, 4 * np.pi, 100)z1 = np.linspace(-2, 2, 100)r = z1**2 + 1x1 = r * np.sin(theta)y1 = r * np.cos(theta)# 第二条3D线性图数据z2 = np.linspace(-3, 3, 100)x2 = np.sin(z2)y2 = np.cos(z2)# 绘制3D线性图ax.plot(x1, y1, z1, color=&#39;b&#39;, label=&#39;3D 线性图一&#39;)ax.plot(x2, y2, z2, color=&#39;r&#39;, label=&#39;3D 线性图二&#39;)# 设置标题、轴标签、图例，也可以直接使用 plt.title、plt.xlabel、plt.legend...ax.set_title(&#39;绘制 3D 线性图示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;x 轴&#39;, color=&#39;r&#39;, fontsize=&#39;12&#39;)ax.set_ylabel(&#39;y 轴&#39;, color=&#39;g&#39;, fontsize=&#39;12&#39;)ax.set_zlabel(&#39;z 轴&#39;, color=&#39;b&#39;, fontsize=&#39;12&#39;)ax.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/03.png" alt="03"></p><h2 id="【04x00】3D-散点图：Axes3D-scatter"><a href="#【04x00】3D-散点图：Axes3D-scatter" class="headerlink" title="【04x00】3D 散点图：Axes3D.scatter"></a><font color=#FF0000>【04x00】3D 散点图：Axes3D.scatter</font></h2><p>基本方法：<code>Axes3D.scatter(xs, ys[, zs=0, zdir=&#39;z&#39;, s=20, c=None, depthshade=True, *args, **kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>xs</td><td>一维数组，点的 x 轴坐标</td></tr><tr><td>ys</td><td>一维数组，点的 y 轴坐标</td></tr><tr><td>zs</td><td>一维数组，可选项，点的 z 轴坐标</td></tr><tr><td>zdir</td><td>可选项，在 3D 轴上绘制 2D 数据时，数据必须以 xs，ys 的形式传递，<br>若此时将 zdir 设置为 ‘y’，数据将会被绘制到 x-z 轴平面上，默认为 ‘z’</td></tr><tr><td>s</td><td>标量或数组类型，可选项，标记的大小，默认 20</td></tr><tr><td>c</td><td>标记的颜色，可选项，可以是单个颜色或者一个颜色列表<br>支持英文颜色名称及其简写、十六进制颜色码等，更多颜色示例参见官网 <a href="https://matplotlib.org/gallery/color/color_demo.html">Color Demo</a></td></tr><tr><td>depthshade</td><td>bool 值，可选项，默认 True，是否为散点标记着色以提供深度外观</td></tr><tr><td>**kwargs</td><td>其他关键字参数，可选项，可参见 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.scatter.html">scatter</a></td></tr></tbody></table><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 依次获取画布和绘图区并创建 Axes3D 对象fig = plt.figure()ax = fig.gca(projection=&#39;3d&#39;)n = 100def randrange(n, vmin, vmax):    return (vmax - vmin)*np.random.rand(n) + vmin&#39;&#39;&#39;定义绘制 n 个随机点，设置每一组数据点的样式和范围x轴数据位于[23，32]区间，y轴数据位于[0，100]区间，z轴数据位于[zlow，zhigh]区间&#39;&#39;&#39;for m, zlow, zhigh in [(&#39;o&#39;, -50, -25), (&#39;^&#39;, -30, -5)]:    xs = randrange(n, 23, 32)    ys = randrange(n, 0, 100)    zs = randrange(n, zlow, zhigh)    ax.scatter(xs, ys, zs, marker=m)# 设置标题、轴标签、图例，也可以直接使用 plt.title、plt.xlabel...ax.set_title(&#39;绘制 3D 散点图示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;x 轴&#39;, color=&#39;b&#39;)ax.set_ylabel(&#39;y 轴&#39;, color=&#39;b&#39;)ax.set_zlabel(&#39;z 轴&#39;, color=&#39;b&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/04.png" alt="04"></p><h2 id="【05x00】3D-线框图：Axes3D-plot-wireframe"><a href="#【05x00】3D-线框图：Axes3D-plot-wireframe" class="headerlink" title="【05x00】3D 线框图：Axes3D.plot_wireframe"></a><font color=#FF0000>【05x00】3D 线框图：Axes3D.plot_wireframe</font></h2><p>基本方法：<code>Axes3D.plot_wireframe(X, Y, Z[, *args, **kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>X</td><td>二维数组，x 轴数据</td></tr><tr><td>Y</td><td>二维数组，y 轴数据</td></tr><tr><td>Z</td><td>二维数组，z 轴数据</td></tr><tr><td>**kwargs</td><td>其他关键字参数，可选项，如线条样式颜色等，可参见 <a href="https://matplotlib.org/api/_as_gen/mpl_toolkits.mplot3d.art3d.Line3DCollection.html">Line3DCollection</a></td></tr></tbody></table><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 获取 figure 画布并通过子图创建 Axes3D 对象fig = plt.figure()ax = fig.add_subplot(111, projection=&#39;3d&#39;)# 定义Z轴坐标的生成方法def f(m, n):    return np.sin(np.sqrt(m ** 2 + n ** 2))# 设置3D线框图数据x = np.linspace(-6, 6, 30)y = np.linspace(-6, 6, 30)# 生成网格点坐标矩阵，该方法在系列文章八中有具体介绍X, Y = np.meshgrid(x, y)Z = f(X, Y)# 绘制3D线框图ax.plot_wireframe(X, Y, Z, color=&#39;c&#39;)# 设置标题、轴标签、图例，也可以直接使用 plt.title、plt.xlabel...ax.set_title(&#39;绘制 3D 线框图示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;x 轴&#39;)ax.set_ylabel(&#39;y 轴&#39;)ax.set_zlabel(&#39;z 轴&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/05.png" alt="05"></p><h2 id="【06x00】3D-曲面图：Axes3D-plot-surface"><a href="#【06x00】3D-曲面图：Axes3D-plot-surface" class="headerlink" title="【06x00】3D 曲面图：Axes3D.plot_surface"></a><font color=#FF0000>【06x00】3D 曲面图：Axes3D.plot_surface</font></h2><p>基本方法：<code>Axes3D.plot_surface(X, Y, Z[, *args, vmin=None, vmax=None, **kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>X</td><td>二维数组，x 轴数据</td></tr><tr><td>Y</td><td>二维数组，y 轴数据</td></tr><tr><td>Z</td><td>二维数组，z 轴数据</td></tr><tr><td>vmin / vmax</td><td>规定数据界限</td></tr><tr><td>**kwargs</td><td>其他关键字参数，可选项，如线条样式颜色等，可参见 <a href="https://matplotlib.org/api/_as_gen/mpl_toolkits.mplot3d.art3d.Line3DCollection.html">Line3DCollection</a></td></tr></tbody></table><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 获取 figure 画布并通过子图创建 Axes3D 对象fig = plt.figure()ax = fig.add_subplot(111, projection=&#39;3d&#39;)# 设置3D曲面图数据X = np.arange(-5, 5, 0.25)Y = np.arange(-5, 5, 0.25)# 生成网格点坐标矩阵，该方法在系列文章八中有具体介绍X, Y = np.meshgrid(X, Y)R = np.sqrt(X**2 + Y**2)Z = np.sin(R)# 绘制3D曲面图并添加色条（长度0.8）surface = ax.plot_surface(X, Y, Z, cmap=&#39;rainbow&#39;, antialiased=False)fig.colorbar(surface, shrink=0.8)# 设置标题、轴标签、图例，也可以直接使用 plt.title、plt.xlabel...ax.set_title(&#39;绘制 3D 曲面图示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;x 轴&#39;)ax.set_ylabel(&#39;y 轴&#39;)ax.set_zlabel(&#39;z 轴&#39;)# 调整观察角度和方位角，俯仰角25度，方位角40度ax.view_init(25, 40)# 设置Z轴刻度界限ax.set_zlim(-2, 2)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/06.png" alt="06"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106558131未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【07x00】3D-柱状图：Axes3D-bar"><a href="#【07x00】3D-柱状图：Axes3D-bar" class="headerlink" title="【07x00】3D 柱状图：Axes3D.bar"></a><font color=#FF0000>【07x00】3D 柱状图：Axes3D.bar</font></h2><p>基本方法：<code>Axes3D.bar(left, height, zs=0, zdir=&#39;z&#39;, *args, **kwargs)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>一维数组，柱状图最左侧位置的 x 坐标</td></tr><tr><td>height</td><td>一维数组，柱状图的高度（y 坐标）</td></tr><tr><td>zs</td><td>第 i 个多边形将出现在平面 y=zs[i] 上</td></tr><tr><td>zdir</td><td>可选项，在 3D 轴上绘制 2D 数据时，数据必须以 xs，ys 的形式传递，<br>若此时将 zdir 设置为 ‘y’，数据将会被绘制到 x-z 轴平面上，默认为 ‘z’</td></tr><tr><td>**kwargs</td><td>其他关键字参数，参见 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.bar.html">matplotlib.axes.Axes.bar</a></td></tr></tbody></table><pre><code class="python">import matplotlib.pyplot as pltimport numpy as npplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 获取 figure 画布并通过子图创建 Axes3D 对象fig = plt.figure()ax = fig.add_subplot(111, projection=&#39;3d&#39;)colors = [&#39;r&#39;, &#39;g&#39;, &#39;b&#39;, &#39;y&#39;]yticks = [3, 2, 1, 0]# 设置3D柱状图数据并绘制图像for c, k in zip(colors, yticks):    xs = np.arange(20)    ys = np.random.rand(20)    cs = [c] * len(xs)    ax.bar(xs, ys, zs=k, zdir=&#39;y&#39;, color=cs, alpha=0.8)# 设置图像标题、坐标标签以及范围ax.set_title(&#39;绘制 3D 柱状图示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;X 轴&#39;)ax.set_ylabel(&#39;Y 轴&#39;)ax.set_zlabel(&#39;Z 轴&#39;)ax.set_yticks(yticks)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/07.png" alt="07"></p><h2 id="【08x00】3D-箭头图：Axes3D-quiver"><a href="#【08x00】3D-箭头图：Axes3D-quiver" class="headerlink" title="【08x00】3D 箭头图：Axes3D.quiver"></a><font color=#FF0000>【08x00】3D 箭头图：Axes3D.quiver</font></h2><p>基本方法：<code>Axes3D.quiver(X, Y, Z, U, V, W, length=1, arrow_length_ratio=0.3, pivot=&#39;tail&#39;, normalize=False, **kwargs)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>X, Y, Z</td><td>数组形式，箭头位置的 x、y 和 z 轴坐标（默认为箭头尾部）</td></tr><tr><td>U, V, W</td><td>数组形式，箭头向量的 x、y 和 z 轴分量</td></tr><tr><td>length</td><td>float 类型，每个箭筒的长度，默认为 1.0</td></tr><tr><td>arrow_length_ratio</td><td>float 类型，箭头相对于箭身的比率，默认为 0.3</td></tr><tr><td>pivot</td><td>箭头在网格点上的位置；箭头围绕该点旋转，因此命名为 pivot，默认为 ‘tail’<br>可选项：<code>&#39;tail&#39;</code>：尾部；<code>&#39;middle&#39;</code>：中间；<code>&#39;tip&#39;</code>：尖端</td></tr><tr><td>normalize</td><td>bool 类型，如果为 True，则所有箭头的长度都将相同<br>默认为 False，即箭头的长度取决于 U、V、W 的值</td></tr><tr><td>**kwargs</td><td>其他关键字参数，参见 <a href="https://matplotlib.org/api/collections_api.html#matplotlib.collections.LineCollection">LineCollection</a></td></tr></tbody></table><pre><code class="python">import matplotlib.pyplot as pltimport numpy as npplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 依次获取画布和绘图区并创建 Axes3D 对象fig = plt.figure()ax = fig.gca(projection=&#39;3d&#39;)# 设置箭头位置x, y, z = np.meshgrid(np.arange(-0.8, 1, 0.2),                      np.arange(-0.8, 1, 0.2),                      np.arange(-0.8, 1, 0.8))# 设置箭头数据u = np.sin(np.pi * x) * np.cos(np.pi * y) * np.cos(np.pi * z)v = -np.cos(np.pi * x) * np.sin(np.pi * y) * np.cos(np.pi * z)w = (np.sqrt(2.0 / 3.0) * np.cos(np.pi * x) * np.cos(np.pi * y) * np.sin(np.pi * z))# 绘制 3D 箭头图ax.quiver(x, y, z, u, v, w, length=0.1, normalize=True)# 设置图像标题、坐标标签ax.set_title(&#39;绘制 3D 箭头图示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;X 轴&#39;)ax.set_ylabel(&#39;Y 轴&#39;)ax.set_zlabel(&#39;Z 轴&#39;)# 调整观察角度，俯仰角20度ax.view_init(20)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/08.png" alt="08"></p><h2 id="【09x00】3D-等高线图：Axes3D-contour"><a href="#【09x00】3D-等高线图：Axes3D-contour" class="headerlink" title="【09x00】3D 等高线图：Axes3D.contour"></a><font color=#FF0000>【09x00】3D 等高线图：Axes3D.contour</font></h2><p>基本方法：<code>Axes3D.contour(X, Y, Z[, *args, extend3d=False, stride=5, zdir=&#39;z&#39;, offset=None, **kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>X</td><td>一维数组，x 轴数据</td></tr><tr><td>Y</td><td>一维数组，y 轴数据</td></tr><tr><td>Z</td><td>一维数组，z 轴数据</td></tr><tr><td>extend3d</td><td>bool 值，可选项，是否以 3D 延伸轮廓，默认 False</td></tr><tr><td>stride</td><td>int 类型，可选项，用于延伸轮廓的步长</td></tr><tr><td>zdir</td><td>可选项，在 3D 轴上绘制 2D 数据时，数据必须以 xs，ys 的形式传递，<br>若此时将 zdir 设置为 ‘y’，数据将会被绘制到 x-z 轴平面上，默认为 ‘z’</td></tr><tr><td>offset</td><td>标量，可选项，如果指定，则在垂直于 zdir 的平面上的位置绘制轮廓线的投影</td></tr><tr><td>**kwargs</td><td>其他关键字参数，可选项，可参见 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.contour.html">matplotlib.axes.Axes.contour</a></td></tr></tbody></table><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 获取 figure 画布并通过子图创建 Axes3D 对象fig = plt.figure(figsize=(8, 4.8))ax = fig.add_subplot(111, projection=&#39;3d&#39;)# 设置等高线数据X = np.arange(-2.0, 2.0, 0.01)Y = np.arange(-2.0, 2.0, 0.01)# 生成网格点坐标矩阵m, n = np.meshgrid(X, Y)# 指定一个函数用于计算每个点的高度，也可以直接使用二维数组储存每个点的高度def f(a, b):    return (1 - b ** 5 + a ** 5) * np.exp(-a ** 2 - b ** 2)# 绘制3D等高线图并添加色条图（长度0.8）contour = ax.contour(X, Y, f(m, n), cmap=&#39;rainbow&#39;)fig.colorbar(contour, shrink=0.8)# 设置标题、轴标签、图例，也可以直接使用 plt.title、plt.xlabel...ax.set_title(&#39;绘制 3D 等高线图示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;x 轴&#39;)ax.set_ylabel(&#39;y 轴&#39;)ax.set_zlabel(&#39;z 轴&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/09.png" alt="09"></p><h2 id="【10x00】3D-等高线填充图：Axes3D-contourf"><a href="#【10x00】3D-等高线填充图：Axes3D-contourf" class="headerlink" title="【10x00】3D 等高线填充图：Axes3D.contourf"></a><font color=#FF0000>【10x00】3D 等高线填充图：Axes3D.contourf</font></h2><p>基本语法：<code>Axes3D.contourf(X, Y, Z[, *args, zdir=&#39;z&#39;, offset=None, **kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>X</td><td>一维数组，x 轴数据</td></tr><tr><td>Y</td><td>一维数组，y 轴数据</td></tr><tr><td>Z</td><td>一维数组，z 轴数据</td></tr><tr><td>zdir</td><td>可选项，在 3D 轴上绘制 2D 数据时，数据必须以 xs，ys 的形式传递，<br>若此时将 zdir 设置为 ‘y’，数据将会被绘制到 x-z 轴平面上，默认为 ‘z’</td></tr><tr><td>offset</td><td>标量，可选项，如果指定，则在垂直于 zdir 的平面上的位置绘制轮廓线的投影</td></tr><tr><td>**kwargs</td><td>其他关键字参数，可选项，可参见 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.contourf.html">matplotlib.axes.Axes.contourf</a></td></tr></tbody></table><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 获取 figure 画布并通过子图创建 Axes3D 对象fig = plt.figure(figsize=(8, 4.8))ax = fig.add_subplot(111, projection=&#39;3d&#39;)# 设置等高线数据X = np.arange(-2.0, 2.0, 0.01)Y = np.arange(-2.0, 2.0, 0.01)# 生成网格点坐标矩阵m, n = np.meshgrid(X, Y)# 指定一个函数用于计算每个点的高度，也可以直接使用二维数组储存每个点的高度def f(a, b):    return (1 - b ** 5 + a ** 5) * np.exp(-a ** 2 - b ** 2)# 绘制3D等高线图并添加色条图（长度0.8）contourf = ax.contourf(X, Y, f(m, n), cmap=&#39;rainbow&#39;)fig.colorbar(contourf, shrink=0.8)# 设置标题、轴标签、图例，也可以直接使用 plt.title、plt.xlabel...ax.set_title(&#39;绘制 3D 等高线填充图示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;x 轴&#39;)ax.set_ylabel(&#39;y 轴&#39;)ax.set_zlabel(&#39;z 轴&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/10.png" alt="10"></p><h2 id="【11x00】3D-三角曲面图：Axes3D-plot-trisurf"><a href="#【11x00】3D-三角曲面图：Axes3D-plot-trisurf" class="headerlink" title="【11x00】3D 三角曲面图：Axes3D.plot_trisurf"></a><font color=#FF0000>【11x00】3D 三角曲面图：Axes3D.plot_trisurf</font></h2><p>基本方法：<code>Axes3D.plot_trisurf(X, Y, Z[, *args, color=None, vmin=None, vmax=None, **kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>X</td><td>一维数组，x 轴数据</td></tr><tr><td>Y</td><td>一维数组，y 轴数据</td></tr><tr><td>Z</td><td>一维数组，z 轴数据</td></tr><tr><td>color</td><td>曲面表面的颜色</td></tr><tr><td>vmin / vmax</td><td>规定数据界限</td></tr><tr><td>**kwargs</td><td>可选项，其他关键字参数，可参见 <a href="https://matplotlib.org/api/_as_gen/mpl_toolkits.mplot3d.art3d.Poly3DCollection.html">Poly3DCollection</a></td></tr></tbody></table><pre><code class="python">import matplotlib.pyplot as pltimport numpy as npplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 获取 figure 画布并通过子图创建 Axes3D 对象fig = plt.figure()ax = fig.add_subplot(111, projection=&#39;3d&#39;)n_radii = 8n_angles = 36radii = np.linspace(0.125, 1.0, n_radii)angles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)[..., np.newaxis]x = np.append(0, (radii*np.cos(angles)).flatten())y = np.append(0, (radii*np.sin(angles)).flatten())z = np.sin(-x*y)# 绘制3D三角曲面图并添加色条（长度0.8）trisurf = ax.plot_trisurf(x, y, z, cmap=&#39;rainbow&#39;)fig.colorbar(trisurf, shrink=0.8)# 设置标题、轴标签、图例，也可以直接使用 plt.title、plt.xlabel...ax.set_title(&#39;绘制 3D 三角曲面图示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;x 轴&#39;)ax.set_ylabel(&#39;y 轴&#39;)ax.set_zlabel(&#39;z 轴&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/11.png" alt="11"></p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltimport matplotlib.tri as mtriplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]fig = plt.figure(figsize=(15, 6))# ============ 第一个示例图 ============ #ax = fig.add_subplot(1, 2, 1, projection=&#39;3d&#39;)u = np.linspace(0, 2.0 * np.pi, endpoint=True, num=50)v = np.linspace(-0.5, 0.5, endpoint=True, num=10)u, v = np.meshgrid(u, v)u, v = u.flatten(), v.flatten()x = (1 + 0.5 * v * np.cos(u / 2.0)) * np.cos(u)y = (1 + 0.5 * v * np.cos(u / 2.0)) * np.sin(u)z = 0.5 * v * np.sin(u / 2.0)tri = mtri.Triangulation(u, v)trisurf_1 = ax.plot_trisurf(x, y, z, triangles=tri.triangles, cmap=&#39;cool&#39;)fig.colorbar(trisurf_1, shrink=0.8)ax.set_zlim(-1, 1)ax.set_title(&#39;绘制 3D 三角曲面图示例一&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;x 轴&#39;)ax.set_ylabel(&#39;y 轴&#39;)ax.set_zlabel(&#39;z 轴&#39;)# ============ 第二个示例图 ============ #ax = fig.add_subplot(1, 2, 2, projection=&#39;3d&#39;)n_angles = 36n_radii = 8min_radius = 0.25radii = np.linspace(min_radius, 0.95, n_radii)angles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)angles[:, 1::2] += np.pi/n_anglesx = (radii*np.cos(angles)).flatten()y = (radii*np.sin(angles)).flatten()z = (np.cos(radii)*np.cos(3*angles)).flatten()triang = mtri.Triangulation(x, y)xmid = x[triang.triangles].mean(axis=1)ymid = y[triang.triangles].mean(axis=1)mask = xmid**2 + ymid**2 &lt; min_radius**2triang.set_mask(mask)trisurf_2 = ax.plot_trisurf(triang, z, cmap=&#39;hsv&#39;)fig.colorbar(trisurf_2, shrink=0.8)ax.set_title(&#39;绘制 3D 三角曲面图示例二&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;x 轴&#39;)ax.set_ylabel(&#39;y 轴&#39;)ax.set_zlabel(&#39;z 轴&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/12.png" alt="12"></p><h2 id="【12x00】将-2D-图像聚合到-3D-图像中：Axes3D-add-collection3d"><a href="#【12x00】将-2D-图像聚合到-3D-图像中：Axes3D-add-collection3d" class="headerlink" title="【12x00】将 2D 图像聚合到 3D 图像中：Axes3D.add_collection3d"></a><font color=#FF0000>【12x00】将 2D 图像聚合到 3D 图像中：Axes3D.add_collection3d</font></h2><p>基本方法：<code>Axes3D.add_collection3d(col, zs=0, zdir=&#39;z&#39;)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>col</td><td><a href="https://matplotlib.org/api/collections_api.html?highlight=polycollection#matplotlib.collections.PolyCollection">PolyCollection</a> / <a href="https://matplotlib.org/api/collections_api.html?highlight=linecollection#matplotlib.collections.LineCollection">LineCollection</a> / <a href="https://matplotlib.org/api/collections_api.html?highlight=patchcollection#matplotlib.collections.PatchCollection">PatchCollection</a> 对象</td></tr><tr><td>zs</td><td>第 i 个多边形将出现在平面 y=zs[i] 上</td></tr><tr><td>zdir</td><td>可选项，在 3D 轴上绘制 2D 数据时，数据必须以 xs，ys 的形式传递，<br>若此时将 zdir 设置为 ‘y’，数据将会被绘制到 x-z 轴平面上，默认为 ‘z’</td></tr></tbody></table><p>该函数一般用来向图形中添加 3D 集合对象，以下用一个示例来展示某个地区在不同年份和不同月份的降水量：</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.collections import PolyCollectionplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]fig = plt.figure()ax = fig.gca(projection=&#39;3d&#39;)np.random.seed(59)month = np.arange(0, 13)years = [2017, 2018, 2019, 2020]precipitation = []for year in years:    value = np.random.rand(len(month)) * 300    value[0], value[-1] = 0, 0    precipitation.append(list(zip(month, value)))poly = PolyCollection(precipitation, facecolors=[&#39;r&#39;, &#39;g&#39;, &#39;b&#39;, &#39;y&#39;], alpha=.6)ax.add_collection3d(poly, zs=years, zdir=&#39;y&#39;)ax.set_title(&#39;2D 图像聚合到 3D 图像示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;月份&#39;)ax.set_ylabel(&#39;年份&#39;)ax.set_zlabel(&#39;降水量&#39;)ax.set_xlim3d(0, 12)ax.set_ylim3d(2016, 2021)ax.set_zlim3d(0, 300)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/13.png" alt="13"></p><p>此外，该方法也常被用于绘制 3D 多边形图，即多边体，示例如下：</p><pre><code class="python">import matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection, Line3DCollectionplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]fig = plt.figure()ax = fig.gca(projection=&#39;3d&#39;)# 六面体顶点和面verts = [(0, 0, 0), (0, 1, 0), (1, 1, 0), (1, 0, 0), (0, 0, 1), (0, 1, 1), (1, 1, 1), (1, 0, 1)]faces = [[0, 1, 2, 3], [4, 5, 6, 7], [0, 1, 5, 4], [1, 2, 6, 5], [2, 3, 7, 6], [0, 3, 7, 4]]# 获取每个面的顶点poly3d = [[verts[vert_id] for vert_id in face] for face in faces]# 绘制顶点x, y, z = zip(*verts)ax.scatter(x, y, z)# 绘制多边形面ax.add_collection3d(Poly3DCollection(poly3d, facecolors=&#39;w&#39;, linewidths=1, alpha=0.5))# 绘制多边形的边ax.add_collection3d(Line3DCollection(poly3d, colors=&#39;k&#39;, linewidths=0.5, linestyles=&#39;:&#39;))# 设置图像标题、坐标标签以及范围ax.set_title(&#39;绘制多边体示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;X 轴&#39;)ax.set_ylabel(&#39;Y 轴&#39;)ax.set_zlabel(&#39;Z 轴&#39;)ax.set_xlim3d(-0.5, 1.5)ax.set_ylim3d(-0.5, 1.5)ax.set_zlim3d(-0.5, 1.5)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/14.png" alt="14"></p><h2 id="【13x00】3D-图添加文本描述：Axes3D-text"><a href="#【13x00】3D-图添加文本描述：Axes3D-text" class="headerlink" title="【13x00】3D 图添加文本描述：Axes3D.text"></a><font color=#FF0000>【13x00】3D 图添加文本描述：Axes3D.text</font></h2><p>基本方法：<code>Axes3D.text(x, y, z, s[, zdir=None, **kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>x, y, z</td><td>文本位置的 x、y、z 轴坐标</td></tr><tr><td>s</td><td>要添加的文本</td></tr><tr><td>zdir</td><td>可选项，若将 zdir 设置为 ‘y’，文本将会被投影到 x-z 轴平面上，默认为 None</td></tr><tr><td>**kwargs</td><td>其他关键字参数，参见 <a href="https://matplotlib.org/api/text_api.html">matplotlib.text</a></td></tr></tbody></table><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 依次获取画布和绘图区并创建 Axes3D 对象fig = plt.figure()ax = fig.gca(projection=&#39;3d&#39;)# Demo 1: zdir 参数用法zdirs = (None, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, (1, 1, 0), (1, 1, 1))xs = (1, 4, 4, 9, 4, 1)ys = (2, 5, 8, 10, 1, 2)zs = (10, 3, 8, 9, 1, 8)for zdir, x, y, z in zip(zdirs, xs, ys, zs):    label = &#39;(%d, %d, %d), dir=%s&#39; % (x, y, z, zdir)    ax.text(x, y, z, label, zdir)# Demo 2：设置颜色ax.text(9, 0, 0, &quot;red&quot;, color=&#39;red&#39;)# Demo 3: text2D，位置(0，0)为左下角，(1，1)为右上角。ax.text2D(0.05, 0.95, &quot;2D Text&quot;, transform=ax.transAxes)# 设置坐标轴界限和标签ax.set_xlim(0, 10)ax.set_ylim(0, 10)ax.set_zlim(0, 10)ax.set_xlabel(&#39;X 轴&#39;)ax.set_ylabel(&#39;Y 轴&#39;)ax.set_zlabel(&#39;Z 轴&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/15.png" alt="15"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106558131未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Matplotlib 系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itbob.cn/article/014/&quot;&gt;Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.itbob.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="Matplotlib" scheme="https://www.itbob.cn/tags/Matplotlib/"/>
    
    <category term="数据分析" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据分析三剑客之 Matplotlib（九）：极区图/极坐标图/雷达图的绘制</title>
    <link href="https://www.itbob.cn/article/022/"/>
    <id>https://www.itbob.cn/article/022/</id>
    <published>2020-06-03T10:58:43.000Z</published>
    <updated>2022-05-22T12:34:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Matplotlib 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/014/">Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</a></li><li><a href="https://www.itbob.cn/article/015/">Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/016/">Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/017/">Python 数据分析三剑客之 Matplotlib（四）：线性图的绘制</a></li><li><a href="https://www.itbob.cn/article/018/">Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制</a></li><li><a href="https://www.itbob.cn/article/019/">Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制</a></li><li><a href="https://www.itbob.cn/article/020/">Python 数据分析三剑客之 Matplotlib（七）：饼状图的绘制</a></li><li><a href="https://www.itbob.cn/article/021/">Python 数据分析三剑客之 Matplotlib（八）：等高线 / 等值线图的绘制</a></li><li><a href="https://www.itbob.cn/article/022/">Python 数据分析三剑客之 Matplotlib（九）：极区图 / 极坐标图 / 雷达图的绘制</a></li><li><a href="https://www.itbob.cn/article/023/">Python 数据分析三剑客之 Matplotlib（十）：3D 图的绘制</a></li><li><a href="https://www.itbob.cn/article/024/">Python 数据分析三剑客之 Matplotlib（十一）：最热门最常用的 50 个图表</a>【译文】</li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106162412未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】了解极坐标"><a href="#【1x00】了解极坐标" class="headerlink" title="【1x00】了解极坐标"></a><font color=#FF0000>【1x00】了解极坐标</font></h2><p>参考百度百科：极坐标，属于二维坐标系统，创始人是牛顿，主要应用于数学领域。极坐标是指在平面内取一个定点 <font color=#FF0000>O</font>，叫极点，引一条射线 <font color=#FF0000>Ox</font>，叫做极轴，再选定一个长度单位和角度的正方向（通常取逆时针方向）。对于平面内任何一点 <font color=#FF0000>M</font>，用 <font color=#FF0000>ρ</font> 表示线段 <font color=#FF0000>OM</font> 的长度（有时也用 <font color=#FF0000>r</font> 表示），<font color=#FF0000>θ</font> 表示从 <font color=#FF0000>Ox</font> 到 <font color=#FF0000>OM</font> 的角度，<font color=#FF0000>ρ</font> 叫做点 <font color=#FF0000>M</font> 的极径，<font color=#FF0000>θ</font> 叫做点 <font color=#FF0000>M</font> 的极角，有序数对 <font color=#FF0000>(ρ,θ)</font> 就叫点 <font color=#FF0000>M</font> 的极坐标，这样建立的坐标系叫做极坐标系。通常情况下，<font color=#FF0000>M</font> 的极径坐标单位为 <font color=#FF0000>1</font>（长度单位），极角坐标单位为 <font color=#FF0000>rad</font>（或<font color=#FF0000>°</font>）。</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/01.png" alt="01"></p><h2 id="【2x00】基本方法-matplotlib-pyplot-polar"><a href="#【2x00】基本方法-matplotlib-pyplot-polar" class="headerlink" title="【2x00】基本方法 matplotlib.pyplot.polar()"></a><font color=#FF0000>【2x00】基本方法 matplotlib.pyplot.polar()</font></h2><p><code>matplotlib.pyplot.polar()</code> 方法可用于绘制极坐标图。</p><p>基本语法：<code>polar(theta, r, **kwargs)</code></p><ul><li><font color=#FF0000><strong>theta</strong></font>：点的角坐标，以弧度单位传入参数；</li><li><font color=#FF0000><strong>r</strong></font>：点的半径坐标；</li><li><font color=#FF0000>**<strong>kwargs</strong></font>：可选项，其他 Line2D 属性，常用属性见<font color=#FF0000><strong>表一</strong></font>。</li></ul><p>拓展：数学上通常是用弧度而非角度，弧度单位缩写为 rad，2π rad = 360°，1° ≈ 0.0174533 rad，1 rad ≈ 57.29578°。</p><ul><li>角度转换为弧度公式：弧度 = 角度 ÷ 180 × π</li><li>弧度转换为角度公式：角度 = 弧度 × 180 ÷ π</li></ul><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font color="FF0000" size=3px>表一：Line2D 部分属性，完整属性参见官方文档：<br>https://matplotlib.org/api/_as_gen/matplotlib.lines.Line2D.html</font></strong></td></tr></table><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>alpha</td><td>线条透明度，float 类型，取值范围：<code>[0, 1]</code>，默认为 1.0，即不透明</td></tr><tr><td>antialiased / aa</td><td>是否使用抗锯齿渲染，默认为 True</td></tr><tr><td>color / c</td><td>线条颜色，支持英文颜色名称及其简写、十六进制颜色码等，更多颜色示例参见官网 <a href="https://matplotlib.org/gallery/color/color_demo.html">Color Demo</a></td></tr><tr><td>fillstyle</td><td>点的填充样式，<code>&#39;full&#39;</code>、<code>&#39;left&#39;</code>、<code>&#39;right&#39;</code>、<code>&#39;bottom&#39;</code>、<code>&#39;top&#39;</code>、<code>&#39;none&#39;</code></td></tr><tr><td>label</td><td>图例，具体参数参见：<br><a href="https://itrhx.blog.csdn.net/article/details/105828143">《Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性》</a></td></tr><tr><td>linestyle / ls</td><td>连接的线条样式：<code>&#39;-&#39;</code> or <code>&#39;solid&#39;</code>, <code>&#39;--&#39;</code> or <code>&#39;dashed&#39;</code>, <code>&#39;-.&#39;</code> or <code>&#39;dashdot&#39;</code> <br> <code>&#39;:&#39;</code> or <code>&#39;dotted&#39;</code>, <code>&#39;none&#39;</code> or <code>&#39; &#39;</code> or <code>&#39;&#39;</code></td></tr><tr><td>linewidth / lw</td><td>连接的线条宽度，float 类型，默认 0.8</td></tr><tr><td>marker</td><td>标记样式，具体样式参见<font color=#FF0000><strong>表二</strong></font></td></tr><tr><td>markeredgecolor / mec</td><td>marker 标记的边缘颜色</td></tr><tr><td>markeredgewidth / mew</td><td>marker 标记的边缘宽度</td></tr><tr><td>markerfacecolor / mfc</td><td>marker 标记的颜色</td></tr><tr><td>markerfacecoloralt / mfcalt</td><td>marker 标记的备用颜色</td></tr><tr><td>markersize / ms</td><td>marker 标记的大小</td></tr></tbody></table><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font color="FF0000" size=3px>表二：marker 标记的样式，官方文档：<br>https://matplotlib.org/api/markers_api.html</font></strong></td></tr></table><table><thead><tr><th>标记</th><th>描述</th></tr></thead><tbody><tr><td><code>&quot;.&quot;</code></td><td>点</td></tr><tr><td><code>&quot;,&quot;</code></td><td>像素点</td></tr><tr><td><code>&quot;o&quot;</code></td><td>圆圈</td></tr><tr><td><code>&quot;v&quot;</code></td><td>倒三角</td></tr><tr><td><code>&quot;^&quot;</code></td><td>正三角</td></tr><tr><td><code>&quot;&lt;&quot;</code></td><td>左三角</td></tr><tr><td><code>&quot;&gt;&quot;</code></td><td>右三角</td></tr><tr><td><code>&quot;1&quot;</code></td><td>倒三叉星</td></tr><tr><td><code>&quot;2&quot;</code></td><td>正三叉星（类似奔驰车标形状）</td></tr><tr><td><code>&quot;3&quot;</code></td><td>左三叉星</td></tr><tr><td><code>&quot;4&quot;</code></td><td>右三叉星</td></tr><tr><td><code>&quot;8&quot;</code></td><td>八边形</td></tr><tr><td><code>&quot;s&quot;</code></td><td>正方形</td></tr><tr><td><code>&quot;p&quot;</code></td><td>五边形</td></tr><tr><td><code>&quot;P&quot;</code></td><td>填充的加号（粗加号）</td></tr><tr><td><code>&quot;+&quot;</code></td><td>加号</td></tr><tr><td><code>&quot;*&quot;</code></td><td>星形</td></tr><tr><td><code>&quot;h&quot;</code></td><td>六边形（底部是角）</td></tr><tr><td><code>&quot;H&quot;</code></td><td>六边形（底部是边）</td></tr><tr><td><code>&quot;x&quot;</code></td><td>x 号</td></tr><tr><td><code>&quot;X&quot;</code></td><td>填充的 x 号（粗 x 号）</td></tr><tr><td><code>&quot;D&quot;</code></td><td>粗菱形（对角线相等）</td></tr><tr><td><code>&quot;d&quot;</code></td><td>细菱形（对角线不等）</td></tr><tr><td>`”</td><td>“`</td></tr><tr><td><code>&quot;_&quot;</code></td><td>水平线</td></tr><tr><td><code>0</code></td><td>水平线靠左</td></tr><tr><td><code>1</code></td><td>水平线靠右</td></tr><tr><td><code>2</code></td><td>垂直线靠上</td></tr><tr><td><code>3</code></td><td>垂直线靠下</td></tr><tr><td><code>4</code></td><td>左三角（比 <code>&quot;&lt;&quot;</code> 更细）</td></tr><tr><td><code>5</code></td><td>右三角（比 <code>&quot;&gt;&quot;</code> 更细）</td></tr><tr><td><code>6</code></td><td>正三角（比 <code>&quot;^&quot;</code> 更细）</td></tr><tr><td><code>7</code></td><td>倒三角（比 <code>&quot;v&quot;</code> 更细）</td></tr><tr><td><code>8</code></td><td>左三角（比 <code>&quot;&lt;&quot;</code> 更细，靠左显示）</td></tr><tr><td><code>9</code></td><td>右三角（比 <code>&quot;&gt;&quot;</code> 更细，靠右显示）</td></tr><tr><td><code>10</code></td><td>正三角（比 <code>&quot;^&quot;</code> 更细，靠上显示）</td></tr><tr><td><code>11</code></td><td>倒三角（比 <code>&quot;v&quot;</code> 更细，靠下显示）</td></tr><tr><td><code>&quot;None&quot;</code> / <code>&quot; &quot;</code> / <code>&quot;&quot;</code></td><td>无样式</td></tr><tr><td><code>&#39;$...$&#39;</code></td><td>支持 LaTeX 数学公式，表达式用美元符号包围起来</td></tr></tbody></table><h2 id="【3x00】绘制极坐标"><a href="#【3x00】绘制极坐标" class="headerlink" title="【3x00】绘制极坐标"></a><font color=#FF0000>【3x00】绘制极坐标</font></h2><pre><code class="python">import numpy as npimport matplotlib.pyplot as plt# 设置中文显示plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 设置画布大小plt.figure(figsize=(8.0, 6.0))# 设置三个数据，theta 为点位置的弧度参数，r 为点的半径坐标theta1 = np.array([1.25*np.pi, np.pi/2, 0])theta2 = np.array([-np.pi/6, -np.pi/2, 0, np.pi/2, np.pi])theta3 = np.arange(0., 2*np.pi, 0.5)r1 = np.array([4, 2, 3])r2 = np.array([5, 2, 4, 5, 3])r3 = np.random.randint(0, 5, 13)# 绘制第一个极坐标图，点的标记样式为细菱形，大小为8，点之间的连接线条样式为:plt.polar(theta1, r1, marker=&#39;d&#39;, ms=8, ls=&#39;:&#39;, label=&#39;数据一&#39;)# 填充第一个极坐标图，填充颜色为蓝色，透明度0.3plt.fill(theta1, r1, color=&#39;b&#39;, alpha=0.3)# 绘制第二个极坐标图，marker、linestyle、color 三个参数可以组合以字符串形式传入plt.polar(theta2, r2, &#39;*-g&#39;, ms=10, label=&#39;数据二&#39;)# 绘制第三个极坐标图，设置 linestyle 为 none，即点与点之间不相连plt.polar(theta3, r3, marker=&#39;o&#39;, ls=&#39;none&#39;, ms=8, color=&#39;r&#39;, label=&#39;数据三&#39;)plt.title(&#39;matplotlib.pyplot.polar 用法示例&#39;, pad=25, fontsize=15)plt.legend(bbox_to_anchor=(1.3, 1))plt.show()</code></pre><p>示例中 figure、title、legend 等其他方法的解释可参见我的系列文章：</p><ul><li><a href="https://itrhx.blog.csdn.net/article/details/105638122">《Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件》</a></li><li><a href="https://itrhx.blog.csdn.net/article/details/105828049">《Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性》</a></li><li><a href="https://itrhx.blog.csdn.net/article/details/105828143">《Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性》</a></li></ul><p>绘制结果如下图：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/02.png" alt="02"></p><h2 id="【4x00】绘制雷达图"><a href="#【4x00】绘制雷达图" class="headerlink" title="【4x00】绘制雷达图"></a><font color=#FF0000>【4x00】绘制雷达图</font></h2><p>雷达图是以从同一点开始的轴上表示的三个或更多个定量变量的二维图表的形式显示多变量数据的图形方法。轴的相对位置和角度通常是无信息的。 雷达图也称为网络图，蜘蛛图，星图，蜘蛛网图，不规则多边形，极坐标图或 Kiviat 图。它相当于平行坐标图，轴径向排列。</p><p>在前面的示例中，使用了 <code>matplotlib.pyplot.fill()</code> 方法对三个极坐标点围成的图形进行了填充，这就有点儿接近于雷达图了，仔细观察前面的示例，在填充时第一个点和最后一个点之间没有连线，即没有闭合，而更精确的雷达图应该是闭合的，且外围应该是文字描述而不是度数。</p><p>在绘制雷达图之前需要提前了解一些函数。这些函数可以帮助我们实现闭合、自定义文字标签等。</p><hr><h3 id="【4x01】理解-numpy-concatenate"><a href="#【4x01】理解-numpy-concatenate" class="headerlink" title="【4x01】理解 numpy.concatenate()"></a><font color=##4876FF>【4x01】理解 numpy.concatenate()</font></h3><p><code>numpy.concatenate()</code> 方法用于沿现有轴连接一系列数组，我们可以利用此方法来实现闭合操作。</p><p>基本语法：<code>numpy.concatenate((a1, a2, ...)[, axis=0, out=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a1, a2, …</td><td>要连接的数组，必须拥有相同的维度</td></tr><tr><td>axis</td><td>沿指定轴连接数组，可选项，如果 axis 为 None，则数组在使用前被展平，默认值为 0</td></tr><tr><td>out</td><td>用于接收连接后的数组，可选项</td></tr></tbody></table><p>用法示例：</p><pre><code class="python">import numpy as npa = np.array([1, 2, 3, 4])b = np.array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])print(np.concatenate((a, b)))</code></pre><p>输出结果如下：</p><pre><code class="python">[&#39;1&#39; &#39;2&#39; &#39;3&#39; &#39;4&#39; &#39;a&#39; &#39;b&#39; &#39;c&#39; &#39;d&#39;]</code></pre><p>如果要实现数组的闭合，则可以传入原数组和一个新数组，其中新数组中的元素为原数组中的第一个元素，示例如下：</p><pre><code class="python">import numpy as npa = np.array([1, 2, 3, 4])print(np.concatenate((a, [a[0]])))</code></pre><p>输出结果如下：</p><pre><code class="python">[1 2 3 4 1]</code></pre><hr><h3 id="【4x02】理解-pyplot-thetagrids"><a href="#【4x02】理解-pyplot-thetagrids" class="headerlink" title="【4x02】理解 pyplot.thetagrids()"></a><font color=##4876FF>【4x02】理解 pyplot.thetagrids()</font></h3><p><code>matplotlib.pyplot.thetagrids()</code> 方法用于获取并设置当前极区图上的极轴。</p><p>基本语法：<code>matplotlib.pyplot.thetagrids(angles, labels=None, fmt=None, **kwargs)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>angles</td><td>网格线的角度，浮点数、度数组成的元组</td></tr><tr><td>labels</td><td>每个极轴要使用的文本标签，字符串组成的元组</td></tr><tr><td>fmt</td><td>格式化 angles 参数，如 <code>&#39;%1.2f&#39;</code> 保留两位小数，注意，将使用以弧度为单位的角度</td></tr><tr><td>**kwargs</td><td>其他关键字参数，参见<a href="https://matplotlib.org/api/text_api.html?highlight=text#matplotlib.text.Text">官方文档</a></td></tr></tbody></table><p>应用举例：</p><pre><code class="python"> import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]plt.polar()angles = range(0, 360, 45)labels = (&#39;东&#39;, &#39;东北&#39;, &#39;北&#39;, &#39;西北&#39;, &#39;西&#39;, &#39;西南&#39;, &#39;南&#39;, &#39;东南&#39;)plt.thetagrids(angles, labels)plt.title(&#39;matplotlib.pyplot.thetagrids() 用法示例&#39;, pad=15)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/03.png" alt="03"></p><hr><h3 id="【4x03】绘制雷达图"><a href="#【4x03】绘制雷达图" class="headerlink" title="【4x03】绘制雷达图"></a><font color=##4876FF>【4x03】绘制雷达图</font></h3><p><code>numpy.concatenate()</code> 方法能够解决闭合问题，<code>matplotlib.pyplot.thetagrids()</code> 能够解决自定义极轴和极轴的文本标记问题，因此就可以绘制一个标准的雷达图了。示例如下：</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as plt# 设置中文显示、画布大小plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]plt.figure(figsize=(8.0, 6.0))# 分割圆并执行闭合操作（0-2π之间返回间隔均匀的6个弧度：π/3、2π/3、π、4π/3、5π/3、2π）theta = np.linspace(0, 2*np.pi, 6, endpoint=False)theta = np.concatenate((theta, [theta[0]]))# 设置两组数据并执行闭合操作data1 = np.array([9, 4, 3, 5, 2, 8])data2 = np.array([3, 6, 9, 6, 3, 2])data1 = np.concatenate((data1, [data1[0]]))data2 = np.concatenate((data2, [data2[0]]))# 绘制并填充两组数据plt.polar(theta, data1, &#39;bo-&#39;, label=&#39;小王&#39;)plt.polar(theta, data2, &#39;ro:&#39;, label=&#39;小张&#39;)plt.fill(theta, data1, color=&#39;b&#39;, alpha=0.3)plt.fill(theta, data2, color=&#39;r&#39;, alpha=0.3)# 将六个弧度（π/3、2π/3、π、4π/3、5π/3、2π）转换成角度，并分别设置标签labels = np.array([&#39;Python&#39;, &#39;Golang&#39;, &#39;Java&#39;, &#39;C++&#39;, &#39;PHP&#39;, &#39;JavaScript&#39;])plt.thetagrids(theta * 180/np.pi, labels)# 设置刻度范围、标题、图例plt.ylim(0, 10)plt.title(&#39;编程语言掌握程度&#39;)plt.legend(bbox_to_anchor=(1.3, 1))plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/04.png" alt="04"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106162412未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【5x00】高级用法：绘制极坐标散点图"><a href="#【5x00】高级用法：绘制极坐标散点图" class="headerlink" title="【5x00】高级用法：绘制极坐标散点图"></a><font color=#FF0000>【5x00】高级用法：绘制极坐标散点图</font></h2><p><code>matplotlib.pyplot.polar()</code> 方法可以实现极坐标散点图，但仅用这一个函数的话实现的样式效果并不多，以下介绍另外三种绘制极坐标散点图的方法：</p><ul><li><p><code>matplotlib.pyplot.polar()</code> 和 <code>matplotlib.pyplot.scatter()</code> 结合，前者绘制极坐标图，后者在极坐标图上绘制散点图；</p></li><li><p><code>matplotlib.pyplot.subplot()</code> 和 <code>matplotlib.pyplot.scatter()</code> 结合，前者添加子图，其中指定 <code>projection=&#39;polar&#39;</code> 即为极坐标图， 后者在极坐标图上绘制散点图；</p></li><li><p><code>matplotlib.pyplot.axes()</code> 与 <code>matplotlib.pyplot.scatter()</code> 结合，前者设置绘图区参数，其中指定 <code>projection=&#39;polar&#39;</code> 或 <code>polar=True</code> 即为极坐标图， 后者在极坐标图上绘制散点图。</p></li></ul><hr><h3 id="【5x01】方法一：pyplot-scatter-与-pyplot-polar"><a href="#【5x01】方法一：pyplot-scatter-与-pyplot-polar" class="headerlink" title="【5x01】方法一：pyplot.scatter() 与 pyplot.polar()"></a><font color=##4876FF>【5x01】方法一：pyplot.scatter() 与 pyplot.polar()</font></h3><p>以下用到的 <code>matplotlib.pyplot.scatter()</code> 函数，各参数含义以及支持的其他参数可以参见前文：</p><ul><li><p><a href="https://itrhx.blog.csdn.net/article/details/105828049">《Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性》</a></p></li><li><p><a href="https://itrhx.blog.csdn.net/article/details/105914929">《Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制》</a></p></li></ul><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]N = 50r = 2 * np.random.rand(N)theta = 2 * np.pi * np.random.rand(N)size = 200 * r ** 2colors = N * np.random.rand(N)plt.polar()plt.scatter(theta, r, s=size, c=colors, alpha=0.8)plt.title(&#39;极坐标散点图示例一&#39;, pad=15)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/05.png" alt="05"></p><hr><h3 id="【5x02】方法二：pyplot-scatter-与-pyplot-subplot"><a href="#【5x02】方法二：pyplot-scatter-与-pyplot-subplot" class="headerlink" title="【5x02】方法二：pyplot.scatter() 与 pyplot.subplot()"></a><font color=##4876FF>【5x02】方法二：pyplot.scatter() 与 pyplot.subplot()</font></h3><p><code>matplotlib.pyplot.subplot()</code> 方法用于添加子图，如果想要子图为极坐标图，则需要指定 <code>projection</code> 参数为 <code>polar</code>，有关此函数的具体介绍可参见<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.subplot.html">官方文档</a>。其他函数的参数解释可参考前文：</p><ul><li><p><a href="https://itrhx.blog.csdn.net/article/details/105828143">《Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性》</a></p></li><li><p><a href="https://itrhx.blog.csdn.net/article/details/105914929">《Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制》</a></p></li></ul><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]N = 50r = 2 * np.random.rand(N)theta = 2 * np.pi * np.random.rand(N)size = 200 * r ** 2colors = N * np.random.rand(N)# 一行一列第一个子图plt.subplot(111, projection=&#39;polar&#39;)plt.scatter(theta, r, s=size, c=colors, alpha=0.8)plt.title(&#39;极坐标散点图示例二&#39;, pad=15)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/06.png" alt="06"></p><hr><h3 id="【5x03】方法三：pyplot-scatter-与-pyplot-axes"><a href="#【5x03】方法三：pyplot-scatter-与-pyplot-axes" class="headerlink" title="【5x03】方法三：pyplot.scatter() 与 pyplot.axes()"></a><font color=##4876FF>【5x03】方法三：pyplot.scatter() 与 pyplot.axes()</font></h3><p>axes 为 Matplotlib 图像中的绘图区，<code>matplotlib.pyplot.axes()</code> 方法可以对绘图区进行设置，同样的也可以设置 <code>projection</code> 参数为 <code>polar</code> 来实现极坐标图，设置 <code>polar=True</code> 也行。示例中其他函数的参数解释可参考前文：</p><ul><li><p><a href="https://itrhx.blog.csdn.net/article/details/105638122">《Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件》</a></p></li><li><p><a href="https://itrhx.blog.csdn.net/article/details/105914929">《Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制》</a></p></li></ul><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]N = 50r = 2 * np.random.rand(N)theta = 2 * np.pi * np.random.rand(N)size = 200 * r ** 2colors = N * np.random.rand(N)# plt.axes(polar=True)plt.axes(projection=&#39;polar&#39;)plt.scatter(theta, r, s=size, c=colors, alpha=0.8)plt.title(&#39;极坐标散点图示例三&#39;, pad=15)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/07.png" alt="07"></p><h2 id="【6x00】高级用法：绘制极坐标柱状图"><a href="#【6x00】高级用法：绘制极坐标柱状图" class="headerlink" title="【6x00】高级用法：绘制极坐标柱状图"></a><font color=#FF0000>【6x00】高级用法：绘制极坐标柱状图</font></h2><p>和极坐标散点图的绘制类似，<code>matplotlib.pyplot.polar()</code> 方法可以实现极坐标图，但仅用这一个函数的话实现的样式效果并不多，以下介绍另外三种绘制极坐标柱状图的方法：</p><ul><li><p><code>matplotlib.pyplot.polar()</code> 和 <code>matplotlib.pyplot.bar()</code> 结合，前者绘制极坐标图，后者在极坐标图上绘制柱状图；</p></li><li><p><code>matplotlib.pyplot.subplot()</code> 和 <code>matplotlib.pyplot.bar()</code> 结合，前者添加子图，其中指定 <code>projection=&#39;polar&#39;</code> 即为极坐标图， 后者在极坐标图上绘制柱状图；</p></li><li><p><code>matplotlib.pyplot.axes()</code> 与 <code>matplotlib.pyplot.bar()</code> 结合，前者设置绘图区参数，其中指定 <code>projection=&#39;polar&#39;</code> 或 <code>polar=True</code> 即为极坐标图， 后者在极坐标图上绘制柱状图。</p></li></ul><hr><h3 id="【6x01】方法一：pyplot-bar-与-pyplot-polar"><a href="#【6x01】方法一：pyplot-bar-与-pyplot-polar" class="headerlink" title="【6x01】方法一：pyplot.bar() 与 pyplot.polar()"></a><font color=##4876FF>【6x01】方法一：pyplot.bar() 与 pyplot.polar()</font></h3><p>以下用到的 <code>matplotlib.pyplot.bar()</code> 函数，各参数含义以及支持的其他参数可以参见前文：</p><ul><li><p><a href="https://itrhx.blog.csdn.net/article/details/105828049">《Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性》</a></p></li><li><p><a href="https://itrhx.blog.csdn.net/article/details/105952856">《Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制》</a></p></li></ul><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]r = np.random.rand(8)theta = np.arange(0, 2 * np.pi, 2 * np.pi / 8)colors = np.array([&#39;#4bb2c5&#39;, &#39;#c5b47f&#39;, &#39;#EAA228&#39;, &#39;#579575&#39;, &#39;#839557&#39;, &#39;#958c12&#39;, &#39;#953579&#39;, &#39;#4b5de4&#39;])plt.polar()plt.bar(theta, r, color=colors, alpha=0.8)plt.title(&#39;极坐标柱状图示例一&#39;, pad=15)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/08.png" alt="08"></p><hr><h3 id="【6x02】方法二：pyplot-bar-与-pyplot-subplot"><a href="#【6x02】方法二：pyplot-bar-与-pyplot-subplot" class="headerlink" title="【6x02】方法二：pyplot.bar() 与 pyplot.subplot()"></a><font color=##4876FF>【6x02】方法二：pyplot.bar() 与 pyplot.subplot()</font></h3><p><code>matplotlib.pyplot.subplot()</code> 方法用于添加子图，如果想要子图为极坐标图，则需要指定 <code>projection</code> 参数为 <code>polar</code>，有关此函数的具体介绍可参见<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.subplot.html">官方文档</a>。其他函数的参数解释可参考前文：</p><ul><li><p><a href="https://itrhx.blog.csdn.net/article/details/105828143">《Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性》</a></p></li><li><p><a href="https://itrhx.blog.csdn.net/article/details/105952856">《Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制》</a></p></li></ul><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]r = np.random.rand(8)theta = np.arange(0, 2 * np.pi, 2 * np.pi / 8)colors = np.array([&#39;#4bb2c5&#39;, &#39;#c5b47f&#39;, &#39;#EAA228&#39;, &#39;#579575&#39;, &#39;#839557&#39;, &#39;#958c12&#39;, &#39;#953579&#39;, &#39;#4b5de4&#39;])plt.subplot(111, projection=&#39;polar&#39;)plt.bar(theta, r, color=colors, alpha=0.8)plt.title(&#39;极坐标柱状图示例二&#39;, pad=15)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/09.png" alt="09"></p><hr><h3 id="【6x03】方法三：pyplot-bar-与-pyplot-axes"><a href="#【6x03】方法三：pyplot-bar-与-pyplot-axes" class="headerlink" title="【6x03】方法三：pyplot.bar() 与 pyplot.axes()"></a><font color=##4876FF>【6x03】方法三：pyplot.bar() 与 pyplot.axes()</font></h3><p>axes 为 Matplotlib 图像中的绘图区，<code>matplotlib.pyplot.axes()</code> 方法可以对绘图区进行设置，同样的也可以设置 <code>projection</code> 参数为 <code>polar</code> 来实现极坐标图，设置 <code>polar=True</code> 也行。示例中其他函数的参数解释可参考前文：</p><ul><li><p><a href="https://itrhx.blog.csdn.net/article/details/105638122">《Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件》</a></p></li><li><p><a href="https://itrhx.blog.csdn.net/article/details/105952856">《Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制》</a></p></li></ul><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]r = np.random.rand(8)theta = np.arange(0, 2 * np.pi, 2 * np.pi / 8)colors = np.array([&#39;#4bb2c5&#39;, &#39;#c5b47f&#39;, &#39;#EAA228&#39;, &#39;#579575&#39;, &#39;#839557&#39;, &#39;#958c12&#39;, &#39;#953579&#39;, &#39;#4b5de4&#39;])# plt.axes(polar=True)plt.axes(projection=&#39;polar&#39;)plt.bar(theta, r, color=colors, alpha=0.8)plt.title(&#39;极坐标柱状图示例三&#39;, pad=15)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/10.png" alt="10"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106162412未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Matplotlib 系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itbob.cn/article/014/&quot;&gt;Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.itbob.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="Matplotlib" scheme="https://www.itbob.cn/tags/Matplotlib/"/>
    
    <category term="数据分析" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据分析三剑客之 Matplotlib（八）：等高线/等值线图的绘制</title>
    <link href="https://www.itbob.cn/article/021/"/>
    <id>https://www.itbob.cn/article/021/</id>
    <published>2020-05-12T14:35:53.000Z</published>
    <updated>2022-05-22T12:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Matplotlib 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/014/">Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</a></li><li><a href="https://www.itbob.cn/article/015/">Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/016/">Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/017/">Python 数据分析三剑客之 Matplotlib（四）：线性图的绘制</a></li><li><a href="https://www.itbob.cn/article/018/">Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制</a></li><li><a href="https://www.itbob.cn/article/019/">Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制</a></li><li><a href="https://www.itbob.cn/article/020/">Python 数据分析三剑客之 Matplotlib（七）：饼状图的绘制</a></li><li><a href="https://www.itbob.cn/article/021/">Python 数据分析三剑客之 Matplotlib（八）：等高线 / 等值线图的绘制</a></li><li><a href="https://www.itbob.cn/article/022/">Python 数据分析三剑客之 Matplotlib（九）：极区图 / 极坐标图 / 雷达图的绘制</a></li><li><a href="https://www.itbob.cn/article/023/">Python 数据分析三剑客之 Matplotlib（十）：3D 图的绘制</a></li><li><a href="https://www.itbob.cn/article/024/">Python 数据分析三剑客之 Matplotlib（十一）：最热门最常用的 50 个图表</a>【译文】</li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106066852未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】等高线概念"><a href="#【1x00】等高线概念" class="headerlink" title="【1x00】等高线概念"></a><font color=#FF0000>【1x00】等高线概念</font></h2><p>参考百度百科，等高线概念总结如下：等高线指的是地形图上高程相等的相邻各点所连成的闭合曲线。把地面上海拔高度相同的点连成的闭合曲线，并垂直投影到一个水平面上，并按比例缩绘在图纸上，就得到等高线。等高线也可以看作是不同海拔高度的水平面与实际地面的交线，所以等高线是闭合曲线。在等高线上标注的数字为该等高线的海拔。</p><ul><li>位于同一等高线上的地面点，海拔高度相同。但海拔高度相同的点不一定位于同一条等高线上；</li><li>在同一幅图内，除了陡崖以外，不同高程的等高线不能相交；</li><li>在图廓内相邻等高线的高差一般是相同的，因此地面坡度与等高线之间的等高线平距成反比，等高线平距愈小，等高线排列越密，说明地面坡度越大；等高线平距愈大，等高线排列越稀，则说明地面坡度愈小；</li><li>等高线是一条闭合的曲线，如果不能在同一幅内闭合，则必在相邻或者其他图幅内闭合。</li><li>等高线经过山脊或山谷时改变方向，因此，山脊线或者山谷线应垂直于等高线转折点处的切线，即等高线与山脊线或者山谷线正交。</li></ul><p><font color=#FF0000><strong>在 Matplotlib 等高线的绘制中，需要传递三个基本参数：某个点的 x、y 轴坐标以及其高度。</strong></font></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A75/01.png" alt="01"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A75/02.png" alt="02"></p><h2 id="【2x00】理解-numpy-meshgrid"><a href="#【2x00】理解-numpy-meshgrid" class="headerlink" title="【2x00】理解 numpy.meshgrid()"></a><font color=#FF0000>【2x00】理解 numpy.meshgrid()</font></h2><p><code>numpy.meshgrid()</code> 方法用于生成网格点坐标矩阵。</p><pre><code class="python">import numpy as npa = np.array([1, 2, 3])b = np.array([7, 8, 9])res = np.meshgrid(a, b)print(res)</code></pre><p>输出结果：</p><pre><code class="python">[array([[1, 2, 3],       [1, 2, 3],       [1, 2, 3]]), array([[7, 7, 7],       [8, 8, 8],       [9, 9, 9]])]</code></pre><p>给定两个数组，<code>a[1, 2, 3]</code> 和 <code>b[7, 8, 9]</code>，a 作为 x 轴数据，b 作为 y 轴数据，那么一共可以绘制出 9 个点： (1,7)、(1,8)、(1,9)、(2,7)、(2,8)、(2,9)、(3,7)、(3,8)、(3,9)，而 <code>numpy.meshgrid()</code> 方法就是起这样的作用，返回的两个二维数组，横坐标矩阵 a 中的每个元素，与纵坐标矩阵 b 中对应位置元素，共同构成一个点的完整坐标。</p><p><font color=#FF0000><strong>因为在 <code>matplotlib.pyplot.contour()</code> 等高线绘制函数中接收的是二维坐标信息，所以在绘制等高线图之前要将原数据经过 <code>numpy.meshgrid()</code> 方法处理，也可以自己构建类似于上述的二维数组。</strong></font></p><p><img src="https://img-blog.csdnimg.cn/20200512112427932.png" alt="分割线"></p><h2 id="【3x00】绘制方法-matplotlib-pyplot-contour"><a href="#【3x00】绘制方法-matplotlib-pyplot-contour" class="headerlink" title="【3x00】绘制方法 matplotlib.pyplot.contour()"></a><font color=#FF0000>【3x00】绘制方法 matplotlib.pyplot.contour()</font></h2><p><code>matplotlib.pyplot.contour()</code> 方法可用于绘制等高线图。</p><p>基本语法：<code>matplotlib.pyplot.contour(\*args, data=None, \*\*kwargs)</code></p><p>通用格式：<code>matplotlib.pyplot.contour([X, Y,] Z, [levels], **kwargs)</code></p><p>基本参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>X, Y</td><td>数组形式的点的 x 和 y 轴坐标，两者都必须是二维的，形状与 Z 相同</td></tr><tr><td>Z</td><td>绘制轮廓的高度值，二维数组，每个元素是其对应点的高度</td></tr><tr><td>levels</td><td>确定等高线的数目和位置，如果是整数 N，则使用 N 个数据间隔，即绘制 N+1 条等高线<br>如果是数组形式，则绘制指定的等高线。值必须按递增顺序排列</td></tr></tbody></table><p>其他参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>colors</td><td>等高线的颜色，颜色字符串或颜色序列</td></tr><tr><td>cmap</td><td>等高线的颜色，字符串或者 <a href="https://matplotlib.org/tutorials/colors/colormaps.html">Colormap</a><br>通常包含一系列的渐变色或其他颜色组合，取值参见<font color=#FF0000><strong>【6x00】Colormap 取值</strong></font></td></tr><tr><td>alpha</td><td>透明度，介于0（透明）和1（不透明）之间</td></tr><tr><td>origin</td><td>通过指定 Z[0，0] 的位置来确定 Z 的方向和确切位置，仅当未指定 X, Y 时才有意义<br><code>None</code>：Z[0，0] 位于左下角的 X=0, Y=0 处<br><code>&#39;lower&#39;</code>：Z [0, 0] 位于左下角的 X = 0.5, Y = 0.5 处<br><code>&#39;upper&#39;</code>：Z[0，0] 位于左上角的 X=N+0.5, Y=0.5 处<br><code>&#39;image&#39;</code>：使用 <code>rcParams[“image.origin”] = &#39;upper&#39;</code>的值</td></tr><tr><td>antialiased</td><td>是否启用抗锯齿渲染，默认 True</td></tr><tr><td>linewidths</td><td>等高线的线宽，如果是数字，则所有等高线都将使用此线宽<br>如果是序列，则将按指定的顺序以升序打印线宽<br>默认为 <code>rcParams[“lines.linewidth”] = 1.5</code></td></tr><tr><td>linestyles</td><td>等高线的样式，如果线条颜色为单色，则负等高线默认为虚线<br><code>&#39;-&#39;</code> or <code>&#39;solid&#39;</code>, <code>&#39;--&#39;</code> or <code>&#39;dashed&#39;</code>, <code>&#39;-.&#39;</code> or <code>&#39;dashdot&#39;</code> <code>&#39;:&#39;</code> or <code>&#39;dotted&#39;</code>, <code>&#39;none&#39;</code> or <code>&#39; &#39;</code> or <code>&#39;&#39;</code></td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20200512112427932.png" alt="分割线"></p><h2 id="【4x00】填充方法-matplotlib-pyplot-contourf"><a href="#【4x00】填充方法-matplotlib-pyplot-contourf" class="headerlink" title="【4x00】填充方法 matplotlib.pyplot.contourf()"></a><font color=#FF0000>【4x00】填充方法 matplotlib.pyplot.contourf()</font></h2><p><code>matplotlib.pyplot.contourf()</code> 方法与 <code>matplotlib.pyplot.contour()</code> 的区别在于：<code>contourf()</code> 会对等高线间的区域进行颜色填充（filled contours）。除此之外两者的函数签名和返回值都相同。</p><p>基本语法：<code>matplotlib.pyplot.contourf(\*args, data=None, \*\*kwargs)</code></p><p>通用格式：<code>matplotlib.pyplot.contour([X, Y,] Z, [levels], **kwargs)</code></p><p>基本参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>X, Y</td><td>数组形式的点的 x 和 y 轴坐标，两者都必须是二维的，形状与 Z 相同</td></tr><tr><td>Z</td><td>绘制轮廓的高度值，二维数组，每个元素是其对应点的高度</td></tr><tr><td>levels</td><td>确定等高线的数目和位置，如果是整数 N，则使用 N 个数据间隔，即绘制 N+1 条等高线<br>如果是数组形式，则绘制指定的等高线。值必须按递增顺序排列</td></tr></tbody></table><p>其他参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>colors</td><td>等高线的填充颜色，颜色字符串或颜色序列</td></tr><tr><td>cmap</td><td>等高线的填充颜色，字符串或者 <a href="https://matplotlib.org/tutorials/colors/colormaps.html">Colormap</a><br>通常包含一系列的渐变色或其他颜色组合，取值参见<font color=#FF0000><strong>【6x00】Colormap 取值</strong></font></td></tr><tr><td>alpha</td><td>透明度，介于0（透明）和1（不透明）之间</td></tr><tr><td>origin</td><td>通过指定 Z[0，0] 的位置来确定 Z 的方向和确切位置，仅当未指定 X, Y 时才有意义<br><code>None</code>：Z[0，0] 位于左下角的 X=0, Y=0 处<br><code>&#39;lower&#39;</code>：Z [0, 0] 位于左下角的 X = 0.5, Y = 0.5 处<br><code>&#39;upper&#39;</code>：Z[0，0] 位于左上角的 X=N+0.5, Y=0.5 处<br><code>&#39;image&#39;</code>：使用 <code>rcParams[“image.origin”] = &#39;upper&#39;</code>的值</td></tr><tr><td>antialiased</td><td>是否启用抗锯齿渲染，默认 True</td></tr><tr><td>linewidths</td><td>等高线的线宽，如果是数字，则所有等高线都将使用此线宽<br>如果是序列，则将按指定的顺序以升序打印线宽<br>默认为 <code>rcParams[“lines.linewidth”] = 1.5</code></td></tr><tr><td>linestyles</td><td>等高线的样式，如果线条颜色为单色，则负等高线默认为虚线<br><code>&#39;-&#39;</code> or <code>&#39;solid&#39;</code>, <code>&#39;--&#39;</code> or <code>&#39;dashed&#39;</code>, <code>&#39;-.&#39;</code> or <code>&#39;dashdot&#39;</code> <code>&#39;:&#39;</code> or <code>&#39;dotted&#39;</code>, <code>&#39;none&#39;</code> or <code>&#39; &#39;</code> or <code>&#39;&#39;</code></td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20200512180336350.png" alt="分割线"></p><h2 id="【5x00】标记方法-matplotlib-pyplot-clabel"><a href="#【5x00】标记方法-matplotlib-pyplot-clabel" class="headerlink" title="【5x00】标记方法 matplotlib.pyplot.clabel()"></a><font color=#FF0000>【5x00】标记方法 matplotlib.pyplot.clabel()</font></h2><p><code>matplotlib.pyplot.clabel(CS, \*args, \*\*kwargs)</code> 方法可用于标记等高线图。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>CS</td><td>ContourSet（等高线集）对象，即 <code>pyplot.contour()</code> 返回的对象</td></tr><tr><td>levels</td><td>需要标记的等高线集，数组类型，如果未指定则默认标记所有等高线</td></tr><tr><td>fontsize</td><td>标记的字体大小，可选项：<br><code>&#39;xx-small&#39;</code>, <code>&#39;x-small&#39;</code>, <code>&#39;small&#39;</code>, <code>&#39;medium&#39;</code>, <code>&#39;large&#39;</code>, <code>&#39;x-large&#39;</code>, <code>&#39;xx-large&#39;</code></td></tr><tr><td>colors</td><td>标记的颜色，颜色字符串或颜色序列</td></tr><tr><td>inline</td><td>是否在标签位置移除轮廓显示，bool 类型，默认 True</td></tr><tr><td>inline_spacing</td><td>标签位置移除轮廓的宽度，float 类型，默认为 5</td></tr><tr><td>fmt</td><td>标签的格式字符串。str 或 dict 类型，默认值为 <code>%1.3f</code></td></tr><tr><td>rightside_up</td><td>是否将标签旋转始终与水平面成正负90度，bool 类型，默认 True</td></tr><tr><td>use_clabeltext</td><td>默认为 False，如果为 True，则使用 <a href="https://matplotlib.org/api/contour_api.html#matplotlib.contour.ClabelText">ClabelText</a> 类（而不是 <a href="https://matplotlib.org/api/text_api.html#matplotlib.text.Text">Text</a>）创建标签<br>ClabelText  在绘图期间重新计算文本的旋转角度，如果轴的角度发生变化，则可以使用此功能</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20200512112427932.png" alt="分割线"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106066852未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【6x00】Colormap-取值"><a href="#【6x00】Colormap-取值" class="headerlink" title="【6x00】Colormap 取值"></a><font color=#FF0000>【6x00】Colormap 取值</font></h2><p><code>matplotlib.pyplot.contour()</code> 和 <code>matplotlib.pyplot.contourf()</code> 中 <code>cmap</code> 参数用于设置等高线的颜色，取值通常为 Colormap 中的值，通常包含一系列的渐变色或其他颜色组合。具体参加下图。</p><p>官方文档：<a href="https://matplotlib.org/tutorials/colors/colormaps.html">https://matplotlib.org/tutorials/colors/colormaps.html</a></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A75/03.png" alt="03"></p><p><img src="https://img-blog.csdnimg.cn/20200512112427932.png" alt="分割线"></p><h2 id="【7x00】简单示例"><a href="#【7x00】简单示例" class="headerlink" title="【7x00】简单示例"></a><font color=#FF0000>【7x00】简单示例</font></h2><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(-2.0, 2.0, 0.01)y = np.arange(-2.0, 2.0, 0.01)m, n = np.meshgrid(x, y)        # 生成网格点坐标矩阵# 指定一个函数用于计算每个点的高度，也可以直接使用二维数组储存每个点的高度def f(a, b):    return (1 - b ** 5 + a ** 5) * np.exp(-a ** 2 - b ** 2)# 绘制等高线图，8 个数据间隔，颜色为黑色plt.contour(m, n, f(m, n), 8, colors=&#39;k&#39;)plt.title(&#39;等高线图简单示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A75/04.png" alt="04"></p><p><img src="https://img-blog.csdnimg.cn/20200512112427932.png" alt="分割线"></p><h2 id="【8x00】添加标记"><a href="#【8x00】添加标记" class="headerlink" title="【8x00】添加标记"></a><font color=#FF0000>【8x00】添加标记</font></h2><p><code>matplotlib.pyplot.clabel()</code> 方法用于给等高线添加标记。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(-2.0, 2.0, 0.01)y = np.arange(-2.0, 2.0, 0.01)m, n = np.meshgrid(x, y)        # 生成网格点坐标矩阵# 指定一个函数用于计算每个点的高度，也可以直接使用二维数组储存每个点的高度def f(a, b):    return (1 - b ** 5 + a ** 5) * np.exp(-a ** 2 - b ** 2)# 绘制等高线图，8 个数据间隔，颜色为黑色C = plt.contour(m, n, f(m, n), 8, colors=&#39;k&#39;)# 添加标记，标记处不显示轮廓线，颜色为黑红绿蓝四种，保留两位小数plt.clabel(C, inline=True, colors=[&#39;k&#39;, &#39;r&#39;, &#39;g&#39;, &#39;b&#39;], fmt=&#39;%1.2f&#39;)plt.title(&#39;等高线图添加标记示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A75/05.png" alt="05"></p><p><img src="https://img-blog.csdnimg.cn/20200512112427932.png" alt="分割线"></p><h2 id="【9x00】轮廓线颜色和样式"><a href="#【9x00】轮廓线颜色和样式" class="headerlink" title="【9x00】轮廓线颜色和样式"></a><font color=#FF0000>【9x00】轮廓线颜色和样式</font></h2><p><code>matplotlib.pyplot.contour()</code> 方法中，<code>colors</code> 参数即可为等高线轮廓设置颜色，可以是单色，也可以是一个颜色列表，<code>linestyles</code> 参数可以设置轮廓线样式，注意，如果线条颜色为单色，则负等高线（高度值为负）默认为虚线。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(-2.0, 2.0, 0.01)y = np.arange(-2.0, 2.0, 0.01)m, n = np.meshgrid(x, y)        # 生成网格点坐标矩阵# 指定一个函数用于计算每个点的高度，也可以直接使用二维数组储存每个点的高度def f(a, b):    return (1 - b ** 5 + a ** 5) * np.exp(-a ** 2 - b ** 2)colors = [&#39;k&#39;, &#39;r&#39;, &#39;g&#39;, &#39;b&#39;]# 绘制等高线图，8 个数据间隔，颜色为黑色，线条样式为 --C = plt.contour(m, n, f(m, n), 8, colors=colors, linestyles=&#39;--&#39;)# 添加标记，标记处不显示轮廓线，颜色为黑红绿蓝四种，保留两位小数plt.clabel(C, inline=True, colors=colors, fmt=&#39;%1.2f&#39;)plt.title(&#39;等高线图设置颜色/样式示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A75/06.png" alt="06"></p><p>如果想启用渐变色，则可以设置 <code>cmap</code>，取值参见<font color=#FF0000><strong>【6x00】Colormap 取值</strong></font>，<code>colorbar()</code> 方法可以显示颜色对照条。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(-2.0, 2.0, 0.01)y = np.arange(-2.0, 2.0, 0.01)m, n = np.meshgrid(x, y)        # 生成网格点坐标矩阵# 指定一个函数用于计算每个点的高度，也可以直接使用二维数组储存每个点的高度def f(a, b):    return (1 - b ** 5 + a ** 5) * np.exp(-a ** 2 - b ** 2)# 绘制等高线图，8 个数据间隔，颜色为 plasmaC = plt.contour(m, n, f(m, n), 8, cmap=&#39;plasma&#39;)# 添加标记，标记处不显示轮廓线，颜色为黑色，保留两位小数plt.clabel(C, inline=True, colors=&#39;k&#39;, fmt=&#39;%1.2f&#39;)# 显示颜色条plt.colorbar()plt.title(&#39;等高线图设置渐变色示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A75/07.png" alt="07"></p><p><img src="https://img-blog.csdnimg.cn/20200512112427932.png" alt="分割线"></p><h2 id="【10x00】颜色填充"><a href="#【10x00】颜色填充" class="headerlink" title="【10x00】颜色填充"></a><font color=#FF0000>【10x00】颜色填充</font></h2><p><code>matplotlib.pyplot.contourf()</code> 方法用于对等高线之间的地方进行颜色填充。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(-2.0, 2.0, 0.01)y = np.arange(-2.0, 2.0, 0.01)m, n = np.meshgrid(x, y)        # 生成网格点坐标矩阵# 指定一个函数用于计算每个点的高度，也可以直接使用二维数组储存每个点的高度def f(a, b):    return (1 - b ** 5 + a ** 5) * np.exp(-a ** 2 - b ** 2)# 绘制等高线图，8 个数据间隔，颜色为 plasmaplt.contourf(m, n, f(m, n), 8, cmap=&#39;plasma&#39;)C = plt.contour(m, n, f(m, n), 8, cmap=&#39;plasma&#39;)# 添加标记，标记处不显示轮廓线，颜色为黑色，保留两位小数plt.clabel(C, inline=True, colors=&#39;k&#39;, fmt=&#39;%1.2f&#39;)# 显示颜色条plt.colorbar()plt.title(&#39;等高线图颜色填充示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A75/08.png" alt="08"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106066852未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Matplotlib 系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itbob.cn/article/014/&quot;&gt;Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.itbob.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="Matplotlib" scheme="https://www.itbob.cn/tags/Matplotlib/"/>
    
    <category term="数据分析" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据分析三剑客之 Matplotlib（七）：饼状图的绘制</title>
    <link href="https://www.itbob.cn/article/020/"/>
    <id>https://www.itbob.cn/article/020/</id>
    <published>2020-05-11T16:43:20.000Z</published>
    <updated>2022-05-22T12:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Matplotlib 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/014/">Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</a></li><li><a href="https://www.itbob.cn/article/015/">Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/016/">Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/017/">Python 数据分析三剑客之 Matplotlib（四）：线性图的绘制</a></li><li><a href="https://www.itbob.cn/article/018/">Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制</a></li><li><a href="https://www.itbob.cn/article/019/">Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制</a></li><li><a href="https://www.itbob.cn/article/020/">Python 数据分析三剑客之 Matplotlib（七）：饼状图的绘制</a></li><li><a href="https://www.itbob.cn/article/021/">Python 数据分析三剑客之 Matplotlib（八）：等高线 / 等值线图的绘制</a></li><li><a href="https://www.itbob.cn/article/022/">Python 数据分析三剑客之 Matplotlib（九）：极区图 / 极坐标图 / 雷达图的绘制</a></li><li><a href="https://www.itbob.cn/article/023/">Python 数据分析三剑客之 Matplotlib（十）：3D 图的绘制</a></li><li><a href="https://www.itbob.cn/article/024/">Python 数据分析三剑客之 Matplotlib（十一）：最热门最常用的 50 个图表</a>【译文】</li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106025845未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】方法描述"><a href="#【1x00】方法描述" class="headerlink" title="【1x00】方法描述"></a><font color=#FF0000>【1x00】方法描述</font></h2><p><code>matplotlib.pyplot.pie()</code> 方法用于绘制饼状图。</p><p>基本语法：</p><pre><code class="python">matplotlib.pyplot.pie(        x[, explode=None, labels=None, colors=None,        autopct=None, pctdistance=0.6, shadow=False,        labeldistance=1.1, startangle=None, radius=None,        counterclock=True, wedgeprops=None, textprops=None,        center=(0, 0), frame=False, rotatelabels=False, \*, data=None]        )</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>x</td><td>每个扇形块的大小，数组形式，大小单位是比例</td></tr><tr><td>explode</td><td>指定对应扇形块脱离饼图的半径大小，数组形式，其中元素个数应该是 len(x)</td></tr><tr><td>labels</td><td>每个扇形块上的文本标签，列表形式</td></tr><tr><td>labeldistance</td><td>每个扇形块上的文本标签与扇形中心的距离，float 类型，默认 1.1</td></tr><tr><td>colors</td><td>每个扇形块对应的颜色，数组形式</td></tr><tr><td>autopct</td><td>用于计算每个扇形块所占比例，字符串或者函数类型<br>例如：<code>autopct=&#39;%1.1f%%&#39;</code> 表示浮点数，保留一位小数，并添加百分比符号</td></tr><tr><td>pctdistance</td><td>每个扇形块的中心与 autopct 生成的文本之间的距离，float 类型，默认 0.6</td></tr><tr><td>shadow</td><td>是否为扇形添加阴影效果</td></tr><tr><td>startangle</td><td>将饼图按照逆时针旋转指定的角度，float 类型</td></tr><tr><td>radius</td><td>饼图的半径，如果是 None，则将被设置为 1，float 类型</td></tr><tr><td>counterclock</td><td>是否按照逆时针对扇形图进行排列，bool 类型，默认 True</td></tr><tr><td>wedgeprops</td><td>传递给绘制每个扇形图对象的参数，字典形式，参数值参见 <a href="https://matplotlib.org/api/_as_gen/matplotlib.patches.Wedge.html#matplotlib.patches.Wedge">Wedge</a><br>例如：<code>wedgeprops = &#123;&#39;linewidth&#39;: 3&#125;</code> 设置扇形边框线宽度为 3</td></tr><tr><td>textprops</td><td>传递给文本对象的参数，字典形式<br>例如：<code>textprops=&#123;&#39;color&#39;: &#39;r&#39;, &#39;fontsize&#39;: 15&#125;</code> 设置文字为红色，大小为15</td></tr><tr><td>center</td><td>饼图圆心在画布上是坐标，默认 (0, 0)</td></tr><tr><td>frame</td><td>是否显示 x, y 坐标轴外框，默认 False</td></tr><tr><td>rotatelabels</td><td>是否按照角度进行调整每块饼的 label 文本标签，默认 False</td></tr></tbody></table><h2 id="【2x00】简单示例"><a href="#【2x00】简单示例" class="headerlink" title="【2x00】简单示例"></a><font color=#FF0000>【2x00】简单示例</font></h2><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = [10, 30, 45, 15]labels = [&#39;Java&#39;, &#39;Golang&#39;, &#39;Python&#39;, &#39;C++&#39;]colors = [&#39;red&#39;, &#39;yellow&#39;, &#39;blue&#39;, &#39;green&#39;]# 指定4个扇区所占比例以及扇区的颜色，扇区文本标签距离扇区中心1.1plt.pie(x, labels=labels, colors=colors, labeldistance=1.1)plt.title(&#39;饼状图简单示例&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A74/01.png" alt="01"></p><h2 id="【3x00】按角度调整扇形标签"><a href="#【3x00】按角度调整扇形标签" class="headerlink" title="【3x00】按角度调整扇形标签"></a><font color=#FF0000>【3x00】按角度调整扇形标签</font></h2><p><code>rotatelabels</code> 属性可以设置是否按照角度调整每块饼的 label（标签）显示方式。</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = [10, 30, 45, 15]labels = [&#39;Java&#39;, &#39;Go&#39;, &#39;Python&#39;, &#39;C++&#39;]colors = [&#39;red&#39;, &#39;yellow&#39;, &#39;blue&#39;, &#39;green&#39;]# 指定4个扇区所占比例以及扇区的颜色，扇区文本标签距离扇区中心1.1，按角度调整 labelsplt.pie(x, labels=labels, colors=colors, labeldistance=1.1, rotatelabels=True)plt.title(&#39;饼状图按角度调整 labels 示例&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A74/02.png" alt="02"></p><h2 id="【4x00】显示图例"><a href="#【4x00】显示图例" class="headerlink" title="【4x00】显示图例"></a><font color=#FF0000>【4x00】显示图例</font></h2><p>与前面文章中绘制线性图、散点图、条形图一样，调用 <code>matplotlib.pyplot.legend()</code> 方法可绘制图例，该方法的参数解释参见前文<a href="https://itrhx.blog.csdn.net/article/details/105828143">《Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性》</a></p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = [10, 30, 45, 15]labels = [&#39;Java&#39;, &#39;Go&#39;, &#39;Python&#39;, &#39;C++&#39;]colors = [&#39;red&#39;, &#39;yellow&#39;, &#39;blue&#39;, &#39;green&#39;]plt.pie(x, labels=labels, colors=colors, labeldistance=1.1)plt.title(&#39;饼状图显示图例示例&#39;)plt.legend(bbox_to_anchor=(1, 1))plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A74/03.png" alt="03"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106025845未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【5x00】突出显示扇形块"><a href="#【5x00】突出显示扇形块" class="headerlink" title="【5x00】突出显示扇形块"></a><font color=#FF0000>【5x00】突出显示扇形块</font></h2><p><code>explode</code> 参数可以实现突出显示某一块扇区，接收数组形式的参数，这个数组中的元素个数应该是 len(x)，即和扇区块的数量相同。</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = [10, 30, 45, 15]labels = [&#39;Java&#39;, &#39;Golang&#39;, &#39;Python&#39;, &#39;C++&#39;]colors = [&#39;red&#39;, &#39;yellow&#39;, &#39;blue&#39;, &#39;green&#39;]# 指定第一个扇区块脱离饼图的半径大小为0.3，其它扇区不脱离plt.pie(x, labels=labels, colors=colors, labeldistance=1.1, explode=[0.3, 0, 0, 0])plt.title(&#39;饼状图突出显示扇形块示例&#39;)plt.legend(bbox_to_anchor=(1, 1))plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A74/04.png" alt="04"></p><h2 id="【6x00】显示各扇区所占百分比"><a href="#【6x00】显示各扇区所占百分比" class="headerlink" title="【6x00】显示各扇区所占百分比"></a><font color=#FF0000>【6x00】显示各扇区所占百分比</font></h2><p><code>autopct</code> 参数可用于计算每个扇形块所占比例，接收字符串或者函数类型，例如：<code>autopct=&#39;%1.1f%%&#39;</code> 表示浮点数，保留一位小数，并添加百分比符号。<code>pctdistance</code> 参数用于调整每个扇形块的中心与 <code>autopct</code> 生成的文本之间的距离，float 类型，默认 0.6。</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = [10, 30, 45, 15]labels = [&#39;Java&#39;, &#39;Golang&#39;, &#39;Python&#39;, &#39;C++&#39;]colors = [&#39;red&#39;, &#39;yellow&#39;, &#39;blue&#39;, &#39;green&#39;]plt.pie(    x,                        # 每个扇形块所占比例    labels=labels,            # 扇形块文本标签    colors=colors,            # 扇形块颜色    labeldistance=1.1,        # 扇形块标签距离中心的距离    explode=[0.3, 0, 0, 0],   # 第一个扇形块突出显示    autopct=&#39;%1.1f%%&#39;,        # 显示百分比，保留一位小数    pctdistance=0.5           # 百分比文本距离饼状图中心的距离)plt.title(&#39;饼状图显示各扇区所占百分比示例&#39;)plt.legend(bbox_to_anchor=(1, 1))  # 显示图例plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A74/05.png" alt="05"></p><h2 id="【7x00】旋转饼状图"><a href="#【7x00】旋转饼状图" class="headerlink" title="【7x00】旋转饼状图"></a><font color=#FF0000>【7x00】旋转饼状图</font></h2><p><code>startangle</code> 参数可以选择饼状图，改变饼状图放置的角度。注意是按照逆时针旋转。</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = [10, 30, 45, 15]labels = [&#39;Java&#39;, &#39;Golang&#39;, &#39;Python&#39;, &#39;C++&#39;]colors = [&#39;red&#39;, &#39;yellow&#39;, &#39;blue&#39;, &#39;green&#39;]plt.pie(    x,                        # 每个扇形块所占比例    labels=labels,            # 扇形块文本标签    colors=colors,            # 扇形块颜色    labeldistance=1.1,        # 扇形块标签距离中心的距离    explode=[0.3, 0, 0, 0],   # 第一个扇形块突出显示    autopct=&#39;%1.1f%%&#39;,        # 显示百分比，保留一位小数    pctdistance=0.5,          # 百分比文本距离饼状图中心的距离    startangle=-90            # 逆时针旋转-90°，即顺时针旋转90°)plt.title(&#39;饼状图旋转角度示例&#39;)plt.legend(bbox_to_anchor=(1, 1))  # 显示图例plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A74/06.png" alt="06"></p><h2 id="【8x00】自定义每个扇形和文字属性"><a href="#【8x00】自定义每个扇形和文字属性" class="headerlink" title="【8x00】自定义每个扇形和文字属性"></a><font color=#FF0000>【8x00】自定义每个扇形和文字属性</font></h2><p><code>wedgeprops</code> 参数以字典形式为每个扇形添加自定义属性，例如：<code>wedgeprops = &#123;&#39;linewidth&#39;: 3&#125;</code> 设置扇形边框线宽度为 3，更多其他参数值参见 <a href="https://matplotlib.org/api/_as_gen/matplotlib.patches.Wedge.html#matplotlib.patches.Wedge">Wedge</a>；</p><p><code>textprops</code> 参数同样以字典形式为文本对象添加自定义属性，例如：<code>textprops=&#123;&#39;color&#39;: &#39;r&#39;, &#39;fontsize&#39;: 15&#125;</code> 设置文字为红色，大小为15，更多其他参数值参见 <a href="https://matplotlib.org/api/text_api.html?highlight=text#matplotlib.text.Text">Text</a>。</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = [10, 30, 45, 15]labels = [&#39;Java&#39;, &#39;Golang&#39;, &#39;Python&#39;, &#39;C++&#39;]colors = [&#39;red&#39;, &#39;yellow&#39;, &#39;blue&#39;, &#39;green&#39;]plt.pie(    x,                           # 每个扇形块所占比例    labels=labels,               # 扇形块文本标签    colors=colors,               # 扇形块颜色    labeldistance=1.1,           # 扇形块标签距离中心的距离    explode=[0.3, 0, 0, 0],      # 第一个扇形块突出显示    autopct=&#39;%1.1f%%&#39;,           # 显示百分比，保留一位小数    pctdistance=0.6,             # 百分比文本距离饼状图中心的距离    shadow=True,                 # 显示阴影效果    wedgeprops=&#123;                 # 为每个扇形添加属性        &#39;width&#39;: 0.7,            # 扇形宽度0.7        &#39;edgecolor&#39;: &#39;#98F5FF&#39;,  # 扇形边缘线颜色        &#39;linewidth&#39;: 3           # 扇形边缘线宽度    &#125;,    textprops=&#123;                  # 为文字添加属性        &#39;fontsize&#39;: 13,          # 文字大小        &#39;fontweight&#39;: &#39;bold&#39;,    # 文字粗细        &#39;color&#39;: &#39;k&#39;             # 文字颜色，黑色    &#125;)plt.title(&#39;饼状图自定义每个扇形和文字属性示例&#39;, fontweight=&#39;bold&#39;)plt.legend(bbox_to_anchor=(1, 1), borderpad=0.6)  # 显示图例plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A74/07.png" alt="07"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106025845未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Matplotlib 系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itbob.cn/article/014/&quot;&gt;Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.itbob.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="Matplotlib" scheme="https://www.itbob.cn/tags/Matplotlib/"/>
    
    <category term="数据分析" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据分析三剑客之 Matplotlib（六）：直方图/柱状图/条形图的绘制</title>
    <link href="https://www.itbob.cn/article/019/"/>
    <id>https://www.itbob.cn/article/019/</id>
    <published>2020-05-08T17:02:25.000Z</published>
    <updated>2022-05-22T12:31:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Matplotlib 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/014/">Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</a></li><li><a href="https://www.itbob.cn/article/015/">Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/016/">Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/017/">Python 数据分析三剑客之 Matplotlib（四）：线性图的绘制</a></li><li><a href="https://www.itbob.cn/article/018/">Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制</a></li><li><a href="https://www.itbob.cn/article/019/">Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制</a></li><li><a href="https://www.itbob.cn/article/020/">Python 数据分析三剑客之 Matplotlib（七）：饼状图的绘制</a></li><li><a href="https://www.itbob.cn/article/021/">Python 数据分析三剑客之 Matplotlib（八）：等高线 / 等值线图的绘制</a></li><li><a href="https://www.itbob.cn/article/022/">Python 数据分析三剑客之 Matplotlib（九）：极区图 / 极坐标图 / 雷达图的绘制</a></li><li><a href="https://www.itbob.cn/article/023/">Python 数据分析三剑客之 Matplotlib（十）：3D 图的绘制</a></li><li><a href="https://www.itbob.cn/article/024/">Python 数据分析三剑客之 Matplotlib（十一）：最热门最常用的 50 个图表</a>【译文】</li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105952856未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】直方图-柱状图-条形图的区别"><a href="#【1x00】直方图-柱状图-条形图的区别" class="headerlink" title="【1x00】直方图 / 柱状图 / 条形图的区别"></a><font color=#FF0000>【1x00】直方图 / 柱状图 / 条形图的区别</font></h2><ul><li><p>直方图：直方图（Histogram）又称质量分布图，是一种统计报告图，由一系列高度不等的纵向条纹或线段表示数据分布的情况。<font color=##0000FF><strong>一般用于描述连续型数据的分布关系</strong></font>，用横轴表示数据类型，纵轴表示分布情况。直方图是用面积表示各组频数的多少，矩形的高度表示每一组的频数或频率，宽度则表示各组的组距，因此其<font color=##32CD32><strong>高度与宽度均有意义</strong></font>。其次，由于分组数据具有连续性，<font color=##32CD32><strong>直方图的各矩形通常是连续排列。</strong></font></p></li><li><p>柱状图：柱状图（bar chart）又称条图、长条图、柱状统计图、条状图、棒形图，是一种以长方形的长度为变量的统计图表。<font color=##0000FF><strong>一般用于描述离散型分类数据的对比</strong></font>，长条图用来比较两个或以上的价值（不同时间或者不同条件），只有一个变量，通常利用于较小的数据集分析。柱状图亦可横向排列，或用多维方式表达。<font color=##32CD32><strong>柱状图各矩形的宽度固定，矩形之间分开排列，会有间距。</strong></font></p></li><li><p>条形图：通常情况下<font color=#FF0000><strong>条形图 = 柱状图</strong></font>，也可以<font color=#FF0000><strong>将横向排列的柱状图称为条形图</strong></font>。在本文中会将条形图视为后者。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200509010455973.png" alt="分割线"></p><h2 id="【2x00】直方图的绘制"><a href="#【2x00】直方图的绘制" class="headerlink" title="【2x00】直方图的绘制"></a><font color=#FF0000>【2x00】直方图的绘制</font></h2><h3 id="【2x01】函数介绍-matplotlib-pyplot-hist"><a href="#【2x01】函数介绍-matplotlib-pyplot-hist" class="headerlink" title="【2x01】函数介绍 matplotlib.pyplot.hist()"></a><font color=##4876FF>【2x01】函数介绍 matplotlib.pyplot.hist()</font></h3><p><code>matplotlib.pyplot.hist()</code> 函数用于绘制直方图。</p><p>基本语法：<code>matplotlib.pyplot.hist(x[, bins=None, range=None, density=False, bottom=None, histtype=&#39;bar&#39;, align=&#39;mid&#39;, orientation=&#39;vertical&#39;, rwidth=None, log=False, color=None, label=None, stacked=False, \*\*kwargs])</code></p><p>基本参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>x</td><td>数据集，数组或数组序列</td></tr><tr><td>bins</td><td>统计的分布区间、条形数，可以是整数、序列或字符串，默认 <code>rcParams[&quot;hist.bins&quot;] =10</code><br>如果 bins 是整数，则定义的是等宽的矩形的个数<br>如果 bins 是序列，则定义的是每个矩形的区间，如：<code>bins = [1, 2, 3, 4]</code>，则矩形分布区间为 <code>[1,2)</code>、<code>[2,3)</code>、<code>[3,4]</code><br>如果 bins 是字符串，则它应该是 <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram_bin_edges.html#numpy.histogram_bin_edges">numpy.histogram_bin_edges</a> 所支持的策略之一</td></tr><tr><td>range</td><td>矩形分布的区间，在没有指定 bins 生效，元组类型</td></tr><tr><td>density</td><td>是否<strong>显示频率统计结果</strong>，<code>频率统计结果=区间数目/(总数*区间宽度)</code></td></tr><tr><td>bottom</td><td>y 轴的起始位置，默认为 0</td></tr><tr><td>histtype</td><td>矩形的样式，有四种类型可选：<br><code>&#39;bar&#39;</code>：默认值，传统的条形直方图，如果给出多个数据，则条形图并排排列<br><code>&#39;barstacked&#39;</code>：当数据为 1 个时，和 bar 结果一样，当数据为多个时，则进行垂直堆叠<br><code>&#39;step&#39;</code>：未填充的线条形式；<code>&#39;stepfilled&#39;</code>：填充的线条形式，效果与 bar 差不多</td></tr><tr><td>align</td><td>矩形的中心位于 bins（x 轴） 的位置，<code>&#39;left&#39;</code>：左；<code>&#39;mid&#39;</code>：中；<code>&#39;right&#39;</code>：右</td></tr><tr><td>orientation</td><td>矩形的方向，<code>vertical</code>：垂直；<code>horizontal</code>：水平</td></tr><tr><td>rwidth</td><td>矩形的相对宽度，如果未指定，则自动计算宽度</td></tr><tr><td>log</td><td>y 坐标轴是否以指数刻度显示</td></tr><tr><td>color</td><td>矩形的颜色，默认蓝色，与 facecolor 作用相同，指定一个即可，如果两者都指定，则取 facecolor 的值</td></tr><tr><td>label</td><td>数据的标签，展示图例时使用</td></tr><tr><td>stacked</td><td>是否为堆积状图（当两个数据相似时，堆积在一起就会把第一个数据的显示相对缩小一点）</td></tr></tbody></table><p>其他参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>facecolor</td><td>标量或数组类型，每个矩形的颜色，与 color 作用相同，指定一个即可，如果两者都指定，则取 facecolor 的值</td></tr><tr><td>edgecolor</td><td>标量或数组类型，直方图边缘线的颜色</td></tr><tr><td>linewidth</td><td>标量或数组类型，直方图边缘线的宽度，如果为 0，则不绘制边</td></tr><tr><td>alpha</td><td>float 类型，矩形透明度</td></tr><tr><td>label</td><td>图例中显示的标签</td></tr><tr><td>linestyle / ls</td><td>线条样式，此处指矩形边缘线条样式<br><code>&#39;-&#39;</code> or <code>&#39;solid&#39;</code>, <code>&#39;--&#39;</code> or <code>&#39;dashed&#39;</code>, <code>&#39;-.&#39;</code> or <code>&#39;dashdot&#39;</code> or <code>&#39;:&#39;</code> or <code>&#39;dotted&#39;</code>, <code>&#39;none&#39;</code> or <code>&#39; &#39;</code> or <code>&#39;&#39;</code></td></tr><tr><td>linewidth / lw</td><td>线条宽度，此处指矩形边缘线的宽度，float 类型，默认 0.8</td></tr><tr><td>hatch</td><td>矩形的填充图案，可以是组合形式，如果有相同的图案，则会增加填充的密度<br>取值可以是：<code>&#39;/&#39;</code>, <code>&#39;\&#39;</code>, `’</td></tr></tbody></table><h3 id="【2x02】简单直方图示例"><a href="#【2x02】简单直方图示例" class="headerlink" title="【2x02】简单直方图示例"></a><font color=##4876FF>【2x02】简单直方图示例</font></h3><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]  # 设置中文显示x = np.random.randint(0, 101, 100)  # 数据集bins = np.arange(0, 101, 10)        # 分布区间 [0,10)、[10,20)...[90,100]plt.hist(x, bins=bins, linewidth=0.5, edgecolor=&#39;k&#39;)  # 边缘线宽0.5，颜色为黑色plt.xlim(0, 100)                    # x 轴刻度范围       plt.title(&#39;简单直方图示例&#39;)         # 标题plt.xlabel(&#39;x axis label&#39;)         # x 轴标签plt.ylabel(&#39;y axis label&#39;)         # y 轴标签plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/01.png" alt="01"></p><h3 id="【2x03】堆积的直方图"><a href="#【2x03】堆积的直方图" class="headerlink" title="【2x03】堆积的直方图"></a><font color=##4876FF>【2x03】堆积的直方图</font></h3><p>参数 <code>stacked</code> 决定了将两份数据进行堆积显示。注意，有可能两个数据相似（y 轴的值相似），但是堆积在一起的时候，会把第一个数据的显示相对缩小一点。</p><pre><code class="python">import matplotlib.pyplot as pltimport numpy as npplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]hist1 = np.random.randint(0, 100, 100)hist2 = np.random.randint(0, 100, 100)x = [hist1, hist2]colors = [&#39;orchid&#39;, &#39;deepskyblue&#39;]labels = [&#39;hist1&#39;, &#39;hist2&#39;]bins = range(0, 101, 10)# 绘制两份数据的直方图，数据集等其他参数可以使用列表形式传递，也可以使用两次 hist 函数单独传递plt.hist(x, bins=bins, color=colors, stacked=True, label=labels)plt.title(&#39;堆积的直方图示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.legend(loc=&quot;upper left&quot;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/02.png" alt="02"></p><h3 id="【2x04】填充其他样式"><a href="#【2x04】填充其他样式" class="headerlink" title="【2x04】填充其他样式"></a><font color=##4876FF>【2x04】填充其他样式</font></h3><p><code>hatch</code> 参数可以让直方图的矩形填充其他样式，可选值有：<code>&#39;/&#39;</code>, <code>&#39;\&#39;</code>, <code>&#39;|&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;x&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;O&#39;</code>, <code>&#39;.&#39;</code>, <code>&#39;*&#39;</code>。可以是不同图案的组合形式，如果有相同的图案，则会增加填充的密度。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]  # 设置中文显示x = np.random.randint(0, 101, 100)  # 数据集bins = np.arange(0, 101, 10)        # 分布区间 [0,10)、[10,20)...[90,100]# 矩形颜色为白色，使用 / 填充，边缘线宽0.5，颜色为黑色plt.hist(x, bins=bins, color=&#39;w&#39;, hatch=&#39;///&#39;, linewidth=0.5, edgecolor=&#39;k&#39;)plt.xlim(0, 100)                   # x 轴刻度范围plt.title(&#39;直方图图案填充示例&#39;)     # 标题plt.xlabel(&#39;x axis label&#39;)         # x 轴标签plt.ylabel(&#39;y axis label&#39;)         # y 轴标签plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/03.png" alt="03"></p><p><img src="https://img-blog.csdnimg.cn/20200509010455973.png" alt="分割线"></p><h2 id="【3x00】柱状图的绘制"><a href="#【3x00】柱状图的绘制" class="headerlink" title="【3x00】柱状图的绘制"></a><font color=#FF0000>【3x00】柱状图的绘制</font></h2><h3 id="【3x01】函数介绍-matplotlib-pyplot-bar"><a href="#【3x01】函数介绍-matplotlib-pyplot-bar" class="headerlink" title="【3x01】函数介绍 matplotlib.pyplot.bar()"></a><font color=##4876FF>【3x01】函数介绍 matplotlib.pyplot.bar()</font></h3><p><code>matplotlib.pyplot.bar()</code> 函数用于绘制柱状图。</p><p>基本语法：<code>matplotlib.pyplot.bar(x, height[, width=0.8, bottom=None, align=&#39;center&#39;, \*\*kwargs])</code></p><p>基本参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>x</td><td>标量序列，每个矩形对应的 x 轴刻度</td></tr><tr><td>height</td><td>标量或标量序列，每个矩形对应的高度，即 y 轴刻度</td></tr><tr><td>width</td><td>标量或数组类型，每个矩形的宽度，默认为 0.8</td></tr><tr><td>bottom</td><td>标量或数组类型，y 轴的起始位置，默认为 0</td></tr><tr><td>align</td><td>矩形与 x 轴刻度对齐的位置，<code>&#39;center&#39;</code>：中；<code>&#39;edge&#39;</code>：左边缘</td></tr></tbody></table><p>其他参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>color</td><td>标量或数组类型，每个矩形的颜色，与 facecolor 作用相同，指定一个即可，如果两者都指定，则取 facecolor 的值</td></tr><tr><td>edgecolor</td><td>标量或数组类型，柱状图边缘线的颜色</td></tr><tr><td>linewidth</td><td>标量或数组类型，柱状图边缘线的宽度，如果为0，则不绘制边</td></tr><tr><td>tick_label</td><td>标量或数组类型，柱状图 x 轴的刻度标签，默认使用数字标签</td></tr><tr><td>xerr / yerr</td><td>标量，指定对应标准差（添加误差线时会用到）</td></tr><tr><td>ecolor</td><td>标量或数组类型，误差线的线条颜色，默认值为 black</td></tr><tr><td>capsize</td><td>标量，误差线两头横线的宽度，默认为 <code>rcParams[&quot;errorbar.capsize&quot;] = 0.0</code></td></tr><tr><td>error_kw</td><td>字典类型，可以此字典中定义 ecolor 和 capsize，比单独指定的优先级要高</td></tr><tr><td>log</td><td>bool 值，y 坐标轴是否以指数刻度显示</td></tr><tr><td>alpha</td><td>float 类型，矩形透明度</td></tr><tr><td>label</td><td>图例中显示的标签</td></tr><tr><td>linestyle / ls</td><td>线条样式，此处指矩形边缘线条样式<br><code>&#39;-&#39;</code> or <code>&#39;solid&#39;</code>, <code>&#39;--&#39;</code> or <code>&#39;dashed&#39;</code>, <code>&#39;-.&#39;</code> or <code>&#39;dashdot&#39;</code> or <code>&#39;:&#39;</code> or <code>&#39;dotted&#39;</code>, <code>&#39;none&#39;</code> or <code>&#39; &#39;</code> or <code>&#39;&#39;</code></td></tr><tr><td>linewidth / lw</td><td>线条宽度，此处指矩形边缘线的宽度，float 类型，默认 0.8</td></tr><tr><td>hatch</td><td>矩形的填充图案，可以是组合形式，如果有相同的图案，则会增加填充的密度<br>取值可以是：<code>&#39;/&#39;</code>, <code>&#39;\&#39;</code>, `’</td></tr></tbody></table><h3 id="【3x02】简单柱状图示例"><a href="#【3x02】简单柱状图示例" class="headerlink" title="【3x02】简单柱状图示例"></a><font color=##4876FF>【3x02】简单柱状图示例</font></h3><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = [1, 2, 3, 4, 5]height = [5, 7, 4, 3, 1]# 设置 x 轴的标签，也可以用 plt.xticks 方法来设置tick_label = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;]# 设置颜色序列color = [&#39;red&#39;, &#39;yellow&#39;, &#39;peru&#39;, &#39;orchid&#39;, &#39;deepskyblue&#39;]# 绘制柱状图，边缘线宽度为1，颜色为黑色，样式为 --plt.bar(x, height, tick_label=tick_label, color=color, edgecolor=&#39;k&#39;, linewidth=1, linestyle=&#39;--&#39;)plt.title(&#39;简单柱状图示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/04.png" alt="04"></p><h3 id="【3x03】添加与标准差的误差线"><a href="#【3x03】添加与标准差的误差线" class="headerlink" title="【3x03】添加与标准差的误差线"></a><font color=##4876FF>【3x03】添加与标准差的误差线</font></h3><p>首先定义一个列表，其中的元素是与每个值对应的标准差，<code>ecolor</code> 和 <code>capsize</code> 参数分别指定误差线的颜色和两头横线的宽度。这两个参数可以通过 <code>error_kw</code> 字典形式组合起来。以字典形式的组合优先级别要比单独指定高。另外，柱状图指定标准差时要用 <code>yerr</code>，条形图（横向排列的柱状图）指定标准差时要用 <code>xerr</code>。</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = [1, 2, 3, 4, 5]height = [5, 7, 4, 3, 2]std = [0.5, 0.1, 1.2, 0.3, 1.0]   # 标准差tick_label = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;]  # 设置 x 轴的标签，也可以用 plt.xticks 方法来设置color = [&#39;red&#39;, &#39;yellow&#39;, &#39;peru&#39;, &#39;orchid&#39;, &#39;deepskyblue&#39;]  # 设置颜色序列plt.bar(    x,    height,    tick_label=tick_label,    color=color,    yerr=std,              # 指定对应标准差    # error_kw=&#123;    #     &#39;ecolor&#39;: &#39;k&#39;,   # 指定误差线的颜色    #     &#39;capsize&#39;: 6     # 指定误差线两头横线的宽度    # &#125;,    ecolor=&#39;k&#39;,    capsize=6,    edgecolor=&#39;k&#39;,         # 指定边缘线颜色    linewidth=1            # 指定边缘线宽度)plt.title(&#39;柱状图添加误差线示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/05.png" alt="05"></p><h3 id="【3x04】多序列柱状图"><a href="#【3x04】多序列柱状图" class="headerlink" title="【3x04】多序列柱状图"></a><font color=##4876FF>【3x04】多序列柱状图</font></h3><p>在绘制多序列的柱状图时，只需要多次调用 <code>matplotlib.pyplot.bar()</code> 函数即可，指定一个较小的宽度值（偏移量），绘制不同数据时设置不同的 x 位置刻度即可。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(5)height1 = np.array([5, 7, 4, 3, 2])height2 = np.array([2, 4, 6, 7, 3])height3 = np.array([3, 1, 7, 5, 2])# 设置宽度值（偏移量）width = 0.3# 绘制不同数据时，x 轴依次增加一个偏移量plt.bar(x, height1, width, label=&#39;bar1&#39;)plt.bar(x + width, height2, width, label=&#39;bar2&#39;)plt.bar(x + width * 2, height3, width, label=&#39;bar3&#39;)# 设置 x 轴刻度的标签plt.xticks(x + width, [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])plt.title(&#39;多序列柱状图示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/06.png" alt="06"></p><h3 id="【3x05】堆积的柱状图"><a href="#【3x05】堆积的柱状图" class="headerlink" title="【3x05】堆积的柱状图"></a><font color=##4876FF>【3x05】堆积的柱状图</font></h3><p>所谓堆积图，就是将多序列数据堆积到一个矩形上显示，在柱状图中要实现堆积图，只需要改变 <code>bottom</code> 参数即可，<code>bottom</code> 参数用于设置 y 轴基线，即柱状图的底边在 y 轴上的起始刻度，第一条数据 <code>data1</code> 的基线可以设置为 0，即默认值，第二条数据 <code>data2</code> 的基线可以设置在 <code>data1</code> 的上方，即 <code>bottom=data1</code>，第三条数据 <code>data3</code> 的基线可以设置在 <code>data1 + data2</code> 的上方，即 <code>bottom=data1+data2</code>，以此类推。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(5)height1 = np.array([5, 7, 4, 3, 2])height2 = np.array([2, 4, 6, 7, 3])height3 = np.array([3, 1, 7, 5, 2])plt.bar(x, height1, label=&#39;bar1&#39;)plt.bar(x, height2, label=&#39;bar2&#39;, bottom=height1)plt.bar(x, height3, label=&#39;bar3&#39;, bottom=(height2+height1))plt.xticks(x, [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])plt.title(&#39;堆积的柱状图示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/07.png" alt="07"></p><h3 id="【3x06】填充其他样式"><a href="#【3x06】填充其他样式" class="headerlink" title="【3x06】填充其他样式"></a><font color=##4876FF>【3x06】填充其他样式</font></h3><p><code>hatch</code> 参数可以让柱状图的矩形填充其他样式，可选值有：<code>&#39;/&#39;</code>, <code>&#39;\&#39;</code>, <code>&#39;|&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;x&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;O&#39;</code>, <code>&#39;.&#39;</code>, <code>&#39;*&#39;</code>。可以是不同图案的组合形式，如果有相同的图案，则会增加填充的密度。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(5)height1 = np.array([5, 7, 4, 3, 2])height2 = np.array([2, 4, 6, 7, 3])height3 = np.array([3, 1, 7, 5, 2])plt.bar(x, height1, label=&#39;bar1&#39;, color=&#39;w&#39;, hatch=&#39;///&#39;)plt.bar(x, height2, label=&#39;bar2&#39;, bottom=height1, color=&#39;w&#39;, hatch=&#39;xxx&#39;)plt.bar(x, height3, label=&#39;bar3&#39;, bottom=(height2+height1), color=&#39;w&#39;, hatch=&#39;|||&#39;)plt.xticks(x, [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])plt.title(&#39;柱状图图案填充示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/08.png" alt="08"></p><h3 id="【3x07】添加文字描述"><a href="#【3x07】添加文字描述" class="headerlink" title="【3x07】添加文字描述"></a><font color=##4876FF>【3x07】添加文字描述</font></h3><p>利用 <code>matplotlib.pyplot.text()</code> 方法可以在柱状图每个矩形上方添加文字描述。具体参数解释可参考前面的文章：<a href="https://itrhx.blog.csdn.net/article/details/105828049">《Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性》</a></p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(5)height1 = np.array([5, 7, 4, 3, 2])height2 = np.array([2, 4, 6, 7, 3])height3 = np.array([3, 1, 7, 5, 2])width = 0.3# 绘制不同数据时，x 轴依次增加一个偏移量plt.bar(x, height1, width, label=&#39;bar1&#39;)plt.bar(x + width, height2, width, label=&#39;bar2&#39;)plt.bar(x + width * 2, height3, width, label=&#39;bar3&#39;)# 依次添加每条数据的标签for a, b in zip(x, height1):    plt.text(a, b, b, ha=&#39;center&#39;, va=&#39;bottom&#39;)for c, d in zip(x, height2):    plt.text(c + width, d, d, ha=&#39;center&#39;, va=&#39;bottom&#39;)for e, f in zip(x, height3):    plt.text(e + width * 2, f, f, ha=&#39;center&#39;, va=&#39;bottom&#39;)# 设置 x 轴刻度的标签plt.xticks(x + width, [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])plt.title(&#39;柱状图添加文字描述示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/09.png" alt="09"></p><p><img src="https://img-blog.csdnimg.cn/20200509010455973.png" alt="分割线"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105952856未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【4x00】条形图的绘制"><a href="#【4x00】条形图的绘制" class="headerlink" title="【4x00】条形图的绘制"></a><font color=#FF0000>【4x00】条形图的绘制</font></h2><h3 id="【4x01】函数介绍-matplotlib-pyplot-barh"><a href="#【4x01】函数介绍-matplotlib-pyplot-barh" class="headerlink" title="【4x01】函数介绍 matplotlib.pyplot.barh()"></a><font color=##4876FF>【4x01】函数介绍 matplotlib.pyplot.barh()</font></h3><p><code>matplotlib.pyplot.barh()</code> 函数用于绘制条形图（水平排列的柱状图）。</p><p>基本语法：<code>matplotlib.pyplot.barh(y, width[, height=0.8, left=None, align=&#39;center&#39;, color, \*\*kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>y</td><td>标量或数组类型，每个矩形对应的 y 轴刻度</td></tr><tr><td>width</td><td>标量或数组类型，每个矩形的宽度，即 x 轴刻度</td></tr><tr><td>height</td><td>标量序列，每个矩形的高度，默认 0.8</td></tr><tr><td>left</td><td>标量序列，每个矩形的左侧 x 坐标的起始位置，默认值为 0</td></tr><tr><td>align</td><td>矩形的底边与 y 轴刻度对齐的位置，<code>&#39;center&#39;</code>：中；<code>&#39;edge&#39;</code>：底边</td></tr></tbody></table><p>其他参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>color</td><td>标量或数组类型，每个矩形的颜色，与 facecolor 作用相同，指定一个即可，如果两者都指定，则取 facecolor 的值</td></tr><tr><td>edgecolor</td><td>标量或数组类型，条形图边缘线的颜色</td></tr><tr><td>linewidth</td><td>标量或数组类型，条形图边缘线的宽度，如果为0，则不绘制边</td></tr><tr><td>tick_label</td><td>标量或数组类型，条形图 y 轴的刻度标签，默认使用数字标签</td></tr><tr><td>xerr / yerr</td><td>标量，指定对应标准差（添加误差线时会用到）</td></tr><tr><td>ecolor</td><td>标量或数组类型，误差线的线条颜色，默认值为 black</td></tr><tr><td>capsize</td><td>标量，误差线两头横线的宽度，默认为 <code>rcParams[&quot;errorbar.capsize&quot;] = 0.0</code></td></tr><tr><td>error_kw</td><td>字典类型，可以此字典中定义 ecolor 和 capsize，比单独指定的优先级要高</td></tr><tr><td>log</td><td>bool 值，y 坐标轴是否以指数刻度显示</td></tr><tr><td>alpha</td><td>float 类型，矩形透明度</td></tr><tr><td>label</td><td>图例中显示的标签</td></tr><tr><td>linestyle / ls</td><td>线条样式，此处指矩形边缘线条样式<br><code>&#39;-&#39;</code> or <code>&#39;solid&#39;</code>, <code>&#39;--&#39;</code> or <code>&#39;dashed&#39;</code>, <code>&#39;-.&#39;</code> or <code>&#39;dashdot&#39;</code> or <code>&#39;:&#39;</code> or <code>&#39;dotted&#39;</code>, <code>&#39;none&#39;</code> or <code>&#39; &#39;</code> or <code>&#39;&#39;</code></td></tr><tr><td>linewidth / lw</td><td>线条宽度，此处指矩形边缘线的宽度，float 类型，默认 0.8</td></tr><tr><td>hatch</td><td>矩形的填充图案，可以是组合形式，如果有相同的图案，则会增加填充的密度<br>取值可以是：<code>&#39;/&#39;</code>, <code>&#39;\&#39;</code>, `’</td></tr></tbody></table><h3 id="【4x02】简单条形图示例"><a href="#【4x02】简单条形图示例" class="headerlink" title="【4x02】简单条形图示例"></a><font color=##4876FF>【4x02】简单条形图示例</font></h3><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]y = [1, 2, 3, 4, 5]width = [5, 7, 4, 3, 1]tick_label = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;]color = [&#39;red&#39;, &#39;yellow&#39;, &#39;peru&#39;, &#39;orchid&#39;, &#39;deepskyblue&#39;]plt.barh(y, width, tick_label=tick_label, color=color, edgecolor=&#39;k&#39;, linewidth=1, linestyle=&#39;--&#39;)plt.title(&#39;简单条形图示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/10.png" alt="10"></p><h3 id="【4x03】添加与标准差的误差线"><a href="#【4x03】添加与标准差的误差线" class="headerlink" title="【4x03】添加与标准差的误差线"></a><font color=##4876FF>【4x03】添加与标准差的误差线</font></h3><p>与柱状图一样，首先定义一个列表，其中的元素是与每个值对应的标准差，<code>ecolor</code> 和 <code>capsize</code> 参数分别指定误差线的颜色和两头横线的宽度。这两个参数可以通过 <code>error_kw</code> 字典形式组合起来。以字典形式的组合优先级别要比单独指定高。另外，柱状图指定标准差时要用 <code>yerr</code>，条形图（横向排列的柱状图）指定标准差时要用 <code>xerr</code>。</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]y = [1, 2, 3, 4, 5]width = [5, 7, 4, 3, 2]std = [0.5, 0.1, 1.2, 0.3, 1.0]  # 标准差tick_label = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;]   # 设置 x 轴的标签，也可以用 plt.xticks 方法来设置color = [&#39;red&#39;, &#39;yellow&#39;, &#39;peru&#39;, &#39;orchid&#39;, &#39;deepskyblue&#39;]  # 颜色序列plt.barh(    y,    width,    tick_label=tick_label,    color=color,    xerr=std,               # 指定对应标准差    # error_kw=&#123;    #     &#39;ecolor&#39;: &#39;k&#39;,    # 指定误差线的颜色    #     &#39;capsize&#39;: 6      # 指定误差线两头横线的宽度    # &#125;,    ecolor=&#39;k&#39;,    capsize=6,    edgecolor=&#39;k&#39;,          # 指定边缘线颜色    linewidth=1             # 指定边缘线宽度)plt.title(&#39;条形图添加误差线示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/11.png" alt="11"></p><h3 id="【4x04】多序列条形图"><a href="#【4x04】多序列条形图" class="headerlink" title="【4x04】多序列条形图"></a><font color=##4876FF>【4x04】多序列条形图</font></h3><p>与多序列柱状图类似，在绘制多序列的条形图时，只需要多次调用 <code>matplotlib.pyplot.barh()</code> 函数即可，指定一个较小的高度值（偏移量），绘制不同数据时设置不同的 y 位置刻度即可。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]y = np.arange(5)width1 = np.array([5, 7, 4, 3, 2])width2 = np.array([2, 4, 6, 7, 3])width3 = np.array([3, 1, 7, 5, 2])# 设置高度值（偏移量）height = 0.3# 绘制不同数据时，y 轴依次增加一个偏移量plt.barh(y, width1, height, label=&#39;bar1&#39;)plt.barh(y + height, width2, height, label=&#39;bar2&#39;)plt.barh(y + height * 2, width3, height, label=&#39;bar3&#39;)# 设置 y 轴刻度的标签plt.yticks(y + height, [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])plt.title(&#39;多序列条形图示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/12.png" alt="12"></p><h3 id="【4x05】堆积的条形图"><a href="#【4x05】堆积的条形图" class="headerlink" title="【4x05】堆积的条形图"></a><font color=##4876FF>【4x05】堆积的条形图</font></h3><p>堆积图就是将多序列数据堆积到一个矩形上显示，和堆积的柱状图类似，在条形图中要实现堆积图，只需要改变 <code>left</code> 参数即可，<code>left</code> 参数用于设置 x 轴基线，即柱状图的底边在 x 轴上的起始刻度，第一条数据 <code>data1</code> 的基线可以设置为 0，即默认值，第二条数据 <code>data2</code> 的基线可以设置在 <code>data1</code> 的上方，即 <code>left=data1</code>，第三条数据 <code>data3</code> 的基线可以设置在 <code>data1 + data2</code> 的上方，即 <code>left=data1+data2</code>，以此类推。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]y = np.arange(5)width1 = np.array([5, 7, 4, 3, 2])width2 = np.array([2, 4, 6, 7, 3])width3 = np.array([3, 1, 7, 5, 2])plt.barh(y, width1, label=&#39;bar1&#39;)plt.barh(y, width2, label=&#39;bar2&#39;, left=width1)plt.barh(y, width3, label=&#39;bar3&#39;, left=(width1+width2))plt.yticks(y, [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])plt.title(&#39;堆积的条形图示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/13.png" alt="13"></p><h3 id="【4x06】填充其他样式"><a href="#【4x06】填充其他样式" class="headerlink" title="【4x06】填充其他样式"></a><font color=##4876FF>【4x06】填充其他样式</font></h3><p><code>hatch</code> 参数可以让柱状图的矩形填充其他样式，可选值有：<code>&#39;/&#39;</code>, <code>&#39;\&#39;</code>, <code>&#39;|&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;x&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;O&#39;</code>, <code>&#39;.&#39;</code>, <code>&#39;*&#39;</code>。可以是不同图案的组合形式，如果有相同的图案，则会增加填充的密度。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]y = np.arange(5)width1 = np.array([5, 7, 4, 3, 2])width2 = np.array([2, 4, 6, 7, 3])width3 = np.array([3, 1, 7, 5, 2])plt.barh(y, width1, label=&#39;bar1&#39;, color=&#39;w&#39;, hatch=&#39;///&#39;)plt.barh(y, width2, label=&#39;bar2&#39;, left=width1, color=&#39;w&#39;, hatch=&#39;xxx&#39;)plt.barh(y, width3, label=&#39;bar3&#39;, left=(width1+width2), color=&#39;w&#39;, hatch=&#39;|||&#39;)plt.yticks(y, [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])plt.title(&#39;条形图图案填充示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/14.png" alt="14"></p><h3 id="【4x07】添加文字描述"><a href="#【4x07】添加文字描述" class="headerlink" title="【4x07】添加文字描述"></a><font color=##4876FF>【4x07】添加文字描述</font></h3><p>利用 <code>matplotlib.pyplot.text()</code> 方法可以在条形图每个矩形上方添加文字描述。具体参数解释可参考前面的文章：<a href="https://itrhx.blog.csdn.net/article/details/105828049">《Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性》</a></p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]y = np.arange(5)width1 = np.array([5, 7, 4, 3, 2])width2 = np.array([2, 4, 6, 7, 3])width3 = np.array([3, 1, 7, 5, 2])height = 0.3# 绘制不同数据时，y 轴依次增加一个偏移量plt.barh(y, width1, height, label=&#39;bar1&#39;)plt.barh(y + height, width2, height, label=&#39;bar2&#39;)plt.barh(y + height * 2, width3, height, label=&#39;bar3&#39;)# 依次添加每条数据的标签for a, b in zip(width1, y):    plt.text(a, b-0.05, a)for c, d in zip(width2, y):    plt.text(c, d+0.20, c)for e, f in zip(width3, y):    plt.text(e, f+0.50, e)# 设置 y 轴刻度的标签plt.yticks(y + height, [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])plt.title(&#39;条形图添加文字描述示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/15.png" alt="15"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105952856未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Matplotlib 系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itbob.cn/article/014/&quot;&gt;Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.itbob.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="Matplotlib" scheme="https://www.itbob.cn/tags/Matplotlib/"/>
    
    <category term="数据分析" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
