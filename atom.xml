<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ITBOB&#39;S BLOG</title>
  
  <subtitle>一入 IT 深似海 从此学习无绝期</subtitle>
  <link href="https://www.itbob.cn/atom.xml" rel="self"/>
  
  <link href="https://www.itbob.cn/"/>
  <updated>2022-05-22T12:49:00.000Z</updated>
  <id>https://www.itbob.cn/</id>
  
  <author>
    <name>BOB</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【JS 逆向】AST 脱混淆实战，某 ICP 备案号查询接口 jsjiami v6 分析</title>
    <link href="https://www.itbob.cn/article/052/"/>
    <id>https://www.itbob.cn/article/052/</id>
    <published>2022-05-25T06:01:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><strong>本文章中所有内容仅供学习交流，抓包内容、敏感网址、数据接口均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关，若有侵权，请在公众号联系我立即删除！</strong></p><h2 id="逆向目标"><a href="#逆向目标" class="headerlink" title="逆向目标"></a>逆向目标</h2><ul><li>目标：站 Z 之家网站 ICP 备案号查询</li><li>主页：<code>aHR0cDovL2ljcC5jaGluYXouY29tLw==</code></li><li>接口：<code>aHR0cDovL2ljcC5jaGluYXouY29tL2hvbWUvR2V0UGVyaW1pdEJ5SG9zdA==</code></li><li>逆向参数：<code>hostToken</code>、<code>permitToken</code></li></ul><p>本次主要是 AST 解混淆实战，本例中的 JS 混淆方式是 sojson 旗下的 jsjiami v6 版本，感兴趣的可以去官网体验一下：<a href="https://www.jsjiami.com/">https://www.jsjiami.com/</a> ，如果你还不了解 AST，可以先看看上期的文章（非常详细）：<a href="https://www.itbob.cn/article/051/">《逆向进阶，利用 AST 技术还原 JavaScript 混淆代码》</a>，本文部分 AST 还原代码直接使用了上期文章中的代码，所以细节方面不再赘述，有疑问的地方可以参考参考上期文章。</p><h2 id="第三方工具"><a href="#第三方工具" class="headerlink" title="第三方工具"></a>第三方工具</h2><p>逆向领域大佬云集，市面上已经有很多大佬写好的解混淆工具了，除了我们自己手动去写 AST 解析代码以外，有时候直接使用工具会更加方便，当然并没有十全十美的工具，不过大部分情况下都能成功解混淆的，以下工具值得去体验一下：</p><ul><li>蔡老板一键还原 OB 混淆：<a href="https://github.com/Tsaiboss/decodeObfuscator">https://github.com/Tsaiboss/decodeObfuscator</a></li><li>哲哥 AST 混淆还原框架：<a href="https://github.com/sml2h3/ast_tools">https://github.com/sml2h3/ast_tools</a></li><li>V 神 Chrome 插件，内置 AST 混淆还原：<a href="https://github.com/cilame/v_jstools">https://github.com/cilame/v_jstools</a></li><li>jsjiami v6 专用解密工具：<a href="https://github.com/NXY666/JsjiamiV6-Decryptor">https://github.com/NXY666/JsjiamiV6-Decryptor</a></li></ul><h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p>进入主题，首先抓包看看，来到 ICP 备案查询页面，查询结果中，其他信息都可以直接在相应的 html 源码中找到，只有这个备案号是通过接口传过来的，对应的请求和相关加密参数如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0f138564edc0bd1105d47f5cdfbfade8.png" alt="01"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/410785d65040014c5e2ef0790cd61d5c.png" alt="02"></p><h2 id="加密定位"><a href="#加密定位" class="headerlink" title="加密定位"></a>加密定位</h2><p>直接搜索关键字 <code>hostToken</code> 或者 <code>permitToken</code> 即可定位：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ce5187bac33cd5f5a818cfc2a6a720fb.png" alt="03"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/049d86ab89afba4d32cb21ac9a2fb599.png" alt="04"></p><p>关键代码：</p><pre><code class="javascript">&#39;data&#39;: &#123;    &#39;kw&#39;: kw,    &#39;hostToken&#39;: _0x791532[&#39;IIPmq&#39;](generateHostKey, kw),    &#39;permitToken&#39;: _0x791532[_0x404f(&#39;‫1df&#39;, &#39;7Gn4&#39;)](generateWordKey, kw)&#125;</code></pre><p>这里的混淆可以手动跟一下，还原后如下：</p><pre><code class="javascript">&#39;data&#39;: &#123;    &#39;kw&#39;: kw,    &#39;hostToken&#39;: generateHostKey(kw),    &#39;permitToken&#39;: generateWordKey(kw)&#125;</code></pre><p><code>kw</code> 是查询的域名，有用的就是 <code>generateHostKey()</code> 和 <code>generateWordKey()</code> 两个方法了，跟进去看，代码经过了 jsjiami v6 混淆：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/66713c07ba6880c09c9dbc3604e290df.png" alt="05"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/abcc44976be8d583e2cd948e06c705d9.png" alt="06"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/3332edc2c481e2dbc672ca818c8ad060.png" alt="07"></p><h2 id="AST-脱混淆"><a href="#AST-脱混淆" class="headerlink" title="AST 脱混淆"></a>AST 脱混淆</h2><p>jsjiami 混淆的特征其实和 OB 混淆是类似的：</p><ol><li>一般由一个大数组或者含有大数组的函数、一个数组位移操作的自执行函数、一个解密函数和加密后的函数四部分组成；</li><li>函数名和变量名通常以 _0x 或者 0x 开头，后接 1~6 位数字或字母组合；</li><li>数组位移操作的自执行函数里，有明显的 push、shift 关键字。</li></ol><p>本例中，<code>generateHostKey()</code> 方法在 <code>commo.js</code> 里，<code>generateWordKey()</code> 方法在 <code>generatetoken.js</code> 里，结构如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3d1c1327ff484c80e8e308d16c71cd22.png" alt="08"></p><p>观察 <code>generatetoken.js</code> 文件，可以发现这里面也有 <code>commo.js</code> 里面的 <code>generateHostKey()</code> 和 <code>getRandom()</code> 方法，从方法名来看貌似是重复了，实际上混淆还原后方法是一样的，所以这里我们只需要还原 <code>generatetoken.js</code> 就可以了。</p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><ul><li>混淆 JS 文件：<code>generatetoken.js</code></li><li>AST 还原代码：<code>generatetokenAst.js</code></li><li>还原后的代码：<code>generatetokenNew.js</code></li></ul><h3 id="解密函数还原"><a href="#解密函数还原" class="headerlink" title="解密函数还原"></a>解密函数还原</h3><p>在原来混淆后的 JS 里，解密函数是 <code>_0x530e</code>，首先观察整个 JS，调用了很多次解密函数，类似于：<code>_0x530e(&#39;1&#39;, &#39;7XEq&#39;)</code>。</p><p>注意这里代码里面有一些特殊字符，类似于 <code>RLE</code>、<code>RLO</code> 之类的，如果在 VSCode 打开是一些 <code>U+202B</code>、<code>U+202E</code> 的字符，实际上这是 RTLO (Right-to-Left Override) 字符，<code>U+202B</code> 和 <code>U+202E</code> 的意思分别是根据内存顺序从左至右和从右至左显示字符，感兴趣的可以网上搜索了解一下。这里并不影响我们进行还原操作。但是如果直接复制过来的话就会导致前后文显示的顺序不对，所以本文中为了方便描述，粘贴的部分代码就手动去掉了这些字符。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/160a9bdb547e5cd19a94563f78addccf.png" alt="09"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/6a62938a7cb953b2c02e7e0326ea8d23.png" alt="10"></p><p>所以第一步我们要还原一下解密函数，把所有 <code>_0x530e</code> 调用的地方直接替换成实际值，首先需要将大数组、自执行函数、加密函数和解密函数分割开，将代码放到 astexplorer.net 看一下，也就是将 body 的前四部分和后面剩余部分分割开来，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/588093722962f4d006dcfeefbe90cb7a.png" alt="11"></p><p>分割代码：</p><pre><code class="javascript">const fs = require(&quot;fs&quot;);const parse = require(&quot;@babel/parser&quot;).parse;const generate = require(&quot;@babel/generator&quot;).defaultconst traverse = require(&quot;@babel/traverse&quot;).defaultconst types = require(&quot;@babel/types&quot;)// 导入混淆代码并解析为 ASTconst oldCode = fs.readFileSync(&quot;generatetoken.js&quot;, &#123;encoding: &quot;utf-8&quot;&#125;);const astCode = parse(oldCode);// 获取整个 AST 节点的长度let astCodeLength = astCode.program.body.length// 获取解密函数的名字 也就是 _0x530elet decryptFunctionName = astCode.program.body[3].id.name// 分割加密函数和解密函数，即 body 的前四部分和后面剩余部分let decryptFunction = astCode.program.body.slice(0, 4)let encryptFunction = astCode.program.body.slice(4, astCodeLength)// 获取加密函数和解密函数的方法多种多样，比如可以挨个取值并转换成 JS 代码// 这样做就不需要将解密函数赋值给整个 AST 节点了// let decryptFunction = &quot;&quot;;// for(let i=0; i&lt;4; i++)&#123;//     decryptFunction += generate(astCode.program.body[i], &#123;compact: true&#125;).code// &#125;// eval(decryptFunction);</code></pre><p>在上面的获取加密函数和解密函数的代码中，方法不是唯一的，多种多样，比如直接循环取 body 并转换成 JS 代码，比如直接人工把大数组、自执行函数和解密函数三部分，拿出来放到一个新文件里，然后导出解密方法，后续直接调用也可以。</p><p>在本例中，拿到解密函数后，需要将其赋值给整个 AST 节点，然后再将整个 AST 节点转换成 JavaScript 代码，这里注意有可能会检测代码是否格式化，所以建议转换要加一个 <code>compact</code> 参数，避免格式化，转换完成后 <code>eval</code> 执行一下，让数组位移操作完成，然后我们就可以直接调用解密函数，即 <code>_0x530e()</code>。</p><pre><code class="javascript">// 将解密函数赋值给整个 AST 节点astCode.program.body = decryptFunction// 将 AST 节点转换成 JS 代码，并 eval 执行一下decryptFunction = generate(astCode, &#123;compact: true&#125;).codeeval(decryptFunction);// 测试一下，直接调用 _0x530e 函数可以正确拿到结果// 输出 split// console.log(_0x530e(&#39;‮b&#39;, &#39;Zp9G&#39;))</code></pre><p>现在我们能直接调用解密函数 <code>_0x530e()</code> 了，接下来要做的就是怎么把混淆代码中所有调用 <code>_0x530e()</code> 的地方替换成真实值，在此之前，我们要把加密函数（<code>generateKey()</code>、<code>generateHostKey()</code>、<code>generateWordKey()</code> 和 <code>getRandom()</code>）赋值给整个 AST 节点，此时整个节点就没有大数组、自执行函数和解密函数了，解密函数 <code>_0x530e()</code> 已经被写入内存，所以后面不影响我们调用。</p><p>老样子，还是先在 astexplorer.net 看一下调用 <code>_0x530e()</code> 的地方，以 <code>_0x530e(&#39;b&#39;, &#39;Zp9G&#39;)</code> 为例，其真实值应该是 <code>split</code>，对比一下替换前后的结构，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/97d80ef9b923f117cac6e4060a4998f5.png" alt="12"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/8bf00ab1113c218219f838cd00ab21e9.png" alt="13"></p><p>可以看到节点由原来的 <code>CallExpression</code> 变成了 <code>StringLiteral</code>，所以我们可以遍历 <code>CallExpression</code>，如果函数名为解密函数名，那就通过 <code>path.toString()</code> 方法获取节点源码，也就类似 <code>_0x530e(&#39;b&#39;, &#39;Zp9G&#39;)</code> 的源码，然后 <code>eval</code> 执行一下获取其真实值，再使用 <code>types.stringLiteral()</code> 构建 <code>StringLiteral</code> 节点，最后通过 <code>path.replaceInline()</code> 方法替换节点，遍历代码如下：</p><pre><code class="javascript">// 将加密函数赋值给整个 AST 节点，此时整个节点就没有大数组、自执行函数和解密函数了astCode.program.body = encryptFunction// 调用解密函数，直接计算出类似以下方法的值并替换// 混淆代码：_0x530e(&#39;‮b&#39;, &#39;Zp9G&#39;)// 还原后：splitconst visitor1 = &#123;    CallExpression(path)&#123;        if (path.node.callee.name === decryptFunctionName &amp;&amp; path.node.arguments.length === 2)&#123;            path.replaceInline(types.stringLiteral(eval(path.toString())))        &#125;    &#125;&#125;// 遍历节点traverse(astCode, visitor1)// 将 AST 节点转换成 JS 代码并写入到新文件里const result = generate(astCode, &#123;concise:true&#125;).codefs.writeFile(&quot;./generatetokenNew.js&quot;, result, (err =&gt; &#123;console.log(err)&#125;))</code></pre><p>自此，第一步的解密函数还原就完成了，可以看一下还原前后的对比，如下图所示浅蓝色标记的地方，所有调用 <code>_0x530e()</code> 的地方都被还原了：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/592ed12ad85ea4b424c8b59a99e03bc9.png" alt="14"></p><h3 id="大对象还原"><a href="#大对象还原" class="headerlink" title="大对象还原"></a>大对象还原</h3><p>初步还原后我们的代码里就只剩下以下四个方法：</p><ul><li><code>generateKey()</code></li><li><code>generateHostKey()</code></li><li><code>generateWordKey()</code></li><li> <code>getRandom()</code></li></ul><p>再观察代码，发现每个方法一开始都有个大的对象，他们分别是：</p><ul><li><code>_0x3b79c6</code></li><li><code>_0x278b2d</code></li><li><code>_0x4115c4</code></li><li><code>_0xd8ec33</code></li></ul><p>后续的代码也在不断调用这个对象的方法，比如 <code>_0x3b79c6[&quot;esdtg&quot;](_0x2e5848[&quot;length&quot;], 0x4)</code> 实际上就是 <code>_0x2e5848[&quot;length&quot;] != 0x4</code>，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/dad85b7cf44527da212f026cf6f8fd36.png" alt="15"></p><p>首先我们将这四个大的对象单独提取出来，还是保持原来的键值对样式，提取完成后删除这两个节点，遍历代码如下：</p><pre><code class="javascript">let functionName = &#123;    &quot;_0x3b79c6&quot;: &#123;&#125;,    &quot;_0x278b2d&quot;: &#123;&#125;,    &quot;_0x4115c4&quot;: &#123;&#125;,    &quot;_0xd8ec33&quot;: &#123;&#125;&#125;// 单独提取出四个大对象const visitor2 = &#123;    VariableDeclarator(path)&#123;        for (let key in functionName)&#123;            if (path.node &amp;&amp; path.node.id.name == key) &#123;                const properties = path.node.init.properties                for (let i=0; i&lt;properties.length; i++)&#123;                    functionName[key][properties[i].key.value] = properties[i].value                &#125;                // 写入对象后就可以删除该节点了                path.remove()            &#125;        &#125;    &#125;&#125;</code></pre><p>这里要注意，大的对象里面，有 <code>+</code>、<code>-</code>、<code>==</code> 之类的二项式计算，也有直接为字符串的，还有变成函数调用的，如下所示：</p><pre><code class="JavaScript">var _0x3b79c6 = &#123;    &#39;MuRlB&#39;: function (_0x3ca134, _0x50ee94) &#123;        return _0x3ca134 + _0x50ee94;    &#125;,     &#39;Ucwyj&#39;: function (_0x32bfa3, _0x3b191b) &#123;        return _0x32bfa3(_0x3b191b);    &#125;,     &#39;YrYQW&#39;: &#39;#IpValue&#39;&#125;</code></pre><p>针对不同的情况有不同的处理方法，同时还要注意传参和 return 返回的参数位置，不要还原后把 <code>a - b</code> 搞成 <code>b - a</code> 了，当然在本例中传入和返回的顺序是一样的，就不需要考虑这个问题。</p><h4 id="字符串还原"><a href="#字符串还原" class="headerlink" title="字符串还原"></a>字符串还原</h4><p>首先来看字符串，有以下几种情况：</p><ul><li>以 <code>_0x3b79c6[&#39;YrYQW&#39;]</code> 为例，实际上其值为字符串 <code>&#39;#IpValue&#39;</code>，观察其结构，是一个 <code>MemberExpression</code>，在一个列表里；</li><li>以 <code>_0x278b2d[&#39;pjbyX&#39;]</code> 为例，实际上其值为字符串 <code>&#39;3|2|1|4|5|0|6&#39;</code>，观察其结构，是一个 <code>MemberExpression</code>，在一个字典里；</li><li>以 <code>_0x278b2d[&#39;CnTaO&#39;]</code> 为例，虽然也是一个 <code>MemberExpression</code>，也在一个字典里。但实际上是二项式计算，所以要排除在外。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/c7da2da4b18ea101be336632d3302e9b.png" alt="16"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/bb64748de3614028d49b5445a8f0a4bd.png" alt="17"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/2d864c898a10fe2512de55ae0aae6b4b.png" alt="18"></p><p>所以我们在写遍历代码时，同时要注意这三种情况，满足条件后直接取原来大对象对应的节点进行替换即可，遍历代码如下所示：</p><pre><code class="javascript">// 函数替换，字符串替换：将类似 _0x3b79c6[&#39;YrYQW&#39;] 变成 &#39;#IpValue&#39;const visitor3 = &#123;    MemberExpression(path) &#123;        for (let key in functionName)&#123;            if (path.node.object &amp;&amp; path.node.object.name == key &amp;&amp; path.inList ) &#123;                path.replaceInline(functionName[key][path.node.property.value])            &#125;            if (path.node.object &amp;&amp; path.node.object.name == key &amp;&amp; path.parent.property &amp;&amp; path.parent.property.value == &quot;split&quot;) &#123;                path.replaceInline(functionName[key][path.node.property.value])            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="二项式计算替换"><a href="#二项式计算替换" class="headerlink" title="二项式计算替换"></a>二项式计算替换</h4><p>再来看看二项式计算的情况，以 <code>_0x278b2d[&#39;CnTaO&#39;](_0x691267[&quot;length&quot;], 0x1)</code> 为例，实际上是做减法运算，即 <code>_0x691267[&quot;length&quot;] - 0x1</code>，看一下替换前后对比：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/15473cd5662d90370f1bdd845bd6f42a.png" alt="19"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c2c67cc2f0760f493d99a29281599894.png" alt="20"></p><p>对于这种情况，我们可以直接提取两个参数，然后提取大对象里对应方法的操作符，然后将参数和操作符直接连接起来组成新的节点（<code>binaryExpression</code>）并替换即可，遍历代码如下：</p><pre><code class="javascript">// 函数替换，二项式计算：将类似 _0x278b2d[&#39;CnTaO&#39;](_0x691267[&quot;length&quot;], 0x1) 变成 _0x691267[&quot;length&quot;] - 0x1const visitor4 = &#123;    CallExpression(path)&#123;        for (let key in functionName) &#123;            if (path.node.callee &amp;&amp; path.node.callee.object &amp;&amp; path.node.callee.object.name == key) &#123;                let func = functionName[key][path.node.callee.property.value]                if (func.body.body[0].argument.type == &quot;BinaryExpression&quot;) &#123;                    let operator = func.body.body[0].argument.operator                    let left = path.node.arguments[0]                    let right = path.node.arguments[1]                    path.replaceInline(types.binaryExpression(operator, left, right))                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="方法调用还原"><a href="#方法调用还原" class="headerlink" title="方法调用还原"></a>方法调用还原</h4><p>以 <code>_0x4115c4[&quot;PJbSm&quot;](getRandom, 0x64, 0x3e7)</code> 为例，实际上是 <code>getRandom(0x64, 0x3e7)</code>，看一下替换前后对比：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0214e34c163d988a87ae74c287aa4fb9.png" alt="21"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/618a03ab22a77658de6b3f90232ad8cd.png" alt="22"></p><p>对于这种情况，传入的第一个参数为方法名称，后面的都是参数，那么可以直接取第一个元素为方法名称，使用 <code>slice(1)</code> 方法取后面所有的参数（因为后面的参数个数是不一定的），然后构造新的节点（<code>callExpression</code>）并替换即可，这部分遍历代码可以和前面二项式的替换相结合，代码如下：</p><pre><code class="javascript">// 函数替换，二项式计算：将类似 _0x278b2d[&#39;CnTaO&#39;](_0x691267[&quot;length&quot;], 0x1) 变成 _0x691267[&quot;length&quot;] - 0x1// 函数替换，方法调用：将类似 _0x4115c4[&quot;PJbSm&quot;](getRandom, 0x64, 0x3e7) 变成 getRandom(0x64, 0x3e7)const visitor4 = &#123;    CallExpression(path)&#123;        for (let key in functionName) &#123;            if (path.node.callee &amp;&amp; path.node.callee.object &amp;&amp; path.node.callee.object.name == key) &#123;                let func = functionName[key][path.node.callee.property.value]                if (func.body.body[0].argument.type == &quot;BinaryExpression&quot;) &#123;                    let operator = func.body.body[0].argument.operator                    let left = path.node.arguments[0]                    let right = path.node.arguments[1]                    path.replaceInline(types.binaryExpression(operator, left, right))                &#125;                if (func.body.body[0].argument.type == &quot;CallExpression&quot;) &#123;                    let identifier = path.node.arguments[0]                    let arguments = path.node.arguments.slice(1)                    path.replaceInline(types.callExpression(identifier, arguments))                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>自此，第二步的大对象还原就完成了，可以看一下还原前后的对比，如下图所示浅蓝色标记的地方，所有调用四个大对象（<code>_0x3b79c6</code>、<code>_0x278b2d</code>、<code>_0x4115c4</code>、<code>_0xd8ec33</code>）的地方都被还原了：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7d6b3b0a9c46e31799e0c8d15b3a7b86.png" alt="23"></p><h3 id="switch-case-反控制流平坦化"><a href="#switch-case-反控制流平坦化" class="headerlink" title="switch-case 反控制流平坦化"></a>switch-case 反控制流平坦化</h3><p>经过前面几步的还原之后，我们发现 <code>generateHostKey()</code>、<code>generateWordKey()</code>、<code>getRandom()</code> 方法里都有一个 <code>switch-case</code> 的控制流，关于反控制流平坦化的讲解在我上期文章有很详细的介绍，不理解的可以看看上期文章，此处也不再赘述了，直接贴代码了：</p><pre><code class="javascript">// switch-case 反控制流平坦化const visitor5 = &#123;    WhileStatement(path) &#123;        // switch 节点        let switchNode = path.node.body.body[0];        // switch 语句内的控制流数组名，本例中是 _0x28073a、_0x2efb35、_0x187fb8        let arrayName = switchNode.discriminant.object.name;        // 获取控制流数组绑定的节点        let bindingArray = path.scope.getBinding(arrayName);        // 获取节点整个表达式的参数、分割方法、分隔符        let init = bindingArray.path.node.init;        let object = init.callee.object.value;        let property = init.callee.property.value;        let argument = init.arguments[0].value;        // 模拟执行 &#39;3|2|1|4|5|0|6&#39;[&#39;split&#39;](&#39;|&#39;) 语句        let array = object[property](argument)        // 也可以直接取参数进行分割，方法不通用，比如分隔符换成 , 就不行了        // let array = init.callee.object.value.split(&#39;|&#39;);        // switch 语句内的控制流自增变量名，本例中是 _0x38c69e、_0x396880、_0x3b3dc7        let autoIncrementName = switchNode.discriminant.property.argument.name;        // 获取控制流自增变量名绑定的节点        let bindingAutoIncrement = path.scope.getBinding(autoIncrementName);        // 可选择的操作：删除控制流数组绑定的节点、自增变量名绑定的节点        bindingArray.path.remove();        bindingAutoIncrement.path.remove();        // 储存正确顺序的控制流语句        let replace = [];        // 遍历控制流数组，按正确顺序取 case 内容        array.forEach(index =&gt; &#123;                let consequent = switchNode.cases[index].consequent;                // 如果最后一个节点是 continue 语句，则删除 ContinueStatement 节点                if (types.isContinueStatement(consequent[consequent.length - 1])) &#123;                    consequent.pop();                &#125;                // concat 方法拼接多个数组，即正确顺序的 case 内容                replace = replace.concat(consequent);            &#125;        );        // 替换整个 while 节点，两种方法都可以        path.replaceWithMultiple(replace);        // path.replaceInline(replace);    &#125;&#125;</code></pre><h3 id="其他细节还原"><a href="#其他细节还原" class="headerlink" title="其他细节还原"></a>其他细节还原</h3><p>到这里其实大部分混淆都已经还原了，已经很容易分析其逻辑了，还剩下一些细节，我们也还原一下，主要有以下细节：</p><ul><li>十六进制、Unicode 编码等，转正常字符；</li><li>对象属性还原，比如 <code>_0x3cbc20[&#39;length&#39;]</code> 转换成 <code>_0x3cbc20.length</code>；</li><li>表达式还原，比如 <code>!![]</code> 直接计算成 true；</li><li>删除未引用的变量，比如 <code>_0xodD= &quot;jsjiami.com.v6&quot;;</code>；</li><li>删除冗余逻辑代码，只保留 if 为 true 的。</li></ul><p>这些还原代码在我上期文章有详细讲过，结合代码，在 astexplorer.net 对照其结构看，也能理解，同样也不赘述了，直接贴代码：</p><pre><code class="javascript">const visitor5 = &#123;    // 十六进制、Unicode 编码等，转正常字符    &quot;StringLiteral|NumericLiteral&quot;(path)&#123;        delete path.node.extra;    &#125;,    // _0x3cbc20[&quot;length&quot;] 转换成 _0x3cbc20.length    MemberExpression(path)&#123;        if (path.node.property.type == &quot;StringLiteral&quot;) &#123;            path.node.computed = false            path.node.property = types.identifier(path.node.property.value)        &#125;    &#125;,    // 表达式还原，!![] 直接计算成 true    &quot;BinaryExpression|UnaryExpression&quot;(path) &#123;        let &#123;confident, value&#125; = path.evaluate()        if (confident)&#123;            path.replaceInline(types.valueToNode(value))        &#125;    &#125;,    // 删除未引用的变量，比如 _0xodD = &quot;jsjiami.com.v6&quot;;    AssignmentExpression(path)&#123;        let binding = path.scope.getBinding(path.node.left.name);        if (!binding) &#123;            path.remove();        &#125;    &#125;&#125;// 删除冗余逻辑代码，只保留 if 为 true 的const visitor6 = &#123;    IfStatement(path) &#123;        if(path.node.test.type == &quot;BooleanLiteral&quot;) &#123;            if(path.node.test.value) &#123;                path.replaceInline(path.node.consequent.body)            &#125; else &#123;                path.replaceInline(path.node.alternate.body)            &#125;        &#125;    &#125;&#125;</code></pre><p>自此 jajiami v6 混淆就还原完毕了，还原前后对比一下，代码量缩短了很多，逻辑也更加清楚了，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/52f0ccf4ce30a1c150ddd25e8f189ab0.png" alt="24"></p><p>最后结合 Python 代码，携带生成的 <code>hostToken</code> 和 <code>permitToken</code>，成功拿到备案号：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4b54ca38cc38d9776bdb39c52ed25c93.png" alt="25"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>原混淆代码 <code>generatetoken.js</code>、AST 脱混淆代码 <code>generatetokenAst.js</code>、还原后的代码 <code>generatetokenNew.js</code>，以及 Python 测试代码均在 GitHub，均有详细注释，欢迎 Star。所有内容仅供学习交流，严禁用于商业用途、非法用途，否则由此产生的一切后果均与作者无关，在仓库中下载的文件学习完毕之后请于 24 小时内删除！</p><p>代码地址：<a href="https://github.com/TRHX/Python3-Spider-Practice">https://github.com/TRHX/Python3-Spider-Practice</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文章中所有内容仅供学习交流，抓包内容、敏感网址、数据接口均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果</summary>
      
    
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91/"/>
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>逆向进阶，利用 AST 技术还原 JavaScript 混淆代码</title>
    <link href="https://www.itbob.cn/article/051/"/>
    <id>https://www.itbob.cn/article/051/</id>
    <published>2022-04-25T09:00:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-AST"><a href="#什么是-AST" class="headerlink" title="什么是 AST"></a>什么是 AST</h2><p>AST（Abstract Syntax Tree），中文抽象语法树，简称语法树（Syntax Tree），是源代码的抽象语法结构的树状表现形式，树上的每个节点都表示源代码中的一种结构。语法树不是某一种编程语言独有的，JavaScript、Python、Java、Golang 等几乎所有编程语言都有语法树。</p><p>小时候我们得到一个玩具，总喜欢把玩具拆解成一个一个小零件，然后按照我们自己的想法，把零件重新组装起来，一个新玩具就诞生了。而 JavaScript 就像一台精妙运作的机器，通过 AST 解析，我们也可以像童年时拆解玩具一样，深入了解 JavaScript 这台机器的各个零部件，然后重新按照我们自己的意愿来组装。</p><p>AST 的用途很广，IDE 的语法高亮、代码检查、格式化、压缩、转译等，都需要先将代码转化成 AST 再进行后续的操作，ES5 和 ES6 语法差异，为了向后兼容，在实际应用中需要进行语法的转换，也会用到 AST。AST 并不是为了逆向而生，但做逆向学会了 AST，在解混淆时可以如鱼得水。</p><p>AST 有一个在线解析网站：<a href="https://astexplorer.net/">https://astexplorer.net/</a> ，顶部可以选择语言、编译器、是否开启转化等，如下图所示，区域①是源代码，区域②是对应的 AST 语法树，区域③是转换代码，可以对语法树进行各种操作，区域④是转换后生成的新代码。图中原来的 Unicode 字符经过操作之后就变成了正常字符。</p><p>语法树没有单一的格式，选择不同的语言、不同的编译器，得到的结果也是不一样的，在 JavaScript 中，编译器有 Acorn、Espree、Esprima、Recast、Uglify-JS 等，使用最多的是 Babel，后续的学习也是以 Babel 为例。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3e56f2edec502087a2bb0b10ef178b52.png" alt="01"></p><h2 id="AST-在编译中的位置"><a href="#AST-在编译中的位置" class="headerlink" title="AST 在编译中的位置"></a>AST 在编译中的位置</h2><p>在编译原理中，编译器转换代码通常要经过三个步骤：词法分析（Lexical Analysis）、语法分析（Syntax Analysis）、代码生成（Code Generation），下图生动展示了这一过程：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/90fe33b7b362f60e1ee1849bf3c06fc9.png" alt="02"></p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词法分析阶段是编译过程的第一个阶段，这个阶段的任务是从左到右一个字符一个字符地读入源程序，然后根据构词规则识别单词，生成 token 符号流，比如 <code>isPanda(&#39;🐼&#39;)</code>，会被拆分成 <code>isPanda</code>，<code>(</code>，<code>&#39;🐼&#39;</code>，<code>)</code> 四部分，每部分都有不同的含义，可以将词法分析过程想象为不同类型标记的列表或数组。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/de8a6906cf7db9be51ef2eb56cbd1b70.gif#pic_center" alt="03"></p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法分析是编译过程的一个逻辑阶段，语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，比如“程序”，“语句”，“表达式”等，前面的例子中，<code>isPanda(&#39;🐼&#39;)</code> 就会被分析为一条表达语句 <code>ExpressionStatement</code>，<code>isPanda()</code> 就会被分析成一个函数表达式 <code>CallExpression</code>，<code>🐼</code> 就会被分析成一个变量 <code>Literal</code> 等，众多语法之间的依赖、嵌套关系，就构成了一个树状结构，即 AST 语法树。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/45b5484465969681707f32a2dde5370b.gif#pic_center" alt="04"></p><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>代码生成是最后一步，将 AST 语法树转换成可执行代码即可，在转换之前，我们可以直接操作语法树，进行增删改查等操作，例如，我们可以确定变量的声明位置、更改变量的值、删除某些节点等，我们将语句 <code>isPanda(&#39;🐼&#39;)</code> 修改为一个布尔类型的 <code>Literal</code>：<code>true</code>，语法树就有如下变化：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6659a4f8614b61a4d6376aadca326f88.gif#pic_center" alt="05"></p><h2 id="Babel-简介"><a href="#Babel-简介" class="headerlink" title="Babel 简介"></a>Babel 简介</h2><p>Babel 是一个 JavaScript 编译器，也可以说是一个解析库，Babel 中文网：<a href="https://www.babeljs.cn/">https://www.babeljs.cn/</a> ，Babel 英文官网：<a href="https://babeljs.io/">https://babeljs.io/</a> ，Babel 内置了很多分析 JavaScript 代码的方法，我们可以利用 Babel 将 JavaScript 代码转换成 AST 语法树，然后增删改查等操作之后，再转换成 JavaScript 代码。</p><p>Babel 包含的各种功能包、API、各方法可选参数等，都非常多，本文不一一列举，在实际使用过程中，应当多查询官方文档，或者参考文末给出的一些学习资料。Babel 的安装和其他 Node 包一样，需要哪个安装哪个即可，比如 <code>npm install @babel/core @babel/parser @babel/traverse @babel/generator</code></p><p>在做逆向解混淆中，主要用到了 Babel 的以下几个功能包，本文也仅介绍以下几个功能包：</p><ol><li><code>@babel/core</code>：Babel 编译器本身，提供了 babel 的编译 API；</li><li><code>@babel/parser</code>：将 JavaScript 代码解析成 AST 语法树；</li><li><code>@babel/traverse</code>：遍历、修改 AST 语法树的各个节点；</li><li><code>@babel/generator</code>：将 AST 还原成 JavaScript 代码；</li><li><code>@babel/types</code>：判断、验证节点的类型、构建新 AST 节点等。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/f8be61bdf850b955459dd4d476f80822.png" alt="06"></p><h3 id="babel-core"><a href="#babel-core" class="headerlink" title="@babel/core"></a>@babel/core</h3><p>Babel 编译器本身，被拆分成了三个模块：<code>@babel/parser</code>、<code>@babel/traverse</code>、<code>@babel/generator</code>，比如以下方法的导入效果都是一样的：</p><pre><code class="javascript">const parse = require(&quot;@babel/parser&quot;).parse;const parse = require(&quot;@babel/core&quot;).parse;const traverse = require(&quot;@babel/traverse&quot;).defaultconst traverse = require(&quot;@babel/core&quot;).traverse</code></pre><h3 id="babel-parser"><a href="#babel-parser" class="headerlink" title="@babel/parser"></a>@babel/parser</h3><p><code>@babel/parser</code> 可以将 JavaScript 代码解析成 AST 语法树，其中主要提供了两个方法：</p><ul><li><code>parser.parse(code, [&#123;options&#125;])</code>：解析一段 JavaScript 代码；</li><li><code>parser.parseExpression(code, [&#123;options&#125;])</code>：考虑到了性能问题，解析单个 JavaScript 表达式。</li></ul><p>部分可选参数 <code>options</code>：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>allowImportExportEverywhere</code></td><td>默认 <code>import</code> 和 <code>export</code> 声明语句只能出现在程序的最顶层，设置为 <code>true</code> 则在任何地方都可以声明</td></tr><tr><td><code>allowReturnOutsideFunction</code></td><td>默认如果在顶层中使用 <code>return</code> 语句会引起错误，设置为 <code>true</code> 就不会报错</td></tr><tr><td><code>sourceType</code></td><td>默认为 <code>script</code>，当代码中含有 <code>import</code> 、<code>export</code> 等关键字时会报错，需要指定为 <code>module</code></td></tr><tr><td><code>errorRecovery</code></td><td>默认如果 babel 发现一些不正常的代码就会抛出错误，设置为 <code>true</code> 则会在保存解析错误的同时继续解析代码，错误的记录将被保存在最终生成的 AST 的 errors 属性中，当然如果遇到严重的错误，依然会终止解析</td></tr></tbody></table><p>举个例子看得比较清楚：</p><pre><code class="javascript">const parser = require(&quot;@babel/parser&quot;);const code = &quot;const a = 1;&quot;;const ast = parser.parse(code, &#123;sourceType: &quot;module&quot;&#125;)console.log(ast)</code></pre><p><code>&#123;sourceType: &quot;module&quot;&#125;</code> 演示了如何添加可选参数，输出的就是 AST 语法树，这和在线网站 <a href="https://astexplorer.net/">https://astexplorer.net/</a> 解析出来的语法树是一样的：</p><p><img src="https://img-blog.csdnimg.cn/cb7791be87be4a4c8f47add3228e3d58.png" alt="07"></p><h3 id="babel-generator"><a href="#babel-generator" class="headerlink" title="@babel/generator"></a>@babel/generator</h3><p><code>@babel/generator</code> 可以将 AST 还原成 JavaScript 代码，提供了一个 <code>generate</code> 方法：<code>generate(ast, [&#123;options&#125;], code)</code>。</p><p>部分可选参数 <code>options</code>：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>auxiliaryCommentBefore</code></td><td>在输出文件内容的头部添加注释块文字</td></tr><tr><td><code>auxiliaryCommentAfter</code></td><td>在输出文件内容的末尾添加注释块文字</td></tr><tr><td><code>comments</code></td><td>输出内容是否包含注释</td></tr><tr><td><code>compact</code></td><td>输出内容是否不添加空格，避免格式化</td></tr><tr><td><code>concise</code></td><td>输出内容是否减少空格使其更紧凑一些</td></tr><tr><td><code>minified</code></td><td>是否压缩输出代码</td></tr><tr><td><code>retainLines</code></td><td>尝试在输出代码中使用与源代码中相同的行号</td></tr></tbody></table><p>接着前面的例子，原代码是 <code>const a = 1;</code>，现在我们把 <code>a</code> 变量修改为 <code>b</code>，值 <code>1</code> 修改为 <code>2</code>，然后将 AST 还原生成新的 JS 代码：</p><pre><code class="javascript">const parser = require(&quot;@babel/parser&quot;);const generate = require(&quot;@babel/generator&quot;).defaultconst code = &quot;const a = 1;&quot;;const ast = parser.parse(code, &#123;sourceType: &quot;module&quot;&#125;)ast.program.body[0].declarations[0].id.name = &quot;b&quot;ast.program.body[0].declarations[0].init.value = 2const result = generate(ast, &#123;minified: true&#125;)console.log(result.code)</code></pre><p>最终输出的是 <code>const b=2;</code>，变量名和值都成功更改了，由于加了压缩处理，等号左右两边的空格也没了。</p><p>代码里 <code>&#123;minified: true&#125;</code> 演示了如何添加可选参数，这里表示压缩输出代码，<code>generate</code> 得到的 <code>result</code> 得到的是一个对象，其中的 <code>code</code> 属性才是最终的 JS 代码。</p><p>代码里 <code>ast.program.body[0].declarations[0].id.name</code> 是 a 在 AST 中的位置，<code>ast.program.body[0].declarations[0].init.value</code> 是 1 在 AST 中的位置，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0ffbf3d9a54e2de3c779735aeac0e3e4.png" alt="08"></p><h3 id="babel-traverse"><a href="#babel-traverse" class="headerlink" title="@babel/traverse"></a>@babel/traverse</h3><p>当代码多了，我们不可能像前面那样挨个定位并修改，对于相同类型的节点，我们可以直接遍历所有节点来进行修改，这里就用到了 <code>@babel/traverse</code>，它通常和 <code>visitor</code> 一起使用，<code>visitor</code> 是一个对象，这个名字是可以随意取的，<code>visitor</code> 里可以定义一些方法来过滤节点，这里还是用一个例子来演示：</p><pre><code class="javascript">const parser = require(&quot;@babel/parser&quot;);const generate = require(&quot;@babel/generator&quot;).defaultconst traverse = require(&quot;@babel/traverse&quot;).defaultconst code = `const a = 1500;const b = 60;const c = &quot;hi&quot;;const d = 787;const e = &quot;1244&quot;;`const ast = parser.parse(code)const visitor = &#123;    NumericLiteral(path)&#123;        path.node.value = (path.node.value + 100) * 2    &#125;,    StringLiteral(path)&#123;        path.node.value = &quot;I Love JavaScript!&quot;    &#125;&#125;traverse(ast, visitor)const result = generate(ast)console.log(result.code)</code></pre><p>这里的原始代码定义了 abcde 五个变量，其值有数字也有字符串，我们在 AST 中可以看到对应的类型为 <code>NumericLiteral</code> 和 <code>StringLiteral</code>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b0a932b29fef0ad7a6f20dbc88f3ec46.png" alt="09"></p><p>然后我们声明了一个 <code>visitor</code> 对象，然后定义对应类型的处理方法，<code>traverse</code> 接收两个参数，第一个是 AST 对象，第二个是 <code>visitor</code>，当 <code>traverse</code> 遍历所有节点，遇到节点类型为 <code>NumericLiteral</code> 和 <code>StringLiteral</code> 时，就会调用 <code>visitor</code> 中对应的处理方法，<code>visitor</code> 中的方法会接收一个当前节点的 <code>path</code> 对象，该对象的类型是 <code>NodePath</code>，该对象有非常多的属性，以下介绍几种最常用的：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>toString()</code></td><td>当前路径的源码</td></tr><tr><td><code>node</code></td><td>当前路径的节点</td></tr><tr><td><code>parent</code></td><td>当前路径的父级节点</td></tr><tr><td><code>parentPath</code></td><td>当前路径的父级路径</td></tr><tr><td><code>type</code></td><td>当前路径的类型</td></tr></tbody></table><p>PS：<code>path</code> 对象除了有很多属性以外，还有很多方法，比如替换节点、删除节点、插入节点、寻找父级节点、获取同级节点、添加注释、判断节点类型等，可在需要时查询相关文档或查看源码，后续介绍 <code>@babel/types</code> 部分将会举部分例子来演示，以后的实战文章中也会有相关实例，篇幅有限本文不再细说。</p><p>因此在上面的代码中，<code>path.node.value</code> 就拿到了变量的值，然后我们就可以进一步对其进行修改了。以上代码运行后，所有数字都会加上100后再乘以2，所有字符串都会被替换成 <code>I Love JavaScript!</code>，结果如下：</p><pre><code class="javascript">const a = 3200;const b = 320;const c = &quot;I Love JavaScript!&quot;;const d = 1774;const e = &quot;I Love JavaScript!&quot;;</code></pre><p>如果多个类型的节点，处理的方式都一样，那么还可以使用 <code>|</code> 将所有节点连接成字符串，将同一个方法应用到所有节点：</p><pre><code class="javascript">const visitor = &#123;    &quot;NumericLiteral|StringLiteral&quot;(path) &#123;        path.node.value = &quot;I Love JavaScript!&quot;    &#125;&#125;</code></pre><p><code>visitor</code> 对象有多种写法，以下几种写法的效果都是一样的：</p><pre><code class="javascript">const visitor = &#123;    NumericLiteral(path)&#123;        path.node.value = (path.node.value + 100) * 2    &#125;,    StringLiteral(path)&#123;        path.node.value = &quot;I Love JavaScript!&quot;    &#125;&#125;</code></pre><pre><code class="javascript">const visitor = &#123;    NumericLiteral: function (path)&#123;        path.node.value = (path.node.value + 100) * 2    &#125;,    StringLiteral: function (path)&#123;        path.node.value = &quot;I Love JavaScript!&quot;    &#125;&#125;</code></pre><pre><code class="javascript">const visitor = &#123;    NumericLiteral: &#123;        enter(path) &#123;            path.node.value = (path.node.value + 100) * 2        &#125;    &#125;,    StringLiteral: &#123;        enter(path) &#123;            path.node.value = &quot;I Love JavaScript!&quot;        &#125;    &#125;&#125;</code></pre><pre><code class="javascript">const visitor = &#123;    enter(path) &#123;        if (path.node.type === &quot;NumericLiteral&quot;) &#123;            path.node.value = (path.node.value + 100) * 2        &#125;        if (path.node.type === &quot;StringLiteral&quot;) &#123;            path.node.value = &quot;I Love JavaScript!&quot;        &#125;    &#125;&#125;</code></pre><p>以上几种写法中有用到了 <code>enter</code> 方法，在节点的遍历过程中，进入节点（enter）与退出（exit）节点都会访问一次节点，<code>traverse</code> 默认在进入节点时进行节点的处理，如果要在退出节点时处理，那么在 <code>visitor</code> 中就必须声明 <code>exit</code> 方法。</p><h3 id="babel-types"><a href="#babel-types" class="headerlink" title="@babel/types"></a>@babel/types</h3><p><code>@babel/types</code> 主要用于构建新的 AST 节点，前面的示例代码为 <code>const a = 1;</code>，如果想要增加内容，比如变成 <code>const a = 1; const b = a * 5 + 1;</code>，就可以通过 <code>@babel/types</code> 来实现。</p><p>首先观察一下 AST 语法树，原语句只有一个 <code>VariableDeclaration</code> 节点，现在增加了一个：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7319ba7290bf4d5c94d86c3c0d89e288.png" alt="10"></p><p>那么我们的思路就是在遍历节点时，遍历到 <code>VariableDeclaration</code> 节点，就在其后面增加一个 <code>VariableDeclaration</code> 节点，生成  <code>VariableDeclaration</code> 节点，可以使用 <code>types.variableDeclaration()</code> 方法，在 types 中各种方法名称和我们在 AST 中看到的是一样的，只不过首字母是小写的，所以我们不需要知道所有方法的情况下，也能大致推断其方法名，只知道这个方法还不行，还得知道传入的参数是什么，可以查文档，不过这里推荐直接看源码，非常清晰明了，以 Pycharm 为例，按住 Ctrl 键，再点击方法名，就进到源码里了：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/59b5979bae2fa54c199c8040f2442d04.png" alt="11"></p><pre><code class="javascript">function variableDeclaration(kind: &quot;var&quot; | &quot;let&quot; | &quot;const&quot;, declarations: Array&lt;BabelNodeVariableDeclarator&gt;)</code></pre><p>可以看到需要 <code>kind</code> 和 <code>declarations</code> 两个参数，其中 <code>declarations</code> 是 <code>VariableDeclarator</code> 类型的节点组成的列表，所以我们可以先写出以下 <code>visitor</code> 部分的代码，其中 <code>path.insertAfter()</code> 是在该节点之后插入新节点的意思：</p><pre><code class="javascript">const visitor = &#123;    VariableDeclaration(path) &#123;        let declaration = types.variableDeclaration(&quot;const&quot;, [declarator])        path.insertAfter(declaration)    &#125;&#125;</code></pre><p>接下来我们还需要进一步定义 <code>declarator</code>，也就是 <code>VariableDeclarator</code> 类型的节点，查询其源码如下：</p><pre><code class="javascript">function variableDeclarator(id: BabelNodeLVal, init?: BabelNodeExpression)</code></pre><p>观察 AST，id 为 <code>Identifier</code> 对象，init 为 <code>BinaryExpression</code> 对象，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/050533c545ec5244818054a2e2572cc4.png" alt="12"></p><p>先来处理 id，可以使用 <code>types.identifier()</code> 方法来生成，其源码为 <code>function identifier(name: string)</code>，name 在这里就是 b 了，此时 <code>visitor</code> 代码就可以这么写：</p><pre><code class="javascript">const visitor = &#123;    VariableDeclaration(path) &#123;        let declarator = types.variableDeclarator(types.identifier(&quot;b&quot;), init)        let declaration = types.variableDeclaration(&quot;const&quot;, [declarator])        path.insertAfter(declaration)    &#125;&#125;</code></pre><p>然后再来看 init 该如何定义，首先仍然是看 AST 结构：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a927d6abed41d43251e3c3c2a432e46f.png" alt="13"></p><p>init 为 <code>BinaryExpression</code> 对象，left 左边是 <code>BinaryExpression</code>，right 右边是 <code>NumericLiteral</code>，可以用 <code>types.binaryExpression()</code> 方法来生成 init，其源码如下：</p><pre><code class="javascript">function binaryExpression(    operator: &quot;+&quot; | &quot;-&quot; | &quot;/&quot; | &quot;%&quot; | &quot;*&quot; | &quot;**&quot; | &quot;&amp;&quot; | &quot;|&quot; | &quot;&gt;&gt;&quot; | &quot;&gt;&gt;&gt;&quot; | &quot;&lt;&lt;&quot; | &quot;^&quot; | &quot;==&quot; | &quot;===&quot; | &quot;!=&quot; | &quot;!==&quot; | &quot;in&quot; | &quot;instanceof&quot; | &quot;&gt;&quot; | &quot;&lt;&quot; | &quot;&gt;=&quot; | &quot;&lt;=&quot;,    left: BabelNodeExpression | BabelNodePrivateName,     right: BabelNodeExpression)</code></pre><p>此时 <code>visitor</code> 代码就可以这么写：</p><pre><code class="javascript">const visitor = &#123;    VariableDeclaration(path) &#123;        let init = types.binaryExpression(&quot;+&quot;, left, right)        let declarator = types.variableDeclarator(types.identifier(&quot;b&quot;), init)        let declaration = types.variableDeclaration(&quot;const&quot;, [declarator])        path.insertAfter(declaration)    &#125;&#125;</code></pre><p>然后继续构造 left 和 right，和前面的方法一样，观察 AST 语法树，查询对应方法应该传入的参数，层层嵌套，直到把所有的节点都构造完毕，最终的 <code>visitor</code> 代码应该是这样的：</p><pre><code class="javascript">const visitor = &#123;    VariableDeclaration(path) &#123;        let left = types.binaryExpression(&quot;*&quot;, types.identifier(&quot;a&quot;), types.numericLiteral(5))        let right = types.numericLiteral(1)        let init = types.binaryExpression(&quot;+&quot;, left, right)        let declarator = types.variableDeclarator(types.identifier(&quot;b&quot;), init)        let declaration = types.variableDeclaration(&quot;const&quot;, [declarator])        path.insertAfter(declaration)        path.stop()    &#125;&#125;</code></pre><p>注意：<code>path.insertAfter()</code> 插入节点语句后面加了一句 <code>path.stop()</code>，表示插入完成后立即停止遍历当前节点和后续的子节点，添加的新节点也是 <code>VariableDeclaration</code>，如果不加停止语句的话，就会无限循环插入下去。</p><p>插入新节点后，再转换成 JavaScript 代码，就可以看到多了一行新代码，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/79269e1d54071214b2438eed3bf58d15.png" alt="14"></p><h2 id="常见混淆还原"><a href="#常见混淆还原" class="headerlink" title="常见混淆还原"></a>常见混淆还原</h2><p>了解了 AST 和 babel 后，就可以对 JavaScript 混淆代码进行还原了，以下是部分样例，带你进一步熟悉 babel 的各种操作。</p><h3 id="字符串还原"><a href="#字符串还原" class="headerlink" title="字符串还原"></a>字符串还原</h3><p>文章开头的图中举了个例子，正常字符被换成了 Unicode 编码：</p><pre><code class="javascript">console[&#39;\u006c\u006f\u0067&#39;](&#39;\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u006f\u0072\u006c\u0064\u0021&#39;)</code></pre><p>观察 AST 结构：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/59b4fc53c0c3aa2a0873a76a5d88c175.png" alt="15"></p><p>我们发现 Unicode 编码对应的是 <code>raw</code>，而 <code>rawValue</code> 和 <code>value</code> 都是正常的，所以我们可以将 <code>raw</code> 替换成 <code>rawValue</code> 或 <code>value</code> 即可，需要注意的是引号的问题，本来是 <code>console[&quot;log&quot;]</code>，你还原后变成了 <code>console[log]</code>，自然会报错的，除了替换值以外，这里直接删除 extra 节点，或者删除 raw 值也是可以的，所以以下几种写法都可以还原代码：</p><pre><code class="javascript">const parser = require(&quot;@babel/parser&quot;);const generate = require(&quot;@babel/generator&quot;).defaultconst traverse = require(&quot;@babel/traverse&quot;).defaultconst code = `console[&#39;\u006c\u006f\u0067&#39;](&#39;\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u006f\u0072\u006c\u0064\u0021&#39;)`const ast = parser.parse(code)const visitor = &#123;    StringLiteral(path) &#123;        // 以下方法均可        // path.node.extra.raw = path.node.rawValue        // path.node.extra.raw = &#39;&quot;&#39; + path.node.value + &#39;&quot;&#39;        // delete path.node.extra        delete path.node.extra.raw    &#125;&#125;traverse(ast, visitor)const result = generate(ast)console.log(result.code)</code></pre><p>还原结果：</p><pre><code class="javascript">console[&quot;log&quot;](&quot;Hello world!&quot;);</code></pre><h3 id="表达式还原"><a href="#表达式还原" class="headerlink" title="表达式还原"></a>表达式还原</h3><p>之前写过 <a href="https://itrhx.blog.csdn.net/article/details/122057377">JSFuck 混淆的还原</a>，其中有介绍 <code>![]</code> 可表示 false，<code>!![]</code> 或者 <code>!+[]</code> 可表示 true，在一些混淆代码中，经常有这些操作，把简单的表达式复杂化，往往需要执行一下语句，才能得到真正的结果，示例代码如下：</p><pre><code class="javascript">const a = !![]+!![]+!![];const b = Math.floor(12.34 * 2.12)const c = 10 &gt;&gt; 3 &lt;&lt; 1const d = String(21.3 + 14 * 1.32)const e = parseInt(&quot;1.893&quot; + &quot;45.9088&quot;)const f = parseFloat(&quot;23.2334&quot; + &quot;21.89112&quot;)const g = 20 &lt; 18 ? &#39;未成年&#39; : &#39;成年&#39;</code></pre><p>想要执行语句，我们需要了解 <code>path.evaluate()</code> 方法，该方法会对 path 对象进行执行操作，自动计算出结果，返回一个对象，其中的 <code>confident</code> 属性表示置信度，<code>value</code> 表示计算结果，使用 <code>types.valueToNode()</code> 方法创建节点，使用 <code>path.replaceInline()</code> 方法将节点替换成计算结果生成的新节点，替换方法有一下几种：</p><ul><li><code>replaceWith</code>：用一个节点替换另一个节点；</li><li><code>replaceWithMultiple</code>：用多个节点替换另一个节点；</li><li><code>replaceWithSourceString</code>：将传入的源码字符串解析成对应 Node 后再替换，性能较差，不建议使用；</li><li><code>replaceInline</code>：用一个或多个节点替换另一个节点，相当于同时有了前两个函数的功能。</li></ul><p>对应的 AST 处理代码如下：</p><pre><code class="javascript">const parser = require(&quot;@babel/parser&quot;);const generate = require(&quot;@babel/generator&quot;).defaultconst traverse = require(&quot;@babel/traverse&quot;).defaultconst types = require(&quot;@babel/types&quot;)const code = `const a = !![]+!![]+!![];const b = Math.floor(12.34 * 2.12)const c = 10 &gt;&gt; 3 &lt;&lt; 1const d = String(21.3 + 14 * 1.32)const e = parseInt(&quot;1.893&quot; + &quot;45.9088&quot;)const f = parseFloat(&quot;23.2334&quot; + &quot;21.89112&quot;)const g = 20 &lt; 18 ? &#39;未成年&#39; : &#39;成年&#39;`const ast = parser.parse(code)const visitor = &#123;    &quot;BinaryExpression|CallExpression|ConditionalExpression&quot;(path) &#123;        const &#123;confident, value&#125; = path.evaluate()        if (confident)&#123;            path.replaceInline(types.valueToNode(value))        &#125;    &#125;&#125;traverse(ast, visitor)const result = generate(ast)console.log(result.code)</code></pre><p>最终结果：</p><pre><code class="javascript">const a = 3;const b = 26;const c = 2;const d = &quot;39.78&quot;;const e = parseInt(&quot;1.89345.9088&quot;);const f = parseFloat(&quot;23.233421.89112&quot;);const g = &quot;\u6210\u5E74&quot;;</code></pre><h3 id="删除未使用变量"><a href="#删除未使用变量" class="headerlink" title="删除未使用变量"></a>删除未使用变量</h3><p>有时候代码里会有一些并没有使用到的多余变量，删除这些多余变量有助于更加高效的分析代码，示例代码如下：</p><pre><code class="javascript">const a = 1;const b = a * 2;const c = 2;const d = b + 1;const e = 3;console.log(d)</code></pre><p>删除多余变量，首先要了解 <code>NodePath</code> 中的 <code>scope</code>，<code>scope</code> 的作用主要是查找标识符的作用域、获取并修改标识符的所有引用等，删除未使用变量主要用到了 <code>scope.getBinding()</code> 方法，传入的值是当前节点能够引用到的标识符名称，返回的关键属性有以下几个：</p><ul><li><code>identifier</code>：标识符的 Node 对象；</li><li><code>path</code>：标识符的 NodePath 对象；</li><li><code>constant</code>：标识符是否为常量；</li><li><code>referenced</code>：标识符是否被引用；</li><li><code> references</code>：标识符被引用的次数；</li><li><code>constantViolations</code>：如果标识符被修改，则会存放所有修改该标识符节点的 Path 对象；</li><li><code>referencePaths</code>：如果标识符被引用，则会存放所有引用该标识符节点的 Path 对象。</li></ul><p>所以我们可以通过 <code>constantViolations</code>、<code>referenced</code>、<code>references</code>、<code>referencePaths</code> 多个参数来判断变量是否可以被删除，AST 处理代码如下：</p><pre><code class="javascript">const parser = require(&quot;@babel/parser&quot;);const generate = require(&quot;@babel/generator&quot;).defaultconst traverse = require(&quot;@babel/traverse&quot;).defaultconst code = `const a = 1;const b = a * 2;const c = 2;const d = b + 1;const e = 3;console.log(d)`const ast = parser.parse(code)const visitor = &#123;    VariableDeclarator(path)&#123;        const binding = path.scope.getBinding(path.node.id.name);        // 如标识符被修改过，则不能进行删除动作。        if (!binding || binding.constantViolations.length &gt; 0) &#123;            return;        &#125;        // 未被引用        if (!binding.referenced) &#123;            path.remove();        &#125;        // 被引用次数为0        // if (binding.references === 0) &#123;        //     path.remove();        // &#125;        // 长度为0，变量没有被引用过        // if (binding.referencePaths.length === 0) &#123;        //     path.remove();        // &#125;    &#125;&#125;traverse(ast, visitor)const result = generate(ast)console.log(result.code)</code></pre><p>处理后的代码（未使用的 b、c、e 变量已被删除）：</p><pre><code class="javascript">const a = 1;const b = a * 2;const d = b + 1;console.log(d);</code></pre><h3 id="删除冗余逻辑代码"><a href="#删除冗余逻辑代码" class="headerlink" title="删除冗余逻辑代码"></a>删除冗余逻辑代码</h3><p>有时候为了增加逆向难度，会有很多嵌套的 if-else 语句，大量判断为假的冗余逻辑代码，同样可以利用 AST 将其删除掉，只留下判断为真的，示例代码如下：</p><pre><code class="javascript">const example = function () &#123;    let a;    if (false) &#123;        a = 1;    &#125; else &#123;        if (1) &#123;            a = 2;        &#125;        else &#123;            a = 3;        &#125;    &#125;    return a;&#125;;</code></pre><p>观察 AST，判断条件对应的是 <code>test</code> 节点，if 对应的是 <code>consequent</code> 节点，else 对应的是 <code>alternate</code> 节点，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/11bee2b313c5327859074428625a9348.png" alt="16"></p><p>AST 处理思路以及代码：</p><ol><li>筛选出 <code>BooleanLiteral</code> 和 <code>NumericLiteral</code> 节点，取其对应的值，即 <code>path.node.test.value</code>；</li><li>判断 <code>value</code> 值为真，则将节点替换成 <code>consequent</code> 节点下的内容，即 <code>path.node.consequent.body</code>；</li><li>判断 <code>value</code> 值为假，则替换成 <code>alternate</code> 节点下的内容，即 <code>path.node.alternate.body</code>；</li><li>有的 if 语句可能没有写 else，也就没有 <code>alternate</code>，所以这种情况下判断 <code>value</code> 值为假，则直接移除该节点，即 <code>path.remove()</code></li></ol><pre><code class="javascript">const parser = require(&quot;@babel/parser&quot;);const generate = require(&quot;@babel/generator&quot;).defaultconst traverse = require(&quot;@babel/traverse&quot;).defaultconst types = require(&#39;@babel/types&#39;);const code = `const example = function () &#123;    let a;    if (false) &#123;        a = 1;    &#125; else &#123;        if (1) &#123;            a = 2;        &#125;        else &#123;            a = 3;        &#125;    &#125;    return a;&#125;;`const ast = parser.parse(code)const visitor = &#123;    enter(path) &#123;        if (types.isBooleanLiteral(path.node.test) || types.isNumericLiteral(path.node.test)) &#123;            if (path.node.test.value) &#123;                path.replaceInline(path.node.consequent.body);            &#125; else &#123;                if (path.node.alternate) &#123;                    path.replaceInline(path.node.alternate.body);                &#125; else &#123;                    path.remove()                &#125;            &#125;        &#125;    &#125;&#125;traverse(ast, visitor)const result = generate(ast)console.log(result.code)</code></pre><p>处理结果：</p><pre><code class="javascript">const example = function () &#123;  let a;  a = 2;  return a;&#125;;</code></pre><h3 id="switch-case-反控制流平坦化"><a href="#switch-case-反控制流平坦化" class="headerlink" title="switch-case 反控制流平坦化"></a>switch-case 反控制流平坦化</h3><p>控制流平坦化是混淆当中最常见的，通过 <code>if-else</code> 或者 <code>while-switch-case</code> 语句分解步骤，示例代码：</p><pre><code class="javascript">const _0x34e16a = &#39;3,4,0,5,1,2&#39;[&#39;split&#39;](&#39;,&#39;);let _0x2eff02 = 0x0;while (!![]) &#123;    switch (_0x34e16a[_0x2eff02++]) &#123;        case&#39;0&#39;:            let _0x38cb15 = _0x4588f1 + _0x470e97;            continue;        case&#39;1&#39;:            let _0x1e0e5e = _0x37b9f3[_0x50cee0(0x2e0, 0x2e8, 0x2e1, 0x2e4)];            continue;        case&#39;2&#39;:            let _0x35d732 = [_0x388d4b(-0x134, -0x134, -0x139, -0x138)](_0x38cb15 &gt;&gt; _0x4588f1);            continue;        case&#39;3&#39;:            let _0x4588f1 = 0x1;            continue;        case&#39;4&#39;:            let _0x470e97 = 0x2;            continue;        case&#39;5&#39;:            let _0x37b9f3 = 0x5 || _0x38cb15;            continue;    &#125;    break;&#125;</code></pre><p>AST 还原思路：</p><ol><li>获取控制流原始数组，将 <code>&#39;3,4,0,5,1,2&#39;[&#39;split&#39;](&#39;,&#39;)</code> 之类的语句转化成 <code>[&#39;3&#39;,&#39;4&#39;,&#39;0&#39;,&#39;5&#39;,&#39;1&#39;,&#39;2&#39;]</code> 之类的数组，得到该数组之后，也可以选择把 split 语句对应的节点删除掉，因为最终代码里这条语句就没用了；</li><li>遍历第一步得到的控制流数组，依次取出每个值所对应的 case 节点；</li><li>定义一个数组，储存每个 case 节点 <code>consequent</code> 数组里面的内容，并删除 <code>continue</code> 语句对应的节点；</li><li>遍历完成后，将第三步的数组替换掉整个 while 节点，也就是 <code>WhileStatement</code>。</li></ol><p>不同思路，写法多样，对于如何获取控制流数组，可以有以下思路：</p><ol><li>获取到 <code>While</code> 语句节点，然后使用 <code>path.getAllPrevSiblings()</code> 方法获取其前面的所有兄弟节点，遍历每个兄弟节点，找到与 <code>switch()</code> 里面数组的变量名相同的节点，然后再取节点的值进行后续处理；</li><li>直接取 <code>switch()</code> 里面数组的变量名，然后使用 <code>scope.getBinding()</code> 方法获取到它绑定的节点，然后再取这个节点的值进行后续处理。</li></ol><p>所以 AST 处理代码就有两种写法，方法一：（code.js 即为前面的示例代码，为了方便操作，这里使用 fs 从文件中读取代码）</p><pre><code class="javascript">const parser = require(&quot;@babel/parser&quot;);const generate = require(&quot;@babel/generator&quot;).defaultconst traverse = require(&quot;@babel/traverse&quot;).defaultconst types = require(&quot;@babel/types&quot;)const fs = require(&quot;fs&quot;);const code = fs.readFileSync(&quot;code.js&quot;, &#123;encoding: &quot;utf-8&quot;&#125;);const ast = parser.parse(code)const visitor = &#123;    WhileStatement(path) &#123;        // switch 节点        let switchNode = path.node.body.body[0];        // switch 语句内的控制流数组名，本例中是 _0x34e16a        let arrayName = switchNode.discriminant.object.name;        // 获得所有 while 前面的兄弟节点，本例中获取到的是声明两个变量的节点，即 const _0x34e16a 和 let _0x2eff02        let prevSiblings = path.getAllPrevSiblings();        // 定义缓存控制流数组        let array = []        // forEach 方法遍历所有节点        prevSiblings.forEach(pervNode =&gt; &#123;            let &#123;id, init&#125; = pervNode.node.declarations[0];            // 如果节点 id.name 与 switch 语句内的控制流数组名相同            if (arrayName === id.name) &#123;                // 获取节点整个表达式的参数、分割方法、分隔符                let object = init.callee.object.value;                let property = init.callee.property.value;                let argument = init.arguments[0].value;                // 模拟执行 &#39;3,4,0,5,1,2&#39;[&#39;split&#39;](&#39;,&#39;) 语句                array = object[property](argument)                // 也可以直接取参数进行分割，方法不通用，比如分隔符换成 | 就不行了                // array = init.callee.object.value.split(&#39;,&#39;);            &#125;            // 前面的兄弟节点就可以删除了            pervNode.remove();        &#125;);        // 储存正确顺序的控制流语句        let replace = [];        // 遍历控制流数组，按正确顺序取 case 内容        array.forEach(index =&gt; &#123;                let consequent = switchNode.cases[index].consequent;                // 如果最后一个节点是 continue 语句，则删除 ContinueStatement 节点                if (types.isContinueStatement(consequent[consequent.length - 1])) &#123;                    consequent.pop();                &#125;                // concat 方法拼接多个数组，即正确顺序的 case 内容                replace = replace.concat(consequent);            &#125;        );        // 替换整个 while 节点，两种方法都可以        path.replaceWithMultiple(replace);        // path.replaceInline(replace);    &#125;&#125;traverse(ast, visitor)const result = generate(ast)console.log(result.code)</code></pre><p>方法二：</p><pre><code class="javascript">const parser = require(&quot;@babel/parser&quot;);const generate = require(&quot;@babel/generator&quot;).defaultconst traverse = require(&quot;@babel/traverse&quot;).defaultconst types = require(&quot;@babel/types&quot;)const fs = require(&quot;fs&quot;);const code = fs.readFileSync(&quot;code.js&quot;, &#123;encoding: &quot;utf-8&quot;&#125;);const ast = parser.parse(code)const visitor = &#123;    WhileStatement(path) &#123;        // switch 节点        let switchNode = path.node.body.body[0];        // switch 语句内的控制流数组名，本例中是 _0x34e16a        let arrayName = switchNode.discriminant.object.name;        // 获取控制流数组绑定的节点        let bindingArray = path.scope.getBinding(arrayName);        // 获取节点整个表达式的参数、分割方法、分隔符        let init = bindingArray.path.node.init;        let object = init.callee.object.value;        let property = init.callee.property.value;        let argument = init.arguments[0].value;        // 模拟执行 &#39;3,4,0,5,1,2&#39;[&#39;split&#39;](&#39;,&#39;) 语句        let array = object[property](argument)        // 也可以直接取参数进行分割，方法不通用，比如分隔符换成 | 就不行了        // let array = init.callee.object.value.split(&#39;,&#39;);        // switch 语句内的控制流自增变量名，本例中是 _0x2eff02        let autoIncrementName = switchNode.discriminant.property.argument.name;        // 获取控制流自增变量名绑定的节点        let bindingAutoIncrement = path.scope.getBinding(autoIncrementName);        // 可选择的操作：删除控制流数组绑定的节点、自增变量名绑定的节点        bindingArray.path.remove();        bindingAutoIncrement.path.remove();        // 储存正确顺序的控制流语句        let replace = [];        // 遍历控制流数组，按正确顺序取 case 内容        array.forEach(index =&gt; &#123;                let consequent = switchNode.cases[index].consequent;                // 如果最后一个节点是 continue 语句，则删除 ContinueStatement 节点                if (types.isContinueStatement(consequent[consequent.length - 1])) &#123;                    consequent.pop();                &#125;                // concat 方法拼接多个数组，即正确顺序的 case 内容                replace = replace.concat(consequent);            &#125;        );        // 替换整个 while 节点，两种方法都可以        path.replaceWithMultiple(replace);        // path.replaceInline(replace);    &#125;&#125;traverse(ast, visitor)const result = generate(ast)console.log(result.code)</code></pre><p>以上代码运行后，原来的 <code>switch-case</code> 控制流就被还原了，变成了按顺序一行一行的代码，更加简洁明了：</p><pre><code class="javascript">let _0x4588f1 = 0x1;let _0x470e97 = 0x2;let _0x38cb15 = _0x4588f1 + _0x470e97;let _0x37b9f3 = 0x5 || _0x38cb15;let _0x1e0e5e = _0x37b9f3[_0x50cee0(0x2e0, 0x2e8, 0x2e1, 0x2e4)];let _0x35d732 = [_0x388d4b(-0x134, -0x134, -0x139, -0x138)](_0x38cb15 &gt;&gt; _0x4588f1);</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>本文有参考以下资料，也是比较推荐的在线学习资料：</p><ul><li>Youtube 视频，Babel 入门：<a href="https://www.youtube.com/watch?v=UeVq_U5obnE">https://www.youtube.com/watch?v=UeVq_U5obnE</a></li><li>官方手册 Babel Handbook：<a href="https://github.com/jamiebuilds/babel-handbook">https://github.com/jamiebuilds/babel-handbook</a></li><li>非官方 Babel API 中文文档：<a href="https://evilrecluse.top/Babel-traverse-api-doc/">https://evilrecluse.top/Babel-traverse-api-doc/</a></li></ul><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>Babel 编译器国内的资料其实不是很多，多看源码、同时在线对照可视化的 AST 语法树，耐心一点儿一层一层分析即可，本文中的案例也只是最基本操作，实际遇到一些混淆还得视情况进行修改，比如需要加一些类型判断来限制等，后续会用实战来带领大家进一步熟悉解混淆当中的其他操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是-AST&quot;&gt;&lt;a href=&quot;#什么是-AST&quot; class=&quot;headerlink&quot; title=&quot;什么是 AST&quot;&gt;&lt;/a&gt;什么是 AST&lt;/h2&gt;&lt;p&gt;AST（Abstract Syntax Tree），中文抽象语法树，简称语法树（Syntax Tre</summary>
      
    
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91/"/>
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>【JS 逆向】网洛者反爬练习平台第七题：JSVMPZL 初体验</title>
    <link href="https://www.itbob.cn/article/050/"/>
    <id>https://www.itbob.cn/article/050/</id>
    <published>2022-04-06T05:39:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><strong>本文章中所有内容仅供学习交流，抓包内容、敏感网址、数据接口均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关，若有侵权，请在公众号联系我立即删除！</strong></p><h2 id="逆向目标"><a href="#逆向目标" class="headerlink" title="逆向目标"></a>逆向目标</h2><ul><li>目标：网洛者反反爬虫练习平台第七题：JSVMPZL 初体验</li><li>链接：<a href="http://spider.wangluozhe.com/challenge/7">http://spider.wangluozhe.com/challenge/7</a></li><li>简介：平台注册需要邀请码，站长在群里，可后台回复交流群加群获取，或者直接加网站底部站长QQ获取。要求采集100页的全部数字，并计算所有数据加和。主要难点在于 vvv 大佬开发的 JS 混淆框架：jsvmpzl</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/adc6eb6d3f2480b306a9e27b85cea3b5.png" alt="01"></p><h2 id="逆向过程"><a href="#逆向过程" class="headerlink" title="逆向过程"></a>逆向过程</h2><p>直接搜索，或者跟栈，可以轻松找到加密入口，打开 F12 有两个反调试，一是无限 debugger，右键 Never pause here 即可，二是定时器，控制台输入 <code>for (let i = 1; i &lt; 99999; i++) window.clearInterval(i);</code> 过掉即可。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5b01302e20f7265f8732b19b0150df6f.png" alt="02"></p><p>跟进 <code>y__()</code>，就可以看到 jsvmpzl 混淆的代码了，如果有做过猿人学平台的题，会发现此混淆和猿人学第 18 题（ <a href="https://match.yuanrenxue.com/match/18">https://match.yuanrenxue.com/match/18</a> ）是一样的，在 <code>y__()</code> 第一行下个断点，观察 <code>__v_()</code> 第一个参数 <code>_</code>，<code>_[2][0]</code> 你会发现有关 MD5 算法的一些特征，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3780acd49c90e60e4877f0b2a688e365.png" alt="03"></p><p>那么我们直接大胆猜测一下，是不是就是某个数据经过 MD5 之后就是 <code>_signature</code> 了呢？再继续调试一下，注意 <code>arguments</code> 的变化：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3a613678a973b5d3f77ab95395a75c02.png" alt="04"></p><p>很明显这个 <code>window.byted_acrawler(window.sign())</code> 应该就是生成 <code>_signature</code> 的语句，这个方法和某字节系的 <code>_signature</code> 生成的方法名称是一样的，直接在控制台输出一下可以拿到值，其中 <code>window.sign()</code> 是取的时间戳：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a1f83868ca67a77c46fe6e1eb9acb290.png" alt="05"></p><p>我们前面猜测是 MD5，直接验证一下，发现并不是的，即便是同一个时间戳，经过 <code>window.byted_acrawler()</code> 后得到的值每次也都不一样：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7c30a65c29a26d5357c6fe6ccbb9fd0d.png" alt="06"></p><h3 id="Hook-关键方法"><a href="#Hook-关键方法" class="headerlink" title="Hook 关键方法"></a>Hook 关键方法</h3><p>经过前面的分析，既然标准的 MD5 不行，那有没有可能是魔改的 MD5 呢？首先找个 JavaScript 标准的 MD5 代码看一下，比如：<a href="http://pajhome.org.uk/crypt/md5/md5.html">http://pajhome.org.uk/crypt/md5/md5.html</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/d7aca0b28d6131db38bdf6e1d9e46441.png" alt="07"></p><p>可以注意到，源码里面有很多 <code>md5_ff</code>、<code>md5_gg</code>、<code>md5_hh</code>、<code>md5_ii</code> 的方法，最后一个值都是固定的，那么有没有可能此题就是在标准 MD5 的基础上修改了一些默认值呢？所以我们可以直接 Hook 这些关键方法，在控制台输出传入的值，来一一对比一下，看看默认值是否是一样的，为了方便观察，我们还可以为输出语句加上颜色，Hook 代码如下：</p><pre><code class="javascript">let oldFF = _[2][0][&#39;md5_ff&#39;];let oldGG = _[2][0][&#39;md5_gg&#39;];let oldHH = _[2][0][&#39;md5_hh&#39;];let oldII = _[2][0][&#39;md5_ii&#39;];let color_white_red = &quot;color: white; background: red;&quot;let color_white_grey = &quot;color: white; background: grey;&quot;let color_white_darkcyan = &quot;color: white; background: darkcyan;&quot;let color_white_green = &quot;color: white; background: green;&quot;let color_white_orange = &quot;color: white; background: orange;&quot;_[2][0][&#39;md5_ff&#39;] = function (a, b, c, d, e, f, g) &#123;    debugger;    let result = oldFF(a, b, c, d, e, f, g);    console.log(&quot;%c Function: %c md5_ff %c Result: %c %s %c Params: %c %s, %s, %s, %s, %s, %s, %s &quot;, color_white_red, color_white_grey, color_white_red, color_white_grey, result, color_white_red, color_white_grey, a, b, c, d, e, f, g)    return result;&#125;;_[2][0][&#39;md5_gg&#39;] = function (a, b, c, d, e, f, g) &#123;    debugger;    let result = oldGG(a, b, c, d, e, f, g);    console.log(&quot;%c Function: %c md5_gg %c Result: %c %s %c Params: %c %s, %s, %s, %s, %s, %s, %s &quot;, color_white_red, color_white_darkcyan, color_white_red, color_white_darkcyan, result, color_white_red, color_white_darkcyan, a, b, c, d, e, f, g)    return result;&#125;;_[2][0][&#39;md5_hh&#39;] = function (a, b, c, d, e, f, g) &#123;    debugger;    let result = oldHH(a, b, c, d, e, f, g);    console.log(&quot;%c Function: %c md5_hh %c Result: %c %s %c Params: %c %s, %s, %s, %s, %s, %s, %s &quot;, color_white_red, color_white_green, color_white_red, color_white_green, result, color_white_red, color_white_green, a, b, c, d, e, f, g)    return result;&#125;;_[2][0][&#39;md5_ii&#39;] = function (a, b, c, d, e, f, g) &#123;    debugger;    let result = oldII(a, b, c, d, e, f, g);    console.log(&quot;%c Function: %c md5_ii %c Result: %c %s %c Params: %c %s, %s, %s, %s, %s, %s, %s &quot;, color_white_red, color_white_orange, color_white_red, color_white_orange, result, color_white_red, color_white_orange, a, b, c, d, e, f, g)    return result;&#125;;</code></pre><p>Hook 代码写得比较死板，熟悉 JS 的大佬可自己优化一下，注意注入代码的时机，清除定时器后，断点运行到 <code>y__()</code> 方法后再注入，然后取消断点，一直下一步，就可以在控制台看到输出的参数了，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/dc4426ed825d5f3fe1516910035de8ce.png" alt="08"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/f73a668ccd538dedf6759c122269c9da.png" alt="09"></p><p>与默认参数进行对比，可以发现 <code>md5_hh()</code> 里有两个默认参数被修改了：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e1b033d6086f175337c36b7c1d04e208.png" alt="10"></p><p>默认的 <code>-722521979</code> 改成了 <code>-722521939</code>、<code>76029189</code> 改成了 <code>76029185</code>，本地代码修改一下即可：</p><pre><code class="javascript">/* ==================================# @Time    : 2021-12-23# @Author  : ITBOB# @FileName: challenge_7.js# @Software: PyCharm# ================================== *//* * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message * Digest Algorithm, as defined in RFC 1321. * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet * Distributed under the BSD License * See http://pajhome.org.uk/crypt/md5 for more info. *//* * Configurable variables. You may need to tweak these to be compatible with * the server-side, but the defaults work in most cases. */var hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */var b64pad  = &quot;&quot;;  /* base-64 pad character. &quot;=&quot; for strict RFC compliance   *//* * These are the functions you&#39;ll usually want to call * They take string arguments and return either hex or base-64 encoded strings */function hex_md5(s)    &#123; return rstr2hex(rstr_md5(str2rstr_utf8(s))); &#125;function b64_md5(s)    &#123; return rstr2b64(rstr_md5(str2rstr_utf8(s))); &#125;function any_md5(s, e) &#123; return rstr2any(rstr_md5(str2rstr_utf8(s)), e); &#125;function hex_hmac_md5(k, d)  &#123; return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); &#125;function b64_hmac_md5(k, d)  &#123; return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); &#125;function any_hmac_md5(k, d, e)  &#123; return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); &#125;/* * Perform a simple self-test to see if the VM is working */function md5_vm_test()&#123;  return hex_md5(&quot;abc&quot;).toLowerCase() == &quot;900150983cd24fb0d6963f7d28e17f72&quot;;&#125;/* * Calculate the MD5 of a raw string */function rstr_md5(s)&#123;  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));&#125;/* * Calculate the HMAC-MD5, of a key and some data (raw strings) */function rstr_hmac_md5(key, data)&#123;  var bkey = rstr2binl(key);  if(bkey.length &gt; 16) bkey = binl_md5(bkey, key.length * 8);  var ipad = Array(16), opad = Array(16);  for(var i = 0; i &lt; 16; i++)  &#123;    ipad[i] = bkey[i] ^ 0x36363636;    opad[i] = bkey[i] ^ 0x5C5C5C5C;  &#125;  var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);  return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));&#125;/* * Convert a raw string to a hex string */function rstr2hex(input)&#123;  try &#123; hexcase &#125; catch(e) &#123; hexcase=0; &#125;  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;  var output = &quot;&quot;;  var x;  for(var i = 0; i &lt; input.length; i++)  &#123;    x = input.charCodeAt(i);    output += hex_tab.charAt((x &gt;&gt;&gt; 4) &amp; 0x0F)           +  hex_tab.charAt( x        &amp; 0x0F);  &#125;  return output;&#125;/* * Convert a raw string to a base-64 string */function rstr2b64(input)&#123;  try &#123; b64pad &#125; catch(e) &#123; b64pad=&#39;&#39;; &#125;  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;  var output = &quot;&quot;;  var len = input.length;  for(var i = 0; i &lt; len; i += 3)  &#123;    var triplet = (input.charCodeAt(i) &lt;&lt; 16)                | (i + 1 &lt; len ? input.charCodeAt(i+1) &lt;&lt; 8 : 0)                | (i + 2 &lt; len ? input.charCodeAt(i+2)      : 0);    for(var j = 0; j &lt; 4; j++)    &#123;      if(i * 8 + j * 6 &gt; input.length * 8) output += b64pad;      else output += tab.charAt((triplet &gt;&gt;&gt; 6*(3-j)) &amp; 0x3F);    &#125;  &#125;  return output;&#125;/* * Convert a raw string to an arbitrary string encoding */function rstr2any(input, encoding)&#123;  var divisor = encoding.length;  var i, j, q, x, quotient;  /* Convert to an array of 16-bit big-endian values, forming the dividend */  var dividend = Array(Math.ceil(input.length / 2));  for(i = 0; i &lt; dividend.length; i++)  &#123;    dividend[i] = (input.charCodeAt(i * 2) &lt;&lt; 8) | input.charCodeAt(i * 2 + 1);  &#125;  /*   * Repeatedly perform a long division. The binary array forms the dividend,   * the length of the encoding is the divisor. Once computed, the quotient   * forms the dividend for the next step. All remainders are stored for later   * use.   */  var full_length = Math.ceil(input.length * 8 /                                    (Math.log(encoding.length) / Math.log(2)));  var remainders = Array(full_length);  for(j = 0; j &lt; full_length; j++)  &#123;    quotient = Array();    x = 0;    for(i = 0; i &lt; dividend.length; i++)    &#123;      x = (x &lt;&lt; 16) + dividend[i];      q = Math.floor(x / divisor);      x -= q * divisor;      if(quotient.length &gt; 0 || q &gt; 0)        quotient[quotient.length] = q;    &#125;    remainders[j] = x;    dividend = quotient;  &#125;  /* Convert the remainders to the output string */  var output = &quot;&quot;;  for(i = remainders.length - 1; i &gt;= 0; i--)    output += encoding.charAt(remainders[i]);  return output;&#125;/* * Encode a string as utf-8. * For efficiency, this assumes the input is valid utf-16. */function str2rstr_utf8(input)&#123;  var output = &quot;&quot;;  var i = -1;  var x, y;  while(++i &lt; input.length)  &#123;    /* Decode utf-16 surrogate pairs */    x = input.charCodeAt(i);    y = i + 1 &lt; input.length ? input.charCodeAt(i + 1) : 0;    if(0xD800 &lt;= x &amp;&amp; x &lt;= 0xDBFF &amp;&amp; 0xDC00 &lt;= y &amp;&amp; y &lt;= 0xDFFF)    &#123;      x = 0x10000 + ((x &amp; 0x03FF) &lt;&lt; 10) + (y &amp; 0x03FF);      i++;    &#125;    /* Encode output as utf-8 */    if(x &lt;= 0x7F)      output += String.fromCharCode(x);    else if(x &lt;= 0x7FF)      output += String.fromCharCode(0xC0 | ((x &gt;&gt;&gt; 6 ) &amp; 0x1F),                                    0x80 | ( x         &amp; 0x3F));    else if(x &lt;= 0xFFFF)      output += String.fromCharCode(0xE0 | ((x &gt;&gt;&gt; 12) &amp; 0x0F),                                    0x80 | ((x &gt;&gt;&gt; 6 ) &amp; 0x3F),                                    0x80 | ( x         &amp; 0x3F));    else if(x &lt;= 0x1FFFFF)      output += String.fromCharCode(0xF0 | ((x &gt;&gt;&gt; 18) &amp; 0x07),                                    0x80 | ((x &gt;&gt;&gt; 12) &amp; 0x3F),                                    0x80 | ((x &gt;&gt;&gt; 6 ) &amp; 0x3F),                                    0x80 | ( x         &amp; 0x3F));  &#125;  return output;&#125;/* * Encode a string as utf-16 */function str2rstr_utf16le(input)&#123;  var output = &quot;&quot;;  for(var i = 0; i &lt; input.length; i++)    output += String.fromCharCode( input.charCodeAt(i)        &amp; 0xFF,                                  (input.charCodeAt(i) &gt;&gt;&gt; 8) &amp; 0xFF);  return output;&#125;function str2rstr_utf16be(input)&#123;  var output = &quot;&quot;;  for(var i = 0; i &lt; input.length; i++)    output += String.fromCharCode((input.charCodeAt(i) &gt;&gt;&gt; 8) &amp; 0xFF,                                   input.charCodeAt(i)        &amp; 0xFF);  return output;&#125;/* * Convert a raw string to an array of little-endian words * Characters &gt;255 have their high-byte silently ignored. */function rstr2binl(input)&#123;  var output = Array(input.length &gt;&gt; 2);  for(var i = 0; i &lt; output.length; i++)    output[i] = 0;  for(var i = 0; i &lt; input.length * 8; i += 8)    output[i&gt;&gt;5] |= (input.charCodeAt(i / 8) &amp; 0xFF) &lt;&lt; (i%32);  return output;&#125;/* * Convert an array of little-endian words to a string */function binl2rstr(input)&#123;  var output = &quot;&quot;;  for(var i = 0; i &lt; input.length * 32; i += 8)    output += String.fromCharCode((input[i&gt;&gt;5] &gt;&gt;&gt; (i % 32)) &amp; 0xFF);  return output;&#125;/* * Calculate the MD5 of an array of little-endian words, and a bit length. */function binl_md5(x, len)&#123;  /* append padding */  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; ((len) % 32);  x[(((len + 64) &gt;&gt;&gt; 9) &lt;&lt; 4) + 14] = len;  var a =  1732584193;  var b = -271733879;  var c = -1732584194;  var d =  271733878;  for(var i = 0; i &lt; x.length; i += 16)  &#123;    var olda = a;    var oldb = b;    var oldc = c;    var oldd = d;    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);    // 注释掉的是默认值    // c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521939);    // b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029185);    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);    a = safe_add(a, olda);    b = safe_add(b, oldb);    c = safe_add(c, oldc);    d = safe_add(d, oldd);  &#125;  return Array(a, b, c, d);&#125;/* * These functions implement the four basic operations the algorithm uses. */function md5_cmn(q, a, b, x, s, t)&#123;  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);&#125;function md5_ff(a, b, c, d, x, s, t)&#123;  return md5_cmn((b &amp; c) | ((~b) &amp; d), a, b, x, s, t);&#125;function md5_gg(a, b, c, d, x, s, t)&#123;  return md5_cmn((b &amp; d) | (c &amp; (~d)), a, b, x, s, t);&#125;function md5_hh(a, b, c, d, x, s, t)&#123;  return md5_cmn(b ^ c ^ d, a, b, x, s, t);&#125;function md5_ii(a, b, c, d, x, s, t)&#123;  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);&#125;/* * Add integers, wrapping at 2^32. This uses 16-bit operations internally * to work around bugs in some JS interpreters. */function safe_add(x, y)&#123;  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);&#125;/* * Bitwise rotate a 32-bit number to the left. */function bit_rol(num, cnt)&#123;  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));&#125;function getSignature() &#123;    return hex_md5(Date.parse(Date()).toString())&#125;console.log(getSignature())</code></pre><p>Python 调用代码：</p><pre><code class="python"># ==================================# --*-- coding: utf-8 --*--# @Time    : 2021-12-23# @Author  : ITBOB# @FileName: challenge_7.py# @Software: PyCharm# ==================================import timeimport execjsimport requestschallenge_api = &quot;http://spider.wangluozhe.com/challenge/api/7&quot;headers = &#123;    &quot;Cookie&quot;: &quot;Cookie 替换成你的&quot;,    &quot;Host&quot;: &quot;spider.wangluozhe.com&quot;,    &quot;Origin&quot;: &quot;http://spider.wangluozhe.com&quot;,    &quot;Referer&quot;: &quot;http://spider.wangluozhe.com/challenge/7&quot;,    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&quot;,    &quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;&#125;def get_signature():    now = str(int(time.time())) + &quot;000&quot;    with open(&#39;challenge_7.js&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:        wlz_js = execjs.compile(f.read())    # signature = wlz_js.call(&quot;getSignature&quot;)    signature = wlz_js.call(&quot;hex_md5&quot;, now)    print(&quot;signature: &quot;, signature)    return signaturedef main():    result = 0    for page in range(1, 101):        data = &#123;            &quot;page&quot;: page,            &quot;count&quot;: 10,            &quot;_signature&quot;: get_signature()        &#125;        response = requests.post(url=challenge_api, headers=headers, data=data).json()        print(response)        for d in response[&quot;data&quot;]:            result += d[&quot;value&quot;]    print(&quot;结果为: &quot;, result)if __name__ == &#39;__main__&#39;:    main()</code></pre><p>这里还有一点小细节，如果是 Python 生成时间戳传入 JS 的 <code>hex_md5</code> 方法的话，要保证时间戳的最后三位为0，不然校验通不过，通常的写法是 <code>str(int(time.time() * 1000))</code>，这里要改一下：<code>str(int(time.time())) + &quot;000&quot;</code>，不用 Python 的话，也可以在 JS 里写个方法直接返回 <code>hex_md5(Date.parse(Date()).toString())</code> 也行。</p><p><strong>还有一个问题就是如果你找的 MD5 代码不规范，准确来说是和题目使用的 MD5 代码不太一样的话，有可能本地要改的地方就不止这两处了，所以尽量找一个方法名都一样的JS，能省不少事儿。</strong></p><h3 id="日志断点-插桩调试"><a href="#日志断点-插桩调试" class="headerlink" title="日志断点 / 插桩调试"></a>日志断点 / 插桩调试</h3><p>除了 Hook 以外，我们还可以通过插桩调试的方式，将整个生成 <code>_signature</code> 的流程、涉及到的参数、生成的值，都通过日志的形式打印出来，逆向分析其逻辑。PS：插桩，即日志断点，鼠标右键选择 <code>Add logpoint</code> 即可添加一个日志断点，相当于 <code>console.log()</code>，此功能是 Chrome 73 版本新增的。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/809d43c9561951a392f9a395f2edb284.png" alt="11"></p><ul><li><strong>Add breakpoint</strong>：添加普通断点；</li><li><strong>Add conditional breakpoint</strong>：添加条件断点，满足条件才断下；</li><li><strong>Add logpoint</strong>：添加日志断点；</li><li><strong>Never pause here</strong>：永不在此处断下；</li><li><strong>Add script to ignore list</strong>：网站的部分 JS，比如 <code>jquery.min.js</code> 之类的库文件，我们单步调试的时候并不想进入到该文件中，那么可以将此类文件右键添加忽略掉。</li></ul><p>关键的日志断点有以下三处：</p><ul><li>第 605 行，<code>arguments</code> 为当前传入函数的参数值；</li><li>第 141 行，<code>___.join(vV_)</code> 为当前调用的方法名称，也会输出方法中的参数名称；</li><li>第 591 行，<code>__V(_, ___(u_), 0, 0, _U__).apply(void 0, y__(v___))</code> 为当前方法执行完毕的结果。</li></ul><p>肯定有人会疑惑，如何知道应该在这三个地方下日志断点呢？答案是只能自己单步、多步调试，找规律、仔细观察，就像交流群里的小小白大佬说的一样，屁股坐烂就行了。当然也不是只有这三个地方能输出对应的信息，有可能其他地方也可以，这就要看你自己调试了。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7824eb659f7e79005c7d06e0a4a8226c.png" alt="12"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/88f582a59787275088ccefd6d2b31040.png" alt="13"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/eacf5f0661f1f37a78b10d0077ceeb83.png" alt="14"></p><p>除了这三个地方的日志断点以外，建议还可以在第 606 行打个断点，这样每次执行一个方法就断下，本地就可以跟着同步调试，挨个对比传入的参数和得到的结果，不至于一下子输出的东西太多，不方便查找。</p><p>第一步，<code>gnature = window.byted_acrawler(window.sign())</code>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5b63ed75da5005cd2cfaf7751e2e21cb.png" alt="15"></p><p>下一步，sign 方法，取时间戳：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3a69124e145ec58b96f9d10b2bfc7116.png" alt="16"></p><p>下一步，调用 <code>hex_md5()</code> 方法：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e5c6bef0f6e7cebb0b63523977364143.png" alt="17"></p><p>从这里就可以开始本地同步调试了，本地 MD5 下断点调试，可以看到得到的值不一样：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/79cfa228e9d358ce3285c07b1e7015f7.png" alt="18"></p><p>下一步，调用 <code>str2binl()</code> 方法，和本地得到的值是一样的：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9100052468ccac22aa4a648964be5e9b.png" alt="19"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/ebf4964df2d57ffd62a499ed74d25ed2.png" alt="20"></p><p>下一步，调用 <code>core_md5()</code> 方法，得到的值和本地就不一样了，这里大致可以确定此方法内部与标准算法有差别了：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/907c0c4e27b8e67a6b1e9424ea48faa7.png" alt="21"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/77f401db641df96442715fc7292c3cd9.png" alt="22"></p><p>下一步，调用 <code>md5_ff()</code> 方法，得到的值是一样的：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/196f75611556bbdfcd3dd9abf0d06732.png" alt="23"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/d88f1342eb678ba930b9e70ab6f1d7ef.png" alt="24"></p><p>以此类推，最终会找到两个不一样的地方，即 <code>md5_hh()</code> 两个默认参数被修改了。</p><p><code>-722521979</code> 被改成了 <code>-722521939</code>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6d6b5d79d7028a73134562e50f537f00.png" alt="25"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c60c5a5e389cdcac6ed85fd19c4b0502.png" alt="26"></p><p><code>76029189</code> 被改成了 <code>76029185</code>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f22f81db4216a5dbe49fc821815b851a.png" alt="27"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/0e115ab6c1095593e66c5367390e1170.png" alt="28"></p><p>最终提交结果，验证成功：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/8806ce0bcee1aa373561097d24caa75f.png" alt="29"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文章中所有内容仅供学习交流，抓包内容、敏感网址、数据接口均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果</summary>
      
    
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91/"/>
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>【JS 逆向】拉勾网爬虫，traceparent、__lg_stoken__、X-S-HEADER 等参数分析</title>
    <link href="https://www.itbob.cn/article/049/"/>
    <id>https://www.itbob.cn/article/049/</id>
    <published>2022-03-16T04:18:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><strong>本文章中所有内容仅供学习交流，抓包内容、敏感网址、数据接口均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关，若有侵权，请在公众号联系我立即删除！</strong></p><h2 id="逆向目标"><a href="#逆向目标" class="headerlink" title="逆向目标"></a>逆向目标</h2><p>本次的目标是拉勾网职位的爬取，涉及到的一些关键参数如下：</p><ul><li>请求头参数：<code>traceparent</code>、<code>X-K-HEADER</code>、<code>X-S-HEADER</code>、<code>X-SS-REQ-HEADER</code>、<code>x-anit-forge-code</code>、<code>x-anit-forge-token</code></li><li>Cookie 值：<code>user_trace_token</code>、<code>X_HTTP_TOKEN</code>、<code>__lg_stoken__</code></li><li>POST 请求数据加密，返回的加密职位信息解密，AES 算法</li></ul><p>参数比较多，但事实上有些参数固定、或者直接不要，也是可以的，比如 Cookie 的三个值，请求头的 <code>X-K-HEADER</code>、<code>X-SS-REQ-HEADER</code> 等可以固定，<code>x-anit-forge-code</code> 和 <code>x-anit-forge-token</code> 可有可无。尽管如此，本文还是把每个参数的来源都分析了，可根据你实际情况灵活处理。</p><p>另外即便是把所有参数都补齐了，拉勾网对于单个 IP 还有频率限制，抓不了几次就要求登录，可自行搭配代理进行抓取，或者复制账号登录后的 cookies 到代码里，可以解除限制，如果是账号登录后访问，请求头多了两个参数，即 <code>x-anit-forge-code</code> 和 <code>x-anit-forge-token</code>，经过测试这两个参数其实不要也行。</p><h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p>搜索职位，点击翻页，就可以看到一条名为 positionAjax.json 的 Ajax 请求，不难判断这就是返回的职位信息。重点参数已在图中框出来了。</p><p>未登录，正常 IP，正常请求，Header 以及 Cookies：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/70cb2fa995ca86f03f2356999f2e76dc.png" alt="01"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/0072eeb2185eb259f92ba86ffaa87216.png" alt="02"></p><p>异常 IP，登录账号后再请求，Header 以及 Cookies：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/24936f2b0de3cfb9830fe000ce73f942.png" alt="03"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/1f7fadc2fceef7508ac9acf308965a69.png" alt="04"></p><p>请求数据和返回数据都经过了加密：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1253e653b4c3ef62aa5b0a6ea43cc60f.png" alt="05"></p><h2 id="Cookies-参数"><a href="#Cookies-参数" class="headerlink" title="Cookies 参数"></a>Cookies 参数</h2><p>先看 cookies 里的关键参数，主要是 <code>user_trace_token</code>、<code>X_HTTP_TOKEN</code> 和 <code>__lg_stoken__</code>。</p><h3 id="user-trace-token"><a href="#user-trace-token" class="headerlink" title="user_trace_token"></a>user_trace_token</h3><p>通过接口返回的，直接搜索就可以找到，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/51b765b8c4bf512393cfc701254bf1a7.png" alt="06"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/cf51c497bb4c3a66b5dd6a4e6d1fa0af.png" alt="07"></p><p>请求参数，time 是时间戳，a 值随便，没有都可以，不影响，其他值都是定值，获取的关键代码如下：</p><pre><code class="python">def get_user_trace_token() -&gt; str:    # 获取 cookie 中的 user_trace_token    json_url = &quot;https://a.脱敏处理.com/json&quot;    headers = &#123;        &quot;Host&quot;: &quot;a.脱敏处理.com&quot;,        &quot;Referer&quot;: &quot;https://www.脱敏处理.com/&quot;,        &quot;User-Agent&quot;: UA    &#125;    params = &#123;        &quot;lt&quot;: &quot;trackshow&quot;,        &quot;t&quot;: &quot;ad&quot;,        &quot;v&quot;: 0,        &quot;dl&quot;: &quot;https://www.脱敏处理.com/&quot;,        &quot;dr&quot;: &quot;https://www.脱敏处理.com&quot;,        &quot;time&quot;: str(int(time.time() * 1000))    &#125;    response = requests.get(url=json_url, headers=headers, params=params)    user_trace_token = response.cookies.get_dict()[&quot;user_trace_token&quot;]    return user_trace_token</code></pre><h3 id="X-HTTP-TOKEN"><a href="#X-HTTP-TOKEN" class="headerlink" title="X_HTTP_TOKEN"></a>X_HTTP_TOKEN</h3><p>直接搜索没有值，直接上 Hook 大法，小白朋友不清楚的话可以看以前的文章，都有详细教程，这里不再细说。</p><pre><code class="javascript">(function () &#123;    &#39;use strict&#39;;    var cookieTemp = &quot;&quot;;    Object.defineProperty(document, &#39;cookie&#39;, &#123;        set: function (val) &#123;            console.log(&#39;Hook捕获到cookie设置-&gt;&#39;, val);            if (val.indexOf(&#39;X_HTTP_TOKEN&#39;) != -1) &#123;                debugger;            &#125;            cookieTemp = val;            return val;        &#125;,        get: function () &#123;            return cookieTemp;        &#125;    &#125;);&#125;)();</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/bbba2e987582027cc7abd508b3574034.png" alt="08"></p><p>往上跟栈调试，是一个小小的 OB 混淆，<code>_0x32e0d2</code> 就是最后的 <code>X_HTTP_TOKEN</code> 值了，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/54d3c9e468fc4a104eceb6d3e888e241.png" alt="09"></p><p>直接梭哈，才300多行，不必扣了，全部 copy 下来，本地运行，发现会报错 document 未定义，定位到代码位置，下断点调试一下，发现是正则匹配 cookie 中的 <code>user_trace_token</code> 的值，那么我们直接定义一下即可：<code>var document = &#123;&quot;cookie&quot;: cookie&#125;</code>，cookie 值把 <code>user_trace_token</code> 传过来即可。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7a1675d3103c4057fc553339712e9f06.png" alt="10"></p><p>补全 document 后，再次运行，又会报错 window 未定义，再次定位到源码，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0b202a0b9bba762648653c7a519277f7.png" alt="11"></p><p>分析一下，取了 window XMLHttpRequest 对象，向 wafcheck.json 这个接口发送了一个 Ajax GET 请求，然后取了 Response Header 的 Date 值赋值给 <code>_0x309ac8</code>，注意这个 Date 值比正常时间晚了8个小时，然而取 Date 值并没有什么用，因为后面又 new 了一个新 Date 标准时间，赋值给了 <code>_0x150c4d</code>，<code>new Date(_0x309ac8[_0x3551(&#39;0x2d&#39;)](/-/g, &#39;/&#39;))</code> 语句虽然用到了前面的旧 Date，然而实际上是 <code>replace()</code> 替换方法，与旧的 Date 并没有什么关系，然后调用 <code>Date.parse()</code> 方法将新 Date 转换成时间戳赋值给 <code>_0x4e6d5d</code>，所以不需要这么复杂，直接本地把 <code>_0x89ea429</code> 方法修改一下就行了：</p><pre><code class="javascript">// 原方法// function _0x89ea42() &#123;//     var _0x372cc0 = null;//     if (window[_0x3551(&#39;0x26&#39;)]) &#123;//         _0x372cc0 = new window[(_0x3551(&#39;0x26&#39;))]();//     &#125; else &#123;//         _0x372cc0 = new ActiveObject(_0x3551(&#39;0x27&#39;));//     &#125;//     _0x372cc0[_0x3551(&#39;0x28&#39;)](_0x3551(&#39;0x29&#39;), _0x3551(&#39;0x2a&#39;), ![]);//     _0x372cc0[_0x3551(&#39;0x2b&#39;)](null);//     var _0x309ac8 = _0x372cc0[_0x3551(&#39;0x2c&#39;)](&#39;Date&#39;);//     var _0x150c4d = new Date(_0x309ac8[_0x3551(&#39;0x2d&#39;)](/-/g, &#39;/&#39;));//     var _0x4e6d5d = Date[_0x3551(&#39;0x2e&#39;)](_0x150c4d);//     return _0x4e6d5d / 0x3e8;// &#125;// 本地改写function _0x89ea42() &#123;    var _0x150c4d = new Date();    var _0x4e6d5d = Date.parse(_0x150c4d);    return _0x4e6d5d / 0x3e8;&#125;</code></pre><p>本地测试 OK：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/281437e650682cc59489955d88dc7bf5.png" alt="12"></p><h3 id="lg-stoken"><a href="#lg-stoken" class="headerlink" title="lg_stoken"></a><strong>lg_stoken</strong></h3><p><code>__lg_stoken__</code> 这个参数是在点击搜索后才开始生成的，直接搜索同样没值，Hook 一下，往上跟栈，很容易找到生成位置：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/da44eff2c8db5bcb772483440154ca4a.png" alt="13"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/95fc8ff9ba9695f869840d786f33b822.png" alt="14"></p><p>可以看到 d 就是 <code>__lg_stoken__</code> 的值，<code>d = (new g()).a()</code>、<code>g = window.gt</code>，<code>window.gt</code> 实际上是调用了 <code>_0x11db59</code></p><p>跟进混淆的 JS 看一下，就会发现末尾的这段代码是关键，这里用到了 prototype 原型对象，我们直接 <code>window.gt.prototype.a()</code> 或者 <code>(new window.gt).a()</code> 就能获取到 <code>__lg_stoken__</code>，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7b16218279b88d708ef41c717ebf03d4.png" alt="15"></p><p>到这里也许你想下断点去调试一下，看看能不能扣个逻辑出来，但是你会发现刷新之后断不下，因为这个混淆 JS 文件是一直在变化的，之前的断点就不管用了，然后你就可能会想到直接替换掉这个 JS，让文件名固定下来，就可以断点调试了，如果你这样操作的话，重新刷新会发现一直在加载中，打开控制台会发现报错了，造成这样的原因就在于这个混淆 JS 不仅文件名会改变，他的内容也会改变，当然，内容也不仅仅是改变了变量名那么简单，有些值也是动态变化的，比如：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/085f1a05ec9ba2419fe631e412e776ff.png" alt="16"></p><p>这里我们先不管那么多，直接把所有的混淆代码 copy 下来，先在本地调试一下，看看能不能跑通，调试过程中，先后会提示 <code>window is not defined</code>、<code>Cannot read properties of undefined (reading &#39;hostname&#39;)</code>，定位到代码，有个取 <code>window.location.hostname</code> 的操作，本地定义一下就行了：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/fdda6cf866ecb09c5f7f059bd91ad056.png" alt="17"></p><p>再次调试又会报错 <code> Cannot read properties of undefined (reading &#39;substr&#39;)</code>，<code>substr()</code> 方法可在字符串中抽取从指定下标开始的、指定数目的字符，是字符串对象 stringObject 具有的方法，我们定位到代码，发现是 <code>window.location.search</code> 对象调用了 <code>substr()</code> 方法，所以同样的，我们本地也要补齐。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e951e3c429fff1e85e127a810d9e259e.png" alt="18"></p><p>本地补齐参数后，运行结果与网页一致：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3ef0c04fbc7678fc2553830a473d4356.png" alt="19"></p><p>执行结果没问题了，那么还有一个问题，<code>window.location.search</code> 的值就是待加密参数了，是咋来的呢？我们直接搜索，就可以看到是一个接口302跳转的地址，用的时候直接取就行了，这个接口是你搜索内容组成的，搜索不同参数，这个跳转地址也是不一样的：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c686be59dceaf2965fd00383cfe68066.png" alt="20"></p><p>调试成功后，我们随便换一个搜索关键词，将得到的302跳转地址拿到这个 JS 中，加密一下，发现会报错，这说明混淆 JS 传入的参数和 JS 内容应该是相对应的，这里的做法是直接请求拿到这个 JS 文件内容，然后把要补的 window 和获取 <code>__lg_stoken__</code> 的方法加进去，然后直接执行就行了。</p><p>获取 <code>__lg_stoken__</code>  的关键代码如下（<code>original_data</code> 为原始搜索数据）：</p><pre><code class="python">def get_lg_stoken(original_data: dict) -&gt; str:    # 获取 cookie 中的 __lg_stoken__    token_url = &quot;https://www.脱敏处理.com/wn/jobs&quot;    token_headers = &#123;        &quot;Host&quot;: &quot;www.脱敏处理.com&quot;,        &quot;Referer&quot;: &quot;https://www.脱敏处理.com/&quot;,        &quot;User-Agent&quot;: UA    &#125;    params = &#123;        &quot;kd&quot;: original_data[&quot;kd&quot;],        &quot;city&quot;: original_data[&quot;city&quot;]    &#125;    token_response = requests.get(url=token_url, params=params, headers=token_headers, cookies=global_cookies, allow_redirects=False)    if token_response.status_code != 302:        raise Exception(&quot;获取跳转链接异常！检查 global_cookies 是否已包含 __lg_stoken__！&quot;)    # 获取 302 跳转的地址    security_check_url = token_response.headers[&quot;Location&quot;]    if &quot;login&quot; in security_check_url:        raise Exception(&quot;IP 被关进小黑屋啦！需要登录！请补全登录后的 Cookie，或者自行添加代理！&quot;)    parse_result = parse.urlparse(security_check_url)    # url 的参数为待加密对象    security_check_params = parse_result.query    # 取 name 参数，为混淆 js 的文件名    security_check_js_name = parse.parse_qs(security_check_params)[&quot;name&quot;][0]    # 发送请求，获取混淆的 js    js_url = &quot;https://www.脱敏处理.com/common-sec/dist/&quot; + security_check_js_name + &quot;.js&quot;    js_headers = &#123;        &quot;Host&quot;: &quot;www.脱敏处理.com&quot;,        &quot;Referer&quot;: security_check_url,        &quot;User-Agent&quot;: UA    &#125;    js_response = requests.get(url=js_url, headers=js_headers, cookies=global_cookies).text    # 补全 js，添加 window 参数和一个方法，用于获取 __lg_stoken__ 的值    lg_js = &quot;&quot;&quot;    window = &#123;        &quot;location&quot;: &#123;            &quot;hostname&quot;: &quot;www.脱敏处理.com&quot;,            &quot;search&quot;: &#39;?%s&#39;        &#125;    &#125;    function getLgStoken()&#123;        return window.gt.prototype.a()    &#125;    &quot;&quot;&quot; % security_check_params + js_response    lg_stoken = execjs.compile(lg_js).call(&quot;getLgStoken&quot;)    return lg_stoken</code></pre><h2 id="请求头参数"><a href="#请求头参数" class="headerlink" title="请求头参数"></a>请求头参数</h2><p>请求头参数比较多，有 <code>traceparent</code>、<code>X-K-HEADER</code>、<code>X-S-HEADER</code>、<code>X-SS-REQ-HEADER</code>、<code>x-anit-forge-code</code>、<code>x-anit-forge-token</code>，其中最后两个 <code>x-anit</code> 开头的参数是登录后才有的，实际测试中，即便是登录了，不加这两个好像也行。不过还是分析一下吧。</p><h3 id="x-anit-forge-code-x-anit-forge-token"><a href="#x-anit-forge-code-x-anit-forge-token" class="headerlink" title="x-anit-forge-code / x-anit-forge-token"></a>x-anit-forge-code / x-anit-forge-token</h3><p>这两个值是首次点击搜索生成的，第一次访问搜索接口，返回的 HTML 里面夹杂了一个 JSON 文件，里面的 <code>submitCode</code> 和 <code>submitToken</code> 就是 <code>x-anit-forge-code</code> 和 <code>x-anit-forge-token</code> 的值，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b058272ab7d86994c7c93e4ef6c521ed.png" alt="21"></p><p>请求这个接口要注意带上登录后的 cookies，有用的只有四个值，正确的 cookies 类似于：</p><pre><code class="python">cookies = &#123;    &quot;login&quot;: &quot;true&quot;,    &quot;gate_login_token&quot;: &quot;54a31e93aa904a6bb9731bxxxxxxxxxxxxxx&quot;,    &quot;_putrc&quot;: &quot;9550E53D830BE8xxxxxxxxxxxxxx&quot;,    &quot;JSESSIONID&quot;: &quot;ABAAAECABIEACCA79BFxxxxxxxxxxxxxx&quot;&#125;</code></pre><p>注意，JSESSIONID 即便不登录也会有，但是登录时应该会携带这个值，进行一个激活操作，如果你请求获取到的 submitCode、submitToken 为空，那么就有可能 JSESSIONID 是无效的，以上所有值都必须登录后复制过来！</p><p>获取 <code> x-anit-forge-code</code>、<code>x-anit-forge-token</code>  的关键代码如下（<code>original_data</code> 为原始搜索数据）：</p><pre><code class="python">def update_x_anit(original_data: dict) -&gt; None:    # 更新 x-anit-forge-code 和 x-anit-forge-token    url = &quot;https://www.脱敏处理.com/wn/jobs&quot;    headers = &#123;        &quot;Host&quot;: &quot;www.脱敏处理.com&quot;,        &quot;Referer&quot;: &quot;https://www.脱敏处理.com/&quot;,        &quot;User-Agent&quot;: UA    &#125;    params = &#123;        &quot;kd&quot;: original_data[&quot;kd&quot;],        &quot;city&quot;: original_data[&quot;city&quot;]    &#125;    response = requests.get(url=url, params=params, headers=headers, cookies=global_cookies)    tree = etree.HTML(response.text)    next_data_json = json.loads(tree.xpath(&quot;//script[@id=&#39;__NEXT_DATA__&#39;]/text()&quot;)[0])    submit_code = next_data_json[&quot;props&quot;][&quot;tokenData&quot;][&quot;submitCode&quot;]    submit_token = next_data_json[&quot;props&quot;][&quot;tokenData&quot;][&quot;submitToken&quot;]    # 注意 JSESSIONID 必须是登录验证后的！    if not submit_code or not submit_token:        raise Exception(&quot;submitCode &amp; submitToken 为空，请检查 JSESSIONID 是否正确！&quot;)    global x_anit    x_anit[&quot;x-anit-forge-code&quot;] = submit_code    x_anit[&quot;x-anit-forge-token&quot;] = submit_token</code></pre><h3 id="traceparent"><a href="#traceparent" class="headerlink" title="traceparent"></a>traceparent</h3><p>同样的 Hook 大法，跟栈：</p><pre><code class="javascript">(function () &#123;    var org = window.XMLHttpRequest.prototype.setRequestHeader;    window.XMLHttpRequest.prototype.setRequestHeader = function (key, value) &#123;        console.log(&#39;Hook 捕获到 %s 设置 -&gt; %s&#39;, key, value);        if (key == &#39;traceparent&#39;) &#123;            debugger;        &#125;        return org.apply(this, arguments);    &#125;;&#125;)();</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/ca4250dc656e4516f61eb4085ca9743e.png" alt="22"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/b38bd3f45b8b107002472e03f13b4ce9.png" alt="23"></p><p>观察上面的代码，三元表达式，<code>t.sampled</code> 为 <code>true</code>，所以 <code>e</code> 值为 <code>01</code>，<code>n</code> 值为 <code>t.id</code>，重点在于 <code>t.traceId</code> 和 <code>t.id</code> 了，跟栈发现很难调，直接搜索关键字，可找到生成的位置：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9aa669c7aac13c6f101f1df1bc01d1df.png" alt="24"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/1c6831862c149d7dec12e01dbf838d86.png" alt="25"></p><p>把 <code>E()</code> 方法扣出来就行了，改写一下即可：</p><pre><code class="javascript">getRandomValues = require(&#39;get-random-values&#39;)function E(t) &#123;    for (var b = [], w = 0; w &lt; 256; ++w)            b[w] = (w + 256).toString(16).substr(1);    var T = new Uint8Array(16);    return function(t) &#123;        for (var e = [], n = 0; n &lt; t.length; n++)            e.push(b[t[n]]);        return e.join(&quot;&quot;)    &#125;(getRandomValues(T)).substr(0, t)&#125;function getTraceparent()&#123;    return &quot;00-&quot; + E() + &quot;-&quot; + E(16) + &quot;-&quot; + &quot;01&quot;&#125;// 测试输出// console.log(getTraceparent())</code></pre><h3 id="X-K-HEADER-X-SS-REQ-HEADER"><a href="#X-K-HEADER-X-SS-REQ-HEADER" class="headerlink" title="X-K-HEADER / X-SS-REQ-HEADER"></a>X-K-HEADER / X-SS-REQ-HEADER</h3><p><code>X-K-HEADER</code> 和 <code>X-SS-REQ-HEADER</code> 数据是一样的，只不过后者是键值对形式，先直接全局搜索关键字，发现都是从本地拿这两个值，清除 cookie 就为空了，那么直接搜索值，发现是 agreement 这个接口返回的，<code>secretKeyValue</code> 值就是我们要的，有可能浏览器抓包直接搜索的话搜索不到，使用抓包工具，比如 Fiddler 就能搜到了，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5b82461455529eac20e1037983745711.png" alt="26"></p><p>这个接口是 post 请求，请求带了一个 json 数据，<code>secretKeyDecode</code>，直接搜索关键字，就一个值，定位跟栈：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/738389717bc00ab5cedf5d7fecc09b82.png" alt="27"></p><p><code>zt()</code> 是从本地缓存中取，<code>At()</code> 是重新生成：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/fa5ccfe57f4391467800a062edbc44e0.png" alt="28"></p><p>这里就非常明显了，t 是32位随机字符串，赋值为 <code>aesKey</code>，后面紧接着一个 RSA 加密了 <code>aesKey</code>，赋值为 <code>rsaEncryptData</code>，而 <code>rsaEncryptData</code> 就是前面 agreement 接口请求的 <code>secretKeyValue</code> 值。</p><p>这里先说一下，最终搜索职位请求的 data 和返回数据都是 AES 加密解密，会用到这个 <code>aesKey</code>，请求头的另一个参数 <code>X-S-HEADER</code> 也会用到，如果这个 key 没有经过 RSA 加密并通过 agreement 接口验证的话，是无效的，可以理解为 agreement 接口既是为了获取 <code>X-K-HEADER</code> 和 <code>X-SS-REQ-HEADER</code>，也是为了激活这个 <code>aesKey</code>。</p><p>这部分的 JS 代码和 Python 代码大致如下：</p><pre><code class="javascript">JSEncrypt = require(&quot;jsencrypt&quot;)function getAesKeyAndRsaEncryptData() &#123;    var aesKey = function (t) &#123;        for (var e = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;, r = &quot;&quot;, n = 0; n &lt; t; n++) &#123;            var i = Math.floor(Math.random() * e.length);            r += e.substring(i, i + 1)        &#125;        return r    &#125;(32);    var e = new JSEncrypt();    e.setPublicKey(&quot;-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnbJqzIXk6qGotX5nD521Vk/24APi2qx6C+2allfix8iAfUGqx0MK3GufsQcAt/o7NO8W+qw4HPE+RBR6m7+3JVlKAF5LwYkiUJN1dh4sTj03XQ0jsnd3BYVqL/gi8iC4YXJ3aU5VUsB6skROancZJAeq95p7ehXXAJfCbLwcK+yFFeRKLvhrjZOMDvh1TsMB4exfg+h2kNUI94zu8MK3UA7v1ANjfgopaE+cpvoulg446oKOkmigmc35lv8hh34upbMmehUqB51kqk9J7p8VMI3jTDBcMC21xq5XF7oM8gmqjNsYxrT9EVK7cezYPq7trqLX1fyWgtBtJZG7WMftKwIDAQAB-----END PUBLIC KEY-----&quot;);    var rsaEncryptData = e.encrypt(aesKey);    return &#123;        &quot;aesKey&quot;: aesKey,        &quot;rsaEncryptData&quot;: rsaEncryptData    &#125;&#125;// 测试输出// console.log(getAesKeyAndRsaEncryptData())</code></pre><pre><code class="python">def update_aes_key() -&gt; None:    # 通过JS获取 AES Key，并通过接口激活，接口激活后会返回一个 secretKeyValue，后续请求头会用到    global aes_key, secret_key_value    url = &quot;https://gate.脱敏处理.com/system/agreement&quot;    headers = &#123;        &quot;Content-Type&quot;: &quot;application/json&quot;,        &quot;Host&quot;: &quot;gate.脱敏处理.com&quot;,        &quot;Origin&quot;: &quot;https://www.脱敏处理.com&quot;,        &quot;Referer&quot;: &quot;https://www.脱敏处理.com/&quot;,        &quot;User-Agent&quot;: UA    &#125;    encrypt_data = lagou_js.call(&quot;getAesKeyAndRsaEncryptData&quot;)    aes_key = encrypt_data[&quot;aesKey&quot;]    rsa_encrypt_data = encrypt_data[&quot;rsaEncryptData&quot;]    data = &#123;&quot;secretKeyDecode&quot;: rsa_encrypt_data&#125;    response = requests.post(url=url, headers=headers, json=data).json()    secret_key_value = response[&quot;content&quot;][&quot;secretKeyValue&quot;]</code></pre><h3 id="X-S-HEADER"><a href="#X-S-HEADER" class="headerlink" title="X-S-HEADER"></a>X-S-HEADER</h3><p><code>X-S-HEADER</code> 你每次翻页都会改变，直接搜索关键字可定位：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3c12d2eec0ae138cdf5b9308c5efd6dd.png" alt="29"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/67936e9e23ab04bbdd242d44b8ec3af1.png" alt="30"></p><p>中间有一个 SHA256 加密，最后返回的 <code>Rt(JSON.stringify(&#123;originHeader: JSON.stringify(e), code: t&#125;))</code> 就是 <code>X-S-HEADER</code> 的值了，<code>Rt()</code> 是一个 AES 加密，比较关键的，<code>Vt(r)</code> 是一个 URL，比如你搜索职位就是 positionAjax.json，搜索公司就是 companyAjax.json，可根据实际情况定制，然后 <code>Lt(t)</code> 就是搜索信息，字符串形式，包含了城市、页码、关键词等。</p><p>获取 <code>X-S-HEADER</code> 的 JS 代码大致如下：</p><pre><code class="javascript">CryptoJS = require(&#39;crypto-js&#39;)jt = function(aesKey, originalData, u) &#123;    var e = &#123;deviceType: 1&#125;      , t = &quot;&quot;.concat(JSON.stringify(e)).concat(u).concat(JSON.stringify(originalData))      , t = (t = t, null === (t = CryptoJS.SHA256(t).toString()) || void 0 === t ? void 0 : t.toUpperCase());    return Rt(JSON.stringify(&#123;        originHeader: JSON.stringify(e),        code: t    &#125;), aesKey)&#125;Rt = function (t, aesKey) &#123;    var Ot = CryptoJS.enc.Utf8.parse(&quot;c558Gq0YQK2QUlMc&quot;),        Dt = CryptoJS.enc.Utf8.parse(aesKey),        t = CryptoJS.enc.Utf8.parse(t);    t = CryptoJS.AES.encrypt(t, Dt, &#123;        iv: Ot,        mode: CryptoJS.mode.CBC,        padding: CryptoJS.pad.Pkcs7    &#125;);    return t.toString()&#125;;function getXSHeader(aesKey, originalData, u)&#123;    return jt(aesKey, originalData, u)&#125;// 测试样例// var url = &quot;https://www.脱敏处理.com/jobs/v2/positionAjax.json&quot;// var aesKey = &quot;dgHY1qVeo/Z0yDaF5WV/EEXxYiwbr5Jt&quot;// var originalData = &#123;&quot;first&quot;: &quot;true&quot;, &quot;needAddtionalResult&quot;: &quot;false&quot;, &quot;city&quot;: &quot;全国&quot;, &quot;pn&quot;: &quot;2&quot;, &quot;kd&quot;: &quot;Java&quot;&#125;// console.log(getXSHeader(aesKey, originalData, url))</code></pre><h2 id="请求-返回数据解密"><a href="#请求-返回数据解密" class="headerlink" title="请求/返回数据解密"></a>请求/返回数据解密</h2><p>前面抓包我们已经发现 positionAjax.json 是 POST 请求，Form Data 中的数据是加密的，返回的 data 也是加密的，我们分析请求头参数的时候，就涉及到 AES 加密解密，所以我们直接搜索 <code>AES.encrypt</code>、<code>AES.decrypt</code>，下断点调试：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a71d05bb4c558409eea816c1792038e7.png" alt="31"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/1127358d32e96c667e465d71b06365ae.png" alt="32"></p><p>非常明显了，这部分的 JS 代码大致如下：</p><pre><code class="javascript">CryptoJS = require(&#39;crypto-js&#39;)function getRequestData(aesKey, originalData)&#123;    return Rt(JSON.stringify(originalData), aesKey)&#125;function getResponseData(encryptData, aesKey)&#123;    return It(encryptData, aesKey)&#125;Rt = function (t, aesKey) &#123;    var Ot = CryptoJS.enc.Utf8.parse(&quot;c558Gq0YQK2QUlMc&quot;),        Dt = CryptoJS.enc.Utf8.parse(aesKey),        t = CryptoJS.enc.Utf8.parse(t);    t = CryptoJS.AES.encrypt(t, Dt, &#123;        iv: Ot,        mode: CryptoJS.mode.CBC,        padding: CryptoJS.pad.Pkcs7    &#125;);    return t.toString()&#125;;It = function(t, aesKey) &#123;    var Ot = CryptoJS.enc.Utf8.parse(&quot;c558Gq0YQK2QUlMc&quot;),    Dt = CryptoJS.enc.Utf8.parse(aesKey);    t = CryptoJS.AES.decrypt(t, Dt, &#123;        iv: Ot,        mode: CryptoJS.mode.CBC,        padding: CryptoJS.pad.Pkcs7    &#125;).toString(CryptoJS.enc.Utf8);    try &#123;        t = JSON.parse(t)    &#125; catch (t) &#123;&#125;    return t&#125;// 测试样例，注意，encryptedData 数据太多，省略了，直接运行解密是会报错的// var aesKey = &quot;dgHY1qVeo/Z0yDaF5WV/EEXxYiwbr5Jt&quot;// var encryptedData = &quot;r4MqbduYxu3Z9sFL75xDhelMTCYPHLluKaurYgzEXlEQ1Rg......&quot;// var originalData = &#123;&quot;first&quot;: &quot;true&quot;, &quot;needAddtionalResult&quot;: &quot;false&quot;, &quot;city&quot;: &quot;全国&quot;, &quot;pn&quot;: &quot;2&quot;, &quot;kd&quot;: &quot;Java&quot;&#125;// console.log(getRequestData(aesKey, originalData))// console.log(getResponseData(encryptedData, aesKey))</code></pre><p>大致的 Python 代码如下：</p><pre><code class="python">def get_header_params(original_data: dict) -&gt; dict:    # 后续请求数据所需的请求头参数    # 职位搜索 URL，如果是搜索公司，那就是 https://www.脱敏处理.com/jobs/companyAjax.json，根据实际情况更改    u = &quot;https://www.脱敏处理.com/jobs/v2/positionAjax.json&quot;    return &#123;        &quot;traceparent&quot;: lagou_js.call(&quot;getTraceparent&quot;),        &quot;X-K-HEADER&quot;: secret_key_value,        &quot;X-S-HEADER&quot;: lagou_js.call(&quot;getXSHeader&quot;, aes_key, original_data, u),        &quot;X-SS-REQ-HEADER&quot;: json.dumps(&#123;&quot;secret&quot;: secret_key_value&#125;)    &#125;def get_encrypted_data(original_data: dict) -&gt; str:    # AES 加密原始数据    encrypted_data = lagou_js.call(&quot;getRequestData&quot;, aes_key, original_data)    return encrypted_datadef get_data(original_data: dict, encrypted_data: str, header_params: dict) -&gt; dict:    # 携带加密后的请求数据和完整请求头，拿到密文，AES 解密得到明文职位信息    url = &quot;https://www.脱敏处理.com/jobs/v2/positionAjax.json&quot;    referer = parse.urljoin(&quot;https://www.脱敏处理.com/wn/jobs?&quot;, parse.urlencode(original_data))    headers = &#123;        # &quot;content-type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,        &quot;Host&quot;: &quot;www.脱敏处理.com&quot;,        &quot;Origin&quot;: &quot;https://www.脱敏处理.com&quot;,        &quot;Referer&quot;: referer,        &quot;traceparent&quot;: header_params[&quot;traceparent&quot;],        &quot;User-Agent&quot;: UA,        &quot;X-K-HEADER&quot;: header_params[&quot;X-K-HEADER&quot;],        &quot;X-S-HEADER&quot;: header_params[&quot;X-S-HEADER&quot;],        &quot;X-SS-REQ-HEADER&quot;: header_params[&quot;X-SS-REQ-HEADER&quot;],    &#125;    # 添加 x-anit-forge-code 和 x-anit-forge-token    headers.update(x_anit)    data = &#123;&quot;data&quot;: encrypted_data&#125;    response = requests.post(url=url, headers=headers, cookies=global_cookies, data=data).json()    if &quot;status&quot; in response:        if not response[&quot;status&quot;] and &quot;操作太频繁&quot; in response[&quot;msg&quot;]:            raise Exception(&quot;获取数据失败！msg：%s！可以尝试补全登录后的 Cookies，或者添加代理！&quot; % response[&quot;msg&quot;])        else:            raise Exception(&quot;获取数据异常！请检查数据是否完整！&quot;)    else:        response_data = response[&quot;data&quot;]        decrypted_data = lagou_js.call(&quot;getResponseData&quot;, response_data, aes_key)        return decrypted_data</code></pre><p>最终整合所有代码，成功拿到数据：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/113e75fb0750f81f8e39031ce7268bb5.png" alt="33"></p><h2 id="逆向小技巧"><a href="#逆向小技巧" class="headerlink" title="逆向小技巧"></a>逆向小技巧</h2><p>浏览器开发者工具 Application - Storage 选项，可以一键清除所有 Cookies，也可以自定义存储配额：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/05bcd18f355250c4570239163d16cae0.png" alt="34"></p><p>Storage - Cookies 可以查看每个站点的所有 Cookies，HttpOnly 打勾的表示是服务器返回的，选中一条 Cookie，右键可以直接定位到哪个请求带了这个 Cookie，也可以直接编辑值，还可以删除单个 Cookie，当你登录了账号，但又需要清除某个 Cookie，且不想重新登录时，这个功能或许有用。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1cc2ddd95e3c595f71f1760b16d60b08.png" alt="35"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>文中给出了部分关键代码，不能直接运行，部分细节可能没提及到，完整代码已放 GitHub，均有详细注释，欢迎 Star。所有内容仅供学习交流，严禁用于商业用途、非法用途，否则由此产生的一切后果均与作者无关，在仓库中下载的文件学习完毕之后请于 24 小时内删除！</p><p>仓库地址：<a href="https://github.com/TRHX/Python3-Spider-Practice">https://github.com/TRHX/Python3-Spider-Practice</a></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul><li><p>JS 代码里引用了三个库，npm install 安装一下即可，如果安装了还提示找不到库，那就是路径问题，推荐在当前目录下执行命令安装，或者在 Python 代码里指定完整路径，具体方法可自行百度。</p></li><li><p>jsencrypt 这个库，本地运行可能会报错 <code>window is not defined</code>，在 <code>\node_modules\jsencrypt\bin\jsencrypt.js</code> 源码中加入 <code>var window = global;</code> 即可，这是实现 RSA 加密的库，当然还有很多其他实现方法或者库，都可以。</p></li><li><p>execjs 执行 JS 的时候，可能会报编码错误 <code>&quot;gbk&quot; can&#39;t decode byte...</code>，有两种解决方法，一是找到官方源码 subprocess.py，搜索 <code>encoding=None</code> 改成 <code>encoding=&#39;utf-8&#39;</code>，二是直接在 Python 代码里面加入以下代码即可：</p></li></ul><pre><code class="python">import subprocessfrom functools import partialsubprocess.Popen = partial(subprocess.Popen, encoding=&quot;utf-8&quot;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文章中所有内容仅供学习交流，抓包内容、敏感网址、数据接口均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果</summary>
      
    
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91/"/>
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python 中如何解决 asyncio 文件描述符最大数量限制问题</title>
    <link href="https://www.itbob.cn/article/048/"/>
    <id>https://www.itbob.cn/article/048/</id>
    <published>2022-02-23T02:18:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>Windows 平台下，Python 版本 3.5，使用异步框架 asyncio，有时候会出现 <code>ValueError: too many file descriptors in select()</code> 的报错信息，今天我们就来聊一下为什么会出现这种问题，以及问题的一些解决方法。</p><p>写一个小 dome 复现这个问题（环境：Windows 64 位、Python 3.7）：</p><pre><code class="python">import aiohttpimport asyncionum = 0async def main(url):    async with aiohttp.ClientSession() as session:        async with session.get(url) as response:            global num            num += 1            print(&#39;%s ——&gt; %s&#39; % (str(num), response.status))def tasks():    url = &#39;https://www.baidu.com/s?ie=UTF-8&amp;wd=%s&#39;    task = [main(url % i) for i in range(10000)]    return taskloop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks()))</code></pre><p>在打印 500 次左右后就会出现以下报错：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f70f58344164e7929022924cd757a85e.png" alt="01.png"></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>好像这个报错和 select 有关，那什么是 select 呢？要怎么解决呢？别急，我们首先来了解一下 asyncio 中的事件循环，即 EventLoop。</p><h3 id="事件循环-EventLoop"><a href="#事件循环-EventLoop" class="headerlink" title="事件循环 EventLoop"></a>事件循环 EventLoop</h3><p>事件循环是 asyncio 的核心，异步任务的运行、任务完成之后的回调、网络 I/O 操作、子进程的运行，都是通过事件循环完成的，通俗来讲，事件循环所做的就是等待事件发生，然后再将每个事件与我们已明确与所述事件类型匹配的函数进行匹配。下图很好的展示了协程、事件循环之间的相互作用：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/91dc097882fc67be9195869f3b179174.png" alt="02.png"></p><p>在 asyncio 中，主要提供了两种不同事件循环的实现方法： </p><ul><li><p><strong>SelectorEventLoop</strong>：基于 selectors 模块的事件循环，selectors 又是建立在底层的 I/O 复用模块 select 之上的，selectors 提供了高度封装和高效的 I/O 复用，也就是说 SelectorEventLoop 在底层就是使用了 select I/O 多路复用的机制。</p></li><li><p><strong>ProactorEventLoop</strong>：使用 IOCP 专为 Windows 构建的事件循环，IOCP 全称 I/O Completion Port，即 I/O 完成端口。它是支持多个同时发生的异步 I/O 操作的应用程序编程接口，它充分利用内核对象的调度，只使用少量的几个线程来处理和客户端的所有通信，消除了无谓的线程上下文切换，是 Windows 下性能最好的 I/O 模型，有关 IOCP 的详细介绍可参考<a href="https://docs.microsoft.com/en-ca/windows/win32/fileio/i-o-completion-ports">微软文档</a>。</p></li></ul><p>那么这两种方法有什么区别呢？在 asyncio 中什么时候用什么方法呢？</p><p>我们不妨看一下 asyncio 的源码，在 Python 3.7 中，无论在 Windows 还是 Linux 中都可以看到其默认的设置是 SelectorEventLoop：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7d650aeaed8ffcd845b1042a2a790501.png" alt="03.png"></p><p>我们也可以分别在 Windows 平台和 Linux 平台打印一下 EventLoop 对象（Python 3.7），可以看到默认都是 SelectorEventLoop：</p><pre><code class="python">import asyncioloop = asyncio.get_event_loop()print(loop)</code></pre><p>Windows：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bcfeab7170f5de6e7ad605d76aa5868a.png" alt="04.png"></p><p>Linux：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/efb7794e5f2ba360cb3d0f0523061d6e.png" alt="05.png"></p><p>事实上，在 Python 3.7 以及之前的版本中，   所有平台默认使用的都是 SelectorEventLoop，在 Python 3.8 以及以后的版本中，Unix 平台默认使用的是 SelectorEventLoop，Windows 平台默认使用的是 ProactorEventLoop，这个差异可以在官方文档中看到。</p><ul><li>Python 3.7 文档：<a href="https://docs.python.org/3.7/library/asyncio-eventloop.html#event-loop-implementations">https://docs.python.org/3.7/library/asyncio-eventloop.html#event-loop-implementations</a></li><li>Python 3.8 文档：<a href="https://docs.python.org/3.8/library/asyncio-eventloop.html#event-loop-implementations">https://docs.python.org/3.8/library/asyncio-eventloop.html#event-loop-implementations</a></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/30387729cf1d1eaafe4114fb3a4a847d.png" alt="06.png"></p><p>说了这么多，这和 <code>ValueError: too many file descriptors in select()</code> 的报错问题有什么关系呢？select 到底是什么东西呢？</p><h3 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h3><p>要了解 select，我们还要了解一下什么是 I/O 多路复用（I/O multiplexing），服务器端编程经常需要构造高性能的 I/O 模型，常见的 I/O 模型有同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用等；当需要同时处理多个客户端接入请求时，可以利用多线程或者 I/O 多路复用技术进行处理，I/O 多路复用技术就是为了解决进程或线程阻塞到某个 I/O 系统调用而出现的技术，使进程不阻塞于某个特定的 I/O 系统调用。</p><p><strong>select，poll，epoll 等都是 I/O 多路复用的一种机制</strong>，其中后两个在 Linux 中可用，Windows 仅支持 select，I/O 多路复用通过这种机制，可以监视多个描述符，一旦某个描述符就绪，一般是读就绪或者写就绪，就是在这个文件描述符进行读写操作之前，能够通知程序进行相应的读写操作。</p><h3 id="select-的缺点"><a href="#select-的缺点" class="headerlink" title="select 的缺点"></a>select 的缺点</h3><p>I/O 多路复用这个概念被提出来以后， select 是第一个实现这个概念的，select 被实现以后，很快就暴露出了很多问题，其中一个缺点就是 <strong>select 在 Windows 中限制了文件描述符数量为 512 个，在 Linux 中限制为 1024 个</strong>，那么在前面的 dome 中，使用的是 Python 3.5，这个版本的 asyncio 默认使用了 SelectorEventLoop，底层调用的是 select，受 select 缺点的影响，并发量过高，就出现了 <code>ValueError: too many file descriptors in select()</code> 的报错信息。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="1-更换事件循环选择器"><a href="#1-更换事件循环选择器" class="headerlink" title="1.更换事件循环选择器"></a>1.更换事件循环选择器</h3><p>如果你使用的是 Python 3.7 及以下的版本，那么在 Windows 平台，可以使用 ProactorEventLoop。在 Linux 平台可以使用 PollSelector。</p><p><strong>注意</strong>：如果你使用了 ProactorEventLoop，那么你将无法使用代理！这是 asyncio 的 bug，早在 2020 年 1 月就有人提过 <a href="https://github.com/aio-libs/aiohttp/issues/4536">issue</a>，目前仍然可以看到类似的 issue，官方貌似也还没办法解决，所以，如果您必须要使用代理，则可以参考后面的解决办法。</p><pre><code class="python">import selectorsimport asyncioimport sysif sys.platform == &#39;win32&#39;:    loop = asyncio.ProactorEventLoop()    asyncio.set_event_loop(loop)else:    selector = selectors.PollSelector()    loop = asyncio.SelectorEventLoop(selector)    asyncio.set_event_loop(loop)</code></pre><h3 id="2-限制并发量"><a href="#2-限制并发量" class="headerlink" title="2.限制并发量"></a>2.限制并发量</h3><p>可以使用方法 <code>asyncio.Semaphore()</code> 来限制并发量，Semaphore 就是信号量的意思，Semaphore 管理一个内部计数器，该计数器在每次调用 <code>acquire()</code> 方法时递减，每次调用 <code>release()</code> 方法时递增，计数器永远不会低于零，当方法 <code>acquire()</code> 发现它为零时，它会阻塞，等待其他线程调用 <code>release()</code> 方法。通过限制并发量的方法来解决报错问题是个不错的选择。</p><pre><code class="python">import aiohttpimport asyncionum = 0async def main(url, semaphore):    async with semaphore:        async with aiohttp.ClientSession() as session:            async with session.get(url) as response:                global num                num += 1                print(&#39;%s ——&gt; %s&#39; % (str(num), response.status))def tasks():    semaphore = asyncio.Semaphore(300)                         # 限制并发量为 300    url = &#39;https://www.baidu.com/s?ie=UTF-8&amp;wd=%s&#39;    task = [main(url % i, semaphore) for i in range(10000)]    # #总共 10000 任务    return taskloop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks()))</code></pre><h3 id="3-修改最大文件描述符限制"><a href="#3-修改最大文件描述符限制" class="headerlink" title="3.修改最大文件描述符限制"></a>3.修改最大文件描述符限制</h3><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>在 Windows 中，最大文件描述符限制在 C 语言的头文件 Winsock2.h 中使用变量 <code>FD_SETSIZE</code> 进行定义，如果要修改它，可以通过在包含 Winsock2.h 之前将 <code>FD_SETSIZE</code> 定义为另一个值来修改，如果我们使用的编程语言是 Python 的话，是不太好对这个值进行修改的，可以参考微软官方文档：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-select">https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-select</a></p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>在 Linux 平台，可以使用 <code>ulimit</code> 命令来修改最大文件描述符限制：</p><ul><li><p>查看当前会话最大文件描述符限制（默认1024）：<code>ulimit -n</code></p></li><li><p>临时修改限制，只对当前的会话有效：<code>ulimit -SHn 65536</code></p></li><li><p>永久修改限制，在 <code>/etc/security/limits.conf</code> 文件里新增以下内容：</p><pre><code>* hard nofile 65536* soft nofile 65536</code></pre></li></ul><p><code>ulimit</code> 命令参考：</p><pre><code>    -S    使用软 (soft) 资源限制    -H    使用硬 (hard) 资源限制    -a    所有当前限制都被报告    -b    套接字缓存尺寸    -c    创建的核文件的最大尺寸    -d    一个进程的数据区的最大尺寸    -e    最高的调度优先级 (nice)    -f    有 shell 及其子进程可以写的最大文件尺寸    -i    最多的可以挂起的信号数    -k    分配给此进程的最大 kqueue 数量    -l    一个进程可以锁定的最大内存尺寸    -m    最大的内存进驻尺寸    -n    最多的打开的文件描述符个数    -p    管道缓冲区尺寸    -q    POSIX 信息队列的最大字节数    -r    实时调度的最大优先级    -s    最大栈尺寸    -t    最大的CPU时间，以秒为单位    -u    最大用户进程数    -v    虚拟内存尺寸    -x    最大的文件锁数量    -P    最大伪终端数量    -T    最大线程数量</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>asyncio 事件循环选择器，在 Python 3.7 以及之前的版本中，所有平台默认使用的都是 SelectorEventLoop，在 Python 3.8 以及以后的版本中，Unix 平台默认使用的是 SelectorEventLoop，Windows 平台默认使用的是 ProactorEventLoop。</p><p>select 在 Windows 中限制了文件描述符最大数量为 512 个，在 Linux 中限制为 1024 个。</p><p>要解决 <code>ValueError: too many file descriptors in select()</code> 的报错问题，根据您的平台和业务要求选择合理的解决方法：</p><h3 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a>Windows</h3><ol><li><p>通过 <code>asyncio.Semaphore()</code> 方法来限制并发量，通常设置在 300-500 比较合理，这是最优的做法；</p></li><li><p>更换 asyncio 的事件循环选择器为 ProactorEventLoop，<strong>注意：这将导致无法使用代理！</strong></p></li></ol><h3 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h3><ol><li><p>通过 <code>asyncio.Semaphore()</code> 方法来限制并发量，通常设置在 800-1000 比较合理；</p></li><li><p>通过 <code>ulimit</code> 命令来修改最大文件描述符限制；</p></li><li><p>更换 asyncio 的事件循环选择器为 PollSelector。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题复现&quot;&gt;&lt;a href=&quot;#问题复现&quot; class=&quot;headerlink&quot; title=&quot;问题复现&quot;&gt;&lt;/a&gt;问题复现&lt;/h2&gt;&lt;p&gt;Windows 平台下，Python 版本 3.5，使用异步框架 asyncio，有时候会出现 &lt;code&gt;ValueErr</summary>
      
    
    
    
    <category term="Python" scheme="https://www.itbob.cn/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="asyncio" scheme="https://www.itbob.cn/tags/asyncio/"/>
    
  </entry>
  
  <entry>
    <title>RPC 技术及其框架 Sekiro 在爬虫逆向中的应用，加密数据一把梭</title>
    <link href="https://www.itbob.cn/article/047/"/>
    <id>https://www.itbob.cn/article/047/</id>
    <published>2022-02-21T09:20:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC"></a>什么是 RPC</h2><p><del>RPC，英文 RangPaCong，中文让爬虫，旨在为爬虫开路，秒杀一切，让爬虫畅通无阻！</del></p><p>开个玩笑，实际上 RPC 为远程过程调用，全称 Remote Procedure Call，是一种技术思想而非一种规范或协议。RPC 的诞生事实上离不开分布式的发展，RPC 主要解决了两个问题：</p><ol><li>解决了分布式系统中，服务之间的互相调用问题；</li><li>RPC 使得在远程调用时，像本地调用一样方便，让调用者感知不到远程调用的逻辑。</li></ol><p>RPC 的存在让构建分布式系统更加容易，相比于 HTTP 协议，RPC 采用二进制字节码传输，因此也更加高效、安全。在一个典型 RPC 的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，完整 RPC 架构图如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/71bb132886df40999a33ad59bd6a1159.png" alt="01"></p><h2 id="JSRPC"><a href="#JSRPC" class="headerlink" title="JSRPC"></a>JSRPC</h2><p>RPC 技术是非常复杂的，对于我们搞爬虫、逆向的来说，不需要完全了解，只需要知道这项技术如何在逆向中应用就行了。</p><p>RPC 在逆向中，简单来说就是将本地和浏览器，看做是服务端和客户端，二者之间通过 WebSocket 协议进行 RPC 通信，在浏览器中将加密函数暴露出来，在本地直接调用浏览器中对应的加密函数，从而得到加密结果，不必去在意函数具体的执行逻辑，也省去了扣代码、补环境等操作，可以省去大量的逆向调试时间。我们以某团网页端的登录为例来演示 RPC 在逆向中的具体使用方法。（假设你已经有一定逆向基础，了解 WebSocket 协议，纯小白可以先看看以前的文章）</p><ul><li>主页（base64）：<code>aHR0cHM6Ly9wYXNzcG9ydC5tZWl0dWFuLmNvbS9hY2NvdW50L3VuaXRpdmVsb2dpbg==</code></li><li>参数：h5Fingerprint</li></ul><p>首先抓一下包，登录接口有一个超级长的参数 h5Fingerprint，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/8fec89761494422c845e5bc8fb712a9c.png" alt="02"></p><p>直接搜一下就能找到加密函数：</p><p><img src="https://img-blog.csdnimg.cn/59e03ca57d2d4b75937961e81fc7b247.png" alt="03"></p><p>其中 <code>utility.getH5fingerprint()</code> 传入的参数 <code>window.location.origin + url</code> 格式化后，参数如下：</p><pre><code>url = &quot;https://passport.脱敏处理.com/account/unitivelogin&quot;params = &#123;    &quot;risk_partner&quot;: &quot;0&quot;,    &quot;risk_platform&quot;: &quot;1&quot;,    &quot;risk_app&quot;: &quot;-1&quot;,    &quot;uuid&quot;: &quot;96309b5f00ba4143b920.1644805104.1.0.0&quot;,    &quot;token_id&quot;: &quot;DNCmLoBpSbBD6leXFdqIxA&quot;,    &quot;service&quot;: &quot;www&quot;,    &quot;continue&quot;: &quot;https://www.脱敏处理.com/account/settoken?continue=https%3A%2F%2Fwww.脱敏处理.com%2F&quot;&#125;</code></pre><p>uuid 和 token_id 都可以直接搜到，不是本次研究重点，这里不再细说，接下来我们使用 RPC 技术，直接调用浏览器里的 <code>utility.getH5fingerprint()</code> 方法，首先在本地编写服务端代码，使其能够一直输入待加密字符串，接收并打印加密后的字符串：</p><pre><code class="python"># ==================================# --*-- coding: utf-8 --*--# @Time    : 2022-02-14# @Author  : ITBOB# @FileName: ws_server.py# @Software: PyCharm# ==================================import sysimport asyncioimport websocketsasync def receive_massage(websocket):    while True:        send_text = input(&quot;请输入要加密的字符串: &quot;)        if send_text == &quot;exit&quot;:            print(&quot;Exit, goodbye!&quot;)            await websocket.send(send_text)            await websocket.close()            sys.exit()        else:            await websocket.send(send_text)            response_text = await websocket.recv()            print(&quot;\n加密结果：&quot;, response_text)start_server = websockets.serve(receive_massage, &#39;127.0.0.1&#39;, 5678)  # 自定义端口asyncio.get_event_loop().run_until_complete(start_server)asyncio.get_event_loop().run_forever()</code></pre><p>编写浏览器客户端 JS 代码，收到消息就直接 <code>utility.getH5fingerprint()</code> 得到加密参数并发送给服务端：</p><pre><code class="javascript">/* ==================================# @Time    : 2022-02-14# @Author  : ITBOB# @FileName: ws_client.js# @Software: PyCharm# ================================== */var ws = new WebSocket(&quot;ws://127.0.0.1:5678&quot;);  // 自定义端口ws.onmessage = function (evt) &#123;    console.log(&quot;Received Message: &quot; + evt.data);    if (evt.data == &quot;exit&quot;) &#123;        ws.close();    &#125; else &#123;        ws.send(utility.getH5fingerprint(evt.data))    &#125;&#125;;</code></pre><p>然后我们需要把客户端代码注入到网页中，这里方法有很多，比如抓包软件 Fiddler 替换响应、浏览器插件 ReRes 替换 JS、浏览器开发者工具 Overrides 重写功能等，也可以通过插件、油猴等注入 Hook 的方式插入，反正方法很多，对这些方法不太了解的朋友可以去看看以前的文章，都有介绍。</p><p>这里我们使用浏览器开发者工具 Overrides 重写功能，将 WebSocket 客户端代码加到加密的这个 JS 文件里并 Ctrl+S 保存，这里将其写成了 IIFE 自执行方式，这样做的原因是防止污染全局变量，不用自执行方式当然也是可以的。</p><p><img src="https://img-blog.csdnimg.cn/5dfd3cb4f9614bed9b3a2eaa60f20c3d.png" alt="04"></p><p>然后先运行本地服务端代码，网页上先登录一遍，网页上先登录一遍，网页上先登录一遍，重要的步骤说三遍！然后就可以在本地传入待加密字符串，获取 <code>utility.getH5fingerprint()</code> 加密后的结果了：</p><p><img src="https://img-blog.csdnimg.cn/8851ff218c3a424f878fda67ecfe6f45.png" alt="05"></p><h2 id="Sekiro"><a href="#Sekiro" class="headerlink" title="Sekiro"></a>Sekiro</h2><p>通过前面的示例，可以发现自己写服务端太麻烦了，不易扩展，那这方面有没有现成的轮子呢？答案是有的，这里介绍两个项目：</p><ul><li>JsRPC-hliang：<a href="https://github.com/jxhczhl/JsRpc">https://github.com/jxhczhl/JsRpc</a></li><li>Sekiro：<a href="https://github.com/virjar/sekiro">https://github.com/virjar/sekiro</a></li></ul><p>JsRPC-hliang 是用 go 语言写的，是专门为 JS 逆向做的项目，而 Sekiro 功能更加强大，Sekiro 是由邓维佳大佬，俗称渣总，写的一个基于长链接和代码注入的 Android Private API 暴露框架，可以用在 APP 逆向、APP 数据抓取、Android 群控等场景，同时 Sekiro 也是目前公开方案唯一稳定的 JSRPC 框架，两者在 JS 逆向方面的使用方法其实都差不多，本文主要介绍一下 Sekiro 在 Web JS 逆向中的应用。</p><p>参考 Sekiro 文档，首先在本地编译项目：</p><ul><li><p>Linux &amp; Mac：执行脚本 <code>build_demo_server.sh</code>，之后得到产出发布压缩包：<code>sekiro-service-demo/target/sekiro-release-demo.zip</code></p></li><li><p>Windows：可以直接下载：<a href="https://oss.virjar.com/sekiro/sekiro-demo">https://oss.virjar.com/sekiro/sekiro-demo</a></p></li></ul><p>然后在本地运行（需要有 Java 环境，自行配置）：</p><ul><li>Linux &amp; Mac：<code>bin/sekiro.sh</code></li><li>Windows：<code>bin/sekiro.bat</code></li></ul><p>以 Windows 为例，启动后如下：</p><p><img src="https://img-blog.csdnimg.cn/c7acc0ca85e040d38ee97aff3e256f22.png" alt="06"></p><p>接下来就需要在浏览器里注入代码了，需要将作者提供的 sekiro_web_client.js（下载地址：<a href="https://sekiro.virjar.com/sekiro-doc/assets/sekiro_web_client.js%EF%BC%89">https://sekiro.virjar.com/sekiro-doc/assets/sekiro_web_client.js）</a> 注入到浏览器环境，然后通过 SekiroClient 和 Sekiro 服务器通信，即可直接 RPC 调用浏览器内部方法，官方提供的 SekiroClient 代码样例如下：</p><pre><code class="javascript">function guid() &#123;    function S4() &#123;        return (((1+Math.random())*0x10000)|0).toString(16).substring(1);    &#125;    return (S4()+S4()+&quot;-&quot;+S4()+&quot;-&quot;+S4()+&quot;-&quot;+S4()+&quot;-&quot;+S4()+S4()+S4());&#125;var client = new SekiroClient(&quot;wss://sekiro.virjar.com/business/register?group=ws-group&amp;clientId=&quot;+guid());client.registerAction(&quot;clientTime&quot;,function(request, resolve, reject)&#123;    resolve(&quot;&quot;+new Date());&#125;)</code></pre><p>wss 链接里，如果是免费版，要将 business 改成 business-demo，解释一下涉及到的名词：</p><ul><li><strong>group</strong>：业务类型（接口组），每个业务一个 group，group 下面可以注册多个终端（SekiroClient），同时 group 可以挂载多个 Action；</li><li><strong>clientId</strong>：指代设备，多个设备使用多个机器提供 API 服务，提供群控能力和负载均衡能力；</li><li><strong>SekiroClient</strong>：服务提供者客户端，主要场景为手机/浏览器等。最终的 Sekiro 调用会转发到 SekiroClient。每个 client 需要有一个惟一的 clientId；</li><li><strong>registerAction</strong>：接口，同一个 group 下面可以有多个接口，分别做不同的功能；</li><li><strong>resolve</strong>：将内容传回给客户端的方法；</li><li><strong>request</strong>：客户端传过来的请求，如果请求里有多个参数，可以以键值对的方式从里面提取参数然后再做处理。</li></ul><p>说了这么多可能也不好理解，直接实战，还是以某团网页端登录为例，我们将 sekiro_web_client.js 与 SekiroClient 通信代码写在一起，然后根据需求，改写一下通信部分代码：</p><ol><li>ws 链接改为：<code>ws://127.0.0.1:5620/business-demo/register?group=rpc-test&amp;clientId=</code>，自定义 <code>group</code> 为 <code>rpc-test</code>；</li><li>注册一个事件 <code>registerAction</code> 为 <code>getH5fingerprint</code>；</li><li><code>resolve</code> 返回的结果为 <code>utility.getH5fingerprint(request[&quot;url&quot;])</code>，即加密并返回客户端传过来的 url 参数。</li></ol><p>完整代码如下（留意末尾 SekiroClient 通信代码部分的写法）：</p><pre><code class="javascript">/* ==================================# @Time    : 2022-02-14# @Author  : ITBOB# @FileName: sekiro.js# @Software: PyCharm# ================================== */(function () &#123;    &#39;use strict&#39;;    function SekiroClient(wsURL) &#123;        this.wsURL = wsURL;        this.handlers = &#123;&#125;;        this.socket = &#123;&#125;;        // check        if (!wsURL) &#123;            throw new Error(&#39;wsURL can not be empty!!&#39;)        &#125;        this.webSocketFactory = this.resolveWebSocketFactory();        this.connect()    &#125;    SekiroClient.prototype.resolveWebSocketFactory = function () &#123;        if (typeof window === &#39;object&#39;) &#123;            var theWebSocket = window.WebSocket ? window.WebSocket : window.MozWebSocket;            return function (wsURL) &#123;                function WindowWebSocketWrapper(wsURL) &#123;                    this.mSocket = new theWebSocket(wsURL);                &#125;                WindowWebSocketWrapper.prototype.close = function () &#123;                    this.mSocket.close();                &#125;;                WindowWebSocketWrapper.prototype.onmessage = function (onMessageFunction) &#123;                    this.mSocket.onmessage = onMessageFunction;                &#125;;                WindowWebSocketWrapper.prototype.onopen = function (onOpenFunction) &#123;                    this.mSocket.onopen = onOpenFunction;                &#125;;                WindowWebSocketWrapper.prototype.onclose = function (onCloseFunction) &#123;                    this.mSocket.onclose = onCloseFunction;                &#125;;                WindowWebSocketWrapper.prototype.send = function (message) &#123;                    this.mSocket.send(message);                &#125;;                return new WindowWebSocketWrapper(wsURL);            &#125;        &#125;        if (typeof weex === &#39;object&#39;) &#123;            // this is weex env : https://weex.apache.org/zh/docs/modules/websockets.html            try &#123;                console.log(&quot;test webSocket for weex&quot;);                var ws = weex.requireModule(&#39;webSocket&#39;);                console.log(&quot;find webSocket for weex:&quot; + ws);                return function (wsURL) &#123;                    try &#123;                        ws.close();                    &#125; catch (e) &#123;                    &#125;                    ws.WebSocket(wsURL, &#39;&#39;);                    return ws;                &#125;            &#125; catch (e) &#123;                console.log(e);                //ignore            &#125;        &#125;        //TODO support ReactNative        if (typeof WebSocket === &#39;object&#39;) &#123;            return function (wsURL) &#123;                return new theWebSocket(wsURL);            &#125;        &#125;        // weex 和 PC环境的websocket API不完全一致，所以做了抽象兼容        throw new Error(&quot;the js environment do not support websocket&quot;);    &#125;;    SekiroClient.prototype.connect = function () &#123;        console.log(&#39;sekiro: begin of connect to wsURL: &#39; + this.wsURL);        var _this = this;        // 不check close，让        // if (this.socket &amp;&amp; this.socket.readyState === 1) &#123;        //     this.socket.close();        // &#125;        try &#123;            this.socket = this.webSocketFactory(this.wsURL);        &#125; catch (e) &#123;            console.log(&quot;sekiro: create connection failed,reconnect after 2s&quot;);            setTimeout(function () &#123;                _this.connect()            &#125;, 2000)        &#125;        this.socket.onmessage(function (event) &#123;            _this.handleSekiroRequest(event.data)        &#125;);        this.socket.onopen(function (event) &#123;            console.log(&#39;sekiro: open a sekiro client connection&#39;)        &#125;);        this.socket.onclose(function (event) &#123;            console.log(&#39;sekiro: disconnected ,reconnection after 2s&#39;);            setTimeout(function () &#123;                _this.connect()            &#125;, 2000)        &#125;);    &#125;;    SekiroClient.prototype.handleSekiroRequest = function (requestJson) &#123;        console.log(&quot;receive sekiro request: &quot; + requestJson);        var request = JSON.parse(requestJson);        var seq = request[&#39;__sekiro_seq__&#39;];        if (!request[&#39;action&#39;]) &#123;            this.sendFailed(seq, &#39;need request param &#123;action&#125;&#39;);            return        &#125;        var action = request[&#39;action&#39;];        if (!this.handlers[action]) &#123;            this.sendFailed(seq, &#39;no action handler: &#39; + action + &#39; defined&#39;);            return        &#125;        var theHandler = this.handlers[action];        var _this = this;        try &#123;            theHandler(request, function (response) &#123;                try &#123;                    _this.sendSuccess(seq, response)                &#125; catch (e) &#123;                    _this.sendFailed(seq, &quot;e:&quot; + e);                &#125;            &#125;, function (errorMessage) &#123;                _this.sendFailed(seq, errorMessage)            &#125;)        &#125; catch (e) &#123;            console.log(&quot;error: &quot; + e);            _this.sendFailed(seq, &quot;:&quot; + e);        &#125;    &#125;;    SekiroClient.prototype.sendSuccess = function (seq, response) &#123;        var responseJson;        if (typeof response == &#39;string&#39;) &#123;            try &#123;                responseJson = JSON.parse(response);            &#125; catch (e) &#123;                responseJson = &#123;&#125;;                responseJson[&#39;data&#39;] = response;            &#125;        &#125; else if (typeof response == &#39;object&#39;) &#123;            responseJson = response;        &#125; else &#123;            responseJson = &#123;&#125;;            responseJson[&#39;data&#39;] = response;        &#125;        if (Array.isArray(responseJson)) &#123;            responseJson = &#123;                data: responseJson,                code: 0            &#125;        &#125;        if (responseJson[&#39;code&#39;]) &#123;            responseJson[&#39;code&#39;] = 0;        &#125; else if (responseJson[&#39;status&#39;]) &#123;            responseJson[&#39;status&#39;] = 0;        &#125; else &#123;            responseJson[&#39;status&#39;] = 0;        &#125;        responseJson[&#39;__sekiro_seq__&#39;] = seq;        var responseText = JSON.stringify(responseJson);        console.log(&quot;response :&quot; + responseText);        this.socket.send(responseText);    &#125;;    SekiroClient.prototype.sendFailed = function (seq, errorMessage) &#123;        if (typeof errorMessage != &#39;string&#39;) &#123;            errorMessage = JSON.stringify(errorMessage);        &#125;        var responseJson = &#123;&#125;;        responseJson[&#39;message&#39;] = errorMessage;        responseJson[&#39;status&#39;] = -1;        responseJson[&#39;__sekiro_seq__&#39;] = seq;        var responseText = JSON.stringify(responseJson);        console.log(&quot;sekiro: response :&quot; + responseText);        this.socket.send(responseText)    &#125;;    SekiroClient.prototype.registerAction = function (action, handler) &#123;        if (typeof action !== &#39;string&#39;) &#123;            throw new Error(&quot;an action must be string&quot;);        &#125;        if (typeof handler !== &#39;function&#39;) &#123;            throw new Error(&quot;a handler must be function&quot;);        &#125;        console.log(&quot;sekiro: register action: &quot; + action);        this.handlers[action] = handler;        return this;    &#125;;    function guid() &#123;        function S4() &#123;            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);        &#125;        return (S4() + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + S4() + S4());    &#125;    var client = new SekiroClient(&quot;ws://127.0.0.1:5620/business-demo/register?group=rpc-test&amp;clientId=&quot; + guid());    client.registerAction(&quot;getH5fingerprint&quot;, function (request, resolve, reject) &#123;        resolve(utility.getH5fingerprint(request[&quot;url&quot;]));    &#125;)&#125;)();</code></pre><p>与前面的方法一样，使用浏览器开发者工具 Overrides 重写功能，将上面的代码注入到网页 JS 里：</p><p><img src="https://img-blog.csdnimg.cn/608ac74417ac4010be5ae64bc986e926.png" alt="07"></p><p>然后 Sekiro 为我们提供了一些 API：</p><ul><li>查看分组列表：<a href="http://127.0.0.1:5620/business-demo/groupList">http://127.0.0.1:5620/business-demo/groupList</a></li><li>查看队列状态：<a href="http://127.0.0.1:5620/business-demo/clientQueue?group=test">http://127.0.0.1:5620/business-demo/clientQueue?group=test</a></li><li>调用转发：<a href="http://127.0.0.1:5620/business-demo/invoke?group=test&amp;action=test&amp;param=testparm">http://127.0.0.1:5620/business-demo/invoke?group=test&amp;action=test&amp;param=testparm</a></li></ul><p>比如我们现在要调用 <code>utility.getH5fingerprint()</code> 加密方法该怎么办呢？很简单，代码注入到浏览器里后，首先还是要手动登录一遍，手动登录一遍，手动登录一遍，重要的事情说三遍！然后参考上面的调用转发 API 进行改写：</p><ul><li>我们自定义的分组 <code>group</code> 是 <code>rpc-test</code>；</li><li>事件 <code>action</code> 是 <code>getH5fingerprint</code>；</li><li>待加密参数名称为 <code>url</code>， 其值例如为：<code>https://www.baidu.com/</code></li></ul><p>那么我们的调用链接就应该是：<code>http://127.0.0.1:5620/business-demo/invoke?group=rpc-test&amp;action=getH5fingerprint&amp;url=https://www.baidu.com/</code>，直接浏览器打开，返回的字典，data 里面就是加密结果：</p><p><img src="https://img-blog.csdnimg.cn/44e52ae1fd9a4c118f543ff63b1c0537.png" alt="08"></p><p>同样的，在本地用 Python 的话，直接 requests 就完事儿了：</p><p><img src="https://img-blog.csdnimg.cn/4e81520df896457b959c61534ade9103.png" alt="09"></p><p>我们前面是把 sekiro_web_client.js 复制下来和通信代码一起注入到浏览器的，这里我们还可以有更加优雅的方法，直接给 document 新创建一个 script，通过链接的形式插入 sekiro_web_client.js，这里需要注意一下几点问题：</p><ol><li>第一个是时机的问题，需要等待 document 这些元素加载完成才能建立 SekiroClient 通信，不然调用 SekiroClient 是会报错的，这里可以用 setTimeout 方法，该方法用于在指定的毫秒数后调用函数或计算表达式，将 SekiroClient 通信代码单独封装成一个函数，比如 <code>function startSekiro()</code>，然后等待 1-2 秒后再执行 SekiroClient 通信代码；</li><li>由于 SekiroClient 通信代码被封装成了函数，此时直接调用 <code>utility.getH5fingerprint</code> 是会提示未定义的，所以我们要先将其导为全局变量，比如 <code>window.getH5fingerprint = utility.getH5fingerprint</code>，后续直接调用 <code>window.getH5fingerprint</code> 即可。</li></ol><p>完整代码如下所示：</p><pre><code class="javascript">/* ==================================# @Time    : 2022-02-14# @Author  : ITBOB# @FileName: sekiro.js# @Software: PyCharm# ================================== */(function () &#123;    var newElement = document.createElement(&quot;script&quot;);    newElement.setAttribute(&quot;type&quot;, &quot;text/javascript&quot;);    newElement.setAttribute(&quot;src&quot;, &quot;https://sekiro.virjar.com/sekiro-doc/assets/sekiro_web_client.js&quot;);    document.body.appendChild(newElement);    window.getH5fingerprint = utility.getH5fingerprint    function guid() &#123;        function S4() &#123;            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);        &#125;        return (S4() + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + S4() + S4());    &#125;    function startSekiro() &#123;        var client = new SekiroClient(&quot;ws://127.0.0.1:5620/business-demo/register?group=rpc-test&amp;clientId=&quot; + guid());        client.registerAction(&quot;getH5fingerprint&quot;, function (request, resolve, reject) &#123;            resolve(window.getH5fingerprint(request[&quot;url&quot;]));        &#125;)    &#125;    setTimeout(startSekiro, 2000)&#125;)();</code></pre><p><img src="https://img-blog.csdnimg.cn/5657c3efd68048b59db91794a8b9c9c4.png" alt="10"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>目前如果不去逆向 JS 来实现加密参数的话，用得最多的就是自动化工具了，比如 Selenium、Puppeteer 等，很显然这些自动化工具配置繁琐、运行效率极低，而 RPC 技术不需要加载多余的资源，稳定性和效率明显都更高，RPC 不需要考虑浏览器指纹、各种环境，如果风控不严的话，高并发也是能够轻松实现的，相反，由于 RPC 是一直挂载在同一个浏览器上的，所以针对风控较严格的站点，比如检测 UA、IP 与加密参数绑定之类的，那么 PRC 调用太频繁就不太行了，当然也可以研究研究浏览器群控技术，操纵多个不同浏览器可以一定程度上缓解这个问题。总之 RPC 技术还是非常牛的，除了 JS 逆向，可以说是目前比较万能、高效的方法了，一定程度上做到了加密参数一把梭！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是-RPC&quot;&gt;&lt;a href=&quot;#什么是-RPC&quot; class=&quot;headerlink&quot; title=&quot;什么是 RPC&quot;&gt;&lt;/a&gt;什么是 RPC&lt;/h2&gt;&lt;p&gt;&lt;del&gt;RPC，英文 RangPaCong，中文让爬虫，旨在为爬虫开路，秒杀一切，让爬虫畅通无阻！</summary>
      
    
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91/"/>
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="RPC" scheme="https://www.itbob.cn/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>【JS 逆向】吾爱破解2022春节解题领红包之番外篇 Web 中级题解</title>
    <link href="https://www.itbob.cn/article/046/"/>
    <id>https://www.itbob.cn/article/046/</id>
    <published>2022-02-17T00:43:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逆向目标"><a href="#逆向目标" class="headerlink" title="逆向目标"></a>逆向目标</h2><p>本次逆向的目标来源于吾爱破解 2022 春节解题领红包之番外篇 Web 中级题，吾爱破解每年都会有派送红包活动（送吾爱币），需要大家使出看家逆向本领来分析内容获得口令红包，今年一共有五个题，一个送分题，两个 Windows 题、一个 Android 题和一个 Web 题，本文分析的正是  Web 题，<strong>吾爱有规定活动结束前不要外泄口令、讨论分享分析过程，所以本文在活动结束后才发出来。</strong></p><p>此 Web 题题目是：小 D 最爱看的视频网站最近关站了，关站前他用 Fiddler 和 Web Archive 保存了一位主播的视频，但他发现存下来的文件无法播放。你能帮小 D 找回他的回忆吗？（.saz 与 .wacz 任选其一即可解题）</p><ul><li><p>活动地址：<a href="https://www.52pojie.cn/thread-1582582-1-1.html">https://www.52pojie.cn/thread-1582582-1-1.html</a></p></li><li><p>Web 题地址：<a href="https://www.52pojie.cn/home.php?mod=task&amp;do=view&amp;id=17">https://www.52pojie.cn/home.php?mod=task&amp;do=view&amp;id=17</a></p></li></ul><h2 id="HLS-流媒体传输协议"><a href="#HLS-流媒体传输协议" class="headerlink" title="HLS 流媒体传输协议"></a>HLS 流媒体传输协议</h2><p>本题涉及到 HLS 流媒体传输协议，先简单介绍一下，了解的同志可直接跳过。</p><p>HLS 全称 HTTP Live Streaming，即基于 HTTP 的自适应码率流媒体传输协议，是苹果研发的动态码率自适应技术，它包括一个 M3U(8) 的索引文件，若干 TS 视频流文件，如果视频流文件是加密的，那就还会存在一个 key 加密串文件。</p><p>M3U8 文件是 M3U 的一种，只不过文件中存储的文本使用 UTF-8 字符编码，在极少数情况下，M3U8 文件可能会以 M3UP 扩展名保存。M3U8 文件是各种音频和视频播放程序使用的播放列表文件，它包含了媒体文件或媒体文件夹的路径或 URL，以及有关播放列表的相关信息。</p><p>TS 全称为 MPEG2-TS，TS 即 Transport Stream 传输流，又称 MPEG-TS、MTS、TP，这种格式的特点就是从视频流的任一片段开始都是可以独立解码的。</p><p>针对 TS 格式的文件，如果是未加密的，一般的播放器就能够直接播放，也可以使用 FFmpeg 等工具转换为其他格式，FFmpeg 也可以直接处理 M3U8 文件，自动解密合并转换 TS 文件，当然也有其他大佬写好的小工具，拖入 M3U8 文件就直接给你处理好了。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/04101c9e3b5b32d096045bf6be06f40a.png" alt="01"></p><p>M3U8 文件内容的大致格式示例如下：</p><pre><code>#EXTM3U#EXT-X-VERSION:3#EXT-X-MEDIA-SEQUENCE:0#EXT-X-ALLOW-CACHE:YES#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://www.example.com/m3u8.key&quot;#EXT-X-TARGETDURATION:5#EXTINF:4.200000,https://www.example.com/hls/live_00000.ts#EXTINF:4.166667,https://www.example.com/hls/live_00001.ts#EXTINF:3.600000,https://www.example.com/hls/live_00002.ts#EXTINF:2.516667,https://www.example.com/hls/live_00003.ts#EXTINF:4.166667,https://www.example.com/hls/live_00004.ts#EXTINF:4.166667,https://www.example.com/hls/live_00005.ts#EXTINF:4.166667,https://www.example.com/hls/live_00006.ts#EXTINF:1.716667,https://www.example.com/hls/live_00007.ts#EXT-X-ENDLIST</code></pre><p>各标签含义如下：</p><ul><li><code>#EXTM3U</code>：m3u文件头，必须放在第一行，起标示作用；</li><li><code>#EXT-X-VERSION</code>：播放列表文件的兼容版本。若不存在此标记，则默认为协议的第一个版本；</li><li><code>#EXT-X-MEDIA-SEQUENCE</code>： 播放列表中的每个媒体 URI 都有一个唯一的整数序列号。URI 的序列号等于它之前的 URI 的序列号加一；</li><li><code>#EXT-X-ALLOW-CACHE</code>：指示客户端是否可以缓存下载的媒体片段以供以后重播；</li><li><code>#EXT-X-KEY</code>：TS 片段可以被加密，该标签指定加密方式（METHOD）、密钥的 URI 以及偏移量 IV 等信息，没有此标签表示未加密；</li><li><code>#EXT-X-TARGETDURATION</code>：每一份 TS 媒体文件的最大持续时间，以秒为单位；</li><li><code>#EXTINF</code>：每一份媒体文件的详细信息，包括媒体持续时间、媒体 URL 地址等；</li><li><code>#EXT-X-ENDLIST</code>：表示不再将媒体片段添加到播放列表文件中，一般位于文件结尾。</li></ul><p>完整格式、标准标签可参考 HLS 标准协议中，对 Playlist file 的介绍：<a href="https://datatracker.ietf.org/doc/html/draft-pantos-http-live-streaming-08">https://datatracker.ietf.org/doc/html/draft-pantos-http-live-streaming-08</a></p><h2 id="SAZ-分析"><a href="#SAZ-分析" class="headerlink" title="SAZ 分析"></a>SAZ 分析</h2><p>在 Fiddler 软件中，使用 SAZ 格式用来保存和读取 HTTP/HTTPS 请求信息，打开该文件可以注意到一些重要的请求：script.bundle.js、live.m3u8、drm 以及八个 ts 视频流文件。</p><p>先来看看 m3u8 文件，可以看到是 AES-128 加密，加密的 key 文件地址为 <code>key://live</code>，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/082996c240d55cb83e787c489961d98b.png" alt="02.png"></p><p>一般情况下，要想解密 ts，必然会去请求 key 的地址，拿到 key 后再解密 ts，很显然此题的 key 地址不是一个合法的 URL 地址，当然此题的抓包记录可能是出题人伪造的，因为这个 Host 是 52tube.mmxxii，也不是一个合法的域名，最主要的是，抓包记录里没有 <code>key://live</code> 这条请求，那么很大概率真实的地址隐藏在 JS 里，从另一个方面来思考，如果这是完整的抓包记录，不管真实的 key 地址是啥，必然会在记录里出现！</p><p>有经验的朋友应该一眼就能看出来 drm 这条请求最有可能是拿 key 的操作了，第一是 drm 这个关键词在 ts 解密里经常会出现，搞得多的朋友应该见过不少，第二 ping 请求返回的 success，通过其名称和返回值来看也不像 key，剩下就只有 drm 了，查看返回值是乱码的，查看 Hex 值，32 位 16 进制数据，而正常的 key 应该是 16 位 16 进制数据，所以你如果直接拿这个数据当作 key 去解密，肯定也是失败的。</p><p>到这里我们应该有如下猜想：drm 返回的数据，经过了 script.bundle.js 二次处理就能得到正确的 key。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2bbab0520ed00218eebede697b3ab165.png" alt="03"></p><h2 id="JS-逆向"><a href="#JS-逆向" class="headerlink" title="JS 逆向"></a>JS 逆向</h2><p>我们把抓包记录的 script.bundle.js，右键，save - response - response body，保存到本地。</p><p>格式化之后有 15000+ 行代码，又不能动态调试，从哪里找加密入口呢？可以大胆尝试一下：</p><ul><li>JS 里可能会检测到 m3u8 里存在 key 的 URI 之后，发送 /api/drm/ 这个请求，可以直接搜索 <code>/api/drm/</code> 或者 <code>key://live</code> 定位；</li><li>drm 是一个 post 请求，带有 h 和 id 两个参数，可以直接搜索 <code>post</code>、<code>id</code>、<code>h</code> 定位到大致位置。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/ed46b7c9427b23de1fca4ce85d46f1f5.png" alt="04"></p><p>通过搜索可以发现如下可疑代码片段：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2dd7603630340ef2fd14cace1e7fc58e.png" alt="05"></p><p>将关键代码提炼一下：</p><pre><code class="javascript">function n(t) &#123;    return [...new Uint8Array(t)].map((t =&gt; t.toString(16).padStart(2, &quot;0&quot;))).join(&quot;&quot;)&#125;function s(t, e) &#123;    let r = new Uint8Array(t.length);    for (let i = 0; i &lt; t.length; i++) r[i] = t[i] ^ e[i];    return r&#125;let e = &quot;/api/ping/&quot;,    i = &quot;/api/drm/&quot;;class a extends t.DefaultConfig.loader &#123;    let e = await async function() &#123;        let t = new Uint8Array(16);        crypto.getRandomValues(t);        let e = n(t.buffer) + Date.now() + Math.random();        return new Uint8Array((await async function(t) &#123;            const e = (new TextEncoder).encode(t);            return await crypto.subtle.digest(&quot;SHA-256&quot;, e)        &#125; (e)).slice(0, 16))    &#125;();    var r = new URLSearchParams;    r.append(&quot;h&quot;, n(e.buffer)),        r.append(&quot;id&quot;, t);    var a = &#123;        method: &quot;POST&quot;,        headers: &#123;            &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;        &#125;,        body: r    &#125;;    let o = await fetch(i, a),        l = await o.arrayBuffer();    if (32 !== l.byteLength) throw new Error(&quot;Invalid response&quot;);    let u = new Uint8Array(l.slice(0, 16)),        c = new Uint8Array(l.slice(16, 32));    return s(s(u, e), c)&#125;</code></pre><p>可以看到事实上在发送 <code>/api/drm/</code> 请求拿到结果后，先后取前后 16 位数据，然后经过了 s 方法的处理，最后返回的 <code>s(s(u, e), c)</code> 应该才是正确的 key，这里的重点在于 e 的值，上面有个方法，取了当前时间+随机值，经过 SHA-256 加密，再取前 16 位。</p><p>这里可以思考一下，这个 e 的值是不固定的，那么最后的 key 应该也是不固定的，同一个 TS 对应有无数个 key，我反正是没见过，不信的话尝试就用那个方法生成 e，你会发现最终的 key 是错误的。</p><p>仔细看一下，发送 post 请求对 h 值赋值的地方：<code>r.append(&quot;h&quot;, n(e.buffer))</code>，n 方法是转 16 进制，那么我们直接将 h 值倒推，从16进制转为10进制，这才是正确的 e 的值！然后 l 的值是 <code>/api/drm/</code> 请求返回的 32 位 16 进制数据转为 10 进制，剩下的就好说了，直接改写一下 JS 代码拿到正确的 key：</p><pre><code class="javascript">function s(t, e) &#123;    let r = new Uint8Array(t.length);    for (let i = 0; i &lt; t.length; i++)        r[i] = t[i] ^ e[i];    return r&#125;function getKey()&#123;    // /api/drm/ 请求表单的 h 值，16进制数据    const h = [&quot;7b&quot;, &quot;10&quot;, &quot;31&quot;, &quot;1e&quot;, &quot;6e&quot;, &quot;31&quot;, &quot;0f&quot;, &quot;0d&quot;, &quot;f0&quot;, &quot;68&quot;, &quot;d9&quot;, &quot;ed&quot;, &quot;e1&quot;, &quot;04&quot;, &quot;75&quot;, &quot;a8&quot;];    // /api/drm/ 请求返回的32位16进制数据    const drm = [&quot;08&quot;, &quot;A5&quot;, &quot;E6&quot;, &quot;C2&quot;, &quot;C2&quot;, &quot;61&quot;, &quot;A8&quot;, &quot;AC&quot;, &quot;B4&quot;, &quot;D7&quot;, &quot;9C&quot;, &quot;49&quot;, &quot;AF&quot;, &quot;16&quot;, &quot;0A&quot;, &quot;3A&quot;, &quot;DA&quot;, &quot;4E&quot;, &quot;5C&quot;, &quot;EA&quot;, &quot;E1&quot;, &quot;6F&quot;, &quot;ED&quot;, &quot;46&quot;, &quot;EB&quot;, &quot;6F&quot;, &quot;49&quot;, &quot;8C&quot;, &quot;9B&quot;, &quot;63&quot;, &quot;D5&quot;, &quot;3B&quot;]    // 转换为10进制数据，为 e 和 l 赋值    const e = [];    const l = [];    for (let i=0; i&lt;h.length; i++)    &#123;        e.push(parseInt(h[i],16))    &#125;    for (let i=0; i&lt;drm.length; i++)    &#123;        l.push(parseInt(drm[i],16))    &#125;    const u = new Uint8Array(l.slice(0, 16));    const c = new Uint8Array(l.slice(16, 32));    const keyArray = s(s(u, e), c);    const keyHex = new Buffer.from(keyArray).toString(&#39;hex&#39;);    const keyBase64 = new Buffer.from(keyArray).toString(&#39;base64&#39;);    console.log(&quot;keyArray: &quot;, keyArray)    console.log(&quot;keyHex: &quot;, keyHex)    console.log(&quot;keyBase64: &quot;, keyBase64)&#125;getKey()// 输出// keyArray:  Uint8Array(16) [//   169, 251, 139,  54,  77,//    63,  74, 231, 175, 208,//    12,  40, 213, 113, 170,//   169// ]// keyHex:  a9fb8b364d3f4ae7afd00c28d571aaa9// keyBase64:  qfuLNk0/Suev0Awo1XGqqQ==</code></pre><h2 id="TS-解密合并转换"><a href="#TS-解密合并转换" class="headerlink" title="TS 解密合并转换"></a>TS 解密合并转换</h2><p>通过 JS 逆向我们拿到了 16进制和 base64 形式的  key，不管什么形式都可以拿来解密，这里介绍两种对 TS 媒体流解密、合并、转换的方法。</p><p>第一种方法是使用 FFmpeg 工具，FFmpeg 是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。官网地址：<a href="https://ffmpeg.org/">https://ffmpeg.org/</a> ，下载编译好的程序，将 bin 目录添加到环境变量即可。</p><p>首先我们要把 m3u8 文件和 ts 媒体流保存到同一个文件夹，由于是虚假的 Host，所以不能直接浏览器访问保存，可以直接在 Fiddler 里，右键，save - response - response body，保存到本地，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/749cfe83e0a6e2fc1abc53d6f014af20.png" alt="06"></p><p>然后就是保存密钥文件，这里要求密钥文件必须是16进制的数据，如果你直接将 key 以字符串形式保存的话，解密也是失败的，编辑 16 进制文件有专门的工具，比如 HxD、010 editor、winhex 等，以 HxD 为例，新建文件，写入我们前面通过 JS 逆向得到的 key 的 16 进制数据，存为 .key 文件，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c967091a3fe77ae7e1431d7611b724aa.png" alt="07"></p><p>然后修改 m3u8 文件里 key 的地址、名称，建议将 key、m3u8、ts 文件都放同一个文件夹，这样 m3u8 文件里就不用添加资源路径了，不容易出错。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bc34af23050758b3b320b24f057bdfb9.png" alt="08"></p><p>然后在当前文件夹，打开命令行输入命令：<code>ffmpeg -allowed_extensions ALL -i live.m3u8 -c copy live.mp4</code>，即可自动解密 ts，并合并转换为 .mp4 格式：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0a7a0cf737aeae4d01bc9217e07c60f1.png" alt="09"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/db9fdff0a45c6d41333c6d475a12ae08.png" alt="10"></p><p>第二种方法就是使用大佬写的第三方小工具，这里推荐吾爱大佬逍遥一仙写的 M3U8 批量下载器，下载地址、使用方法见原贴：<a href="https://www.52pojie.cn/thread-1374045-1-1.html">https://www.52pojie.cn/thread-1374045-1-1.html</a></p><p>我们可以直接拖入处理好的 M3U8 文件，自动处理：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/985f2c1a952e14b41d264c5e172092be.png" alt="11"></p><p>也可以选择其他 - 工具 - 合并助手，添加所有 TS 文件，输入 key 后自动处理：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/71c5a02310dcc053f385d80116196775.png" alt="12"></p><p>处理完毕后的 mp4 文件默认在软件目录的 output 文件夹里面，解密后是一段动画，往后看会找到 flag：<code>flag&#123;like_sub_52tube&#125;</code> 为正确答案。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/270c7e60d56bc2ea20a33f11c1eb042f.png" alt="13"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/362caaedb5b649cfd650aefd326ae615.png" alt="14"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4dd28112ed306fd0ba26f946f8531891.png" alt="15"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;逆向目标&quot;&gt;&lt;a href=&quot;#逆向目标&quot; class=&quot;headerlink&quot; title=&quot;逆向目标&quot;&gt;&lt;/a&gt;逆向目标&lt;/h2&gt;&lt;p&gt;本次逆向的目标来源于吾爱破解 2022 春节解题领红包之番外篇 Web 中级题，吾爱破解每年都会有派送红包活动（送吾爱币），</summary>
      
    
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91/"/>
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>CTF&amp;爬虫：掌握这些特征，一秒识别密文加密方式</title>
    <link href="https://www.itbob.cn/article/045/"/>
    <id>https://www.itbob.cn/article/045/</id>
    <published>2022-01-13T09:40:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>爬虫工程师在做加密参数逆向的时候，经常会遇到各种各样的加密算法、编码、混淆，每个算法都有其对应的特征，对于一些较小的网站，往往直接引用这些官方算法，没有进行魔改等其他操作，这种情况下，如果我们能熟悉常见算法的特征，通过密文就能猜测出使用的哪种算法、编码、混淆，将会大大提高工作效率！在 CTF 中通常也会有密码类的题目，掌握一些常见密文特征也是 CTFer 们必备的技能！</p><p>本文将介绍以下编码和加密算法的特征：</p><ul><li>编码：Base 系列、Unicode、Escape、URL、Hex；</li><li>算法：MD5、SHA 系列、HMAC 系列、RSA、AES、DES、3DES、RC4、Rabbit、SM 系列；</li><li>混淆：Obfuscator、JJEncode、AAEncode、JSFuck、Jother、Brainfuck、Ook!、Trivial brainfuck substitution；</li><li>其他：恺撒密码、栅栏密码、猪圈密码、摩斯密码、培根密码、维吉尼亚密码、与佛论禅、当铺密码。</li></ul><p>PS：常见加密算法原理以及在 Python 和 JavaScript 中的实现方法可参见以前的文章：<a href="https://www.itbob.cn/article/039/">爬虫常见加密解密算法总结</a></p><h2 id="编码系列"><a href="#编码系列" class="headerlink" title="编码系列"></a>编码系列</h2><h3 id="Base-系列编码"><a href="#Base-系列编码" class="headerlink" title="Base 系列编码"></a>Base 系列编码</h3><p>Base64 是我们最常见的编码，除此之外，其实还有 Base16、Base32、Base58、Base85、Base100 等，他们之间最明显的区别就是使用了不同数量的可打印字符对任意字节数据进行编码，比如 Base64 使用了64个可打印字符（A-Z、a-z、0-9、+、/），Base16 使用了16个可打印字符（A-F、0-9），这里主要讲怎么快速识别，其具体原理可自行百度，Base 系列主要特征如下：</p><ul><li>Base16：结尾没有等号，数字要多于字母；</li><li>Base32：字母要多于数字，明文数量超过10个，结尾可能会有很多等号；</li><li>Base58：结尾没有等号，字母要多于数字；</li><li>Base64：一般情况下结尾都会有1个或者2个等号，明文很少的时候可能没有；</li><li>Base85：等号一般出现在字符串中间，含有一些奇怪的字符；</li><li>Base100：密文由 Emoji 表情组成。</li></ul><p>示例：</p><table><thead><tr><th align="left">编码类型</th><th align="left">示例一</th><th>示例二</th></tr></thead><tbody><tr><td align="left">明文</td><td align="left">01234567890</td><td>administrators</td></tr><tr><td align="left">Base16</td><td align="left"><code>3031323334353637383930</code></td><td><code>61646D696E6973747261746F7273</code></td></tr><tr><td align="left">Base32</td><td align="left"><code>GAYTEMZUGU3DOOBZGA======</code></td><td><code>MFSG22LONFZXI4TBORXXE4Y=</code></td></tr><tr><td align="left">Base58</td><td align="left"><code>cX8j8pvGzppMKVb</code></td><td><code>BNF5dFLUTN5XwM1yLoF</code></td></tr><tr><td align="left">Base64</td><td align="left"><code>MDEyMzQ1Njc4OTA=</code></td><td><code>YWRtaW5pc3RyYXRvcnM=</code></td></tr><tr><td align="left">Base85</td><td align="left"><code>0JP==1c70M3&amp;rY</code></td><td><code>@:X4hDJ=06Eaa&#39;.EcV</code></td></tr><tr><td align="left">Base100</td><td align="left"><code>🐧🐨🐩🐪🐫🐬🐭🐮🐯🐰🐧</code></td><td><code>👘👛👤👠👥👠👪👫👩👘👫👦👩👪</code></td></tr></tbody></table><h3 id="Unicode-编码"><a href="#Unicode-编码" class="headerlink" title="Unicode 编码"></a>Unicode 编码</h3><p>Unicode 又称为统一码、万国码、单一码，是一种在计算机上使用的字符编码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。其主要特征如下：</p><ul><li>以 <code>\u</code>、<code>&amp;#</code> 或 <code>&amp;#x</code> 开头，后面是数字加字母组合</li></ul><p>PS：<code>\u</code> 开头和 <code>&amp;#x</code> 开头是一样的，都是16进制 Unicode 字符的不同写法，<code>&amp;#</code> 则是 Unicode 字符10进制的写法，此外，<code>&amp;#</code> 和 <code>&amp;#x</code> 开头的，也称为 HTML 字符实体转换，字符实体是用一个编号写入 HTML 代码中来代替一个字符，在 HTML 中，某些字符是预留的，如果希望正确地显示预留字符，就必须在 HTML 源代码中使用字符实体。</p><table><thead><tr><th>编码类型</th><th>示例一</th><th>示例二</th></tr></thead><tbody><tr><td>明文</td><td>12345</td><td>admin</td></tr><tr><td>Unicode</td><td><code>\u0031\u0032\u0033\u0034\u0035</code></td><td><code>\u0061\u0064\u006d\u0069\u006e</code></td></tr></tbody></table><h3 id="Escape-编码"><a href="#Escape-编码" class="headerlink" title="Escape 编码"></a>Escape 编码</h3><p>Escape 编码又叫 %u 编码，Escape 编码就是字符对应 UTF-16BE 表示方式前面加 %u，Escape 不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： <code>* @ - _ + . / </code>，其他所有的字符都会被转义序列替换。其主要特征如下：</p><ul><li>以 <code>%u</code> 开头，后面是数字加字母组合</li></ul><table><thead><tr><th>编码类型</th><th>示例一</th><th>示例二</th></tr></thead><tbody><tr><td>明文</td><td>爬虫</td><td>我爱Python</td></tr><tr><td>Escape</td><td><code>%u722C%u866B</code></td><td><code>%u6211%u7231Python</code></td></tr></tbody></table><h3 id="URL-Hex-编码"><a href="#URL-Hex-编码" class="headerlink" title="URL / Hex 编码"></a>URL / Hex 编码</h3><p>URL 和 Hex 编码的结果是一样的，不同的是当你用 URL 编码网址时是不会把 <code>http</code>、<code>https</code> 关键字和 <code>/</code>、<code>?</code>、<code>&amp;</code>、<code>=</code> 等连接符进行编码的，而 Hex 编码则全部转化了，其主要特征如下：</p><ul><li>以 <code>%</code> 开头，后面是数字加字母组合</li></ul><table><thead><tr><th>编码类型</th><th>示例</th></tr></thead><tbody><tr><td>明文</td><td><a href="https://www.kuaidaili.com/">https://www.kuaidaili.com/</a></td></tr><tr><td>Unicode</td><td><code>https://%77%77%77%2E%6B%75%61%69%64%61%69%6C%69%2E%63%6F%6D/</code></td></tr><tr><td>Hex</td><td><code>%68%74%74%70%73%3a%2f%2f%77%77%77%2e%6b%75%61%69%64%61%69%6c%69%2e%63%6f%6d%2f</code></td></tr></tbody></table><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p>MD5 实质是一种消息摘要算法，一个数据的 MD5 值是唯一的，同一个数据不可能计算出多个不同的 MD5 值，但是，不同数据计算出来的 MD5 值是有可能一样的，知道一个 MD5 值，理论上是无法还原出它的原始数据的，MD5 是最容易辨别的，主要特征如下：</p><ul><li>密文一般为 16 位或者 32 位，其中 16 位是取的 32 位第 9~25 位的值；</li><li>组成方式为字母（a-f）和数字（0-9）混合，字母可以全部是大写或者小写。</li></ul><p>除了通过密文特征来判断以外，我们还可以搜索源代码，标准 MD5 的源码里是包含了一些特定的值的，没有这些特定值，就无法实现 MD5：</p><ul><li><code>0123456789ABCDEF</code>、<code>0123456789abcdef</code></li><li><code>1732584193</code>、<code>-271733879</code>、<code>-1732584194</code>、<code>271733878</code></li></ul><p>PS：某些特殊情况下，密文的长度也有可能不止 16 位或者 32 位，有可能是在官方算法上有一些魔改，通常也是在 16 位的基础上，左右填充了一些随机字符串。</p><p>示例：</p><table><thead><tr><th>编码类型</th><th>示例一</th><th>示例二</th></tr></thead><tbody><tr><td>明文</td><td>123456</td><td>admin</td></tr><tr><td>MD5（16位小写）</td><td><code>49ba59abbe56e057</code></td><td><code>7a57a5a743894a0e</code></td></tr><tr><td>MD5（16位大写）</td><td><code>49BA59ABBE56E057</code></td><td><code>7A57A5A743894A0E</code></td></tr><tr><td>MD5（32位小写）</td><td><code>e10adc3949ba59abbe56e057f20f883e</code></td><td><code>21232f297a57a5a743894a0e4a801fc3</code></td></tr><tr><td>MD5（32位大写）</td><td><code>E10ADC3949BA59ABBE56E057F20F883E</code></td><td><code>21232F297A57A5A743894A0E4A801FC3</code></td></tr></tbody></table><h3 id="SHA-系列"><a href="#SHA-系列" class="headerlink" title="SHA 系列"></a>SHA 系列</h3><p>SHA 是比 MD5 更安全一点的摘要算法，SHA 通常指 SHA 家族算法，分别是 SHA-1、SHA-2、SHA-3，其中 SHA-2 是 SHA-224、SHA-256、SHA-384、SHA-512 的并称，SHA-3 是 SHA3-224、SHA3-256、SHA3-384、SHA3-512、SHAKE128、SHAKE256 的并称，其名字的后缀的数字就代表了结果的大小（bit），注意，SHAKE 算法结果的大小并不是固定的，其他算法特征如下：</p><ul><li>SHA-1：字母（a-f）和数字（0-9）混合，固定位数 40 位；</li><li>SHA-224/SHA3-224：字母（a-f）和数字（0-9）混合，固定位数 56 位；</li><li>SHA-256/SHA3-256：字母（a-f）和数字（0-9）混合，固定位数 64 位；</li><li>SHA-384/SHA3-384：字母（a-f）和数字（0-9）混合，固定位数 96 位；</li><li>SHA-512/SHA3-512：字母（a-f）和数字（0-9）混合，固定位数 128 位。</li></ul><p>示例：</p><table><thead><tr><th>编码类型</th><th>示例</th></tr></thead><tbody><tr><td>明文</td><td>123456</td></tr><tr><td>SHA-1</td><td><code>7c4a8d09ca3762af61e59520943dc26494f8941b</code></td></tr><tr><td>SHA-256</td><td><code>8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92</code></td></tr><tr><td>SHA3-256</td><td><code>c888c9ce9e098d5864d3ded6ebcc140a12142263bace3a23a36f9905f12bd64a</code></td></tr></tbody></table><h3 id="HMAC-系列"><a href="#HMAC-系列" class="headerlink" title="HMAC 系列"></a>HMAC 系列</h3><p>HMAC 这种算法就是在 MD5、SHA 两种加密的基础上引入了秘钥，其密文也和 MD5、SHA 类似，密文的长度和使用的 MD5、SHA 算法对应密文的长度是一样的。特征如下：</p><ul><li>HMAC-MD5：字母（a-f）和数字（0-9）混合，位数一般为 32 位；</li><li>HMAC-SHA-1：字母（a-f）和数字（0-9）混合，固定位数 40 位；</li><li>HMAC-SHA-224 / HMAC-SHA3-224：字母（a-f）和数字（0-9）混合，固定位数 56 位；</li><li>HMAC-SHA-256 / HMAC-SHA3-256：字母（a-f）和数字（0-9）混合，固定位数 64 位；</li><li>HMAC-SHA-384 / HMAC-SHA3-384：字母（a-f）和数字（0-9）混合，固定位数 96 位；</li><li>HMAC-SHA-512 / HMAC-SHA3-512：字母（a-f）和数字（0-9）混合，固定位数 128 位。</li></ul><p>HMAC 和 SHA、MD5 的密文都很像，当无法确定是否为 HMAC 时，可以通过其名称搜索到加密方法，如果传入了密钥 key，说明就是 HMAC，当然你也可以直接当做是 SHA 或 MD5 来解，解密失败时就得考虑是否有密钥，是否为 HMAC 了，在 JS 中，通常一个 HMAC 加密方法是这样写的：</p><pre><code class="javascript">function HmacSHA1Encrypt(word, key) &#123;    return CryptoJS.HmacSHA1(word, key).toString();&#125;</code></pre><p>示例（密钥 123456abcde）：</p><table><thead><tr><th>编码类型</th><th>示例</th></tr></thead><tbody><tr><td>明文</td><td>123456</td></tr><tr><td>HMAC-MD5</td><td><code>432bb95bb00005ddce4a1c757488ed95</code></td></tr><tr><td>HMAC-SHA-1</td><td><code>37a04076b7736c44460d330ee0d00014428b175e</code></td></tr><tr><td>HMAC-SHA-256</td><td><code>50cb1345366df11140fb91b43caaf69627e3f5529705ddf6b0d0cae67986e585</code></td></tr><tr><td>HMAC-SHA3-256</td><td><code>b808ed9f66436e89fba527a01d1d6044318fea8599d9f39bfb6bec4843964bf3</code></td></tr></tbody></table><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>RSA 加密算法是一种非对称加密算法，通过公钥加密结果，必须私钥解密。 同样私钥加密结果，公钥可以解密，应用非常广泛，在网站中通常使用 JSEncrypt 库来实现，其最大的特征就是有一个设置公钥的过程，我们可以通过以下方法来快速初步判断是否为 RSA 算法：</p><ul><li><p>搜索关键词 <code>new JSEncrypt()</code>，<code>JSEncrypt</code> 等，一般会使用 JSEncrypt 库，会有 new 一个实例对象的操作；</p></li><li><p>搜索关键词 <code>setPublicKey</code>、<code>setKey</code>、<code>setPrivateKey</code>、<code>getPublicKey</code> 等，一般实现的代码里都含有设置密钥的过程；</p></li><li><p>RSA 的私钥、公钥、明文、密文长度也有一定对应关系，也可以从这方面初步判断：</p><table><thead><tr><th align="left">私钥长度（Base64）</th><th align="left">公钥长度（Base64）</th><th align="left">明文长度</th><th align="left">密文长度</th></tr></thead><tbody><tr><td align="left">428</td><td align="left">128</td><td align="left">1~53</td><td align="left">88</td></tr><tr><td align="left">812</td><td align="left">216</td><td align="left">1~117</td><td align="left">172</td></tr><tr><td align="left">1588</td><td align="left">392</td><td align="left">1~245</td><td align="left">344</td></tr></tbody></table></li></ul><h3 id="AES、DES、3DES、RC4、Rabbit-等"><a href="#AES、DES、3DES、RC4、Rabbit-等" class="headerlink" title="AES、DES、3DES、RC4、Rabbit 等"></a>AES、DES、3DES、RC4、Rabbit 等</h3><p>AES、DES、3DES、RC4、Rabbit 等加密算法的密文通常没有固定的长度，他们通常使用 crypto-js 来实现，比如 AES 加解密示例如下：</p><pre><code class="javascript">CryptoJS = require(&quot;crypto-js&quot;)var key = CryptoJS.enc.Utf8.parse(&quot;0123456789abcdef&quot;);var iv = CryptoJS.enc.Utf8.parse(&quot;0123456789abcdef&quot;);function AESEncrypt(word) &#123;    var srcs = CryptoJS.enc.Utf8.parse(word);    var encrypted = CryptoJS.AES.encrypt(srcs, key, &#123;        iv: iv,        mode: CryptoJS.mode.CBC,        padding: CryptoJS.pad.Pkcs7    &#125;);    return encrypted.toString();&#125;function AESDecrypt(word) &#123;    var srcs = word;    var decrypt = CryptoJS.AES.decrypt(srcs, key, &#123;        iv: iv,        mode: CryptoJS.mode.CBC,        padding: CryptoJS.pad.Pkcs7    &#125;);    return decrypt.toString(CryptoJS.enc.Utf8);&#125;console.log(AESEncrypt(&quot;K哥爬虫&quot;))console.log(AESDecrypt(&quot;nSk3wCd92s08sQ9N+VHNvA==&quot;))</code></pre><p>在 crypto-js 中，也有一些特定的关键字，我们可以通过搜索这些关键字来快速定位到 crypto-js：</p><ul><li><p><code>CryptoJS</code>、<code>crypto-js</code>、<code>iv</code>、<code>mode</code>、<code>padding</code>、<code>createEncryptor</code>、<code>createDecryptor</code></p></li><li><p><code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=</code>、<code>0xffffffff</code>、<code>0xffff</code></p></li></ul><p>定位到 CryptoJS 后，观察加密方法，比如 AES 就是 <code>CryptoJS.AES.encrypt</code>，DES 就是 <code>CryptoJS.DES.encrypt</code>，3DES 就是 <code>CryptoJS.TripleDES.encrypt</code>，注意他的 iv、mode、padding，拿下来就可以本地复现了。</p><h3 id="SM-系列"><a href="#SM-系列" class="headerlink" title="SM 系列"></a>SM 系列</h3><p>SM 代表商密，即商业密码，是我国发布的一系列国产加密算法，SM 系列包括：SM1、SM2、SM3 、SM4、SM7、SM9，其中 SM1 和 SM7 的算法不公开，SM 系列算法在我国一些 gov 网站上有应用，有关国产加密算法前期文章有介绍：<a href="https://www.itbob.cn/article/041/">《认识 SM1/SM2/SM3/SM4/SM7/SM9/ZUC 国密算法》</a>，本文不再赘述。</p><p>在 SM 的 JavaScript 代码中一般会存在以下关键字，可以通过搜索关键字定位：</p><ul><li><code>SM2</code>、<code>SM3</code>、<code>SM4</code></li><li><code>FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF</code></li><li><code>FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC</code></li><li><code>28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93</code></li><li><code>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789</code></li><li><code>getPublicKeyFromPrivateKey</code>、<code>doEncrypt</code>、<code>doDecrypt</code>、<code>doSignature</code></li></ul><h2 id="混淆系列"><a href="#混淆系列" class="headerlink" title="混淆系列"></a>混淆系列</h2><h3 id="Obfuscator"><a href="#Obfuscator" class="headerlink" title="Obfuscator"></a>Obfuscator</h3><p>Obfuscator 就是混淆的意思，简称 OB 混淆，实战可参考以前的文章：<a href="https://itrhx.blog.csdn.net/article/details/121719631">【JS 逆向百例】W店UA，OB反混淆，抓包替换CORS跨域错误分析</a>，OB 混淆具有以下特征：</p><ul><li>一般由一个大数组或者含有大数组的函数、一个自执行函数、解密函数和加密后的函数四部分组成；</li><li>函数名和变量名通常以 <code>_0x</code> 或者 <code>0x</code> 开头，后接 1~6 位数字或字母组合；</li><li>自执行函数，进行移位操作，有明显的 push、shift 关键字；</li></ul><p>一段正常的代码如下：</p><pre><code class="javascript">function hi() &#123;  console.log(&quot;Hello World!&quot;);&#125;hi();</code></pre><p>经过 OB 混淆后的结果：</p><pre><code class="javascript">function _0x3f26() &#123;    var _0x2dad75 = [&#39;5881925kTCKCP&#39;, &#39;Hello\x20World!&#39;, &#39;600mDvfGa&#39;, &#39;699564jYNxbu&#39;, &#39;1083271cEvuvT&#39;, &#39;log&#39;, &#39;18sKjcFY&#39;, &#39;214857eMgFSU&#39;, &#39;77856FUKcuE&#39;, &#39;736425OzpdFI&#39;, &#39;737172JqcGMg&#39;];    _0x3f26 = function () &#123;        return _0x2dad75;    &#125;;    return _0x3f26();&#125;(function (_0x307c88, _0x4f8223) &#123;    var _0x32807d = _0x1fe9, _0x330c58 = _0x307c88();    while (!![]) &#123;        try &#123;            var _0x5d6354 = parseInt(_0x32807d(0x6f)) / 0x1 + parseInt(_0x32807d(0x6e)) / 0x2 + parseInt(_0x32807d(0x70)) / 0x3 + -parseInt(_0x32807d(0x69)) / 0x4 + parseInt(_0x32807d(0x71)) / 0x5 + parseInt(_0x32807d(0x6c)) / 0x6 * (parseInt(_0x32807d(0x6a)) / 0x7) + -parseInt(_0x32807d(0x73)) / 0x8 * (parseInt(_0x32807d(0x6d)) / 0x9);            if (_0x5d6354 === _0x4f8223) break; else _0x330c58[&#39;push&#39;](_0x330c58[&#39;shift&#39;]());        &#125; catch (_0x3f18e4) &#123;            _0x330c58[&#39;push&#39;](_0x330c58[&#39;shift&#39;]());        &#125;    &#125;&#125;(_0x3f26, 0xaa023));function _0x1fe9(_0xa907e7, _0x410a46) &#123;    var _0x3f261f = _0x3f26();    return _0x1fe9 = function (_0x1fe950, _0x5a08da) &#123;        _0x1fe950 = _0x1fe950 - 0x69;        var _0x82a06 = _0x3f261f[_0x1fe950];        return _0x82a06;    &#125;, _0x1fe9(_0xa907e7, _0x410a46);&#125;function hi() &#123;    var _0x12a222 = _0x1fe9;    console[_0x12a222(0x6b)](_0x12a222(0x72));&#125;hi();</code></pre><h3 id="JJEncode"><a href="#JJEncode" class="headerlink" title="JJEncode"></a>JJEncode</h3><p>JJEncode、AAEncode、JSFuck 都是同一个作者，实战可参考以前的文章：<a href="https://itrhx.blog.csdn.net/article/details/121920783">【JS 逆向百例】网洛者反爬练习平台第二题：JJEncode 加密</a>，JJEncode 具有以下特征：</p><ul><li>大量 <code>$</code>、<code>_</code> 符号，大量重复的自定义变量；</li><li>仅由 18 个符号组成：<code>[]()!+,\&quot;$.:;_&#123;&#125;~=</code></li></ul><p>正常的一段 JS 代码：</p><pre><code class="javascript">alert(&quot;Hello, JavaScript&quot; )</code></pre><p>经过 JJEncode 混淆（自定义变量名为 $）之后的代码：</p><pre><code class="javascript">$=~[];$=&#123;___:++$,$$$$:(![]+&quot;&quot;)[$],__$:++$,$_$_:(![]+&quot;&quot;)[$],_$_:++$,$_$$:(&#123;&#125;+&quot;&quot;)[$],$$_$:($[$]+&quot;&quot;)[$],_$$:++$,$$$_:(!&quot;&quot;+&quot;&quot;)[$],$__:++$,$_$:++$,$$__:(&#123;&#125;+&quot;&quot;)[$],$$_:++$,$$$:++$,$___:++$,$__$:++$&#125;;$.$_=($.$_=$+&quot;&quot;)[$.$_$]+($._$=$.$_[$.__$])+($.$$=($.$+&quot;&quot;)[$.__$])+((!$)+&quot;&quot;)[$._$$]+($.__=$.$_[$.$$_])+($.$=(!&quot;&quot;+&quot;&quot;)[$.__$])+($._=(!&quot;&quot;+&quot;&quot;)[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$=$.$+(!&quot;&quot;+&quot;&quot;)[$._$$]+$.__+$._+$.$+$.$$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$$+&quot;\&quot;&quot;+$.$_$_+(![]+&quot;&quot;)[$._$_]+$.$$$_+&quot;\\&quot;+$.__$+$.$$_+$._$_+$.__+&quot;(\\\&quot;\\&quot;+$.__$+$.__$+$.___+$.$$$_+(![]+&quot;&quot;)[$._$_]+(![]+&quot;&quot;)[$._$_]+$._$+&quot;,\\&quot;+$.$__+$.___+&quot;\\&quot;+$.__$+$.__$+$._$_+$.$_$_+&quot;\\&quot;+$.__$+$.$$_+$.$$_+$.$_$_+&quot;\\&quot;+$.__$+$._$_+$._$$+$.$$__+&quot;\\&quot;+$.__$+$.$$_+$._$_+&quot;\\&quot;+$.__$+$.$_$+$.__$+&quot;\\&quot;+$.__$+$.$$_+$.___+$.__+&quot;\\\&quot;\\&quot;+$.$__+$.___+&quot;)&quot;+&quot;\&quot;&quot;)())();</code></pre><h3 id="AAEncode"><a href="#AAEncode" class="headerlink" title="AAEncode"></a>AAEncode</h3><p>JJEncode、AAEncode、JSFuck 都是同一个作者，实战可参考以前的文章：<a href="https://itrhx.blog.csdn.net/article/details/121920864">【JS 逆向百例】网洛者反爬练习平台第三题：AAEncode 加密</a>，AAEncode 具有以下特征：</p><ul><li>仅由日式表情符号组成</li></ul><p>正常的一段 JS 代码：</p><pre><code class="javascript">alert(&quot;Hello, JavaScript&quot;)</code></pre><p>经过 AAEncode 混淆之后的代码：</p><pre><code class="javascript">ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ [&#39;_&#39;]; o=(ﾟｰﾟ)  =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)=&#123;ﾟΘﾟ: &#39;_&#39; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&#39;_&#39;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &#39;_&#39;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&#39;_&#39;)[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&#39;_&#39;) [c^_^o];(ﾟДﾟ) [&#39;c&#39;] = ((ﾟДﾟ)+&#39;_&#39;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&#39;o&#39;] = ((ﾟДﾟ)+&#39;_&#39;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [&#39;c&#39;]+(ﾟДﾟ) [&#39;o&#39;]+(ﾟωﾟﾉ +&#39;_&#39;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&#39;_&#39;) [ﾟｰﾟ] + ((ﾟДﾟ) +&#39;_&#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&#39;_&#39;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&#39;c&#39;]+((ﾟДﾟ)+&#39;_&#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&#39;o&#39;]+((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ];(ﾟДﾟ) [&#39;_&#39;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&#39;_&#39;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&#39;_&#39;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&#39;_&#39;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&#39;\\&#39;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +&#39;_&#39;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=&#39;\&quot;&#39;;(ﾟДﾟ) [&#39;_&#39;] ( (ﾟДﾟ) [&#39;_&#39;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&#39;_&#39;);</code></pre><h3 id="JSFuck"><a href="#JSFuck" class="headerlink" title="JSFuck"></a>JSFuck</h3><p>JJEncode、AAEncode、JSFuck 都是同一个作者，实战可参考以前的文章：<a href="https://itrhx.blog.csdn.net/article/details/122057377">【JS 逆向百例】网洛者反爬练习平台第四题：JSFuck 加密</a>，JSFuck 具有以下特征：</p><ul><li>仅由 6 个符号组成：<code>[]()!+</code></li></ul><p>正常的一段 JS 代码：</p><pre><code class="javascript">alert(1)</code></pre><p>经过 JSFuck 混淆之后的代码类似于：</p><pre><code class="javascript">[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(+(!+[]+!+[]+!+[]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]])+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]])()((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[+!+[]+[!+[]+!+[]+!+[]]]+[+!+[]]+([+[]]+![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[!+[]+!+[]+[+[]]])</code></pre><h3 id="Jother"><a href="#Jother" class="headerlink" title="Jother"></a>Jother</h3><p>Jother 混淆和 JSFuck 有点儿类似，唯一的区别就是密文比 JSFuck 多了 <code>&#123;&#125;</code>，其解密方式和 JSFuck 是一样的，Jother 混淆现在不太常见了，也很难找到在线混淆之类的工具了，原作者有个在线页面也关闭了，不过仍然可以了解一下，Jother 混淆具有以下特征：</p><ul><li>仅由 8 个符号组成：<code>[]()!+&#123;&#125;</code></li></ul><p>正常的一段代码：</p><pre><code class="javascript">function anonymous() &#123;return location&#125;</code></pre><p>经过 Jother 混淆之后的代码类似于：</p><pre><code class="javascript">[][(![]+[])[!![]+!![]+!![]]+(&#123;&#125;+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]]+(&#123;&#125;+[])[+!![]]+(&#123;&#125;[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+(&#123;&#125;[[]]+[])[+[]]+(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+(&#123;&#125;+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(&#123;&#125;[[]]+[])[+[]]+(!![]+[])[+!![]]+(&#123;&#125;[[]]+[])[+!![]]+(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+(&#123;&#125;+[])[+!![]]+(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+(&#123;&#125;[[]]+[])[!![]+!![]+!![]+!![]+!![]]+(&#123;&#125;+[])[+!![]]+(&#123;&#125;[[]]+[])[+!![]])()</code></pre><h3 id="Brainfuck"><a href="#Brainfuck" class="headerlink" title="Brainfuck"></a>Brainfuck</h3><p>Brainfuck 实际上是一种极小化的计算机语言，又称为 BF 语言，该语言以其极简主义着称，仅包含八个简单的命令、一个数据指针和一个指令指针，这种语言在爬虫领域也可以是一种反爬手段，可以视为一种混淆方式，虽然不常见🤔，这里给一个在线体验的网址：<a href="https://copy.sh/brainfuck/text.html">https://copy.sh/brainfuck/text.html</a> ，感兴趣的同志可以深入研究一下，Brainfuck 具有以下特征：</p><ul><li>仅由 <code>&lt;&gt;+-.[]</code> 组成；</li><li>大量的 <code>+-</code> 符号。</li></ul><p>正常的一段代码：</p><pre><code class="javascript">alert(&quot;Hello, Brainfuck&quot;)</code></pre><p>经过 Brainfuck 混淆之后的代码类似于：</p><pre><code class="javascript">--[-----&gt;+&lt;]&gt;-----.+++++++++++.-------.+++++++++++++.++.+[---&gt;+&lt;]&gt;+.------.++[-&gt;++&lt;]&gt;.-[-&gt;+++++&lt;]&gt;++.+++++++..+++.[-&gt;+++++&lt;]&gt;+.------------.+[-&gt;++&lt;]&gt;.---[-----&gt;+&lt;]&gt;-.+++[-&gt;+++&lt;]&gt;++.++++++++.+++++.--------.-[---&gt;+&lt;]&gt;--.+[-&gt;+++&lt;]&gt;+.++++++++.+[++&gt;---&lt;]&gt;.+++++++.</code></pre><h3 id="Ook"><a href="#Ook" class="headerlink" title="Ook!"></a>Ook!</h3><p>Ook! 和 Brainfuck 的原理都是类似的，只不过符号有差异，同样的，这种语言在爬虫领域也可以是一种反爬手段，可以视为一种混淆方式，虽然不常见🤔，在线体验的网址：<a href="https://www.splitbrain.org/services/ook">https://www.splitbrain.org/services/ook</a> ，Ook! 具有以下特征：</p><ul><li>完整 Ook!：仅由 3 种符号组成 <code>Ook.</code>、<code>Ook?</code>、<code>Ook!</code></li><li>Short Ook!：仅由 3 种符号组成 <code>.!?</code></li></ul><p>正常的一段代码：</p><pre><code class="javascript">alert(&quot;Hello, Ook!&quot;)</code></pre><p>经过 Ook! 混淆之后的代码类似于：</p><pre><code class="javascript">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. </code></pre><h3 id="Trivial-brainfuck-substitution"><a href="#Trivial-brainfuck-substitution" class="headerlink" title="Trivial brainfuck substitution"></a>Trivial brainfuck substitution</h3><p>Trivial brainfuck substitution 不是一种单一的编程语言，而是一大类编程语言，成员超过 20 个，前面提到的 Brainfuck、Ook! 都是其中的一员，在爬虫领域中，说实话这种稀奇古怪的混淆其实并不常见，但是在一些 CTF 中有可能会出现，作为爬虫工程师也可以了解了解😎，具体可以参考：<a href="https://esolangs.org/wiki/Trivial_brainfuck_substitution">https://esolangs.org/wiki/Trivial_brainfuck_substitution</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="恺撒密码"><a href="#恺撒密码" class="headerlink" title="恺撒密码"></a>恺撒密码</h3><p>恺撒密码（Caesar cipher）又称为恺撒加密、恺撒变换、变换加密，它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是 3 的时候，所有的字母 A 将被替换成 D，B 变成 E，以此类推。这个加密方法是以罗马共和时期恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。</p><p>根据偏移量的不同，还存在若干特定的恺撒密码名称：偏移量为10：Avocat（A→K）；偏移量为13：ROT13；偏移量为-5：Cassis (K 6)；偏移量为-6：Cassette (K 7)</p><p>示例（偏移量 3）：</p><ul><li><p>明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ</p></li><li><p>密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC</p></li></ul><h3 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h3><p>栅栏密码就是把要加密的明文分成 N 个一组，然后把每组的第 1 个字连起来，形成一段无规律的话。栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多，一般不超过 30 个。</p><p>示例：明文为 THE LONGEST DAY MUST HAVE AN END。加密时，把将要传递的信息中的字母交替排成上下两行：</p><p>T E O G S D Y U T A E N N</p><p>H L N E T A M S H V A E D</p><p>将下面一行字母排在上面一行的后边组合成密文：</p><p>TEOGSDYUTAENN HLNETAMSHVAED</p><p>栅栏密码还有一种变种，称为栅栏密码 W 型，它会先把明文类似 W 形状进行排列，然后再按栏目顺序 1-N，取每一栏的所有字符值，组成加密后密文，比如字符串 123456789，采用栏目数为 3 时，明文将采用如下排列：<br>1—5—9<br>-2-4-6-8-<br>–3—7–<br>取每一栏所有字符串，组成加密后密文：159246837</p><h3 id="猪圈密码"><a href="#猪圈密码" class="headerlink" title="猪圈密码"></a>猪圈密码</h3><p>猪圈密码也称为朱高密码、共济会暗号、共济会密码或共济会员密码，是一种以格子为基础的简单替代式密码。只能对字母加解密并且符号无法复制，粘贴后会直接显示明文，即使使用符号，也不会影响密码分析，亦可用在其它替代式的方法。曾经是美国内战时盟军使用的密码，目前仅在密码教学、各种竞赛中使用。</p><p><img src="https://img-blog.csdnimg.cn/3f805384f17840368db5e1611a54c9a2.gif#pic_center" alt="01.gif"></p><h3 id="摩斯密码"><a href="#摩斯密码" class="headerlink" title="摩斯密码"></a>摩斯密码</h3><p>摩斯密码（Morse code），又称为摩尔斯电码、摩斯电码，是一种时通时断的信号代码，这种信号代码通过不同的排列顺序来表达不同的英文字母、数字和标点符号等。</p><p>26个字母的摩斯密码表</p><table><thead><tr><th align="left">字符</th><th align="left">摩斯码</th><th align="left">字符</th><th align="left">摩斯码</th><th>字符</th><th>摩斯码</th><th>字符</th><th>摩斯码</th></tr></thead><tbody><tr><td align="left">A</td><td align="left"><code>．━</code></td><td align="left">B</td><td align="left"><code>━ ．．．</code></td><td>C</td><td><code>━ ．━ ．</code></td><td>D</td><td><code>━ ．．</code></td></tr><tr><td align="left">E</td><td align="left"><code>．</code></td><td align="left">F</td><td align="left"><code>．．━ ．</code></td><td>G</td><td><code>━ ━ ．</code></td><td>H</td><td><code>．．．．</code></td></tr><tr><td align="left">I</td><td align="left"><code>．．</code></td><td align="left">J</td><td align="left"><code>．━ ━ ━</code></td><td>K</td><td><code>━ ．━</code></td><td>L</td><td><code>．━ ．．</code></td></tr><tr><td align="left">M</td><td align="left"><code>━ ━</code></td><td align="left">N</td><td align="left"><code>━ ．</code></td><td>O</td><td><code>━ ━ ━</code></td><td>P</td><td><code>．━ ━ ．</code></td></tr><tr><td align="left">Q</td><td align="left"><code>━ ━ ．━</code></td><td align="left">R</td><td align="left"><code>．━ ．</code></td><td>S</td><td><code>．．．</code></td><td>T</td><td><code>━</code></td></tr><tr><td align="left">U</td><td align="left"><code>．．━</code></td><td align="left">V</td><td align="left"><code>．．．━</code></td><td>W</td><td><code>．━ ━</code></td><td>X</td><td><code>━ ．．━</code></td></tr><tr><td align="left">Y</td><td align="left"><code>━ ．━ ━</code></td><td align="left">Z</td><td align="left"><code>━ ━ ．．</code></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>10个数字的摩斯密码表</p><table><thead><tr><th align="left">字符</th><th align="left">摩斯码</th><th align="left">字符</th><th align="left">摩斯码</th><th>字符</th><th>摩斯码</th><th>字符</th><th>摩斯码</th></tr></thead><tbody><tr><td align="left">0</td><td align="left"><code>━ ━ ━ ━ ━</code></td><td align="left">1</td><td align="left"><code>．━ ━ ━ ━</code></td><td>2</td><td><code>．．━ ━ ━</code></td><td>3</td><td><code>．．．━ ━</code></td></tr><tr><td align="left">4</td><td align="left"><code>．．．．━</code></td><td align="left">5</td><td align="left"><code>．．．．．</code></td><td>6</td><td><code>━ ．．．．</code></td><td>7</td><td><code>━ ━ ．．．</code></td></tr><tr><td align="left">8</td><td align="left"><code>━ ━ ━ ．．</code></td><td align="left">9</td><td align="left"><code>━ ━ ━ ━ ．</code></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>标点符号的摩斯密码表</p><table><thead><tr><th align="left">字符</th><th align="left">摩斯码</th><th align="left">字符</th><th align="left">摩斯码</th><th>字符</th><th>摩斯码</th><th>字符</th><th>摩斯码</th></tr></thead><tbody><tr><td align="left">.</td><td align="left"><code>．━ ．━ ．━</code></td><td align="left">:</td><td align="left"><code>━ ━ ━ ．．．</code></td><td>,</td><td><code>━ ━ ．．━ ━</code></td><td>;</td><td><code>━ ．━ ．━ ．</code></td></tr><tr><td align="left">?</td><td align="left"><code>．．━ ━ ．．</code></td><td align="left">=</td><td align="left"><code>━ ．．．━</code></td><td>‘</td><td><code>．━ ━ ━ ━ ．</code></td><td>/</td><td><code>━ ．．━ ．</code></td></tr><tr><td align="left">!</td><td align="left"><code>━ ．━ ．━ ━</code></td><td align="left">━</td><td align="left"><code>━ ．．．．━</code></td><td>_</td><td><code>．．━ ━ ．━</code></td><td>“</td><td><code>．━ ．．━ ．</code></td></tr><tr><td align="left">(</td><td align="left"><code>━ ．━ ━ ．</code></td><td align="left">)</td><td align="left"><code>━ ．━ ━ ．━</code></td><td>$</td><td><code>．．．━ ．．━</code></td><td>&amp;</td><td><code>． ．．．</code></td></tr><tr><td align="left">@</td><td align="left"><code>．━ ━ ．━ ．</code></td><td align="left"></td><td align="left"></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="培根密码"><a href="#培根密码" class="headerlink" title="培根密码"></a>培根密码</h3><p>培根密码，又名倍康尼密码（Bacon’s cipher）是由法兰西斯·培根发明的一种隐写术，它是一种本质上用二进制数设计的，没有用通常的0和1来表示，而是采用a和b，看到一串的a和b，并且五个一组，那么就是培根加密了。</p><p>第一种方式：</p><table><thead><tr><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th></tr></thead><tbody><tr><td>A</td><td>aaaaa</td><td>H</td><td>aabbb</td><td>O</td><td>abbba</td><td>V</td><td>babab</td></tr><tr><td>B</td><td>aaaab</td><td>I</td><td>abaaa</td><td>P</td><td>abbbb</td><td>W</td><td>babba</td></tr><tr><td>C</td><td>aaaba</td><td>J</td><td>abaab</td><td>Q</td><td>baaaa</td><td>X</td><td>babbb</td></tr><tr><td>D</td><td>aaabb</td><td>K</td><td>ababa</td><td>R</td><td>baaab</td><td>Y</td><td>bbaaa</td></tr><tr><td>E</td><td>aabaa</td><td>L</td><td>ababb</td><td>S</td><td>baaba</td><td>Z</td><td>bbaab</td></tr><tr><td>F</td><td>aabab</td><td>M</td><td>abbaa</td><td>T</td><td>baabb</td><td></td><td></td></tr><tr><td>G</td><td>aabba</td><td>N</td><td>abbab</td><td>U</td><td>babaa</td><td></td><td></td></tr></tbody></table><p>第二种方式：</p><table><thead><tr><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th></tr></thead><tbody><tr><td>a</td><td>AAAAA</td><td>h</td><td>AABBB</td><td>p</td><td>ABBBA</td><td>x</td><td>BABAB</td></tr><tr><td>b</td><td>AAAAB</td><td>i-j</td><td>ABAAA</td><td>q</td><td>ABBBB</td><td>y</td><td>BABBA</td></tr><tr><td>c</td><td>AAABA</td><td>k</td><td>ABAAB</td><td>r</td><td>BAAAA</td><td>z</td><td>BABBB</td></tr><tr><td>d</td><td>AAABB</td><td>l</td><td>ABABA</td><td>s</td><td>BAAAB</td><td></td><td></td></tr><tr><td>e</td><td>AABAA</td><td>m</td><td>ABABB</td><td>t</td><td>BAABA</td><td></td><td></td></tr><tr><td>f</td><td>AABAB</td><td>n</td><td>ABBAA</td><td>u-v</td><td>BAABB</td><td></td><td></td></tr><tr><td>g</td><td>AABBA</td><td>o</td><td>ABBAB</td><td>w</td><td>BABAA</td><td></td><td></td></tr></tbody></table><p>示例：</p><ul><li>明文：kuaidaili</li><li>密文：ABABABABAAAAAAAABAAAAAABBAAAAAABAAAABABBABAAA</li></ul><h3 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h3><p>维吉尼亚密码是在凯撒密码基础上产生的一种加密方法，它将凯撒密码的全部25种位移排序为一张表，与原字母序列共同组成26行及26列的字母表。另外，维吉尼亚密码必须有一个密钥，这个密钥由字母组成，最少一个，最多可与明文字母数量相等。维吉尼亚密码表如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f2d77e1fbf392a531272954ec46a4aa2.png" alt="02.png"></p><p>示例：</p><ul><li>明文：I’ve got it.</li><li>密钥：ok</li><li>密文：W’fs qcd wd.</li></ul><p>首先，密钥长度需要与明文长度相同，如果少于明文长度，则重复拼接直到相同。示例的明文长度为8个字母（非字母均被忽略），密钥会被程序补全为 <code>okokokok</code>，然后根据维吉尼亚密码表进行加密：明文第一个字母是 <code>I</code>，密钥第一个字母是 <code>o</code>，在表格中找到 <code>I</code> 列与 <code>o</code> 行相交点，字母 <code>W</code> 就是密文第一个字母，同理，<code>v</code> 列与 <code>k</code> 行交点字母是 <code>F</code>，<code>e</code> 列与 <code>o</code> 行交点字母是 <code>S</code>，以此类推。注意：维吉尼亚密码只对字母进行加密，不区分大小写，若文本中出现非字母字符会原样保留，如果输入多行文本，每行是单独加密的。</p><h3 id="与佛论禅"><a href="#与佛论禅" class="headerlink" title="与佛论禅"></a>与佛论禅</h3><p>字符串转换后，是一些佛语，在线体验：<a href="https://keyfc.net/bbs/tools/tudoucode.aspx">https://keyfc.net/bbs/tools/tudoucode.aspx</a></p><p>示例：</p><ul><li>明文：爬虫</li><li>密文：佛曰：俱曳栗羅。諳故大多罰顛冥有諳姪帝罰知俱薩心俱智伊</li></ul><h3 id="当铺密码"><a href="#当铺密码" class="headerlink" title="当铺密码"></a>当铺密码</h3><p>当铺密码在 CTF 比赛题目中出现过。该加密算法是根据当前汉字有多少笔画出头，对应的明文就是数字几。</p><p>示例：</p><ul><li>明文：王夫 井工 夫口 由中人 井中 夫夫 由中大</li><li>密文：67 84 70 123 82 77 125</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;爬虫工程师在做加密参数逆向的时候，经常会遇到各种各样的加密算法、编码、混淆，每个算法都有其对应的特征，对于一些较小的网站，往往直接引用这些官</summary>
      
    
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91/"/>
    
    
    <category term="算法" scheme="https://www.itbob.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>【JS 逆向】WebSocket 协议爬虫，智慧树扫码登录案例分析</title>
    <link href="https://www.itbob.cn/article/043/"/>
    <id>https://www.itbob.cn/article/043/</id>
    <published>2022-01-10T09:30:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><strong>本文章中所有内容仅供学习交流，抓包内容、敏感网址、数据接口均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关，若有侵权，请联系我立即删除！</strong></p><h2 id="逆向目标"><a href="#逆向目标" class="headerlink" title="逆向目标"></a>逆向目标</h2><ul><li>目标：智慧树扫码登录，接口使用了 WebSocket 通信协议</li><li>主页：<code>aHR0cHM6Ly9wYXNzcG9ydC56aGlodWlzaHUuY29tL2xvZ2luI3FyQ29kZUxvZ2lu</code></li></ul><h2 id="WebSocket-简介"><a href="#WebSocket-简介" class="headerlink" title="WebSocket 简介"></a>WebSocket 简介</h2><p>WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议，WebSocket 使得客户端和服务器之间的数据交换变得更加简单。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><p>WebSocket 协议简称为 WS 或者 WSS（WebSocket Secure），其发送请求的 URL 以 <code>ws://</code> 或者 <code>wss://</code> 开头，WSS 是 WS 的加密版本，类似于 HTTP 与 HTTPS。</p><p>WebSocket 协议的最大特点就是：服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。与 HTTP 的对比如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20211207170201530.png" alt="01.png"></p><h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p>来到智慧树的扫码登录页面，抓包选中 WS，用来筛选 WebSocket 请求，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20211207170202672.png" alt="02.png"></p><p>其中有一些比较特别的参数，是 HTTP/ HTTPS 请求中没有的：</p><ul><li><code>Upgrade: websocket</code>：表明这是 WebSocket 类型请求；</li><li><code>Sec-WebSocket-Version</code>：告诉服务器所使用的 Websocket Draft（协议版本），必须是 13；</li><li><code>Sec-WebSocket-Extensions</code>：协议扩展，某类协议可能支持多个扩展，通过它可以实现协议增强；</li><li><code>Sec-WebSocket-Key</code>：是 WebSocket 客户端发送的一个 base64 编码的密文，是浏览器随机生成的，要求服务端必须返回一个对应加密的 <code>Sec-WebSocket-Accept</code> 应答，否则客户端会抛出 <code>Error during WebSocket handshake</code> 错误，并关闭连接。</li></ul><p>我们先扫码登录一遍，再选择 Messages 选项卡，可以看到有一些数据交互，其中绿色的箭头是客户端发送给服务器的数据，红色箭头是服务器响应返回给客户端的数据，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20211207170204424.png" alt="03.png"></p><p>我们观察一下整个交互过程，当我们打开二维码页面后，也就是二维码加载出来的同时，WebSocket 连接就建立了，每隔8秒左右，客户端就主动发送一串字符串，服务端也返回相同的字符串，只不过是字典格式，当我们扫码成功时，服务端就返回扫码成功的信息，当我们点击登陆时，客户端又会返回扫码结果，如果成功，就有一个一次性密码 <code>oncePassword</code> 和一个 <code>uuid</code>，这两个参数肯定在后续的请求中会用到的。如果长时间不扫码的话，过段时间就会返回二维码已失效的信息，每隔8秒发送一次消息，正是为了保持连接以及获取二维码状态消息。</p><p>那么到这里就出现了两个问题：</p><ol><li><p>在来回交互发送的那串字符串，是怎么得来的？</p></li><li><p>在 Python 中应该如何实现 WebSocket 请求？</p></li><li><p>如何实现客户端每隔 8 秒发送一次数据的同时，实时接收服务端的信息？（观察请求扫码结果实时返回的，所以不能每隔 8 秒才接收一次）</p></li></ol><h2 id="参数获取"><a href="#参数获取" class="headerlink" title="参数获取"></a>参数获取</h2><p>首先解决第一个问题，客户端发送的那串字符串是怎么来的，这里寻找加密字符串的方式和 HTTP/HTTPS 请求是一样的，在本例中，我们可以直接搜索这个字符串，发现是通过一个接口传过来的，其中 img 就是二维码图片的 base64 值，qrToken 就是客户端发送的那串字符串，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20211207170205334.png" alt="04.png"></p><p>这里需要注意的是，并不是所有的 WebSocket 请求都是如此的简单的，有的客户端发送的数据是 Binary Message（二进制数据）、或者更复杂的加密参数，直接搜索无法获取，针对这种情况，我们也有解决方法：</p><ol><li><p>已知创建 WebSocket 对象的语句为：<code>var Socket = new WebSocket(url, [protocol] );</code>，所以我们可以搜索 <code>new WebSocket</code> 定位到建立请求的位置。</p></li><li><p>已知一个 WebSocket 对象有以下相关事件，我们可以搜索对应事件处理程序代码来定位：</p></li></ol><table><thead><tr><th align="left">事件</th><th align="left">事件处理程序</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">open</td><td align="left">Socket.onopen</td><td align="left">连接建立时触发</td></tr><tr><td align="left">message</td><td align="left">Socket.onmessage</td><td align="left">客户端接收服务端数据时触发</td></tr><tr><td align="left">error</td><td align="left">Socket.onerror</td><td align="left">通信发生错误时触发</td></tr><tr><td align="left">close</td><td align="left">Socket.onclose</td><td align="left">连接关闭时触发</td></tr></tbody></table><ol start="3"><li>已知一个 WebSocket 对象有以下相关方法，我们可以搜索对应方法来定位：</li></ol><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Socket.send()</td><td align="left">使用连接发送数据</td></tr><tr><td align="left">Socket.close()</td><td align="left">关闭连接</td></tr></tbody></table><h2 id="Python-实现-WebSocket-请求"><a href="#Python-实现-WebSocket-请求" class="headerlink" title="Python 实现 WebSocket 请求"></a>Python 实现 WebSocket 请求</h2><p>接着前面说，第二个问题，在 Python 中应该如何实现 WebSocket 请求？Python 库中用于连接 WebSocket 的有很多，比较常用、稳定的有 <a href="https://github.com/websocket-client/websocket-client">websocket-client</a>（非异步）、<a href="https://github.com/aaugustin/websockets">websockets</a>（异步）、<a href="https://github.com/asyncins/aiowebsocket">aiowebsocket</a>（异步）。在本案例中使用 websocket-client，这里还要注意第三个问题，对于客户端来说，要每隔 8 秒发送一次数据，对于服务端，我们需要实时接收服务端的信息，可以观察请求，扫码的结果是实时返回的，如果我们也每隔 8 秒才接收一次数据的话，有可能会丢失数据，而且也会使得整个程序的响应也不及时，效率变低。</p><p>在 websocket-client 官方文档中给我们提供了一个长连接的 demo，它实现了连续发送三次数据，并实时监听服务端返回的数据，其中的 <code>websocket.enableTrace(True)</code> 表示是否显示连接详细信息：</p><pre><code class="python">import websocketimport _threadimport timedef on_message(ws, message):    print(message)def on_error(ws, error):    print(error)def on_close(ws, close_status_code, close_msg):    print(&quot;### closed ###&quot;)def on_open(ws):    def run(*args):        for i in range(3):            time.sleep(1)            ws.send(&quot;Hello %d&quot; % i)        time.sleep(1)        ws.close()        print(&quot;thread terminating...&quot;)    _thread.start_new_thread(run, ())if __name__ == &quot;__main__&quot;:    websocket.enableTrace(True)    ws = websocket.WebSocketApp(        &quot;ws://echo.websocket.org/&quot;, on_open=on_open,        on_message=on_message, on_error=on_error, on_close=on_close    )    ws.run_forever()</code></pre><p>我们将其适当改造一下，客户端在 run 方法里，依然是每隔 8 秒发送一次 qr_token，实时接收服务端的消息，当“扫码成功”字样出现在消息里时，将得到的 <code>oncePassword</code> 和 <code>uuid</code> 存起来，然后关闭连接，逻辑代码如下所示，后续只要将二维码的获取逻辑接入就行了。（已脱敏处理，不能直接运行）</p><pre><code class="python">import jsonimport timeimport _threadimport websocketweb_socket_url = &quot;wss://appcomm-user.脱敏处理.com/app-commserv-user/websocket?qrToken=%s&quot;qr_token = &quot;ca6e6cfb70de4f2f915b968aefcad404&quot;once_password = &quot;&quot;uuid = &quot;&quot;def wss_on_message(ws, message):    print(&quot;=============== [message] ===============&quot;)    message = json.loads(message)    print(message)    if &quot;扫码成功&quot; in message[&quot;msg&quot;]:        global once_password, uuid        once_password = message[&quot;oncePassword&quot;]        uuid = message[&quot;uuid&quot;]        ws.close()def wss_on_error(ws, error):    print(&quot;=============== [error] ===============&quot;)    print(error)    ws.close()def wss_on_close(ws, close_status_code, close_msg):    print(&quot;=============== [closed] ===============&quot;)    print(close_status_code)    print(close_msg)def wss_on_open(ws):    def run(*args):        while True:            ws.send(qr_token)            time.sleep(8)    _thread.start_new_thread(run, (qr_token,))def wss():    # websocket.enableTrace(True)  # 是否显示连接详细信息    ws = websocket.WebSocketApp(        web_socket_url % qr_token, on_open=wss_on_open,        on_message=wss_on_message, on_error=wss_on_error,        on_close=wss_on_close    )    ws.run_forever()</code></pre><h2 id="实现扫码登录"><a href="#实现扫码登录" class="headerlink" title="实现扫码登录"></a>实现扫码登录</h2><p>最重要的 WebSocket 请求部分已经解决了，扫码拿到 <code>oncePassword</code> 和 <code>uuid</code> 后，后续的处理步骤就比较简单了，现在来理一下完整的步骤：</p><ol><li>请求首页，第一次获取 cookie，包含：INGRESSCOOKIE、JSESSIONID、SERVERID、acw_tc；</li><li>请求获取二维码接口，得到二维码的 base64 值和 qrToken；</li><li>建立 WebSocket 连接，扫描二维码，获取一次性密码 oncePassword 和 uuid（好像没什么用）；</li><li>请求一个登录接口，302 重定向，需要携带一次性密码，第二次获取 cookie，包含：CASLOGC、CASTGC，同时更新 SERVERID；</li><li>请求第 4 步 302 重定向地址，第三次获取 cookie，包含：SESSION；</li><li>携带完整 cookie，请求用户信息接口，获取真实用户名等信息。</li></ol><p>实际上 WebSocket 连接结束后，有很多请求，看起来都比较可以，但是经过测试，只有两个重定向比较有用，抓包如下：</p><p><img src="https://img-blog.csdnimg.cn/20211207170206292.png" alt="05.png"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><strong>以下只演示部分关键代码，不能直接运行！</strong> 完整代码仓库地址：<a href="https://github.com/TRHX/Python3-Spider-Practice/">https://github.com/TRHX/Python3-Spider-Practice/</a></p><pre><code class="python">import timeimport jsonimport base64import _threadimport requestsimport websocketfrom PIL import Imageweb_socket_url = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;get_login_qr_img_url = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;login_url = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;user_info_url = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;headers = &#123;    &quot;Host&quot;: &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;,    &quot;Pragma&quot;: &quot;no-cache&quot;,    &quot;Referer&quot;: &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;,    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36&quot;&#125;qr_token = &quot;&quot;once_password = &quot;&quot;uuid = &quot;&quot;cookie = &#123;&#125;def get_cookies_first():    response = requests.get(url=login_url, headers=headers)    global cookie    cookie = response.cookies.get_dict()def get_login_qr_img():    response = requests.get(url=get_login_qr_img_url, headers=headers, cookies=cookie).json()    qr_img = response[&quot;img&quot;]    global qr_token    qr_token = response[&quot;qrToken&quot;]    with open(&#39;code.png&#39;, &#39;wb&#39;) as f:        f.write(base64.b64decode(qr_img))    image = Image.open(&#39;code.png&#39;)    image.show()    print(&quot;请扫描验证码! &quot;)def wss_on_message(ws, message):    print(&quot;=============== [message] ===============&quot;)    message = json.loads(message)    print(message)    if &quot;扫码成功&quot; in message[&quot;msg&quot;]:        global once_password, uuid        once_password = message[&quot;oncePassword&quot;]        uuid = message[&quot;uuid&quot;]        ws.close()def wss_on_error(ws, error):    print(&quot;=============== [error] ===============&quot;)    print(error)    ws.close()def wss_on_close(ws, close_status_code, close_msg):    print(&quot;=============== [closed] ===============&quot;)    print(close_status_code)    print(close_msg)def wss_on_open(ws):    def run(*args):        while True:            ws.send(qr_token)            time.sleep(8)    _thread.start_new_thread(run, (qr_token,))def wss():    # websocket.enableTrace(True)  # 是否显示连接详细信息    ws = websocket.WebSocketApp(        web_socket_url % qr_token, on_open=wss_on_open,        on_message=wss_on_message, on_error=wss_on_error,        on_close=wss_on_close    )    ws.run_forever()def get_cookie_second():    global cookie    params = &#123;        &quot;pwd&quot;: once_password,        &quot;service&quot;: &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;    &#125;    headers[&quot;Host&quot;] = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;    headers[&quot;Referer&quot;] = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;    response = requests.get(url=login_url, params=params, headers=headers, cookies=cookie, allow_redirects=False)    cookie.update(response.cookies.get_dict())    location = response.headers.get(&quot;Location&quot;)    return locationdef get_cookie_third(location):    global cookie    headers[&quot;Host&quot;] = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;    headers[&quot;Referer&quot;] = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;    response = requests.get(url=location, headers=headers, cookies=cookie, allow_redirects=False)    cookie.update(response.cookies.get_dict())    location = response.headers.get(&quot;Location&quot;)    return locationdef get_login_user_info():    headers[&quot;Host&quot;] = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;    headers[&quot;Origin&quot;] = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;    headers[&quot;Referer&quot;] = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;    params = &#123;&quot;time&quot;: str(int(time.time() * 1000))&#125;    response = requests.get(url=user_info_url, headers=headers, cookies=cookie, params=params)    print(response.text)def main():    # 第一次获取 cookie，包含 INGRESSCOOKIE、JSESSIONID、SERVERID、acw_tc    get_cookies_first()    # 获取二维码    get_login_qr_img()    # websocket 扫码登录，返回一次性密码    wss()    # 第二次获取 cookie，更新 SERVERID、获取 CASLOGC、CASTGC    location1 = get_cookie_second()    # 第三次获取 cookie，获取 SESSION    get_cookie_third(location1)    # 获取登录用户信息    get_login_user_info()if __name__ == &#39;__main__&#39;:    main()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文章中所有内容仅供学习交流，抓包内容、敏感网址、数据接口均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果</summary>
      
    
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91/"/>
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>【JS 逆向】某空气质量监测平台无限 debugger 以及数据动态加密分析</title>
    <link href="https://www.itbob.cn/article/044/"/>
    <id>https://www.itbob.cn/article/044/</id>
    <published>2022-01-10T09:30:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><strong>本文章中所有内容仅供学习交流，抓包内容、敏感网址、数据接口均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关，若有侵权，请联系我立即删除！</strong></p><h2 id="逆向目标"><a href="#逆向目标" class="headerlink" title="逆向目标"></a>逆向目标</h2><ul><li>目标：某空气质量监测平台无限 debugger 以及请求数据、返回数据动态加密、解密</li><li>主页：<code>aHR0cHM6Ly93d3cuYXFpc3R1ZHkuY24v</code></li><li>接口：<code>aHR0cHM6Ly93d3cuYXFpc3R1ZHkuY24vYXBpbmV3L2FxaXN0dWR5YXBpLnBocA==</code></li></ul><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这个站点更新频率很高，在我之前也已经有很多博主写了该站点的分析文章，近期有读者问请求数据的加密和返回数据的解密，发现其加解密 JS 变成了动态的，以前的那些文章提到的解决思路不太行了，但整体上来说也不是很难，只不过处理起来比较麻烦一点，还有一些小细节需要注意。</p><p>在网站的“关于系统”里可以看到，这个站貌似是个人开发者在维护，最早在2013年就有了，在友情赞助列表里，可以看到大多数都是一些环境、测绘、公共卫生相关的大学专业、研究院人员，可以猜测到这些数据对于他们的研究是非常有帮助的，再加上反爬更新频繁，可以看出站长饱受爬虫之苦，K哥也不想给站长添加负担，毕竟这种站点咱们应该支持，让他长久维护下去，<strong>所以本期K哥只分析逻辑和少部分代码，就不放完整代码了，如果有相关专业人士确实需要抓取数据做研究的，可以在公众号后台联系我。</strong></p><h2 id="绕过无限-debugger"><a href="#绕过无限-debugger" class="headerlink" title="绕过无限 debugger"></a>绕过无限 debugger</h2><p>右键 F12，会提示右键被禁用，不要紧，使用快捷键 <code>Ctrl+Shift+i</code> 或者浏览器右上角，更多工具，开发者工具，照样能打开。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/389c5830317031a092ffe6ddd0c10050.png#pic_center" alt="01.png"></p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>打开控制台后会进入第一个无限 debugger，往上跟一个栈，可以看到一个 try-catch 语句，你下断点会发现他会一直走 catch，调用 <code>setTimeout()</code> 方法，该方法用于在指定的毫秒数后调用函数或计算表达式，注意上面，是将 debugger 传递给了构造方法 constructor，所以这里我们有两种方法过掉 debugger，Hook 掉 constructor 或 setTimeout 都可以。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c311099f5c0b77192424c42d937d90c4.png#pic_center" alt="02.png"></p><pre><code class="javascript">// 两种 Hook 任选一中// Hook 构造方法Function.prototype.constructor_ = Function.prototype.constructor;Function.prototype.constructor = function (a) &#123;    if(a == &quot;debugger&quot;) &#123;        return function ()&#123;&#125;;    &#125;    return Function.prototype.constructor_(a);&#125;;// Hook setTimeoutvar setTimeout_ = setTimeoutvar setTimeout = function (func, time)&#123;    if (func == txsdefwsw)&#123;        return function () &#123;&#125;;    &#125;    return setTimeout_(func, time)&#125;</code></pre><p>然后就来到了第二个无限 debugger，同样跟栈，发现有个 setInterval 定时器和构造方法 constructor，类似的，我们 Hook 掉 constructor 或 setInterval 都可以。注意：定时器这里还检测了窗口高宽，即便是你过了 constructor 或 setInterval，如果不把开发者工具单独拿出来也是不行的，会不断输出“检测到非法调试”。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/24fb1072abd88b44ce7e6a836e56af97.png#pic_center" alt="03.png"></p><pre><code class="javascript">// Hook setIntervalvar setInterval_ = setIntervalsetInterval = function (func, time)&#123;    if (time == 2000) &#123;        return function () &#123;&#125;;    &#125;    return setInterval_(func, time)&#125;</code></pre><p>我们观察到，其实这两个无限 debugger 都可以 Hook 构造方法来过掉，所以直接 Fiddler 注入该 Hook 构造方法的代码即可：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/57c491d6b2a5f28110ba422d34355cc9.png#pic_center" alt="04.png"></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>在我们遇到第二个无限 debugger 的时候，还可以直接跟栈到一个 city_realtime.php 的页面，里面有两个 eval 语句，执行第一个 eval 里面的语句你就会发现正是前面我们在 VM 虚拟机里面看到的 debugger 代码，所以这里理论上可以直接替换掉这个页面，去掉 eval 语句，就不会有无限 debugger 了，但是K哥先告诉你，现在不行了，因为里面有加载了某个 JS，这个 JS 在后面加密解密中会用到，但是这个 JS 是动态的，每10分钟就会改变，我们后面还要通过此页面来获取动态的 JS，所以是不能替换的！这里只是提一下这个思路！</p><p><img src="https://img-blog.csdnimg.cn/img_convert/db958514d4e4bc98ffa605cf626ca23a.png#pic_center" alt="05.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/282ada73849ebb74039a98732edaf72e.png#pic_center" alt="06.png"></p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>当然，这里还有一种最简单的方法，直接右键选择 Never pause here，永不在此处断下即可，同样还需要把开发者工具窗口单独拿出来，不然会一直输出“检测到非法调试”。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f5922a0ad3c48adc030e368bf8542b8a.png#pic_center" alt="07.png"></p><h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p>我们在实时监控页面，顺便点击查询一个城市，可以看到请求的 Form Data 和返回的数据都是加密的，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6f1b1872723348480a25b3862201622e.png#pic_center" alt="08.png"></p><h2 id="加密入口"><a href="#加密入口" class="headerlink" title="加密入口"></a>加密入口</h2><p>由于是 XHR，所以我们直接跟栈，很容易找到加密的位置：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ed3d2b8414cdb6f2d434d2534939e379.png#pic_center" alt="09.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/53044ab14dbfdb75bd21657060d6bbd8.png#pic_center" alt="10.png"></p><p>可以看到传递的 data 键值对：<code>&#123;hXM8NDFHN: p7crXYR&#125;</code>，键在这个 JS 里是写死的，值是通过一个方法 <code>pU14VhqrofroULds()</code> 得到的，这个方法需要传递两个参数，第一个是定值 GETDATA，第二个就是城市名称，我们再跟进看看这个方法是啥：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6145ba480135887e42bda4f0f471d3f9.png#pic_center" alt="11.png"></p><p>一些 appId、时间戳、城市等参数，做了一些 MD5、base64 的操作，返回的 param 就是我们要的值了。看起来不难，我们再找找返回的加密数据是如何解密的，我们注意到 ajax 请求有个 success 关键字，我们即便是不懂 JS 逻辑，也可以猜到应该是请求成功后的处理操作吧，如下图所示：传进来的 dzJMI 就是返回的加密的数据，经过 <code>db0HpCYIy97HkHS7RkhUn()</code> 方法后，就解密成功了：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6f5527d38878bcabda88878591aafb3a.png#pic_center" alt="12.png"></p><p>跟进 <code>db0HpCYIy97HkHS7RkhUn()</code> 方法，可以看到是 AES+DES+BASE64 解密，传入的密钥 key 和偏移量 iv 都在头部有定义：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b77e427fed50ef80002d0144fb478741.png#pic_center" alt="13.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/960e2ebfe395fbb139442d10e5f16f43.png#pic_center" alt="14.png"></p><h2 id="动态-JS"><a href="#动态-JS" class="headerlink" title="动态 JS"></a>动态 JS</h2><p>经过以上分析后，我们加密解密的逻辑都搞定了，但是你多调试一下就会发现，这一个加密解密的 JS 是动态变化的，定义的密钥 key 和偏移量 iv 都是隔段时间就会改变的，如果你在这段代码里下断点，停留时间过长，突然发现断点失效无法断下了，那就是 JS 变了，当前代码已经失效了。</p><p>我们随便薅两个不同的 JS 下来（提示：JS 每隔10分钟会变化，后文有详细分析），利用 PyCharm 的文件对比功能（依次选择 View - Compare With）可以总结出以下几个变化的地方（变量名的变化不算）：</p><ol><li>开头的8个参数的值：两个 aes key 和 iv，两个 des key 和 iv；</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/4f48281ff87143bc23a094cf634802d8.png#pic_center" alt="15.png"></p><ol start="2"><li>生成加密的 param 时，appId 是变化的，最后的加密分为 AES、DES 和没有加密，三种情况（这里是最容易忽略的地方，这里没有注意到，请求可能会提示 appId 无效的情况）：</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/762fa747135504fbde73fa6b3986d869.png#pic_center" alt="16.png"></p><ol start="3"><li>最后发送请求时，data 键值对，其中的键也是变化的：</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/67ee28a04033aa503d8e41be6fcf3dbd.png#pic_center" alt="17.png"></p><p>变化的地方我们找到了，那我们怎么获取这个 JS 呢？因为这个 JS 的在 VM 虚拟机里，所以我们还要找到它的源头，是从哪里来的，我们抓包可以看到一个比较特殊的 JS，类似于 encrypt_xxxxxx.js，看这取名就知道不简单，返回的是一段 eval 包裹的代码：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a2f3687fe4ee1aad5c7ca1331bf65a68.png#pic_center" alt="18.png"></p><p>对于 eval 我们已经很熟悉了，直接去掉 eval，让他执行一下，就可以看到正是我们需要的那段 JS：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ab32b5eff66ba4cf024ce79109bea03a.png#pic_center" alt="19.png"></p><p>这里有个小细节，如果你使用控制台，会发现它一直在打印 img 标签，影响我们的输入，这里可以直接跟进去下断点暂时阻止他运行就行了，不需要做其他操作浪费时间：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/54b72f44ae13b7eed13f0f4f6e0e3091.png#pic_center" alt="20.png"></p><p>你以为到这里就差不多搞定了？错了，同样的这个 encrypt_xxxxxx.js 也藏有玄机：</p><ol><li>encrypt_xxxxxx.js 的名称是动态的，后面的 v 值是秒级时间戳，隔600秒，也就是十分钟就会改变，这个 JS 可以在 city_realtime.php 页面找到，还记得我们前面说过的绕过无限 debugger 不能替换此页面吗？我们要通过此页面来获取动态的 JS，所以是不能替换的！</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/73f20c39d6bc6e0cc6ed54815cad99fa.png#pic_center" alt="21.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/fc3eeffb3bf092330e03cefaf34363e6.png#pic_center" alt="22.png"></p><ol start="2"><li>encrypt_xxxxxx.js 返回的 JS，并不是所有的执行一遍 eval 就能得到明文代码了，它是 eval 和 base64 相结合的，第一遍都是 eval，但是后面就说不定了，有可能直接出结果，有可能需要 base64，有可能 base64 两遍，有可能两遍 base64 之后还要再 eval，总之，除了第一遍是 eval 以外，后面是否需要 base64 和 eval，以及需要的次数和先后顺序，都是不确定的！举几个例子：</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/5f2297cf7a0481ae3399b5c2a8fa81c0.png#pic_center" alt="23.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/b2217260728ded9a44be53524f23ad2b.png#pic_center" alt="24.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/9fa531eb305cba680b129ca22d910298.png#pic_center" alt="25.png"></p><p>这里可能有人会问，你怎么看出来那是 base64 呢？很简单，直接在网站页面的控制台里输入 <code>dswejwehxt</code>，点击去看这个函数，就是 base64：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5a0ee651bf758051472d212c7f0a5b07.png#pic_center" alt="26.png"></p><p>那么针对 encrypt_xxxxxx.js 内容不确定的情况，我们可以写一个方法，获取到 encrypt_xxxxxx.js 后，需要执行 eval 就执行 eval，需要执行 base64 就执行 base64，直到没有 eval 和 base64 即可，可以分别用字符串 <code>eval(function</code> 和 <code>dswejwehxt(</code> 来判断是否需要 eval 和 base64（当然也有其他方式，比如 <code>()</code> 的个数等），示例代码如下所示：</p><pre><code class="python">def get_decrypted_js(encrypted_js_url):    &quot;&quot;&quot;    :param encrypted_js_url: encrypt_xxxxxx.js 的地址    :return: 解密后的 JS    &quot;&quot;&quot;    decrypted_js = requests.get(url=encrypted_js_url, headers=headers).text    flag = True    while flag:        if &quot;eval(function&quot; in decrypted_js:            # 需要执行 eval            print(&quot;需要执行 eval！&quot;)            replace_js = decrypted_js.replace(&quot;eval(function&quot;, &quot;(function&quot;)            decrypted_js = execjs.eval(replace_js)        elif &quot;dswejwehxt(&quot; in decrypted_js:            # 需要 base64 解码            base64_num = decrypted_js.count(&quot;dswejwehxt(&quot;)            print(&quot;需要 %s 次 base64 解码！&quot; % base64_num)            decrypted_js = re.findall(r&quot;\(&#39;(.*?)&#39;\)&quot;, decrypted_js)[0]            num = 0            while base64_num &gt; num:                decrypted_js = base64.b64decode(decrypted_js).decode()                num += 1        else:            # 得到明文            flag = False    # print(decrypted_js)    return decrypted_js</code></pre><h2 id="本地改写"><a href="#本地改写" class="headerlink" title="本地改写"></a>本地改写</h2><p>通过以上函数我们就拿到了动态的 JS 了，那么我们可以直接执行拿回来的 JS 吗？当然是不可以的，你可以自己本地执行一下，可以发现里面的 CryptoJS、Base64、hex_md5 都需要补齐才行，所以到这里我们就有两种做法：</p><ol><li>拿到解密后的动态 JS 后，动态 JS 和我们自己写的 Base64、hex_md5 等方法组成新的 JS 代码，执行新的 JS 代码拿到参数，这里还需要注意因为里面的其他方法名都是动态的，所以你还得想办法匹配到正确的方法名来调用才行，所以这种方法个人感觉还是稍微有点儿麻烦的；</li><li>我们本地自己写一个 JS，拿到解密后的动态 JS 后，把里面的 key、iv、appId、data 键名、param 是否需要 AES 或 DES 加密，这些信息都匹配出来，然后传给我们自己写的 JS，调用我们自己的方法拿到加密结果。</li></ol><p>虽然两种方法都很麻烦，但K哥暂时也想不到更好的解决方法了，有比较好的想法的朋友可以留言说一说。</p><p>以第二种方法为例，我们本地的 JS 示例（main.js）：</p><pre><code class="javascript">var CryptoJS = require(&quot;crypto-js&quot;);var BASE64 = &#123;    encrypt: function (text) &#123;        return CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(text))    &#125;,    decrypt: function (text) &#123;        return CryptoJS.enc.Base64.parse(text).toString(CryptoJS.enc.Utf8)    &#125;&#125;;var DES = &#123;    encrypt: function (text, key, iv) &#123;        var secretkey = (CryptoJS.MD5(key).toString()).substr(0, 16);        var secretiv = (CryptoJS.MD5(iv).toString()).substr(24, 8);        secretkey = CryptoJS.enc.Utf8.parse(secretkey);        secretiv = CryptoJS.enc.Utf8.parse(secretiv);        var result = CryptoJS.DES.encrypt(text, secretkey, &#123;            iv: secretiv,            mode: CryptoJS.mode.CBC,            padding: CryptoJS.pad.Pkcs7        &#125;);        return result.toString();    &#125;,    decrypt: function (text, key, iv) &#123;        var secretkey = (CryptoJS.MD5(key).toString()).substr(0, 16);        var secretiv = (CryptoJS.MD5(iv).toString()).substr(24, 8);        secretkey = CryptoJS.enc.Utf8.parse(secretkey);        secretiv = CryptoJS.enc.Utf8.parse(secretiv);        var result = CryptoJS.DES.decrypt(text, secretkey, &#123;            iv: secretiv,            mode: CryptoJS.mode.CBC,            padding: CryptoJS.pad.Pkcs7        &#125;);        return result.toString(CryptoJS.enc.Utf8);    &#125;&#125;;var AES = &#123;    encrypt: function (text, key, iv) &#123;        var secretkey = (CryptoJS.MD5(key).toString()).substr(16, 16);        var secretiv = (CryptoJS.MD5(iv).toString()).substr(0, 16);        secretkey = CryptoJS.enc.Utf8.parse(secretkey);        secretiv = CryptoJS.enc.Utf8.parse(secretiv);        var result = CryptoJS.AES.encrypt(text, secretkey, &#123;            iv: secretiv,            mode: CryptoJS.mode.CBC,            padding: CryptoJS.pad.Pkcs7        &#125;);        return result.toString();    &#125;,    decrypt: function (text, key, iv) &#123;        var secretkey = (CryptoJS.MD5(key).toString()).substr(16, 16);        var secretiv = (CryptoJS.MD5(iv).toString()).substr(0, 16);        secretkey = CryptoJS.enc.Utf8.parse(secretkey);        secretiv = CryptoJS.enc.Utf8.parse(secretiv);        var result = CryptoJS.AES.decrypt(text, secretkey, &#123;            iv: secretiv,            mode: CryptoJS.mode.CBC,            padding: CryptoJS.pad.Pkcs7        &#125;);        return result.toString(CryptoJS.enc.Utf8);    &#125;&#125;;function getDecryptedData(data, AES_KEY_1, AES_IV_1, DES_KEY_1, DES_IV_1) &#123;    data = AES.decrypt(data, AES_KEY_1, AES_IV_1);    data = DES.decrypt(data, DES_KEY_1, DES_IV_1);    data = BASE64.decrypt(data);    return data;&#125;function ObjectSort(obj) &#123;    var newObject = &#123;&#125;;    Object.keys(obj).sort().map(function (key) &#123;        newObject[key] = obj[key];    &#125;);    return newObject;&#125;function getRequestParam(method, obj, appId) &#123;    var clienttype = &#39;WEB&#39;;    var timestamp = new Date().getTime()    var param = &#123;        appId: appId,        method: method,        timestamp: timestamp,        clienttype: clienttype,        object: obj,        secret: CryptoJS.MD5(appId + method + timestamp + clienttype + JSON.stringify(ObjectSort(obj))).toString()    &#125;;    param = BASE64.encrypt(JSON.stringify(param));    return param;&#125;function getRequestAESParam(requestMethod, requestCity, appId, AES_KEY_2, AES_IV_2)&#123;    var param = getRequestParam(requestMethod, requestCity, appId);    return AES.encrypt(param, AES_KEY_2, AES_IV_2);&#125;function getRequestDESParam(requestMethod, requestCity, appId, DES_KEY_2, DES_IV_2)&#123;    var param = getRequestParam(requestMethod, requestCity, appId);    return DES.encrypt(param, DES_KEY_2, DES_IV_2);&#125;</code></pre><p>我们匹配 JS 里面的各项参数的 Python 代码示例（匹配8个 key、iv 值、appId 和 param 的加密方式）：</p><pre><code class="python">def get_key_iv_appid(decrypted_js):    &quot;&quot;&quot;    :param decrypted_js: 解密后的 encrypt_xxxxxx.js    :return: 请求必须的一些参数    &quot;&quot;&quot;    key_iv = re.findall(r&#39;const.*?&quot;(.*?)&quot;;&#39;, decrypted_js)    app_id = re.findall(r&quot;var appId.*?&#39;(.*?)&#39;;&quot;, decrypted_js)    request_data_name = re.findall(r&quot;aqistudyapi.php.*?data.*?&#123;(.*?):&quot;, decrypted_js, re.DOTALL)    # 判断 param 是 AES 加密还是 DES 加密还是没有加密    if &quot;AES.encrypt(param&quot; in decrypted_js:        request_param_encrypt = &quot;AES&quot;    elif &quot;DES.encrypt(param&quot; in decrypted_js:        request_param_encrypt = &quot;DES&quot;    else:        request_param_encrypt = &quot;NO&quot;    key_iv_appid = &#123;        # key 和 iv 的位置和原来 js 里的是一样的        &quot;aes_key_1&quot;: key_iv[0],        &quot;aes_iv_1&quot;: key_iv[1],        &quot;aes_key_2&quot;: key_iv[2],        &quot;aes_iv_2&quot;: key_iv[3],        &quot;des_key_1&quot;: key_iv[4],        &quot;des_iv_1&quot;: key_iv[5],        &quot;des_key_2&quot;: key_iv[6],        &quot;des_iv_2&quot;: key_iv[7],        &quot;app_id&quot;: app_id[0],        # 发送请求的 data 的键名        &quot;request_data_name&quot;: request_data_name[0].strip(),        # 发送请求的 data 值需要哪种加密        &quot;request_param_encrypt&quot;: request_param_encrypt    &#125;    # print(key_iv_appid)    return key_iv_appid</code></pre><p>我们发送请求以及解密返回值的 Python 代码示例（以北京为例）：</p><pre><code class="python">def get_data(key_iv_appid):    &quot;&quot;&quot;    :param key_iv_appid: get_key_iv_appid() 方法返回的值    &quot;&quot;&quot;    request_method = &quot;GETDATA&quot;    request_city = &#123;&quot;city&quot;: &quot;北京&quot;&#125;    with open(&#39;main.js&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:        execjs_ = execjs.compile(f.read())    # 根据不同加密方式调用不同方法获取请求加密的 param 参数    request_param_encrypt = key_iv_appid[&quot;request_param_encrypt&quot;]    if request_param_encrypt == &quot;AES&quot;:        param = execjs_.call(            &#39;getRequestAESParam&#39;, request_method, request_city,            key_iv_appid[&quot;app_id&quot;], key_iv_appid[&quot;aes_key_2&quot;], key_iv_appid[&quot;aes_iv_2&quot;]        )    elif request_param_encrypt == &quot;DES&quot;:        param = execjs_.call(            &#39;getRequestDESParam&#39;, request_method, request_city,            key_iv_appid[&quot;app_id&quot;], key_iv_appid[&quot;des_key_2&quot;], key_iv_appid[&quot;des_iv_2&quot;]        )    else:        param = execjs_.call(&#39;getRequestParam&#39;, request_method, request_city, key_iv_appid[&quot;app_id&quot;])    data = &#123;        key_iv_appid[&quot;request_data_name&quot;]: param    &#125;    response = requests.post(url=aqistudy_api, headers=headers, data=data).text    # print(response)    # 对获取的加密数据解密    decrypted_data = execjs_.call(        &#39;getDecryptedData&#39;, response,        key_iv_appid[&quot;aes_key_1&quot;], key_iv_appid[&quot;aes_iv_1&quot;],        key_iv_appid[&quot;des_key_1&quot;], key_iv_appid[&quot;des_iv_1&quot;]    )    print(json.loads(decrypted_data))</code></pre><p>运行结果，成功请求并解密返回值：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f6243a66a4ddcf72bb77b28bb94bc49d.png#pic_center" alt="27.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文章中所有内容仅供学习交流，抓包内容、敏感网址、数据接口均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果</summary>
      
    
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91/"/>
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Loguru：Python 日志终极解决方案</title>
    <link href="https://www.itbob.cn/article/042/"/>
    <id>https://www.itbob.cn/article/042/</id>
    <published>2021-11-04T07:48:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日志的重要性"><a href="#日志的重要性" class="headerlink" title="日志的重要性"></a>日志的重要性</h2><p>日志的作用非常重要，日志可以记录用户的操作、程序的异常，还可以为数据分析提供依据，日志的存在意义就是为了能够在程序在运行过程中记录错误，方便维护和调试，能够快速定位出错的地方，减少维护成本。每个程序员都应该知道，不是为了记录日志而记录日志，日志也不是随意记的。要实现能够只通过日志文件还原整个程序执行的过程，达到能透明地看到程序里执行情况，每个线程、每个过程到底执行到哪的目的。日志就像飞机的黑匣子一样，应当能够复原异常的整个现场乃至细节！</p><h2 id="常见日志记录方式"><a href="#常见日志记录方式" class="headerlink" title="常见日志记录方式"></a>常见日志记录方式</h2><h3 id="一、print"><a href="#一、print" class="headerlink" title="一、print()"></a>一、print()</h3><p>最常见的是把输出函数 <code>print()</code> 当作日志记录的方式，直接打印各种提示信息，常见于个人练习项目里，通常是懒得单独配置日志，而且项目太小不需要日志信息，不需要上线，不需要持续运行，完整的项目不推荐直接打印日志信息，现实中也几乎没有人这么做。</p><h3 id="二、自写模板"><a href="#二、自写模板" class="headerlink" title="二、自写模板"></a>二、自写模板</h3><p>我们可以在不少小项目里面看到作者自己写了一个日志模板，通常利用 <code>print()</code> 或者 <code>sys.stdout</code> 稍微封装一下即可实现简单的日志输出，这里的 <code>sys.stdout</code> 是 Python 中的标准输出流，<code>print()</code> 函数是对 <code>sys.stdout</code> 的高级封装，当我们在 Python 中打印对象调用 <code>print(obj)</code> 时候，事实上是调用了 <code>sys.stdout.write(obj+&#39;\n&#39;)</code>，<code>print()</code> 将内容打印到了控制台，然后追加了一个换行符 <code>\n</code>。</p><p>自写日志模板适合比较小的项目，可以按照自己的喜好编写模板，不需要太多复杂配置，方便快捷，但是这种记录日志的方式并不是很规范，有可能你自己觉得阅读体验不错，但是别人在接触你的项目的时候往往需要花费一定的时间去学习日志的逻辑、格式、输出方式等，比较大的项目同样不推荐这种方法。</p><p>一个简单的自写日志模板举例：</p><p>日志模板 log.py：</p><pre><code class="python">import sysimport tracebackimport datetimedef getnowtime():    return datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)def _log(content, level, *args):    sys.stdout.write(&quot;%s - %s - %s\n&quot; % (getnowtime(), level, content))    for arg in args:        sys.stdout.write(&quot;%s\n&quot; % arg)def debug(content, *args):    _log(content, &#39;DEBUG&#39;, *args)def info(content, *args):    _log(content, &#39;INFO&#39;, *args)def warn(content, *args):    _log(content, &#39;WARN&#39;, *args)def error(content, *args):    _log(content, &#39;ERROR&#39;, *args)def exception(content):    sys.stdout.write(&quot;%s - %s\n&quot; % (getnowtime(), content))    traceback.print_exc(file=sys.stdout)</code></pre><p>调用日志模块：</p><pre><code class="python">import loglog.info(&quot;This is log info!&quot;)log.warn(&quot;This is log warn!&quot;)log.error(&quot;This is log error!&quot;)log.debug(&quot;This is log debug!&quot;)people_info = &#123;&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 20&#125;try:    gender = people_info[&quot;gender&quot;]except Exception as error:    log.exception(error)</code></pre><p>日志输出：</p><pre><code class="python">2021-10-19 09:50:58 - INFO - This is log info!2021-10-19 09:50:58 - WARN - This is log warn!2021-10-19 09:50:58 - ERROR - This is log error!2021-10-19 09:50:58 - DEBUG - This is log debug!2021-10-19 09:50:58 - &#39;gender&#39;Traceback (most recent call last):  File &quot;D:/python3Project/test.py&quot;, line 18, in &lt;module&gt;    gender = people_info[&quot;gender&quot;]KeyError: &#39;gender&#39;</code></pre><h3 id="三、Logging"><a href="#三、Logging" class="headerlink" title="三、Logging"></a>三、Logging</h3><p>在一个完整的项目中，大多数人都会引入专门的日志记录库，而 Python 自带的标准库 logging 就是专门为日志记录而生的，logging 模块定义的函数和类为应用程序和库的开发实现了一个灵活的事件日志系统。由标准库模块提供日志记录 API 的关键好处是所有 Python 模块都可以使用这个日志记录功能。所以，你的应用日志可以将你自己的日志信息与来自第三方模块的信息整合起来。</p><p>logging 模块虽然强大，但是其配置也是比较繁琐的，在大型项目中通常需要单独初始化日志、配置日志格式等等，我在日常使用中通常都会对 logging 做如下的封装写法，使日志可以按天保存，保留15天的日志，可以配置是否输出到控制台和文件，如下所示：</p><pre><code class="python"># 实现按天分割保留日志import osimport sysimport loggingfrom logging import handlersPARENT_DIR = os.path.split(os.path.realpath(__file__))[0]  # 父目录LOGGING_DIR = os.path.join(PARENT_DIR, &quot;log&quot;)              # 日志目录LOGGING_NAME = &quot;test&quot;                                      # 日志文件名LOGGING_TO_FILE = True                                     # 日志输出文件LOGGING_TO_CONSOLE = True                                  # 日志输出到控制台LOGGING_WHEN = &#39;D&#39;                                         # 日志文件切分维度LOGGING_INTERVAL = 1                                       # 间隔少个 when 后，自动重建文件LOGGING_BACKUP_COUNT = 15                                  # 日志保留个数，0 保留所有日志LOGGING_LEVEL = logging.DEBUG                              # 日志等级LOGGING_suffix = &quot;%Y.%m.%d.log&quot;                            # 旧日志文件名# 日志输出格式LOGGING_FORMATTER = &quot;%(levelname)s - %(asctime)s - process:%(process)d - %(filename)s - %(name)s - line:%(lineno)d - %(module)s - %(message)s&quot;def logging_init():    if not os.path.exists(LOGGING_DIR):        os.makedirs(LOGGING_DIR)    logger = logging.getLogger()    logger.setLevel(LOGGING_LEVEL)    formatter = logging.Formatter(LOGGING_FORMATTER)    if LOGGING_TO_FILE:        file_handler = handlers.TimedRotatingFileHandler(filename=os.path.join(LOGGING_DIR, LOGGING_NAME), when=LOGGING_WHEN, interval=LOGGING_INTERVAL, backupCount=LOGGING_BACKUP_COUNT)        file_handler.suffix = LOGGING_suffix        file_handler.setFormatter(formatter)        logger.addHandler(file_handler)    if LOGGING_TO_CONSOLE:        stream_handler = logging.StreamHandler(sys.stderr)        stream_handler.setFormatter(formatter)        logger.addHandler(stream_handler)def logging_test():    logging.info(&quot;This is log info!&quot;)    logging.warning(&quot;This is log warn!&quot;)    logging.error(&quot;This is log error!&quot;)    logging.debug(&quot;This is log debug!&quot;)    people_info = &#123;&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 20&#125;    try:        gender = people_info[&quot;gender&quot;]    except Exception as error:        logging.exception(error)if __name__ == &quot;__main__&quot;:    logging_init()    logging_test()</code></pre><p>输出日志：</p><pre><code class="bash">INFO - 2021-10-19 11:28:10,103 - process:15144 - test.py - root - line:52 - test - This is log info!WARNING - 2021-10-19 11:28:10,105 - process:15144 - test.py - root - line:53 - test - This is log warn!ERROR - 2021-10-19 11:28:10,105 - process:15144 - test.py - root - line:54 - test - This is log error!DEBUG - 2021-10-19 11:28:10,105 - process:15144 - test.py - root - line:55 - test - This is log debug!ERROR - 2021-10-19 11:28:10,105 - process:15144 - test.py - root - line:61 - test - &#39;gender&#39;Traceback (most recent call last):  File &quot;D:/python3Project/test.py&quot;, line 59, in logging_test    gender = people_info[&quot;gender&quot;]KeyError: &#39;gender&#39;</code></pre><p>它在控制台中是这样的：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/906ed37334702098905b7cff083f2c6e.png" alt="02.png"></p><p>当然，如果你不需要很复杂的功能，希望简洁一点，仅仅需要在控制台输出一下日志的话，也可以只进行简单的配置：</p><pre><code class="python">import logginglogging.basicConfig(level=logging.DEBUG, format=&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)logging.getLogger()</code></pre><h2 id="更优雅的解决方案：Loguru"><a href="#更优雅的解决方案：Loguru" class="headerlink" title="更优雅的解决方案：Loguru"></a>更优雅的解决方案：Loguru</h2><p>对于 logging 模块，即便是简单的使用，也需要自己定义格式，这里介绍一个更加优雅、高效、简洁的第三方模块：loguru，官方的介绍是：Loguru is a library which aims to bring enjoyable logging in Python. Loguru 旨在为 Python 带来愉快的日志记录。这里引用官方的一个 GIF 来快速演示其功能：</p><p><img src="https://img-blog.csdnimg.cn/d2cfb68d514240209779ae9dac5a42cb.gif#pic_center" alt="02.gif"></p><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Loguru 仅支持 Python 3.5 及以上的版本，使用 pip 安装即可：</p><pre><code class="bash">pip install loguru</code></pre><hr><h3 id="开箱即用"><a href="#开箱即用" class="headerlink" title="开箱即用"></a>开箱即用</h3><p>Loguru 的主要概念是只有一个：logger</p><pre><code class="python">from loguru import loggerlogger.info(&quot;This is log info!&quot;)logger.warning(&quot;This is log warn!&quot;)logger.error(&quot;This is log error!&quot;)logger.debug(&quot;This is log debug!&quot;)</code></pre><p>控制台输出：</p><p><img src="https://img-blog.csdnimg.cn/345214edaba24e988379399393ac0a7f.png" alt="03.png"></p><p>可以看到不需要手动设置，Loguru 会提前配置一些基础信息，自动输出时间、日志级别、模块名、行号等信息，而且根据等级的不同，还自动设置了不同的颜色，方便观察，真正做到了开箱即用！</p><hr><h3 id="add-remove"><a href="#add-remove" class="headerlink" title="add() / remove()"></a>add() / remove()</h3><p>如果想自定义日志级别，自定义日志格式，保存日志到文件该怎么办？与 logging 模块不同，不需要 Handler，不需要 Formatter，只需要一个 <code>add()</code> 函数就可以了，例如我们想把日志储存到文件：</p><pre><code class="python">from loguru import loggerlogger.add(&#39;test.log&#39;)logger.debug(&#39;this is a debug&#39;)</code></pre><p>我们不需要像 logging 模块一样再声明一个 FileHandler 了，就一行 <code>add()</code> 语句搞定，运行之后会发现目录下 test.log 里面同样出现了刚刚控制台输出的 debug 信息。 </p><p>与 <code>add()</code> 语句相反，<code>remove()</code> 语句可以删除我们添加的配置：</p><pre><code class="python">from loguru import loggerlog_file = logger.add(&#39;test.log&#39;)logger.debug(&#39;This is log debug!&#39;)logger.remove(log_file)logger.debug(&#39;This is another log debug!&#39;)</code></pre><p>此时控制台会输出两条 debug 信息：</p><pre><code class="bash">2021-10-19 13:53:36.610 | DEBUG    | __main__:&lt;module&gt;:86 - This is log debug!2021-10-19 13:53:36.611 | DEBUG    | __main__:&lt;module&gt;:88 - This is another log debug!</code></pre><p>而 test.log 日志文件里面只有一条 debug  信息，原因就在于我们在第二条 debug 语句之前使用了 <code>remove()</code> 语句。</p><hr><h3 id="完整参数"><a href="#完整参数" class="headerlink" title="完整参数"></a>完整参数</h3><p>Loguru 对输出到文件的配置有非常强大的支持，比如支持输出到多个文件，分级别分别输出，过大创建新文件，过久自动删除等等。 下面我们来详细看一下 <code>add()</code> 语句的详细参数：</p><p>基本语法：</p><pre><code class="python">add(sink, *, level=&#39;DEBUG&#39;, format=&#39;&lt;green&gt;&#123;time:YYYY-MM-DD HH:mm:ss.SSS&#125;&lt;/green&gt; | &lt;level&gt;&#123;level: &lt;8&#125;&lt;/level&gt; | &lt;cyan&gt;&#123;name&#125;&lt;/cyan&gt;:&lt;cyan&gt;&#123;function&#125;&lt;/cyan&gt;:&lt;cyan&gt;&#123;line&#125;&lt;/cyan&gt; - &lt;level&gt;&#123;message&#125;&lt;/level&gt;&#39;, filter=None, colorize=None, serialize=False, backtrace=True, diagnose=True, enqueue=False, catch=True, **kwargs)</code></pre><p><strong>基本参数释义：</strong></p><ul><li><strong>sink</strong>：可以是一个 file 对象，例如 <code>sys.stderr</code> 或 <code>open(&#39;file.log&#39;, &#39;w&#39;)</code>，也可以是 <code>str</code> 字符串或者 <code>pathlib.Path</code> 对象，即文件路径，也可以是一个方法，可以自行定义输出实现，也可以是一个 logging 模块的 Handler，比如 FileHandler、StreamHandler 等，还可以是 <a href="https://docs.python.org/3/glossary.html#term-coroutine-function">coroutine function</a>，即一个返回协程对象的函数等。</li><li><strong>level</strong>：日志输出和保存级别。</li><li><strong>format</strong>：日志格式模板。</li><li><strong>filter</strong>：一个可选的指令，用于决定每个记录的消息是否应该发送到 sink。</li><li><strong>colorize</strong>：格式化消息中包含的颜色标记是否应转换为用于终端着色的 ansi 代码，或以其他方式剥离。 如果没有，则根据 sink 是否为 tty（电传打字机缩写） 自动做出选择。</li><li><strong>serialize</strong>：在发送到 sink 之前，是否应首先将记录的消息转换为 JSON 字符串。</li><li><strong>backtrace</strong>：格式化的异常跟踪是否应该向上扩展，超出捕获点，以显示生成错误的完整堆栈跟踪。</li><li><strong>diagnose</strong>：异常跟踪是否应显示变量值以简化调试。建议在生产环境中设置 <code>False</code>，避免泄露敏感数据。</li><li><strong>enqueue</strong>：要记录的消息是否应在到达 sink 之前首先通过多进程安全队列，这在通过多个进程记录到文件时很有用，这样做的好处还在于使日志记录调用是非阻塞的。</li><li><strong>catch</strong>：是否应自动捕获 sink 处理日志消息时发生的错误，如果为 <code>True</code>，则会在 <code>sys.stderr</code> 上显示异常消息，但该异常不会传播到 sink，从而防止应用程序崩溃。</li><li>*<strong>*kwargs</strong>：仅对配置协程或文件接收器有效的附加参数（见下文）。</li></ul><p><strong>当且仅当 sink 是协程函数时，以下参数适用：</strong></p><ul><li><strong>loop</strong>：将在其中调度和执行异步日志记录任务的事件循环。如果为 <code>None</code>，将使用 <code>asyncio.get_event_loop()</code> 返回的循环。</li></ul><p><strong>当且仅当 sink 是文件路径时，以下参数适用：</strong></p><ul><li><strong>rotation</strong>：一种条件，指示何时应关闭当前记录的文件并开始新的文件。</li><li>**retention **：过滤旧文件的指令，在循环或程序结束期间会删除旧文件。</li><li><strong>compression</strong>：日志文件在关闭时应转换为的压缩或存档格式。</li><li><strong>delay</strong>：是在配置 sink 后立即创建文件，还是延迟到第一条记录的消息时再创建。默认为 <code>False</code>。</li><li><strong>mode</strong>：内置 <code>open()</code> 函数的打开模式，默认为 <code>a</code>（以追加模式打开文件）。</li><li><strong>buffering</strong>：内置 <code>open()</code> 函数的缓冲策略，默认为<code>1</code>（行缓冲文件）。</li><li><strong>encoding</strong>：内置 <code>open()</code> 函数的文件编码，如果 <code>None</code>，则默认为 <a href="https://docs.python.org/3/library/locale.html#locale.getpreferredencoding"><code>locale.getpreferredencoding()</code></a>。</li><li>*<strong>*kwargs</strong>：其他传递给内置 <code>open()</code> 函数的参数。</li></ul><p>这么多参数可以见识到 <code>add()</code> 函数的强大之处，仅仅一个函数就能实现 logging 模块的诸多功能，接下来介绍几个比较常用的方法。</p><hr><h3 id="rotation-日志文件分隔"><a href="#rotation-日志文件分隔" class="headerlink" title="rotation 日志文件分隔"></a>rotation 日志文件分隔</h3><p><code>add()</code> 函数的 rotation 参数，可以实现按照固定时间创建新的日志文件，比如设置每天 0 点新创建一个 log 文件：</p><pre><code class="python">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, rotation=&#39;00:00&#39;)</code></pre><p>设置超过 500 MB 新创建一个 log 文件：</p><pre><code class="python">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, rotation=&quot;500 MB&quot;)</code></pre><p>设置每隔一个周新创建一个 log 文件：</p><pre><code class="python">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, rotation=&#39;1 week&#39;)</code></pre><hr><h3 id="retention-日志保留时间"><a href="#retention-日志保留时间" class="headerlink" title="retention 日志保留时间"></a>retention 日志保留时间</h3><p><code>add()</code> 函数的 retention 参数，可以设置日志的最长保留时间，比如设置日志文件最长保留 15 天：</p><pre><code class="python">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, retention=&#39;15 days&#39;)</code></pre><p>设置日志文件最多保留 10 个：</p><pre><code class="python">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, retention=10)</code></pre><p>也可以是一个 <code>datetime.timedelta</code> 对象，比如设置日志文件最多保留 5 个小时：</p><pre><code class="python">import datetimefrom loguru import loggerlogger.add(&#39;runtime_&#123;time&#125;.log&#39;, retention=datetime.timedelta(hours=5))</code></pre><hr><h3 id="compression-日志压缩格式"><a href="#compression-日志压缩格式" class="headerlink" title="compression 日志压缩格式"></a>compression 日志压缩格式</h3><p><code>add()</code> 函数的 compression 参数，可以配置日志文件的压缩格式，这样可以更加节省存储空间，比如设置使用 zip 文件格式保存：</p><pre><code class="python">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, compression=&#39;zip&#39;)</code></pre><p>其格式支持：<code>gz</code>、<code>bz2</code>、<code>xz</code>、<code>lzma</code>、<code>tar</code>、<code>tar.gz</code>、<code>tar.bz2</code>、<code>tar.xz</code></p><hr><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>Loguru 在输出 log 的时候还提供了非常友好的字符串格式化功能，相当于 <code>str.format()</code>：</p><pre><code class="python">logger.info(&#39;If you are using Python &#123;&#125;, prefer &#123;feature&#125; of course!&#39;, 3.6, feature=&#39;f-strings&#39;)</code></pre><p>输出：</p><pre><code class="python">2021-10-19 14:59:06.412 | INFO     | __main__:&lt;module&gt;:3 - If you are using Python 3.6, prefer f-strings of course!</code></pre><hr><h3 id="异常追溯"><a href="#异常追溯" class="headerlink" title="异常追溯"></a>异常追溯</h3><p>在 Loguru 里可以直接使用它提供的装饰器就可以直接进行异常捕获，而且得到的日志是无比详细的：</p><pre><code class="python">from loguru import logger@logger.catchdef my_function(x, y, z):    # An error? It&#39;s caught anyway!    return 1 / (x + y + z)my_function(0, 0, 0)</code></pre><p>日志输出：</p><pre><code class="python">2021-10-19 15:04:51.675 | ERROR    | __main__:&lt;module&gt;:10 - An error has been caught in function &#39;&lt;module&gt;&#39;, process &#39;MainProcess&#39; (30456), thread &#39;MainThread&#39; (26268):Traceback (most recent call last):&gt; File &quot;D:/python3Project\test.py&quot;, line 10, in &lt;module&gt;    my_function(0, 0, 0)    └ &lt;function my_function at 0x014CDFA8&gt;  File &quot;D:/python3Project\test.py&quot;, line 7, in my_function    return 1 / (x + y + z)                │   │   └ 0                │   └ 0                └ 0ZeroDivisionError: division by zero</code></pre><p>在控制台的输出是这样的：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3b7fd75ef2a10a5a0dde917280d9224c.png" alt="04.png"></p><p>相比 Logging，Loguru 无论是在配置方面、日志输出样式还是异常追踪，都远优于 Logging，使用 Loguru 无疑能提升开发人员效率。本文仅介绍了一些常用的方法，想要详细了解可参考 <a href="https://loguru.readthedocs.io/">Loguru 官方文档</a>或关注 <a href="https://github.com/Delgan/loguru">Loguru GitHub</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;日志的重要性&quot;&gt;&lt;a href=&quot;#日志的重要性&quot; class=&quot;headerlink&quot; title=&quot;日志的重要性&quot;&gt;&lt;/a&gt;日志的重要性&lt;/h2&gt;&lt;p&gt;日志的作用非常重要，日志可以记录用户的操作、程序的异常，还可以为数据分析提供依据，日志的存在意义就是为了能够</summary>
      
    
    
    
    <category term="Python" scheme="https://www.itbob.cn/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>认识 SM1/SM2/SM3/SM4/SM7/SM9/ZUC 国密算法</title>
    <link href="https://www.itbob.cn/article/041/"/>
    <id>https://www.itbob.cn/article/041/</id>
    <published>2021-11-04T04:39:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><font color=#B01B15>简介</font></h2><p>国密即国家密码局认定的国产加密算法，爬虫工程师在做 JS 逆向的时候，会遇到各种各样的加密算法，其中 RSA、AES、SHA 等算法是最常见的，这些算法都是国外的，在我以前的文章里也有介绍：<a href="https://itrhx.blog.csdn.net/article/details/119250052">《史上最全总结！爬虫常见加密解密算法》</a></p><p>事实上从 2010 年开始，我国国家密码管理局就已经开始陆续发布了一系列国产加密算法，这其中就包括 SM1、SM2、SM3 、SM4、SM7、SM9、ZUC（祖冲之加密算法）等，SM 代表商密，即商业密码，是指用于商业的、不涉及国家秘密的密码技术。<strong>SM1 和 SM7 的算法不公开</strong>，其余算法都已成为 ISO/IEC 国际标准。</p><p>在这些国产加密算法中，**<font color=#B01B15>SM2、SM3、SM4 三种加密算法是比较常见的</font>**，在爬取部分 gov 网站时，也可能会遇到这些算法，所以作为爬虫工程师是有必要了解一下这些算法的，如下图所示某 gov 网站就使用了 SM2 和 SM4 加密算法：</p><p><img src="https://img-blog.csdnimg.cn/758cb19d1fbc4ec5ad7cc33781c2f34e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVFJIWCDigKIg6bKN5YuD,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"></p><hr><h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a><font color=#B01B15>算法概述</font></h2><table><thead><tr><th align="center">算法名称</th><th align="center">算法类别</th><th align="center">应用领域</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">SM1</td><td align="center">对称（分组）加密算法</td><td align="center">芯片</td><td align="center">分组长度、密钥长度均为 128 比特</td></tr><tr><td align="center">SM2</td><td align="center">非对称（基于椭圆曲线 ECC）加密算法</td><td align="center">数据加密</td><td align="center">ECC 椭圆曲线密码机制 256 位，相比 RSA 处理速度快，消耗更少</td></tr><tr><td align="center">SM3</td><td align="center">散列（hash）函数算法</td><td align="center">完整性校验</td><td align="center">安全性及效率与 SHA-256 相当，压缩函数更复杂</td></tr><tr><td align="center">SM4</td><td align="center">对称（分组）加密算法</td><td align="center">数据加密和局域网产品</td><td align="center">分组长度、密钥长度均为 128 比特，计算轮数多</td></tr><tr><td align="center">SM7</td><td align="center">对称（分组）加密算法</td><td align="center">非接触式 IC 卡</td><td align="center">分组长度、密钥长度均为 128 比特</td></tr><tr><td align="center">SM9</td><td align="center">标识加密算法（IBE）</td><td align="center">端对端离线安全通讯</td><td align="center">加密强度等同于 3072 位密钥的 RSA 加密算法</td></tr><tr><td align="center">ZUC</td><td align="center">对称（序列）加密算法</td><td align="center">移动通信 4G 网络</td><td align="center">流密码</td></tr></tbody></table><hr><h2 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a><font color=#B01B15>算法详解</font></h2><h3 id="SM1-分组加密算法"><a href="#SM1-分组加密算法" class="headerlink" title="SM1 分组加密算法"></a>SM1 分组加密算法</h3><p>SM1 为分组加密算法，对称加密，分组长度和密钥长度都为 128 位，故对消息进行加解密时，若消息长度过长，需要进行分组，要消息长度不足，则要进行填充。算法安全保密强度及相关软硬件实现性能与 AES 相当，该算法不公开，仅以 IP 核的形式存在于芯片中，调用该算法时，需要通过加密芯片的接口进行调用，采用该算法已经研制了系列芯片、智能 IC 卡、智能密码钥匙、加密卡、加密机等安全产品，广泛应用于电子政务、电子商务及国民经济的各个应用领域（包括国家政务通、警务通等重要领域），一般了解的人比较少，爬虫工程师也不会遇到这种加密算法。</p><h3 id="椭圆曲线公钥加密算法"><a href="#椭圆曲线公钥加密算法" class="headerlink" title="椭圆曲线公钥加密算法"></a>椭圆曲线公钥加密算法</h3><p>SM2 为椭圆曲线（ECC）公钥加密算法，非对称加密，SM2 算法和 RSA 算法都是公钥加密算法，SM2 算法是一种更先进安全的算法，在我们国家商用密码体系中被用来替换 RSA 算法，在不少 gov 网站会见到此类加密算法。我国学者对椭圆曲线密码的研究从 20 世纪 80 年代开始，目前已取得不少成果，SM2 椭圆曲线公钥密码算法比 RSA 算法有以下优势：</p><table><thead><tr><th align="center"></th><th align="center">SM2</th><th align="center">RSA</th></tr></thead><tbody><tr><td align="center">安全性</td><td align="center">256 位 SM2 强度已超过 RSA-2048</td><td align="center">一般</td></tr><tr><td align="center">算法结构</td><td align="center">基本椭圆曲线（ECC）</td><td align="center">基于特殊的可逆模幂运算</td></tr><tr><td align="center">计算复杂度</td><td align="center">完全指数级</td><td align="center">亚指数级</td></tr><tr><td align="center">存储空间（密钥长度）</td><td align="center">192-256 bit</td><td align="center">2048-4096 bit</td></tr><tr><td align="center">秘钥生成速度</td><td align="center">较 RSA 算法快百倍以上</td><td align="center">慢</td></tr><tr><td align="center">解密加密速度</td><td align="center">较快</td><td align="center">一般</td></tr></tbody></table><h3 id="杂凑算法"><a href="#杂凑算法" class="headerlink" title="杂凑算法"></a>杂凑算法</h3><p>SM3 为密码杂凑算法，采用密码散列（hash）函数标准，用于替代 MD5/SHA-1/SHA-2 等国际算法，是在 SHA-256 基础上改进实现的一种算法，消息分组长度为 512 位，摘要值长度为 256 位，其中使用了异或、模、模加、移位、与、或、非运算，由填充、迭代过程、消息扩展和压缩函数所构成。在商用密码体系中，SM3 主要用于数字签名及验证、消息认证码生成及验证、随机数生成等。据国家密码管理局表示，其安全性及效率要高于 MD5 算法和 SHA-1 算法，与 SHA-256 相当。</p><h3 id="分组加密算法"><a href="#分组加密算法" class="headerlink" title="分组加密算法"></a>分组加密算法</h3><p>SM4 为无线局域网标准的分组加密算法，对称加密，用于替代 DES/AES 等国际算法，SM4 算法与 AES 算法具有相同的密钥长度和分组长度，均为 128 位，故对消息进行加解密时，若消息长度过长，需要进行分组，要消息长度不足，则要进行填充。加密算法与密钥扩展算法都采用 32 轮非线性迭代结构，解密算法与加密算法的结构相同，只是轮密钥的使用顺序相反，解密轮密钥是加密轮密钥的逆序。</p><table><thead><tr><th></th><th>SM4</th><th>DES</th><th>AES</th></tr></thead><tbody><tr><td>计算轮数</td><td>32</td><td>16（3DES 为 16*3）</td><td>10/12/14</td></tr><tr><td>密码部件</td><td>S 盒、非线性变换、线性变换、合成变换</td><td>标准算术和逻辑运算、先替换后置换，不含线性变换</td><td>S 盒、行移位变换、列混合变换、圈密钥加变换（AddRoundKey）</td></tr></tbody></table><h3 id="分组加密算法-1"><a href="#分组加密算法-1" class="headerlink" title="分组加密算法"></a>分组加密算法</h3><p>SM7 为分组加密算法，对称加密，该算法不公开，应用包括身份识别类应用（非接触式 IC 卡、门禁卡、工作证、参赛证等），票务类应用（大型赛事门票、展会门票等），支付与通卡类应用（积分消费卡、校园一卡通、企业一卡通等）。爬虫工程师基本上不会遇到此类算法。</p><h3 id="标识加密算法"><a href="#标识加密算法" class="headerlink" title="标识加密算法"></a>标识加密算法</h3><p>SM9 为标识加密算法（Identity-Based Cryptography），非对称加密，标识加密将用户的标识（如微信号、邮件地址、手机号码、QQ 号等）作为公钥，省略了交换数字证书和公钥过程，使得安全系统变得易于部署和管理，适用于互联网应用的各种新兴应用的安全保障，如基于云技术的密码服务、电子邮件安全、智能终端保护、物联网安全、云存储安全等等。这些安全应用可采用手机号码或邮件地址作为公钥，实现数据加密、身份认证、通话加密、通道加密等。在商用密码体系中，SM9 主要用于用户的身份认证，据新华网公开报道，SM9 的加密强度等同于 3072 位密钥的 RSA 加密算法。</p><h3 id="祖冲之算法"><a href="#祖冲之算法" class="headerlink" title="祖冲之算法"></a>祖冲之算法</h3><p>ZUC 为流密码算法，对称加密，该机密性算法可适用于 3GPP LTE 通信中的加密和解密，该算法包括祖冲之算法（ZUC）、机密性算法（128-EEA3）和完整性算法（128-EIA3）三个部分。已经被国际组织 3GPP 推荐为 4G 无线通信的第三套国际加密和完整性标准的候选算法。</p><hr><h2 id="编程语言实现"><a href="#编程语言实现" class="headerlink" title="编程语言实现"></a><font color=#B01B15>编程语言实现</font></h2><h3 id="Python-语言实现"><a href="#Python-语言实现" class="headerlink" title="Python 语言实现"></a>Python 语言实现</h3><p>在 Python 里面并没有比较官方的库来实现国密算法，这里仅列出了其中两个较为完善的第三方库，需要注意的是，SM1 和 SM7 算法不公开，目前大多库仅实现了 SM2、SM3、SM4 三种密算法。</p><ul><li>snowland-smx-python：<a href="https://gitee.com/snowlandltd/snowland-smx-python">https://gitee.com/snowlandltd/snowland-smx-python</a></li><li>gmssl：<a href="https://github.com/duanhongyi/gmssl">https://github.com/duanhongyi/gmssl</a></li><li>gmssl-python：<a href="https://github.com/gongxian-ding/gmssl-python">https://github.com/gongxian-ding/gmssl-python</a></li></ul><p>其中 gmssl-python 是 gmssl 的改进版，gmssl-python 新增支持了 SM9 算法，不过截止本文编写时，gmssl-python 并未发布 pypi，也未 PR 到 gmssl，使用 <code>pip install gmssl</code> 安装的 gmssl 不支持 SM9 算法。若要使用 SM9 算法，可下载 gmssl-python 源码手动安装。</p><p>以 gmssl 的 SM2 算法为例，实现如下（其他算法和详细用法可参考其官方文档）：</p><p>SM2 加密（encrypt）和解密（decrypt）：</p><pre><code class="python">from gmssl import sm2# 16 进制的公钥和私钥private_key = &#39;00B9AB0B828FF68872F21A837FC303668428DEA11DCD1B24429D0C99E24EED83D5&#39;public_key = &#39;B9C9A6E04E9C91F7BA880429273747D7EF5DDEB0BB2FF6317EB00BEF331A83081A6994B8993F3F5D6EADDDB81872266C87C018FB4162F5AF347B483E24620207&#39;sm2_crypt = sm2.CryptSM2(public_key=public_key, private_key=private_key)# 待加密数据和加密后数据为 bytes 类型data = b&quot;this is the data to be encrypted&quot;enc_data = sm2_crypt.encrypt(data)dec_data = sm2_crypt.decrypt(enc_data)print(&#39;enc_data: &#39;, enc_data.hex())print(&#39;dec_data: &#39;, dec_data)# enc_data:  3cb96dd2e0b6c24df8e22a5da3951d061a6ee6ce99f46a446426feca83e501073288b1553ca8d91fad79054e26696a27c982492466dafb5ed06a573fb09947f2aed8dfae243b095ab88115c584bb6f0814efe2f338a00de42b244c99698e81c7913c1d82b7609557677a36681dd10b646229350ad0261b51ca5ed6030d660947# dec_data:  b&#39;this is the data to be encrypted&#39;</code></pre><p>SM2 签名（sign）和校验（verify）：</p><pre><code class="python">from gmssl import sm2, func# 16 进制的公钥和私钥private_key = &#39;00B9AB0B828FF68872F21A837FC303668428DEA11DCD1B24429D0C99E24EED83D5&#39;public_key = &#39;B9C9A6E04E9C91F7BA880429273747D7EF5DDEB0BB2FF6317EB00BEF331A83081A6994B8993F3F5D6EADDDB81872266C87C018FB4162F5AF347B483E24620207&#39;sm2_crypt = sm2.CryptSM2(public_key=public_key, private_key=private_key)# 待签名数据为 bytes 类型data = b&quot;this is the data to be signed&quot;random_hex_str = func.random_hex(sm2_crypt.para_len)#  16 进制sign = sm2_crypt.sign(data, random_hex_str)verify = sm2_crypt.verify(sign, data)print(&#39;sign: &#39;, sign)print(&#39;verify: &#39;, verify)# sign:  45cfe5306b1a87cf5d0034ef6712babdd1d98547e75bcf89a17f3bcb617150a3f111ab05597601bab8c41e2b980754b74ebe9a169a59db37d549569910ae273a# verify:  True</code></pre><h3 id="JavaScript-语言实现"><a href="#JavaScript-语言实现" class="headerlink" title="JavaScript 语言实现"></a>JavaScript 语言实现</h3><p>在 JavaScript 中已有比较成熟的实现库，这里推荐 sm-crypto，目前支持 SM2、SM3 和 SM4，需要注意的是，SM2 非对称加密的结果由 C1、C2、C3 三部分组成，其中 C1 是生成随机数的计算出的椭圆曲线点，C2 是密文数据，C3 是 SM3 的摘要值，最开始的国密标准的结果是按 C1C2C3 顺序的，新标准的是按 C1C3C2 顺序存放的，sm-crypto 支持设置 cipherMode，也就是 C1C2C3 的排列顺序。</p><p>sm-crypto：<a href="https://www.npmjs.com/package/sm-crypto">https://www.npmjs.com/package/sm-crypto</a></p><p>以 SM2 算法为例，实现如下（其他算法和详细用法可参考其官方文档）：</p><p>SM2 加密（encrypt）和解密（decrypt）：</p><pre><code class="javascript">const sm2 = require(&#39;sm-crypto&#39;).sm2// 1 - C1C3C2，0 - C1C2C3，默认为1const cipherMode = 1// 获取密钥对let keypair = sm2.generateKeyPairHex()let publicKey = keypair.publicKey   // 公钥let privateKey = keypair.privateKey // 私钥let msgString = &quot;this is the data to be encrypted&quot;let encryptData = sm2.doEncrypt(msgString, publicKey, cipherMode)    // 加密结果let decryptData = sm2.doDecrypt(encryptData, privateKey, cipherMode) // 解密结果console.log(&quot;encryptData: &quot;, encryptData)console.log(&quot;decryptData: &quot;, decryptData)// encryptData:  ddf261103fae06d0efe20ea0fe0d82bcc170e8efd8eeae24e9559b3835993f0ed2acb8ba6782fc21941ee74ca453d77664a5cb7dbb91517e6a3b0c27db7ce587ae7af54f8df48d7fa822b7062e2af66c112aa57de94d12ba28e5ba96bf4439d299b41da4a5282d054696adc64156d248049d1eb1d0af28d76b542fe8a95d427e// decryptData:  this is the data to be encrypted</code></pre><p>SM2 签名（sign）和校验（verify）：</p><pre><code class="javascript">const sm2 = require(&#39;sm-crypto&#39;).sm2// 获取密钥对let keypair = sm2.generateKeyPairHex()let publicKey = keypair.publicKey   // 公钥let privateKey = keypair.privateKey // 私钥// 纯签名 + 生成椭圆曲线点let msgString = &quot;this is the data to be signed&quot;let sigValueHex = sm2.doSignature(msgString, privateKey)                    // 签名let verifyResult = sm2.doVerifySignature(msgString, sigValueHex, publicKey) // 验签结果console.log(&quot;sigValueHex: &quot;, sigValueHex)console.log(&quot;verifyResult: &quot;, verifyResult)// sigValueHex:  924cbb9f2b5adb554ef77129ff1e3a00b2da42017ad3ec2f806d824a77646987ba8c8c4fb94576c38bc11ae69cc98ebbb40b5d47715171ec7dcea913dfc6ccc1// verifyResult:  true</code></pre><h3 id="其他语言实现以及参考资料"><a href="#其他语言实现以及参考资料" class="headerlink" title="其他语言实现以及参考资料"></a>其他语言实现以及参考资料</h3><ul><li>Java 语言实现：<ul><li><a href="https://github.com/bcgit/bc-csharp">https://github.com/bcgit/bc-csharp</a></li><li><a href="https://github.com/xjfuuu/SM2_SM3_SM4Encrypt">https://github.com/xjfuuu/SM2_SM3_SM4Encrypt</a></li></ul></li><li>Go 语言实现：<a href="https://github.com/tjfoc/gmsm">https://github.com/tjfoc/gmsm</a></li><li>开源国密算法工具箱：<a href="http://gmssl.org/">http://gmssl.org/</a></li><li>国密算法源代码下载：<a href="http://www.scctc.org.cn/templates/Download/index.aspx?nodeid=71">http://www.scctc.org.cn/templates/Download/index.aspx?nodeid=71</a></li><li>国家密码管理局：<a href="https://www.sca.gov.cn/">https://www.sca.gov.cn/</a></li><li>密码标准委员会：<a href="http://www.gmbz.org.cn/">http://www.gmbz.org.cn/</a></li></ul><hr><h2 id="附：GM-T-密码行业标准"><a href="#附：GM-T-密码行业标准" class="headerlink" title="附：GM/T 密码行业标准"></a><font color=#B01B15>附：GM/T 密码行业标准</font></h2><ul><li><a href="http://www.gmbz.org.cn/main/viewfile/20180117202410524608.html">GM/T 0001.1-2012：祖冲之序列密码算法：第1部分：算法描述</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180107233806310781.html">GM/T 0001.2-2012：祖冲之序列密码算法：第2部分：基于祖冲之算法的机密性算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180107234058336917.html">GM/T 0001.3-2012：祖冲之序列密码算法：第3部分：基于祖冲之算法的完整性算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180108015515787986.html">GM/T 0003.1-2012：SM2 椭圆曲线公钥密码算法第1部分：总则</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180108023346264349.html">GM/T 0003.2-2012：SM2 椭圆曲线公钥密码算法第2部分：数字签名算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180108023456003485.html">GM/T 0003.3-2012：SM2 椭圆曲线公钥密码算法第3部分：密钥交换协议</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180108023602687857.html">GM/T 0003.4-2012：SM2 椭圆曲线公钥密码算法第4部分：公钥加密算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/2018010802371372251.html">GM/T 0003.5-2012：SM2 椭圆曲线公钥密码算法第5部分：参数定义</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180108023812835219.html">GM/T 0004-2012：SM3 密码杂凑算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180108015408199368.html">GM/T 0002-2012：SM4 分组密码算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/2018011002473633053.html">GM/T 0044.1-2016：SM9 标识密码算法 第1部分：总则</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180110024900801385.html">GM/T 0044.2-2016：SM9 标识密码算法 第2部分：数字签名算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180110025010004565.html">GM/T 0044.3-2016：SM9 标识密码算法 第3部分：密钥交换协议</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180110025115084846.html">GM/T 0044.4-2016：SM9 标识密码算法 第4部分：密钥封装机制和公钥加密算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180110025229918536.html">GM/T 0044.5-2016：SM9 标识密码算法 第5部分：参数定义</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;font color=#B01B15&gt;简介&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;国密即国家密码局认定的国产加密算法，爬虫工程师在做 JS 逆向的时候，会遇到各种各样的</summary>
      
    
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91/"/>
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>爬虫逆向基础，理解 JavaScript 模块化编程 webpack</title>
    <link href="https://www.itbob.cn/article/040/"/>
    <id>https://www.itbob.cn/article/040/</id>
    <published>2021-10-23T23:00:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><font color=#FFB11B>简介</font></h2><p>在分析一些站点的 JavaScript 代码时，比较简单的代码，函数通常都是一个一个的，例如：</p><pre><code class="javascript">function a() &#123;console.log(&quot;a&quot;)&#125;function b() &#123;console.log(&quot;a&quot;)&#125;function c() &#123;console.log(&quot;a&quot;)&#125;</code></pre><p>但是稍微复杂一点的站点，通常会遇到类似如下的代码结构：</p><pre><code class="javascript">!function(i) &#123;    function n(t) &#123;        return i[t].call(a, b, c, d)    &#125;&#125;([    function(t, e) &#123;&#125;,     function(t, e, n) &#123;&#125;,     function(t, e, r) &#123;&#125;,     function(t, e, o) &#123;&#125;]);</code></pre><p>这种写法在 JavaScript 中很常见，对于熟悉 JavaScript 的人来说可能非常简单，但是爬虫工程师大多数都是用 Python 或者 Java 来写代码的，看到这种语法就有可能懵了，由于在剥离 JS 加密代码时会经常遇到，所以理解这种语法对于爬虫工程师来说是非常重要的。</p><p>这种写法貌似没有官方的名称，相当于进行了模块化编程，因此大多数人称其为 webpack，上面的示例看起来比较费劲，简单优化一下：</p><pre><code class="javascript">!function (allModule) &#123;    function useModule(whichModule) &#123;        allModule[whichModule].call(null, &quot;hello world!&quot;);    &#125;    useModule(0)&#125;([    function module0(param) &#123;console.log(&quot;module0: &quot; + param)&#125;,    function module1(param) &#123;console.log(&quot;module1: &quot; + param)&#125;,    function module2(param) &#123;console.log(&quot;module2: &quot; + param)&#125;,]);</code></pre><p>运行以上代码，会输出 <code>module0: hello world!</code>，相信通过浅显易懂的变量名和函数名，应该就可以看懂大致含义了，调用 <code>useModule(0)</code>，从所有函数里选择第一个，将 <code>hello world!</code> 传递给 <code>module0</code> 并输出。</p><p>仔细观察以上代码，我们会发现主要用到了 <code>!function()&#123;&#125;()</code> 和 <code>function.call()</code> 语法，接下来就一一介绍一下。</p><hr><h2 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a><font color=#FFB11B>函数声明与函数表达式</font></h2><p>在 ECMAScript（JavaScript 的一个标准）中，有两个最常用的创建函数对象的方法，即使用函数声明或者函数表达式，ECMAScript 规范明确了一点，即函数声明必须始终带有一个标识符，也就是我们所说的函数名，而函数表达式则可以省略。</p><p>函数声明，会给函数指定一个名字，会在代码执行以前被加载到作用域中，所以<strong>调用函数在函数声明之前或之后都是可以的</strong>：</p><pre><code class="javascript">test(&quot;Hello World!&quot;)function test(arg) &#123;    console.log(arg)&#125;</code></pre><p>函数表达式，创建一个匿名函数，然后将这个匿名函数赋给一个变量，在代码执行到函数表达式的时候才会有定义，所以<strong>调用函数在函数表达式之后才能正确运行</strong>，否则是会报错的：</p><pre><code class="javascript">var test = function (arg) &#123;    console.log(arg)&#125;test(&quot;Hello World!&quot;)</code></pre><hr><h2 id="IIFE-立即调用函数表达式"><a href="#IIFE-立即调用函数表达式" class="headerlink" title="IIFE 立即调用函数表达式"></a><font color=#FFB11B>IIFE 立即调用函数表达式</font></h2><p>IIFE 全称 Immediately-invoked Function Expressions，译为立即调用函数表达式，也称为自执行函数、立即执行函数、自执行匿名函数等，IIFE 是一种语法，这种模式本质上就是函数表达式（命名的或者匿名的）在创建后立即执行。当函数变成立即执行的函数表达式时，表达式中的变量不能从外部访问。IIFE 主要用来隔离作用域，避免污染。</p><hr><h3 id="IIFE-基本语法"><a href="#IIFE-基本语法" class="headerlink" title="IIFE 基本语法"></a>IIFE 基本语法</h3><p>IIFE 的写法非常灵活，主要有以下几种格式：</p><p>1、匿名函数前面加上一元操作符，后面加上 <code>()</code>：</p><pre><code class="javascript">!function () &#123;    console.log(&quot;I AM IIFE&quot;)&#125;();-function () &#123;    console.log(&quot;I AM IIFE&quot;)&#125;();+function () &#123;    console.log(&quot;I AM IIFE&quot;)&#125;();~function () &#123;    console.log(&quot;I AM IIFE&quot;)&#125;();</code></pre><p>2、匿名函数后面加上 <code>()</code>，然后再用 <code>()</code> 将整个括起来：</p><pre><code class="javascript">(function () &#123;    console.log(&quot;I AM IIFE&quot;)&#125;());</code></pre><p>3、先用 <code>()</code> 将匿名函数括起来，再在后面加上 <code>()</code>：</p><pre><code class="javascript">(function () &#123;    console.log(&quot;I AM IIFE&quot;)&#125;)();</code></pre><p>4、使用箭头函数表达式，先用 <code>()</code> 将箭头函数表达式括起来，再在后面加上 <code>()</code>：</p><pre><code class="javascript">(() =&gt; &#123;  console.log(&quot;I AM IIFE&quot;)&#125;)()</code></pre><p>5、匿名函数前面加上 <code>void</code> 关键字，后面加上 <code>()</code>， <code>void</code> 指定要计算或运行一个表达式，但是不返回值：</p><pre><code class="javascript">void function () &#123;    console.log(&quot;I AM IIFE&quot;)&#125;();</code></pre><p>有的时候，我们还有可能见到立即执行函数前面后分号的情况，例如：</p><pre><code class="javascript">;(function () &#123;    console.log(&quot;I AM IIFE&quot;)&#125;());!function () &#123;    console.log(&quot;I AM IIFE&quot;)&#125;()</code></pre><p>这是因为立即执行函数通常作为一个单独模块使用一般是没有问题的，但是还是建议在立即执行函数前面或者后面加上分号，这样可以有效地与前面或者后面的代码进行隔离，否则可能出现意想不到的错误。</p><hr><h3 id="IIFE-参数传递"><a href="#IIFE-参数传递" class="headerlink" title="IIFE 参数传递"></a>IIFE 参数传递</h3><p>将参数放在末尾的 <code>()</code> 里即可实现参数传递：</p><pre><code class="javascript">var text = &quot;I AM IIFE&quot;;(function (param) &#123;    console.log(param)&#125;)(text);// I AM IIFE</code></pre><pre><code class="javascript">var dict = &#123;name: &quot;Bob&quot;, age: &quot;20&quot;&#125;;(function () &#123;    console.log(dict.name);&#125;)(dict);// Bob</code></pre><pre><code class="javascript">var list = [1, 2, 3, 4, 5];(function () &#123;    var sum = 0;    for (var i = 0; i &lt; list.length; i++) &#123;        sum += list[i];    &#125;    console.log(sum);&#125;)(list);// 15</code></pre><hr><h2 id="Function-prototype-call-apply-bind"><a href="#Function-prototype-call-apply-bind" class="headerlink" title="Function.prototype.call() / apply() / bind()"></a><font color=#FFB11B>Function.prototype.call() / apply() / bind()</font></h2><p><code>Function.prototype.call()</code>、<code>Function.prototype.apply()</code>、<code>Function.prototype.bind()</code> 都是比较常用的方法。它们的作用一模一样，即<strong>改变函数中的 <code>this</code> 指向</strong>，它们的区别如下：</p><ul><li><code>call()</code> 方法会立即执行这个函数，接受一个多个参数，参数之间用逗号隔开；</li><li><code>apply()</code> 方法会立即执行这个函数，接受一个包含多个参数的数组；</li><li><code>bind()</code> 方法不会立即执行这个函数，返回的是一个修改过后的函数，便于稍后调用，接受的参数和 <code>call()</code> 一样。</li></ul><hr><h3 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h3><p><code>call()</code> 方法接受多个参数，第一个参数 thisArg 指定了函数体内 this 对象的指向，如果这个函数处于非严格模式下，指定为 null 或 undefined 时会自动替换为指向全局对象（浏览器中就是 window 对象），在严格模式下，函数体内的 this 还是为 null。从第二个参数开始往后，每个参数被依次传入函数，基本语法如下：</p><pre><code class="javascript">function.call(thisArg, arg1, arg2, ...)</code></pre><p>示例：</p><pre><code class="javascript">function test(a, b, c) &#123;    console.log(a + b + c)&#125;test.call(null, 1, 2, 3)  // 6</code></pre><pre><code class="javascript">function test() &#123;    console.log(this.firstName + &quot; &quot; + this.lastName)&#125;var data = &#123;firstName: &quot;John&quot;, lastName: &quot;Doe&quot;&#125;test.call(data)  // John Doe</code></pre><hr><h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p><code>apply()</code> 方法接受两个参数，第一个参数 thisArg 与 <code>call()</code> 方法一致，第二个参数为一个带下标的集合，从 ECMAScript 第5版开始，这个集合可以为数组，也可以为类数组，<code>apply()</code> 方法把这个集合中的元素作为参数传递给被调用的函数，基本语法如下：</p><pre><code class="javascript">function.apply(thisArg, [arg1, arg2, ...])</code></pre><p>示例：</p><pre><code class="javascript">function test(a, b, c) &#123;    console.log(a + b + c)&#125;test.apply(null, [1, 2, 3])  // 6</code></pre><pre><code class="javascript">function test() &#123;    console.log(this.firstName + &quot; &quot; + this.lastName)&#125;var data = &#123;firstName: &quot;John&quot;, lastName: &quot;Doe&quot;&#125;test.apply(data)  // John Doe</code></pre><hr><h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p><code>bind()</code> 方法和 <code>call()</code> 接受的参数是相同的，只不过 <code>bind()</code> 返回的是一个函数，基本语法如下：</p><pre><code class="javascript">function.bind(thisArg, arg1, arg2, ...)</code></pre><p>示例：</p><pre><code class="javascript">function test(a, b, c) &#123;    console.log(a + b + c)&#125;test.bind(null, 1, 2, 3)()  // 6</code></pre><pre><code class="javascript">function test() &#123;    console.log(this.firstName + &quot; &quot; + this.lastName)&#125;var data = &#123;firstName: &quot;John&quot;, lastName: &quot;Doe&quot;&#125;test.bind(data)()  // John Doe</code></pre><hr><h2 id="理解-webpack"><a href="#理解-webpack" class="headerlink" title="理解 webpack"></a><font color=#FFB11B>理解 webpack</font></h2><p>有了以上知识后，我们再来理解一下模块化编程，也就是前面所说的 webpack 写法：</p><pre><code class="javascript">!function (allModule) &#123;    function useModule(whichModule) &#123;        allModule[whichModule].call(null, &quot;hello world!&quot;);    &#125;    useModule(0)&#125;([    function module0(param) &#123;console.log(&quot;module0: &quot; + param)&#125;,    function module1(param) &#123;console.log(&quot;module1: &quot; + param)&#125;,    function module2(param) &#123;console.log(&quot;module2: &quot; + param)&#125;,]);</code></pre><p>首先，这整个代码是一个 IIFE 立即调用函数表达式，传递的参数是一个数组，里面包含三个方法，分别是 <code>module0</code>、<code>module1</code> 和 <code>module2</code>，可以将其视为三个模块，那么 IIFE 接受的参数 <code>allModule</code> 就包含这三个模块，IIFE 里面还包含一个函数 <code>useModule()</code>，可以将其视为模块加载器，即要使用哪个模块，示例中 <code>useModule(0)</code> 即表示调用第一个模块，函数里面使用 <code>call()</code> 方法改变函数中的 <code>this</code> 指向并传递参数，调用相应的模块进行输出。</p><hr><h2 id="改写-webpack"><a href="#改写-webpack" class="headerlink" title="改写 webpack"></a><font color=#FFB11B>改写 webpack</font></h2><p>对于我们爬虫逆向当中经常遇到的 webpack 模块化的写法，可以很容易对其进行改写，以下以一段加密代码为例：</p><pre><code class="javascript">CryptoJS = require(&quot;crypto-js&quot;)!function (func) &#123;    function acvs() &#123;        var kk = func[1].call(null, 1e3);        var data = &#123;            r: &quot;I LOVE PYTHON&quot;,            e: kk,            i: &quot;62bs819idl00oac2&quot;,            k: &quot;0123456789abcdef&quot;        &#125;        return func[0].call(data);    &#125;    console.log(&quot;加密文本：&quot; + acvs())    function odsc(account) &#123;        var cr = false;        var regExp = /(^\d&#123;7,8&#125;$)|(^0\d&#123;10,12&#125;$)/;        if (regExp.test(account)) &#123;            cr = true;        &#125;        return cr;    &#125;    function mkle(account) &#123;        var cr = false;        var regExp = /^([a-zA-Z0-9_\.\-\+])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]&#123;2,4&#125;)+$/;        if (regExp.test(account)) &#123;            cr = true;        &#125;        return cr;    &#125;&#125;([    function () &#123;        for (var n = &quot;&quot;, t = 0; t &lt; this.r.length; t++) &#123;            var o = this.e ^ this.r.charCodeAt(t);            n += String.fromCharCode(o)        &#125;        return encodeURIComponent(n)    &#125;,    function (x) &#123;        return Math.ceil(x * Math.random())    &#125;,    function (e) &#123;        var a = CryptoJS.MD5(this.k);        var c = CryptoJS.enc.Utf8.parse(a);        var d = CryptoJS.AES.encrypt(e, c, &#123;            iv: this.i        &#125;);        return d + &quot;&quot;    &#125;,    function (e) &#123;        var b = CryptoJS.MD5(this.k);        var d = CryptoJS.enc.Utf8.parse(b);        var a = CryptoJS.AES.decrypt(e, d, &#123;            iv: this.i        &#125;).toString(CryptoJS.enc.Utf8);        return a    &#125;]);</code></pre><p>可以看到关键的加密入口函数是 <code>acvs()</code>，<code>acvs()</code> 里面又调用了 IIFE 参数列表里面的第一个和第二个函数，剩下的其他函数都是干扰项，而第一个函数中用到了 r 和 e 参数，将其直接传入即可，最终改写如下：</p><pre><code class="javascript">function a(r, e) &#123;    for (var n = &quot;&quot;, t = 0; t &lt; r.length; t++) &#123;        var o = e ^ r.charCodeAt(t);        n += String.fromCharCode(o)    &#125;    return encodeURIComponent(n)&#125;function b(x) &#123;    return Math.ceil(x * Math.random())&#125;function acvs() &#123;    var kk = b(1e3);    var r = &quot;I LOVE PYTHON&quot;;    return a(r, kk);&#125;console.log(&quot;加密文本：&quot; + acvs())</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;font color=#FFB11B&gt;简介&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;在分析一些站点的 JavaScript 代码时，比较简单的代码，函数通常都是一个一个的</summary>
      
    
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91/"/>
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91/"/>
    
    <category term="webpack" scheme="https://www.itbob.cn/tags/webpack/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>爬虫常见加密解密算法总结</title>
    <link href="https://www.itbob.cn/article/039/"/>
    <id>https://www.itbob.cn/article/039/</id>
    <published>2021-07-28T07:25:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文总结了在爬虫中常见的各种加密算法、编码算法的原理、在 JavaScript 中和 Python 中的基本实现方法，遇到 JS 加密的时候可以快速还原加密过程，有的网站在加密的过程中可能还经过了其他处理，但是大致的方法是一样的。</p><p>常见加密算法：</p><ol><li>对称加密（加密解密密钥相同）：DES、3DES、AES、RC4、Rabbit</li><li>非对称加密（区分公钥和私钥）：RSA、DSA、ECC</li><li>消息摘要算法/签名算法：MD5、SHA、HMAC、PBKDF2</li></ol><p>常见编码算法：Base64</p><h3 id="JavaScript-加密解密模块"><a href="#JavaScript-加密解密模块" class="headerlink" title="JavaScript 加密解密模块"></a>JavaScript 加密解密模块</h3><h4 id="Crypto-JS"><a href="#Crypto-JS" class="headerlink" title="Crypto-JS"></a>Crypto-JS</h4><p>Crypto-JS 支持 MD5、SHA、RIPEMD-160、HMAC、PBKDF2、AES、DES、3DES（Triple DES）、Rabbit、RC4 等，<strong>不支持 RSA、ECC</strong>，是应用比较广的加密模块，使用命令 <code>npm install crypto-js</code> 安装。</p><p>参考资料：</p><ul><li><p>Crypto-JS 文档：<a href="https://cryptojs.gitbook.io/docs/">https://cryptojs.gitbook.io/docs/</a></p></li><li><p>Crypto-JS Github：<a href="https://github.com/brix/crypto-js">https://github.com/brix/crypto-js</a></p></li></ul><h4 id="Node-RSA"><a href="#Node-RSA" class="headerlink" title="Node-RSA"></a>Node-RSA</h4><p>Node-RSA 对  RSA 算法提供了支持，使用命令 <code>npm install node-rsa </code> 安装。</p><p>参考资料：Node-RSA Github：<a href="https://github.com/rzcoder/node-rsa">https://github.com/rzcoder/node-rsa</a></p><h4 id="JSEncrypt"><a href="#JSEncrypt" class="headerlink" title="JSEncrypt"></a>JSEncrypt</h4><p>参考资料：JSEncrypt 对  RSA 算法提供了更加全面的支持，使用命令 <code>npm install jsencrypt </code> 安装。</p><ul><li>JSEncrypt 文档：<a href="http://travistidwell.com/jsencrypt/">http://travistidwell.com/jsencrypt/</a></li><li>JSEncrypt Github：<a href="https://github.com/travist/jsencrypt">https://github.com/travist/jsencrypt</a></li></ul><h3 id="Python-加密解密库"><a href="#Python-加密解密库" class="headerlink" title="Python 加密解密库"></a>Python 加密解密库</h3><h4 id="Cryptodome-amp-Crypto"><a href="#Cryptodome-amp-Crypto" class="headerlink" title="Cryptodome &amp; Crypto"></a>Cryptodome &amp; Crypto</h4><p>在 Python 中有很多算法是通过第三方库 Cryptodome 或者 Crypto 来实现的，Cryptodome 几乎是 Crypto 的替代品，Crypto 已经停止更新好多年了，有很多未知错误，所以<strong>不建议安装 Crypto ！</strong></p><p>Cryptodome 支持几乎所有主流加密算法，包括 MD5、SHA、BLAKE2b、BLAKE2s、HMAC、PBKDF2、AES、DES、3DES（Triple DES）、ECC、RSA、RC4 等。</p><p>Cryptodome 使用命令 <code>pip install pycryptodome</code> 进行安装，Crypto 使用命令 <code>pip install pycrypto </code> 进行安装。</p><p>参考资料：</p><ul><li><p>Crypto 库：<a href="https://www.dlitz.net/software/pycrypto/">https://www.dlitz.net/software/pycrypto/</a></p></li><li><p>Cryptodome 库：<a href="https://www.pycryptodome.org/en/latest/">https://www.pycryptodome.org/en/latest/</a></p></li></ul><h4 id="Hashlib"><a href="#Hashlib" class="headerlink" title="Hashlib"></a>Hashlib</h4><p>Python 的标准库 hashlib 提供了常见的摘要算法，如 MD5，SHA、BLAKE2b、BLAKE2s 等。</p><p>参考资料：</p><ul><li>hashlib 库：<a href="https://docs.python.org/3/library/hashlib.html">https://docs.python.org/3/library/hashlib.html</a></li><li>廖雪峰 hashlib：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017686752491744">https://www.liaoxuefeng.com/wiki/1016959663602400/1017686752491744</a></li></ul><h4 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h4><p>Python 的标准库 hmac 对 HMAC 算法提供了支持。</p><p>参考资料：</p><ul><li>hmac 库：<a href="https://docs.python.org/3/library/hmac.html">https://docs.python.org/3/library/hmac.html</a></li><li>廖雪峰 hmac：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1183198304823296">https://www.liaoxuefeng.com/wiki/1016959663602400/1183198304823296</a></li></ul><h4 id="pyDes"><a href="#pyDes" class="headerlink" title="pyDes"></a>pyDes</h4><p>Python 的第三方库 pyDes 对 DES 算法提供了支持。使用命令 <code>pip install pydes</code> 进行安装。</p><p>参考资料：pyDes 库：<a href="https://github.com/twhiteman/pyDes">https://github.com/twhiteman/pyDes</a></p><h4 id="ESA"><a href="#ESA" class="headerlink" title="ESA"></a>ESA</h4><p>Python 的第三方库 rsa 对 RSA 算法提供了支持。使用命令 <code>pip install rsa</code> 进行安装。</p><p>参考资料：rsa 库：<a href="https://stuvel.eu/python-rsa-doc/">https://stuvel.eu/python-rsa-doc/</a></p><h2 id="加密解密基本参数"><a href="#加密解密基本参数" class="headerlink" title="加密解密基本参数"></a>加密解密基本参数</h2><p>在一些对称和非对称加密算法中，经常会用到以下三个参数：初始向量 iv、加密模式 mode、填充方式 padding，先介绍一下这三个参数的含义和作用：</p><h3 id="初始向量-iv"><a href="#初始向量-iv" class="headerlink" title="初始向量 iv"></a>初始向量 iv</h3><p>在密码学中，初始向量（initialization vector，缩写为 iv），又称初始变数（starting variable，缩写为 sv），与密钥结合使用，作为加密数据的手段，它是一个固定长度的值，iv 的长度取决于加密方法，通常与使用的加密密钥或密码块的长度相当，一般在使用过程中会要求它是随机数或拟随机数，使用随机数产生的初始向量才能达到语义安全，让攻击者难以对原文一致且使用同一把密钥生成的密文进行破解。</p><p>参考资料：维基百科：<a href="https://en.wikipedia.org/wiki/Initialization_vector">https://en.wikipedia.org/wiki/Initialization_vector</a></p><h3 id="加密模式-mode"><a href="#加密模式-mode" class="headerlink" title="加密模式 mode"></a>加密模式 mode</h3><p>目前流行的加密和数字认证算法，都是采用块加密方式，就是将需要加密的明文分成固定大小的数据块，然后对其执行密码算法，得到密文。数据块的大小通常采用跟密钥一样的长度。加密模式在加密算法的基础上发展出来，同时也可以独立于加密算法而存在，加密模式定义了怎样通过重复利用加密算法将大于一个数据块大小的明文转化为密文，描述了加密每一数据块的过程。目前利用较多的加密模式有以下几种：</p><ul><li><p><strong>ECB：Electronic Code Book（电子码本模式）</strong>，是一种基础的加密方式，密文被分割成分组长度相等的块（不足补齐），然后单独一个个加密，一个个输出组成密文。</p></li><li><p><strong>CBC：Cipher Block Chaining（密码块链接模式）</strong>，是一种循环模式，前一个分组的密文和当前分组的明文异或操作后再加密，这样做的目的是增强破解难度。</p></li><li><p><strong>PCBC：Propagating Cipher Block Chaining（填充密码块链接模式）</strong>，也称为明文密码块链接模式（Plaintext Cipher Block Chaining），是一种可以使密文中的微小更改在解密时导致明文大部分错误的模式，并在加密的时候也具有同样的特性。</p></li><li><p><strong>CFB：Cipher Feedback（密码反馈模式）</strong>，可以将块密码变为自同步的流密码，类似于 CBC，CFB 的解密过程几乎就是颠倒的 CBC 的加密过程。</p></li><li><p><strong>OFB：Output Feedback（输出反馈模式）</strong>，可以将块密码变成同步的流密码，它产生密钥流的块，然后将其与明文块进行异或，得到密文。与其它流密码一样，密文中一个位的翻转会使明文中同样位置的位也产生翻转。</p></li><li><p><strong>CTR：Counter mode（计数器模式）</strong>，也被称为 ICM 模式（Integer Counter Mode，整数计数模式）和 SIC 模式（Segmented Integer Counter），在 CTR 模式中，有一个自增的算子，这个算子用密钥加密之后的输出和明文异或的结果得到密文，相当于一次一密。这种加密方式简单快速，安全可靠，而且可以并行加密，但是在计算器不能维持很长的情况下，密钥只能使用一次。</p></li></ul><p>参考资料：维基百科：<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation</a></p><h3 id="填充方式-padding"><a href="#填充方式-padding" class="headerlink" title="填充方式 padding"></a>填充方式 padding</h3><p>块密码只能对确定长度的数据块进行处理，而消息的长度通常是可变的。因此部分模式最后一块数据在加密前需要进行填充。有数种填充方法，其中最简单的一种是在明文的最后填充空字符以使其长度为块长度的整数倍。常见填充方式有以下几种：</p><ul><li><p><strong>PKCS7</strong>：在填充时首先获取需要填充的字节长度 = 块长度 - （数据长度 % 块长度）, 在填充字节序列中所有字节填充为需要填充的字节长度值。</p></li><li><p><strong>PKCS5</strong>：PKCS5 作为 PKCS7 的子集算法，概念上没有什么区别，只是在 blockSize 上固定为 8 bytes，即块大小固定为 8 字节。</p></li><li><p><strong>ZeroPadding</strong>：在填充时首先获取需要填充的字节长度 = 块长度 - （数据长度 % 块长度）, 在填充字节序列中所有字节填充为 0 。</p></li><li><p><strong>ISO10126</strong>：在填充时首先获取需要填充的字节长度 = 块长度 - （数据长度 % 块长度），在填充字节序列中最后一个字节填充为需要填充的字节长度值，填充字节中其余字节均填充随机数值。</p></li><li><p><strong>ANSIX923</strong>：在填充时首先获取需要填充的字节长度 = 块长度 - （数据长度 % 块长度），在填充字节序列中最后一个字节填充为需要填充的字节长度值，填充字节中其余字节均填充数字零。</p></li></ul><p>参考资料：</p><ul><li>维基百科：<a href="https://en.wikipedia.org/wiki/Padding_(cryptography)">https://en.wikipedia.org/wiki/Padding_(cryptography)</a></li><li>PKCS7/PKCS5 填充算法：<a href="https://segmentfault.com/a/1190000019793040">https://segmentfault.com/a/1190000019793040</a></li></ul><h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>简介：Base64 是一种用 64 个字符来表示任意二进制数据的方法。</p><p>参考资料：</p><ul><li>Base64 百度百科：<a href="https://baike.baidu.com/item/base64/8545775">https://baike.baidu.com/item/base64/8545775</a></li><li>Base64 维基百科：<a href="https://en.wikipedia.org/wiki/Base64">https://en.wikipedia.org/wiki/Base64</a></li></ul><h3 id="JavaScript-实现"><a href="#JavaScript-实现" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function base64Encode() &#123;    var srcs = CryptoJS.enc.Utf8.parse(text);    var encodeData = CryptoJS.enc.Base64.stringify(srcs);    return encodeData&#125;function base64Decode() &#123;    var srcs = CryptoJS.enc.Base64.parse(encodeData);    var decodeData = srcs.toString(CryptoJS.enc.Utf8);    return decodeData&#125;var text = &quot;I love Python!&quot;var encodeData = base64Encode()var decodeData = base64Decode()console.log(&quot;Base64 编码: &quot;, encodeData)console.log(&quot;Base64 解码: &quot;, decodeData)// Base64 编码:  SSBsb3ZlIFB5dGhvbiE=// Base64 解码:  I love Python!</code></pre><h3 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h3><pre><code class="python">import base64def base64_encode(text):    encode_data = base64.b64encode(text.encode())    return encode_datadef base64_decode(encode_data):    decode_data = base64.b64decode(encode_data)    return decode_dataif __name__ == &#39;__main__&#39;:    text = &#39;I love Python!&#39;    encode_data = base64_encode(text)    decode_data = base64_decode(encode_data)    print(&#39;Base64 编码：&#39;, encode_data)    print(&#39;Base64 解码：&#39;, decode_data)# Base64 编码： b&#39;SSBsb3ZlIFB5dGhvbiE=&#39;# Base64 解码： b&#39;I love Python!&#39;</code></pre><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>简介：全称 MD5 消息摘要算法（英文名称：MD5 Message-Digest Algorithm），又称哈希算法、散列算法，由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于 1992 年作为 RFC 1321 被公布，用以取代 MD4 算法。摘要算法是单向加密的，也就是说明文通过摘要算法加密之后，是不能解密的。摘要算法的第二个特点密文是固定长度的，它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。之所以叫摘要算法，它的算法就是提取明文重要的特征。所以，两个不同的明文，使用了摘要算法之后，有可能他们的密文是一样的，不过这个概率非常的低。</p><p>参考资料：</p><ul><li>RFC 1321：<a href="https://datatracker.ietf.org/doc/rfc1321/">https://datatracker.ietf.org/doc/rfc1321/</a></li><li>MD5 维基百科：<a href="https://en.wikipedia.org/wiki/MD5">https://en.wikipedia.org/wiki/MD5</a></li></ul><h3 id="JavaScript-实现-1"><a href="#JavaScript-实现-1" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function MD5Test() &#123;    var text = &quot;I love python!&quot;    return CryptoJS.MD5(text).toString()&#125;console.log(MD5Test())  // 21169ee3acd4a24e1fcb4322cfd9a2b8</code></pre><h3 id="Python-实现-1"><a href="#Python-实现-1" class="headerlink" title="Python 实现"></a>Python 实现</h3><pre><code class="python">import hashlibdef md5_test1():    md5 = hashlib.new(&#39;md5&#39;, &#39;I love python!&#39;.encode(&#39;utf-8&#39;))    print(md5.hexdigest())def md5_test2():    md5 = hashlib.md5()    md5.update(&#39;I love &#39;.encode(&#39;utf-8&#39;))    md5.update(&#39;python!&#39;.encode(&#39;utf-8&#39;))    print(md5.hexdigest())if __name__ == &#39;__main__&#39;:    md5_test1()  # 21169ee3acd4a24e1fcb4322cfd9a2b8    md5_test2()  # 21169ee3acd4a24e1fcb4322cfd9a2b8</code></pre><h2 id="PBKDF2"><a href="#PBKDF2" class="headerlink" title="PBKDF2"></a>PBKDF2</h2><p>简介：英文名称：Password-Based Key Derivation Function 2，PBKDF2 是 RSA 实验室的公钥加密标准（PKCS）系列的一部分，2017 年发布的 RFC 8018 （PKCS #5 v2.1）推荐使用 PBKDF2 进行密码散列。PBKDF2 将伪随机函数（例如 HMAC），把明文和一个盐值（salt）作为输入参数，然后进行重复运算，并最终产生密钥，如果重复的次数足够大，破解的成本就会变得很高。</p><p>参考资料：</p><ul><li>RFC 8018：<a href="https://datatracker.ietf.org/doc/rfc8018/">https://datatracker.ietf.org/doc/rfc8018/</a></li><li>PBKDF2 维基百科：<a href="https://en.wikipedia.org/wiki/PBKDF2">https://en.wikipedia.org/wiki/PBKDF2</a></li></ul><h3 id="JavaScript-实现-2"><a href="#JavaScript-实现-2" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function pbkdf2Encrypt() &#123;    var text = &quot;I love Python!&quot;    var salt = &quot;43215678&quot;    // key 长度 128，10 次重复运算    var encryptedData = CryptoJS.PBKDF2(text, salt, &#123;keySize: 128/32,iterations: 10&#125;);    return encryptedData.toString()&#125;console.log(pbkdf2Encrypt())  // 7fee6e8350cfe96314c76aaa6e853a50</code></pre><h3 id="Python-实现-2"><a href="#Python-实现-2" class="headerlink" title="Python 实现"></a>Python 实现</h3><pre><code class="python">import binasciifrom Cryptodome.Hash import SHA1from Cryptodome.Protocol.KDF import PBKDF2text = &#39;I love Python!&#39;salt = b&#39;43215678&#39;result = PBKDF2(text,  salt, count=10, hmac_hash_module=SHA1)result = binascii.hexlify(result)print(result)# b&#39;7fee6e8350cfe96314c76aaa6e853a50&#39;</code></pre><h2 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h2><p>简介：全称安全哈希算法（英文名称：Secure Hash Algorithm），由美国国家安全局（NSA）所设计，主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA），SHA 通常指 SHA 家族的五个算法，分别是 SHA-1、SHA-224、SHA-256、SHA-384、SHA-512，后四者有时并称为 SHA-2，SHA 是比 MD5 更安全一点的摘要算法，MD5 的密文是 32 位，而 SHA-1 是 40 位，版本越强，密文越长，代价是速度越慢。</p><p>参考资料：</p><ul><li>RFC 3174：<a href="https://datatracker.ietf.org/doc/rfc3174/">https://datatracker.ietf.org/doc/rfc3174/</a></li><li>SHA 维基百科：<a href="https://en.wikipedia.org/wiki/Secure_Hash_Algorithms">https://en.wikipedia.org/wiki/Secure_Hash_Algorithms</a></li></ul><h3 id="JavaScript-实现-3"><a href="#JavaScript-实现-3" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function SHA1Encrypt() &#123;    var text = &quot;I love python!&quot;    return CryptoJS.SHA1(text).toString();&#125;console.log(SHA1Encrypt())  // 23c02b203bd2e2ca19da911f1d270a06d86719fb</code></pre><h3 id="Python-实现-3"><a href="#Python-实现-3" class="headerlink" title="Python 实现"></a>Python 实现</h3><pre><code class="python">import hashlibdef sha1_test1():    sha1 = hashlib.new(&#39;sha1&#39;, &#39;I love python!&#39;.encode(&#39;utf-8&#39;))    print(sha1.hexdigest())def sha1_test2():    sha1 = hashlib.sha1()    sha1.update(&#39;I love python!&#39;.encode(&#39;utf-8&#39;))    print(sha1.hexdigest())if __name__ == &#39;__main__&#39;:    sha1_test1()  # 23c02b203bd2e2ca19da911f1d270a06d86719fb    sha1_test2()  # 23c02b203bd2e2ca19da911f1d270a06d86719fb</code></pre><h2 id="HMAC-1"><a href="#HMAC-1" class="headerlink" title="HMAC"></a>HMAC</h2><p>简介：全称散列消息认证码、密钥相关的哈希运算消息认证码（英文名称：Hash-based Message Authentication Code 或者 Keyed-hash Message Authentication Code），于 1996 年提出，1997 年作为 RFC 2104 被公布，HMAC 加密算法是一种安全的基于加密 Hash 函数和共享密钥的消息认证协议，它要求通信双方共享密钥 key、约定算法、对报文进行 Hash 运算，形成固定长度的认证码。通信双方通过认证码的校验来确定报文的合法性。</p><p>参考资料：</p><ul><li>RFC 2104：<a href="https://datatracker.ietf.org/doc/rfc2104/">https://datatracker.ietf.org/doc/rfc2104/</a></li><li>HMAC 维基百科：<a href="https://en.wikipedia.org/wiki/HMAC">https://en.wikipedia.org/wiki/HMAC</a></li></ul><h3 id="JavaScript-实现-4"><a href="#JavaScript-实现-4" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function HMACEncrypt() &#123;    var text = &quot;I love python!&quot;    var key = &quot;secret&quot;    return CryptoJS.HmacMD5(text, key).toString();    // return CryptoJS.HmacSHA1(text, key).toString();    // return CryptoJS.HmacSHA256(text, key).toString();&#125;console.log(HMACEncrypt())</code></pre><h3 id="Python-实现-4"><a href="#Python-实现-4" class="headerlink" title="Python 实现"></a>Python 实现</h3><pre><code class="python">import hmacdef hmac_test1():    message = b&#39;I love python!&#39;    key = b&#39;secret&#39;    md5 = hmac.new(key, message, digestmod=&#39;MD5&#39;)    print(md5.hexdigest())def hmac_test2():    key = &#39;secret&#39;.encode(&#39;utf8&#39;)    sha1 = hmac.new(key, digestmod=&#39;sha1&#39;)    sha1.update(&#39;I love &#39;.encode(&#39;utf8&#39;))    sha1.update(&#39;Python!&#39;.encode(&#39;utf8&#39;))    print(sha1.hexdigest())if __name__ == &#39;__main__&#39;:    hmac_test1()  # 9c503a1f852edcc3526ea56976c38edf    hmac_test2()  # 2d8449a4292d4bbeed99ce9ea570880d6e19b61a</code></pre><h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><p>简介：全称数据加密标准（英文名称：Data Encryption Standard），加密与解密使用同一密钥，属于对称加密算法，1977 年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），DES 是一个分组加密算法，使用 56 位的密钥（一般认为密钥是 64 位，但是密钥的每个第 8 位设置为奇偶校验位，所以实际上有效位只有 56 位），由于 56 位密钥长度相对较短，所以 DES 是不安全的，现在基本上已被更高级的加密标准 AES 取代。</p><ul><li>mode 支持：CBC，CFB，CTR，CTRGladman，ECB，OFB 等。</li><li>padding 支持：ZeroPadding，NoPadding，AnsiX923，Iso10126，Iso97971，Pkcs7 等。</li></ul><p>参考资料：</p><ul><li>RFC 4772：<a href="https://datatracker.ietf.org/doc/rfc4772/">https://datatracker.ietf.org/doc/rfc4772/</a></li><li>DES 维基百科：<a href="https://en.wikipedia.org/wiki/Data_Encryption_Standard">https://en.wikipedia.org/wiki/Data_Encryption_Standard</a></li></ul><h3 id="JavaScript-实现-5"><a href="#JavaScript-实现-5" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function desEncrypt() &#123;    var key = CryptoJS.enc.Utf8.parse(desKey),        iv = CryptoJS.enc.Utf8.parse(desIv),        srcs = CryptoJS.enc.Utf8.parse(text),        // CBC 加密模式，Pkcs7 填充方式        encrypted = CryptoJS.DES.encrypt(srcs, key, &#123;            iv: iv,            mode: CryptoJS.mode.CBC,            padding: CryptoJS.pad.Pkcs7        &#125;);    return encrypted.toString();&#125;function desDecrypt() &#123;    var key = CryptoJS.enc.Utf8.parse(desKey),        iv = CryptoJS.enc.Utf8.parse(desIv),        srcs = encryptedData,        // CBC 加密模式，Pkcs7 填充方式        decrypted = CryptoJS.DES.decrypt(srcs, key, &#123;            iv: iv,            mode: CryptoJS.mode.CBC,            padding: CryptoJS.pad.Pkcs7        &#125;);    return decrypted.toString(CryptoJS.enc.Utf8);&#125;var text = &quot;I love Python!&quot;       // 待加密对象var desKey = &quot;6f726c64f2c2057&quot;    // 密钥var desIv = &quot;0123456789ABCDEF&quot;    // 初始向量var encryptedData = desEncrypt()var decryptedData = desDecrypt()console.log(&quot;加密字符串: &quot;, encryptedData)console.log(&quot;解密字符串: &quot;, decryptedData)// 加密字符串:  +ndbEkWNw2QAfIYQtwC14w==// 解密字符串:  I love Python!</code></pre><h3 id="Python-实现-5"><a href="#Python-实现-5" class="headerlink" title="Python 实现"></a>Python 实现</h3><pre><code class="python">import binascii# 加密模式 CBC，填充方式 PAD_PKCS5from pyDes import des, CBC, PAD_PKCS5def des_encrypt(key, text, iv):    k = des(key, CBC, iv, pad=None, padmode=PAD_PKCS5)    en = k.encrypt(text, padmode=PAD_PKCS5)    return binascii.b2a_hex(en)def des_decrypt(key, text, iv):    k = des(key, CBC, iv, pad=None, padmode=PAD_PKCS5)    de = k.decrypt(binascii.a2b_hex(text), padmode=PAD_PKCS5)    return deif __name__ == &#39;__main__&#39;:    secret_key = &#39;12345678&#39;   # 密钥    text = &#39;I love Python!&#39;   # 加密对象    iv = secret_key           # 偏移量    secret_str = des_encrypt(secret_key, text, iv)    print(&#39;加密字符串：&#39;, secret_str)    clear_str = des_decrypt(secret_key, secret_str, iv)    print(&#39;解密字符串：&#39;, clear_str)# 加密字符串： b&#39;302d3abf2421169239f829b38a9545f1&#39;# 解密字符串： b&#39;I love Python!&#39;</code></pre><h2 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h2><p>简介：全称三重数据加密算法（英文名称：Triple Data Encryption Standard、 Triple Data Encryption Algorithm、TDES、TDEA），是对称加密算法中的一种。70 年代初由 IBM 研发，后 1977 年被美国国家标准局采纳为数据加密标准，它相当于是对每个数据块应用三次 DES 加密算法。由于计算机运算能力的增强，原版 DES 密码的密钥长度变得容易被暴力破解；3DES 即是设计用来提供一种相对简单的方法，即通过增加 DES 的密钥长度来避免破解，所以严格来说 3DES 不是设计一种全新的块密码算法。</p><ul><li>mode 支持：CBC，CFB，CTR，CTRGladman，ECB，OFB 等。</li><li>padding 支持：ZeroPadding，NoPadding，AnsiX923，Iso10126，Iso97971，Pkcs7 等。</li></ul><p>参考资料：</p><ul><li>RFC 1851：<a href="https://datatracker.ietf.org/doc/rfc1851/">https://datatracker.ietf.org/doc/rfc1851/</a></li><li>3DES 维基百科：<a href="https://en.wikipedia.org/wiki/Triple_DES">https://en.wikipedia.org/wiki/Triple_DES</a></li></ul><h3 id="JavaScript-实现-6"><a href="#JavaScript-实现-6" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function tripleDesEncrypt() &#123;    var key = CryptoJS.enc.Utf8.parse(desKey),        iv = CryptoJS.enc.Utf8.parse(desIv),        srcs = CryptoJS.enc.Utf8.parse(text),        // ECB 加密方式，Iso10126 填充方式        encrypted = CryptoJS.TripleDES.encrypt(srcs, key, &#123;            iv: iv,            mode: CryptoJS.mode.ECB,            padding: CryptoJS.pad.Iso10126        &#125;);    return encrypted.toString();&#125;function tripleDesDecrypt() &#123;    var key = CryptoJS.enc.Utf8.parse(desKey),        iv = CryptoJS.enc.Utf8.parse(desIv),        srcs = encryptedData,        // ECB 加密方式，Iso10126 填充方式        decrypted = CryptoJS.TripleDES.decrypt(srcs, key, &#123;            iv: iv,            mode: CryptoJS.mode.ECB,            padding: CryptoJS.pad.Iso10126        &#125;);    return decrypted.toString(CryptoJS.enc.Utf8);&#125;var text = &quot;I love Python!&quot;       // 待加密对象var desKey = &quot;6f726c64f2c2057c&quot;    // 密钥var desIv = &quot;0123456789ABCDEF&quot;    // 偏移量var encryptedData = tripleDesEncrypt()var decryptedData = tripleDesDecrypt()console.log(&quot;加密字符串: &quot;, encryptedData)console.log(&quot;解密字符串: &quot;, decryptedData)// 加密字符串:  3J0NX7x6GbewjjhoW2HKqg==// 解密字符串:  I love Python!</code></pre><h3 id="Python-实现-6"><a href="#Python-实现-6" class="headerlink" title="Python 实现"></a>Python 实现</h3><pre><code class="python">from Cryptodome.Cipher import DES3from Cryptodome import Random# 需要补位，str不是16的倍数那就补足为16的倍数def add_to_16(value):    while len(value) % 16 != 0:        value += &#39;\0&#39;    return str.encode(value)def des_encrypt(key, text, iv):    # 加密模式 OFB    cipher_encrypt = DES3.new(add_to_16(key), DES3.MODE_OFB, iv)    encrypted_text = cipher_encrypt.encrypt(text.encode(&quot;utf-8&quot;))    return encrypted_textdef des_decrypt(key, text, iv):    # 加密模式 OFB    cipher_decrypt = DES3.new(add_to_16(key), DES3.MODE_OFB, iv)    decrypted_text = cipher_decrypt.decrypt(text)    return decrypted_textif __name__ == &#39;__main__&#39;:    key = &#39;12345678&#39;            # 密钥，16 位    text = &#39;I love Python!&#39;     # 加密对象    iv = Random.new().read(DES3.block_size)  # DES3.block_size == 8    secret_str = des_encrypt(key, text, iv)    print(&#39;加密字符串：&#39;, secret_str)    clear_str = des_decrypt(key, secret_str, iv)    print(&#39;解密字符串：&#39;, clear_str)# 加密字符串： b&#39;\xa5\x8a\xd4R\x99\x16j\xba?vg\xf2\xb6\xa9&#39;# 解密字符串： b&#39;I love Python!&#39;</code></pre><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><p>简介：全称高级加密标准（英文名称：Advanced Encryption Standard），在密码学中又称 Rijndael 加密法，由美国国家标准与技术研究院 （NIST）于 2001 年发布，并在 2002 年成为有效的标准，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES，已经被多方分析且广为全世界所使用，它本身只有一个密钥，即用来实现加密，也用于解密。</p><ul><li>mode 支持：CBC，CFB，CTR，CTRGladman，ECB，OFB 等。</li><li>padding 支持：ZeroPadding，NoPadding，AnsiX923，Iso10126，Iso97971，Pkcs7 等。</li></ul><p>参考资料：</p><ul><li>RFC 3268：<a href="https://datatracker.ietf.org/doc/rfc3268/">https://datatracker.ietf.org/doc/rfc3268/</a></li><li>AES 维基百科：<a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">https://en.wikipedia.org/wiki/Advanced_Encryption_Standard</a></li></ul><h3 id="JavaScript-实现-7"><a href="#JavaScript-实现-7" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function aesEncrypt() &#123;    var key = CryptoJS.enc.Utf8.parse(aesKey),        iv = CryptoJS.enc.Utf8.parse(aesIv),        srcs = CryptoJS.enc.Utf8.parse(text),        // CBC 加密方式，Pkcs7 填充方式        encrypted = CryptoJS.AES.encrypt(srcs, key, &#123;            iv: iv,            mode: CryptoJS.mode.CBC,            padding: CryptoJS.pad.Pkcs7        &#125;);    return encrypted.toString();&#125;function aesDecrypt() &#123;    var key = CryptoJS.enc.Utf8.parse(aesKey),        iv = CryptoJS.enc.Utf8.parse(aesIv),        srcs = encryptedData,        // CBC 加密方式，Pkcs7 填充方式        decrypted = CryptoJS.AES.decrypt(srcs, key, &#123;            iv: iv,            mode: CryptoJS.mode.CBC,            padding: CryptoJS.pad.Pkcs7        &#125;);    return decrypted.toString(CryptoJS.enc.Utf8);&#125;var text = &quot;I love Python!&quot;       // 待加密对象var aesKey = &quot;6f726c64f2c2057c&quot;   // 密钥，16 倍数var aesIv = &quot;0123456789ABCDEF&quot;    // 偏移量，16 倍数var encryptedData = aesEncrypt()var decryptedData = aesDecrypt()console.log(&quot;加密字符串: &quot;, encryptedData)console.log(&quot;解密字符串: &quot;, decryptedData)// 加密字符串:  dZL7TLJR786VGvuUvqYGoQ==// 解密字符串:  I love Python!</code></pre><h3 id="Python-实现-7"><a href="#Python-实现-7" class="headerlink" title="Python 实现"></a>Python 实现</h3><pre><code class="python">import base64from Cryptodome.Cipher import AES# 需要补位，str不是16的倍数那就补足为16的倍数def add_to_16(value):    while len(value) % 16 != 0:        value += &#39;\0&#39;    return str.encode(value)# 加密方法def aes_encrypt(key, t, iv):    aes = AES.new(add_to_16(key), AES.MODE_CBC, add_to_16(iv))  # 初始化加密器    encrypt_aes = aes.encrypt(add_to_16(t))                    # 先进行 aes 加密    encrypted_text = str(base64.encodebytes(encrypt_aes), encoding=&#39;utf-8&#39;)  # 执行加密并转码返回 bytes    return encrypted_text# 解密方法def aes_decrypt(key, t, iv):    aes = AES.new(add_to_16(key), AES.MODE_CBC, add_to_16(iv))         # 初始化加密器    base64_decrypted = base64.decodebytes(t.encode(encoding=&#39;utf-8&#39;))  # 优先逆向解密 base64 成 bytes    decrypted_text = str(aes.decrypt(base64_decrypted), encoding=&#39;utf-8&#39;).replace(&#39;\0&#39;, &#39;&#39;)  # 执行解密密并转码返回str    return decrypted_textif __name__ == &#39;__main__&#39;:    secret_key = &#39;12345678&#39;   # 密钥    text = &#39;I love Python!&#39;   # 加密对象    iv = secret_key           # 初始向量    encrypted_str = aes_encrypt(secret_key, text, iv)    print(&#39;加密字符串：&#39;, encrypted_str)    decrypted_str = aes_decrypt(secret_key, encrypted_str, iv)    print(&#39;解密字符串：&#39;, decrypted_str)# 加密字符串： lAVKvkQh+GtdNpoKf4/mHA==# 解密字符串： I love Python!</code></pre><h2 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h2><p>简介：英文名称：Rivest Cipher 4，也称为 ARC4 或 ARCFOUR，是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。RC4 是有线等效加密（WEP）中采用的加密算法，也曾经是 TLS 可采用的算法之一，该算法的速度可以达到 DES 加密的 10 倍左右，且具有很高级别的非线性，虽然它在软件方面的简单性和速度非常出色，但在 RC4 中发现了多个漏洞，它特别容易受到攻击，RC4 作为一种老旧的验证和加密算法易于受到黑客攻击，现在逐渐不推荐使用了。</p><p>参考资料：</p><ul><li>RFC 7465：<a href="https://datatracker.ietf.org/doc/rfc7465/">https://datatracker.ietf.org/doc/rfc7465/</a></li><li>RC4 维基百科：<a href="https://en.wikipedia.org/wiki/RC4">https://en.wikipedia.org/wiki/RC4</a></li></ul><h3 id="JavaScript-实现-8"><a href="#JavaScript-实现-8" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function RC4Encrypt() &#123;    return CryptoJS.RC4.encrypt(text, key).toString();&#125;function RC4Decrypt()&#123;    return CryptoJS.RC4.decrypt(encryptedData, key).toString(CryptoJS.enc.Utf8);&#125;var text = &quot;I love Python!&quot;var key = &quot;6f726c64f2c2057c&quot;var encryptedData = RC4Encrypt()var decryptedData = RC4Decrypt()console.log(&quot;加密字符串: &quot;, encryptedData)console.log(&quot;解密字符串: &quot;, decryptedData)// 加密字符串:  U2FsdGVkX18hMm9WWdoEQGPolnXzlg9ryArdGNwv// 解密字符串:  I love Python!</code></pre><h3 id="Python-实现-8"><a href="#Python-实现-8" class="headerlink" title="Python 实现"></a>Python 实现</h3><pre><code class="python">import base64from Cryptodome.Cipher import ARC4def rc4_encrypt(key, t):    enc = ARC4.new(key.encode(&#39;utf8&#39;))    res = enc.encrypt(t.encode(&#39;utf-8&#39;))    res = base64.b64encode(res)    return resdef rc4_decrypt(key, t):    data = base64.b64decode(t)    enc = ARC4.new(key.encode(&#39;utf8&#39;))    res = enc.decrypt(data)    return resif __name__ == &quot;__main__&quot;:    secret_key = &#39;12345678&#39;   # 密钥    text = &#39;I love Python!&#39;   # 加密对象    encrypted_str = rc4_encrypt(secret_key, text)    print(&#39;加密字符串：&#39;, encrypted_str)    decrypted_str = rc4_decrypt(secret_key, encrypted_str)    print(&#39;解密字符串：&#39;, decrypted_str)# 加密字符串： b&#39;8tNVu3/U/veJR2KgyBw=&#39;# 解密字符串： b&#39;I love Python!&#39;</code></pre><h2 id="Rabbit"><a href="#Rabbit" class="headerlink" title="Rabbit"></a>Rabbit</h2><p>简介：Rabbit 加密算法是一个高性能的流密码加密方式，2003 年首次被提出，它从 128 位密钥和 64 位初始向量（iv）创建一个密钥流。</p><p>参考资料：</p><ul><li>RFC 4503：<a href="https://datatracker.ietf.org/doc/rfc4503/">https://datatracker.ietf.org/doc/rfc4503/</a></li><li>Rabbit 维基百科：<a href="https://en.wikipedia.org/wiki/Rabbit_(cipher)">https://en.wikipedia.org/wiki/Rabbit_(cipher)</a></li></ul><h3 id="JavaScript-实现-9"><a href="#JavaScript-实现-9" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function rabbitEncrypt() &#123;    return CryptoJS.Rabbit.encrypt(text, key).toString();&#125;function rabbitDecrypt() &#123;    return CryptoJS.Rabbit.decrypt(encryptedData, key).toString(CryptoJS.enc.Utf8);&#125;var text = &quot;I love Python!&quot;var key = &quot;6f726c64f2c2057&quot;var encryptedData = rabbitEncrypt()var decryptedData = rabbitDecrypt()console.log(&quot;加密字符串: &quot;, encryptedData)console.log(&quot;解密字符串: &quot;, decryptedData)// 加密字符串:  U2FsdGVkX1+ZVCHRXlhmG5Xw87YPWMNIBlbukuh8// 解密字符串:  I love Python!</code></pre><h3 id="Python-实现-9"><a href="#Python-实现-9" class="headerlink" title="Python 实现"></a>Python 实现</h3><p>目前没有找到有第三方库可以直接实现 Rabbit 算法，在 Python 中实现可以参考：<a href="https://asecuritysite.com/encryption/rabbit2">https://asecuritysite.com/encryption/rabbit2</a></p><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>简介：英文名称：Rivest-Shamir-Adleman，是 1977 年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的，RSA 就是他们三人姓氏开头字母拼在一起组成的，RSA 加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。它被普遍认为是目前比较优秀的公钥方案之一。RSA是第一个能同时用于加密和数字签名的算法，它能够抵抗到目前为止已知的所有密码攻击。</p><p>参考资料：</p><ul><li>RSA 维基百科：<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">https://en.wikipedia.org/wiki/RSA_(cryptosystem)</a></li></ul><h3 id="JavaScript-实现-10"><a href="#JavaScript-实现-10" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 node-rsa 加密模块var NodeRSA = require(&#39;node-rsa&#39;);function rsaEncrypt() &#123;    pubKey = new NodeRSA(publicKey,&#39;pkcs8-public&#39;);    var encryptedData = pubKey.encrypt(text, &#39;base64&#39;);    return encryptedData&#125;function rsaDecrypt() &#123;    priKey = new NodeRSA(privatekey,&#39;pkcs8-private&#39;);    var decryptedData = priKey.decrypt(encryptedData, &#39;utf8&#39;);    return decryptedData&#125;var key = new NodeRSA(&#123;b: 512&#125;);                    //生成512位秘钥var publicKey = key.exportKey(&#39;pkcs8-public&#39;);    //导出公钥var privatekey = key.exportKey(&#39;pkcs8-private&#39;);  //导出私钥var text = &quot;I love Python!&quot;var encryptedData = rsaEncrypt()var decryptedData = rsaDecrypt()console.log(&quot;公钥:\n&quot;, publicKey)console.log(&quot;私钥:\n&quot;, privatekey)console.log(&quot;加密字符串: &quot;, encryptedData)console.log(&quot;解密字符串: &quot;, decryptedData)/*公钥: -----BEGIN PUBLIC KEY-----MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAOV1BwTJSVce/QjJAro5fXG9WzOpal09Qtv1yuXKE81vZSNTHxW6dICwPT/kjCfC3bA5Qs6wnYBANuwD6wlAS0UCAwEAAQ==-----END PUBLIC KEY-----私钥: -----BEGIN PRIVATE KEY-----MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEA5XUHBMlJVx79CMkCujl9cb1bM6lqXT1C2/XK5coTzW9lI1MfFbp0gLA9P+SMJ8LdsDlCzrCdgEA27APrCUBLRQIDAQABAkAiXwJbJC+5PioXG80tyhjRZdT4iyMkrl2Kh2oKO9f1iLaBXLyaD0HW82wFh+cUy8GcMl9jse8DE8wd1TdORmHhAiEA/rwmWjXHVgDqcH/fqk8Ufku0fXvs56h5QDoh1so5vokCIQDmmL3JDW6Y7RuK2qwFbHBZtYPRFRVdn5X1oqU2FOSX3QIhAOVTjVN5RtNuT6Cn/jvcpZ5tmTe+8TA8w6vGqeAsfn/BAiBvKKIUEQ2HWoU0YkUaODPQiteIKomqIAvB5S2O7HNlYQIgWMuLUxGZbbcAmIX+YmRXuET97S7OWv+zWHVfb/rbXtI=-----END PRIVATE KEY-----加密字符串:  hHXTF1K3w55Wd6OSjVYtqxceJ5VhlySNUahel9pwKD92Ef7wIT7DYPuJRKiqz5tuHtUqujbmbZBSL0qDE/EA+A==解密字符串:  I love Python!*/</code></pre><h3 id="Python-实现-10"><a href="#Python-实现-10" class="headerlink" title="Python 实现"></a>Python 实现</h3><p>模块：rsa：</p><pre><code class="python">import rsadef rsa_encrypt(pu_key, t):    # 公钥加密    rsa = rsa.encrypt(t.encode(&quot;utf-8&quot;), pu_key)    return rsadef rsa_decrypt(pr_key, t):    # 私钥解密    rsa = rsa.decrypt(t, pr_key).decode(&quot;utf-8&quot;)    return rsaif __name__ == &quot;__main__&quot;:    public_key, private_key = rsa.newkeys(512)   # 生成公钥、私钥    print(&#39;公钥：&#39;, public_key)    print(&#39;私钥：&#39;, private_key)    text = &#39;I love Python!&#39;  # 加密对象    encrypted_str = rsa_encrypt(public_key, text)    print(&#39;加密字符串：&#39;, encrypted_str)    decrypted_str = rsa_decrypt(private_key, encrypted_str)    print(&#39;解密字符串：&#39;, decrypted_str)&#39;&#39;&#39;公钥： PublicKey(7636479066127060956100056267701318377455704072072698049978592945665550579944731953431504993757594103617537700972424661030900303472123028864161050235168613, 65537)私钥： PrivateKey(7636479066127060956100056267701318377455704072072698049978592945665550579944731953431504993757594103617537700972424661030900303472123028864161050235168613, 65537, 3850457767980968449796700480128630632818465005441846698224554128042451115530564586537997896922067523638756079019054611200173122138274839877369624069360253, 4713180694194659323798858305046043997526301456820208338158979730140812744181638767, 1620238976946735819854194349514460863335347861649166352709029254680140139)加密字符串： b&quot;\x1aaeps\xa0c&#125;\xb6\xcf\xa3\xb0\xbb\xedA\x7f&#125;\x03\xdc\xd5\x1c\x9b\xdb\xda\xf9q\x80[=\xf5\x91\r\xd0&#39;f\xce\x1f\x01\xef\xa5\xdb3\x96\t0qIxF\xbd\x11\xd6\xb25\xc5\xe1pM\xb4M\xc2\xd4\x03\xa6&quot;解密字符串： I love Python!&#39;&#39;&#39;</code></pre><p>模块 Cryptodome：</p><pre><code class="python">import base64from Cryptodome.PublicKey import RSAfrom Cryptodome.Cipher import PKCS1_v1_5data = &quot;cKK8B2rWwfwWeXhz&quot;public_key = &quot;MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAM1xhOWaThSMpfxFsjV5YaWOFHt+6RvS+zH2Pa47VVr8PkZYnRaaKKy2MYBuEh7mZfM/R1dUXTgu0gp6VTNeNQkCAwEAAQ==&quot;rsa_key = RSA.import_key(base64.b64decode(public_key))  # 导入读取到的公钥cipher = PKCS1_v1_5.new(rsa_key)                        # 生成对象cipher_text = base64.b64encode(cipher.encrypt(data.encode(encoding=&quot;utf-8&quot;)))print(cipher_text)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本文总结了在爬虫中常见的各种加密算法、编码算法的原理、在 JavaScript 中和 Python 中的基本实现方法，遇到 JS 加密的时候</summary>
      
    
    
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91/"/>
    
    
    <category term="算法" scheme="https://www.itbob.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="JS 逆向" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据结构之栈的实现</title>
    <link href="https://www.itbob.cn/article/038/"/>
    <id>https://www.itbob.cn/article/038/</id>
    <published>2020-11-30T06:48:05.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈的概念"><a href="#栈的概念" class="headerlink" title="栈的概念"></a>栈的概念</h2><p>栈（stack）又名堆栈，栈是一种线性数据结构，用先进后出或者是后进先出的方式存储数据，栈中数据的插入删除操作都是在栈的顶端进行，这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p><p><img src="https://img-blog.csdnimg.cn/20201101205308521.png" alt="01"></p><hr><h2 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h2><p>元素后进先出（Last in First Out，LIFO）</p><hr><h2 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h2><ul><li><font color=#FF0000><strong>push(item)</strong></font>：进栈（向栈顶添加元素）</li><li><font color=#FF0000><strong>pop()</strong></font>：出栈（删除栈顶元素）</li><li><font color=#FF0000><strong>top()</strong></font>：查看栈顶元素</li><li><font color=#FF0000><strong>empty()</strong></font>：判断栈是否为空</li></ul><hr><h2 id="Python-实现栈"><a href="#Python-实现栈" class="headerlink" title="Python 实现栈"></a>Python 实现栈</h2><p>栈并不是 Python 的内建类型，在必要的时候可以使用列表来模拟基于数组的栈。如果将列表的末尾看作是栈的顶，列表方法 <code>append()</code> 就是将元素压入到栈中（进栈），而列表方法 <code>pop()</code> 会删除并返回栈顶的元素（出栈），列表索引的方式 <code>arr[-1]</code> 可以查看栈顶元素。具体代码实现如下：</p><pre><code class="python">class Stack:    def __init__(self):        self.stack = []    def push(self, item):        self.stack.append(item)    def pop(self):        if self.empty():            return None        else:            return self.stack.pop()    def top(self):        if self.empty():            return None        else:            return self.stack[-1]    def empty(self):        return len(self.stack) == 0</code></pre><hr><h2 id="栈的简单应用：括号匹配问题"><a href="#栈的简单应用：括号匹配问题" class="headerlink" title="栈的简单应用：括号匹配问题"></a>栈的简单应用：括号匹配问题</h2><p><font color=#2DAF8B><strong>问题描述：</strong></font></p><p>给定一个字符串，字符串中只包含小括号 <code>()</code>、中括号 <code>[]</code>、大括号 <code>&#123;&#125;</code>，求该字符串中的括号是否匹配。匹配规则：成对出现或者左右对称出现，例如：</p><p><font color=#FF0000><strong>()[]{}</strong></font>：匹配；<font color=#FF0000><strong>{[()]}</strong></font>：匹配；<font color=#FF0000><strong>({}]</strong></font>：不匹配；<font color=#FF0000><strong>()]</strong></font>：不匹配；<font color=#FF0000><strong>({)}</strong></font>：不匹配</p><p><font color=#2DAF8B><strong>通过栈来解决：</strong></font></p><p>有字符串 <font color=#FF0000><strong>()[{}]</strong></font>，依次取每个括号，只要是左括号就进栈，只要是右括号就判断栈顶是否为对应的左括号，具体步骤如下：</p><ul><li><strong>①</strong> 遇到左小括号 <font color=#FF0000><strong>(</strong></font>，执行进栈操作；</li><li><strong>②</strong> 遇到右小括号 <font color=#FF0000><strong>)</strong></font>，判断此时栈顶是否为左小括号 <font color=#FF0000><strong>(</strong></font>，是则让左小括号 <font color=#FF0000><strong>(</strong></font> 出栈，此时栈为空;</li><li><strong>③</strong> 遇到左中括号 <font color=#FF0000><strong>[</strong></font>，执行进栈操作；</li><li><strong>④</strong> 遇到左大括号 <font color=#FF0000><strong>{</strong></font>，执行进栈操作；</li><li><strong>⑤</strong> 遇到右大括号 <font color=#FF0000><strong>}</strong></font>，判断此时栈顶是否为左大括号 <font color=#FF0000><strong>{</strong></font>，是则让左大括号 <font color=#FF0000><strong>{</strong></font> 出栈，此时栈为空；</li><li><strong>⑥</strong> 遇到右中括号 <font color=#FF0000><strong>]</strong></font>，判断此时栈顶是否为左中括号 <font color=#FF0000><strong>[</strong></font>，是则让左中括号 <font color=#FF0000><strong>[</strong></font> 出栈，此时栈为空；</li><li><strong>⑦</strong> 判断最终的栈是否为空，是则表示匹配，不是则表示不匹配。其中第 <strong>② ⑤ ⑥</strong> 步中，若判断为不是，则直接表示不匹配。</li></ul><p><font color=#2DAF8B><strong>Python 代码实现：</strong></font></p><pre><code class="python">class Stack:    def __init__(self):        self.stack = []    def push(self, item):        self.stack.append(item)    def pop(self):        if self.empty():            return None        else:            return self.stack.pop()    def top(self):        if self.empty():            return None        else:            return self.stack[-1]    def empty(self):        return len(self.stack) == 0def brackets_match(s):    match_dict = &#123;&#39;&#125;&#39;: &#39;&#123;&#39;, &#39;]&#39;: &quot;[&quot;, &#39;)&#39;: &#39;(&#39;&#125;    stack = Stack()    for ch in s:        if ch in [&#39;(&#39;, &#39;[&#39;, &#39;&#123;&#39;]:    # 如果为左括号，则执行进栈操作            stack.push(ch)        else:                        # 如果为右括号            if stack.empty():        # 如果栈为空，则不匹配，即多了一个右括号，没有左括号匹配                return False            elif stack.top() == match_dict[ch]:  # 如果栈顶的元素为对应的左括号，则让栈顶出栈                stack.pop()            else:                    # 如果栈顶元素不是对应的左括号，则不匹配                return False    if stack.empty():                # 最后的栈如果为空，则匹配，否则不匹配        return True    else:        return Falseprint(brackets_match(&#39;[&#123;()&#125;()&#123;()&#125;[](&#123;&#125;)&#123;&#125;]&#39;))print(brackets_match(&#39;()[&#123;&#125;]&#39;))print(brackets_match(&#39;(&#123;)&#125;&#39;))print(brackets_match(&#39;[]&#125;&#39;))</code></pre><p>输出结果：</p><pre><code class="python">TrueTrueFalseFalse</code></pre><hr><h2 id="栈的简单应用：倒序输出一组元素"><a href="#栈的简单应用：倒序输出一组元素" class="headerlink" title="栈的简单应用：倒序输出一组元素"></a>栈的简单应用：倒序输出一组元素</h2><p>把元素存入栈，再顺序取出：</p><pre><code class="python">class Stack:    def __init__(self):        self.stack = []    def push(self, item):        self.stack.append(item)    def pop(self):        if self.empty():            return None        else:            return self.stack.pop()    def top(self):        if self.empty():            return None        else:            return self.stack[-1]    def empty(self):        return len(self.stack) == 0def reverse_list(s):    stack = Stack()    for ch in s:        stack.push(ch)    new_list = []    while not stack.empty():        new_list.append(stack.pop())    return new_listprint(reverse_list([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;]))</code></pre><p>输出结果：</p><pre><code class="python">[&#39;E&#39;, &#39;D&#39;, &#39;C&#39;, &#39;B&#39;, &#39;A&#39;]</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;栈的概念&quot;&gt;&lt;a href=&quot;#栈的概念&quot; class=&quot;headerlink&quot; title=&quot;栈的概念&quot;&gt;&lt;/a&gt;栈的概念&lt;/h2&gt;&lt;p&gt;栈（stack）又名堆栈，栈是一种线性数据结构，用先进后出或者是后进先出的方式存储数据，栈中数据的插入删除操作都是在栈的顶端</summary>
      
    
    
    
    <category term="算法" scheme="https://www.itbob.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="算法" scheme="https://www.itbob.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python 算法之递归与尾递归，斐波那契数列以及汉诺塔的实现</title>
    <link href="https://www.itbob.cn/article/037/"/>
    <id>https://www.itbob.cn/article/037/</id>
    <published>2020-10-28T14:05:13.000Z</published>
    <updated>2022-05-22T12:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递归概念"><a href="#递归概念" class="headerlink" title="递归概念"></a>递归概念</h2><p><font color=#ff0000><strong>递归</strong></font>：程序调用自身的编程技巧称为递归（ recursion）。用一种通俗的话来说就是自己调用自己，它通常把一个大型复杂的问题层层转化为一个与原问题相似的、但是规模较小的问题来求解，当问题小到一定规模的时候，需要一个递归出口返回。递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。</p><p><font color=#ff0000><strong>递归函数</strong></font>：在编程语言中，函数直接或间接调用函数本身，则该函数称为递归函数；在数学上的定义如下：对于某一函数 $f(x)$，其定义域是集合 A，那么若对于 A 集合中的某一个值 $X_0$，其函数值 $f(x_0)$ 由 $f(f(x_0))$ 决定，那么就称 $f(x)$ 为递归函数。</p><hr><h2 id="递归要素"><a href="#递归要素" class="headerlink" title="递归要素"></a>递归要素</h2><ul><li><p>递归必须包含一个基本的出口（结束条件），否则就会无限递归，最终导致栈溢出；</p></li><li><p>递归必须包含一个可以分解的问题，例如要想求得 $fact(n)$，就需要用 $n * fact(n-1)$；</p></li><li><p>递归必须必须要向着递归出口靠近，例如每次递归调用都会 $n-1$，向着递归出口 $n == 0$ 靠近。</p></li></ul><hr><h2 id="递归与迭代的区别"><a href="#递归与迭代的区别" class="headerlink" title="递归与迭代的区别"></a>递归与迭代的区别</h2><ul><li><p><font color=#ff0000><strong>递归（recursion）</strong></font>：递归则是一步一步往前递推，直到递归基础，寻找一条路径， 然后再由前向后计算。（A调用A）</p></li><li><p><font color=#ff0000><strong>迭代（iteration）</strong></font>：迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值，因此迭代是从前往后计算的。（A重复调用B）</p></li></ul><hr><h2 id="示例一：阶乘"><a href="#示例一：阶乘" class="headerlink" title="示例一：阶乘"></a>示例一：阶乘</h2><p>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且 0 的阶乘为 1。即 $n!=1×2×3×…×(n-1)×n$，以递归方式定义：$n!=(n-1)!×n$</p><pre><code class="python">def factorial(n):    if n == 0:        return 1    else:        return n * factorial(n-1)</code></pre><hr><h2 id="示例二：斐波那契数列"><a href="#示例二：斐波那契数列" class="headerlink" title="示例二：斐波那契数列"></a>示例二：斐波那契数列</h2><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家莱昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”。</p><p>有一个数列：0、1、1、2、3、5、8、13、21、34、55、89…，这个数列从第3项开始，每一项都等于前两项之和。以递推的方法定义：$F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N^*）$</p><pre><code class="python">def fibonacc(n):    if n == 1 or n == 2:        return 1    else:        return fibonacc(n-1) + fibonacc(n-2)</code></pre><p>以上方法的时间复杂度为$O(2^n)$，稍微大一点的数都会算很久，有一个简单的解决方案，使用 <code>lru_cache</code> 缓存装饰器，缓存一些中间结果：</p><pre><code class="python">from functools import lru_cache# 缓存斐波那契函数已经计算出的结果，最多占用1024字节内存@lru_cache(maxsize=1024)def fibonacc(n):    if n == 1 or n == 2:        return 1    else:        return fibonacc(n-1) + fibonacc(n-2)</code></pre><p>另外还有更加节省时间和空间的方法：</p><pre><code class="python">def fibonacc(n, current=0, next=1):    if n == 0:        return current    else:        return fibonacc(n-1, next, current+next)</code></pre><hr><h2 id="示例三：汉诺塔问题"><a href="#示例三：汉诺塔问题" class="headerlink" title="示例三：汉诺塔问题"></a>示例三：汉诺塔问题</h2><p>汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。64片黄金圆盘移动完毕之日，就是世界毁灭之时。</p><p><img src="https://img-blog.csdnimg.cn/20201028204105893.gif" alt="01汉诺塔"></p><p>对于 n 个盘子，移动步骤如下：</p><ul><li>把 n-1 个盘子由 A 经过 C 移动到 B</li><li>把最后一个盘子移动到 C</li><li>把 n-1 个盘子由 B 经过 A 移动到 C</li></ul><p><img src="https://img-blog.csdnimg.cn/20201028220237371.png" alt="02汉诺塔"></p><p>递归代码实现：</p><pre><code class="python">def hanoi(n, a, b, c):                                # n 个盘子，a，b，c三个柱子    if n &gt; 0:        hanoi(n-1, a, c, b)                           # 把 n-1 个盘子由 a 经过 c 移动到 b        print(&#39;moving from &#123;0&#125; to &#123;1&#125;&#39;.format(a, c))  # 把最后一个盘子移动到 c        hanoi(n-1, b, a, c)                           # 把 n-1 个盘子由 b 经过 a 移动到 c</code></pre><p>示例：</p><pre><code class="python">def hanoi(n, a, b, c):    if n &gt; 0:        hanoi(n-1, a, c, b)        print(&#39;moving from &#123;0&#125; to &#123;1&#125;&#39;.format(a, c))        hanoi(n-1, b, a, c)hanoi(3, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;)</code></pre><pre><code class="python">moving from A to Cmoving from A to Bmoving from C to Bmoving from A to Cmoving from B to Amoving from B to Cmoving from A to C</code></pre><hr><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。通俗来讲就是递归调用放在了函数的最后。</p><pre><code class="python"># 一般递归def func(n):    if n &gt; 0:        func(n-1)        print(n)# 一般递归def func(n):    if n &gt; 0:        return func(n-1) + n# 尾递归def func(n):    a = n    if n &gt; 0:        a += 1        print(a, n)        return func(n-1)</code></pre><p>对于普通的递归，每一级递归都产生了新的局部变量，必须创建新的调用栈，随着递归深度的增加，创建的栈越来越多，容易造成爆栈。</p><pre><code class="python">def normal_recursion(n):    if n == 1:        return 1    else:        return n + normal_recursion(n-1)</code></pre><p><code>normal_recursion(5)</code> 执行：</p><pre><code class="python">normal_recursion(5)5 + normal_recursion(4)5 + 4 + normal_recursion(3)5 + 4 + 3 + normal_recursion(2)5 + 4 + 3 + 2 + normal_recursion(1)5 + 4 + 3 + 35 + 4 + 65 + 1015</code></pre><p>尾递归基于函数的尾调用，每一级调用直接返回递归函数更新调用栈，没有新局部变量的产生，类似迭代的实现。</p><pre><code class="python">def tail_recursion(n, total=0):    if n == 0:        return total    else:        return tail_recursion(n-1, total+n)</code></pre><p><code>normal_recursion(5)</code> 执行：</p><pre><code class="python">tail_recursion(5, 0)tail_recursion(4, 5)tail_recursion(3, 9)tail_recursion(2, 12)tail_recursion(1, 14)tail_recursion(0, 15)15</code></pre><p>在 Python，Java，Pascal 等语言中是无法实现尾递归优化的，所以采用了 for，while，goto 等特殊结构以迭代的方式来代替尾递归。</p><hr><h2 id="Python-中尾递归的解决方案"><a href="#Python-中尾递归的解决方案" class="headerlink" title="Python 中尾递归的解决方案"></a>Python 中尾递归的解决方案</h2><p>使用普通的递归来实现斐波那契数列的计算，代码段如下：</p><pre><code class="python">def fibonacc(n, current=0, next=1):    if n == 0:        return current    else:        return fibonacc(n-1, next, current+next)a = fibonacc(1000)print(a)</code></pre><p>此时会报错，因为超过了最大递归深度（默认深度900-1000左右）：</p><pre><code class="python">Traceback (most recent call last):  File &quot;F:/PycharmProjects/algorithm/fibonacc_test.py&quot;, line 57, in &lt;module&gt;    a = fibonacc(1000)  File &quot;F:/PycharmProjects/algorithm/fibonacc_test.py&quot;, line 47, in fibonacc    return fibonacc(n-1, next, current+next)  File &quot;F:/PycharmProjects/algorithm/fibonacc_test.py&quot;, line 47, in fibonacc    return fibonacc(n-1, next, current+next)  File &quot;F:/PycharmProjects/algorithm/fibonacc_test.py&quot;, line 47, in fibonacc    return fibonacc(n-1, next, current+next)  [Previous line repeated 995 more times]  File &quot;F:/PycharmProjects/algorithm/fibonacc_test.py&quot;, line 44, in fibonacc    if n == 0:RecursionError: maximum recursion depth exceeded in comparison</code></pre><p>如果是递归深度不是很大的情况，可以手动重设递归深度来解决：</p><pre><code class="python">import syssys.setrecursionlimit(10000)  # 递归深度设置为 10000</code></pre><p>如果递归深度非常大，那么就可以采用尾递归优化，但是 Python 官方是并不支持尾递归的（不知道为啥），然而这难不到广大的程序员们，早在 2006 年 <a href="https://code.activestate.com/recipes/users/2792865/">Crutcher Dunnavant</a> 就想出了一个解决办法，实现一个 <code>tail_call_optimized</code> 装饰器，原文链接：<a href="https://code.activestate.com/recipes/474088/">https://code.activestate.com/recipes/474088/</a>，原代码是 Python 2.4 实现的，用 Python 3.x 实现如下：</p><pre><code class="python"># This program shows off a python decorator# which implements tail call optimization. It# does this by throwing an exception if it is# it&#39;s own grandparent, and catching such# exceptions to recall the stack.import sysclass TailRecurseException(BaseException):    def __init__(self, args, kwargs):        self.args = args        self.kwargs = kwargsdef tail_call_optimized(g):    &quot;&quot;&quot;    This function decorates a function with tail call    optimization. It does this by throwing an exception    if it is it&#39;s own grandparent, and catching such    exceptions to fake the tail call optimization.    This function fails if the decorated5    function recurses in a non-tail context.    &quot;&quot;&quot;    def func(*args, **kwargs):        f = sys._getframe()        if f.f_back and f.f_back.f_back and f.f_back.f_back.f_code == f.f_code:            raise TailRecurseException(args, kwargs)        else:            while 1:                try:                    return g(*args, **kwargs)                except TailRecurseException as e:                    args = e.args                    kwargs = e.kwargs    func.__doc__ = g.__doc__    return func</code></pre><p>使用该装饰器再来实现比较大的斐波那契数列的计算：</p><pre><code class="python">@tail_call_optimizeddef fibonacc(n, current=0, next=1):    if n == 0:        return current    else:        return fibonacc(n-1, next, current+next)a = fibonacc(1000)print(a)</code></pre><p>输出结果：</p><pre><code class="python">43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875</code></pre><p><code>tail_call_optimized</code> 实现尾递归优化的原理：当递归函数被该装饰器修饰后，递归调用在装饰器while循环内部进行，每当产生新的递归调用栈帧时，<code>f.f_back.f_back.f_code == f.f_code:</code> 就捕获当前尾调用函数的参数，并抛出异常，从而销毁递归栈并使用捕获的参数手动调用递归函数，所以递归的过程中始终只存在一个栈帧对象，达到优化的目的。</p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX•鲍勃。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/109322815未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;递归概念&quot;&gt;&lt;a href=&quot;#递归概念&quot; class=&quot;headerlink&quot; title=&quot;递归概念&quot;&gt;&lt;/a&gt;递归概念&lt;/h2&gt;&lt;p&gt;&lt;font color=#ff0000&gt;&lt;strong&gt;递归&lt;/strong&gt;&lt;/font&gt;：程序调用自身的编程技巧称为递归</summary>
      
    
    
    
    <category term="算法" scheme="https://www.itbob.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="算法" scheme="https://www.itbob.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python 实现十大经典排序算法</title>
    <link href="https://www.itbob.cn/article/036/"/>
    <id>https://www.itbob.cn/article/036/</id>
    <published>2020-10-23T16:12:00.000Z</published>
    <updated>2022-05-22T12:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考资料：<a href="https://www.bilibili.com/video/BV1mp4y1D7UP">https://www.bilibili.com/video/BV1mp4y1D7UP</a></li><li>本文动图演示来源：<a href="https://visualgo.net/">https://visualgo.net/</a></li></ul><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/108987300未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a><font color=#FF0000>排序算法分类</font></h2><ul><li><font color=#FF0000><strong>内部排序</strong></font>：指在排序期间，元素全部存放在内存中的排序，常见的内部排序算法有：<strong>冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、基数排序</strong>等。</li><li><font color=#FF0000><strong>外部排序</strong></font>：指在排序期间，元素无法完全全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序；</li><li><font color=#FF0000><strong>比较类排序</strong></font>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li><li><font color=#FF0000><strong>非比较类排序</strong></font>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 常见的非比较类排序算法有：<strong>基数排序、计数排序、桶排序</strong>等</li></ul><hr><p>一般情况下，内部排序算法在执行过程中都要进行两种操作：比较和移动。通过比较两个关键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。但是，并非所有的内部排序算法都要基于比较操作。</p><p>每种排序算法都有各自的优缺点，适合在不同的环境下使用，就其全面性能而言，很难提出一种被认为是最好的算法。<font color=#FF0000><strong>通常可以将排序算法分为插入排序、交换排序、选择排序、归并排序和基数排序五大类</strong></font>，内部排序算法的性能取决于算法的时间复杂度和空间复杂度，而时间复杂度一般是由比较和移动的次数决定的。</p><hr><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/01.png" alt="01"></p><table><thead><tr><th>排序算法</th><th>时间复杂度（平均）</th><th>时间复杂度（最好）</th><th>时间复杂度（最坏）</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$$ O(n^2) $$</td><td>$$ O(n) $$</td><td>$$ O(n^2) $$</td><td>$$ O(1) $$</td><td>稳定</td></tr><tr><td>选择排序</td><td>$$ O(n^2) $$</td><td>$$ O(n^2) $$</td><td>$$ O(n^2) $$</td><td>$$ O(1) $$</td><td>不稳定</td></tr><tr><td>插入排序</td><td>$$ O(n^2) $$</td><td>$$ O(n) $$</td><td>$$ O(n^2) $$</td><td>$$ O(1) $$</td><td>稳定</td></tr><tr><td>希尔排序</td><td>$$ O(nlogn) $$</td><td>$$ O(nlog^2n) $$</td><td>$$ O(nlog^2n) $$</td><td>$$ O(1) $$</td><td>不稳定</td></tr><tr><td>归并排序</td><td>$$ O(nlogn) $$</td><td>$$ O(nlogn) $$</td><td>$$ O(nlogn) $$</td><td>$$ O(n) $$</td><td>稳定</td></tr><tr><td>快速排序</td><td>$$ O(nlogn) $$</td><td>$$ O(nlogn) $$</td><td>$$ O(n^2) $$</td><td>$$ O(logn) $$</td><td>不稳定</td></tr><tr><td>堆排序</td><td>$$ O(nlogn) $$</td><td>$$ O(nlogn) $$</td><td>$$ O(nlogn) $$</td><td>$$ O(1) $$</td><td>不稳定</td></tr><tr><td>计数排序</td><td>$$ O(n+k) $$</td><td>$$ O(n+k) $$</td><td>$$ O(n+k) $$</td><td>$$ O(k) $$</td><td>稳定</td></tr><tr><td>桶排序</td><td>$$ O(n+k) $$</td><td>$$ O(n+k) $$</td><td>$$ O(n^2) $$</td><td>$$ O(n+k) $$</td><td>稳定</td></tr><tr><td>基数排序</td><td>$$ O(n*k) $$</td><td>$$ O(n*k) $$</td><td>$$ O(n*k) $$</td><td>$$ O(n+k) $$</td><td>稳定</td></tr></tbody></table><p><strong>稳定性</strong>：排序后 2 个相等键值的顺序和排序之前它们的顺序是否相同。例：如果 a 原本在 b 前面，且 a=b，排序之后 a 仍然在 b 的前面，则表示具有稳定性。</p><p>常见时间复杂度大小比较：</p><p>$$<br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt;…&lt; O(2^n)&lt;O (n!)<br>$$</p><hr><h2 id="一、冒泡排序（Bubble-Sort）"><a href="#一、冒泡排序（Bubble-Sort）" class="headerlink" title="一、冒泡排序（Bubble Sort）"></a><font color=#FF0000>一、冒泡排序（Bubble Sort）</font></h2><h3 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h3><p>重复地走访要排序的元素，依次比较两个相邻的元素，如果顺序（如从大到小）错误就把他们交换过来。走访元素的工作是重复地进行，直到没有相邻元素需要交换，也就是说该元素列已经排序完成。冒泡的意思其实就是每一轮冒泡一个最大的元素就会通过不断比较和交换相邻元素使它转移到最右边。</p><p>假如有 10 个小盆友从左到右站成一排，个头不等。老师想让他们按照个头从低到高站好，于是他开始喊口号。 每喊一次，从第一个小盆友开始，相邻的小朋友如果身高不是正序就会两两调换，就这样第一轮个头最高的排到了最右边（冒泡到最右边），第二轮依次这么来，从第一个小朋友开始两两交换，这样次高的小盆友又排到了倒数第二个位置。依次类推。</p><h3 id="2、步骤"><a href="#2、步骤" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li><strong>②</strong> 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li><strong>③</strong> 针对所有的元素重复步骤 <strong>①</strong> ~ <strong>②</strong>，除了最后一个元素，直到排序完成。</li></ul><h3 id="3、动画演示"><a href="#3、动画演示" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/02%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="02冒泡排序"></p><h3 id="4、代码实现"><a href="#4、代码实现" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def bubbleSort(arr):    for i in range(len(arr)-1):         # 循环第 i 趟        for j in range(len(arr)-i-1):   # j 为下标            if arr[j] &gt; arr[j+1]:       # 如果这个数大于后面的数就交换两者的位置                arr[j], arr[j+1] = arr[j+1], arr[j]    return arr</code></pre><p>冒泡排序还有一种优化算法，就是立一个 flag，当某一趟序列遍历中元素没有发生交换，则证明该序列已经有序，就不再进行后续的排序。动画演示里就是改进后的算法，改进后的代码如下：</p><pre><code class="python">def bubbleSort(arr):    for i in range(len(arr)-1):         # 循环第 i 趟    flag = False        for j in range(len(arr)-i-1):   # j 为下标            if arr[j] &gt; arr[j+1]:       # 如果这个数大于后面的数就交换两者的位置                arr[j], arr[j+1] = arr[j+1], arr[j]                flag = True        if not flag:            return    return arr</code></pre><p>冒泡排序最快的情况：当输入的数据是正序时；最慢的情况：当输入的数据是反序时。</p><h3 id="5、具体示例"><a href="#5、具体示例" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><p>未改进版本：</p><pre><code class="python">def bubble_sort(arr):    for i in range(len(arr)-1):         # 循环第 i 趟        for j in range(len(arr)-i-1):   # j 为下标            if arr[j] &gt; arr[j+1]:       # 如果这个数大于后面的数就交换两者的位置                arr[j], arr[j+1] = arr[j+1], arr[j]        print(arr)                      # 每一趟比较完了就打印一次arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]bubble_sort(arr)</code></pre><pre><code class="python">[3, 38, 5, 44, 15, 36, 26, 27, 2, 46, 4, 19, 47, 48, 50][3, 5, 38, 15, 36, 26, 27, 2, 44, 4, 19, 46, 47, 48, 50][3, 5, 15, 36, 26, 27, 2, 38, 4, 19, 44, 46, 47, 48, 50][3, 5, 15, 26, 27, 2, 36, 4, 19, 38, 44, 46, 47, 48, 50][3, 5, 15, 26, 2, 27, 4, 19, 36, 38, 44, 46, 47, 48, 50][3, 5, 15, 2, 26, 4, 19, 27, 36, 38, 44, 46, 47, 48, 50][3, 5, 2, 15, 4, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][3, 2, 5, 4, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</code></pre><p>改进版本：</p><pre><code class="python">def bubble_sort(arr):    for i in range(len(arr)-1):         # 循环第 i 趟        flag = False        for j in range(len(arr)-i-1):   # j 为下标            if arr[j] &gt; arr[j+1]:       # 如果这个数大于后面的数就交换两者的位置                arr[j], arr[j+1] = arr[j+1], arr[j]                flag = True        if not flag:            return        print(arr)                      # 每一趟比较完了就打印一次arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]bubble_sort(arr)</code></pre><pre><code class="python">[3, 38, 5, 44, 15, 36, 26, 27, 2, 46, 4, 19, 47, 48, 50][3, 5, 38, 15, 36, 26, 27, 2, 44, 4, 19, 46, 47, 48, 50][3, 5, 15, 36, 26, 27, 2, 38, 4, 19, 44, 46, 47, 48, 50][3, 5, 15, 26, 27, 2, 36, 4, 19, 38, 44, 46, 47, 48, 50][3, 5, 15, 26, 2, 27, 4, 19, 36, 38, 44, 46, 47, 48, 50][3, 5, 15, 2, 26, 4, 19, 27, 36, 38, 44, 46, 47, 48, 50][3, 5, 2, 15, 4, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][3, 2, 5, 4, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</code></pre><hr><h2 id="二、选择排序（Selection-Sort）"><a href="#二、选择排序（Selection-Sort）" class="headerlink" title="二、选择排序（Selection Sort）"></a><font color=#FF0000>二、选择排序（Selection Sort）</font></h2><h3 id="1、原理-1"><a href="#1、原理-1" class="headerlink" title="1、原理"></a>1、原理</h3><p>第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。可以理解为 一个 0 到 n-1 的迭代，每次向后查找选择一个最小的元素。选择排序是不稳定的排序方法。</p><p>假如有 10 个小盆友从左到右站成一排，个头不等。老师想让他们按照个头从低到高站好，我们从第一个开始，从头到尾找一个个头最小的小盆友，然后把它和第一个小盆友交换。 然后从第二个小盆友开始采取同样的策略，这样一圈下来小盆友就是有序的了。</p><h3 id="2、步骤-1"><a href="#2、步骤-1" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；</li><li><strong>②</strong> 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；</li><li><strong>③</strong> 重复步骤 <strong>②</strong>，直到所有元素均排序完毕。</li></ul><h3 id="3、动画演示-1"><a href="#3、动画演示-1" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/03%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="03选择排序"></p><h3 id="4、代码实现-1"><a href="#4、代码实现-1" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><p>Python 代码：</p><pre><code class="python">def selection_sort(arr):    for i in range(len(arr)-1):          # 循环第 i 趟        min_index = i                    # 记录最小数的下标        for j in range(i+1, len(arr)):   # j 为下标            if arr[j] &lt; arr[min_index]:  # 如果这个数小于记录的最小数，则更新最小数的下标                min_index = j        arr[i], arr[min_index] = arr[min_index], arr[i]  # 将 i 位置的数（已排序序列的末尾的数）和最小数进行交换    return arr</code></pre><h3 id="5、具体示例-1"><a href="#5、具体示例-1" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def selection_sort(arr):    for i in range(len(arr)-1):          # 循环第 i 趟        min_index = i                    # 记录最小数的下标        for j in range(i+1, len(arr)):   # j 为下标            if arr[j] &lt; arr[min_index]:  # 如果这个数小于记录的最小数，则更新最小数的下标                min_index = j        arr[i], arr[min_index] = arr[min_index], arr[i]  # 将 i 位置的数（已排序序列的末尾的数）和最小数进行交换        print(arr)                       # 每一趟比较完了就打印一次arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]selection_sort(arr)</code></pre><pre><code class="python">[2, 44, 38, 5, 47, 15, 36, 26, 27, 3, 46, 4, 19, 50, 48][2, 3, 38, 5, 47, 15, 36, 26, 27, 44, 46, 4, 19, 50, 48][2, 3, 4, 5, 47, 15, 36, 26, 27, 44, 46, 38, 19, 50, 48][2, 3, 4, 5, 47, 15, 36, 26, 27, 44, 46, 38, 19, 50, 48][2, 3, 4, 5, 15, 47, 36, 26, 27, 44, 46, 38, 19, 50, 48][2, 3, 4, 5, 15, 19, 36, 26, 27, 44, 46, 38, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 36, 27, 44, 46, 38, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 44, 46, 38, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 44, 46, 38, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 46, 44, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</code></pre><hr><h2 id="三、插入排序（Insertion-Sort）"><a href="#三、插入排序（Insertion-Sort）" class="headerlink" title="三、插入排序（Insertion Sort）"></a><font color=#FF0000>三、插入排序（Insertion Sort）</font></h2><h3 id="1、原理-2"><a href="#1、原理-2" class="headerlink" title="1、原理"></a>1、原理</h3><p>插入排序一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法。它的基本思想是将一个记录插入到已经排好序的有序表中，从而形成一个新的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素进行遍历，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。</p><p>插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。拿在左手上的牌总是排序好的，原来这些牌是桌子上牌堆中顶部的牌。</p><h3 id="2、步骤-2"><a href="#2、步骤-2" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 从第一个元素开始，该元素可以认为已经被排序；</li><li><strong>②</strong> 取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li><strong>③</strong> 如果该元素（已排序的）大于新元素，将该元素往右移到下一位置，重复该步骤，直到找到已排序的元素小于或者等于新元素的位置；</li><li><strong>④</strong> 将新元素插入到步骤 <strong>③</strong> 找到的位置的后面；</li><li><strong>⑤</strong> 重复步骤 <strong>②</strong> ~ <strong>④</strong>。</li></ul><h3 id="3、动画演示-2"><a href="#3、动画演示-2" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/04%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="04插入排序"></p><h3 id="4、代码实现-2"><a href="#4、代码实现-2" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def insertion_sort(arr):    for i in range(1, len(arr)):    # 将 i 看做摸到的牌的下标        tmp = arr[i]                # 将摸到的牌储存到 tmp        j = i-1                     # 将 j 看做手里的牌的下标        while j &gt;= 0 and arr[j] &gt; tmp:  # 如果手里的牌大于摸到的牌            arr[j+1] = arr[j]       # 将手里的牌往右移一个位置（将手里的牌赋值给下一个位置）            j -= 1                  # 将手里的牌的下标减 1，再次准备与摸到的牌进行比较        arr[j+1] = tmp              # 将摸到的牌插入到 j+1 位置    return arr</code></pre><h3 id="5、具体示例-2"><a href="#5、具体示例-2" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def insertion_sort(arr):    for i in range(1, len(arr)):    # 将 i 看做摸到的牌的下标        tmp = arr[i]                # 将摸到的牌储存到 tmp        j = i-1                     # 将 j 看做手里的牌的下标        while j &gt;= 0 and arr[j] &gt; tmp:  # 如果手里的牌大于摸到的牌            arr[j+1] = arr[j]       # 将手里的牌往右移一个位置（将手里的牌赋值给下一个位置）            j -= 1                  # 将手里的牌的下标减 1，再次准备与摸到的牌进行比较        arr[j+1] = tmp              # 将摸到的牌插入到 j+1 位置        print(arr)                  # 每一趟比较完了就打印一次arr = [0, 9, 8, 7, 1, 2, 3, 4, 5, 6]insertion_sort(arr)</code></pre><pre><code class="python">[0, 9, 8, 7, 1, 2, 3, 4, 5, 6]  # 手里第一张牌为 0，摸到 9，此时 i=1，j=0，0 比 9 小，将 9 插到索引 j+1=1 处。[0, 8, 9, 7, 1, 2, 3, 4, 5, 6]  # 手里的牌为 0，9，摸到 8，此时 i=2，j=1，9 比 8 大，将 9 右移一个位置，j-1=0，将 8 插到 j+1=1 处[0, 7, 8, 9, 1, 2, 3, 4, 5, 6][0, 1, 7, 8, 9, 2, 3, 4, 5, 6][0, 1, 2, 7, 8, 9, 3, 4, 5, 6][0, 1, 2, 3, 7, 8, 9, 4, 5, 6][0, 1, 2, 3, 4, 7, 8, 9, 5, 6][0, 1, 2, 3, 4, 5, 7, 8, 9, 6][0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><hr><h2 id="四、希尔排序（Shell-Sort）"><a href="#四、希尔排序（Shell-Sort）" class="headerlink" title="四、希尔排序（Shell Sort）"></a><font color=#FF0000>四、希尔排序（Shell Sort）</font></h2><h3 id="1、原理-3"><a href="#1、原理-3" class="headerlink" title="1、原理"></a>1、原理</h3><p>希尔排序是插入排序的一种更高效的改进版本，是一种分组插入排序算法，又称缩小增量排序（Diminishing Increment Sort），希尔排序是非稳定排序算法。该方法因 D.L.Shell 于 1959 年提出而得名。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h3 id="2、步骤-3"><a href="#2、步骤-3" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> n 为数组长度，首先取一个整数 <strong>d1=n/2</strong>，将元素分为 <strong>d1</strong> 个组，每组相邻量元素之间距离为 <strong>d1-1</strong>，在各组内进行直接插入排序；</li><li><strong>②</strong> 取第二个整数 <strong>d2=d1/2</strong>，重复步骤 <strong>①</strong> 分组排序过程，直到 <strong>di=1</strong>，即所有元素在同一组内进行直接插入排序。</li></ul><p>PS：希尔排序每趟并不使某些元素有序，而是使整体数据越来越接近有序；最后一趟排序使得所有数据有序。</p><h3 id="3、动画演示-3"><a href="#3、动画演示-3" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/05%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt="05希尔排序"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/06%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt="06希尔排序"></p><h3 id="4、代码实现-3"><a href="#4、代码实现-3" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def insertion_sort_gap(arr, gap):     # 将 gap 看做隔 gap 个距离摸一张牌，而不是依次按照顺序摸牌    for i in range(gap, len(arr)):    # 将 i 看做摸到的牌的下标        tmp = arr[i]                  # 将摸到的牌储存到 tmp        j = i-gap                     # 将 j 看做手里的牌的下标        while j &gt;= 0 and arr[j] &gt; tmp:  # 如果手里的牌大于摸到的牌            arr[j+gap] = arr[j]         # 将手里的牌往右移一个位置（将手里的牌赋值给下一个位置）            j -= gap                    # 将手里的牌的下标减 gap，再次准备与摸到的牌进行比较        arr[j+gap] = tmp                # 将摸到的牌插入到 j+gap 位置def shell_sort(arr):    d = len(arr) // 2                   # 第一次分组    while d &gt;= 1:        insertion_sort_gap(arr, d)      # 调用插入排序        d //= 2                         # 整除 2 后再次分组    return arr</code></pre><p>也可以不使用两个函数，写在一起即可：</p><pre><code class="python">def shell_sort(arr):    d = len(arr) // 2                   # 第一次分组    while d &gt;= 1:                       # 将 d 看做隔 d 个距离摸一张牌，而不是依次按照顺序摸牌        for i in range(d, len(arr)):    # 将 i 看做摸到的牌的下标            tmp = arr[i]                # 将摸到的牌储存到 tmp            j = i - d                   # 将 j 看做手里的牌的下标            while j &gt;= 0 and arr[j] &gt; tmp:   # 如果手里的牌大于摸到的牌                arr[j + d] = arr[j]          # 将手里的牌往右移一个位置（将手里的牌赋值给下一个位置）                j -= d                       # 将手里的牌的下标减 d，再次准备与摸到的牌进行比较            arr[j + d] = tmp                 # 将摸到的牌插入到 j+d 位置        d //= 2                              # 整除 2 后再次分组    return arr</code></pre><h3 id="5、具体示例-3"><a href="#5、具体示例-3" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def insertion_sort_gap(arr, gap):     # 将 gap 看做隔 gap 个距离摸一张牌，而不是依次按照顺序摸牌    for i in range(gap, len(arr)):    # 将 i 看做摸到的牌的下标        tmp = arr[i]                  # 将摸到的牌储存到 tmp        j = i-gap                     # 将 j 看做手里的牌的下标        while j &gt;= 0 and arr[j] &gt; tmp:  # 如果手里的牌大于摸到的牌            arr[j+gap] = arr[j]         # 将手里的牌往右移一个位置（将手里的牌赋值给下一个位置）            j -= gap                    # 将手里的牌的下标减 gap，再次准备与摸到的牌进行比较        arr[j+gap] = tmp                # 将摸到的牌插入到 j+gap 位置def shell_sort(arr):    d = len(arr) // 2                   # 第一次分组    while d &gt;= 1:        insertion_sort_gap(arr, d)      # 调用插入排序        print(arr)                      # 每一轮排序后打印一次        d //= 2                         # 整除 2 后再次分组arr = [5, 7, 4, 6, 3, 1, 2, 9, 8]shell_sort(arr)</code></pre><pre><code class="python">[3, 1, 2, 6, 5, 7, 4, 9, 8][2, 1, 3, 6, 4, 7, 5, 9, 8][1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><pre><code class="python">def shell_sort(arr):    d = len(arr) // 2                   # 第一次分组    while d &gt;= 1:                       # 将 d 看做隔 d 个距离摸一张牌，而不是依次按照顺序摸牌        for i in range(d, len(arr)):    # 将 i 看做摸到的牌的下标            tmp = arr[i]                # 将摸到的牌储存到 tmp            j = i - d                   # 将 j 看做手里的牌的下标            while j &gt;= 0 and arr[j] &gt; tmp:   # 如果手里的牌大于摸到的牌                arr[j + d] = arr[j]          # 将手里的牌往右移一个位置（将手里的牌赋值给下一个位置）                j -= d                       # 将手里的牌的下标减 d，再次准备与摸到的牌进行比较            arr[j + d] = tmp                 # 将摸到的牌插入到 j+d 位置        print(arr)                           # 每一轮排序后打印一次        d //= 2                              # 整除 2 后再次分组arr = [5, 7, 4, 6, 3, 1, 2, 9, 8]shell_sort(arr)</code></pre><pre><code class="python">[3, 1, 2, 6, 5, 7, 4, 9, 8][2, 1, 3, 6, 4, 7, 5, 9, 8][1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><hr><h2 id="五、归并排序（Merge-Sort）"><a href="#五、归并排序（Merge-Sort）" class="headerlink" title="五、归并排序（Merge Sort）"></a><font color=#FF0000>五、归并排序（Merge Sort）</font></h2><h3 id="1、原理-4"><a href="#1、原理-4" class="headerlink" title="1、原理"></a>1、原理</h3><p>归并的概念：假设一个列表分为两段，其中每一段都是有序列表，现在将该两段合并为一个有序列表，这种操作称为一次归并。</p><p>归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/08.png" alt="08"></p><h3 id="2、步骤-4"><a href="#2、步骤-4" class="headerlink" title="2、步骤"></a>2、步骤</h3><p><font color=#ff0000><strong>归并的基本步骤：</strong></font></p><ul><li><strong>①</strong> 申请空间，使其大小为<strong>两个已经排序序列之和</strong>，该空间用来存放合并后的序列；</li><li><strong>②</strong> 设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li><strong>③</strong> 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li><strong>④</strong> 重复步骤 <strong>③</strong> 直到某一指针达到序列尾；</li><li><strong>⑤</strong> 将另一序列剩下的所有元素直接复制到合并序列尾。</li></ul><p><font color=#ff0000><strong>归并排序的步骤：</strong></font></p><ul><li><strong>①</strong> 分解：将列表越分越小，直至分成一个元素，终止条件：一个元素是有序的。</li><li><strong>②</strong> 合并：不断将两个有序列表进行归并，列表越来越大，直到所有序列归并完毕。</li></ul><h3 id="3、动画演示-4"><a href="#3、动画演示-4" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/07%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="07归并排序"></p><h3 id="4、代码实现-4"><a href="#4、代码实现-4" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def merge(arr, low, mid, high):    # low 和 high 为整个数组的第一个和最后一个位置索引，mid 为中间位置索引    # i 和 j 为指针，最初位置分别为两个有序序列的起始位置    # ltmp 用来存放合并后的序列    i = low    j = mid+1    ltmp = []    while i &lt;= mid and j &lt;= high:  # 只要左右两边都有数        if arr[i] &lt; arr[j]:        # 当左边的数小于右边的数            ltmp.append(arr[i])    # 将左边的数存入 ltmp            i += 1                 # 左边的指针往右移一位        else:                      # 当右边的数小于左边的数            ltmp.append(arr[j])    # 将右边的数存入 ltmp            j += 1                 # 右边的指针往右移一位    # 上面的 while 语句执行完后，左边或者右边没有数了    while i &lt;= mid:                # 当左边还有数的时候        ltmp.append(arr[i])        # 将左边剩下的数全部存入 ltmp        i += 1    while j &lt;= high:               # 当右边还有数的时候        ltmp.append(arr[j])        # 将右边剩下的数全部存入 ltmp        j += 1    arr[low:high+1] = ltmp         # 将排序后的数组写回原数组def merge_sort(arr, low, high):       # low 和 high 为整个数组的第一个和最后一个位置索引    if low &lt; high:                    # 至少有两个元素        mid = (low + high) // 2        merge_sort(arr, low, mid)     # 把左边递归分解        merge_sort(arr, mid+1, high)  # 把右边递归分解        merge(arr, low, mid, high)    # 做归并</code></pre><h3 id="5、具体示例-4"><a href="#5、具体示例-4" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def merge(arr, low, mid, high):    # low 和 high 为整个数组的第一个和最后一个位置索引，mid 为中间位置索引    # i 和 j 为指针，最初位置分别为两个有序序列的起始位置    # ltmp 用来存放合并后的序列    i = low    j = mid+1    ltmp = []    while i &lt;= mid and j &lt;= high:  # 只要左右两边都有数        if arr[i] &lt; arr[j]:        # 当左边的数小于右边的数            ltmp.append(arr[i])    # 将左边的数存入 ltmp            i += 1                 # 左边的指针往右移一位        else:                      # 当右边的数小于左边的数            ltmp.append(arr[j])    # 将右边的数存入 ltmp            j += 1                 # 右边的指针往右移一位    # 上面的 while 语句执行完后，左边或者右边没有数了    while i &lt;= mid:                # 当左边还有数的时候        ltmp.append(arr[i])        # 将左边剩下的数全部存入 ltmp        i += 1    while j &lt;= high:               # 当右边还有数的时候        ltmp.append(arr[j])        # 将右边剩下的数全部存入 ltmp        j += 1    arr[low:high+1] = ltmp         # 将排序后的数组写回原数组def merge_sort(arr, low, high):       # low 和 high 为整个数组的第一个和最后一个位置索引    if low &lt; high:                    # 至少有两个元素        mid = (low + high) // 2        merge_sort(arr, low, mid)     # 把左边递归分解        merge_sort(arr, mid+1, high)  # 把右边递归分解        merge(arr, low, mid, high)    # 做归并        print(arr)                    # 每一次归并打印一次arr = [7, 1, 3, 2, 6, 9, 4]merge_sort(arr, 0, len(arr)-1)</code></pre><pre><code class="python">[1, 7, 3, 2, 6, 9, 4][1, 7, 2, 3, 6, 9, 4][1, 2, 3, 7, 6, 9, 4][1, 2, 3, 7, 6, 9, 4][1, 2, 3, 7, 4, 6, 9][1, 2, 3, 4, 6, 7, 9]</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/108987300未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="六、快速排序（Quick-Sort）"><a href="#六、快速排序（Quick-Sort）" class="headerlink" title="六、快速排序（Quick Sort）"></a><font color=#FF0000>六、快速排序（Quick Sort）</font></h2><h3 id="1、原理-5"><a href="#1、原理-5" class="headerlink" title="1、原理"></a>1、原理</h3><p>快速排序是对冒泡排序的一种改进。顾名思义快速排序就是快，而且效率高！它是处理大数据最快的排序算法之一了。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h3 id="2、步骤-5"><a href="#2、步骤-5" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 从数列中挑出一个元素，称为 “基准值”;</li><li><strong>②</strong> 重新排序数列，所有元素比基准值小的放在基准值的左边，比基准值大的放在基准值的右边（相同的数可以到任一边）。在这个分区退出之后，该基准值就处于数列的中间位置。这个称为分区（partition）操作，也可以称为一次归位操作，归位操作的过程见下动图；</li><li><strong>③</strong> 递归地把小于基准值元素的子数列和大于基准值元素的子数列按照步骤 <strong>① ②</strong> 排序。</li></ul><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/09%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="09快速排序"></p><h3 id="3、动画演示-5"><a href="#3、动画演示-5" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/10%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="10快速排序"></p><h3 id="4、代码实现-5"><a href="#4、代码实现-5" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def partition(arr, left, right):    # 归位操作，left，right 分别为数组左边和右边的位置索引    tmp = arr[left]    while left &lt; right:        while left &lt; right and arr[right] &gt;= tmp:  # 从右边找比 tmp 小的数，如果比 tmp 大，则移动指针            right -= 1                             # 将指针左移一个位置        arr[left] = arr[right]                     # 将右边的值写到左边的空位上        while left &lt; right and arr[left] &lt;= tmp:   # 从左边找比 tmp 大的数，如果比 tmp 小，则移动指针            left += 1                              # 将指针右移一个位置        arr[right] = arr[left]                     # 将左边的值写到右边的空位上    arr[left] = tmp                                # 把 tmp 归位    return left                   # 返回 left，right 都可以，目的是便于后面的递归操作对左右两部分进行排序def quick_sort(arr, left, right):          # 快速排序    if left &lt; right:        mid = partition(arr, left, right)        quick_sort(arr, left, mid-1)       # 对左半部分进行归位操作        quick_sort(arr, mid+1, right)      # 对右半部分进行归位操作    return arr</code></pre><h3 id="5、具体示例-5"><a href="#5、具体示例-5" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def partition(arr, left, right):    # 归位操作，left，right 分别为数组左边和右边的位置索引    tmp = arr[left]    while left &lt; right:        while left &lt; right and arr[right] &gt;= tmp:  # 从右边找比 tmp 小的数，如果比 tmp 大，则移动指针            right -= 1                             # 将指针左移一个位置        arr[left] = arr[right]                     # 将右边的值写到左边的空位上        while left &lt; right and arr[left] &lt;= tmp:   # 从左边找比 tmp 大的数，如果比 tmp 小，则移动指针            left += 1                              # 将指针右移一个位置        arr[right] = arr[left]                     # 将左边的值写到右边的空位上    arr[left] = tmp                                # 把 tmp 归位    return left                   # 返回 left，right 都可以，目的是便于后面的递归操作对左右两部分进行排序def quick_sort(arr, left, right):    if left &lt; right:        mid = partition(arr, left, right)        print(arr)                         # 每次归位后打印一次        quick_sort(arr, left, mid-1)       # 对左半部分进行归位操作        quick_sort(arr, mid+1, right)      # 对右半部分进行归位操作arr = [5, 7, 4, 6, 3, 1, 2, 9, 8]quick_sort(arr, 0, len(arr)-1)</code></pre><pre><code class="python">[2, 1, 4, 3, 5, 6, 7, 9, 8][1, 2, 4, 3, 5, 6, 7, 9, 8][1, 2, 3, 4, 5, 6, 7, 9, 8][1, 2, 3, 4, 5, 6, 7, 9, 8][1, 2, 3, 4, 5, 6, 7, 9, 8][1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><hr><h2 id="七、堆排序（Heap-Sort）"><a href="#七、堆排序（Heap-Sort）" class="headerlink" title="七、堆排序（Heap Sort）"></a><font color=#FF0000>七、堆排序（Heap Sort）</font></h2><h3 id="1、原理-6"><a href="#1、原理-6" class="headerlink" title="1、原理"></a>1、原理</h3><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><ul><li>堆：一种特殊的完全二叉树结构</li><li>大根堆：一棵完全二叉树，满足任一节点都比其孩子节点大</li><li>小根堆：一棵完全二叉树，满足任一节点都比其孩子节点小</li></ul><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/11%E5%A0%86%E6%8E%92%E5%BA%8F.png" alt="11堆排序"></p><h3 id="2、步骤-6"><a href="#2、步骤-6" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li>① 构建堆：将待排序序列构建成一个堆 H[0……n-1]，从最后一个非叶子结点开始，从左至右，从下至上进行调整。根据升序或降序需求选择大顶堆或小顶堆；</li><li>② 此时的堆顶元素，为最大或者最小元素；</li><li>③ 把堆顶元素和堆尾元素互换，调整堆，重新使堆有序；</li><li>④ 此时堆顶元素为第二大元素；</li><li>⑤ 重复以上步骤，直到堆变空。</li></ul><h3 id="3、动画演示-6"><a href="#3、动画演示-6" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/12%E6%9E%84%E5%BB%BA%E5%A0%86.gif" alt="12构建堆"></p><p>堆构建完成后再进行推排序：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/13%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="13堆排序"></p><h3 id="4、代码实现-6"><a href="#4、代码实现-6" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def sift(arr, low, high):    &quot;&quot;&quot;    :param li: 列表    :param low: 堆的根节点位置    :param high: 堆的最后一个元素的位置    &quot;&quot;&quot;    i = low                 # i最开始指向根节点    j = 2 * i + 1           # j开始是左孩子    tmp = arr[low]          # 把堆顶存起来    while j &lt;= high:        # 只要j位置有数        if j + 1 &lt;= high and arr[j+1] &gt; arr[j]:   # 如果右孩子有并且比较大            j = j + 1       # j指向右孩子        if arr[j] &gt; tmp:            arr[i] = arr[j]            i = j           # 往下看一层            j = 2 * i + 1        else:               # tmp更大，把tmp放到i的位置上            arr[i] = tmp    # 把tmp放到某一级领导位置上            break    else:        arr[i] = tmp        # 把tmp放到叶子节点上def heap_sort(arr):    n = len(arr)    for i in range((n-2)//2, -1, -1):   # i表示建堆的时候调整的部分的根的下标        sift(arr, i, n-1)    # 建堆完成    for i in range(n-1, -1, -1):        # i 指向当前堆的最后一个元素        arr[0], arr[i] = arr[i], arr[0]        sift(arr, 0, i - 1)             # i-1是新的high    return arr</code></pre><h3 id="5、具体示例-6"><a href="#5、具体示例-6" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def sift(arr, low, high):    &quot;&quot;&quot;    :param li: 列表    :param low: 堆的根节点位置    :param high: 堆的最后一个元素的位置    &quot;&quot;&quot;    i = low                 # i最开始指向根节点    j = 2 * i + 1           # j开始是左孩子    tmp = arr[low]          # 把堆顶存起来    while j &lt;= high:        # 只要j位置有数        if j + 1 &lt;= high and arr[j+1] &gt; arr[j]:   # 如果右孩子有并且比较大            j = j + 1       # j指向右孩子        if arr[j] &gt; tmp:            arr[i] = arr[j]            i = j           # 往下看一层            j = 2 * i + 1        else:               # tmp更大，把tmp放到i的位置上            arr[i] = tmp    # 把tmp放到某一级领导位置上            break    else:        arr[i] = tmp        # 把tmp放到叶子节点上def heap_sort(arr):    n = len(arr)    print(&#39;建堆过程：&#39;)    print(arr)    for i in range((n-2)//2, -1, -1):   # i表示建堆的时候调整的部分的根的下标        sift(arr, i, n-1)        print(arr)    # 建堆完成    print(&#39;堆排序过程：&#39;)    print(arr)    for i in range(n-1, -1, -1):        # i 指向当前堆的最后一个元素        arr[0], arr[i] = arr[i], arr[0]        sift(arr, 0, i - 1)             # i-1是新的high        print(arr)arr = [2, 7, 26, 25, 19, 17, 1, 90, 3, 36]heap_sort(arr)</code></pre><pre><code class="python">建堆过程：[2, 7, 26, 25, 19, 17, 1, 90, 3, 36][2, 7, 26, 25, 36, 17, 1, 90, 3, 19][2, 7, 26, 90, 36, 17, 1, 25, 3, 19][2, 7, 26, 90, 36, 17, 1, 25, 3, 19][2, 90, 26, 25, 36, 17, 1, 7, 3, 19][90, 36, 26, 25, 19, 17, 1, 7, 3, 2]堆排序过程：[90, 36, 26, 25, 19, 17, 1, 7, 3, 2][36, 25, 26, 7, 19, 17, 1, 2, 3, 90][26, 25, 17, 7, 19, 3, 1, 2, 36, 90][25, 19, 17, 7, 2, 3, 1, 26, 36, 90][19, 7, 17, 1, 2, 3, 25, 26, 36, 90][17, 7, 3, 1, 2, 19, 25, 26, 36, 90][7, 2, 3, 1, 17, 19, 25, 26, 36, 90][3, 2, 1, 7, 17, 19, 25, 26, 36, 90][2, 1, 3, 7, 17, 19, 25, 26, 36, 90][1, 2, 3, 7, 17, 19, 25, 26, 36, 90][1, 2, 3, 7, 17, 19, 25, 26, 36, 90]</code></pre><hr><h2 id="八、计数排序（Counting-Sort）"><a href="#八、计数排序（Counting-Sort）" class="headerlink" title="八、计数排序（Counting Sort）"></a><font color=#FF0000>八、计数排序（Counting Sort）</font></h2><h3 id="1、原理-7"><a href="#1、原理-7" class="headerlink" title="1、原理"></a>1、原理</h3><p>计数排序是一个非基于比较的排序算法，它的优势在于在对一定范围内的整数排序时，它的复杂度为 Ο(n+k)，其中 k 是整数的范围，快于任何比较排序算法。计数排序是一种牺牲空间换取时间的做法。计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，<strong>计数排序要求输入的数据必须是有确定范围的整数。</strong></p><h3 id="2、步骤-7"><a href="#2、步骤-7" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 找到待排序列表中的最大值 k，开辟一个长度为 k+1 的计数列表，计数列表中的值都为 0。</li><li><strong>②</strong> 遍历待排序列表，如果遍历到的元素值为 i，则计数列表中索引 i 的值加1。</li><li><strong>③</strong> 遍历完整个待排序列表，计数列表中索引 i 的值 j 表示 i 的个数为 j，统计出待排序列表中每个值的数量。</li><li><strong>④</strong> 创建一个新列表（也可以清空原列表，在原列表中添加），遍历计数列表，依次在新列表中添加 j 个 i，新列表就是排好序后的列表，整个过程没有比较待排序列表中的数据大小。</li></ul><h3 id="3、动画演示-7"><a href="#3、动画演示-7" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/14%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="14计数排序"></p><h3 id="4、代码实现-7"><a href="#4、代码实现-7" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def count_sort(arr):    if len(arr) &lt; 2:                       # 如果数组长度小于 2 则直接返回        return arr    max_num = max(arr)    count = [0 for _ in range(max_num+1)]  # 开辟一个计数列表    for val in arr:        count[val] += 1    arr.clear()                        # 原数组清空    for ind, val in enumerate(count):  # 遍历值和下标（值的数量）        for i in range(val):            arr.append(ind)    return arr</code></pre><h3 id="5、具体示例-7"><a href="#5、具体示例-7" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def count_sort(arr):    if len(arr) &lt; 2:                       # 如果数组长度小于 2 则直接返回        return arr    max_num = max(arr)    count = [0 for _ in range(max_num+1)]  # 开辟一个计数列表    for val in arr:        count[val] += 1    arr.clear()                        # 原数组清空    for ind, val in enumerate(count):  # 遍历值和下标（值的数量）        for i in range(val):            arr.append(ind)    return arrarr = [2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2]sorted_arr = count_sort(arr)print(sorted_arr)</code></pre><pre><code class="python">[1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]</code></pre><hr><h2 id="九、桶排序（Bucket-Sort）"><a href="#九、桶排序（Bucket-Sort）" class="headerlink" title="九、桶排序（Bucket Sort）"></a><font color=#FF0000>九、桶排序（Bucket Sort）</font></h2><h3 id="1、原理-8"><a href="#1、原理-8" class="headerlink" title="1、原理"></a>1、原理</h3><p>桶排序又叫箱排序，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。</p><p>桶排序也是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ul><li>在额外空间充足的情况下，尽量增大桶的数量；</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中。</li></ul><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><ul><li>最快情况：当输入的数据可以均匀的分配到每一个桶中；</li><li>最慢情况：当输入的数据被分配到了同一个桶中。</li></ul><h3 id="2、步骤-8"><a href="#2、步骤-8" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 创建一个定量的数组当作空桶子；</li><li><strong>②</strong> 遍历序列，把元素一个一个放到对应的桶子去；</li><li><strong>③</strong> 对每个不是空的桶子进行排序；</li><li><strong>④</strong> 从不是空的桶子里把元素再放回原来的序列中。</li></ul><h3 id="3、动画演示-8"><a href="#3、动画演示-8" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p>（动图来源于@五分钟学算法，侵删）</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/15%E6%A1%B6%E6%8E%92%E5%BA%8F.gif" alt="15桶排序"></p><h3 id="4、代码实现-8"><a href="#4、代码实现-8" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def bucket_sort(arr):    max_num = max(arr)    n = len(arr)    buckets = [[] for _ in range(n)]         # 创建桶    for var in arr:        i = min(var // (max_num // n), n-1)  # i 表示 var 放到几号桶里        buckets[i].append(var)               # 把 var 加到桶里边        # 保持桶内的顺序        for j in range(len(buckets[i])-1, 0, -1):            if buckets[i][j] &lt; buckets[i][j-1]:                buckets[i][j], buckets[i][j-1] = buckets[i][j-1], buckets[i][j]            else:                break    sorted_arr = []    for buc in buckets:        sorted_arr.extend(buc)    return sorted_arr</code></pre><h3 id="5、具体示例-8"><a href="#5、具体示例-8" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def bucket_sort(arr):    max_num = max(arr)    n = len(arr)    buckets = [[] for _ in range(n)]         # 创建桶    for var in arr:        i = min(var // (max_num // n), n-1)  # i 表示 var 放到几号桶里        buckets[i].append(var)               # 把 var 加到桶里边        # 保持桶内的顺序        for j in range(len(buckets[i])-1, 0, -1):            if buckets[i][j] &lt; buckets[i][j-1]:                buckets[i][j], buckets[i][j-1] = buckets[i][j-1], buckets[i][j]            else:                break    sorted_arr = []    for buc in buckets:        sorted_arr.extend(buc)    return sorted_arrarr = [7, 12, 56, 23, 19, 33, 35, 42, 42, 2, 8, 22, 39, 26, 17]sorted_arr = bucket_sort(arr)print(sorted_arr)</code></pre><pre><code class="python">[2, 7, 8, 12, 17, 19, 22, 23, 26, 33, 35, 39, 42, 42, 56]</code></pre><hr><h2 id="十、基数排序（Radix-Sort）"><a href="#十、基数排序（Radix-Sort）" class="headerlink" title="十、基数排序（Radix Sort）"></a><font color=#FF0000>十、基数排序（Radix Sort）</font></h2><h3 id="1、原理-9"><a href="#1、原理-9" class="headerlink" title="1、原理"></a>1、原理</h3><p>基数排序属于分配式排序，是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p>基数排序、计数排序、桶排序三种排序算法都利用了桶的概念，但对桶的使用方法上是有明显差异的：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值。</li></ul><h3 id="2、步骤-9"><a href="#2、步骤-9" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 取数组中的最大数，并取得位数；</li><li><strong>②</strong> 从最低位开始，依次进行一次排序；</li><li><strong>③</strong> 从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li></ul><h3 id="3、动画演示-9"><a href="#3、动画演示-9" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/16%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="16基数排序"></p><h3 id="4、代码实现-9"><a href="#4、代码实现-9" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def radix_sort(li):    max_num = max(li)      # 最大值 9-&gt;1次循环, 99-&gt;2次循环, 888-&gt;3次循环, 10000-&gt;5次循环    it = 0    while 10 ** it &lt;= max_num:        buckets = [[] for _ in range(10)]        for var in li:            # var=987, it=1, 987//10-&gt;98, 98%10-&gt;8; it=2, 987//100-&gt;9, 9%10=9            digit = (var // 10 ** it) % 10   # 依次取一位数            buckets[digit].append(var)        # 分桶完成        li.clear()        for buc in buckets:            li.extend(buc)        it += 1            # 把数重新写回 li    return arr</code></pre><h3 id="5、具体示例-9"><a href="#5、具体示例-9" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def radix_sort(li):    max_num = max(li)      # 最大值 9-&gt;1次循环, 99-&gt;2次循环, 888-&gt;3次循环, 10000-&gt;5次循环    it = 0    while 10 ** it &lt;= max_num:        buckets = [[] for _ in range(10)]        for var in li:            # var=987, it=1, 987//10-&gt;98, 98%10-&gt;8; it=2, 987//100-&gt;9, 9%10=9            digit = (var // 10 ** it) % 10   # 依次取一位数            buckets[digit].append(var)        # 分桶完成        li.clear()        for buc in buckets:            li.extend(buc)        it += 1            # 把数重新写回 li    return arrarr = [3221, 1, 10, 9680, 577, 9420, 7, 5622, 4793, 2030, 3138, 82, 2599, 743, 4127]sorted_arr = radix_sort(arr)print(sorted_arr)</code></pre><pre><code class="python">[1, 7, 10, 82, 577, 743, 2030, 2599, 3138, 3221, 4127, 4793, 5622, 9420, 9680]</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/108987300未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;参考资料：&lt;a href=&quot;https://www.bilibili.com/video/BV1mp4y1D7UP&quot;&gt;https://www.bilibili.com/video/BV1mp4y1D7UP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文动图演示来源：&lt;a hre</summary>
      
    
    
    
    <category term="算法" scheme="https://www.itbob.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="算法" scheme="https://www.itbob.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>COVID-19 肺炎疫情数据实时监控（python 爬虫 + pyecharts 数据可视化 + wordcloud 词云图）</title>
    <link href="https://www.itbob.cn/article/035/"/>
    <id>https://www.itbob.cn/article/035/</id>
    <published>2020-07-06T04:49:35.000Z</published>
    <updated>2022-05-22T12:46:00.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/107140534未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】前言"><a href="#【1x00】前言" class="headerlink" title="【1x00】前言"></a><font color=#FF0000>【1x00】前言</font></h2><p>本来两三个月之前就想搞个疫情数据实时数据展示的，由于各种不可抗拒因素一而再再而三的鸽了，最近终于抽空写了一个，数据是用 Python 爬取的<a href="https://voice.baidu.com/act/newpneumonia/newpneumonia/">百度疫情实时大数据报告</a>，请求库用的 requests，解析用的 Xpath 语法，词云用的 wordcloud 库，数据可视化用 pyecharts 绘制的地图和折线图，数据储存在 Excel 表格里面，使用 openpyxl 对表格进行处理。</p><p>本程序实现了累计确诊地图展示和每日数据变化折线图展示，其他更多数据的获取和展示均可在程序中进行拓展，可以将程序部署在服务器上，设置定时运行，即可实时展示数据，pyecharts 绘图模块也可以整合到 Web 框架（Django、Flask等）中使用。</p><p>在获取数据时有<font color=#FF0000><strong>全球</strong></font>和<font color=#FF0000><strong>境外</strong></font>两个概念，全球包含中国，境外不包含中国，后期绘制的四个图：中国累计确诊地图、全球累计确诊地图（包含中国）、中国每日数据折线图、境外每日数据折线图（不包含中国）。</p><p><font color=#FF0000><strong>注意项：直接向该网页发送请求获取的响应中，没有每个国家的每日数据，该数据获取的地址是：<a href="https://voice.baidu.com/newpneumonia/get?target=trend&isCaseIn=1&stage=publish">https://voice.baidu.com/newpneumonia/get?target=trend&amp;isCaseIn=1&amp;stage=publish</a></strong></font></p><ul><li><strong>预览地址</strong>：<del><a href="http://cov.itrhx.com/">http://cov.itrhx.com/</a></del>（已失效）</li><li><strong>数据来源</strong>：<a href="https://voice.baidu.com/act/newpneumonia/newpneumonia/">https://voice.baidu.com/act/newpneumonia/newpneumonia/</a></li><li><strong>pyecharts 文档</strong>：<a href="https://pyecharts.org/">https://pyecharts.org/</a></li><li><strong>openpyxl 文档</strong>：<a href="https://openpyxl.readthedocs.io/">https://openpyxl.readthedocs.io/</a></li><li><strong>wordcloud 文档</strong>：<a href="http://amueller.github.io/word_cloud/">http://amueller.github.io/word_cloud/</a></li></ul><h2 id="【2x00】思维导图"><a href="#【2x00】思维导图" class="headerlink" title="【2x00】思维导图"></a><font color=#FF0000>【2x00】思维导图</font></h2><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/01.png" alt="01"></p><h2 id="【3x00】数据结构分析"><a href="#【3x00】数据结构分析" class="headerlink" title="【3x00】数据结构分析"></a><font color=#FF0000>【3x00】数据结构分析</font></h2><p>通过查看百度的疫情数据页面，可以看到很多整齐的数据，猜测就是疫情相关的数据，保存该页面，对其进行格式化，很容易可以分析出所有的数据都在 <code>&lt;script type=&quot;application/json&quot; id=&quot;captain-config&quot;&gt;&lt;/script&gt;</code> 里面，其中 title 里面是一些 Unicode 编码，将其转为中文后更容易得到不同的分类数据。</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/02.png" alt="02"></p><p>由于数据繁多，可以将数据主体部分提取出来，删除一些重复项和其他杂项，留下数据大体位置并分析数据结构，便于后期的数据提取，经过处理后的数据大致结构如下：</p><pre><code class="json">&lt;script type=&quot;application/json&quot; id=&quot;captain-config&quot;&gt;    &#123;        &quot;component&quot;: [            &#123;                &quot;mapLastUpdatedTime&quot;: &quot;2020.07.05 16:13&quot;,        // 国内疫情数据最后更新时间                &quot;caseList&quot;: [                                    // caseList 列表，每一个元素是一个字典                    &#123;                        &quot;confirmed&quot;: &quot;1&quot;,                        // 每个字典包含中国每个省的每一项疫情数据                        &quot;died&quot;: &quot;0&quot;,                        &quot;crued&quot;: &quot;1&quot;,                        &quot;relativeTime&quot;: &quot;1593792000&quot;,                        &quot;confirmedRelative&quot;: &quot;0&quot;,                        &quot;diedRelative&quot;: &quot;0&quot;,                        &quot;curedRelative&quot;: &quot;0&quot;,                        &quot;curConfirm&quot;: &quot;0&quot;,                        &quot;curConfirmRelative&quot;: &quot;0&quot;,                        &quot;icuDisable&quot;: &quot;1&quot;,                        &quot;area&quot;: &quot;西藏&quot;,                        &quot;subList&quot;: [                            // subList 列表，每一个元素是一个字典                            &#123;                                &quot;city&quot;: &quot;拉萨&quot;,                 // 每个字典包含该省份对应的每个城市疫情数据                                &quot;confirmed&quot;: &quot;1&quot;,                                &quot;died&quot;: &quot;0&quot;,                                &quot;crued&quot;: &quot;1&quot;,                                &quot;confirmedRelative&quot;: &quot;0&quot;,                                &quot;curConfirm&quot;: &quot;0&quot;,                                &quot;cityCode&quot;: &quot;100&quot;                            &#125;                        ]                    &#125;                ],                &quot;caseOutsideList&quot;: [                           // caseOutsideList 列表，每一个元素是一个字典                    &#123;                        &quot;confirmed&quot;: &quot;241419&quot;,                 // 每个字典包含各国的每一项疫情数据                        &quot;died&quot;: &quot;34854&quot;,                        &quot;crued&quot;: &quot;191944&quot;,                        &quot;relativeTime&quot;: &quot;1593792000&quot;,                        &quot;confirmedRelative&quot;: &quot;223&quot;,                        &quot;curConfirm&quot;: &quot;14621&quot;,                        &quot;icuDisable&quot;: &quot;1&quot;,                        &quot;area&quot;: &quot;意大利&quot;,                        &quot;subList&quot;: [                          // subList 列表，每一个元素是一个字典                            &#123;                                &quot;city&quot;: &quot;伦巴第&quot;,              // 每个字典包含每个国家对应的每个城市疫情数据                                &quot;confirmed&quot;: &quot;94318&quot;,                                &quot;died&quot;: &quot;16691&quot;,                                &quot;crued&quot;: &quot;68201&quot;,                                &quot;curConfirm&quot;: &quot;9426&quot;                            &#125;                        ]                    &#125;                ],                &quot;summaryDataIn&quot;: &#123;                           // summaryDataIn 国内总的疫情数据                    &quot;confirmed&quot;: &quot;85307&quot;,                    &quot;died&quot;: &quot;4648&quot;,                    &quot;cured&quot;: &quot;80144&quot;,                    &quot;asymptomatic&quot;: &quot;99&quot;,                    &quot;asymptomaticRelative&quot;: &quot;7&quot;,                    &quot;unconfirmed&quot;: &quot;7&quot;,                    &quot;relativeTime&quot;: &quot;1593792000&quot;,                    &quot;confirmedRelative&quot;: &quot;19&quot;,                    &quot;unconfirmedRelative&quot;: &quot;1&quot;,                    &quot;curedRelative&quot;: &quot;27&quot;,                    &quot;diedRelative&quot;: &quot;0&quot;,                    &quot;icu&quot;: &quot;6&quot;,                    &quot;icuRelative&quot;: &quot;0&quot;,                    &quot;overseasInput&quot;: &quot;1931&quot;,                    &quot;unOverseasInputCumulative&quot;: &quot;83375&quot;,                    &quot;overseasInputRelative&quot;: &quot;6&quot;,                    &quot;unOverseasInputNewAdd&quot;: &quot;13&quot;,                    &quot;curConfirm&quot;: &quot;515&quot;,                    &quot;curConfirmRelative&quot;: &quot;-8&quot;,                    &quot;icuDisable&quot;: &quot;1&quot;                &#125;,                &quot;summaryDataOut&quot;: &#123;                           // summaryDataOut 国外总的疫情数据                    &quot;confirmed&quot;: &quot;11302569&quot;,                    &quot;died&quot;: &quot;528977&quot;,                    &quot;curConfirm&quot;: &quot;4410601&quot;,                    &quot;cured&quot;: &quot;6362991&quot;,                    &quot;confirmedRelative&quot;: &quot;206165&quot;,                    &quot;curedRelative&quot;: &quot;190018&quot;,                    &quot;diedRelative&quot;: &quot;4876&quot;,                    &quot;curConfirmRelative&quot;: &quot;11271&quot;,                    &quot;relativeTime&quot;: &quot;1593792000&quot;                &#125;,                &quot;trend&quot;: &#123;                                    // trend 字典，包含国内每日的疫情数据                    &quot;updateDate&quot;: [],                         // 日期                    &quot;list&quot;: [                                 // list 列表，每项数据及其对应的值                        &#123;                            &quot;name&quot;: &quot;确诊&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;疑似&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;治愈&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;死亡&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;新增确诊&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;新增疑似&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;新增治愈&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;新增死亡&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;累计境外输入&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;新增境外输入&quot;,                            &quot;data&quot;: []                        &#125;                    ]                &#125;,                &quot;foreignLastUpdatedTime&quot;: &quot;2020.07.05 16:13&quot;,       // 国外疫情数据最后更新时间                &quot;globalList&quot;: [                                     // globalList 列表，每一个元素是一个字典                    &#123;                        &quot;area&quot;: &quot;亚洲&quot;,                              // 按照不同洲进行分类                        &quot;subList&quot;: [                                // subList 列表，每个洲各个国家的疫情数据                            &#123;                                &quot;died&quot;: &quot;52&quot;,                                &quot;confirmed&quot;: &quot;6159&quot;,                                &quot;crued&quot;: &quot;4809&quot;,                                &quot;curConfirm&quot;: &quot;1298&quot;,                                &quot;confirmedRelative&quot;: &quot;0&quot;,                                &quot;relativeTime&quot;: &quot;1593792000&quot;,                                &quot;country&quot;: &quot;塔吉克斯坦&quot;                            &#125;                        ],                        &quot;died&quot;: &quot;56556&quot;,                            // 每个洲总的疫情数据                        &quot;crued&quot;: &quot;1625562&quot;,                        &quot;confirmed&quot;: &quot;2447873&quot;,                        &quot;curConfirm&quot;: &quot;765755&quot;,                        &quot;confirmedRelative&quot;: &quot;60574&quot;                    &#125;,                    &#123;                        &quot;area&quot;: &quot;其他&quot;,                             // 其他特殊区域疫情数据                        &quot;subList&quot;: [                            &#123;                                &quot;died&quot;: &quot;13&quot;,                                &quot;confirmed&quot;: &quot;712&quot;,                                &quot;crued&quot;: &quot;651&quot;,                                &quot;curConfirm&quot;: &quot;48&quot;,                                &quot;confirmedRelative&quot;: &quot;0&quot;,                                &quot;relativeTime&quot;: &quot;1593792000&quot;,                                &quot;country&quot;: &quot;钻石公主号邮轮&quot;                            &#125;                        ],                        &quot;died&quot;: &quot;13&quot;,                              // 其他特殊区域疫情总的数据                        &quot;crued&quot;: &quot;651&quot;,                        &quot;confirmed&quot;: &quot;712&quot;,                        &quot;curConfirm&quot;: &quot;48&quot;,                        &quot;confirmedRelative&quot;: &quot;0&quot;                    &#125;,                    &#123;                        &quot;area&quot;: &quot;热门&quot;,                            // 热门国家疫情数据                        &quot;subList&quot;: [                            &#123;                                &quot;died&quot;: &quot;5206&quot;,                                &quot;confirmed&quot;: &quot;204610&quot;,                                &quot;crued&quot;: &quot;179492&quot;,                                &quot;curConfirm&quot;: &quot;19912&quot;,                                &quot;confirmedRelative&quot;: &quot;1172&quot;,                                &quot;relativeTime&quot;: &quot;1593792000&quot;,                                &quot;country&quot;: &quot;土耳其&quot;                            &#125;                        ],                        &quot;died&quot;: &quot;528967&quot;,                         // 热门国家疫情总的数据                        &quot;crued&quot;: &quot;6362924&quot;,                        &quot;confirmed&quot;: &quot;11302357&quot;,                        &quot;confirmedRelative&quot;: &quot;216478&quot;,                        &quot;curConfirm&quot;: &quot;4410466&quot;                    &#125;],                &quot;allForeignTrend&quot;: &#123;                            // allForeignTrend 字典，包含国外每日的疫情数据                        &quot;updateDate&quot;: [],                       // 日期                        &quot;list&quot;: [                               // list 列表，每项数据及其对应的值                            &#123;                                &quot;name&quot;: &quot;累计确诊&quot;,                                &quot;data&quot;: []                            &#125;,                            &#123;                                &quot;name&quot;: &quot;治愈&quot;,                                &quot;data&quot;: []                            &#125;,                            &#123;                                &quot;name&quot;: &quot;死亡&quot;,                                &quot;data&quot;: []                            &#125;,                            &#123;                                &quot;name&quot;: &quot;现有确诊&quot;,                                &quot;data&quot;: []                            &#125;,                            &#123;                                &quot;name&quot;: &quot;新增确诊&quot;,                                &quot;data&quot;: []                            &#125;                        ]                    &#125;,                &quot;topAddCountry&quot;: [                    // 确诊增量最高的国家                        &#123;                            &quot;name&quot;: &quot;美国&quot;,                            &quot;value&quot;: 53162                        &#125;                    ],                &quot;topOverseasInput&quot;: [                // 境外输入最多的省份                    &#123;                        &quot;name&quot;: &quot;黑龙江&quot;,                        &quot;value&quot;: 386                    &#125;                ]            &#125;        ]    &#125;&lt;/script&gt;</code></pre><h2 id="【4x00】主函数-main"><a href="#【4x00】主函数-main" class="headerlink" title="【4x00】主函数 main()"></a><font color=#FF0000>【4x00】主函数 main()</font></h2><p>分别将数据获取、词云图绘制、地图绘制写入三个文件：<code>data_get()</code>、<code>data_wordcloud()</code>、<code>data_map()</code>，然后使用一个主函数文件 main.py 来调用这三个文件里面的函数。</p><pre><code class="python">import data_getimport data_wordcloudimport data_mapdata_dict = data_get.init()data_get.china_total_data(data_dict)data_get.global_total_data(data_dict)data_get.china_daily_data(data_dict)data_get.foreign_daily_data(data_dict)data_wordcloud.china_wordcloud()data_wordcloud.global_wordcloud()data_map.all_map()</code></pre><h2 id="【5x00】数据获取模块-data-get"><a href="#【5x00】数据获取模块-data-get" class="headerlink" title="【5x00】数据获取模块 data_get"></a><font color=#FF0000>【5x00】数据获取模块 data_get</font></h2><h3 id="【5x01】初始化函数-init"><a href="#【5x01】初始化函数-init" class="headerlink" title="【5x01】初始化函数 init()"></a><font color="#4876FF">【5x01】初始化函数 init()</font></h3><p>使用 xpath 语法 <code>//script[@id=&quot;captain-config&quot;]/text()</code> 提取里面的值，利用 <code>json.loads</code> 方法将其转换为字典对象，以便后续的其他函数调用。</p><pre><code class="python">def init():    headers = &#123;        &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.13 Safari/537.36&#39;    &#125;    url = &#39;https://voice.baidu.com/act/newpneumonia/newpneumonia/&#39;    response = requests.get(url=url, headers=headers)    tree = etree.HTML(response.text)    dict1 = tree.xpath(&#39;//script[@id=&quot;captain-config&quot;]/text()&#39;)    print(type(dict1[0]))    dict2 = json.loads(dict1[0])    return dict2</code></pre><h3 id="【5x02】中国总数据-china-total-data"><a href="#【5x02】中国总数据-china-total-data" class="headerlink" title="【5x02】中国总数据 china_total_data()"></a><font color="#4876FF">【5x02】中国总数据 china_total_data()</font></h3><pre><code class="python">def china_total_data(data):    &quot;&quot;&quot;    1、中国省/直辖市/自治区/行政区疫情数据    省/直辖市/自治区/行政区：area    现有确诊：    curConfirm    累计确诊：    confirmed    累计治愈：    crued    累计死亡：    died    现有确诊增量： curConfirmRelative    累计确诊增量： confirmedRelative    累计治愈增量： curedRelative    累计死亡增量： diedRelative    &quot;&quot;&quot;    wb = openpyxl.Workbook()            # 创建工作簿    ws_china = wb.active                # 获取工作表    ws_china.title = &quot;中国省份疫情数据&quot;   # 命名工作表    ws_china.append([&#39;省/直辖市/自治区/行政区&#39;, &#39;现有确诊&#39;, &#39;累计确诊&#39;, &#39;累计治愈&#39;,                     &#39;累计死亡&#39;, &#39;现有确诊增量&#39;, &#39;累计确诊增量&#39;,                     &#39;累计治愈增量&#39;, &#39;累计死亡增量&#39;])    china = data[&#39;component&#39;][0][&#39;caseList&#39;]    for province in china:        ws_china.append([province[&#39;area&#39;],                        province[&#39;curConfirm&#39;],                        province[&#39;confirmed&#39;],                        province[&#39;crued&#39;],                        province[&#39;died&#39;],                        province[&#39;curConfirmRelative&#39;],                        province[&#39;confirmedRelative&#39;],                        province[&#39;curedRelative&#39;],                        province[&#39;diedRelative&#39;]])    &quot;&quot;&quot;    2、中国城市疫情数据    城市：city    现有确诊：curConfirm    累计确诊：confirmed    累计治愈：crued    累计死亡：died    累计确诊增量：confirmedRelative    &quot;&quot;&quot;    ws_city = wb.create_sheet(&#39;中国城市疫情数据&#39;)    ws_city.append([&#39;城市&#39;, &#39;现有确诊&#39;, &#39;累计确诊&#39;,                    &#39;累计治愈&#39;, &#39;累计死亡&#39;, &#39;累计确诊增量&#39;])    for province in china:        for city in province[&#39;subList&#39;]:            # 某些城市没有 curConfirm 数据，则将其设置为 0，crued 和 died 为空时，替换成 0            if &#39;curConfirm&#39; not in city:                city[&#39;curConfirm&#39;] = &#39;0&#39;            if city[&#39;crued&#39;] == &#39;&#39;:                city[&#39;crued&#39;] = &#39;0&#39;            if city[&#39;died&#39;] == &#39;&#39;:                city[&#39;died&#39;] = &#39;0&#39;            ws_city.append([city[&#39;city&#39;], &#39;0&#39;, city[&#39;confirmed&#39;],                           city[&#39;crued&#39;], city[&#39;died&#39;], city[&#39;confirmedRelative&#39;]])    &quot;&quot;&quot;    3、中国疫情数据更新时间：mapLastUpdatedTime    &quot;&quot;&quot;    time_domestic = data[&#39;component&#39;][0][&#39;mapLastUpdatedTime&#39;]    ws_time = wb.create_sheet(&#39;中国疫情数据更新时间&#39;)    ws_time.column_dimensions[&#39;A&#39;].width = 22  # 调整列宽    ws_time.append([&#39;中国疫情数据更新时间&#39;])    ws_time.append([time_domestic])    wb.save(&#39;COVID-19-China.xlsx&#39;)    print(&#39;中国疫情数据已保存至 COVID-19-China.xlsx！&#39;)</code></pre><h3 id="【5x03】全球总数据-global-total-data"><a href="#【5x03】全球总数据-global-total-data" class="headerlink" title="【5x03】全球总数据 global_total_data()"></a><font color="#4876FF">【5x03】全球总数据 global_total_data()</font></h3><p>全球总数据在提取完成后，进行地图绘制时发现并没有中国的数据，因此在写入全球数据时注意要单独将中国的数据插入 Excel 中。</p><pre><code class="python">def global_total_data(data):    &quot;&quot;&quot;    1、全球各国疫情数据    国家：country    现有确诊：curConfirm    累计确诊：confirmed    累计治愈：crued    累计死亡：died    累计确诊增量：confirmedRelative    &quot;&quot;&quot;    wb = openpyxl.Workbook()    ws_global = wb.active    ws_global.title = &quot;全球各国疫情数据&quot;    # 按照国家保存数据    countries = data[&#39;component&#39;][0][&#39;caseOutsideList&#39;]    ws_global.append([&#39;国家&#39;, &#39;现有确诊&#39;, &#39;累计确诊&#39;, &#39;累计治愈&#39;, &#39;累计死亡&#39;, &#39;累计确诊增量&#39;])    for country in countries:        ws_global.append([country[&#39;area&#39;],                          country[&#39;curConfirm&#39;],                          country[&#39;confirmed&#39;],                          country[&#39;crued&#39;],                          country[&#39;died&#39;],                          country[&#39;confirmedRelative&#39;]])    # 按照洲保存数据    continent = data[&#39;component&#39;][0][&#39;globalList&#39;]    for area in continent:        ws_foreign = wb.create_sheet(area[&#39;area&#39;] + &#39;疫情数据&#39;)        ws_foreign.append([&#39;国家&#39;, &#39;现有确诊&#39;, &#39;累计确诊&#39;, &#39;累计治愈&#39;, &#39;累计死亡&#39;, &#39;累计确诊增量&#39;])        for country in area[&#39;subList&#39;]:            ws_foreign.append([country[&#39;country&#39;],                               country[&#39;curConfirm&#39;],                               country[&#39;confirmed&#39;],                               country[&#39;crued&#39;],                               country[&#39;died&#39;],                               country[&#39;confirmedRelative&#39;]])    # 在“全球各国疫情数据”和“亚洲疫情数据”两张表中写入中国疫情数据    ws1, ws2 = wb[&#39;全球各国疫情数据&#39;], wb[&#39;亚洲疫情数据&#39;]    original_data = data[&#39;component&#39;][0][&#39;summaryDataIn&#39;]    add_china_data = [&#39;中国&#39;,                      original_data[&#39;curConfirm&#39;],                      original_data[&#39;confirmed&#39;],                      original_data[&#39;cured&#39;],                      original_data[&#39;died&#39;],                      original_data[&#39;confirmedRelative&#39;]]    ws1.append(add_china_data)    ws2.append(add_china_data)    &quot;&quot;&quot;    2、全球疫情数据更新时间：foreignLastUpdatedTime    &quot;&quot;&quot;    time_foreign = data[&#39;component&#39;][0][&#39;foreignLastUpdatedTime&#39;]    ws_time = wb.create_sheet(&#39;全球疫情数据更新时间&#39;)    ws_time.column_dimensions[&#39;A&#39;].width = 22  # 调整列宽    ws_time.append([&#39;全球疫情数据更新时间&#39;])    ws_time.append([time_foreign])    wb.save(&#39;COVID-19-Global.xlsx&#39;)    print(&#39;全球疫情数据已保存至 COVID-19-Global.xlsx！&#39;)</code></pre><h3 id="【5x04】中国每日数据-china-daily-data"><a href="#【5x04】中国每日数据-china-daily-data" class="headerlink" title="【5x04】中国每日数据 china_daily_data()"></a><font color="#4876FF">【5x04】中国每日数据 china_daily_data()</font></h3><pre><code class="python">def china_daily_data(data):    &quot;&quot;&quot;    i_dict = data[&#39;component&#39;][0][&#39;trend&#39;]    i_dict[&#39;updateDate&#39;]：日期    i_dict[&#39;list&#39;][0]：确诊    i_dict[&#39;list&#39;][1]：疑似    i_dict[&#39;list&#39;][2]：治愈    i_dict[&#39;list&#39;][3]：死亡    i_dict[&#39;list&#39;][4]：新增确诊    i_dict[&#39;list&#39;][5]：新增疑似    i_dict[&#39;list&#39;][6]：新增治愈    i_dict[&#39;list&#39;][7]：新增死亡    i_dict[&#39;list&#39;][8]：累计境外输入    i_dict[&#39;list&#39;][9]：新增境外输入    &quot;&quot;&quot;    ccd_dict = data[&#39;component&#39;][0][&#39;trend&#39;]    update_date = ccd_dict[&#39;updateDate&#39;]              # 日期    china_confirmed = ccd_dict[&#39;list&#39;][0][&#39;data&#39;]     # 每日累计确诊数据    china_crued = ccd_dict[&#39;list&#39;][2][&#39;data&#39;]         # 每日累计治愈数据    china_died = ccd_dict[&#39;list&#39;][3][&#39;data&#39;]          # 每日累计死亡数据    wb = openpyxl.load_workbook(&#39;COVID-19-China.xlsx&#39;)    # 写入每日累计确诊数据    ws_china_confirmed = wb.create_sheet(&#39;中国每日累计确诊数据&#39;)    ws_china_confirmed.append([&#39;日期&#39;, &#39;数据&#39;])    for data in zip(update_date, china_confirmed):        ws_china_confirmed.append(data)    # 写入每日累计治愈数据    ws_china_crued = wb.create_sheet(&#39;中国每日累计治愈数据&#39;)    ws_china_crued.append([&#39;日期&#39;, &#39;数据&#39;])    for data in zip(update_date, china_crued):        ws_china_crued.append(data)    # 写入每日累计死亡数据    ws_china_died = wb.create_sheet(&#39;中国每日累计死亡数据&#39;)    ws_china_died.append([&#39;日期&#39;, &#39;数据&#39;])    for data in zip(update_date, china_died):        ws_china_died.append(data)    wb.save(&#39;COVID-19-China.xlsx&#39;)    print(&#39;中国每日累计确诊/治愈/死亡数据已保存至 COVID-19-China.xlsx！&#39;)</code></pre><h3 id="【5x05】境外每日数据-foreign-daily-data"><a href="#【5x05】境外每日数据-foreign-daily-data" class="headerlink" title="【5x05】境外每日数据 foreign_daily_data()"></a><font color="#4876FF">【5x05】境外每日数据 foreign_daily_data()</font></h3><pre><code class="python">def foreign_daily_data(data):    &quot;&quot;&quot;    te_dict = data[&#39;component&#39;][0][&#39;allForeignTrend&#39;]    te_dict[&#39;updateDate&#39;]：日期    te_dict[&#39;list&#39;][0]：累计确诊    te_dict[&#39;list&#39;][1]：治愈    te_dict[&#39;list&#39;][2]：死亡    te_dict[&#39;list&#39;][3]：现有确诊    te_dict[&#39;list&#39;][4]：新增确诊    &quot;&quot;&quot;    te_dict = data[&#39;component&#39;][0][&#39;allForeignTrend&#39;]    update_date = te_dict[&#39;updateDate&#39;]                # 日期    foreign_confirmed = te_dict[&#39;list&#39;][0][&#39;data&#39;]     # 每日累计确诊数据    foreign_crued = te_dict[&#39;list&#39;][1][&#39;data&#39;]         # 每日累计治愈数据    foreign_died = te_dict[&#39;list&#39;][2][&#39;data&#39;]          # 每日累计死亡数据    wb = openpyxl.load_workbook(&#39;COVID-19-Global.xlsx&#39;)    # 写入每日累计确诊数据    ws_foreign_confirmed = wb.create_sheet(&#39;境外每日累计确诊数据&#39;)    ws_foreign_confirmed.append([&#39;日期&#39;, &#39;数据&#39;])    for data in zip(update_date, foreign_confirmed):        ws_foreign_confirmed.append(data)    # 写入累计治愈数据    ws_foreign_crued = wb.create_sheet(&#39;境外每日累计治愈数据&#39;)    ws_foreign_crued.append([&#39;日期&#39;, &#39;数据&#39;])    for data in zip(update_date, foreign_crued):        ws_foreign_crued.append(data)    # 写入累计死亡数据    ws_foreign_died = wb.create_sheet(&#39;境外每日累计死亡数据&#39;)    ws_foreign_died.append([&#39;日期&#39;, &#39;数据&#39;])    for data in zip(update_date, foreign_died):        ws_foreign_died.append(data)    wb.save(&#39;COVID-19-Global.xlsx&#39;)    print(&#39;境外每日累计确诊/治愈/死亡数据已保存至 COVID-19-Global.xlsx！&#39;)</code></pre><h2 id="【6x00】词云图绘制模块-data-wordcloud"><a href="#【6x00】词云图绘制模块-data-wordcloud" class="headerlink" title="【6x00】词云图绘制模块 data_wordcloud"></a><font color=#FF0000>【6x00】词云图绘制模块 data_wordcloud</font></h2><h3 id="【6x01】中国累计确诊词云图-foreign-daily-data"><a href="#【6x01】中国累计确诊词云图-foreign-daily-data" class="headerlink" title="【6x01】中国累计确诊词云图 foreign_daily_data()"></a><font color="#4876FF">【6x01】中国累计确诊词云图 foreign_daily_data()</font></h3><pre><code class="python">def china_wordcloud():    wb = openpyxl.load_workbook(&#39;COVID-19-China.xlsx&#39;)  # 获取已有的xlsx文件    ws_china = wb[&#39;中国省份疫情数据&#39;]                     # 获取中国省份疫情数据表    ws_china.delete_rows(1)                             # 删除第一行    china_dict = &#123;&#125;                                     # 将省份及其累计确诊按照键值对形式储存在字典中    for data in ws_china.values:        china_dict[data[0]] = int(data[2])    word_cloud = wordcloud.WordCloud(font_path=&#39;C:/Windows/Fonts/simsun.ttc&#39;,                                     background_color=&#39;#CDC9C9&#39;,                                     min_font_size=15,                                     width=900, height=500)    word_cloud.generate_from_frequencies(china_dict)    word_cloud.to_file(&#39;WordCloud-China.png&#39;)    print(&#39;中国省份疫情词云图绘制完毕！&#39;)</code></pre><h3 id="【6x02】全球累计确诊词云图-foreign-daily-data"><a href="#【6x02】全球累计确诊词云图-foreign-daily-data" class="headerlink" title="【6x02】全球累计确诊词云图 foreign_daily_data()"></a><font color="#4876FF">【6x02】全球累计确诊词云图 foreign_daily_data()</font></h3><pre><code class="python">def global_wordcloud():    wb = openpyxl.load_workbook(&#39;COVID-19-Global.xlsx&#39;)    ws_global = wb[&#39;全球各国疫情数据&#39;]    ws_global.delete_rows(1)    global_dict = &#123;&#125;    for data in ws_global.values:        global_dict[data[0]] = int(data[2])    word_cloud = wordcloud.WordCloud(font_path=&#39;C:/Windows/Fonts/simsun.ttc&#39;,                                     background_color=&#39;#CDC9C9&#39;,                                     width=900, height=500)    word_cloud.generate_from_frequencies(global_dict)    word_cloud.to_file(&#39;WordCloud-Global.png&#39;)    print(&#39;全球各国疫情词云图绘制完毕！&#39;)</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/107140534未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【7x00】地图绘制模块-data-map"><a href="#【7x00】地图绘制模块-data-map" class="headerlink" title="【7x00】地图绘制模块 data_map"></a><font color=#FF0000>【7x00】地图绘制模块 data_map</font></h2><h3 id="【7x01】中国累计确诊地图-china-total-map"><a href="#【7x01】中国累计确诊地图-china-total-map" class="headerlink" title="【7x01】中国累计确诊地图 china_total_map()"></a><font color="#4876FF">【7x01】中国累计确诊地图 china_total_map()</font></h3><pre><code class="python">def china_total_map():    wb = openpyxl.load_workbook(&#39;COVID-19-China.xlsx&#39;)  # 获取已有的xlsx文件    ws_time = wb[&#39;中国疫情数据更新时间&#39;]                   # 获取文件中中国疫情数据更新时间表    ws_data = wb[&#39;中国省份疫情数据&#39;]                      # 获取文件中中国省份疫情数据表    ws_data.delete_rows(1)                              # 删除第一行    province = []                                       # 省份    curconfirm = []                                     # 累计确诊    for data in ws_data.values:        province.append(data[0])        curconfirm.append(data[2])    time_china = ws_time[&#39;A2&#39;].value                    # 更新时间    # 设置分级颜色    pieces = [        &#123;&#39;max&#39;: 0, &#39;min&#39;: 0, &#39;label&#39;: &#39;0&#39;, &#39;color&#39;: &#39;#FFFFFF&#39;&#125;,        &#123;&#39;max&#39;: 9, &#39;min&#39;: 1, &#39;label&#39;: &#39;1-9&#39;, &#39;color&#39;: &#39;#FFE5DB&#39;&#125;,        &#123;&#39;max&#39;: 99, &#39;min&#39;: 10, &#39;label&#39;: &#39;10-99&#39;, &#39;color&#39;: &#39;#FF9985&#39;&#125;,        &#123;&#39;max&#39;: 999, &#39;min&#39;: 100, &#39;label&#39;: &#39;100-999&#39;, &#39;color&#39;: &#39;#F57567&#39;&#125;,        &#123;&#39;max&#39;: 9999, &#39;min&#39;: 1000, &#39;label&#39;: &#39;1000-9999&#39;, &#39;color&#39;: &#39;#E64546&#39;&#125;,        &#123;&#39;max&#39;: 99999, &#39;min&#39;: 10000, &#39;label&#39;: &#39;≧10000&#39;, &#39;color&#39;: &#39;#B80909&#39;&#125;    ]    # 绘制地图    ct_map = (        Map()        .add(series_name=&#39;累计确诊人数&#39;, data_pair=[list(z) for z in zip(province, curconfirm)], maptype=&quot;china&quot;)        .set_global_opts(            title_opts=opts.TitleOpts(title=&quot;中国疫情数据（累计确诊）&quot;,                                      subtitle=&#39;数据更新至：&#39; + time_china + &#39;\n\n来源：百度疫情实时大数据报告&#39;),            visualmap_opts=opts.VisualMapOpts(max_=300, is_piecewise=True, pieces=pieces)        )    )    return ct_map</code></pre><h3 id="【7x02】全球累计确诊地图-global-total-map"><a href="#【7x02】全球累计确诊地图-global-total-map" class="headerlink" title="【7x02】全球累计确诊地图 global_total_map()"></a><font color="#4876FF">【7x02】全球累计确诊地图 global_total_map()</font></h3><pre><code class="python">def global_total_map():    wb = openpyxl.load_workbook(&#39;COVID-19-Global.xlsx&#39;)    ws_time = wb[&#39;全球疫情数据更新时间&#39;]    ws_data = wb[&#39;全球各国疫情数据&#39;]    ws_data.delete_rows(1)    country = []                        # 国家    curconfirm = []                     # 累计确诊    for data in ws_data.values:        country.append(data[0])        curconfirm.append(data[2])    time_global = ws_time[&#39;A2&#39;].value   # 更新时间    # 国家名称中英文映射表    name_map = &#123;          &quot;Somalia&quot;: &quot;索马里&quot;,          &quot;Liechtenstein&quot;: &quot;列支敦士登&quot;,          &quot;Morocco&quot;: &quot;摩洛哥&quot;,          &quot;W. Sahara&quot;: &quot;西撒哈拉&quot;,          &quot;Serbia&quot;: &quot;塞尔维亚&quot;,          &quot;Afghanistan&quot;: &quot;阿富汗&quot;,          &quot;Angola&quot;: &quot;安哥拉&quot;,          &quot;Albania&quot;: &quot;阿尔巴尼亚&quot;,          &quot;Andorra&quot;: &quot;安道尔共和国&quot;,          &quot;United Arab Emirates&quot;: &quot;阿拉伯联合酋长国&quot;,          &quot;Argentina&quot;: &quot;阿根廷&quot;,          &quot;Armenia&quot;: &quot;亚美尼亚&quot;,          &quot;Australia&quot;: &quot;澳大利亚&quot;,          &quot;Austria&quot;: &quot;奥地利&quot;,          &quot;Azerbaijan&quot;: &quot;阿塞拜疆&quot;,          &quot;Burundi&quot;: &quot;布隆迪&quot;,          &quot;Belgium&quot;: &quot;比利时&quot;,          &quot;Benin&quot;: &quot;贝宁&quot;,          &quot;Burkina Faso&quot;: &quot;布基纳法索&quot;,          &quot;Bangladesh&quot;: &quot;孟加拉国&quot;,          &quot;Bulgaria&quot;: &quot;保加利亚&quot;,          &quot;Bahrain&quot;: &quot;巴林&quot;,          &quot;Bahamas&quot;: &quot;巴哈马&quot;,          &quot;Bosnia and Herz.&quot;: &quot;波斯尼亚和黑塞哥维那&quot;,          &quot;Belarus&quot;: &quot;白俄罗斯&quot;,          &quot;Belize&quot;: &quot;伯利兹&quot;,          &quot;Bermuda&quot;: &quot;百慕大&quot;,          &quot;Bolivia&quot;: &quot;玻利维亚&quot;,          &quot;Brazil&quot;: &quot;巴西&quot;,          &quot;Barbados&quot;: &quot;巴巴多斯&quot;,          &quot;Brunei&quot;: &quot;文莱&quot;,          &quot;Bhutan&quot;: &quot;不丹&quot;,          &quot;Botswana&quot;: &quot;博茨瓦纳&quot;,          &quot;Central African Rep.&quot;: &quot;中非共和国&quot;,          &quot;Canada&quot;: &quot;加拿大&quot;,          &quot;Switzerland&quot;: &quot;瑞士&quot;,          &quot;Chile&quot;: &quot;智利&quot;,          &quot;China&quot;: &quot;中国&quot;,          &quot;Côte d&#39;Ivoire&quot;: &quot;科特迪瓦&quot;,          &quot;Cameroon&quot;: &quot;喀麦隆&quot;,          &quot;Dem. Rep. Congo&quot;: &quot;刚果（布）&quot;,          &quot;Congo&quot;: &quot;刚果（金）&quot;,          &quot;Colombia&quot;: &quot;哥伦比亚&quot;,          &quot;Cape Verde&quot;: &quot;佛得角&quot;,          &quot;Costa Rica&quot;: &quot;哥斯达黎加&quot;,          &quot;Cuba&quot;: &quot;古巴&quot;,          &quot;N. Cyprus&quot;: &quot;北塞浦路斯&quot;,          &quot;Cyprus&quot;: &quot;塞浦路斯&quot;,          &quot;Czech Rep.&quot;: &quot;捷克&quot;,          &quot;Germany&quot;: &quot;德国&quot;,          &quot;Djibouti&quot;: &quot;吉布提&quot;,          &quot;Denmark&quot;: &quot;丹麦&quot;,          &quot;Dominican Rep.&quot;: &quot;多米尼加&quot;,          &quot;Algeria&quot;: &quot;阿尔及利亚&quot;,          &quot;Ecuador&quot;: &quot;厄瓜多尔&quot;,          &quot;Egypt&quot;: &quot;埃及&quot;,          &quot;Eritrea&quot;: &quot;厄立特里亚&quot;,          &quot;Spain&quot;: &quot;西班牙&quot;,          &quot;Estonia&quot;: &quot;爱沙尼亚&quot;,          &quot;Ethiopia&quot;: &quot;埃塞俄比亚&quot;,          &quot;Finland&quot;: &quot;芬兰&quot;,          &quot;Fiji&quot;: &quot;斐济&quot;,          &quot;France&quot;: &quot;法国&quot;,          &quot;Gabon&quot;: &quot;加蓬&quot;,          &quot;United Kingdom&quot;: &quot;英国&quot;,          &quot;Georgia&quot;: &quot;格鲁吉亚&quot;,          &quot;Ghana&quot;: &quot;加纳&quot;,          &quot;Guinea&quot;: &quot;几内亚&quot;,          &quot;Gambia&quot;: &quot;冈比亚&quot;,          &quot;Guinea-Bissau&quot;: &quot;几内亚比绍&quot;,          &quot;Eq. Guinea&quot;: &quot;赤道几内亚&quot;,          &quot;Greece&quot;: &quot;希腊&quot;,          &quot;Grenada&quot;: &quot;格林纳达&quot;,          &quot;Greenland&quot;: &quot;格陵兰岛&quot;,          &quot;Guatemala&quot;: &quot;危地马拉&quot;,          &quot;Guam&quot;: &quot;关岛&quot;,          &quot;Guyana&quot;: &quot;圭亚那合作共和国&quot;,          &quot;Honduras&quot;: &quot;洪都拉斯&quot;,          &quot;Croatia&quot;: &quot;克罗地亚&quot;,          &quot;Haiti&quot;: &quot;海地&quot;,          &quot;Hungary&quot;: &quot;匈牙利&quot;,          &quot;Indonesia&quot;: &quot;印度尼西亚&quot;,          &quot;India&quot;: &quot;印度&quot;,          &quot;Br. Indian Ocean Ter.&quot;: &quot;英属印度洋领土&quot;,          &quot;Ireland&quot;: &quot;爱尔兰&quot;,          &quot;Iran&quot;: &quot;伊朗&quot;,          &quot;Iraq&quot;: &quot;伊拉克&quot;,          &quot;Iceland&quot;: &quot;冰岛&quot;,          &quot;Israel&quot;: &quot;以色列&quot;,          &quot;Italy&quot;: &quot;意大利&quot;,          &quot;Jamaica&quot;: &quot;牙买加&quot;,          &quot;Jordan&quot;: &quot;约旦&quot;,          &quot;Japan&quot;: &quot;日本&quot;,          &quot;Siachen Glacier&quot;: &quot;锡亚琴冰川&quot;,          &quot;Kazakhstan&quot;: &quot;哈萨克斯坦&quot;,          &quot;Kenya&quot;: &quot;肯尼亚&quot;,          &quot;Kyrgyzstan&quot;: &quot;吉尔吉斯斯坦&quot;,          &quot;Cambodia&quot;: &quot;柬埔寨&quot;,          &quot;Korea&quot;: &quot;韩国&quot;,          &quot;Kuwait&quot;: &quot;科威特&quot;,          &quot;Lao PDR&quot;: &quot;老挝&quot;,          &quot;Lebanon&quot;: &quot;黎巴嫩&quot;,          &quot;Liberia&quot;: &quot;利比里亚&quot;,          &quot;Libya&quot;: &quot;利比亚&quot;,          &quot;Sri Lanka&quot;: &quot;斯里兰卡&quot;,          &quot;Lesotho&quot;: &quot;莱索托&quot;,          &quot;Lithuania&quot;: &quot;立陶宛&quot;,          &quot;Luxembourg&quot;: &quot;卢森堡&quot;,          &quot;Latvia&quot;: &quot;拉脱维亚&quot;,          &quot;Moldova&quot;: &quot;摩尔多瓦&quot;,          &quot;Madagascar&quot;: &quot;马达加斯加&quot;,          &quot;Mexico&quot;: &quot;墨西哥&quot;,          &quot;Macedonia&quot;: &quot;马其顿&quot;,          &quot;Mali&quot;: &quot;马里&quot;,          &quot;Malta&quot;: &quot;马耳他&quot;,          &quot;Myanmar&quot;: &quot;缅甸&quot;,          &quot;Montenegro&quot;: &quot;黑山&quot;,          &quot;Mongolia&quot;: &quot;蒙古国&quot;,          &quot;Mozambique&quot;: &quot;莫桑比克&quot;,          &quot;Mauritania&quot;: &quot;毛里塔尼亚&quot;,          &quot;Mauritius&quot;: &quot;毛里求斯&quot;,          &quot;Malawi&quot;: &quot;马拉维&quot;,          &quot;Malaysia&quot;: &quot;马来西亚&quot;,          &quot;Namibia&quot;: &quot;纳米比亚&quot;,          &quot;New Caledonia&quot;: &quot;新喀里多尼亚&quot;,          &quot;Niger&quot;: &quot;尼日尔&quot;,          &quot;Nigeria&quot;: &quot;尼日利亚&quot;,          &quot;Nicaragua&quot;: &quot;尼加拉瓜&quot;,          &quot;Netherlands&quot;: &quot;荷兰&quot;,          &quot;Norway&quot;: &quot;挪威&quot;,          &quot;Nepal&quot;: &quot;尼泊尔&quot;,          &quot;New Zealand&quot;: &quot;新西兰&quot;,          &quot;Oman&quot;: &quot;阿曼&quot;,          &quot;Pakistan&quot;: &quot;巴基斯坦&quot;,          &quot;Panama&quot;: &quot;巴拿马&quot;,          &quot;Peru&quot;: &quot;秘鲁&quot;,          &quot;Philippines&quot;: &quot;菲律宾&quot;,          &quot;Papua New Guinea&quot;: &quot;巴布亚新几内亚&quot;,          &quot;Poland&quot;: &quot;波兰&quot;,          &quot;Puerto Rico&quot;: &quot;波多黎各&quot;,          &quot;Dem. Rep. Korea&quot;: &quot;朝鲜&quot;,          &quot;Portugal&quot;: &quot;葡萄牙&quot;,          &quot;Paraguay&quot;: &quot;巴拉圭&quot;,          &quot;Palestine&quot;: &quot;巴勒斯坦&quot;,          &quot;Qatar&quot;: &quot;卡塔尔&quot;,          &quot;Romania&quot;: &quot;罗马尼亚&quot;,          &quot;Russia&quot;: &quot;俄罗斯&quot;,          &quot;Rwanda&quot;: &quot;卢旺达&quot;,          &quot;Saudi Arabia&quot;: &quot;沙特阿拉伯&quot;,          &quot;Sudan&quot;: &quot;苏丹&quot;,          &quot;S. Sudan&quot;: &quot;南苏丹&quot;,          &quot;Senegal&quot;: &quot;塞内加尔&quot;,          &quot;Singapore&quot;: &quot;新加坡&quot;,          &quot;Solomon Is.&quot;: &quot;所罗门群岛&quot;,          &quot;Sierra Leone&quot;: &quot;塞拉利昂&quot;,          &quot;El Salvador&quot;: &quot;萨尔瓦多&quot;,          &quot;Suriname&quot;: &quot;苏里南&quot;,          &quot;Slovakia&quot;: &quot;斯洛伐克&quot;,          &quot;Slovenia&quot;: &quot;斯洛文尼亚&quot;,          &quot;Sweden&quot;: &quot;瑞典&quot;,          &quot;Swaziland&quot;: &quot;斯威士兰&quot;,          &quot;Seychelles&quot;: &quot;塞舌尔&quot;,          &quot;Syria&quot;: &quot;叙利亚&quot;,          &quot;Chad&quot;: &quot;乍得&quot;,          &quot;Togo&quot;: &quot;多哥&quot;,          &quot;Thailand&quot;: &quot;泰国&quot;,          &quot;Tajikistan&quot;: &quot;塔吉克斯坦&quot;,          &quot;Turkmenistan&quot;: &quot;土库曼斯坦&quot;,          &quot;Timor-Leste&quot;: &quot;东帝汶&quot;,          &quot;Tonga&quot;: &quot;汤加&quot;,          &quot;Trinidad and Tobago&quot;: &quot;特立尼达和多巴哥&quot;,          &quot;Tunisia&quot;: &quot;突尼斯&quot;,          &quot;Turkey&quot;: &quot;土耳其&quot;,          &quot;Tanzania&quot;: &quot;坦桑尼亚&quot;,          &quot;Uganda&quot;: &quot;乌干达&quot;,          &quot;Ukraine&quot;: &quot;乌克兰&quot;,          &quot;Uruguay&quot;: &quot;乌拉圭&quot;,          &quot;United States&quot;: &quot;美国&quot;,          &quot;Uzbekistan&quot;: &quot;乌兹别克斯坦&quot;,          &quot;Venezuela&quot;: &quot;委内瑞拉&quot;,          &quot;Vietnam&quot;: &quot;越南&quot;,          &quot;Vanuatu&quot;: &quot;瓦努阿图&quot;,          &quot;Yemen&quot;: &quot;也门&quot;,          &quot;South Africa&quot;: &quot;南非&quot;,          &quot;Zambia&quot;: &quot;赞比亚&quot;,          &quot;Zimbabwe&quot;: &quot;津巴布韦&quot;,          &quot;Aland&quot;: &quot;奥兰群岛&quot;,          &quot;American Samoa&quot;: &quot;美属萨摩亚&quot;,          &quot;Fr. S. Antarctic Lands&quot;: &quot;南极洲&quot;,          &quot;Antigua and Barb.&quot;: &quot;安提瓜和巴布达&quot;,          &quot;Comoros&quot;: &quot;科摩罗&quot;,          &quot;Curaçao&quot;: &quot;库拉索岛&quot;,          &quot;Cayman Is.&quot;: &quot;开曼群岛&quot;,          &quot;Dominica&quot;: &quot;多米尼加&quot;,          &quot;Falkland Is.&quot;: &quot;福克兰群岛马尔维纳斯&quot;,          &quot;Faeroe Is.&quot;: &quot;法罗群岛&quot;,          &quot;Micronesia&quot;: &quot;密克罗尼西亚&quot;,          &quot;Heard I. and McDonald Is.&quot;: &quot;赫德岛和麦克唐纳群岛&quot;,          &quot;Isle of Man&quot;: &quot;曼岛&quot;,          &quot;Jersey&quot;: &quot;泽西岛&quot;,          &quot;Kiribati&quot;: &quot;基里巴斯&quot;,          &quot;Saint Lucia&quot;: &quot;圣卢西亚&quot;,          &quot;N. Mariana Is.&quot;: &quot;北马里亚纳群岛&quot;,          &quot;Montserrat&quot;: &quot;蒙特塞拉特&quot;,          &quot;Niue&quot;: &quot;纽埃&quot;,          &quot;Palau&quot;: &quot;帕劳&quot;,          &quot;Fr. Polynesia&quot;: &quot;法属波利尼西亚&quot;,          &quot;S. Geo. and S. Sandw. Is.&quot;: &quot;南乔治亚岛和南桑威奇群岛&quot;,          &quot;Saint Helena&quot;: &quot;圣赫勒拿&quot;,          &quot;St. Pierre and Miquelon&quot;: &quot;圣皮埃尔和密克隆群岛&quot;,          &quot;São Tomé and Principe&quot;: &quot;圣多美和普林西比&quot;,          &quot;Turks and Caicos Is.&quot;: &quot;特克斯和凯科斯群岛&quot;,          &quot;St. Vin. and Gren.&quot;: &quot;圣文森特和格林纳丁斯&quot;,          &quot;U.S. Virgin Is.&quot;: &quot;美属维尔京群岛&quot;,          &quot;Samoa&quot;: &quot;萨摩亚&quot;        &#125;    pieces = [        &#123;&#39;max&#39;: 0, &#39;min&#39;: 0, &#39;label&#39;: &#39;0&#39;, &#39;color&#39;: &#39;#FFFFFF&#39;&#125;,        &#123;&#39;max&#39;: 49, &#39;min&#39;: 1, &#39;label&#39;: &#39;1-49&#39;, &#39;color&#39;: &#39;#FFE5DB&#39;&#125;,        &#123;&#39;max&#39;: 99, &#39;min&#39;: 50, &#39;label&#39;: &#39;50-99&#39;, &#39;color&#39;: &#39;#FFC4B3&#39;&#125;,        &#123;&#39;max&#39;: 999, &#39;min&#39;: 100, &#39;label&#39;: &#39;100-999&#39;, &#39;color&#39;: &#39;#FF9985&#39;&#125;,        &#123;&#39;max&#39;: 9999, &#39;min&#39;: 1000, &#39;label&#39;: &#39;1000-9999&#39;, &#39;color&#39;: &#39;#F57567&#39;&#125;,        &#123;&#39;max&#39;: 99999, &#39;min&#39;: 10000, &#39;label&#39;: &#39;10000-99999&#39;, &#39;color&#39;: &#39;#E64546&#39;&#125;,        &#123;&#39;max&#39;: 999999, &#39;min&#39;: 100000, &#39;label&#39;: &#39;100000-999999&#39;, &#39;color&#39;: &#39;#B80909&#39;&#125;,        &#123;&#39;max&#39;: 9999999, &#39;min&#39;: 1000000, &#39;label&#39;: &#39;≧1000000&#39;, &#39;color&#39;: &#39;#8A0808&#39;&#125;    ]    gt_map = (        Map()        .add(series_name=&#39;累计确诊人数&#39;, data_pair=[list(z) for z in zip(country, curconfirm)], maptype=&quot;world&quot;, name_map=name_map, is_map_symbol_show=False)        .set_series_opts(label_opts=opts.LabelOpts(is_show=False))        .set_global_opts(            title_opts=opts.TitleOpts(title=&quot;全球疫情数据（累计确诊）&quot;,                                      subtitle=&#39;数据更新至：&#39; + time_global + &#39;\n\n来源：百度疫情实时大数据报告&#39;),            visualmap_opts=opts.VisualMapOpts(max_=300, is_piecewise=True, pieces=pieces),        )    )    return gt_map</code></pre><h3 id="【7x03】中国每日数据折线图-china-daily-map"><a href="#【7x03】中国每日数据折线图-china-daily-map" class="headerlink" title="【7x03】中国每日数据折线图 china_daily_map()"></a><font color="#4876FF">【7x03】中国每日数据折线图 china_daily_map()</font></h3><pre><code class="python">def china_daily_map():    wb = openpyxl.load_workbook(&#39;COVID-19-China.xlsx&#39;)    ws_china_confirmed = wb[&#39;中国每日累计确诊数据&#39;]    ws_china_crued = wb[&#39;中国每日累计治愈数据&#39;]    ws_china_died = wb[&#39;中国每日累计死亡数据&#39;]    ws_china_confirmed.delete_rows(1)    ws_china_crued.delete_rows(1)    ws_china_died.delete_rows(1)    x_date = []               # 日期    y_china_confirmed = []    # 每日累计确诊    y_china_crued = []        # 每日累计治愈    y_china_died = []         # 每日累计死亡    for china_confirmed in ws_china_confirmed.values:        y_china_confirmed.append(china_confirmed[1])    for china_crued in ws_china_crued.values:        x_date.append(china_crued[0])        y_china_crued.append(china_crued[1])    for china_died in ws_china_died.values:        y_china_died.append(china_died[1])    fi_map = (        Line(init_opts=opts.InitOpts(height=&#39;420px&#39;))            .add_xaxis(xaxis_data=x_date)            .add_yaxis(            series_name=&quot;中国累计确诊数据&quot;,            y_axis=y_china_confirmed,            label_opts=opts.LabelOpts(is_show=False),        )            .add_yaxis(            series_name=&quot;中国累计治愈趋势&quot;,            y_axis=y_china_crued,            label_opts=opts.LabelOpts(is_show=False),        )            .add_yaxis(            series_name=&quot;中国累计死亡趋势&quot;,            y_axis=y_china_died,            label_opts=opts.LabelOpts(is_show=False),        )            .set_global_opts(            title_opts=opts.TitleOpts(title=&quot;中国每日累计确诊/治愈/死亡趋势&quot;),            legend_opts=opts.LegendOpts(pos_bottom=&quot;bottom&quot;, orient=&#39;horizontal&#39;),            tooltip_opts=opts.TooltipOpts(trigger=&quot;axis&quot;),            yaxis_opts=opts.AxisOpts(                type_=&quot;value&quot;,                axistick_opts=opts.AxisTickOpts(is_show=True),                splitline_opts=opts.SplitLineOpts(is_show=True),            ),            xaxis_opts=opts.AxisOpts(type_=&quot;category&quot;, boundary_gap=False),        )    )    return fi_map</code></pre><h3 id="【7x04】境外每日数据折线图-foreign-daily-map"><a href="#【7x04】境外每日数据折线图-foreign-daily-map" class="headerlink" title="【7x04】境外每日数据折线图 foreign_daily_map()"></a><font color="#4876FF">【7x04】境外每日数据折线图 foreign_daily_map()</font></h3><pre><code class="python">def foreign_daily_map():    wb = openpyxl.load_workbook(&#39;COVID-19-Global.xlsx&#39;)    ws_foreign_confirmed = wb[&#39;境外每日累计确诊数据&#39;]    ws_foreign_crued = wb[&#39;境外每日累计治愈数据&#39;]    ws_foreign_died = wb[&#39;境外每日累计死亡数据&#39;]    ws_foreign_confirmed.delete_rows(1)    ws_foreign_crued.delete_rows(1)    ws_foreign_died.delete_rows(1)    x_date = []                # 日期    y_foreign_confirmed = []   # 累计确诊    y_foreign_crued = []       # 累计治愈    y_foreign_died = []        # 累计死亡    for foreign_confirmed in ws_foreign_confirmed.values:        y_foreign_confirmed.append(foreign_confirmed[1])    for foreign_crued in ws_foreign_crued.values:        x_date.append(foreign_crued[0])        y_foreign_crued.append(foreign_crued[1])    for foreign_died in ws_foreign_died.values:        y_foreign_died.append(foreign_died[1])    fte_map = (        Line(init_opts=opts.InitOpts(height=&#39;420px&#39;))            .add_xaxis(xaxis_data=x_date)            .add_yaxis(            series_name=&quot;境外累计确诊趋势&quot;,            y_axis=y_foreign_confirmed,            label_opts=opts.LabelOpts(is_show=False),        )            .add_yaxis(            series_name=&quot;境外累计治愈趋势&quot;,            y_axis=y_foreign_crued,            label_opts=opts.LabelOpts(is_show=False),        )            .add_yaxis(            series_name=&quot;境外累计死亡趋势&quot;,            y_axis=y_foreign_died,            label_opts=opts.LabelOpts(is_show=False),        )            .set_global_opts(            title_opts=opts.TitleOpts(title=&quot;境外每日累计确诊/治愈/死亡趋势&quot;),            legend_opts=opts.LegendOpts(pos_bottom=&quot;bottom&quot;, orient=&#39;horizontal&#39;),            tooltip_opts=opts.TooltipOpts(trigger=&quot;axis&quot;),            yaxis_opts=opts.AxisOpts(                type_=&quot;value&quot;,                axistick_opts=opts.AxisTickOpts(is_show=True),                splitline_opts=opts.SplitLineOpts(is_show=True),            ),            xaxis_opts=opts.AxisOpts(type_=&quot;category&quot;, boundary_gap=False),        )    )    return fte_map</code></pre><h2 id="【8x00】结果截图"><a href="#【8x00】结果截图" class="headerlink" title="【8x00】结果截图"></a><font color=#FF0000>【8x00】结果截图</font></h2><h3 id="【8x01】数据储存-Excel"><a href="#【8x01】数据储存-Excel" class="headerlink" title="【8x01】数据储存 Excel"></a><font color="#4876FF">【8x01】数据储存 Excel</font></h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/03.png" alt="03"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/04.png" alt="04"></p><h3 id="【8x02】词云图"><a href="#【8x02】词云图" class="headerlink" title="【8x02】词云图"></a><font color="#4876FF">【8x02】词云图</font></h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/05.png" alt="05"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/06.png" alt="06"></p><h3 id="【8x03】地图-折线图"><a href="#【8x03】地图-折线图" class="headerlink" title="【8x03】地图 + 折线图"></a><font color="#4876FF">【8x03】地图 + 折线图</font></h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/07.png" alt="07"></p><h2 id="【9x00】完整代码"><a href="#【9x00】完整代码" class="headerlink" title="【9x00】完整代码"></a><font color=#FF0000>【9x00】完整代码</font></h2><p>预览地址：<del><a href="http://cov.itrhx.com/">http://cov.itrhx.com/</a></del>（已失效）<br>完整代码地址（点亮 star 有 buff 加成）：<a href="https://github.com/TRHX/Python3-Spider-Practice">https://github.com/TRHX/Python3-Spider-Practice</a><br>爬虫实战专栏（持续更新）：<a href="https://itrhx.blog.csdn.net/article/category/9351278">https://itrhx.blog.csdn.net/article/category/9351278</a></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/107140534未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code class=&quot;yaml&quot;&gt;这里是一段防爬虫文本，请读者忽略。
本文原创首发于 CSDN，作者 TRHX。
博客首页：https://itrhx.blog.csdn.net/
本文链接：https://itrhx.blog.csdn.net/article/d</summary>
      
    
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="肺炎疫情" scheme="https://www.itbob.cn/tags/%E8%82%BA%E7%82%8E%E7%96%AB%E6%83%85/"/>
    
    <category term="COVID-19" scheme="https://www.itbob.cn/tags/COVID-19/"/>
    
    <category term="数据可视化" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据分析三剑客之 Pandas（十）：数据读写</title>
    <link href="https://www.itbob.cn/article/034/"/>
    <id>https://www.itbob.cn/article/034/</id>
    <published>2020-06-26T14:54:56.000Z</published>
    <updated>2022-05-22T12:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106963135未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】读取数据"><a href="#【01x00】读取数据" class="headerlink" title="【01x00】读取数据"></a><font color=#FF0000>【01x00】读取数据</font></h2><p>Pandas 提供了一些用于将表格型数据读取为 DataFrame 对象的函数。常见方法如下：</p><p>Pandas 官方对 IO 工具的介绍：<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html">https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html</a></p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>read_csv</td><td>从文件、URL、文件型对象中加载带分隔符的数据。默认分隔符为逗号</td></tr><tr><td>read_table</td><td>从文件、URL、文件型对象中加载带分隔符的数据。默认分隔符为制表符（<code>&#39;\t&#39;</code>）</td></tr><tr><td>read_fwf</td><td>读取定宽列格式数据（没有分隔符）</td></tr><tr><td>read_clipboard</td><td>读取剪贴板中的数据，可以看做 read_table 的剪贴板版本。在将网页转换为表格时很有用</td></tr><tr><td>read_excel</td><td>从 Excel XLS 或 XLSX file 读取表格数据</td></tr><tr><td>read_hdf</td><td>读取 pandas写的 HDF5 文件</td></tr><tr><td>read_html</td><td>读取 HTML 文档中的所有表格</td></tr><tr><td>read_json</td><td>读取 JSON（ JavaScript Object Notation）字符串中的数据</td></tr><tr><td>read_msgpack</td><td>读取二进制格式编码的 pandas 数据（Pandas v1.0.0 中已删除对 msgpack 的支持，建议使用 <a href="https://pandas.pydata.org/docs/user_guide/io.html#io-msgpack">pyarrow</a>）</td></tr><tr><td>read_pickle</td><td>读取 Python pickle 格式中存储的任意对象</td></tr><tr><td>read_sas</td><td>读取存储于 SAS 系统自定义存储格式的 SAS 数据集</td></tr><tr><td>read_sql</td><td>（使用 SQLAlchemy）读取 SQL 查询结果为 pandas 的 DataFrame</td></tr><tr><td>read_stata</td><td>读取 Stata 文件格式的数据集</td></tr><tr><td>read_feather</td><td>读取 Feather 二进制格式文件</td></tr></tbody></table><p>以下以 read_csv 和 read_table 为例，它们的参数多达 50 多个，具体可参见官方文档：</p><p>read_csv：<a href="https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html">https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html</a></p><p>read_table：<a href="https://pandas.pydata.org/docs/reference/api/pandas.read_table.html">https://pandas.pydata.org/docs/reference/api/pandas.read_table.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>path</td><td>表示文件系统位置、URL、文件型对象的字符串</td></tr><tr><td>sep / delimiter</td><td>用于对行中各字段进行拆分的字符序列或正则表达式</td></tr><tr><td>header</td><td>用作列名的行号，默认为 0（第一行），如果没有 header 行就应该设置为 None</td></tr><tr><td>index_col</td><td>用作行索引的列编号或列名。可以是单个名称、数字或由多个名称、数字组成的列表（层次化索引）</td></tr><tr><td>names</td><td>用于结果的列名列表，结合 header=None</td></tr><tr><td>skiprows</td><td>需要忽略的行数（从文件开始处算起），或需要跳过的行号列表（从0开始）</td></tr><tr><td>na_values</td><td>指定一组值，将该组值设置为 NaN（缺失值）</td></tr><tr><td>comment</td><td>用于将注释信息从行尾拆分出去的字符（一个或多个）</td></tr><tr><td>parse_dates</td><td>尝试将数据解析为日期，默认为 False。如果为 True，则尝试解析所有列。此外，还可以指定需要解析的一组列号或列名。<br>如果列表的元素为列表或元组，就会将多个列组合到一起再进行日期解析工作（例如，日期、时间分别位于两个列中）</td></tr><tr><td>keep_date_col</td><td>如果连接多列解析日期，则保持参与连接的列。默认为 False</td></tr><tr><td>converters</td><td>由列号 / 列名跟函数之间的映射关系组成的字典。例如，<code>&#123;&#39;foo&#39;: f&#125;</code> 会对 foo 列的所有值应用函数 f</td></tr><tr><td>dayfirst</td><td>当解析有歧义的日期时，将其看做国际格式（例如，7/6/2012 —&gt; June 7,2012），默认为 Fase</td></tr><tr><td>date_parser</td><td>用于解析日期的函数</td></tr><tr><td>nrows</td><td>需要读取的行数（从文件开始处算起）</td></tr><tr><td>iterator</td><td>返回一个 TextParser 以便逐块读取文件</td></tr><tr><td>chunksize</td><td>文件块的大小（用于迭代）</td></tr><tr><td>skip_footer</td><td>需要忽略的行数（从文件末尾处算起）</td></tr><tr><td>verbose</td><td>打印各种解析器输出信息，比如“非数值列中缺失值的数量”等</td></tr><tr><td>encoding</td><td>用于 unicode 的文本编码格式。例如，“utf-8” 表示用 UTF-8 编码的文本</td></tr><tr><td>squeeze</td><td>如果数据经解析后仅含一列，则返回 Series</td></tr><tr><td>thousands</td><td>千分位分隔符，如 <code>,</code> 或 <code>.</code></td></tr></tbody></table><h3 id="【01x01】简单示例"><a href="#【01x01】简单示例" class="headerlink" title="【01x01】简单示例"></a><font color=#4876FF>【01x01】简单示例</font></h3><p>首先创建一个 test1.csv 文件：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/01.png" alt="01"></p><p>使用 read_csv 方法将其读出为一个 DataFrame 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test1.csv&#39;)&gt;&gt;&gt; obj   a   b   c   d message0  1   2   3   4   hello1  5   6   7   8   world2  9  10  11  12  python&gt;&gt;&gt; &gt;&gt;&gt; type(obj)&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</code></pre><p>前面的 csv 文件是以逗号分隔的，可以使用 read_table 方法并指定分隔符来读取：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.read_table(r&#39;C:\Users\TanRe\Desktop\test1.csv&#39;, sep=&#39;,&#39;)&gt;&gt;&gt; obj   a   b   c   d message0  1   2   3   4   hello1  5   6   7   8   world2  9  10  11  12  python</code></pre><h3 id="【01x02】header-names-定制列标签"><a href="#【01x02】header-names-定制列标签" class="headerlink" title="【01x02】header / names 定制列标签"></a><font color=#4876FF>【01x02】header / names 定制列标签</font></h3><p>以上示例中第一行为列标签，如果没有单独定义列标签，使用 read_csv 方法也会默认将第一行当作列标签：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/02.png" alt="02"></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test2.csv&#39;)&gt;&gt;&gt; obj   1   2   3   4   hello0  5   6   7   8   world1  9  10  11  12  python</code></pre><p>避免以上情况，可以设置 <code>header=None</code>，Pandas 会为其自动分配列标签：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test2.csv&#39;, header=None)   0   1   2   3       40  1   2   3   4   hello1  5   6   7   8   world2  9  10  11  12  python</code></pre><p>也可以使用 <code>names</code> 参数自定义列标签，传递的是一个列表：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test2.csv&#39;, names=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;message&#39;])   a   b   c   d message0  1   2   3   4   hello1  5   6   7   8   world2  9  10  11  12  python</code></pre><h3 id="【01x03】index-col-指定列为行索引"><a href="#【01x03】index-col-指定列为行索引" class="headerlink" title="【01x03】index_col 指定列为行索引"></a><font color=#4876FF>【01x03】index_col 指定列为行索引</font></h3><p><code>index_col</code> 参数可以指定某一列作为 DataFrame 的行索引，传递的参数是列名称，在以下示例中，会将列名为 <code>message</code> 的列作为 DataFrame 的行索引：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/03.png" alt="03"></p><pre><code class="python">&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test2.csv&#39;,                 names=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;message&#39;],                 index_col=&#39;message&#39;)         a   b   c   dmessage               hello    1   2   3   4world    5   6   7   8python   9  10  11  12</code></pre><p>如果需要构造多层索引的 DataFrame 对象，则只需传入由列编号或列名组成的列表即可：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/04.png" alt="04"></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test3.csv&#39;, index_col=[&#39;key1&#39;, &#39;key2&#39;])           value1  value2key1 key2                one  a          1       2     b          3       4     c          5       6     d          7       8two  a          9      10     b         11      12     c         13      14     d         15      16</code></pre><h3 id="【01x04】sep-指定分隔符"><a href="#【01x04】sep-指定分隔符" class="headerlink" title="【01x04】sep 指定分隔符"></a><font color=#4876FF>【01x04】sep 指定分隔符</font></h3><p>在 read_table 中，sep 参数用于接收分隔符，如果遇到不是用固定的分隔符去分隔字段的，也可以传递一个正则表达式作为 read_table 的分隔符，如下面的 txt 文件数据之间是由不同的空白字符间隔开的：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/05.png" alt="05"></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.read_table(r&#39;C:\Users\TanRe\Desktop\test1.txt&#39;, sep=&#39;\s+&#39;)            A         B         Caaa -0.264438 -1.026059 -0.619500bbb  0.927272  0.302904 -0.032399ccc -0.264273 -0.386314 -0.217601ddd -0.871858 -0.348382  1.100491</code></pre><h3 id="【01x05】skiprows-忽略行"><a href="#【01x05】skiprows-忽略行" class="headerlink" title="【01x05】skiprows 忽略行"></a><font color=#4876FF>【01x05】skiprows 忽略行</font></h3><p>skiprows    参数可用于设置需要忽略的行数，或需要跳过的行号列表，在下面的示例中，读取文件时选择跳过第1、3、4行（索引值分别为0、2、3）：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/06.png" alt="06"></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test4.csv&#39;, skiprows=[0, 2, 3])   a   b   c   d message0  1   2   3   4   hello1  5   6   7   8   world2  9  10  11  12  python</code></pre><h3 id="【01x06】na-values-设置缺失值"><a href="#【01x06】na-values-设置缺失值" class="headerlink" title="【01x06】na_values 设置缺失值"></a><font color=#4876FF>【01x06】na_values 设置缺失值</font></h3><p>当文件中出现了空字符串或者 NA 值，Pandas 会将其标记成 NaN（缺失值），同样也可以使用 <code>isnull</code> 方法来判断结果值是否为缺失值：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/07.png" alt="07"></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; obj  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt; &gt;&gt;&gt; pd.isnull(obj)   something      a      b      c      d  message0      False  False  False  False  False     True1      False  False  False   True  False    False2      False  False  False  False  False    False</code></pre><p><code>na_values</code> 方法可以传递一组值，将这组值设置为缺失值，如果传递的为字典对象，则字典的各值将被设置为 NaN：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; obj1  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt; &gt;&gt;&gt; obj2 = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;, na_values=[&#39;1&#39;, &#39;12&#39;])&gt;&gt;&gt; obj2  something    a   b     c    d message0       one  NaN   2   3.0  4.0     NaN1       two  5.0   6   NaN  8.0   world2     three  9.0  10  11.0  NaN  python&gt;&gt;&gt; &gt;&gt;&gt; sentinels = &#123;&#39;message&#39;: [&#39;python&#39;, &#39;world&#39;], &#39;something&#39;: [&#39;two&#39;]&#125;&gt;&gt;&gt; obj3 = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;, na_values=sentinels)&gt;&gt;&gt; obj3  something  a   b     c   d  message0       one  1   2   3.0   4      NaN1       NaN  5   6   NaN   8      NaN2     three  9  10  11.0  12      NaN</code></pre><h3 id="【01x07】nrows-chunksize-行与块"><a href="#【01x07】nrows-chunksize-行与块" class="headerlink" title="【01x07】nrows / chunksize 行与块"></a><font color=#4876FF>【01x07】nrows / chunksize 行与块</font></h3><p>以下 test6.csv 文件中包含 50 行数据：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/08.png" alt="08"></p><p>可以设置 <code>pd.options.display.max_rows</code> 来紧凑地显示指定行数的数据：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.options.display.max_rows = 10&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test6.csv&#39;)         one       two     three      four key0   0.467976 -0.038649 -0.295344 -1.824726   L1  -0.358893  1.404453  0.704965 -0.200638   B2  -0.501840  0.659254 -0.421691 -0.057688   G3   0.204886  1.074134  1.388361 -0.982404   R4   0.354628 -0.133116  0.283763 -0.837063   Q..       ...       ...       ...       ...  ..45  2.311896 -0.417070 -1.409599 -0.515821   L46 -0.479893 -0.633419  0.745152 -0.646038   E47  0.523331  0.787112  0.486066  1.093156   K48 -0.362559  0.598894 -1.843201  0.887292   G49 -0.096376 -1.012999 -0.657431 -0.573315   0[50 rows x 5 columns]</code></pre><p>通过 nrows 参数可以读取指定行数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test6.csv&#39;, nrows=5)        one       two     three      four key0  0.467976 -0.038649 -0.295344 -1.824726   L1 -0.358893  1.404453  0.704965 -0.200638   B2 -0.501840  0.659254 -0.421691 -0.057688   G3  0.204886  1.074134  1.388361 -0.982404   R4  0.354628 -0.133116  0.283763 -0.837063   Q</code></pre><p>要逐块读取文件，可以指定 chunksize（行数）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; chunker = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test6.csv&#39;, chunksize=50)&gt;&gt;&gt; chunker&lt;pandas.io.parsers.TextFileReader object at 0x07A20D60&gt;</code></pre><p>返回的 TextParser 对象，可以根据 chunksize 对文件进行逐块迭代。以下示例中，对 test6.csv 文件数据进行迭代处理，将值计数聚合到 “key” 列中：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; chunker = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test6.csv&#39;, chunksize=50)&gt;&gt;&gt; tot = pd.Series([], dtype=&#39;float64&#39;)&gt;&gt;&gt; for piece in chunker:    tot = tot.add(piece[&#39;key&#39;].value_counts(), fill_value=0)&gt;&gt;&gt; tot = tot.sort_values(ascending=False)&gt;&gt;&gt; tot[:10]G    6.0E    5.0B    5.0L    5.00    5.0K    4.0A    4.0R    4.0C    2.0Q    2.0dtype: float64</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106963135未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【02x00】写入数据"><a href="#【02x00】写入数据" class="headerlink" title="【02x00】写入数据"></a><font color=#FF0000>【02x00】写入数据</font></h2><p>Pandas 提供了一些用于将表格型数据读取为 DataFrame 对象的函数。常见方法如下：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>to_csv</td><td>将对象写入逗号分隔值（csv）文件</td></tr><tr><td>to_clipboard</td><td>将对象复制到系统剪贴板</td></tr><tr><td>to_excel</td><td>将对象写入 Excel 工作表</td></tr><tr><td>to_hdf</td><td>使用 HDFStore 将包含的数据写入 HDF5 文件</td></tr><tr><td>to_html</td><td>将 DataFrame 呈现为 HTML 表格</td></tr><tr><td>to_json</td><td>将对象转换为 JSON（ JavaScript Object Notation）字符串</td></tr><tr><td>to_msgpack</td><td>将对象写入二进制格式编码的文件（Pandas v1.0.0 中已删除对 msgpack 的支持，建议使用 <a href="https://pandas.pydata.org/docs/user_guide/io.html#io-msgpack">pyarrow</a>）</td></tr><tr><td>to_pickle</td><td>Pickle（序列化）对象到文件</td></tr><tr><td>to_sql</td><td>将存储在 DataFrame 中的数据写入 SQL 数据库</td></tr><tr><td>to_stata</td><td>将 DataFrame 对象导出为 Stata 格式</td></tr><tr><td>to_feather</td><td>将 DataFrames 写入 Feather 二进制格式文件</td></tr></tbody></table><p>以下以 to_csv 为例，它的参数同样多达 50 多个，具体可参见官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_csv.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_csv.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.to_csv.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.to_csv.html</a></p></li></ul><h3 id="【02x01】简单示例"><a href="#【02x01】简单示例" class="headerlink" title="【02x01】简单示例"></a><font color=#4876FF>【02x01】简单示例</font></h3><p>以之前的 test5.csv 文件为例，先读出数据，再将数据写入另外的文件：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; data  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt; &gt;&gt;&gt; data.to_csv(r&#39;C:\Users\TanRe\Desktop\out1.csv&#39;)</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/09.png" alt="09"></p><h3 id="【02x02】sep-指定分隔符"><a href="#【02x02】sep-指定分隔符" class="headerlink" title="【02x02】sep 指定分隔符"></a><font color=#4876FF>【02x02】sep 指定分隔符</font></h3><p>sep 参数可用于其他分隔符：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; data  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt;&gt;&gt;&gt; data.to_csv(r&#39;C:\Users\TanRe\Desktop\out2.csv&#39;, sep=&#39;|&#39;)</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/10.png" alt="10"></p><h3 id="【02x03】na-rep-替换缺失值"><a href="#【02x03】na-rep-替换缺失值" class="headerlink" title="【02x03】na_rep 替换缺失值"></a><font color=#4876FF>【02x03】na_rep 替换缺失值</font></h3><p>na_rep 参数可将缺失值（NaN）替换成其他字符串：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; data  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt; &gt;&gt;&gt; data.to_csv(r&#39;C:\Users\TanRe\Desktop\out3.csv&#39;, na_rep=&#39;X&#39;)</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/11.png" alt="11"></p><h3 id="【02x04】index-header-行与列标签"><a href="#【02x04】index-header-行与列标签" class="headerlink" title="【02x04】index / header 行与列标签"></a><font color=#4876FF>【02x04】index / header 行与列标签</font></h3><p>设置 <code>index=False</code>, <code>header=False</code>，可以禁用行标签与列标签：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; data  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt; &gt;&gt;&gt; data.to_csv(r&#39;C:\Users\TanRe\Desktop\out4.csv&#39;, index=False, header=False)</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/12.png" alt="12"></p><p>还可以传入列表来重新设置列标签：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; data  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt; &gt;&gt;&gt; data.to_csv(r&#39;C:\Users\TanRe\Desktop\out5.csv&#39;, header=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;])</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/13.png" alt="13"></p><h3 id="【02x05】columns-指定列"><a href="#【02x05】columns-指定列" class="headerlink" title="【02x05】columns 指定列"></a><font color=#4876FF>【02x05】columns 指定列</font></h3><p>可以通过设置 columns 参数，只写入部分列，并按照指定顺序排序：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; data  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt;&gt;&gt;&gt; data.to_csv(r&#39;C:\Users\TanRe\Desktop\out6.csv&#39;, columns=[&#39;c&#39;, &#39;b&#39;, &#39;a&#39;])</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/14.png" alt="14"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106963135未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Pandas 系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itbob.cn/article/025/&quot;&gt;Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象&lt;/a&gt;&lt;/li&gt;</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.itbob.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="数据分析" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="Pandas" scheme="https://www.itbob.cn/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据分析三剑客之 Pandas（九）：时间序列</title>
    <link href="https://www.itbob.cn/article/033/"/>
    <id>https://www.itbob.cn/article/033/</id>
    <published>2020-06-25T13:55:49.000Z</published>
    <updated>2022-05-22T12:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106947061未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】时间序列"><a href="#【01x00】时间序列" class="headerlink" title="【01x00】时间序列"></a><font color=#FF0000>【01x00】时间序列</font></h2><p>官网对于时间序列的介绍：<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html">https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html</a></p><p>时间序列（time series）是一种重要的结构化数据形式，应用于多个领域，包括金融学、经济学、生态学、神经科学、物理学等。在多个时间点观察或测量到的任何事物都可以形成一段时间序列。很多时间序列是固定频率的，也就是说，数据点是根据某种规律定期出现的（比如每15秒、每5分钟、每月出现一次）。时间序列也可以是不定期的，没有固定的时间单位或单位之间的偏移量。时间序列数据的意义取决于具体的应用场景，主要有以下几种：</p><ul><li><p><font color=#4169E1><strong>时间戳（timestamp），表示某个具体的时间点，例如 2020-6-24 15:30；</strong></font></p></li><li><p><font color=#4169E1><strong>固定周期（period），表示某个时间周期，例如 2020-01；</strong></font></p></li><li><p><font color=#4169E1><strong>时间间隔（timedelta），持续时间，即两个日期或时间之间的差异。</strong></font></p></li><li><p><font color=#FFA500><strong>针对时间戳数据，Pandas 提供了 Timestamp 类型。它本质上是 Python 的原生 datetime 类型的替代品，但是在性能更好的 numpy.datetime64 类型的基础上创建。对应的索引数据结构是 DatetimeIndex。</strong></font></p></li><li><p><font color=#FFA500><strong>针对时间周期数据，Pandas 提供了 Period 类型。这是利用 numpy.datetime64 类型将固定频率的时间间隔进行编码。对应的索引数据结构是 PeriodIndex。</strong></font></p></li><li><p><font color=#FFA500><strong>针对时间增量或持续时间，Pandas 提供了 Timedelta 类型。Timedelta 是一种代替 Python 原生datetime.timedelta 类型的高性能数据结构，同样是基于 numpy.timedelta64 类型。对应的索引数据结构是 TimedeltaIndex。</strong></font></p></li></ul><h2 id="【02x00】Timestamp-时间戳"><a href="#【02x00】Timestamp-时间戳" class="headerlink" title="【02x00】Timestamp 时间戳"></a><font color=#FF0000>【02x00】Timestamp 时间戳</font></h2><h3 id="【02x01】pandas-Timestamp"><a href="#【02x01】pandas-Timestamp" class="headerlink" title="【02x01】pandas.Timestamp"></a><font color=#4876FF>【02x01】pandas.Timestamp</font></h3><p>在 pandas 中，<code>pandas.Timestamp</code> 方法用来代替 Python 中的 <code>datetime.datetime</code> 方法。</p><p>Timestamp 与 Python 的 Datetime 等效，在大多数情况下都可以互换。 此类型用于组成 DatetimeIndex 以及 Pandas 中其他面向时间序列的数据结构。</p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Timestamp.html">https://pandas.pydata.org/docs/reference/api/pandas.Timestamp.html</a></p><p>基本语法：</p><pre><code class="python">class pandas.Timestamp(ts_input=&lt;object object&gt;,                        freq=None, tz=None, unit=None,                        year=None, month=None, day=None,                        hour=None, minute=None, second=None,                        microsecond=None, nanosecond=None, tzinfo=None)</code></pre><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>ts_input</td><td>要转换为时间戳的对象，可以是 datetime-like，str，int，float 类型</td></tr><tr><td>freq</td><td>时间戳将具有的偏移量，可以是 str，日期偏移量类型，取值参见<a href="#t4">【02x02】freq 频率部分取值</a></td></tr><tr><td>tz</td><td>时间戳将具有的时区</td></tr><tr><td>unit</td><td>如果 ts_input 是整数或浮点数，该参数用于设置其单位（D、s、ms、us、ns）</td></tr></tbody></table><p>简单示例：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Timestamp(&#39;2017-01-01T12&#39;)Timestamp(&#39;2017-01-01 12:00:00&#39;)</code></pre><p>设置 <code>unit=&#39;s&#39;</code>，即待转换对象单位为秒：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Timestamp(1513393355.5, unit=&#39;s&#39;)Timestamp(&#39;2017-12-16 03:02:35.500000&#39;)</code></pre><p>使用 <code>tz</code> 参数设置时区：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Timestamp(1513393355, unit=&#39;s&#39;, tz=&#39;US/Pacific&#39;)Timestamp(&#39;2017-12-15 19:02:35-0800&#39;, tz=&#39;US/Pacific&#39;)</code></pre><p>单独设置年月日：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Timestamp(year=2020, month=6, day=24, hour=12)Timestamp(&#39;2020-06-24 12:00:00&#39;)</code></pre><h3 id="【02x02】freq-频率部分取值"><a href="#【02x02】freq-频率部分取值" class="headerlink" title="【02x02】freq 频率部分取值"></a><font color=#4876FF>【02x02】freq 频率部分取值</font></h3><p>完整取值参见官方文档：<a href="https://pandas.pydata.org/docs/user_guide/timeseries.html#timeseries-offset-aliases">https://pandas.pydata.org/docs/user_guide/timeseries.html#timeseries-offset-aliases</a></p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>D</td><td>Day</td><td>每日历日</td></tr><tr><td>B</td><td>BusinessDay</td><td>每工作日</td></tr><tr><td>H</td><td>Hour</td><td>每小时</td></tr><tr><td>T 或 min</td><td>Minute</td><td>每分</td></tr><tr><td>S</td><td>Second</td><td>每秒</td></tr><tr><td>L 或 ms</td><td>Milli</td><td>每毫秒（即每千分之一秒）</td></tr><tr><td>U</td><td>Micro</td><td>每微秒（即每百万分之一秒）</td></tr><tr><td>M</td><td>MonthEnd</td><td>每月最后一个日历日</td></tr><tr><td>BM</td><td>BusinessMonthEnd</td><td>每月最后一个工作日</td></tr><tr><td>MS</td><td>MonthBegin</td><td>每月第一个日历日</td></tr><tr><td>BMS</td><td>BusinessMonthBegin</td><td>每月第一个工作日</td></tr><tr><td>W-MON、W-TUE…</td><td>Week</td><td>从指定的星期几（MON、TUE、 WED、THU、FR、SAT、SUN）开始算起，每周</td></tr><tr><td>WoM-1MON、WOM-2MON…</td><td>WeekOfMonth</td><td>产生每月第一、第二、第三或第四周的星期几。例如，WoM-3FRI 表示每月第3个星期五</td></tr><tr><td>Q-JAN、Q-FEB…</td><td>QuarterEnd</td><td>对于以指定月份（JAN、FEB、MAR、APR、MAY、JUN、JUL、AUG、SEP、OCT、NOV、DEC）结束的年度，每季度最后一月的最后个日历日</td></tr><tr><td>BQ-JAN、BQ-FEB…</td><td>BusinessQuarterEnd</td><td>对于以指定月份结束的年度，每季度最后一月的最后一个工作日</td></tr><tr><td>QS-JAN、QS-FEB…</td><td>QuarterBegin</td><td>对于以指定月份结束的年度，每季度最后一月的第一个日历日</td></tr><tr><td>BQS-JAN、 BQS-FEB…</td><td>BusinessQuarterBegin</td><td>对于以指定月份结束的年度，每季度最后一月的第一个工作日</td></tr><tr><td>A-JAN、A-FEB…</td><td>YearEnd</td><td>每年指定月份（JAN、FEB、MAR、APR、MAY、JUN、JUL、AUG、SEP、 OCT、NOV、DEC）的最后一个日历日</td></tr><tr><td>BA-JAN、BA-FEB…</td><td>BusinessYearEnd</td><td>每年指定月份的最后一个工作日</td></tr><tr><td>AS-JAN、AS-FEB…</td><td>YearBegin</td><td>每年指定月份的第一个历日日</td></tr><tr><td>BAS-JAN、BAS-FEB…</td><td>BusinessYearBegin</td><td>每年指定月份的第一个工作日</td></tr></tbody></table><h3 id="【02x03】to-datetime"><a href="#【02x03】to-datetime" class="headerlink" title="【02x03】to_datetime"></a><font color=#4876FF>【02x03】to_datetime</font></h3><p>在 Python 中，datetime 库提供了日期和时间处理方法，利用 <code>str</code> 或 <code>strftime</code> 方法可以将 datetime 对象转化成字符串，具体用法可参见<a href="https://blog.csdn.net/qq_36759224/article/details/104427220">【Python 标准库学习】日期和时间处理库 — datetime</a>。</p><pre><code class="python">&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; stamp = datetime(2020, 6, 24)&gt;&gt;&gt; stampdatetime.datetime(2020, 6, 24, 0, 0)&gt;&gt;&gt;&gt;&gt;&gt; str(stamp)&#39;2020-06-24 00:00:00&#39;&gt;&gt;&gt; &gt;&gt;&gt; stamp.strftime(&#39;%Y-%m-%d&#39;)&#39;2020-06-24&#39;</code></pre><p><font color=#FF0000><strong>在 pandas 中 to_datetime 方法可以将字符串解析成多种不同的 Timestamp（时间戳） 对象：</strong></font></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; datestrs = &#39;2011-07-06 12:00:00&#39;&gt;&gt;&gt; type(datestrs)&lt;class &#39;str&#39;&gt;&gt;&gt;&gt; &gt;&gt;&gt; pd.to_datetime(datestrs)Timestamp(&#39;2011-07-06 12:00:00&#39;)</code></pre><p>基本语法：</p><pre><code class="python">pandas.to_datetime(arg, errors=&#39;raise&#39;, dayfirst=False,                    yearfirst=False, utc=None, format=None,                    exact=True, unit=None, infer_datetime_format=False,                    origin=&#39;unix&#39;, cache=True)</code></pre><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html">https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>arg</td><td>要转换为日期时间的对象，可以接受 int, float, str, datetime, list, tuple, 1-d array, Series DataFrame/dict-like 类型</td></tr><tr><td>errors</td><td>如果字符串不满足时间戳的形式，是否会发生异常<br><code>ignore</code>：不引发异常，返回原始输入；<code>raise</code>：无效解析将引发异常（默认）；<code>coerce</code>：无效解析将被设置为NaT</td></tr><tr><td>dayfirst</td><td>bool 类型，默认 False，如果 arg 是 str 或列表，是否首先解析为日期<br>例如 dayfirst 为 True，<code>10/11/12</code> 被解析为 <code>2012-11-10</code>，为 False 则解析为 <code>2012-10-11</code></td></tr><tr><td>yearfirst</td><td>bool 类型，默认 False，如果 arg 是 str 或列表，是否首先解析为年份<br>例如 dayfirst 为 True，<code>10/11/12</code> 被解析为 <code>2010-11-12</code>，为 False 则解析为 <code>2012-10-11</code><br>如果 dayfirst 和 yearfirst 都为 True，则优先 yearfirst</td></tr><tr><td>utc</td><td>bool 类型，是否转换为协调世界时，默认 None</td></tr><tr><td>format</td><td>格式化时间，如 <code>21/2/20 16:10</code> 使用 <code>%d/%m/%y %H:%M</code> 会被解析为 <code>2020-02-21 16:10:00</code><br>符号含义常见文章：<a href="https://blog.csdn.net/qq_36759224/article/details/104427220">【Python 标准库学习】日期和时间处理库 — datetime</a> 或者<a href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior">官方文档</a></td></tr><tr><td>exact</td><td>如果为 True，则需要精确的格式匹配。如果为 False，则允许格式与目标字符串中的任何位置匹配</td></tr><tr><td>unit</td><td>如果 arg 是整数或浮点数，该参数用于设置其单位（D、s、ms、us、ns）</td></tr></tbody></table><p>简单应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;year&#39;: [2015, 2016], &#39;month&#39;: [2, 3], &#39;day&#39;: [4, 5]&#125;)&gt;&gt;&gt; obj   year  month  day0  2015      2    41  2016      3    5&gt;&gt;&gt; &gt;&gt;&gt; pd.to_datetime(obj)0   2015-02-041   2016-03-05dtype: datetime64[ns]</code></pre><p>设置 <code>format</code> 和 <code>errors</code> 参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.to_datetime(&#39;13000101&#39;, format=&#39;%Y%m%d&#39;, errors=&#39;ignore&#39;)datetime.datetime(1300, 1, 1, 0, 0)&gt;&gt;&gt; &gt;&gt;&gt; pd.to_datetime(&#39;13000101&#39;, format=&#39;%Y%m%d&#39;, errors=&#39;coerce&#39;)NaT&gt;&gt;&gt; &gt;&gt;&gt; pd.to_datetime(&#39;13000101&#39;, format=&#39;%Y%m%d&#39;, errors=&#39;raise&#39;)Traceback (most recent call last):...pandas._libs.tslibs.np_datetime.OutOfBoundsDatetime: Out of bounds nanosecond timestamp: 1300-01-01 00:00:00</code></pre><p>设置 <code>unit</code> 参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.to_datetime(1490195805, unit=&#39;s&#39;)Timestamp(&#39;2017-03-22 15:16:45&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.to_datetime(1490195805433502912, unit=&#39;ns&#39;)Timestamp(&#39;2017-03-22 15:16:45.433502912&#39;)</code></pre><h3 id="【02x04】date-range"><a href="#【02x04】date-range" class="headerlink" title="【02x04】date_range"></a><font color=#4876FF>【02x04】date_range</font></h3><p><code>pandas.date_range</code> 方法可用于根据指定的频率生成指定长度的 DatetimeIndex。</p><p>基本语法：</p><pre><code class="python">pandas.date_range(start=None, end=None, periods=None, freq=None,                   tz=None, normalize=False, name=None, closed=None,                   **kwargs) → pandas.core.indexes.datetimes.DatetimeIndex</code></pre><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.date_range.html">https://pandas.pydata.org/docs/reference/api/pandas.date_range.html</a></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>开始日期</td></tr><tr><td>end</td><td>结束日期</td></tr><tr><td>periods</td><td>int 类型，要生成的时段数（天）</td></tr><tr><td>freq</td><td>频率字符串，即按照某种特定的频率来生成日期，取值参见<a href="#t4">【02x02】freq 频率部分取值</a></td></tr><tr><td>tz</td><td>设置时区，例如 “Asia/Hong_Kong”</td></tr><tr><td>normalize</td><td>bool 类型，默认 False，是否在生成日期之前对其进行规范化（仅保留年月日）</td></tr><tr><td>name</td><td>结果 DatetimeIndex 的名称</td></tr><tr><td>closed</td><td><code>None</code>：默认值，同时保留开始日期和结束日期<br><code>&#39;left&#39;</code>：保留开始日期，不保留结束日期<br><code>&#39;right&#39;</code>：保留结束日期，不保留开始日期</td></tr></tbody></table><p>简单示例：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, end=&#39;1/08/2018&#39;)DatetimeIndex([&#39;2018-01-01&#39;, &#39;2018-01-02&#39;, &#39;2018-01-03&#39;, &#39;2018-01-04&#39;,               &#39;2018-01-05&#39;, &#39;2018-01-06&#39;, &#39;2018-01-07&#39;, &#39;2018-01-08&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</code></pre><p>指定 <code>periods</code> 参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(start=&#39;2012-04-01&#39;, periods=20)DatetimeIndex([&#39;2012-04-01&#39;, &#39;2012-04-02&#39;, &#39;2012-04-03&#39;, &#39;2012-04-04&#39;,               &#39;2012-04-05&#39;, &#39;2012-04-06&#39;, &#39;2012-04-07&#39;, &#39;2012-04-08&#39;,               &#39;2012-04-09&#39;, &#39;2012-04-10&#39;, &#39;2012-04-11&#39;, &#39;2012-04-12&#39;,               &#39;2012-04-13&#39;, &#39;2012-04-14&#39;, &#39;2012-04-15&#39;, &#39;2012-04-16&#39;,               &#39;2012-04-17&#39;, &#39;2012-04-18&#39;, &#39;2012-04-19&#39;, &#39;2012-04-20&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.date_range(end=&#39;2012-06-01&#39;, periods=20)DatetimeIndex([&#39;2012-05-13&#39;, &#39;2012-05-14&#39;, &#39;2012-05-15&#39;, &#39;2012-05-16&#39;,               &#39;2012-05-17&#39;, &#39;2012-05-18&#39;, &#39;2012-05-19&#39;, &#39;2012-05-20&#39;,               &#39;2012-05-21&#39;, &#39;2012-05-22&#39;, &#39;2012-05-23&#39;, &#39;2012-05-24&#39;,               &#39;2012-05-25&#39;, &#39;2012-05-26&#39;, &#39;2012-05-27&#39;, &#39;2012-05-28&#39;,               &#39;2012-05-29&#39;, &#39;2012-05-30&#39;, &#39;2012-05-31&#39;, &#39;2012-06-01&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)&gt;&gt;&gt;&gt;&gt;&gt; pd.date_range(start=&#39;2018-04-24&#39;, end=&#39;2018-04-27&#39;, periods=3)DatetimeIndex([&#39;2018-04-24 00:00:00&#39;, &#39;2018-04-25 12:00:00&#39;, &#39;2018-04-27 00:00:00&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=None)&gt;&gt;&gt;&gt;&gt;&gt; pd.date_range(start=&#39;2018-04-24&#39;, end=&#39;2018-04-28&#39;, periods=3)DatetimeIndex([&#39;2018-04-24&#39;, &#39;2018-04-26&#39;, &#39;2018-04-28&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</code></pre><p>指定 <code>freq=&#39;M&#39;</code> 会按照每月最后一个日历日的频率生成日期，指定 <code>freq=&#39;3M&#39;</code> 会每隔3个月按照每月最后一个日历日的频率生成日期：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, periods=5, freq=&#39;M&#39;)DatetimeIndex([&#39;2018-01-31&#39;, &#39;2018-02-28&#39;, &#39;2018-03-31&#39;, &#39;2018-04-30&#39;,               &#39;2018-05-31&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, periods=5, freq=&#39;3M&#39;)DatetimeIndex([&#39;2018-01-31&#39;, &#39;2018-04-30&#39;, &#39;2018-07-31&#39;, &#39;2018-10-31&#39;,               &#39;2019-01-31&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;3M&#39;)&gt;&gt;&gt; </code></pre><p>使用 <code>tz</code> 参数设置时区：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, periods=5, tz=&#39;Asia/Tokyo&#39;)DatetimeIndex([&#39;2018-01-01 00:00:00+09:00&#39;, &#39;2018-01-02 00:00:00+09:00&#39;,               &#39;2018-01-03 00:00:00+09:00&#39;, &#39;2018-01-04 00:00:00+09:00&#39;,               &#39;2018-01-05 00:00:00+09:00&#39;],              dtype=&#39;datetime64[ns, Asia/Tokyo]&#39;, freq=&#39;D&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.date_range(start=&#39;6/24/2020&#39;, periods=5, tz=&#39;Asia/Hong_Kong&#39;)DatetimeIndex([&#39;2020-06-24 00:00:00+08:00&#39;, &#39;2020-06-25 00:00:00+08:00&#39;,               &#39;2020-06-26 00:00:00+08:00&#39;, &#39;2020-06-27 00:00:00+08:00&#39;,               &#39;2020-06-28 00:00:00+08:00&#39;],              dtype=&#39;datetime64[ns, Asia/Hong_Kong]&#39;, freq=&#39;D&#39;)</code></pre><p>设置 <code>normalize</code> 参数，在生成时间戳之前对其进行格式化操作：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(&#39;2020-06-24 12:56:31&#39;, periods=5, normalize=True)DatetimeIndex([&#39;2020-06-24&#39;, &#39;2020-06-25&#39;, &#39;2020-06-26&#39;, &#39;2020-06-27&#39;,               &#39;2020-06-28&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</code></pre><p>设置 <code>closed</code> 参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(start=&#39;2020-06-20&#39;, end=&#39;2020-06-24&#39;, closed=None)DatetimeIndex([&#39;2020-06-20&#39;, &#39;2020-06-21&#39;, &#39;2020-06-22&#39;, &#39;2020-06-23&#39;,               &#39;2020-06-24&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.date_range(start=&#39;2020-06-20&#39;, end=&#39;2020-06-24&#39;, closed=&#39;left&#39;)DatetimeIndex([&#39;2020-06-20&#39;, &#39;2020-06-21&#39;, &#39;2020-06-22&#39;, &#39;2020-06-23&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.date_range(start=&#39;2020-06-20&#39;, end=&#39;2020-06-24&#39;, closed=&#39;right&#39;)DatetimeIndex([&#39;2020-06-21&#39;, &#39;2020-06-22&#39;, &#39;2020-06-23&#39;, &#39;2020-06-24&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</code></pre><h3 id="【02x05】索引与切片"><a href="#【02x05】索引与切片" class="headerlink" title="【02x05】索引与切片"></a><font color=#4876FF>【02x05】索引与切片</font></h3><p>Pandas 最基本的时间序列类型就是以时间戳（通常以 Python 字符串或 datatime 对象表示）为索引的Series，这些 datetime 对象实际上是被放在 DatetimeIndex 中的，可以使用类似 pandas.Series 对象的切片方法对其进行索引：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; dates = [datetime(2011, 1, 2), datetime(2011, 1, 5),             datetime(2011, 1, 7), datetime(2011, 1, 8),             datetime(2011, 1, 10), datetime(2011, 1, 12)]&gt;&gt;&gt; obj = pd.Series(np.random.randn(6), index=dates)&gt;&gt;&gt; &gt;&gt;&gt; obj2011-01-02   -0.4071102011-01-05   -0.1866612011-01-07   -0.7310802011-01-08    0.8609702011-01-10    1.9299732011-01-12   -0.168599dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.indexDatetimeIndex([&#39;2011-01-02&#39;, &#39;2011-01-05&#39;, &#39;2011-01-07&#39;, &#39;2011-01-08&#39;,               &#39;2011-01-10&#39;, &#39;2011-01-12&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=None)&gt;&gt;&gt;&gt;&gt;&gt; obj.index[0]Timestamp(&#39;2011-01-02 00:00:00&#39;)&gt;&gt;&gt; &gt;&gt;&gt; obj.index[0:3]DatetimeIndex([&#39;2011-01-02&#39;, &#39;2011-01-05&#39;, &#39;2011-01-07&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</code></pre><p>另外还可以传入一个可以被解释为日期的字符串，或者只需传入“年”或“年月”即可轻松选取数据的切片：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series(np.random.randn(1000), index=pd.date_range(&#39;1/1/2000&#39;, periods=1000))&gt;&gt;&gt; obj2000-01-01   -1.1422842000-01-02    1.1987852000-01-03    2.4669092000-01-04   -0.0867282000-01-05   -0.978437                ...   2002-09-22   -0.2522402002-09-23    0.1485612002-09-24   -1.3304092002-09-25   -0.6734712002-09-26   -0.253271Freq: D, Length: 1000, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;26/9/2002&#39;]-0.25327100684233356&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;2002&#39;]2002-01-01    1.0587152002-01-02    0.9008592002-01-03    1.9935082002-01-04   -0.1032112002-01-05   -0.950090                ...   2002-09-22   -0.2522402002-09-23    0.1485612002-09-24   -1.3304092002-09-25   -0.6734712002-09-26   -0.253271Freq: D, Length: 269, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;2002-09&#39;]2002-09-01   -0.9955282002-09-02    0.5015282002-09-03   -0.4867532002-09-04   -1.0839062002-09-05    1.4589752002-09-06   -1.3316852002-09-07    0.1953382002-09-08   -0.4296132002-09-09    1.1258232002-09-10    1.6070512002-09-11    0.5303872002-09-12   -0.0159382002-09-13    1.7810432002-09-14   -0.2771232002-09-15    0.3445692002-09-16   -1.0108102002-09-17    0.4630012002-09-18    1.8836362002-09-19    0.2745202002-09-20    0.6241842002-09-21   -1.2030572002-09-22   -0.2522402002-09-23    0.1485612002-09-24   -1.3304092002-09-25   -0.6734712002-09-26   -0.253271Freq: D, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;20/9/2002&#39;:&#39;26/9/2002&#39;]2002-09-20    0.6241842002-09-21   -1.2030572002-09-22   -0.2522402002-09-23    0.1485612002-09-24   -1.3304092002-09-25   -0.6734712002-09-26   -0.253271Freq: D, dtype: float64</code></pre><h3 id="【02x06】移动数据与数据偏移"><a href="#【02x06】移动数据与数据偏移" class="headerlink" title="【02x06】移动数据与数据偏移"></a><font color=#4876FF>【02x06】移动数据与数据偏移</font></h3><p>移动（shifting）指的是沿着时间轴将数据前移或后移。Series 和 DataFrame 都有一个 shift 方法用于执行单纯的前移或后移操作，保持索引不变：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series(np.random.randn(4),            index=pd.date_range(&#39;1/1/2000&#39;, periods=4, freq=&#39;M&#39;))&gt;&gt;&gt; obj2000-01-31   -0.1002172000-02-29    1.1778342000-03-31   -0.6443532000-04-30   -1.954679Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.shift(2)2000-01-31         NaN2000-02-29         NaN2000-03-31   -0.1002172000-04-30    1.177834Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.shift(-2)2000-01-31   -0.6443532000-02-29   -1.9546792000-03-31         NaN2000-04-30         NaNFreq: M, dtype: float64</code></pre><p>因为简单的移位操作不会修改索引，所以部分数据会被丢弃并引入 NaN（缺失值）。因此，如果频率已知，则可以将其传给 shift 以便实现对时间戳进行位移而不是对数据进行简单位移：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series(np.random.randn(4),            index=pd.date_range(&#39;1/1/2000&#39;, periods=4, freq=&#39;M&#39;))&gt;&gt;&gt; obj2000-01-31   -0.1002172000-02-29    1.1778342000-03-31   -0.6443532000-04-30   -1.954679Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.shift(2, freq=&#39;M&#39;)2000-03-31   -0.1002172000-04-30    1.1778342000-05-31   -0.6443532000-06-30   -1.954679Freq: M, dtype: float64</code></pre><p>Pandas 中的频率是由一个基础频率（base frequency）和一个乘数组成的。基础频率通常以一个字符串别名表示，比如 <code>&quot;M&quot;</code> 表示每月，<code>&quot;H&quot;</code> 表示每小时。对于每个基础频率，都有一个被称为日期偏移量（date offset）的对象与之对应。例如，按小时计算的频率可以用 <code>Hour</code> 类表示：</p><pre><code class="python">&gt;&gt;&gt; from pandas.tseries.offsets import Hour, Minute&gt;&gt;&gt; hour = Hour()&gt;&gt;&gt; hour&lt;Hour&gt;&gt;&gt;&gt; &gt;&gt;&gt; four_hours = Hour(4)&gt;&gt;&gt; four_hours&lt;4 * Hours&gt;</code></pre><p>一般来说，无需明确创建这样的对象，只需使用诸如 <code>&quot;H&quot;</code> 或 <code>&quot;4H&quot;</code> 这样的字符串别名即可。在基础频率前面放上一个整数即可创建倍数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(&#39;2000-01-01&#39;, &#39;2000-01-03 23:59&#39;, freq=&#39;4h&#39;)DatetimeIndex([&#39;2000-01-01 00:00:00&#39;, &#39;2000-01-01 04:00:00&#39;,               &#39;2000-01-01 08:00:00&#39;, &#39;2000-01-01 12:00:00&#39;,               &#39;2000-01-01 16:00:00&#39;, &#39;2000-01-01 20:00:00&#39;,               &#39;2000-01-02 00:00:00&#39;, &#39;2000-01-02 04:00:00&#39;,               &#39;2000-01-02 08:00:00&#39;, &#39;2000-01-02 12:00:00&#39;,               &#39;2000-01-02 16:00:00&#39;, &#39;2000-01-02 20:00:00&#39;,               &#39;2000-01-03 00:00:00&#39;, &#39;2000-01-03 04:00:00&#39;,               &#39;2000-01-03 08:00:00&#39;, &#39;2000-01-03 12:00:00&#39;,               &#39;2000-01-03 16:00:00&#39;, &#39;2000-01-03 20:00:00&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;4H&#39;)</code></pre><p>大部分偏移量对象都可通过加法进行连接：</p><pre><code class="python">&gt;&gt;&gt; from pandas.tseries.offsets import Hour, Minute&gt;&gt;&gt; Hour(2) + Minute(30)&lt;150 * Minutes&gt;</code></pre><p>对于 <code>freq</code> 参数也可以传入频率字符串（如 <code>&quot;2h30min&quot;</code>），这种字符串可以被高效地解析为等效的表达式：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(&#39;2000-01-01&#39;, periods=10, freq=&#39;1h30min&#39;)DatetimeIndex([&#39;2000-01-01 00:00:00&#39;, &#39;2000-01-01 01:30:00&#39;,               &#39;2000-01-01 03:00:00&#39;, &#39;2000-01-01 04:30:00&#39;,               &#39;2000-01-01 06:00:00&#39;, &#39;2000-01-01 07:30:00&#39;,               &#39;2000-01-01 09:00:00&#39;, &#39;2000-01-01 10:30:00&#39;,               &#39;2000-01-01 12:00:00&#39;, &#39;2000-01-01 13:30:00&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;90T&#39;)</code></pre><p>这种偏移量还可以用在 datetime 或 Timestamp 对象上：</p><pre><code class="python">&gt;&gt;&gt; from pandas.tseries.offsets import Day, MonthEnd&gt;&gt;&gt; now = datetime(2011, 11, 17)&gt;&gt;&gt; now + 3 * Day()Timestamp(&#39;2011-11-20 00:00:00&#39;)</code></pre><p>如果加的是锚点偏移量，比如 MonthEnd，第一次增量会将原日期向前滚动到符合频率规则的下一个日期：</p><pre><code class="python">&gt;&gt;&gt; from pandas.tseries.offsets import Day, MonthEnd&gt;&gt;&gt; now = datetime(2011, 11, 17)&gt;&gt;&gt; now + MonthEnd()Timestamp(&#39;2011-11-30 00:00:00&#39;)&gt;&gt;&gt; now + MonthEnd(2)Timestamp(&#39;2011-12-31 00:00:00&#39;)</code></pre><p>通过锚点偏移量的 rollforward 和 rollback 方法，可明确地将日期向前或向后滚动：</p><pre><code class="python">&gt;&gt;&gt; from pandas.tseries.offsets import Day, MonthEnd&gt;&gt;&gt; now = datetime(2011, 11, 17)&gt;&gt;&gt; offset = MonthEnd()&gt;&gt;&gt; offset.rollforward(now)Timestamp(&#39;2011-11-30 00:00:00&#39;)&gt;&gt;&gt; offset.rollback(now)Timestamp(&#39;2011-10-31 00:00:00&#39;)</code></pre><p>与 <code>groupby</code> 方法结合使用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; from pandas.tseries.offsets import Day, MonthEnd&gt;&gt;&gt; obj = pd.Series(np.random.randn(20),            index=pd.date_range(&#39;1/15/2000&#39;, periods=20, freq=&#39;4d&#39;))&gt;&gt;&gt; obj2000-01-15   -0.5917292000-01-19   -0.7758442000-01-23   -0.7456032000-01-27   -0.0764392000-01-31    1.7964172000-02-04   -0.5003492000-02-08    0.5158512000-02-12   -0.3441712000-02-16    0.4196572000-02-20    0.3072882000-02-24    0.1151132000-02-28   -0.3625852000-03-03    1.0748922000-03-07    1.1113662000-03-11    0.9499102000-03-15   -1.5357272000-03-19    0.5459442000-03-23   -0.8101392000-03-27   -1.2606272000-03-31   -0.128403Freq: 4D, dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; offset = MonthEnd()&gt;&gt;&gt; obj.groupby(offset.rollforward).mean()2000-01-31   -0.0786402000-02-29    0.0215432000-03-31   -0.006598dtype: float64</code></pre><h3 id="【02x07】时区处理"><a href="#【02x07】时区处理" class="headerlink" title="【02x07】时区处理"></a><font color=#4876FF>【02x07】时区处理</font></h3><p>在 Python 中，时区信息来自第三方库 pytz，使用 <code>pytz.common_timezones</code> 方法可以查看所有的时区名称，使用 <code>pytz.timezone</code> 方法从 pytz 中获取时区对象：</p><pre><code class="python">&gt;&gt;&gt; import pytz&gt;&gt;&gt; pytz.common_timezones[&#39;Africa/Abidjan&#39;, &#39;Africa/Accra&#39;, &#39;Africa/Addis_Ababa&#39;, ..., &#39;UTC&#39;]&gt;&gt;&gt;&gt;&gt;&gt; tz = pytz.timezone(&#39;Asia/Shanghai&#39;)&gt;&gt;&gt; tz&lt;DstTzInfo &#39;Asia/Shanghai&#39; LMT+8:06:00 STD&gt;  # 表示与 UTC 时间相差8小时6分</code></pre><p>在 <code>date_range</code> 方法中，<code>tz</code> 参数用于指定时区，默认为 None，可以使用 <code>tz_localize</code> 方法将其进行本地化时区转换，如下示例中，将无时区转本地化 UTC 时区：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; rng = pd.date_range(&#39;3/9/2012 9:30&#39;, periods=6, freq=&#39;D&#39;)&gt;&gt;&gt; ts = pd.Series(np.random.randn(len(rng)), index=rng)&gt;&gt;&gt; ts2012-03-09 09:30:00   -1.5279132012-03-10 09:30:00   -1.1161012012-03-11 09:30:00    0.3593582012-03-12 09:30:00   -0.4759202012-03-13 09:30:00   -0.3365702012-03-14 09:30:00   -1.075952Freq: D, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; print(ts.index.tz)None&gt;&gt;&gt; &gt;&gt;&gt; ts_utc = ts.tz_localize(&#39;UTC&#39;)&gt;&gt;&gt; ts_utc2012-03-09 09:30:00+00:00   -1.5279132012-03-10 09:30:00+00:00   -1.1161012012-03-11 09:30:00+00:00    0.3593582012-03-12 09:30:00+00:00   -0.4759202012-03-13 09:30:00+00:00   -0.3365702012-03-14 09:30:00+00:00   -1.075952Freq: D, dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; ts_utc.indexDatetimeIndex([&#39;2012-03-09 09:30:00+00:00&#39;, &#39;2012-03-10 09:30:00+00:00&#39;,               &#39;2012-03-11 09:30:00+00:00&#39;, &#39;2012-03-12 09:30:00+00:00&#39;,               &#39;2012-03-13 09:30:00+00:00&#39;, &#39;2012-03-14 09:30:00+00:00&#39;],              dtype=&#39;datetime64[ns, UTC]&#39;, freq=&#39;D&#39;)</code></pre><p>时间序列被本地化到某个特定时区后，就可以用 <code>tz_convert</code> 方法将其转换到别的时区了：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; rng = pd.date_range(&#39;3/9/2012 9:30&#39;, periods=6, freq=&#39;D&#39;)&gt;&gt;&gt; ts = pd.Series(np.random.randn(len(rng)), index=rng)&gt;&gt;&gt; ts2012-03-09 09:30:00    0.4803032012-03-10 09:30:00   -1.4610392012-03-11 09:30:00   -1.5127492012-03-12 09:30:00   -2.1854212012-03-13 09:30:00    1.6578452012-03-14 09:30:00    0.175633Freq: D, dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; ts.tz_localize(&#39;UTC&#39;).tz_convert(&#39;Asia/Shanghai&#39;)2012-03-09 17:30:00+08:00    0.4803032012-03-10 17:30:00+08:00   -1.4610392012-03-11 17:30:00+08:00   -1.5127492012-03-12 17:30:00+08:00   -2.1854212012-03-13 17:30:00+08:00    1.6578452012-03-14 17:30:00+08:00    0.175633Freq: D, dtype: float64</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106947061未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【03x00】period-固定时期"><a href="#【03x00】period-固定时期" class="headerlink" title="【03x00】period 固定时期"></a><font color=#FF0000>【03x00】period 固定时期</font></h2><h3 id="【03x01】pandas-Period"><a href="#【03x01】pandas-Period" class="headerlink" title="【03x01】pandas.Period"></a><font color=#4876FF>【03x01】pandas.Period</font></h3><p>固定时期（period）表示的是时间区间，比如数日、数月、数季、数年等。Period 类所表示的就是这种数据类型，其构造函数需要用到一个字符串或整数。</p><p>基本语法：</p><pre><code class="python">class pandas.Period(value=None, freq=None, ordinal=None,                     year=None, month=None, quarter=None,                     day=None, hour=None, minute=None, second=None)</code></pre><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Period.html">https://pandas.pydata.org/docs/reference/api/pandas.Period.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>时间段</td></tr><tr><td>freq</td><td>时间戳将具有的偏移量，可以是 str，日期偏移量类型，取值参见<a href="#t4">【02x02】freq 频率部分取值</a></td></tr></tbody></table><p>以下示例中，Period 对象表示的是从2020年1月1日到2020年12月31日之间的整段时间</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Period(2020, freq=&#39;A-DEC&#39;)Period(&#39;2020&#39;, &#39;A-DEC&#39;)</code></pre><p>利用加减法对其按照频率进行位移：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Period(2020, freq=&#39;A-DEC&#39;)&gt;&gt;&gt; objPeriod(&#39;2020&#39;, &#39;A-DEC&#39;)&gt;&gt;&gt; &gt;&gt;&gt; obj + 5Period(&#39;2025&#39;, &#39;A-DEC&#39;)&gt;&gt;&gt; &gt;&gt;&gt; obj - 5Period(&#39;2015&#39;, &#39;A-DEC&#39;)</code></pre><p>PeriodIndex 类保存了一组 Period，它可以在任何 pandas 数据结构中被用作轴索引：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; rng = [pd.Period(&#39;2000-01&#39;), pd.Period(&#39;2000-02&#39;), pd.Period(&#39;2000-03&#39;),            pd.Period(&#39;2000-04&#39;), pd.Period(&#39;2000-05&#39;), pd.Period(&#39;2000-06&#39;)]&gt;&gt;&gt; obj = pd.Series(np.random.randn(6), index=rng)&gt;&gt;&gt; obj2000-01    0.2290922000-02    1.5154982000-03   -0.3344012000-04   -0.4926812000-05   -2.0128182000-06    0.338804Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.indexPeriodIndex([&#39;2000-01&#39;, &#39;2000-02&#39;, &#39;2000-03&#39;, &#39;2000-04&#39;, &#39;2000-05&#39;, &#39;2000-06&#39;], dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)</code></pre><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; values = [&#39;2001Q3&#39;, &#39;2002Q2&#39;, &#39;2003Q1&#39;]&gt;&gt;&gt; index = pd.PeriodIndex(values, freq=&#39;Q-DEC&#39;)&gt;&gt;&gt; indexPeriodIndex([&#39;2001Q3&#39;, &#39;2002Q2&#39;, &#39;2003Q1&#39;], dtype=&#39;period[Q-DEC]&#39;, freq=&#39;Q-DEC&#39;)&gt;&gt;&gt; </code></pre><h3 id="【03x02】period-range"><a href="#【03x02】period-range" class="headerlink" title="【03x02】period_range"></a><font color=#4876FF>【03x02】period_range</font></h3><p><code>pandas.period_range</code> 方法可根据指定的频率生成指定长度的 PeriodIndex。</p><p>基本语法：</p><p><code>pandas.period_range(start=None, end=None, periods=None, freq=None, name=None) → pandas.core.indexes.period.PeriodIndex</code></p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.period_range.html">https://pandas.pydata.org/docs/reference/api/pandas.period_range.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>起始日期</td></tr><tr><td>end</td><td>结束日期</td></tr><tr><td>periods</td><td>要生成的时段数</td></tr><tr><td>freq</td><td>时间戳将具有的偏移量，可以是 str，日期偏移量类型，取值参见<a href="#t4">【02x02】freq 频率部分取值</a></td></tr><tr><td>name</td><td>结果 PeriodIndex 对象名称</td></tr></tbody></table><p>简单应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.period_range(start=&#39;2019-01-01&#39;, end=&#39;2020-01-01&#39;, freq=&#39;M&#39;)PeriodIndex([&#39;2019-01&#39;, &#39;2019-02&#39;, &#39;2019-03&#39;, &#39;2019-04&#39;, &#39;2019-05&#39;, &#39;2019-06&#39;,             &#39;2019-07&#39;, &#39;2019-08&#39;, &#39;2019-09&#39;, &#39;2019-10&#39;, &#39;2019-11&#39;, &#39;2019-12&#39;,             &#39;2020-01&#39;],            dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)&gt;&gt;&gt;&gt;&gt;&gt; pd.period_range(start=pd.Period(&#39;2017Q1&#39;, freq=&#39;Q&#39;),                    end=pd.Period(&#39;2017Q2&#39;, freq=&#39;Q&#39;), freq=&#39;M&#39;)PeriodIndex([&#39;2017-03&#39;, &#39;2017-04&#39;, &#39;2017-05&#39;, &#39;2017-06&#39;], dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)</code></pre><h3 id="【03x03】asfreq-时期频率转换"><a href="#【03x03】asfreq-时期频率转换" class="headerlink" title="【03x03】asfreq 时期频率转换"></a><font color=#4876FF>【03x03】asfreq 时期频率转换</font></h3><p>Period 和 PeriodIndex 对象都可以通过 asfreq 方法被转换成别的频率。</p><p>基本语法：<code>PeriodIndex.asfreq(self, *args, **kwargs)</code></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>freq</td><td>新的频率（偏移量），取值参见<a href="#t4">【02x02】freq 频率部分取值</a></td></tr><tr><td>how</td><td>按照开始或者结束对齐，<code>&#39;E&#39;</code> or <code>&#39;END&#39;</code> or <code>&#39;FINISH&#39;</code>；<code>&#39;S&#39;</code> or <code>&#39;START&#39;</code> or <code>&#39;BEGIN&#39;</code></td></tr></tbody></table><p>应用示例：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pidx = pd.period_range(&#39;2010-01-01&#39;, &#39;2015-01-01&#39;, freq=&#39;A&#39;)&gt;&gt;&gt; pidxPeriodIndex([&#39;2010&#39;, &#39;2011&#39;, &#39;2012&#39;, &#39;2013&#39;, &#39;2014&#39;, &#39;2015&#39;], dtype=&#39;period[A-DEC]&#39;, freq=&#39;A-DEC&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pidx.asfreq(&#39;M&#39;)PeriodIndex([&#39;2010-12&#39;, &#39;2011-12&#39;, &#39;2012-12&#39;, &#39;2013-12&#39;, &#39;2014-12&#39;, &#39;2015-12&#39;], dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pidx.asfreq(&#39;M&#39;, how=&#39;S&#39;)PeriodIndex([&#39;2010-01&#39;, &#39;2011-01&#39;, &#39;2012-01&#39;, &#39;2013-01&#39;, &#39;2014-01&#39;, &#39;2015-01&#39;], dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)</code></pre><h3 id="【03x04】to-period-与-to-timestamp"><a href="#【03x04】to-period-与-to-timestamp" class="headerlink" title="【03x04】to_period 与 to_timestamp()"></a><font color=#4876FF>【03x04】to_period 与 to_timestamp()</font></h3><p><code>to_period</code> 方法可以将 Timestamp（时间戳） 转换为 Period（固定时期）；</p><p><code>to_timestamp</code> 方法可以将 Period（固定时期）转换为 Timestamp（时间戳） 。</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; rng = pd.date_range(&#39;2000-01-01&#39;, periods=3, freq=&#39;M&#39;)&gt;&gt;&gt; ts = pd.Series(np.random.randn(3), index=rng)&gt;&gt;&gt; ts2000-01-31    0.2207592000-02-29   -0.1082212000-03-31    0.819433Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; pts = ts.to_period()&gt;&gt;&gt; pts2000-01    0.2207592000-02   -0.1082212000-03    0.819433Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; pts2 = pts.to_timestamp()&gt;&gt;&gt; pts22000-01-01    0.2207592000-02-01   -0.1082212000-03-01    0.819433Freq: MS, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; ts.indexDatetimeIndex([&#39;2000-01-31&#39;, &#39;2000-02-29&#39;, &#39;2000-03-31&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pts.indexPeriodIndex([&#39;2000-01&#39;, &#39;2000-02&#39;, &#39;2000-03&#39;], dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pts2.indexDatetimeIndex([&#39;2000-01-01&#39;, &#39;2000-02-01&#39;, &#39;2000-03-01&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;MS&#39;)</code></pre><h2 id="【04x00】timedelta-时间间隔"><a href="#【04x00】timedelta-时间间隔" class="headerlink" title="【04x00】timedelta 时间间隔"></a><font color=#FF0000>【04x00】timedelta 时间间隔</font></h2><h3 id="【04x01】pandas-Timedelta"><a href="#【04x01】pandas-Timedelta" class="headerlink" title="【04x01】pandas.Timedelta"></a><font color=#4876FF>【04x01】pandas.Timedelta</font></h3><p>Timedelta 表示持续时间，即两个日期或时间之间的差。</p><p>Timedelta 相当于 Python 的 datetime.timedelta，在大多数情况下两者可以互换。</p><p>基本语法：<code>class pandas.Timedelta(value=&lt;object object&gt;, unit=None, **kwargs)</code></p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Timedelta.html">https://pandas.pydata.org/docs/reference/api/pandas.Timedelta.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>传入的值，可以是 Timedelta，timedelta，np.timedelta64，string 或 integer 对象</td></tr><tr><td>unit</td><td>用于设置 value 的单位，具体取值参见官方文档</td></tr></tbody></table><p>表示两个 datetime 对象之间的时间差：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.to_datetime(&#39;2020-6-24&#39;) - pd.to_datetime(&#39;2016-1-1&#39;)Timedelta(&#39;1636 days 00:00:00&#39;)</code></pre><p>通过字符串传递参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Timedelta(&#39;3 days 3 hours 3 minutes 30 seconds&#39;)Timedelta(&#39;3 days 03:03:30&#39;)</code></pre><p>通过整数传递参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Timedelta(5,unit=&#39;h&#39;)Timedelta(&#39;0 days 05:00:00&#39;)</code></pre><p>获取属性：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Timedelta(&#39;3 days 3 hours 3 minutes 30 seconds&#39;)&gt;&gt;&gt; objTimedelta(&#39;3 days 03:03:30&#39;)&gt;&gt;&gt; &gt;&gt;&gt; obj.days3&gt;&gt;&gt; obj.seconds11010</code></pre><h3 id="【04x02】to-timedelta"><a href="#【04x02】to-timedelta" class="headerlink" title="【04x02】to_timedelta"></a><font color=#4876FF>【04x02】to_timedelta</font></h3><p>to_timedelta 方法可以将传入的对象转换成 timedelta 对象。</p><p>基本语法：<code>pandas.to_timedelta(arg, unit=&#39;ns&#39;, errors=&#39;raise&#39;)</code></p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.to_timedelta.html">https://pandas.pydata.org/docs/reference/api/pandas.to_timedelta.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>arg</td><td>要转换为 timedelta 的对象，可以是 str，timedelta，list-like 或 Series 对象</td></tr><tr><td>unit</td><td>用于设置 arg 的单位，具体取值参见官方文档</td></tr><tr><td>errors</td><td>如果 arg 不满足时间戳的形式，是否会发生异常<br><code>ignore</code>：不引发异常，返回原始输入；<code>raise</code>：无效解析将引发异常（默认）；<code>coerce</code>：无效解析将被设置为NaT</td></tr></tbody></table><p>将单个字符串解析为 timedelta 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.to_timedelta(&#39;1 days 06:05:01.00003&#39;)Timedelta(&#39;1 days 06:05:01.000030&#39;)&gt;&gt;&gt;&gt;&gt;&gt; pd.to_timedelta(&#39;15.5us&#39;)Timedelta(&#39;0 days 00:00:00.000015&#39;)</code></pre><p>将字符串列表或数组解析为  timedelta 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.to_timedelta([&#39;1 days 06:05:01.00003&#39;, &#39;15.5us&#39;, &#39;nan&#39;])TimedeltaIndex([&#39;1 days 06:05:01.000030&#39;, &#39;0 days 00:00:00.000015&#39;, NaT], dtype=&#39;timedelta64[ns]&#39;, freq=None)</code></pre><p>指定 <code>unit</code> 参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.to_timedelta(np.arange(5), unit=&#39;s&#39;)TimedeltaIndex([&#39;00:00:00&#39;, &#39;00:00:01&#39;, &#39;00:00:02&#39;, &#39;00:00:03&#39;, &#39;00:00:04&#39;], dtype=&#39;timedelta64[ns]&#39;, freq=None)&gt;&gt;&gt; &gt;&gt;&gt; pd.to_timedelta(np.arange(5), unit=&#39;d&#39;)TimedeltaIndex([&#39;0 days&#39;, &#39;1 days&#39;, &#39;2 days&#39;, &#39;3 days&#39;, &#39;4 days&#39;], dtype=&#39;timedelta64[ns]&#39;, freq=None)</code></pre><h3 id="【04x03】timedelta-range"><a href="#【04x03】timedelta-range" class="headerlink" title="【04x03】timedelta_range"></a><font color=#4876FF>【04x03】timedelta_range</font></h3><p><code>timedelta_range</code> 方法可根据指定的频率生成指定长度的 TimedeltaIndex。</p><p>基本语法：</p><pre><code class="python">pandas.timedelta_range(start=None, end=None, periods=None,                       freq=None, name=None, closed=None) → pandas.core.indexes.timedeltas.TimedeltaIndex</code></pre><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.timedelta_range.html">https://pandas.pydata.org/docs/reference/api/pandas.timedelta_range.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>开始日期</td></tr><tr><td>end</td><td>结束日期</td></tr><tr><td>periods</td><td>int 类型，要生成的时段数</td></tr><tr><td>freq</td><td>频率字符串，即按照某种特定的频率来生成日期，取值参见<a href="#t4">【02x02】freq 频率部分取值</a></td></tr><tr><td>name</td><td>结果 TimedeltaIndex 的名称</td></tr><tr><td>closed</td><td><code>None</code>：默认值，同时保留开始日期和结束日期<br><code>&#39;left&#39;</code>：保留开始日期，不保留结束日期<br><code>&#39;right&#39;</code>：保留结束日期，不保留开始日期</td></tr></tbody></table><p>应用示例：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.timedelta_range(start=&#39;1 day&#39;, periods=4)TimedeltaIndex([&#39;1 days&#39;, &#39;2 days&#39;, &#39;3 days&#39;, &#39;4 days&#39;], dtype=&#39;timedelta64[ns]&#39;, freq=&#39;D&#39;)</code></pre><p>closed 参数指定保留哪个端点。默认保留两个端点：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.timedelta_range(start=&#39;1 day&#39;, periods=4, closed=&#39;right&#39;)TimedeltaIndex([&#39;2 days&#39;, &#39;3 days&#39;, &#39;4 days&#39;], dtype=&#39;timedelta64[ns]&#39;, freq=&#39;D&#39;)</code></pre><p>freq 参数指定 TimedeltaIndex 的频率。只接受固定频率，非固定频率如 <code>&#39;M&#39;</code> 将会报错：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.timedelta_range(start=&#39;1 day&#39;, end=&#39;2 days&#39;, freq=&#39;6H&#39;)TimedeltaIndex([&#39;1 days 00:00:00&#39;, &#39;1 days 06:00:00&#39;, &#39;1 days 12:00:00&#39;,                &#39;1 days 18:00:00&#39;, &#39;2 days 00:00:00&#39;],               dtype=&#39;timedelta64[ns]&#39;, freq=&#39;6H&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.timedelta_range(start=&#39;1 day&#39;, end=&#39;2 days&#39;, freq=&#39;M&#39;)Traceback (most recent call last):...ValueError: &lt;MonthEnd&gt; is a non-fixed frequency</code></pre><h2 id="【05x00】重采样及频率转换"><a href="#【05x00】重采样及频率转换" class="headerlink" title="【05x00】重采样及频率转换"></a><font color=#FF0000>【05x00】重采样及频率转换</font></h2><p>重采样（resampling）指的是将时间序列从一个频率转换到另一个频率的处理过程。将高频率数据聚合到低频率称为降采样（downsampling），而将低频率数据转换到高频率则称为升采样（upsampling）。并不是所有的重采样都能被划分到这两个大类中。例如，将 W-WED（每周三）转换为 W-FRI 既不是降采样也不是升采样。</p><p>Pandas 中提供了 resample 方法来帮助我们实现重采样。Pandas 对象都带有一个 resample 方法，它是各种频率转换工作的主力函数。</p><p>基本语法：</p><pre><code class="python">Series.resample(self, rule, axis=0,                 closed: Union[str, NoneType] = None,                 label: Union[str, NoneType] = None,                 convention: str = &#39;start&#39;,                 kind: Union[str, NoneType] = None,                 loffset=None, base: int = 0,                 on=None, level=None)</code></pre><pre><code class="python">DataFrame.resample(self, rule, axis=0,                    closed: Union[str, NoneType] = None,                    label: Union[str, NoneType] = None,                    convention: str = &#39;start&#39;,                    kind: Union[str, NoneType] = None,                    loffset=None, base: int = 0,                    on=None, level=None)</code></pre><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>rule</td><td></td></tr><tr><td>axis</td><td>重采样的轴，默认 0</td></tr><tr><td>closed</td><td>在重采样中，各时间段的哪一端是闭合（即包含）的，<br>除 <code>&#39;M&#39;</code>、<code>&#39;A&#39;</code>、<code>&#39;Q&#39;</code>、<code>&#39;BM&#39;</code>、<code>&#39;BA&#39;</code>、<code>&#39;BQ&#39;</code> 和 <code>&#39;W&#39;</code> 默认值为 ‘right’ 外，其他默认值为 ‘left‘</td></tr><tr><td>label</td><td>在重采样中，如何设置聚合值的标签， right 或 left，默认为 None，<br>例如，9:30 到 9:35 之间的这 5 分钟会被标记为 9:30 或 9:35</td></tr><tr><td>convention</td><td>仅用于 PeriodIndex（固定时期），对周期进行重采样，<code>&#39;start&#39;</code> or <code>&#39;s&#39;</code>，<code>&#39;end&#39;</code> or <code>&#39;e&#39;</code></td></tr><tr><td>on</td><td>对于 DataFrame 对象，可用该参数指定重采样后的数据的 index（行索引） 为原数据中的某列</td></tr><tr><td>level</td><td>对于具有层级索引（MultiIndex）的 DataFrame 对象，可以使用该参数来指定需要在哪个级别上进行重新采样</td></tr></tbody></table><p>将序列重采样到三分钟的频率，并将每个频率的值相加：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; series.resample(&#39;3T&#39;).sum()2000-01-01 00:00:00     32000-01-01 00:03:00    122000-01-01 00:06:00    21Freq: 3T, dtype: int64</code></pre><p>设置 <code>label=&#39;right&#39;</code>，即每个索引 index 会使用靠右侧（较大值）的标签：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; series.resample(&#39;3T&#39;, label=&#39;right&#39;).sum()2000-01-01 00:03:00     32000-01-01 00:06:00    122000-01-01 00:09:00    21Freq: 3T, dtype: int64</code></pre><p>设置 <code>closed=&#39;right&#39;</code>，即结果中会包含原数据中最右侧（较大）的值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; series.resample(&#39;3T&#39;, label=&#39;right&#39;, closed=&#39;right&#39;).sum()2000-01-01 00:00:00     02000-01-01 00:03:00     62000-01-01 00:06:00    152000-01-01 00:09:00    15Freq: 3T, dtype: int64</code></pre><p>以下示例将序列重采样到30秒的频率，<code>asfreq()[0:5]</code> 用于选择前5行数据：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; series.resample(&#39;30S&#39;).asfreq()[0:5]2000-01-01 00:00:00    0.02000-01-01 00:00:30    NaN2000-01-01 00:01:00    1.02000-01-01 00:01:30    NaN2000-01-01 00:02:00    2.0Freq: 30S, dtype: float64</code></pre><p>使用 <code>pad</code> 方法向后填充缺失值（NaN）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; series.resample(&#39;30S&#39;).pad()[0:5]2000-01-01 00:00:00    02000-01-01 00:00:30    02000-01-01 00:01:00    12000-01-01 00:01:30    12000-01-01 00:02:00    2Freq: 30S, dtype: int64</code></pre><p>使用 <code>bfill</code> 方法向前填充缺失值（NaN）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; series.resample(&#39;30S&#39;).bfill()[0:5]2000-01-01 00:00:00    02000-01-01 00:00:30    12000-01-01 00:01:00    12000-01-01 00:01:30    22000-01-01 00:02:00    2Freq: 30S, dtype: int64</code></pre><p>通过 <code>apply</code> 方法传递自定义函数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; def custom_resampler(array_like):    return np.sum(array_like) + 5&gt;&gt;&gt; series.resample(&#39;3T&#39;).apply(custom_resampler)2000-01-01 00:00:00     82000-01-01 00:03:00    172000-01-01 00:06:00    26Freq: 3T, dtype: int64</code></pre><p>convention 参数的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; s = pd.Series([1, 2], index=pd.period_range(&#39;2012-01-01&#39;, freq=&#39;A&#39;, periods=2))&gt;&gt;&gt; s2012    12013    2Freq: A-DEC, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; s.resample(&#39;Q&#39;, convention=&#39;start&#39;).asfreq()2012Q1    1.02012Q2    NaN2012Q3    NaN2012Q4    NaN2013Q1    2.02013Q2    NaN2013Q3    NaN2013Q4    NaNFreq: Q-DEC, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; s.resample(&#39;Q&#39;, convention=&#39;end&#39;).asfreq()2012Q4    1.02013Q1    NaN2013Q2    NaN2013Q3    NaN2013Q4    2.0Freq: Q-DEC, dtype: float64</code></pre><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; q = pd.Series([1, 2, 3, 4], index=pd.period_range(&#39;2018-01-01&#39;, freq=&#39;Q&#39;, periods=4))&gt;&gt;&gt; q2018Q1    12018Q2    22018Q3    32018Q4    4Freq: Q-DEC, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; q.resample(&#39;M&#39;, convention=&#39;end&#39;).asfreq()2018-03    1.02018-04    NaN2018-05    NaN2018-06    2.02018-07    NaN2018-08    NaN2018-09    3.02018-10    NaN2018-11    NaN2018-12    4.0Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; q.resample(&#39;M&#39;, convention=&#39;start&#39;).asfreq()2018-01    1.02018-02    NaN2018-03    NaN2018-04    2.02018-05    NaN2018-06    NaN2018-07    3.02018-08    NaN2018-09    NaN2018-10    4.02018-11    NaN2018-12    NaNFreq: M, dtype: float64</code></pre><p>对于 DataFrame 对象，可以使用关键字 on 来指定原数据中的某列为重采样后数据的行索引：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; d = dict(&#123;&#39;price&#39;: [10, 11, 9, 13, 14, 18, 17, 19],                &#39;volume&#39;: [50, 60, 40, 100, 50, 100, 40, 50]&#125;)&gt;&gt;&gt; df = pd.DataFrame(d)&gt;&gt;&gt; df[&#39;week_starting&#39;] = pd.date_range(&#39;01/01/2018&#39;, periods=8, freq=&#39;W&#39;)&gt;&gt;&gt; df   price  volume week_starting0     10      50    2018-01-071     11      60    2018-01-142      9      40    2018-01-213     13     100    2018-01-284     14      50    2018-02-045     18     100    2018-02-116     17      40    2018-02-187     19      50    2018-02-25&gt;&gt;&gt; &gt;&gt;&gt; df.resample(&#39;M&#39;, on=&#39;week_starting&#39;).mean()               price  volumeweek_starting               2018-01-31     10.75    62.52018-02-28     17.00    60.0</code></pre><p>对于具有层级索引（MultiIndex）的 DataFrame 对象，可以使用关键字 <code>level</code> 来指定需要在哪个级别上进行重新采样：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; days = pd.date_range(&#39;1/1/2000&#39;, periods=4, freq=&#39;D&#39;)&gt;&gt;&gt; d2 = dict(&#123;&#39;price&#39;: [10, 11, 9, 13, 14, 18, 17, 19],                  &#39;volume&#39;: [50, 60, 40, 100, 50, 100, 40, 50]&#125;)&gt;&gt;&gt; df2 = pd.DataFrame(d2, index=pd.MultiIndex.from_product([days, [&#39;morning&#39;, &#39;afternoon&#39;]]))&gt;&gt;&gt; df2                      price  volume2000-01-01 morning       10      50           afternoon     11      602000-01-02 morning        9      40           afternoon     13     1002000-01-03 morning       14      50           afternoon     18     1002000-01-04 morning       17      40           afternoon     19      50&gt;&gt;&gt; &gt;&gt;&gt; df2.resample(&#39;D&#39;, level=0).sum()            price  volume2000-01-01     21     1102000-01-02     22     1402000-01-03     32     1502000-01-04     36      90</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106947061未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Pandas 系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itbob.cn/article/025/&quot;&gt;Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象&lt;/a&gt;&lt;/li&gt;</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.itbob.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
    <category term="数据分析" scheme="https://www.itbob.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="Pandas" scheme="https://www.itbob.cn/tags/Pandas/"/>
    
  </entry>
  
</feed>
