<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BOB&#39;S BLOG</title>
  
  <subtitle>一入 IT 深似海 从此学习无绝期</subtitle>
  <link href="https://www.itbob.cn/atom.xml" rel="self"/>
  
  <link href="https://www.itbob.cn/"/>
  <updated>2022-11-26T08:52:00.000Z</updated>
  <id>https://www.itbob.cn/</id>
  
  <author>
    <name>BOB</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>某片行为验证，滑动验证码和点选验证码逆向分析</title>
    <link href="https://www.itbob.cn/article/058/"/>
    <id>https://www.itbob.cn/article/058/</id>
    <published>2022-11-26T08:51:00.000Z</published>
    <updated>2022-11-26T08:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><h2 id="声明">声明</h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2 id="逆向目标">逆向目标</h2><ul><li>目标：某片的滑动验证码和点选验证码逆向</li><li>主页：<code>aHR0cHM6Ly93d3cueXVucGlhbi5jb20vcHJvZHVjdC9jYXB0Y2hh</code></li></ul><p><img src="https://cdn.itbob.cn/img/article/058/01.png" alt="01"></p><h2 id="抓包分析">抓包分析</h2><p>验证码图片获取接口，GET 请求，包含四个参数：<code>cb</code>、<code>i</code>、<code>k</code>、<code>captchaId</code>，有时候可能也会有 <code>token</code> 参数，那是因为不是第一次加载图片，比如刷新图片，会将之前接口的 <code>token</code> 值带上。</p><p><img src="https://cdn.itbob.cn/img/article/058/02.png" alt="02"></p><p>接口返回，如果是滑动验证码，则 <code>bg</code> 是背景图，<code>front</code> 是滑块图，还有个 <code>token</code> 值后续会用到。</p><p><img src="https://cdn.itbob.cn/img/article/058/03.png" alt="03"></p><p>如果是点选验证码，则 <code>captchaImage</code> 是底图，<code>wordsImage</code> 是需要点击的文字，同样的有个 <code>token</code> 值后续会用到。</p><p><img src="https://cdn.itbob.cn/img/article/058/04.png" alt="04"></p><p>验证接口，包含五个参数：<code>cb</code>、<code>i</code>、<code>k</code>、<code>token</code>、<code>captchaId</code>，其中 <code>token</code> 就是获取验证码接口返回的。</p><p><img src="https://cdn.itbob.cn/img/article/058/05.png" alt="05"></p><p><img src="https://cdn.itbob.cn/img/article/058/06.png" alt="06"></p><h2 id="逆向分析">逆向分析</h2><h3 id="图片接口">图片接口</h3><p>先来看看获取验证码图片的接口，全局搜索关键字 <code>captchaId</code> 即可定位到 key 为 <code>jsonpRequest</code> 的地方，下图中的 <code>t</code> 就是完整的接口 URL 了：</p><p><img src="https://cdn.itbob.cn/img/article/058/07.png" alt="07"></p><p>往上挨个找，先看看 <code>captchaId</code>，其实就是 <code>this.APP_ID</code>，多次刷新你会发现，对于滑块来讲，是定值 <code>974cd565f11545b6a5006d10dc324281</code>，对于点选来讲，是定值 <code>e1e7be036f9242c7aed023438af66f46</code>，这两个值在一个 JS 里是写死的，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/058/08.png" alt="08"></p><p><img src="https://cdn.itbob.cn/img/article/058/09.png" alt="09"></p><p>再往上看，<code>HOSTS</code> 啥的是定值就不用说了，<code>cb</code> 就是 <code>r</code>，<code>i</code> 就是 <code>a.i</code>，<code>k</code> 就是 <code>a.k</code>，通过 <code>concat()</code> 方法连接起来，所以只需要搞定 <code>r</code> 和 <code>a</code> 的值就行了，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/058/10.png" alt="10"></p><p><code>a</code> 的值是通过 <code>encrypt(e)</code> 得到的，<code>e</code> 里面有 <code>fp</code>、<code>address</code>、<code>yp_riddler_id</code> 等值，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/058/11.png" alt="11"></p><p>先看看这个 <code>encrypt</code> 方法，最终返回的是 <code>i</code> 和 <code>k</code>，瞧瞧这熟悉的 <code>iv</code>、<code>parse</code>，一看就是 AES、DES 之类的，试一下就知道了，或者跟进 <code>lt.a.encrypt()</code> 看看他的源码，对比一下标准算法里的源码，就可以发现是 AES，<code>k</code> 就很明显了，RSA 加密，公钥啥的一搜就有。</p><p><img src="https://cdn.itbob.cn/img/article/058/12.png" alt="12"></p><p>然后往上有个 <code>yp_riddler_id</code>，貌似是从 cookie 中拿的，直接搜索这个关键字，可以找到其设置值的地方，就是一个 UUID，其中有个 <code>window.performance.now()</code> 方法，其作用是返回一个当前页面执行的时间的时间戳，用来精确计算程序执行时间，在 node 实现方法如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> perf = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;perf_hooks&#x27;</span>);performance = perf.performance.now()<span class="hljs-built_in">console</span>.log(performance);</code></pre><p><img src="https://cdn.itbob.cn/img/article/058/13.png" alt="13"></p><p><img src="https://cdn.itbob.cn/img/article/058/14.png" alt="14"></p><p>然后再往上有个 <code>e.fp = this.fingerprint</code>，这里用到的应该是一个指纹库：<a href="https://github.com/fingerprintjs/fingerprintjs">https://github.com/fingerprintjs/fingerprintjs</a> ，感兴趣的可以了解一下，同一个浏览器得到的指纹是一样的，这里固定即可。</p><p><img src="https://cdn.itbob.cn/img/article/058/15.png" alt="15"></p><p>然后就是 <code>r</code> 的值，<code>preAdd</code> 方法，直接扣就行了</p><p><img src="https://cdn.itbob.cn/img/article/058/16.png" alt="16"></p><p><img src="https://cdn.itbob.cn/img/article/058/17.png" alt="17"></p><p>然后这个 <code>e</code> 的值，再传到 <code>jsonpRequest</code> 之前就已经有一些值了，所以我们还得往前跟栈看看：</p><p><img src="https://cdn.itbob.cn/img/article/058/18.png" alt="18"></p><p>来到 <code>getCaptcha</code> 这里，没啥特别的，扣就完事儿了，其中有个 <code>browserInfo</code> 是浏览器的一些东西，copy 下来就行了。</p><p><img src="https://cdn.itbob.cn/img/article/058/19.png" alt="19"></p><h3 id="验证接口">验证接口</h3><p>验证接口最后也是走的 <code>jsonpRequest</code>，和前面的获取图片接口类似，不同之处就是传入的 <code>e</code> 里面包含的值不一样，先来看看滑块：</p><p><img src="https://cdn.itbob.cn/img/article/058/20.png" alt="20"></p><p>包含 <code>distanceX</code> 和 <code>points</code>，很明显 <code>points</code> 就是轨迹了，再往前跟看看，如下图所示，我们只需要 <code>i</code> 和 <code>r</code> 参数就行了，参数是一些图片高宽，固定就行，<code>offsetX</code> 是滑动的距离。</p><p><img src="https://cdn.itbob.cn/img/article/058/21.png" alt="21"></p><p>主要看看这个轨迹 <code>i = this.reducePoints()</code>，跟进 <code>reducePoints()</code> 方法里，<code>this.position</code> 是轨迹信息，这个方法对轨迹做了一些处理再返回的，直接把逻辑扣下来即可。</p><p><img src="https://cdn.itbob.cn/img/article/058/22.png" alt="22"></p><p>滑块就到这儿了，再来看看点选验证，同样的还是 <code>jsonpRequest</code>，传入的 <code>e</code> 包含了三个点的坐标。</p><p><img src="https://cdn.itbob.cn/img/article/058/23.png" alt="23"></p><p>同样往上跟栈，这里的 <code>this.position</code> 才是真实坐标，后面每个坐标分别对 x 和 y 与图片的宽和高进行相除，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/058/24.png" alt="24"></p><h2 id="结果验证">结果验证</h2><p><img src="https://cdn.itbob.cn/img/article/058/25.png" alt="25"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;red&quot;</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>安某客滑动验证码逆向分析</title>
    <link href="https://www.itbob.cn/article/057/"/>
    <id>https://www.itbob.cn/article/057/</id>
    <published>2022-11-08T09:35:00.000Z</published>
    <updated>2022-11-26T08:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><h2 id="声明">声明</h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2 id="逆向目标">逆向目标</h2><ul><li>目标：安某客滑动验证码逆向分析</li><li>主页：<code>aHR0cHM6Ly93d3cuYW5qdWtlLmNvbS9jYXB0Y2hhLXZlcmlmeS8/Y2FsbGJhY2s9c2hpZWxkJmZyb209YW50aXNwYW0=</code></li></ul><p><img src="https://cdn.itbob.cn/img/article/057/01.png" alt="01"></p><h2 id="抓包分析">抓包分析</h2><p>首页请求，有个初始化函数，其中有个 <code>sessionId</code> 后续会用到。</p><p><img src="https://cdn.itbob.cn/img/article/057/02.png" alt="02"></p><p>然后有个 <code>getInfoTp</code> 的请求，<code>Form Data</code> 里有个 <code>dInfo</code> 是加密参数，返回值里 <code>info</code> 也是加密的，包含了图片信息，返回值 <code>responseId</code> 在后续的请求也会用到。</p><p><img src="https://cdn.itbob.cn/img/article/057/03.png" alt="03"></p><p>滑动之后，有个 <code>checkInfoTp</code> 请求，<code>Form Data</code> 里有个 <code>data</code> 是加密参数，包含了轨迹信息，返回值 <code>message</code> 可以看到是否校验成功。</p><p><img src="https://cdn.itbob.cn/img/article/057/04.png" alt="04"></p><p>整体流程就是：请求首页获取 <code>sessionId</code>，请求 <code>getInfoTp</code> 获取图片信息和 <code>responseId</code>，请求 <code>checkInfoTp</code> 校验是否成功，中间涉及到 <code>dInfo</code> 和 <code>data</code> 两个加密参数，以及 <code>getInfoTp</code> 返回得到的 <code>info</code> 的解密。</p><h2 id="dInfo-生成">dInfo 生成</h2><p>先来看 <code>getInfoTp</code> 请求的 <code>dInfo</code> 参数，直接搜索可定位，刷新断下，大致就可以看出是 AES 加密，传入了 <code>sessionId</code> 和一个 <code>_taN()</code> 函数的返回值：</p><p><img src="https://cdn.itbob.cn/img/article/057/05.png" alt="05"></p><p><code>_taN()</code> 函数是一些 URL，UA 之类的信息，可以写死：</p><p><img src="https://cdn.itbob.cn/img/article/057/06.png" alt="06"></p><p>往里跟就可以看到 AES 算法了：</p><p><img src="https://cdn.itbob.cn/img/article/057/07.png" alt="07"></p><p>这里简简单单扣一下，JavaScript 代码如下：</p><pre><code class="hljs javascript"><span class="hljs-comment">/* ==================================</span><span class="hljs-comment"># @Time    : 2021-12-14</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: ajk.js</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ================================== */</span><span class="hljs-keyword">var</span> CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto-js&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AESEncrypt</span>(<span class="hljs-params">_cRV, _2undefinedp</span>) </span>&#123;    _2undefinedp = _2undefinedp.split(<span class="hljs-string">&quot;&quot;</span>).reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_PUi, _JrX, _JP9</span>) </span>&#123;        <span class="hljs-keyword">return</span> _JP9 % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? _PUi + <span class="hljs-string">&quot;&quot;</span> : _PUi + _JrX;    &#125;, <span class="hljs-string">&quot;&quot;</span>);    _2undefinedp = CryptoJS.enc.Utf8.parse(_2undefinedp);    _cRV = <span class="hljs-string">&quot;string&quot;</span> == <span class="hljs-keyword">typeof</span> _cRV ? _cRV : <span class="hljs-built_in">JSON</span>.stringify(_cRV);    _cRV = CryptoJS.AES.encrypt(_cRV, _2undefinedp, &#123;        <span class="hljs-attr">iv</span>: _2undefinedp,        <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,        <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7    &#125;);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">encodeURIComponent</span>(_cRV.toString())&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">u</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> &#123;        <span class="hljs-string">&quot;sdkv&quot;</span>: <span class="hljs-string">&quot;3.0.1&quot;</span>,        <span class="hljs-string">&quot;busurl&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com/captcha-verify/?callback=shield&amp;from=antispam&quot;</span>,        <span class="hljs-string">&quot;useragent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36&quot;</span>,        <span class="hljs-string">&quot;clienttype&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDInfo</span>(<span class="hljs-params">sessionId</span>)</span>&#123;    <span class="hljs-keyword">return</span> AESEncrypt(u(), sessionId)&#125;<span class="hljs-comment">// 测试样例</span><span class="hljs-keyword">var</span> sessionId = <span class="hljs-string">&quot;a8b339ec0c26459598786fee1cce8dc2&quot;</span><span class="hljs-built_in">console</span>.log(getDInfo(sessionId))</code></pre><p>这段逻辑也可以用 Python 来实现，关键代码如下（脱敏处理，不能直接运行）：</p><pre><code class="hljs python"><span class="hljs-comment"># ==================================</span><span class="hljs-comment"># --*-- coding: utf-8 --*--</span><span class="hljs-comment"># @Time    : 2021-12-14</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: ajk.py</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ==================================</span><span class="hljs-keyword">import</span> json<span class="hljs-keyword">import</span> base64<span class="hljs-keyword">import</span> requests<span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<span class="hljs-keyword">from</span> loguru <span class="hljs-keyword">import</span> logger<span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> quote_plus<span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<span class="hljs-keyword">from</span> Crypto.Util.Padding <span class="hljs-keyword">import</span> pad, unpad<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AESAlgorithm</span>:</span><span class="hljs-meta">    @staticmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encrypt</span>(<span class="hljs-params">aes_key_iv, text</span>):</span>        <span class="hljs-string">&quot;&quot;&quot; 对明文进行加密 &quot;&quot;&quot;</span>        cipher = AES.new(key=<span class="hljs-built_in">bytes</span>(aes_key_iv, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>), mode=AES.MODE_CBC, iv=<span class="hljs-built_in">bytes</span>(aes_key_iv, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>))        result = base64.b64encode(cipher.encrypt(pad(text.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), <span class="hljs-number">16</span>))).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)        result = quote_plus(result)        <span class="hljs-keyword">return</span> result<span class="hljs-meta">    @staticmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decrypt</span>(<span class="hljs-params">aes_key_iv, text</span>):</span>        <span class="hljs-string">&quot;&quot;&quot; 对密文进行解密 &quot;&quot;&quot;</span>        cipher = AES.new(key=<span class="hljs-built_in">bytes</span>(aes_key_iv, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>), mode=AES.MODE_CBC, iv=<span class="hljs-built_in">bytes</span>(aes_key_iv, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>))        result = unpad(cipher.decrypt(base64.b64decode(text)), <span class="hljs-number">16</span>).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)        <span class="hljs-keyword">return</span> result<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AJKSlide</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, index_url, user_agent</span>):</span>        self.aes = AESAlgorithm()        self.index_url = index_url        self.user_agent = user_agent        self.headers = &#123;<span class="hljs-string">&quot;user-agent&quot;</span>: self.user_agent&#125;    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_session_id</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot; 获取 sessionId &quot;&quot;&quot;</span>        response = requests.get(url=self.index_url, headers=self.headers).text        session_id = etree.HTML(response).xpath(<span class="hljs-string">&quot;//input[@name=&#x27;sessionId&#x27;]/@value&quot;</span>)[<span class="hljs-number">0</span>]        logger.info(<span class="hljs-string">f&quot;sessionId ==&gt; <span class="hljs-subst">&#123;session_id&#125;</span>&quot;</span>)        <span class="hljs-keyword">return</span> session_id<span class="hljs-meta">    @staticmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_aes_key_iv</span>(<span class="hljs-params">session_id</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;设置 AES key 和 iv&quot;&quot;&quot;</span>        aes_key_iv = <span class="hljs-string">&#x27;&#x27;</span>        <span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(session_id):            <span class="hljs-keyword">if</span> index % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:                aes_key_iv += value        logger.info(<span class="hljs-string">f&quot;处理 sessionId 获取 aes key iv ==&gt; <span class="hljs-subst">&#123;aes_key_iv&#125;</span>&quot;</span>)        <span class="hljs-keyword">return</span> aes_key_iv    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_d_info</span>(<span class="hljs-params">self, aes_key_iv</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;获取 dInfo&quot;&quot;&quot;</span>        sdk_info = &#123;            <span class="hljs-string">&quot;sdkv&quot;</span>: <span class="hljs-string">&quot;3.0.1&quot;</span>,            <span class="hljs-string">&quot;busurl&quot;</span>: self.index_url,            <span class="hljs-string">&quot;useragent&quot;</span>: self.user_agent,            <span class="hljs-string">&quot;clienttype&quot;</span>: <span class="hljs-number">1</span>        &#125;        d_info = self.aes.encrypt(aes_key_iv, json.dumps(sdk_info))        logger.info(<span class="hljs-string">f&#x27;dInfo ==&gt; <span class="hljs-subst">&#123;d_info&#125;</span>&#x27;</span>)        <span class="hljs-keyword">return</span> d_info    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, session_id=<span class="hljs-literal">None</span></span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> session_id:            session_id = self.get_session_id()        aes_key_iv = self.get_aes_key_iv(session_id)        self.get_d_info(aes_key_iv)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    UA = <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&quot;</span>    index_url_ = <span class="hljs-string">&quot;https://www.脱敏处理.com/captcha-verify/?callback=shield&amp;from=antispam&quot;</span>    ajk_slide = AJKSlide(index_url_, UA)    ajk_slide.run()</code></pre><h2 id="getInfoTp-解密">getInfoTp 解密</h2><p><code>getInfoTp</code> 这个接口返回的 <code>info</code> 的值是加密的，前面我们已经知道用到了 AES 加密算法，这里可以直接猜测也是用的的 AES 来解密的，找到 <code>AESDecrypt</code> 这个方法，下个断点，刷新发现断下之后传入了两个参数，第一个正是 <code>info</code> 的内容，第二个则是 <code>sessionId</code>。</p><p><img src="https://cdn.itbob.cn/img/article/057/08.png" alt="08"></p><p><img src="https://cdn.itbob.cn/img/article/057/09.png" alt="09"></p><p>解密结果可以看到滑块的图片地址等信息：</p><p><img src="https://cdn.itbob.cn/img/article/057/10.png" alt="10"></p><h2 id="data-生成">data 生成</h2><p>接下来就是 <code>checkInfoTp</code> 提交验证了，要搞清楚提交的 <code>data</code> 是什么东西，同样搜索打断点，如下图所示 <code>_5DD</code> 就是 <code>data</code> 值，传过来的。</p><p><img src="https://cdn.itbob.cn/img/article/057/11.png" alt="11"></p><p>往上跟栈，可以看到 <code>_Ug0</code> 里面有个 <code>track</code> 参数，这明显就是轨迹了，同样最后的结果经过了 AES 加密。</p><p><img src="https://cdn.itbob.cn/img/article/057/12.png" alt="12"></p><p>再往上跟，可以看到 <code>_Ug0</code> 由三个参数组成，<code>x</code> 是水平滑动的距离，<code>track</code> 是轨迹，<code>p</code> 是定值。</p><p><img src="https://cdn.itbob.cn/img/article/057/13.png" alt="13"></p><h2 id="轨迹处理">轨迹处理</h2><p>轨迹生成前，得先识别缺口得到要滑动的距离，方式有很多，比如 <code>OpenCV</code>、开源的 <code>ddddocr</code>，或者直接打码平台都行，这里唯一要注意的一点就是图片是有缩放的，原始尺寸 <code>480 × 270 px</code> 渲染后的尺寸 <code>280 × 158 px</code>，比例大概是 <code>1:0.5833333333333333</code>，可以先将图片进行缩放后再识别，也可以先识别距离后再将距离进行缩放。</p><p><img src="https://cdn.itbob.cn/img/article/057/14.png" alt="14"></p><p>轨迹的处理，该站点校验并不太严格，所以可以自己写一下，关于滑块的轨迹处理，主要有缩放法、本地轨迹库、根据一些函数来生成轨迹，如缓动函数、贝塞尔曲线等，以后再单独写一篇文章来介绍，本例中可以使用缩放法，先采集一条正常的，手动滑出来的轨迹，然后根据识别出的实际距离和样本轨迹中的距离相比，得到一个比值，然后将样本中的 x 值和时间值都做一个对应的缩放，生成新的轨迹，主要代码如下：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_track</span>(<span class="hljs-params">distance</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;生成轨迹，样本距离为 126&quot;&quot;&quot;</span>    ratio = distance / <span class="hljs-number">126</span>    new_track = <span class="hljs-string">&quot;&quot;</span>    base_track = <span class="hljs-string">&quot;29,11,0|29,11,11|29,11,26|33,11,56|34,11,66|36,11,67|39,11,76|41,11,83|43,11,86|46,11,92|49,11,98|50,11,102|52,11,106|53,11,111|55,11,116|57,11,118|59,11,123|60,11,126|62,11,132|64,12,134|65,12,138|66,12,142|68,12,148|69,12,151|70,13,155|71,13,158|72,13,164|74,13,166|75,13,170|76,14,174|77,14,180|79,14,182|81,14,186|82,14,196|84,14,198|86,14,207|87,15,212|89,15,219|90,15,223|92,15,230|93,15,234|94,15,239|95,15,243|98,15,246|100,15,250|102,15,260|105,15,262|106,15,266|108,15,270|109,16,276|111,16,278|113,16,283|115,16,286|117,16,291|118,16,294|119,16,298|121,16,302|123,16,309|124,16,311|125,16,315|126,16,319|129,16,324|130,16,327|131,16,331|132,16,334|132,16,388|132,16,522|133,16,566|134,16,574|135,16,575|136,16,594|137,16,620|138,16,625|139,16,652|140,16,657|141,17,676|141,18,680|142,18,684|143,18,688|144,18,716|145,18,724|146,18,796|147,19,828|148,19,860|149,19,888|149,19,890|150,19,916|151,20,932|152,20,936|152,20,1021|153,20,1150|154,20,1152|155,20,1236|155,20,1388|155,20,1522|155,20,1717|&quot;</span>    base_track = base_track.split(<span class="hljs-string">&quot;|&quot;</span>)[:-<span class="hljs-number">1</span>]    <span class="hljs-keyword">for</span> track <span class="hljs-keyword">in</span> base_track:        t = track.split(<span class="hljs-string">&quot;,&quot;</span>)        new_track += <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(<span class="hljs-built_in">int</span>(t[<span class="hljs-number">0</span>]) * ratio)) + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-built_in">str</span>(t[<span class="hljs-number">1</span>]) + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(<span class="hljs-built_in">int</span>(t[<span class="hljs-number">2</span>]) * ratio)) + <span class="hljs-string">&quot;|&quot;</span>        logger.info(<span class="hljs-string">f&quot;new_track ==&gt; <span class="hljs-subst">&#123;new_track&#125;</span>&quot;</span>)        <span class="hljs-keyword">return</span> new_track</code></pre><h2 id="结果验证">结果验证</h2><p>整个过程比较简单，验证成功。</p><p><img src="https://cdn.itbob.cn/img/article/057/15.png" alt="15"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;red&quot;</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>某音短视频 X-Bogus 逆向分析，JSVMP 纯算法还原</title>
    <link href="https://www.itbob.cn/article/056/"/>
    <id>https://www.itbob.cn/article/056/</id>
    <published>2022-10-16T11:00:00.000Z</published>
    <updated>2022-11-02T16:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/javascript_reverse.png" alt="javascript_reverse"></p><h2 id="声明">声明</h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2 id="逆向目标">逆向目标</h2><ul><li>目标：某音短视频网页端用户信息接口 X-Bogus 参数</li><li>接口：<code>aHR0cHM6Ly93d3cuZG91eWluLmNvbS9hd2VtZS92MS93ZWIvdXNlci9wcm9maWxlL290aGVyLw==</code></li></ul><h2 id="什么是-JSVMP？">什么是 JSVMP？</h2><p>JSVMP 全称 Virtual Machine based code Protection for JavaScript，即 JS 代码虚拟化保护方案。</p><p>JSVMP 的概念最早应该是由西北大学2015级硕士研究生匡开圆，在其2018年的学位论文中提出的，论文标题为：《基于 WebAssembly 的 JavaScript 代码虚拟化保护方法研究与实现》，同年还申请了国家专利，专利名称：《一种基于前端字节码技术的 JavaScript 虚拟化保护方法》，网上可以直接搜到，也可在公众号【K哥爬虫】后台回复 JSVMP，免费获取原版高清无水印的论文和专利。本文就简单介绍一下 JSVMP，想要详细了解，当然还是建议去读一下这篇论文。</p><p><img src="https://cdn.itbob.cn/img/article/056/01.png" alt="01"></p><p>JSVMP 的核心是在 JavaScript 代码保护过程中引入代码虚拟化思想，实现源代码的虚拟化过程，将目标代码转换成自定义的字节码，这些字节码只有特殊的解释器才能识别，隐藏目标代码的关键逻辑。在匡开圆的论文中，利用 WebAssembly 技术实现了特殊的虚拟解释器，通过编译隐藏解释器的执行逻辑。JSVMP 的保护流程如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/02.png" alt="02"></p><p>一个完整的 JSVMP 保护系统，大致的架构应该是这样子的：服务器端读取 JavaScript 代码 —&gt; 词法分析 —&gt; 语法分析 —&gt; 生成AST语法树 —&gt; 生成私有指令 —&gt; 生成对应私有解释器，将私有指令加密与私有解释器发送给浏览器，然后一边解释，一边执行。</p><p><img src="https://cdn.itbob.cn/img/article/056/03.png" alt="03"></p><h2 id="JSVMP-有哪些学习资料？">JSVMP 有哪些学习资料？</h2><p>除了匡开圆的论文以外，还有以下文章也值得学习：</p><ul><li><a href="https://mp.weixin.qq.com/s/YDx5Dr-HDfAm-sAqeWW0qg">H5应用加固防破解-js虚拟机保护方案浅谈</a></li><li><a href="https://blog.csdn.net/w2sft/article/details/120843310">JS加密？用虚拟机opcode保护JS源码</a></li><li><a href="https://bbs.pediy.com/thread-261414.htm">给&quot;某音&quot;的js虚拟机写一个编译器</a></li></ul><h2 id="JSVMP-逆向方法有哪些？">JSVMP 逆向方法有哪些？</h2><p>就目前来讲，JSVMP 的逆向方法有三种（自动化不算）：RPC 远程调用，补环境，日志断点还原算法，其中日志断点也称为插桩，找到关键位置，输出关键参数的日志信息，从结果往上倒推生成逻辑，以达到算法还原的目的，RPC 技术以前写过文章，补环境的方式以后有时间再写，本文主要介绍如何使用插桩来还原算法。</p><h2 id="抓包情况">抓包情况</h2><p>随便来到某个博主主页，抓包后搜索可发现一个接口，返回的是 JSON 数据，里面包含了博主某音号，认证信息、签名，关注、粉丝、获赞等，请求 <code>Query String Parameters</code> 里包含了一个 <code>X-Bogus</code> 参数，每次请求会改变，此外还有 <code>sec_user_id</code> 是博主主页 URL 后面那一串，<code>webid</code> 直接请求主页返回内容里就有，<code>msToken</code> 与 cookie 有关，清除 cookie 访问，就没这个参数了，实测该接口不验证 <code>webid</code> 和 <code>msToken</code>，直接置空即可。</p><p><img src="https://cdn.itbob.cn/img/article/056/04.png" alt="04"></p><p><img src="https://cdn.itbob.cn/img/article/056/05.png" alt="05"></p><h2 id="逆向分析">逆向分析</h2><p>这条请求是 XHR 请求，所以直接下个 XHR 断点，当 URL 中包含 <code>X-Bogus</code> 参数时就断下：</p><p><img src="https://cdn.itbob.cn/img/article/056/06.png" alt="06"></p><p><img src="https://cdn.itbob.cn/img/article/056/07.png" alt="07"></p><p>往前跟栈，来到一个叫 webmssdk.js 的 JS 文件，这里就是生成参数的主要 JS 逻辑了，也就是 JSVMP，整体上做了一个混淆，这里可以使用 AST 来解混淆，以前同样也写过 AST 的文章，这里还原混淆不是重点，咱们直接使用 V 佬的插件 <a href="https://github.com/cilame/v_jstools">v_jstools</a> 来还原：</p><p><img src="https://cdn.itbob.cn/img/article/056/08.png" alt="08"></p><p>还原后使用浏览器的 Overrides 替换功能将 webmssdk.js 替换掉，往上跟栈，如下图所示，到 W 这里就已经生成了 <code>X-Bogus</code> 了，<code>this.openArgs[1]</code> 就是携带了 <code>X-Bogus</code> 的完整 URL，仔细观察这段代码，有很多三元表达式，当 M 的值为 15 时，就会走到这段逻辑，U 的值生成之后，有一个 <code>S[C] = U</code> 的操作。</p><p><img src="https://cdn.itbob.cn/img/article/056/09.png" alt="09"></p><p>再往上看代码，S 是一个数组，单步调试的话会发现代码会一直走这个 <code>if-else</code> 的逻辑，几乎每一步都有 S 数组的参与，不断往里面增删改查值，for 循环里面的 I 值，决定着后续 if 语句的走向，这里也就是插桩的关键所在，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/10.png" alt="10"></p><h2 id="插桩分析">插桩分析</h2><p>大的 for 循环和 if-else 逻辑有两个地方，为了保证最后的日志更加详细完整，在这两个地方都下个日志断点（右键 <code>Add logpoint</code>），断点内容为：</p><pre><code class="hljs text">&quot;位置 1&quot;, &quot;索引I&quot;, I, &quot;索引A&quot;, A, &quot;值S: &quot;, JSON.stringify(S, function(key, value) &#123;if (value == window) &#123;return undefined&#125; return value&#125;)&quot;位置 2&quot;, &quot;索引I&quot;, I, &quot;索引A&quot;, A, &quot;值S: &quot;, JSON.stringify(S, function(key, value) &#123;if (value == window) &#123;return undefined&#125; return value&#125;)</code></pre><p><img src="https://cdn.itbob.cn/img/article/056/11.png" alt="11"></p><p>插桩输出 S 的时候为什么要写这么长一串呢？首先 <code>JSON.stringify()</code> 方法的作用是将 JavaScript 值转换为 JSON 字符串，基础语法是 <code>JSON.stringify(value[, replacer [, space]])</code>，如果不将其转换成 JSON，那么 S 的值，输出可能是这样的：<code>[empty, Array(26), 1, Array(0)]</code>，你看不到 Array 数组里面具体的值，该方法有个可选参数 replacer，如果 replacer 为函数，则 <code>JSON.stringify</code> 将调用该函数，并传入每个成员的键和值，在函数中可以对成员进行处理，最后返回处理后的值，如果此函数返回 undefined，则排除该成员，举个例子：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj1 = &#123;<span class="hljs-attr">key1</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-attr">key2</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeValue</span>(<span class="hljs-params">key, value</span>) </span>&#123;    <span class="hljs-keyword">if</span> (value == <span class="hljs-string">&#x27;value2&#x27;</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ITBOB&#x27;</span>    &#125; <span class="hljs-keyword">return</span> value&#125;<span class="hljs-keyword">var</span> obj2 = <span class="hljs-built_in">JSON</span>.stringify(obj1, changeValue)<span class="hljs-built_in">console</span>.log(obj2)<span class="hljs-comment">// 输出：&#123;&quot;key1&quot;:&quot;value1&quot;,&quot;key2&quot;:&quot;ITBOB&quot;&#125;</span></code></pre><p>上面的代码中 <code>JSON.stringify</code> 传入了一个函数，当 <code>value</code> 为 <code>value2</code> 的时候就将其替换成字符串 <code>ITBOB</code>，接下来我们演示一下当 <code>value</code> 为 <code>window</code> 时，会发生什么：</p><p><img src="https://cdn.itbob.cn/img/article/056/12.png" alt="12"></p><p>根据报错我们可以看到这里由于循环引用导致异常，要知道在插桩的时候，如果插桩内容有报错，就会导致不能正常输出日志，这样就会缺失一部分日志，这种情况我们就可以加个函数处理一下，让 value 为 window 的时候，JSON 处理的时候函数返回 undefined，排除该成员，其他成员正常输出，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/13.png" alt="13"></p><p>以上就是日志断点为什么要这样写的原因，下好日志断点后，注意前面我们下的 XHR 断点不要取消，然后刷新网页，控制台就开始打印日志了，因为有很多 XHR 请求都包含了 X-Bogus，如果你 XHR 断点取消了，日志就会一直打印直到卡死。日志输出完毕后，大约有8千多条，搜索就能看到最后一条日志 X-Bogus 已经生成了：</p><p><img src="https://cdn.itbob.cn/img/article/056/14.png" alt="14"></p><h2 id="28个字符生成逻辑">28个字符生成逻辑</h2><p>直接在打印的日志页面右键 <code>save as..</code>，将日志导出到本地进行分析。<code>X-Bogus</code> 由28个字符组成，现在要做的就是看 <code>DFSzswVOAATANH89SMHZqF9WX7n6</code> 这28个字符是怎么来的，在日志里搜索这个字符串，找到第一次出现的地方，观察一下可以发现，他是逐个字符依次生成的，如下图红框所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/15.png" alt="15"></p><p>在上图中，第8511行，X-Bogus 字符串的下一个元素是 null，到了第8512行，就生成数字6了，那么在这两步之间就是数字6的生成逻辑，这个时候我们看第8511行的日志断点是 <code>位置 2 索引I 16 索引A 738</code>，那么我们回到原网页，在位置2，下一个条件断点（右键 <code>Add conditional breakpoint</code>），当 <code>I == 16 &amp;&amp; A == 738 &amp;&amp; S[7] &amp;&amp; S[7] == 21</code> 时就断下。之所以要加 <code>S[7]</code> 是因为 <code>索引I 16 索引A 738</code> 的位置有很多，在日志里搜一下大概有40多个，多加个限制条件就可以缩小范围，当然有可能加了多个条件仍然有多个位置都满足，这就需要你细心观察了，通过断点断下的时候看看控制台前面输出的日志来判断是不是我们想要的位置。这也是一个小细节，一定要找准位置，千万别搞混了。（提示一下，像我这样下断点的话，一般情况下会断下两次，第二次是满足要求的）</p><p>（注意：本文描述的日志的多少行、断点的具体位置、变量的具体值，可能会有所变化，以你的实际情况为准，但思路是一样的）</p><p><img src="https://cdn.itbob.cn/img/article/056/16.png" alt="16"></p><p>刷新网页，断下之后开始单步跟，来到下图所示的地方：</p><p><img src="https://cdn.itbob.cn/img/article/056/17.png" alt="17"></p><p>到这里之后，就不要下一步了，再下一步有可能整个语句就执行完毕了，其中的细节你看不到，所以这里我们在控制台挨个输入看看：</p><p><img src="https://cdn.itbob.cn/img/article/056/18.png" alt="18"></p><p>可以看到实际上的逻辑就是返回指定位置的字符，y 的值就是 <code>S[5]</code>，m 的值就是 <code>S[4]</code>，经过多次调试发现 m 的值是固定的，M 就是 <code>charAt()</code> 方法，我们再看看我们本地的日志，<code>S[5]</code> 的值为 <code>[20]</code>，<code>charAt()</code> 取值出来就是6，逻辑完全正确。</p><p><img src="https://cdn.itbob.cn/img/article/056/19.png" alt="19"></p><p>现在我们还需要知道这个20是怎么来的，继续往上看，找到20第一次出现的地方，在第8510行，那么我们就要使其在上一步断下，也就是第8509行，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/20.png" alt="20"></p><p>第8509行的索引信息为 <code>位置 2 索引I 47 索引A 730</code>，同样的下条件断点观察怎么生成的：</p><p><img src="https://cdn.itbob.cn/img/article/056/21.png" alt="21"></p><p><img src="https://cdn.itbob.cn/img/article/056/22.png" alt="22"></p><p>可以看到逻辑是 <code>S[5] &amp; S[6]</code>，再看我们本地 <code>S[5] = 5647508</code>、<code>S[6] = 63 </code>，<code>5647508 &amp; 63 = 20</code>，逻辑正确，20就是这么来的。接下来又开始找 <code>5647508</code> 和 <code>63</code> 是怎么生成的，同样在生成的上一步，也就是8508行下个条件断点，这行的索引为 <code>位置 2 索引I 72 索引A 726</code>。</p><p><img src="https://cdn.itbob.cn/img/article/056/23.png" alt="23"></p><p><img src="https://cdn.itbob.cn/img/article/056/24.png" alt="24"></p><p><img src="https://cdn.itbob.cn/img/article/056/25.png" alt="25"></p><p>可以看到 63 是直接 <code>q[A]</code> 生成的，q 是一个大数组，A 就是索引为 726，q 这个大数组怎么来的先不用管，而 <code>5647508</code> 这个大数字，搜索一下，发现有很多，咱们也先放着，到这里咱们可以总结一下最后一个字符的生成步骤如下：</p><pre><code class="hljs text">short_str = &quot;Dkdpgh4ZKsQB80/Mfvw36XI1R25-WUAlEi7NLboqYTOPuzmFjJnryx9HVGcaStCe=&quot;q[726] = 635647508 &amp; 63 = 20short_str.charAt(20) = &#x27;6&#x27;</code></pre><p>然后接日志着往上看，看倒数第二个字母是怎么来的，方法也和前面演示的一样，不断往前下条件断点，这里就不再逐步演示了，当你找完四个数字后，就可以开始看 <code>5647508</code> 这个大数字怎么来的了，搜索这个数字，同样的找到第一次出现的地方，在其前一步下条件断点，步骤捋出来会发现有一个乱码字符串经过 <code>charCodeAt()</code> 操作，再加上一些位运算得到的，乱码字符串类似下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/26.png" alt="26"></p><p>至于这个乱码字符串怎么来的，我们后面再讲，到这里先总结一下，首先我们的 <code>X-Bogus = DFSz swVO AATA NH89 SMHZ qF9W X7n6</code>，将其看成每四个为一组，之所以这么分组，是因为你经过分析后会发现，每一组的每一个字符生成流程都是一样的，这里以最后两组为例，流程大致如下：</p><pre><code class="hljs in">short_str = &quot;Dkdpgh4ZKsQB80/Mfvw36XI1R25-WUAlEi7NLboqYTOPuzmFjJnryx9HVGcaStCe=&quot;X-Bogus = DFSz swVO AATA NH89 SMHZ qF9W X7n6============== 第6组【qF9W】==============&quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;.charCodeAt(15) = 158q[342] = 16158 &lt;&lt; 16 = 10354688&quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;.charCodeAt(16) = 253q[408] = 8253 &lt;&lt; 8 = 6476810354688 | 64768 = 10419456&quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;.charCodeAt(17) = 156156 | 10419456 = 10419612q[520] = 1651507210419612 &amp; 16515072 = 10223616q[532] = 1810223616 &gt;&gt; 18 = 39short_str.charAt(39) = &#x27;q&#x27;q[590]= 25804810419612 &amp; 258048 = 192512q[602] = 12192512 &gt;&gt; 12 = 47short_str.charAt(47) = &#x27;F&#x27;q[660] = 403210419612 &amp; 4032 = 3456q[668] = 63456 &gt;&gt; 6 = 54short_str.charAt(54) = &#x27;9&#x27;q[726] = 6310419612 &amp; 63 = 28short_str.charAt(28) = &#x27;W&#x27;============== 第7组【X7n6】==============&quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;.charCodeAt(18) = 86q[342] = 1686 &lt;&lt; 16 = 5636096&quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;.charCodeAt(19) = 44q[408] = 844 &lt;&lt; 8 = 112645636096 | 11264 = 5647360&quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;.charCodeAt(20) = 148148 | 5647360 = 5647508q[520] = 165150725647508 &amp; 16515072 = 5505024q[532] = 185505024 &gt;&gt; 18 = 21short_str.charAt(21) = &#x27;X&#x27;q[590] = 2580485647508 &amp; 258048 = 139264q[602] = 12139264 &gt;&gt; 12 = 34short_str.charAt(34) = &#x27;7&#x27;q[660] = 40325647508 &amp; 4032 = 3200q[668] = 63200 &gt;&gt; 6 = 50short_str.charAt(50) = &#x27;n&#x27;q[726] = 635647508 &amp; 63 = 20short_str.charAt(20) = &#x27;6&#x27;</code></pre><p>将流程对比一下就可以发现，每个步骤 q 里面的取值都是一样的，这个可以直接写死，不同之处就在于最开始的 <code>charCodeAt()</code> 操作，也就是返回乱码字符串指定位置字符的 Unicode 编码，第7组依次是 18、19、20，第6组依次是15、16、17，以此类推，第1组刚好是0、1、2，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/27.png" alt="27"></p><p>每一组的逻辑都是一样的，我们就可以写个通用方法，依次生成七组字符串，最后拼接成完整的 <code>X-Bogus</code>，代码如下：（乱码字符串的生成后文会讲）</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getXBogus</span>(<span class="hljs-params">originalString</span>)</span>&#123;    <span class="hljs-comment">// 生成乱码字符串</span>    <span class="hljs-keyword">var</span> garbledString = getGarbledString(originalString);    <span class="hljs-keyword">var</span> XBogus = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-comment">// 依次生成七组字符串</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">20</span>; i += <span class="hljs-number">3</span>) &#123;        <span class="hljs-keyword">var</span> charCodeAtNum0 = garbledString.charCodeAt(i);        <span class="hljs-keyword">var</span> charCodeAtNum1 = garbledString.charCodeAt(i + <span class="hljs-number">1</span>);        <span class="hljs-keyword">var</span> charCodeAtNum2 = garbledString.charCodeAt(i + <span class="hljs-number">2</span>);        <span class="hljs-keyword">var</span> baseNum = charCodeAtNum2 | charCodeAtNum1 &lt;&lt; <span class="hljs-number">8</span> | charCodeAtNum0 &lt;&lt; <span class="hljs-number">16</span>;        <span class="hljs-comment">// 依次生成四个字符</span>        <span class="hljs-keyword">var</span> str1 = short_str[(baseNum &amp; <span class="hljs-number">16515072</span>) &gt;&gt; <span class="hljs-number">18</span>];        <span class="hljs-keyword">var</span> str2 = short_str[(baseNum &amp; <span class="hljs-number">258048</span>) &gt;&gt; <span class="hljs-number">12</span>];        <span class="hljs-keyword">var</span> str3 = short_str[(baseNum &amp; <span class="hljs-number">4032</span>) &gt;&gt; <span class="hljs-number">6</span>];        <span class="hljs-keyword">var</span> str4 = short_str[baseNum &amp; <span class="hljs-number">63</span>];        XBogus += str1 + str2 + str3 + str4;    &#125;    <span class="hljs-keyword">return</span> XBogus;&#125;</code></pre><h2 id="乱码字符串生成逻辑">乱码字符串生成逻辑</h2><p>在进行下一步之前，我们要注意两点：</p><ul><li><p>文章演示有些变量前后不对应，因为每次插桩的值都是会变的，看流程就行了，流程是正确的；</p></li><li><p>我们日志输出是经过 <code>JSON.stringify</code> 处理了的，有些步骤是向某个函数传入乱码字符串进行处理，你会发现处理后的结果和日志不一致，这是正常的。</p></li></ul><p>乱码字符串的生成相对来说稍微复杂一点，但思路仍然一样，这里就不一一截图展示了，直接用日志描述一下关键步骤，注意以下日志是正向的步骤，就不逆着推了，建议自己先逆着把流程走一走，再来看这个步骤就看得懂了。</p><p><strong>Step1</strong>：首先对 URL 后面的参数，也就是 <code>Query String Parameters</code> 进行两次 MD5、两次转 <code>Uint8Array</code> 处理，最后得到的 <code>Uint8Array</code> 对象在后面的步骤中用得到，步骤如下：</p><pre><code class="hljs text">位置 1 索引I 4  索引A 134：将 URL 后面的参数进行 MD5 加密得到字符串位置 1 索引I 16 索引A 460：将上一步的字符串转换为 Uint8Array 对象位置 1 索引I 4  索引A 134：将上一步的 Uint8Array 对象进行 MD5 加密，得到字符串位置 1 索引I 29 索引A 472：将上一步的字符串转换为 Uint8Array 对象</code></pre><p>上述步骤中，我们将最终得到的结果命名为 <code>uint8Array</code>，关键代码实现如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> md5 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;md5&quot;</span>);<span class="hljs-comment">// 字符串转换为 Uint8Array 对象，缺失的变量自行补齐</span>_0x5960a2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> c = a.length &gt;&gt; <span class="hljs-number">1</span>, e = c &lt;&lt; <span class="hljs-number">1</span>, b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(c), d = <span class="hljs-number">0</span>, f = <span class="hljs-number">0</span>; f &lt; e; ) &#123;        b[d++] = _0x511f86[a.charCodeAt(f++)] &lt;&lt; <span class="hljs-number">4</span> | _0x511f86[a.charCodeAt(f++)];    &#125;    <span class="hljs-keyword">return</span> b;&#125;<span class="hljs-comment">// originalString: URL 后面的原始参数</span><span class="hljs-keyword">var</span> uint8Array = _0x5960a2(md5(_0x5960a2(md5(originalString))));</code></pre><p><strong>Step2</strong>：生成两个大数，一个是时间戳，我们称之为 <code>fixedString1</code>，另一个调用某个方法生成，我们称之为 <code>fixedString2</code>。</p><pre><code class="hljs text">fixedString1位置 1 索引I 43 索引A 806：1663385262240 / 1000 = 1663385262.24fixedString2位置 1 索引I 16 索引A 834：M.apply(null, []) = 536919696</code></pre><p>上述步骤中，M 对应以下方法，缺失的方法自行补齐（其中 <code>_0x229792</code> 是创建 <code>canvas</code>）：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x2996f8</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> _0x4b3b53 || (_0xb55f3e.perf ? -<span class="hljs-number">1</span> : (_0x4b3b53 = _0x229792(<span class="hljs-number">3735928559</span>), _0x4b3b53));    &#125; <span class="hljs-keyword">catch</span> (a) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p><strong>Step3</strong>：先后生成两个数组，我们称之为 <code>array1</code>、<code>array2</code>，<code>array2</code> 就是由 <code>array1</code> 的元素位置变换后得来的，严格来讲，<code>array1</code> 不是一个完整的数组，而是一个个数字，这一点可以在日志中体现出来，为了方便我们就直接将其视为一个数组，两个数组都有19个元素，步骤如下：</p><pre><code class="hljs text">array1[0] 至 array1[3] 为定值array1[4]位置 1 索引I 25 索引A 946：uint8Array[14]array1[5]位置 1 索引I 25 索引A 970：uint8Array[15]array1[6] 至 array1[7] 与 post 提交的 form data 有关array1[8] 至 array1[9] 与 ua 有关，与 Step1 类似array1[10]位置 1 索引I 52 索引A 1090：fixedString1 &gt;&gt; 24 = 99位置 1 索引I 47 索引A 1098：99 &amp; 255 = 99array1[11]位置 1 索引I 52 索引A 1122：fixedString1 &gt;&gt; 16 = 25417位置 1 索引I 47 索引A 1130：25417 &amp; 255 = 73array1[12]位置 1 索引I 52 索引A 1154：fixedString1 &gt;&gt; 8 = 6506755位置 1 索引I 47 索引A 1162：6506755 &amp; 255 = 3array1[13]位置 1 索引I 52 索引A 1186：fixedString1 &gt;&gt; 0 = 241位置 1 索引I 47 索引A 1194：241 &amp; 255 = 241array1[14]位置 1 索引I 52 索引A 1218：fixedString2 &gt;&gt; 24 = 32位置 1 索引I 47 索引A 1226：32 &amp; 255 = 32array1[15]位置 1 索引I 52 索引A 1250：fixedString2 &gt;&gt; 16 = 8192位置 1 索引I 47 索引A 1258：8192 &amp; 255 = 0array1[16]位置 1 索引I 52 索引A 1282：fixedString2 &gt;&gt; 8 = 2097342位置 1 索引I 47 索引A 1290：2097342 &amp; 255 = 190array1[17]位置 1 索引I 52 索引A 1314：fixedString2 &gt;&gt; 0 = 536919696位置 1 索引I 47 索引A 1322：536919696 &amp; 255 = 144array1[18]位置 1 索引I 27 索引A 1352：array1.reduce(function(a, b) &#123; return a ^ b; &#125;); = 100array1 完整值如下位置 1 索引I 27 索引A 1538：64,1.00390625,1,8,9,185,69,63,74,125,99,73,3,241,32,0,190,144,100array2 由 array1 元素交换位置而来：array2 = [array1[0], array1[2], array1[4], array1[6], array1[8], array1[10], array1[12], array1[14], array1[16], array1[18], array1[1], array1[3], array1[5], array1[7], array1[9], array1[11], array1[13], array1[15], array1[17]]array2 完整值如下array2 = [64,1,9,69,74,99,3,32,190,100,1.00390625,8,185,63,125,73,241,0,144]</code></pre><p><strong>Step4</strong>：将 Step3 得到的 array2 经过转换得到乱码字符串，步骤如下：</p><pre><code class="hljs text">位置 1 索引I 16 索引A 1706：_0x2f2740.apply(null, array2) = &quot;@\u0000\u0001\u000eíxE?\u0016c%&gt;® \u0000¾ó&quot;位置 1 索引I 16 索引A 1760：_0x46fa4c.apply(null, [&quot;ÿ&quot;, &quot;@\u0000\u0001\u000e\t¹E?J&#125;cI\u0003ñ \u0000¾d&quot;]) = &quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;位置 1 索引I 16 索引A 1812：_0x2b6720.apply(null, [2, 255, &quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;]) = &quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;</code></pre><p>其中用到的函数：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x2f2740</span>(<span class="hljs-params">a, c, e, b, d, f, t, n, o, i, r, _, x, u, s, l, v, h, g</span>) </span>&#123;    <span class="hljs-keyword">let</span> w = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">19</span>);    <span class="hljs-keyword">return</span> w[<span class="hljs-number">0</span>] = a,    w[<span class="hljs-number">1</span>] = r,    w[<span class="hljs-number">2</span>] = c,    w[<span class="hljs-number">3</span>] = _,    w[<span class="hljs-number">4</span>] = e,    w[<span class="hljs-number">5</span>] = x,    w[<span class="hljs-number">6</span>] = b,    w[<span class="hljs-number">7</span>] = u,    w[<span class="hljs-number">8</span>] = d,    w[<span class="hljs-number">9</span>] = s,    w[<span class="hljs-number">10</span>] = f,    w[<span class="hljs-number">11</span>] = l,    w[<span class="hljs-number">12</span>] = t,    w[<span class="hljs-number">13</span>] = v,    w[<span class="hljs-number">14</span>] = n,    w[<span class="hljs-number">15</span>] = h,    w[<span class="hljs-number">16</span>] = o,    w[<span class="hljs-number">17</span>] = g,    w[<span class="hljs-number">18</span>] = i,    <span class="hljs-built_in">String</span>.fromCharCode.apply(<span class="hljs-literal">null</span>, w);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x46fa4c</span>(<span class="hljs-params">a, c</span>) </span>&#123;    <span class="hljs-keyword">let</span> e, b = [], d = <span class="hljs-number">0</span>, f = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">256</span>; a++) &#123;        b[a] = a;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c = <span class="hljs-number">0</span>; c &lt; <span class="hljs-number">256</span>; c++) &#123;        d = (d + b[c] + a.charCodeAt(c % a.length)) % <span class="hljs-number">256</span>,        e = b[c],        b[c] = b[d],        b[d] = e;    &#125;    <span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>;    d = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>; a &lt; c.length; a++) &#123;        t = (t + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>,        d = (d + b[t]) % <span class="hljs-number">256</span>,        e = b[t],        b[t] = b[d],        b[d] = e,        f += <span class="hljs-built_in">String</span>.fromCharCode(c.charCodeAt(a) ^ b[(b[t] + b[d]) % <span class="hljs-number">256</span>]);    &#125;    <span class="hljs-keyword">return</span> f;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x583250</span>(<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode(a);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x2b6720</span>(<span class="hljs-params">a, c, e</span>) </span>&#123;    <span class="hljs-keyword">return</span> _0x583250(a) + _0x583250(c) + e;&#125;</code></pre><p>自此，整个流程就走完了。可以用 JavaScript 来实现整个算法，用 Python 也可以，完善代码后随便请求一个博主主页，简单解析几个数据，输出正常：</p><p><img src="https://cdn.itbob.cn/img/article/056/28.png" alt="28"></p><p><img src="https://cdn.itbob.cn/img/article/056/29.png" alt="29"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/javascript_reverse.png&quot; alt=&quot;javascript_reverse&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>APP 逆向，Frida 初体验，root 检测与加密字符串定位</title>
    <link href="https://www.itbob.cn/article/055/"/>
    <id>https://www.itbob.cn/article/055/</id>
    <published>2022-09-12T10:00:00.000Z</published>
    <updated>2022-11-02T16:46:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/app_reverse.png" alt="app_reverse"></p><h2 id="声明">声明</h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2 id="逆向目标">逆向目标</h2><ul><li>设备：Google Pixel4，Android 10，已 root</li><li>APP：UnCrackable-Level1.apk（来源：<a href="https://github.com/OWASP/owasp-mastg/tree/master/Crackmes">https://github.com/OWASP/owasp-mastg/tree/master/Crackmes</a> ）</li><li>APP 检测了 root，如果手机 root 了，会强制退出 APP，过了 root 检测后，还需要输入一个字符串进行校验。</li></ul><h2 id="安装-ADB">安装 ADB</h2><p>adb（Android Debug Bridge）即安卓调试桥，安装后可以在电脑上与手机进行交互，Android Studio 等工具里面会自带 adb，有时候我们并不想下载这么大的工具，所以这里介绍一下 Android SDK Platform-Tools，它是 Android SDK 的一个组件，它包括与 Android 平台交互的工具，主要是 adb 和 fastboot，官方下载地址：<a href="https://developer.android.com/studio/releases/platform-tools">https://developer.android.com/studio/releases/platform-tools</a> ，下载完成后将该目录添加到环境变量，USB 连接手机，手机上设置允许 USB 调试，使用命令 <code>adb version</code> 可查看版本信息，<code>adb devices</code> 可以查看当前连接的设备，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/055/01.png" alt="01"></p><h2 id="安装-Frida">安装 Frida</h2><p>Frida 是一款基于 Python + JavaScript 的 Hook 与调试框架，首先电脑端使用命令 <code>pip install frida-tools</code> 安装 frida 模块（此命令默认会安装最新版的 frida 和 frida-tools，如），然后下载 frida-server，下载地址：<a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a></p><p>frida-server 要根据你电脑端安装的 frida 版本和手机的 CPU 架构来选择对应的，使用命令 <code>frida --version</code> 可以查看 frida 版本，使用命令 <code>adb shell</code> 进入手机，输入 <code>getprop ro.product.cpu.abi</code> 查看 CPU 架构，如下图所示，我这里 frida 是 15.2.2 版本，手机 CPU 为 arm64，所以我下载的是 <code>frida-server-15.2.2-android-arm64.xz</code>。</p><p>某些 Android 低版本使用高版本 frida 可能有问题，遇到问题可尝试降低 frida 版本来解决。</p><p><img src="https://cdn.itbob.cn/img/article/055/02.png" alt="02"></p><p><img src="https://cdn.itbob.cn/img/article/055/03.png" alt="03"></p><p>将下载好的 frida-server 使用 <code>adb push</code> 命令传到手机的 <code>/data/local/tmp/</code> 目录下，并给予 777 读、写、执行的权限，然后直接运行 frida-server，正常不会有任何输出，当然也可以使用 &amp; 等方式让其在后台运行。</p><p><img src="https://cdn.itbob.cn/img/article/055/04.png" alt="04"></p><p>然后另开一个 cmd 使用命令 <code>frida-ps -U </code> 可查看手机进程，有输出则正常。</p><p><img src="https://cdn.itbob.cn/img/article/055/05.png" alt="05"></p><h2 id="逆向分析">逆向分析</h2><p>使用 <code>adb install</code> 命令安装 UnCrackable-Level1.apk，打开该 APP，会检测到 root，出现 <code>Root detected!</code> 的提示，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/055/06.png" alt="06"></p><p>使用 JEB、JADX、GDA 等工具反编译 apk，直接搜索关键字 <code>Root detected!</code> 即可定位到检测的地方：</p><p><img src="https://cdn.itbob.cn/img/article/055/07.png" alt="07"></p><p>可以看到图中有三个检测方法 <code>c.a()</code>、<code>c.b()</code>、<code>c.c()</code>，其中一个返回为真，则弹出 <code>Root detected!</code>，然后前面还有一个 <code>onClick</code> 方法，如果点击 OK 按钮，则触发 <code>System.exit(0);</code>，即退出 APP，先点进三个检测方法看看：</p><p><code>a()</code> 方法通过检测 Android 系统环境变量中是否有 su 文件来判断是否被 root；</p><p><code>b()</code> 方法通过检测 <code>Build.TAGS</code> 中是否包含字符串 <code>test-keys</code> 来判断是否被 root；</p><p><code>c()</code> 方法通过检测指定路径下是否包含指定的文件来判断是否被 root。</p><p><img src="https://cdn.itbob.cn/img/article/055/08.png" alt="08"></p><p>所以我们这里就有多种过掉检测的方法：</p><p>方法一：Hook 三个检测方法，让它们都返回 false，不再执行后续的 a 方法，就不会退出 APP 了：</p><pre><code class="hljs javascript">Java.perform(    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook begin&quot;</span>)        <span class="hljs-keyword">var</span> vantagePoint = Java.use(<span class="hljs-string">&quot;sg.vantagepoint.a.c&quot;</span>)        vantagePoint.a.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook vantagepoint.a.c.a&quot;</span>)            <span class="hljs-built_in">this</span>.a();            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        vantagePoint.b.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook vantagepoint.a.c.b&quot;</span>)            <span class="hljs-built_in">this</span>.b();            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        vantagePoint.c.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook vantagepoint.a.c.c&quot;</span>)            <span class="hljs-built_in">this</span>.c();            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;)</code></pre><p>方法二：Hook <code>a()</code> 方法，置空，什么都不做，不弹出对话框，也不退出 APP：</p><pre><code class="hljs javascript">Java.perform(    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook begin&quot;</span>)        <span class="hljs-keyword">var</span> mainActivity = Java.use(<span class="hljs-string">&quot;sg.vantagepoint.uncrackable1.MainActivity&quot;</span>);        mainActivity.a.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook mainActivity.a&quot;</span>)        &#125;    &#125;)</code></pre><p>方法三：Hook <code>onClick()</code> 方法，点击 OK 后不让其退出 APP，注意这里是内部类的 Hook 写法：</p><pre><code class="hljs javascript">Java.perform(    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook begin&quot;</span>)        <span class="hljs-keyword">var</span> mainActivity$<span class="hljs-number">1</span> = Java.use(<span class="hljs-string">&quot;sg.vantagepoint.uncrackable1.MainActivity$1&quot;</span>);        mainActivity$<span class="hljs-number">1.</span>onClick.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook mainActivity$1.onClick&quot;</span>)        &#125;    &#125;)</code></pre><p>方法四：Hook <code>System.exit()</code> 方法，点击 OK 后不让其退出 APP：</p><pre><code class="hljs javascript">Java.perform(    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook begin&quot;</span>)        <span class="hljs-keyword">var</span> javaSystem = Java.use(<span class="hljs-string">&quot;java.lang.System&quot;</span>);        javaSystem.exit.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook system.exit&quot;</span>)        &#125;    &#125;)</code></pre><p>root 检测过掉之后，APP 还要输入一个字符串，输入错误会提示 <code>That's not it. Try again.</code>，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/055/09.png" alt="09"></p><p>分析 Java 代码，有一个 <code>if-else</code> 判断，obj 为输入的字符串，<code>a.a(obj)</code> 判断为真，就表示输入正确。</p><p><img src="https://cdn.itbob.cn/img/article/055/10.png" alt="10"></p><p>跟到 <code>a.a()</code> 方法，可以看到 <code>bArr</code> 是内置的字符串，通过 <code>equals()</code> 方法比较输入的 <code>str</code> 是否和 <code>bArr</code> 相等：</p><p><img src="https://cdn.itbob.cn/img/article/055/11.png" alt="11"></p><p><code>bArr</code> 的值，主要经过 <code>sg.vantagepoint.a.a.a()</code> 方法处理后得到，继续跟进去可以发现是 AES 加密算法：</p><p><img src="https://cdn.itbob.cn/img/article/055/12.png" alt="12"></p><p>这里就可以直接 Hook <code>sg.vantagepoint.a.a.a()</code>，直接拿到加密后的值，也就是我们要的正确字符串，由于这里返回的是 ASCII 码，所以我们还需要在 JavaScript 代码中使用 <code>String.fromCharCode()</code> 将其转换成正常字符，Hook 代码如下：</p><pre><code class="hljs javascript">Java.perform(    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">var</span> cryptoAES = Java.use(<span class="hljs-string">&quot;sg.vantagepoint.a.a&quot;</span>);        cryptoAES.a.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bArr, bArr2</span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook cryptoAES&quot;</span>)            <span class="hljs-keyword">var</span> secret = <span class="hljs-string">&quot;&quot;</span>;            <span class="hljs-keyword">var</span> decryptValue = <span class="hljs-built_in">this</span>.a(bArr, bArr2);            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] DecryptValue:&quot;</span>, decryptValue)            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i &lt; decryptValue.length; i++)&#123;              secret += <span class="hljs-built_in">String</span>.fromCharCode(decryptValue[i]);            &#125;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Secret:&quot;</span>, secret)            <span class="hljs-keyword">return</span> decryptValue;        &#125;    &#125;)</code></pre><p>运行 Hook 脚本有两种方式，一是结合 Python 使用，二是直接通过 frida 命令使用脚本，注入 Hook 代码也有个时机问题，有时候需要在 APP 启动就开始 Hook，有时候可以等 APP 启动加载完毕了再 Hook，本例中，过 root 检测的时候，如果采用第一、二种方法，即 Hook 三个检测方法或者 a 方法，那就需要在 APP 启动的时候就 Hook，如果采用第三、四种方法，即 Hook  <code>onClick()</code> 或者 <code>System.exit()</code> 方法，那么等 APP 启动了再 Hook 也可以。</p><h3 id="结合-Python-使用">结合 Python 使用</h3><p>首先来看一下结合 Python 怎么使用，JavaScript 代码如下（frida-hook.js）：</p><pre><code class="hljs javascript"><span class="hljs-comment">/* ==================================</span><span class="hljs-comment"># @Time    : 2022-08-29</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: frida-hook.js</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ================================== */</span>Java.perform(    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook begin&quot;</span>)        <span class="hljs-comment">// 方法一：Hook 三个检测方法，让它们都返回 false，不再执行后续的 a 方法，就不会退出 APP 了</span>        <span class="hljs-comment">// var vantagePoint = Java.use(&quot;sg.vantagepoint.a.c&quot;)</span>        <span class="hljs-comment">// vantagePoint.a.implementation = function()&#123;</span>        <span class="hljs-comment">//     console.log(&quot;[*] Hook vantagepoint.a.c.a&quot;)</span>        <span class="hljs-comment">//     this.a();</span>        <span class="hljs-comment">//     return false;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// vantagePoint.b.implementation = function()&#123;</span>        <span class="hljs-comment">//     console.log(&quot;[*] Hook vantagepoint.a.c.b&quot;)</span>        <span class="hljs-comment">//     this.b();</span>        <span class="hljs-comment">//     return false;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// vantagePoint.c.implementation = function()&#123;</span>        <span class="hljs-comment">//     console.log(&quot;[*] Hook vantagepoint.a.c.c&quot;)</span>        <span class="hljs-comment">//     this.c();</span>        <span class="hljs-comment">//     return false;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// 方法二：Hook a() 方法，置空，什么都不做，不弹出对话框，也不退出 APP</span>        <span class="hljs-comment">// var mainActivity = Java.use(&quot;sg.vantagepoint.uncrackable1.MainActivity&quot;);</span>        <span class="hljs-comment">// mainActivity.a.implementation = function()&#123;</span>        <span class="hljs-comment">//    console.log(&quot;[*] Hook mainActivity.a&quot;)</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// 方法三：Hook onClick() 方法，点击 OK 后不让其退出 APP</span>        <span class="hljs-comment">// var mainActivity$1 = Java.use(&quot;sg.vantagepoint.uncrackable1.MainActivity$1&quot;);</span>        <span class="hljs-comment">// mainActivity$1.onClick.implementation = function()&#123;</span>        <span class="hljs-comment">//     console.log(&quot;[*] Hook mainActivity$1.onClick&quot;)</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// 方法四：Hook System.exit 方法，点击 OK 后不让其退出 APP</span>        <span class="hljs-keyword">var</span> javaSystem = Java.use(<span class="hljs-string">&quot;java.lang.System&quot;</span>);        javaSystem.exit.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook system.exit&quot;</span>)        &#125;        <span class="hljs-keyword">var</span> cryptoAES = Java.use(<span class="hljs-string">&quot;sg.vantagepoint.a.a&quot;</span>);        cryptoAES.a.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bArr, bArr2</span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook cryptoAES&quot;</span>)            <span class="hljs-keyword">var</span> secret = <span class="hljs-string">&quot;&quot;</span>;            <span class="hljs-keyword">var</span> decryptValue = <span class="hljs-built_in">this</span>.a(bArr, bArr2);            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] DecryptValue:&quot;</span>, decryptValue)            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i &lt; decryptValue.length; i++)&#123;              secret += <span class="hljs-built_in">String</span>.fromCharCode(decryptValue[i]);            &#125;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Secret:&quot;</span>, secret)            <span class="hljs-keyword">return</span> decryptValue;        &#125;    &#125;)</code></pre><p>Python 代码如下（<a href="http://frida-hook.py">frida-hook.py</a>）：</p><pre><code class="hljs python"><span class="hljs-comment"># ==================================</span><span class="hljs-comment"># --*-- coding: utf-8 --*--</span><span class="hljs-comment"># @Time    : 2022-08-29</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: frida-hook.py</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ==================================</span><span class="hljs-keyword">import</span> sys<span class="hljs-keyword">import</span> frida<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_message</span>(<span class="hljs-params">message, data</span>):</span>    <span class="hljs-keyword">if</span> message[<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;send&#x27;</span>:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[*] &#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(message[<span class="hljs-string">&#x27;payload&#x27;</span>]))    <span class="hljs-keyword">else</span>:        <span class="hljs-built_in">print</span>(message)<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./frida-hook.js&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> fp:    hook_string = fp.read()<span class="hljs-comment"># 方式一：attach 模式，已经启动的 APP</span>process = frida.get_usb_device(-<span class="hljs-number">1</span>).attach(<span class="hljs-string">&quot;Uncrackable1&quot;</span>)script = process.create_script(hook_string)script.on(<span class="hljs-string">&quot;message&quot;</span>, on_message)script.load()sys.stdin.read()<span class="hljs-comment"># 方式二，spawn 模式，重启 APP</span><span class="hljs-comment"># device = frida.get_usb_device(-1)</span><span class="hljs-comment"># pid = device.spawn([&quot;owasp.mstg.uncrackable1&quot;])</span><span class="hljs-comment"># process = device.attach(pid)</span><span class="hljs-comment"># script = process.create_script(hook_string)</span><span class="hljs-comment"># script.on(&quot;message&quot;, on_message)</span><span class="hljs-comment"># script.load()</span><span class="hljs-comment"># device.resume(pid)</span><span class="hljs-comment"># sys.stdin.read()</span></code></pre><p>Python 代码中，attach 模式 Hook 已经存在的进程，spawn 模式会重启 APP，启动一个新的进程并挂起，在启动的同时注入 frida 代码，适用于在进程启动前的一些 Hook，attach 模式传入的是 APP 名称，spawn 模式传入的是 APP 包名，查看 APP 名称和包名的方法有很多，这里介绍两个 frida 命令，<code>frida-ps -Uai</code>：列出安装的程序，<code>frida-ps -Ua</code>：列出正在运行中的程序，如下图所示，本例中 <code>Uncrackable1</code> 就是 APP 名称，<code>owasp.mstg.uncrackable1</code> 就是包名：</p><p><img src="https://cdn.itbob.cn/img/article/055/13.png" alt="13"></p><p>运行 Python 代码，注意手机端也要启动 frida-server，过掉 root 检测后，先随便输入字符串，点击 VERIFY 就会 Hook 到正确的字符串为 <code>I want to believe</code>，再次输入正确的字符串，即可验证成功。</p><p><img src="https://cdn.itbob.cn/img/article/055/14.png" alt="14"></p><h3 id="frida-命令">frida 命令</h3><p>不使用 Python，也可以直接使用 frida 命令来实现，和前面 Python  一样也有两种模式，同样的一个是 APP 名一个是包名：</p><p><code>frida -U Uncrackable1 -l .\frida-hook.js</code>：attach 模式，APP 启动后注入 frida 代码；</p><p><code>frida -U -f owasp.mstg.uncrackable1 -l .\frida-hook.js --no-pause</code>：spawn 模式，重启 APP，启动的同时注入 frida 代码。</p><p><img src="https://cdn.itbob.cn/img/article/055/15.png" alt="15"></p><p>至此，我们完美绕过了 root 检测，并成功找到了正确的字符串。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/app_reverse.png&quot; alt=&quot;app_reverse&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;本文章中所有内</summary>
      
    
    
    
    <category term="APP 逆向实战" scheme="https://www.itbob.cn/categories/APP-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="APP 逆向实战" scheme="https://www.itbob.cn/tags/APP-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>国内 Web 防护天花板，瑞数 5 代 JS 逆向分析</title>
    <link href="https://www.itbob.cn/article/054/"/>
    <id>https://www.itbob.cn/article/054/</id>
    <published>2022-09-01T05:00:00.000Z</published>
    <updated>2022-11-02T15:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/javascript_reverse.png" alt="javascript_reverse"></p><h2 id="声明">声明</h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2 id="前言">前言</h2><p><img src="https://cdn.itbob.cn/img/article/054/01.png" alt="01"></p><p>瑞数动态安全 Botgate（机器人防火墙）以“动态安全”技术为核心，通过动态封装、动态验证、动态混淆、动态令牌等技术对服务器网页底层代码持续动态变换，增加服务器行为的“不可预测性”，实现了从用户端到服务器端的全方位“主动防护”，为各类 Web、HTML5 提供强大的安全保护。</p><p>在往期的文章<a href="https://www.itbob.cn/article/053/">《国内 Web 防护天花板，瑞数 4 代 JS 逆向分析》</a>中，详细介绍了瑞数的特征、如何区分不同版本、瑞数的代码结构以及各自的作用，本文就不再赘述了，不了解的同志可以先去看看之前的文章。</p><h2 id="Cookie-入口定位">Cookie 入口定位</h2><p>本文案例中瑞数 5 代网站为：<code>aHR0cHM6Ly93d3cubm1wYS5nb3YuY24vZGF0YXNlYXJjaC9ob21lLWluZGV4Lmh0bWw=</code></p><p>定位 Cookie，首选 Hook 来的最快，通过 Fiddler 插件、油猴脚本、浏览器插件等方式注入以下 Hook 代码：</p><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 严谨模式 检查所有错误</span><span class="hljs-meta">    &#x27;use strict&#x27;</span>;    <span class="hljs-comment">// document 为要hook的对象 这里是hook的cookie</span>    <span class="hljs-keyword">var</span> cookieTemp = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">document</span>, <span class="hljs-string">&#x27;cookie&#x27;</span>, &#123;        <span class="hljs-comment">// hook set方法也就是赋值的方法 </span>        <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;                <span class="hljs-comment">// 这样就可以快速给下面这个代码行下断点</span>                <span class="hljs-comment">// 从而快速定位设置cookie的代码</span>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hook捕获到cookie设置-&gt;&#x27;</span>, val);                <span class="hljs-keyword">debugger</span>;                cookieTemp = val;                <span class="hljs-keyword">return</span> val;        &#125;,        <span class="hljs-comment">// hook get 方法也就是取值的方法 </span>        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;            <span class="hljs-keyword">return</span> cookieTemp;        &#125;    &#125;);&#125;)();</code></pre><p>断下之后往上跟栈，可以看到组装 Cookie 后赋值给 <code>document.cookie</code> 的代码，类似如下结构：</p><p><img src="https://cdn.itbob.cn/img/article/054/02.png" alt="02"></p><p>继续往上跟栈，和4代瑞数类似，<code>(772, 1)</code> 的位置是入口，4代有一次生成假 cookie 的过程，5代就没有了，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/054/03.png" alt="03"></p><p>再往前跟栈，来到首页代码，这里就是我们熟悉的 call 位置了，图中 <code>_$ug</code> 实际上是 eval 方法，传入的第一个参数 <code>_$Cs</code> 是 Window 对象，第二个对象 <code>_$Dm</code> 是我们前面看到的 VM 虚拟机中的 IIFE 自执行代码。</p><p><img src="https://cdn.itbob.cn/img/article/054/04.png" alt="04"></p><h2 id="VM-代码以及-ts-变量获取">VM 代码以及 $_ts 变量获取</h2><p>获取 VM 代码和 <code>$_ts</code> 变量是第一步，和4代类似，复制外链 JS（例如 <code>fjtvkgf7LVI2.a670748.js</code>）的代码和 412 页面的自执行代码到文件，本地直接运行即可，需要轻度补一下环境，缺啥补啥，大致补一下 window、location、document 就行了，补的具体内容可以直接在浏览器控制台使用 <code>copy()</code> 命令复制过来，然后 VM 代码我们就可以直接 Hook eval 的方式得到，这里 <code>$_ts</code> 变量的获取和4代有点儿区别，4代我们的做法是运行完代码后直接取 <code>window.$_ts</code> 就行了，5代运行完代码后会有一个清空 <code>$_ts</code> 的操作，可以自己跟栈看一下逻辑，要么把清空的逻辑删了，要么定义一个全局变量，然后直接在 call 的地方将 <code>$_ts</code> 的值导出来：</p><p><img src="https://cdn.itbob.cn/img/article/054/05.png" alt="05"></p><p>大致的补环境代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> eval_js = <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">var</span> rs_ts = <span class="hljs-string">&quot;&quot;</span><span class="hljs-built_in">window</span> = &#123;    <span class="hljs-attr">$_ts</span>: &#123;&#125;,    <span class="hljs-attr">eval</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;        eval_js = data    &#125;&#125;location = &#123;    <span class="hljs-string">&quot;ancestorOrigins&quot;</span>: &#123;&#125;,    <span class="hljs-string">&quot;href&quot;</span>: <span class="hljs-string">&quot;https://脱敏处理/datasearch/home-index.html&quot;</span>,    <span class="hljs-string">&quot;origin&quot;</span>: <span class="hljs-string">&quot;https://脱敏处理&quot;</span>,    <span class="hljs-string">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;https:&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.cn&quot;</span>,    <span class="hljs-string">&quot;hostname&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.cn&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,    <span class="hljs-string">&quot;pathname&quot;</span>: <span class="hljs-string">&quot;/datasearch/home-index.html&quot;</span>,    <span class="hljs-string">&quot;search&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,    <span class="hljs-string">&quot;hash&quot;</span>: <span class="hljs-string">&quot;&quot;</span>&#125;<span class="hljs-built_in">document</span> = &#123;    <span class="hljs-string">&quot;scripts&quot;</span>: [<span class="hljs-string">&quot;script&quot;</span>, <span class="hljs-string">&quot;script&quot;</span>]&#125;</code></pre><p>获取 VM 代码以及 <code>$_ts</code> 变量：</p><p><img src="https://cdn.itbob.cn/img/article/054/06.png" alt="06"></p><h2 id="善用-Watch-跟踪功能">善用 Watch 跟踪功能</h2><p>在跟栈分析之前，有必要了解一下浏览器开发者工具的 Watch 功能，它能够持续跟踪某个变量的值，对于瑞数这种控制流很多的情况，设置相应的变量跟踪，能够让你知道你现在处于哪个控制流中，以及生成的数组的变化，不至于跟着跟着不知道到哪一步了。如下图所示，<code>_$S8</code> 表示目前正处于第 279 号大控制流，<code>_$5x</code> 表示大控制流下的哪个分支，<code>_$mz</code> 表示 128 位大数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/07.png" alt="07"></p><h2 id="跟栈分析">跟栈分析</h2><p>老样子，本地替换一套 412 页面的代码，固定下来，然后开始跟栈分析。直接从 <code>(772, 1)</code> 开始跟（文中说的第多少号控制流、第几步均为作者自己的叫法，第多少步并不代表实际上的步骤，仅表示关键步骤）：</p><p><img src="https://cdn.itbob.cn/img/article/054/08.png" alt="08"></p><p>单步进来，<code>_$qh</code> 是传进来的参数 1，即将进入 742 号控制流：</p><p><img src="https://cdn.itbob.cn/img/article/054/09.png" alt="09"></p><p>进入 742 号控制流，第 1 步通过一个方法获取了一个时间戳，进入这个方法内部，对时间戳进行了差值计算，会发现有两个变量 <code>_$tb</code> 和 <code>_$t1</code> 已经生成了值：</p><p><img src="https://cdn.itbob.cn/img/article/054/10.png" alt="10"></p><p><img src="https://cdn.itbob.cn/img/article/054/11.png" alt="11"></p><p>这两个值也是时间戳，怎么来的？直接搜索这两个变量，搜索结果有几个全部打上断点，刷新断下后往前跟栈，会发现是最开始走了一遍 703 号控制流：</p><p><img src="https://cdn.itbob.cn/img/article/054/12.png" alt="12"></p><p>先单步跟一遍 703 号控制流，703 号控制流第 1 步是进入 699 号控制流，返回一个数组，没有特别的，直接扣代码即可：</p><p><img src="https://cdn.itbob.cn/img/article/054/13.png" alt="13"></p><p>703 号控制流第 2、3 步分别取数组的值：</p><p><img src="https://cdn.itbob.cn/img/article/054/14.png" alt="14"></p><p><img src="https://cdn.itbob.cn/img/article/054/15.png" alt="15"></p><p>703 号控制流第 4、5、6 步生成两个时间戳并赋值给前面提到的 <code>_$tb</code>、<code>_$t1</code> 变量，涉及到的方法也没有什么特别的，缺啥搜啥补啥即可：</p><p><img src="https://cdn.itbob.cn/img/article/054/16.png" alt="16"></p><p><img src="https://cdn.itbob.cn/img/article/054/17.png" alt="17"></p><p><img src="https://cdn.itbob.cn/img/article/054/18.png" alt="18"></p><p>703 号控制流第 7 步，这里修改了 <code>$_ts</code> 的某个值（VM 代码中，<code>$_ts</code> 被赋值给了另一个变量，下图中是 <code>_$iw</code>），<code>_$iw._$uq</code> 原本的值是 <code>_$ou</code>，修改后的值是 181，这个值也是后面关键 4 位数组中的其中一个，具体逻辑后面再讲。</p><p><img src="https://cdn.itbob.cn/img/article/054/19.png" alt="19"></p><p>703 号控制流结束，我们继续前面的  742 号控制流，742 号控制流第 2 步，将前面生成的时间戳赋值给另一个变量。</p><p><img src="https://cdn.itbob.cn/img/article/054/20.png" alt="20"></p><p>742 号控制流第 3 步，进入 279 号控制流，279 号控制流是生成 128 位数组的关键。</p><p><img src="https://cdn.itbob.cn/img/article/054/21.png" alt="21"></p><p>进入 279 号控制流，第 1 步定义了一个变量：</p><p><img src="https://cdn.itbob.cn/img/article/054/22.png" alt="22"></p><p>279 号控制流，第 2 步，进入 157 号控制流，157 号控制流主要是做自动化检测</p><p><img src="https://cdn.itbob.cn/img/article/054/23.png" alt="23"></p><p><img src="https://cdn.itbob.cn/img/article/054/24.png" alt="24"></p><p>279 号控制流，第 3、4、5 步，做了一些运算，一些全局变量的值会改变，后续的数组里会用到。</p><p><img src="https://cdn.itbob.cn/img/article/054/25.png" alt="25"></p><p><img src="https://cdn.itbob.cn/img/article/054/26.png" alt="26"></p><p><img src="https://cdn.itbob.cn/img/article/054/27.png" alt="27"></p><p>279 号控制流，第 6 步，初始化了一个 128 位的空数组，后续的操作都是为了往这个数组里面填充值。</p><p><img src="https://cdn.itbob.cn/img/article/054/28.png" alt="28"></p><p>279 号控制流，第 7 步，进入 695 号控制流，生成一个 20 位的数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/29.png" alt="29"></p><p>进入 695 号控制流看一下，第 1 步，取 <code>$_ts</code> 的一个值，生成 16 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/30.png" alt="30"></p><p>695 号控制流，第 2 步，取 <code>$_ts</code> 里的四个值，与前面的 16 位数组一起组成 20 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/31.png" alt="31"></p><p>这里注意这四个值怎么来的，以第二个值 <code>_$iw._$KI</code> 为例，搜索发现有一条语句 <code>_$iw._$KI = _$iw[_$iw._$KI](_$bl, _$n2);</code>，首先等号右边取 <code>_$iw._$KI</code> 的值为 <code>_$Mo</code>，然后 <code>_$iw[&quot;_$Mo&quot;]</code> 实际上就是 <code>_$iw._$Mo</code>，前面的定义 <code>_$iw._$Mo = _$1D</code>，<code>_$1D</code> 是个方法，所以原语句相当于 <code>_$iw._$KI = _$1D(_$bl, _$n2)</code>，其他三个值的来源也是类似的。</p><p><img src="https://cdn.itbob.cn/img/article/054/32.png" alt="32"></p><p>695 号控制流结束，回到 279 号控制流，第 8 步，将前面的时间戳转换成了一个 8 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/33.png" alt="33"></p><p>279 号控制流，第 9 步，往 128 位数组里面添加了一个值。</p><p><img src="https://cdn.itbob.cn/img/article/054/34.png" alt="34"></p><p><code>_$ae</code> 这个值怎么来的？搜索下断点并跟栈，发现是开头走了第 178 号控制流得来的，跟着走一遍即可。</p><p><img src="https://cdn.itbob.cn/img/article/054/35.png" alt="35"></p><p><img src="https://cdn.itbob.cn/img/article/054/36.png" alt="36"></p><p>279 号控制流，第 10 步，又往 128 位数组里面添加了一个值，这个值是开始 279 号控制流传过来的。</p><p><img src="https://cdn.itbob.cn/img/article/054/37.png" alt="37"></p><p><img src="https://cdn.itbob.cn/img/article/054/38.png" alt="38"></p><p>279 号控制流，第 11、12、13、14 步，时间戳相关计算，然后生成两个 2 位数组。注意这里面的两个变量，<code>_$ll</code> 和 <code>_$ed</code>，在刷新 cookie、生成后缀的时候可能是有值的，仅访问主页没有值不影响。</p><p><img src="https://cdn.itbob.cn/img/article/054/39.png" alt="39"></p><p><img src="https://cdn.itbob.cn/img/article/054/40.png" alt="40"></p><p><img src="https://cdn.itbob.cn/img/article/054/41.png" alt="41"></p><p><img src="https://cdn.itbob.cn/img/article/054/42.png" alt="42"></p><p>279 号控制流，第 15 步，往 128 位数组里面添加了一个 4 位数组 <code>_$bl</code>，搜索也可以找到是通过 723 号控制流得来的。</p><p><img src="https://cdn.itbob.cn/img/article/054/43.png" alt="43"></p><p><img src="https://cdn.itbob.cn/img/article/054/44.png" alt="44"></p><p>这里的 723 号控制流，实际上是取了 <code>$_ts</code> 某个值进行运算，生成 16 位数组，然后截取前 4 位数组返回的。</p><p><img src="https://cdn.itbob.cn/img/article/054/45.png" alt="45"></p><p><img src="https://cdn.itbob.cn/img/article/054/46.png" alt="46"></p><p>279 号控制流，第 16 步，往 128 位数组里面添加了一个 8 位数组 <code>_$Yb</code>。</p><p><img src="https://cdn.itbob.cn/img/article/054/47.png" alt="47"></p><p>8 位数组 <code>_$Yb</code> 同样搜索打断点，可以在一个赋值语句断下：</p><p><img src="https://cdn.itbob.cn/img/article/054/48.png" alt="48"></p><p>可以看到 <code>_$EJ</code> 的值就是 <code>_$Yb</code>，往前跟栈，会发现先后经过了 657 号、10 号、777 号控制流，其中 777 号控制流是入口：</p><p><img src="https://cdn.itbob.cn/img/article/054/49.png" alt="49"></p><p><img src="https://cdn.itbob.cn/img/article/054/50.png" alt="50"></p><p><img src="https://cdn.itbob.cn/img/article/054/51.png" alt="51"></p><p>如果单步跟 777 号控制流，你会发现步骤较多，中间有些语句不好处理，且容易跟丢，所以我们这里就直接关注 657 号控制流就行了，777 号控制流直接到 10 号控制流，再到 657 号控制流，中间的一些过程暂时不管，跟到缺什么的时候再说（后续有很多取值赋值等操作都是在 777 号控制流里实现的，可以注意一下），这段逻辑在本地表现的代码如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/054/52.png" alt="52"></p><p>这里直接单步跟一下 657 号控制流，第 1、2 步 new 了一个方法。</p><p><img src="https://cdn.itbob.cn/img/article/054/53.png" alt="53"></p><p><img src="https://cdn.itbob.cn/img/article/054/54.png" alt="54"></p><p>这里就要注意了，容易跟丢，先进入 <code>_$bH</code> 方法打上断点，然后下一个断点就走到里面了，接着在单步调试，会进到另一个小的控制流里面，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/054/55.png" alt="55"></p><p><img src="https://cdn.itbob.cn/img/article/054/56.png" alt="56"></p><p>开始单步跟第 96 号小控制流，第 1 步定义了一个变量。</p><p><img src="https://cdn.itbob.cn/img/article/054/57.png" alt="57"></p><p>96 号小控制流，第 2 步将 <code>_$PI</code> 的值赋值给了 <code>_$fT</code>，而 <code>_$PI</code> 的值其实是 <code>window.localStorage.$_YWTU</code>，<code>window.localStorage</code> 里面有很多值，这个东西我们文章最后再讲，其中一些值与浏览器指纹相关，这里先知道他是取值就行了。</p><p><img src="https://cdn.itbob.cn/img/article/054/58.png" alt="58"></p><p>96 号小控制流，第 3 步，进入第 94 号小控制流，最终生成的是一个 8 位数组，这个其实就是前面我们想要的 <code>_$Yb</code> 的值了。</p><p><img src="https://cdn.itbob.cn/img/article/054/59.png" alt="59"></p><p>后面没有什么特别的，中间几步我就省略了，照着扣代码就行了，然后 96 号小控制流，第 4 步，就将 <code>_$EJ</code> 的值赋值给 <code>_$Yb</code> 了。</p><p><img src="https://cdn.itbob.cn/img/article/054/60.png" alt="60"></p><p>到这里先别急着结束，后面还有关键的几步，96 号小控制流，第 5 步，又遇到了和前面类似的写法。</p><p><img src="https://cdn.itbob.cn/img/article/054/61.png" alt="61"></p><p>同样的，先进 <code>_$pu</code> 打断点，再单步跟。</p><p><img src="https://cdn.itbob.cn/img/article/054/62.png" alt="62"></p><p>来到另一个小控制流，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/054/63.png" alt="63"></p><p>10 号小控制流第 1 步，取 <code>window.localStorage.$_cDro</code> 的值，转为 int 类型，赋值给 <code>_$5s</code>，这个 <code>_$5s</code> 后续也会加到 128 位大数组里面。</p><p><img src="https://cdn.itbob.cn/img/article/054/64.png" alt="64"></p><p>10 号小控制流后续还有几步，没啥用可以省略，最后一步返回 96 号小控制流。</p><p><img src="https://cdn.itbob.cn/img/article/054/65.png" alt="65"></p><p>然后 96 号小控制流后续也没啥了，返回 657 号控制流。</p><p><img src="https://cdn.itbob.cn/img/article/054/66.png" alt="66"></p><p>此时我们已经拿到  <code>_$Yb</code> 了，777 号控制流就先不管了，后续还有些代码先不管不用扣，等用到的时候再说，返回 279 号控制流，接着前面的步骤，来到第 17 步，变量 <code>_$5s</code> 经过 264 号控制流后，生成了一个值并添加到 128 位大数组里面，而 <code>_$5s</code> 的值正是前面我们跟 <code>_$Yb</code> 时，通过 777 号控制流拿到的，实际上也就是取 <code>window.localStorage.$_cDro</code> 的值，转为了 int 类型。</p><p><img src="https://cdn.itbob.cn/img/article/054/67.png" alt="67"></p><p>279 号控制流，第 18、19、20 步，往 128 位数组里面添加了两个定值、一个 8 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/68.png" alt="68"></p><p><img src="https://cdn.itbob.cn/img/article/054/69.png" alt="69"></p><p><img src="https://cdn.itbob.cn/img/article/054/70.png" alt="70"></p><p>279 号控制流，第 21 步，往 128 位数组里面添加了一个 <code>undefined</code> 占位，后续会有操作将其填充值。</p><p><img src="https://cdn.itbob.cn/img/article/054/71.png" alt="71"></p><p><img src="https://cdn.itbob.cn/img/article/054/72.png" alt="72"></p><p>279 号控制流，第 22 步，进入 58 号控制流，58 号控制流与 <code>window.localStorage.$_fb</code> 的值有关，如果有这个值，就会生成 20 位数组，如果没有就是 undefined。58 号控制流就只有一步，返回一个变量，本文中是 <code>_$0g</code>。</p><p><img src="https://cdn.itbob.cn/img/article/054/73.png" alt="73"></p><p><img src="https://cdn.itbob.cn/img/article/054/74.png" alt="74"></p><p>这个 <code>_$0g</code> 是咋来的呢？同样的直接搜索，下断点，发现是通过 112 号控制流得来的，往前跟栈，同样是先经过了 777 号控制流，和之前的情况类似，中间的过程就不看了，直接看这个 112 号控制流。</p><p><img src="https://cdn.itbob.cn/img/article/054/75.png" alt="75"></p><p>本文中，112 号控制流传的参是 <code>_$bd[279]</code> 即 <code>$_fb</code>，112 号控制流第 1 步，进入 247 号控制流。</p><p><img src="https://cdn.itbob.cn/img/article/054/76.png" alt="76"></p><p>247 号控制流就 3 步，先将 <code>window.localStorage</code> 赋值给一个变量，然后取其中 <code>$_fb</code> 的值再返回。</p><p><img src="https://cdn.itbob.cn/img/article/054/77.png" alt="77"></p><p><img src="https://cdn.itbob.cn/img/article/054/78.png" alt="78"></p><p><img src="https://cdn.itbob.cn/img/article/054/79.png" alt="79"></p><p>112 号控制流第 2、3 步，一个 <code>try-catch</code> 语句，取 <code>window.localStorage.$_fb</code> 计算得到 25 位数组，然后取前 20 位并返回，这就是前面我们需要的 <code>_$0g</code> 的值了。</p><p><img src="https://cdn.itbob.cn/img/article/054/80.png" alt="80"></p><p><img src="https://cdn.itbob.cn/img/article/054/81.png" alt="81"></p><p>279 号控制流，第 23 步，将前面 <code>window.localStorage.$_fb</code> 计算得到的 20 位数组添加到 128 位大数组里面，注意这一步如果没有 <code>window.localStorage.$_fb</code> 值的话，是不会添加的。</p><p><img src="https://cdn.itbob.cn/img/article/054/82.png" alt="82"></p><p>279 号控制流，第 24 步，对一个变量进行位运算，然后取 <code>window.localStorage.$_f0</code> 进行运算，如果 <code>$_f0</code> 为空的话是不会往 128 位大数组里添加值的。</p><p><img src="https://cdn.itbob.cn/img/article/054/83.png" alt="83"></p><p><img src="https://cdn.itbob.cn/img/article/054/84.png" alt="84"></p><p><img src="https://cdn.itbob.cn/img/article/054/85.png" alt="85"></p><p>279 号控制流，第 25 步，对一个变量进行位运算，然后取 <code>window.localStorage.$_fh0</code> 进行运算，如果 <code>$_fh0</code> 为空的话是不会往 128 位大数组里添加值的。</p><p><img src="https://cdn.itbob.cn/img/article/054/86.png" alt="86"></p><p><img src="https://cdn.itbob.cn/img/article/054/87.png" alt="87"></p><p><img src="https://cdn.itbob.cn/img/article/054/88.png" alt="88"></p><p>279 号控制流，第 26 步，对一个变量进行位运算，然后取 <code>window.localStorage.$_f1</code> 进行运算，如果 <code>$_f1</code> 为空的话是不会往 128 位大数组里添加值的。</p><p><img src="https://cdn.itbob.cn/img/article/054/89.png" alt="89"></p><p><img src="https://cdn.itbob.cn/img/article/054/90.png" alt="90"></p><p><img src="https://cdn.itbob.cn/img/article/054/91.png" alt="91"></p><p>279 号控制流，第 27 步，进入 611 号控制流，611 号控制流主要是检测 <code>window.navigator.connection.type</code>，即 <code>NetworkInformation</code> 网络相关信息，里面判断了 <code>type</code> 是不是 <code>bluetooth</code>、<code>cellular</code>、<code>ethernet</code>、<code>wifi</code>、<code>wimax</code>，正常的话应该返回 0。</p><p><img src="https://cdn.itbob.cn/img/article/054/92.png" alt="92"></p><p><img src="https://cdn.itbob.cn/img/article/054/93.png" alt="93"></p><p><img src="https://cdn.itbob.cn/img/article/054/94.png" alt="94"></p><p>279 号控制流，接下来几步都是类似的，这里就直接统称第 28 步了，首先对一个变量进行位运算，然后分别取 <code>window.localStorage.$_fr</code>、 <code>window.localStorage.$_fpn1</code> 、 <code>window.localStorage.$_vvCI</code>、 <code>window.localStorage.$_JQnh</code> 进行运算，同样如果这些变量为空的话，也是不会往 128 位大数组里添加值的。</p><p><img src="https://cdn.itbob.cn/img/article/054/96.png" alt="96"></p><p><img src="https://cdn.itbob.cn/img/article/054/97.png" alt="97"></p><p><img src="https://cdn.itbob.cn/img/article/054/98.png" alt="98"></p><p><img src="https://cdn.itbob.cn/img/article/054/99.png" alt="99"></p><p>279 号控制流，第 29 步，往 128 位大数组里添加了一个定值 4，本文中该变量名是 <code>_$kW</code>。</p><p><img src="https://cdn.itbob.cn/img/article/054/100.png" alt="100"></p><p><code>_$kW</code> 这个变量是咋来的，和前面的套路类似，直接搜索下断，同样是经过开头的 777 号控制流得来的，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/054/101.png" alt="101"></p><p>继续 279 号控制流，中间有一些变量位运算之类的就省略了，第 30、31 步，取了一个 <code>https:443</code> 的长度进行计算，先后往 128 位大数组里添加了一个定值和一个 9 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/102.png" alt="102"></p><p><img src="https://cdn.itbob.cn/img/article/054/103.png" alt="103"></p><p>279 号控制流，接下来几步都是在取值，都差不多，就统称为第 32 步了。</p><p><img src="https://cdn.itbob.cn/img/article/054/104.png" alt="104"></p><p><img src="https://cdn.itbob.cn/img/article/054/105.png" alt="105"></p><p><img src="https://cdn.itbob.cn/img/article/054/106.png" alt="106"></p><p><img src="https://cdn.itbob.cn/img/article/054/107.png" alt="107"></p><p><img src="https://cdn.itbob.cn/img/article/054/108.png" alt="108"></p><p><img src="https://cdn.itbob.cn/img/article/054/109.png" alt="109"></p><p>279 号控制流，第 33 步，之前 128 位大数组第 12 位是个 <code>undefined</code>，这里就将第 12 位填充上了一个 4 位数组，其中有个变量 <code>_$8L</code>，前面我们跟步骤的时候就有一个变量一直在做位运算，此处的 <code>_$8L</code> 就是这么来的。</p><p><img src="https://cdn.itbob.cn/img/article/054/110.png" alt="110"></p><p>279 号控制流，最后两步，原来的 128 位大数组，只取有值的前 21 位，一共有多少位与 <code>window.localStorage</code> 的某些值有关，有值的话就长一些，没有就短一些，然后再将数组的每个元素合并成最终的一个大数组并返回，279 号控制流就结束了。</p><p><img src="https://cdn.itbob.cn/img/article/054/111.png" alt="111"></p><p><img src="https://cdn.itbob.cn/img/article/054/112.png" alt="112"></p><p>返回到文章开头的逻辑，279 号控制流结束，返回到 742 号控制流，第 2 步，定义了一个变量并生成了一个 32 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/113.png" alt="113"></p><p><img src="https://cdn.itbob.cn/img/article/054/114.png" alt="114"></p><p>742 号控制流，第 3 步，取 <code>$_ts</code> 里面的某个值并赋值给一个变量。</p><p><img src="https://cdn.itbob.cn/img/article/054/115.png" alt="115"></p><p>742 号控制流，第 4 步，将前面 279 号控制流得到的大数组与上一步 <code>$_ts</code> 里面的某个值进行合并，合并后计算得到一个值。</p><p><img src="https://cdn.itbob.cn/img/article/054/116.png" alt="116"></p><p>742 号控制流，第 4 步，将上一步得到的值进一步计算得到一个 4 位数组，再将其和大数组合并。</p><p><img src="https://cdn.itbob.cn/img/article/054/117.png" alt="117"></p><p>742 号控制流，接下来几步是对时间戳进行各种操作，这里统称为第 5 步。</p><p><img src="https://cdn.itbob.cn/img/article/054/118.png" alt="118"></p><p><img src="https://cdn.itbob.cn/img/article/054/119.png" alt="119"></p><p><img src="https://cdn.itbob.cn/img/article/054/120.png" alt="120"></p><p><img src="https://cdn.itbob.cn/img/article/054/121.png" alt="121"></p><p>742 号控制流，第 6 步，将上一步得到的 4 个时间戳进行计算，得到一个 16 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/122.png" alt="122"></p><p>742 号控制流，第 7 步，将上一步得到的 16 位数组进行异或运算。</p><p><img src="https://cdn.itbob.cn/img/article/054/123.png" alt="123"></p><p>742 号控制流，第 8 步，将上一步的 16 位数组进行计算，得到一个字符串。</p><p><img src="https://cdn.itbob.cn/img/article/054/124.png" alt="124"></p><p>742 号控制流，第 9 步，正式生成 cookie 值，其中 <code>_$bd[274]</code> 定值，一般视为版本号，将上一步得到的字符串、之前得到的大数组和一个 32 位数组进行计算、组合，得到最终结果。</p><p><img src="https://cdn.itbob.cn/img/article/054/125.png" alt="125"></p><p>742 号控制流结束，返回 772 号控制流，利用了一个方法，组装 cookie，然后赋值给 <code>document.cookie</code>，整个流程就结束了。</p><p><img src="https://cdn.itbob.cn/img/article/054/126.png" alt="126"></p><p><img src="https://cdn.itbob.cn/img/article/054/127.png" alt="127"></p><p><img src="https://cdn.itbob.cn/img/article/054/128.png" alt="128"></p><p>代码中用到的 <code>$_ts</code> 的值需要我们自己去匹配出来，动态替换，这些步骤和 4 代是类似的，本文就不再重复叙述，可以参考 4 代的那篇逆向文章进行处理即可。</p><p><img src="https://cdn.itbob.cn/img/article/054/129.png" alt="129"></p><h2 id="后缀生成">后缀生成</h2><p>本例中，请求头中有个 sign 参数，Query String Parameters 有两个后缀参数，这两个后缀和 4 代类似，都是瑞数生成的。</p><p><img src="https://cdn.itbob.cn/img/article/054/130.png" alt="130"></p><p><img src="https://cdn.itbob.cn/img/article/054/131.png" alt="131"></p><p>和 4 代的处理方法一样，我们下一个 XHR 断点，先让网页加载完毕，然后打开开发者工具，过掉无限 debugger 后，点击搜索就会断下，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/054/132.png" alt="132"></p><p>往上跟栈到 <code>hasTokenGet</code>，是一个 sojson 旗下的 jsjiami v6 混淆，不值一提，重点是 <code>jsonMD5ToStr</code> 方法，先对传进去的参数做了一些编码处理，最后返回的是 <code>hex_md5</code>，和在线 MD5 加密的结果是一样的，说明是标准的 MD5。</p><p><img src="https://cdn.itbob.cn/img/article/054/133.png" alt="133"></p><p><img src="https://cdn.itbob.cn/img/article/054/134.png" alt="134"></p><p>重点来看瑞数的两个后缀生成方式，和 4 代一样，<code>XMLHttpRequest.send</code> 和 <code>XMLHttpRequest.open</code> 被重写了，如下图所示，在 <code>XMLHttpRequest.open</code> 下个断点，也就是图中的 <code>_$RQ</code> 方法，<code>arguments[1]</code> 就是原始 URL，经过图中的 <code>_$tB</code> 方法处理后就能拿到后缀。</p><p><img src="https://cdn.itbob.cn/img/article/054/135.png" alt="135"></p><p>跟进图中的 <code>_$tB</code> 方法，<code>_$tB</code> 方法里嵌套了一些其他方法，走一遍逻辑，到图中的 <code>_$5j</code> 方法里，前面的一部分都是在对传入的 URL 做处理。</p><p><img src="https://cdn.itbob.cn/img/article/054/136.png" alt="136"></p><p>接下来是生成了一个 16 位数组：</p><p><img src="https://cdn.itbob.cn/img/article/054/137.png" alt="137"></p><p>然后这个 16 位数组经过一个方法后就生成了第一个后缀，如下图所示，本文中这个方法是 <code>_$ZO</code>。</p><p><img src="https://cdn.itbob.cn/img/article/054/138.png" alt="138"></p><p>跟进 <code>_$ZO</code> 方法，主要有以下 5 步：</p><p>第 1 步：生成了一个 32 位数组；</p><p>第 2 步：将之前的 16 位数组以及两个变量拼接生成一个 50 位的数组；</p><p>第 3 步：进入 744 控制流，这里你会发现和之前我们跟 cookie 时的 742 号控制流是一样的，重复走了一遍，所以这里就不再跟了；</p><p>第 4 步：将生成的第一个后缀值进行处理，得到一个两位的字符串，这个字符串在获取第二个后缀的时候会用到；</p><p>第 5 步：将第一个后缀名称和值进行拼接并返回，此时，第一个后缀 <code>hKHnQfLv</code> 就生成了。</p><p><img src="https://cdn.itbob.cn/img/article/054/139.png" alt="139"></p><p>接着前面的 <code>_$5j</code> 方法，图中的 <code>_$5j</code> 这一步，就是获取第二个后缀 <code>8X7Yi61c</code> 的值：</p><p><img src="https://cdn.itbob.cn/img/article/054/140.png" alt="140"></p><p>主要是看一下图中的 <code>_$UM</code> 方法，先将前面生成的两位的字符串与 URL 参数进行拼接，然后会经过一个 <code>_$Nr</code> 方法就能得到第二个后缀的值了。</p><p><img src="https://cdn.itbob.cn/img/article/054/141.png" alt="141"></p><p>再来看一下 <code>_$Nr</code> 方法，先生成一个类似 53924 的值，然后一个 try 语句，注意这里有个方法，图中的 <code>_$Js</code> 方法，里面用到了 <code>$_ts</code> 里面的某个值，后面又生成了一个由数字组成的字符串，再次经过组合、计算后得到最终的值。</p><p><img src="https://cdn.itbob.cn/img/article/054/142.png" alt="142"></p><p><img src="https://cdn.itbob.cn/img/article/054/143.png" alt="143"></p><p>回到前面的 <code>_$UM</code> 方法，前缀 <code>8X7Yi61c</code> 与值组合，自此，两个后缀都拿到了：</p><p><img src="https://cdn.itbob.cn/img/article/054/144.png" alt="144"></p><h2 id="指纹生成">指纹生成</h2><p>我们前面已经分析了，在往 128 位数组里添加值的时候，会有取 <code>window.localStorage</code> 里面的某些值进行计算的步骤，这些值就是取浏览器 canvas 等指纹生成的，指纹随机就能并发，通常访问单独的一个 html 页面是不校验指纹的，生成的短 cookie 就能通过，但是一些查询数据接口会校验指纹，通过触发 load 事件来向 cookie 里添加指纹，使得 cookie 长度变长，怎么查找指纹在哪里生成的，这里推荐直接看视频资料，已经讲得很清楚了，篇幅太长，本文就不再赘述了，资料链接：<a href="https://mp.weixin.qq.com/s/DEUc1K8WaO_Cq1a2r0Ge5g">https://mp.weixin.qq.com/s/DEUc1K8WaO_Cq1a2r0Ge5g</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/javascript_reverse.png&quot; alt=&quot;javascript_reverse&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>国内 Web 防护天花板，瑞数 4 代 JS 逆向分析</title>
    <link href="https://www.itbob.cn/article/053/"/>
    <id>https://www.itbob.cn/article/053/</id>
    <published>2022-07-01T04:00:00.000Z</published>
    <updated>2022-11-02T15:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/javascript_reverse.png" alt="javascript_reverse"></p><h2 id="声明">声明</h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2 id="前言">前言</h2><p><img src="https://cdn.itbob.cn/img/article/053/01.png" alt="01"></p><p>瑞数动态安全 Botgate（机器人防火墙）以“动态安全”技术为核心，通过动态封装、动态验证、动态混淆、动态令牌等技术对服务器网页底层代码持续动态变换，增加服务器行为的“不可预测性”，实现了从用户端到服务器端的全方位“主动防护”，为各类 Web、HTML5 提供强大的安全保护。</p><p>瑞数 Botgate 多用于政企、金融、运营商行业，曾一度被视为反爬天花板，随着近年来逆向大佬越来越多，相关的逆向文章也层出不穷，真正到了人均瑞数的时代了，这里也感谢诸如 Nanda、懒神等逆向大佬，揭开了瑞数神秘的面纱，总结的经验让后来人少走了不少弯路。</p><p>过瑞数的方法基本上有以下几种：自动化工具（要隐藏特征值）、RPC 远程调用、JS 逆向（硬扣代码和补环境），本文介绍的是 JS 逆向硬扣代码，尽可能多的介绍各种细节。</p><h2 id="瑞数特征以及不同版本的区别">瑞数特征以及不同版本的区别</h2><p>对于绝大多数使用了瑞数的网站来说，有以下几点特征（可能有特殊版本不一样，先仅看主流的）：</p><p>1、打开开发者工具（F12）会依次出现两个典型的无限 debugger：</p><p><img src="https://cdn.itbob.cn/img/article/053/02.png" alt="02"></p><p><img src="https://cdn.itbob.cn/img/article/053/03.png" alt="03"></p><p>2、瑞数的 JS 混淆代码中，变量、方法名大多类似于 <code>_$xx</code>，有众多的 <code>if-else</code> 控制流，新版瑞数还可能会有 jsvmp 以及众多三目表达式的情况：</p><p><img src="https://cdn.itbob.cn/img/article/053/04.png" alt="04"></p><p>3、看请求，会有典型的三次请求，首次请求响应码是 202（瑞数3、4代）或者 412（瑞数5代），接着单独请求一个 JS 文件，然后再重新请求页面，后续的其他 XHR 请求中，都带有一个后缀，这个后缀的值是由 JS 生成的，每次都会变化，后缀的值第一个数字为瑞数的版本，比如 <code>MmEwMD=4xxxxx</code> 就是4代瑞数，<code>bX3Xf9nD=5xxxxx</code> 就是5代瑞数：</p><p><img src="https://cdn.itbob.cn/img/article/053/05.png" alt="05"></p><p><img src="https://cdn.itbob.cn/img/article/053/06.png" alt="06"></p><p><img src="https://cdn.itbob.cn/img/article/053/07.png" alt="07"></p><p><img src="https://cdn.itbob.cn/img/article/053/08.png" alt="08"></p><p>4、看 Cookie，瑞数 3、4 代有以 T 和 S 结尾的两个 Cookie，其中以 S 开头的 Cookie 是第一次的 201 那个请求返回的，以 T 开头的 Cookie 是由 JS 生成的，动态变化的，T 和 S 前面一般会跟 80 或 443 的数字，Cookie 值第一个数字为瑞数的版本（为什么可以通过第一个数字来判断版本？难道相同版本第一个数字不会变吗？这些问题我们在分析 JS 的时候可以找到答案），比如：</p><ul><li><code>FSSBBIl1UgzbN7N80T=37Na97B.nWX3....</code>：数字 80 是 http 协议的默认端口号，对应 http 请求，其值第一位为 3，表示 3 代瑞数；</li><li><code>FSSBBIl1UgzbN7N443T=4a.tr1kEXk.....</code>：数字 443 是 https 协议的默认端口号，对应 https 请求，其值第一位为 4，表示 4 代瑞数。</li></ul><p><img src="https://cdn.itbob.cn/img/article/053/09.png" alt="09"></p><p>瑞数 5 代也有以 T 和 S 结尾的两个 Cookie，但有些特殊的 5 代瑞数也有以 O 和 P 结尾的，同样的，以 O 开头的是第一次的 412 那个请求返回的，以 P 开头的是由 JS 生成的，Cookie 值第一个数字同样为瑞数的版本，和 3、4 代不同的是，5 代没有加端口号了，比如：</p><ul><li><code>vsKWUwn3HsfIO=57C6DwDUXS.....</code>：以 O 结尾，其值第一位为 5，表示 5 代瑞数；</li><li><code>WvY7XhIMu0fGT=53.9fybty......</code>：以 T 结尾，其值第一位为 5，表示 5 代瑞数。</li></ul><p><img src="https://cdn.itbob.cn/img/article/053/10.png" alt="10"></p><p><img src="https://cdn.itbob.cn/img/article/053/11.png" alt="11"></p><p>5、看入口，瑞数有个流程是在虚拟机 VM 中加载 1w+ 行的代码，加载此代码的入口，不同版本也不一样（这个入口具体在哪里？怎么定位？在后续逆向分析中再详细介绍），示例如下：</p><ul><li>3 代：<code>_$aW = _$c6[_$l6()](_$wc, _$mo);</code>，<code>_$c6</code> 实际上是 <code>eval</code>，<code>_$l6()</code> 实际上是 <code>call</code>；</li></ul><p><img src="https://cdn.itbob.cn/img/article/053/12.png" alt="12"></p><ul><li>4 代：<code>ret = _$DG.call(_$6a, _$YK);</code>，<code>_$DG</code> 实际上是 <code>eval</code>，有关键字 <code>ret</code>，<code>call</code> 是明文；</li></ul><p><img src="https://cdn.itbob.cn/img/article/053/13.png" alt="13"></p><ul><li>5 代：5 代种类比较多了，最初和 4 代的类似，比如 <code>ret = _$Yg.call(_$kc, _$mH);</code>，有关键字 ret，call 是明文，也有没有 ret 关键字的版本，比如 <code>_$ap = _$j5.call(_$_T, _$gp);</code>，也有像 3 代那样全部混淆了的，比如：<code>_$x8 = _$mP[_$nU[15]](_$z3, _$Ec);</code>，<code>_$mP</code> 实际上是 <code>eval</code>，<code>_$nU[15]</code> 实际上是 <code>call</code>，混淆的 <code>call</code> 与 3 代的区别就是 5 代是在一个数组里取值得到的；</li></ul><p><img src="https://cdn.itbob.cn/img/article/053/14.png" alt="14"></p><p><img src="https://cdn.itbob.cn/img/article/053/15.png" alt="15"></p><p><img src="https://cdn.itbob.cn/img/article/053/16.png" alt="16"></p><p>当然要想精准区分不同版本，得各个条件结合起来看，最主要的还是得看看内部的实现逻辑，以及页面的代码结构，比如 4 代有一个生成假 Cookie 的步骤，而 5 代没有，有的特殊版本虽然看起来是 5 代，但是加了 jsvmp 和三目表达式，和传统的 5 代又有区别，偶尔愚人节啥的突然来个新版本，也会不一样，各版本在分析一遍之后，就很容易区分了。</p><h2 id="Cookie-入口定位">Cookie 入口定位</h2><p>本文案例中瑞数 4 代网站为：<code>aHR0cDovL3d3dy5mYW5nZGkuY29tLmNuL25ld19ob3VzZS9uZXdfaG91c2VfZGV0YWlsLmh0bWw=</code></p><p>首先过掉无限 debugger（过不过其实无所谓，后面的分析其实这个基本上没影响），直接右键 <code>Never pause here</code> 永不在此处断下即可：</p><p><img src="https://cdn.itbob.cn/img/article/053/17.png" alt="17"></p><p>定位 Cookie，首选 Hook 来的最快，通过 Fiddler 等抓包工具、油猴脚本、浏览器插件等方式注入以下 Hook 代码：</p><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 严谨模式 检查所有错误</span><span class="hljs-meta">    &#x27;use strict&#x27;</span>;    <span class="hljs-comment">// document 为要hook的对象 这里是hook的cookie</span>    <span class="hljs-keyword">var</span> cookieTemp = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">document</span>, <span class="hljs-string">&#x27;cookie&#x27;</span>, &#123;        <span class="hljs-comment">// hook set方法也就是赋值的方法 </span>        <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;                <span class="hljs-comment">// 这样就可以快速给下面这个代码行下断点</span>                <span class="hljs-comment">// 从而快速定位设置cookie的代码</span>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hook捕获到cookie设置-&gt;&#x27;</span>, val);                <span class="hljs-keyword">debugger</span>;                cookieTemp = val;                <span class="hljs-keyword">return</span> val;        &#125;,        <span class="hljs-comment">// hook get 方法也就是取值的方法 </span>        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;            <span class="hljs-keyword">return</span> cookieTemp;        &#125;    &#125;);&#125;)();</code></pre><p>Hook 发现会有生成两次 Cookie 的情况，断下之后往上跟栈，可以看到组装 Cookie 的代码，类似如下结构：</p><p><img src="https://cdn.itbob.cn/img/article/053/18.png" alt="18"></p><p>仔细观察这两次 Cookie 生成的地方，分别往上跟栈，你就会发现两个 Cookie 分别是经过了两个不同方法得到的，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/053/19.png" alt="19"></p><p><img src="https://cdn.itbob.cn/img/article/053/20.png" alt="20"></p><p>这里的代码存在于 VM 虚拟机中，且是 IIFE 自执行代码，我们还得往前跟栈看看这些 VM 代码是从哪里加载出来的，跟栈来到首页（202页面）带有 call 的位置：</p><p><img src="https://cdn.itbob.cn/img/article/053/21.png" alt="21"></p><p>我们在文章开头介绍的这个位置就是这么分析得来的，这个位置通常在分析瑞数的时候作为入口，图中 <code>_$te</code> 实际上是 eval 方法，传入的第一个参数 <code>_$fY</code> 是 Window 对象，第二个对象 <code>_$F8</code> 是我们前面看到的 VM 虚拟机中的 IIFE 自执行代码。</p><p>在知道了瑞数大致的入口之后，我们也可以使用事件监听中的 Script 断点，一直下一个断点（F8）就可以走到 202 页面，然后搜索 call 关键字就能快速定位到入口，Script 断点中的两个选项，第一个表示运行 JS 脚本的第一条语句时断下，第二个表示 JS 因为内容安全政策而被屏蔽时断下，一般选择第一个就可以了，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/053/22.png" alt="22"></p><h2 id="文件结构与逻辑">文件结构与逻辑</h2><p>想要后续分析 Cookie 的生成，我们不得不要观察一下 202 页面的代码，meta 标签有个 content 内容，引用了一个类似于 <code>c.FxJzG50F.dfe1675.js</code> 的 JS 文件，接着跟一个自执行的 JS，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/053/23.png" alt="23"></p><p>第1部分 meta 标签的 content 内容，每次都是变化的，第2部分引用的这个外部 JS 在不同页面也有所差别，但是同一个网站同一个页面 JS 里的内容一般是固定不会变的，第3部分自执行代码每次变化的只是变量名，整体逻辑不变，后续我们在扣代码的时候，也会用到这里的部分方法。自执行代码里同样也是有很多 <code>if-else</code> 控制流，开头的那个数组，比如上图中的 <code>_$Dk</code> 就是用来控制后续的控制流的。</p><p>引用的 <code>c.FxJzG50F.dfe1675.js</code> 直接打开看是乱码的，而自执行 JS 的主要作用是将这 JS 乱码还原成 VM 里的 1w+ 行的正常代码，并且定义了一个全局变量 <code>window.$_ts</code> 并赋了许多值，这个变量在后续 VM 中作用非常大，meta 标签的 content 内容同样也会在 VM 里用到。</p><p>由于很多值、变量都是动态变化的，肯定不利于我们的分析，所以我们需要固定一套代码到本地，打断点、跟栈都会更加方便，随便保存一份 202 页面的代码，以及该页面对应的外链 JS 文件，如 <code>c.FxJzG50F.dfe1675.js</code> 到本地，使用浏览器自带的 overrides 重写功能、或者浏览器插件 ReRes、或者抓包工具的响应替换功能（如 Fiddler 的 AutoResponder）进行替换。</p><p><img src="https://cdn.itbob.cn/img/article/053/24.png" alt="24"></p><p>VM 里面的代码是生成 Cookie 的主要代码，包含众多的 <code>if-else</code> 控制流，无疑增加了我们分析代码的成本，这里就可以使用 AST 技术做一下反混淆，比如 Nanda 就将 <code>if-else</code> 控制流转换成了 <code>switch-case</code> 的，同一个控制流下的代码放在了同一个 <code>case</code> 下，然后在 <code>call</code> 入口那个地方，将 VM 代码做一下本地替换，具体可以参考 Nanda 的文章：<a href="https://mp.weixin.qq.com/s/r3FXjvT5Mm9Ikg_bDEadcw">《某数4代逻辑分析》</a>，感兴趣的可以试试，不了解 AST 的可以看看以前的文章<a href="https://mp.weixin.qq.com/s/fIbPuNMs5FRADJE5MOZXgA">《逆向进阶，利用 AST 技术还原 JavaScript 混淆代码》</a>，后续有时间再写写 AST 还原瑞数代码的实战，本文咱们选择硬刚！</p><p><img src="https://cdn.itbob.cn/img/article/053/25.jpg" alt="25"></p><h2 id="VM-代码以及-ts-变量获取">VM 代码以及 $_ts 变量获取</h2><p>前面我们了解了 VM 代码和 <code>$_ts</code> 的重要性，所以我们第一步是要想办法拿到他们，至于在什么时候有用到，文章后续再说，复制外链 JS，即  <code>c.FxJzG50F.dfe1675.js</code> 的代码和 202 页面的自执行代码到文件，本地直接运行即可，需要轻度补一下环境，缺啥补啥，大致补一下 window、location、document 就行了，补的具体内容可以直接在浏览器控制台使用 <code>copy()</code> 命令复制过来，然后 VM 代码我们就可以直接 Hook eval 的方式得到，大致的补环境代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> eval_js = <span class="hljs-string">&quot;&quot;</span><span class="hljs-built_in">window</span> = &#123;    <span class="hljs-attr">$_ts</span>:&#123;&#125;,    <span class="hljs-attr">eval</span>:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;        eval_js = data    &#125;&#125;location = &#123;    <span class="hljs-string">&quot;ancestorOrigins&quot;</span>: &#123;&#125;,    <span class="hljs-string">&quot;href&quot;</span>: <span class="hljs-string">&quot;http://www.脱敏处理.com.cn/new_house/new_house_detail.html&quot;</span>,    <span class="hljs-string">&quot;origin&quot;</span>: <span class="hljs-string">&quot;http://www.脱敏处理.com.cn&quot;</span>,    <span class="hljs-string">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;http:&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.com.cn&quot;</span>,    <span class="hljs-string">&quot;hostname&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.com.cn&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,    <span class="hljs-string">&quot;pathname&quot;</span>: <span class="hljs-string">&quot;/new_house/new_house_detail.html&quot;</span>,    <span class="hljs-string">&quot;search&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,    <span class="hljs-string">&quot;hash&quot;</span>: <span class="hljs-string">&quot;&quot;</span>&#125;<span class="hljs-built_in">document</span> = &#123;    <span class="hljs-string">&quot;scripts&quot;</span>: [<span class="hljs-string">&quot;script&quot;</span>, <span class="hljs-string">&quot;script&quot;</span>]&#125;</code></pre><p><img src="https://cdn.itbob.cn/img/article/053/25.png" alt="25"></p><p>观察 <code>$_ts</code> 的 key 和 value，和浏览器中得到的是一样的：</p><p><img src="https://cdn.itbob.cn/img/article/053/26.png" alt="26"></p><p>注意事项：<code>c.FxJzG50F.dfe1675.js</code> 外链 JS 如果你直接下载下来用编辑器打开可能会被自动编码，和原始数据有出入，导致运行报错，这里建议直接在浏览器在线访问这个文件，手动复制过来，或者在抓包软件里将响应内容复制过来，观察以下两种情况，第一种情况就可能会导致运行出错，第二种是正常的：</p><p><img src="https://cdn.itbob.cn/img/article/053/27.png" alt="27"></p><h2 id="扣代码">扣代码</h2><p>前面说了这么多，现在终于可以进入主题了，那就是扣代码，找个好椅子，准备把屁股坐穿，此时你的键盘只有 F11 有用，不断单步调试，只需要亿点点细节，就完事儿了！</p><p>扣代码步骤太多，不可能每一步都截图写出来，只写一下比较重要的，如有遗漏的地方，那也没办法，首先先在我们替换的 202 页面里，自执行代码开始的地方手动加个 debugger，一进入页面就断下，方便后续的分析：</p><p><img src="https://cdn.itbob.cn/img/article/053/28.png" alt="28"></p><p>通过前面我们的分析，已经知道了入口在 call 的地方，快速搜索并下断点：</p><p><img src="https://cdn.itbob.cn/img/article/053/29.png" alt="29"></p><p>通过前面我们的分析，我们也知道了有两次生成 Cookie 的地方，快速搜索 <code>(5)</code>，搜索结果第二个即为入口：</p><p><img src="https://cdn.itbob.cn/img/article/053/30.png" alt="30"></p><h3 id="假-Cookie-生成逻辑">假 Cookie 生成逻辑</h3><p>首先单步跟假 Cookie，虽然是假的，但是后续生成真 Cookie 中会用到，在跟的时候你会走到这个逻辑里面：</p><p><img src="https://cdn.itbob.cn/img/article/053/31.png" alt="31"></p><p>有一步会调用 <code>_$8e()</code> 方法，而 <code>_$8e = _$Q9</code>，<code>_$Q9</code> 又嵌套在 <code>_$d0</code> 里的，搜索一下哪里调用了 <code>_$d0</code>，发现是代码开头：</p><p><img src="https://cdn.itbob.cn/img/article/053/32.png" alt="32"></p><p>那么传入的参数 <code>_$Wn</code> 是啥呢？单步跟入，是一个方法，作用就是取 202 页面的 content 内容，那么我们在本地就直接删掉这个 <code>_$Wn</code> 方法，直接传入 content 的值即可，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/053/33.png" alt="33"></p><p>另外，我们发现，代码有非常多的在数组里面按索引取值的情况，比如上图中的 <code>_$PV[68]</code> 的值，实际上就是字符串 content，很显然我们要把这个数组的来源找到，直接搜索 <code>_$PV = </code>，可以找到疑似定义和赋值的地方：</p><p><img src="https://cdn.itbob.cn/img/article/053/34.png" alt="34"></p><p><img src="https://cdn.itbob.cn/img/article/053/35.png" alt="35"></p><p>所以我们得看看这个 <code>_$iL</code> 方法，传入了一个非常长的字符串，打断点进去看看，果然生成了 <code>_$PV</code>，是一个 725 位的数组：</p><p><img src="https://cdn.itbob.cn/img/article/053/36.png" alt="36"></p><p>接下来在扣代码的过程中，你会经常遇到一个变量，在本文中是 <code>_$sX</code>：</p><p><img src="https://cdn.itbob.cn/img/article/053/37.png" alt="37"></p><p>有没有很熟悉？这个值就是我们前面拿到的 <code>$_ts</code> 变量，在开头就可以看到是将 <code>window.$_ts</code> 赋值给了 <code>_$sX</code>：</p><p><img src="https://cdn.itbob.cn/img/article/053/38.png" alt="38"></p><p>继续走，会走到以下逻辑中：</p><p><img src="https://cdn.itbob.cn/img/article/053/39.png" alt="39"></p><p>这里会遇到六个数组，他们都已经有值了，所以我们得找到他们是咋来的，任意搜索其中一个数组名称，会找到定义和赋值的地方：</p><p><img src="https://cdn.itbob.cn/img/article/053/40.png" alt="40"></p><p><img src="https://cdn.itbob.cn/img/article/053/41.png" alt="41"></p><p>赋值明显是调用了 <code>_$rv</code> 方法，再搜 <code>_$rv</code> 方法，发现是开头就调用了：</p><p><img src="https://cdn.itbob.cn/img/article/053/42.png" alt="42"></p><p>后续没有什么特别的，一直单步，最后有个 <code>join('')</code> 操作，就生成了假 Cookie：</p><p><img src="https://cdn.itbob.cn/img/article/053/43.png" alt="43"></p><p>接下来是生成 Cookie 的名字 <code>FSSBBIl1UgzbN7N80T</code>，然后将 Cookie 赋值给 <code>document.cookie</code>，然后又向 <code>localStorage</code> 里面的 <code>$_ck</code> 赋了个值，<code>localStorage</code> 的内容可以直接复制下来，没有太大影响。</p><p><img src="https://cdn.itbob.cn/img/article/053/44.png" alt="44"></p><h3 id="真-Cookie-生成逻辑">真 Cookie 生成逻辑</h3><p>单步跟真 Cookie，在本文中也就是 <code>_$ZN(768, 1);</code>，可以看到开始进入了无穷无尽的 <code>if-else</code> 控制流：</p><p><img src="https://cdn.itbob.cn/img/article/053/45.png" alt="45"></p><p>这里本地应该怎样处理呢？我的做法是以 <code>_$Hn</code> 和其值命名函数，<code>function _$Hn768()&#123;&#125;</code> 就表示所有走 768 号控制流的方法，继续跟，生成真 Cookie 的方法基本上在 747 号控制流，后续我们主要以 747 号控制流的各个步骤来看，747 号控制流扣出来的代码大致如下：</p><p><img src="https://cdn.itbob.cn/img/article/053/46.png" alt="46"></p><h4 id="取假-Cookie">取假 Cookie</h4><p>单步跟 747 号控制流，会有个进入第 709 号控制流的步骤，会取先前生成的假 Cookie，经过一系列操作之后返回一个数组：</p><p><img src="https://cdn.itbob.cn/img/article/053/47.png" alt="47"></p><p><img src="https://cdn.itbob.cn/img/article/053/48.png" alt="48"></p><p>至此我们在本地同步扣的代码，如果正常的话，返回的数组也应该是一样的（后续的数据就不一样了，有一些时间戳之类的参数参与运算）：</p><p><img src="https://cdn.itbob.cn/img/article/053/49.png" alt="49"></p><h4 id="自动化工具检测">自动化工具检测</h4><p>继续跟 747 号控制流，会进入 268 号控制流，接着进入 154 号控制流，这里面会针对自动化工具做一些检测，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/053/50.png" alt="50"></p><p><img src="https://cdn.itbob.cn/img/article/053/51.png" alt="51"></p><p>这里定义了一个变量 <code>_$iL</code>，检测不通过就是1，后续又把这个变量赋值给了 <code>_$aW</code>，所以我们本地保持一致，也为 false 即可（其实我们不用自动化工具的话，这一段检测就不用管直接返回 false 就行）：</p><p><img src="https://cdn.itbob.cn/img/article/053/52.png" alt="52"></p><h4 id="20-位核心数组">20 位核心数组</h4><p>继续跟 268 号控制流，会进入 668 号控制流，668 号控制流就两个操作，一是生成一个 16 位数组，二是取 <code>$_ts</code> 里面的 4 个变量，加到前面的 16 位后面，组成一个 20 位数组，这 20 位数组的最后 4 位是瑞数核心，其中的映射关系搞错了请求是通不过的，在五代中这部分的处理逻辑会更加复杂。</p><p><img src="https://cdn.itbob.cn/img/article/053/53.png" alt="53"></p><p><img src="https://cdn.itbob.cn/img/article/053/54.png" alt="54"></p><p>这里不是单纯的取 <code>$_ts</code> 里的键值对，你在扣代码的时候，你也许会发现怎么本地到这里取值的时候，取出来的不是数字，而是字符串呢？就像下面这种情况：</p><p><img src="https://cdn.itbob.cn/img/article/053/55.png" alt="55"></p><p>实际上我们最开始得到的 <code>$_ts</code> 值，是经过了二次处理的，我们以第一个 <code>_$sX._$Xb</code> 为例，直接搜索 <code>_$sX._$Xb</code>，可以发现这么一个地方：</p><p><img src="https://cdn.itbob.cn/img/article/053/56.png" alt="56"></p><p>很明显这里给  <code>_$sX._$Xb</code> 重新赋值了一遍，我们可以看到等号右边，先取了一次 <code>_$sX._$Xb</code>，其值为 <code>_$Rm</code>，这和我们初始 <code>$_ts</code> 里面对应的值是一样的，然后我们就得再看看 <code>_$sX[&quot;_$Rm&quot;]</code> 又是何方神圣，直接搜索发现是开头赋值了一个方法，通过调用这个方法来生成新的值：</p><p><img src="https://cdn.itbob.cn/img/article/053/57.png" alt="57"></p><p>另外其他三个值也是同样的套路，赋值的代码分别为：</p><pre><code class="hljs javascript">_$sX._$Xb = _$sX[_$sX._$Xb](_$BH, _$DP);_$sX._$oI = _$sX[_$sX._$oI](_$ZJ, _$DS)_$sX._$EN = _$sX[_$sX._$EN]();_$sX._$D9 = _$sX[_$sX._$D9](_$iL);</code></pre><p>实际上应该是：</p><pre><code class="hljs javascript">_$sX._$Xb = _$sX[<span class="hljs-string">&quot;_$Rm&quot;</span>](_$BH, _$DP);_$sX._$oI = _$sX[<span class="hljs-string">&quot;_$Nw&quot;</span>](_$ZJ, _$DS)_$sX._$EN = _$sX[<span class="hljs-string">&quot;_$Uh&quot;</span>]();_$sX._$D9 = _$sX[<span class="hljs-string">&quot;_$ci&quot;</span>](_$iL);</code></pre><p>进一步来说，实际上是：</p><pre><code class="hljs javascript">_$sX._$Xb = _$1k(_$BH, _$DP);_$sX._$oI = _$jH(_$ZJ, _$DS)_$sX._$EN = _$9M();_$sX._$D9 = _$oL(_$iL);</code></pre><p>静态分析没问题，我们可以先固定下来，但是实际应用当中这些值都是动态的，那我们应该怎么处理呢？先来多看几个对比一下找找规律：</p><p><img src="https://cdn.itbob.cn/img/article/053/58.png" alt="58"></p><p><img src="https://cdn.itbob.cn/img/article/053/59.png" alt="59"></p><p>可以发现每次对应的位次都不一样，但是实际上相同位置的方法点进去都是一样的，也就是说，变的只有方法名和变量名，实现的逻辑是不变的，所以我们只要知道了这四个值分别对应的位置，就能够拿到正确的值，在本地，我们就可以这样做：</p><p>1、先利用正则匹配出这四个值，如：<code>[_$sX._$Xb, _$sX._$oI, _$sX._$EN, _$sX._$D9]</code>；</p><p><img src="https://cdn.itbob.cn/img/article/053/60.png" alt="60"></p><p>2、再匹配出 VM 代码开头的 20 个赋值的语句，如：<code>_$sX._$RH = _$wI; _$sX._$i5 = _$n5;</code> 等；</p><p><img src="https://cdn.itbob.cn/img/article/053/61.png" alt="61"></p><p>3、然后通过 <code>$_ts</code> 取这四个值对应的值，相当于：<code>_$sX._$Xb = _$ts._$Xb = _$Rm</code>；然后再找这四个值所定义的方法在 20 个赋值语句中的位置，相当于：查找 <code>_$sX._$Rm = _$1k; </code> 在 20 个赋值语句中的位置为 7（索引从 0 开始）</p><p><img src="https://cdn.itbob.cn/img/article/053/62.png" alt="62"></p><p>4、我们知道了这四个方法在 20 个赋值语句中的位置，那么我们直接匹配本地对应位置的名称，进行动态替换即可，当然前提是咱们本地已经扣了一套代码出来了：</p><p><img src="https://cdn.itbob.cn/img/article/053/63.png" alt="63"></p><p><img src="https://cdn.itbob.cn/img/article/053/64.png" alt="64"></p><p>经过这样处理后，就能够保证这四个值的准确性了。</p><h4 id="其他用到-ts-值的地方">其他用到 $_ts 值的地方</h4><p>除了上面说的 20 位数组里用到了 4 个 <code>$_ts</code> 的值以外，还有其他地方有 7 个值也用到了，直接搜索就能定位，这 7 个值相对较简单，每次都是固定取 <code>$_ts</code> 里面的第 2、3、4、15、16、17、19 位的值，同样的，找到对应位置，进行动态替换即可：</p><p><img src="https://cdn.itbob.cn/img/article/053/65.png" alt="65"></p><h3 id="注意事项">注意事项</h3><p>特别注意 VM 代码开头，会直接调用执行一些方法，某些变量的值就是通过这些方法生成的，当你一步一步跟的时候发现某些参数不对，或者没有，那么就得注意开头这些方法了，可能一开始就已经生成了。</p><p><img src="https://cdn.itbob.cn/img/article/053/66.png" alt="66"></p><h3 id="后缀-MmEwMD-生成逻辑">后缀 MmEwMD 生成逻辑</h3><p>后续的其他 XHR 请求中，都带有一个后缀，这个后缀的值同样是由 JS 生成的，每次都会变化，当然不同网站，后缀名不一定都是一样的，本例中是 <code>MmEwMD</code>，先下一个 XHR 断点，当 XHR 请求中包含了 <code>MmEwMD=</code> 时就断下，然后刷新网页：</p><p><img src="https://cdn.itbob.cn/img/article/053/67.png" alt="67"></p><p>可以看到后传入 <code>l.open()</code> 的 URL 还是正常的，断下后到 <code>l.send()</code> 就带有后缀了，再看 <code>l.open()</code> 其实就是 <code>xhr.open()</code>，明显和正常的有区别，同样这个方法也在 VM 代码里，应该是重写了方法，可以和正常的做对比：</p><p><img src="https://cdn.itbob.cn/img/article/053/68.png" alt="68"></p><p>跟到 VM 代码里去看看，经过了 <code>_$sd(arguments[1])</code> 方法就变成了带有后缀的完整链接了：</p><p><img src="https://cdn.itbob.cn/img/article/053/69.png" alt="69"></p><p>跟进 <code>_$sd</code> 方法，前面都是对 url 做一些处理，后面有个进入第 779 号控制流的流程，实际上就是原来我们生成 Cookie 的步骤，跟一下就行了。</p><p><img src="https://cdn.itbob.cn/img/article/053/70.png" alt="70"></p><h2 id="善用-Watch-跟踪功能">善用 Watch 跟踪功能</h2><p><img src="https://cdn.itbob.cn/img/article/053/71.png" alt="71"></p><p>开发者工具的 Watch 功能能够持续跟踪某个变量的值，对于这种控制流很多的情况，设置相应的变量跟踪，能够让你知道你现在处于哪个控制流中，以及生成的数组的变化，不至于跟着跟着不知道到哪一步了。</p><h2 id="结果验证">结果验证</h2><p>如果整个流程没问题，代码也扣得正确，携带正确的 Cookie 和正确的后缀，就能成功访问：</p><p><img src="https://cdn.itbob.cn/img/article/053/72.png" alt="72"></p><p><img src="https://cdn.itbob.cn/img/article/053/73.png" alt="73"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/javascript_reverse.png&quot; alt=&quot;javascript_reverse&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>AST 脱混淆实战，某 ICP 备案号查询接口 jsjiami v6 分析</title>
    <link href="https://www.itbob.cn/article/052/"/>
    <id>https://www.itbob.cn/article/052/</id>
    <published>2022-05-25T06:01:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/ast.png" alt="ast"></p><h2 id="声明">声明</h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2 id="逆向目标">逆向目标</h2><ul><li>目标：站 Z 之家网站 ICP 备案号查询</li><li>主页：<code>aHR0cDovL2ljcC5jaGluYXouY29tLw==</code></li><li>接口：<code>aHR0cDovL2ljcC5jaGluYXouY29tL2hvbWUvR2V0UGVyaW1pdEJ5SG9zdA==</code></li><li>逆向参数：<code>hostToken</code>、<code>permitToken</code></li></ul><p>本次主要是 AST 解混淆实战，本例中的 JS 混淆方式是 sojson 旗下的 jsjiami v6 版本，感兴趣的可以去官网体验一下：<a href="https://www.jsjiami.com/">https://www.jsjiami.com/</a> ，如果你还不了解 AST，可以先看看上期的文章（非常详细）：<a href="https://www.itbob.cn/article/051/">《逆向进阶，利用 AST 技术还原 JavaScript 混淆代码》</a>，本文部分 AST 还原代码直接使用了上期文章中的代码，所以细节方面不再赘述，有疑问的地方可以参考参考上期文章。</p><h2 id="第三方工具">第三方工具</h2><p>逆向领域大佬云集，市面上已经有很多大佬写好的解混淆工具了，除了我们自己手动去写 AST 解析代码以外，有时候直接使用工具会更加方便，当然并没有十全十美的工具，不过大部分情况下都能成功解混淆的，以下工具值得去体验一下：</p><ul><li>蔡老板一键还原 OB 混淆：<a href="https://github.com/Tsaiboss/decodeObfuscator">https://github.com/Tsaiboss/decodeObfuscator</a></li><li>哲哥 AST 混淆还原框架：<a href="https://github.com/sml2h3/ast_tools">https://github.com/sml2h3/ast_tools</a></li><li>V 神 Chrome 插件，内置 AST 混淆还原：<a href="https://github.com/cilame/v_jstools">https://github.com/cilame/v_jstools</a></li><li>jsjiami v6 专用解密工具：<a href="https://github.com/NXY666/JsjiamiV6-Decryptor">https://github.com/NXY666/JsjiamiV6-Decryptor</a></li></ul><h2 id="抓包分析">抓包分析</h2><p>进入主题，首先抓包看看，来到 ICP 备案查询页面，查询结果中，其他信息都可以直接在相应的 html 源码中找到，只有这个备案号是通过接口传过来的，对应的请求和相关加密参数如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/052/01.png" alt="01"></p><p><img src="https://cdn.itbob.cn/img/article/052/02.png" alt="02"></p><h2 id="加密定位">加密定位</h2><p>直接搜索关键字 <code>hostToken</code> 或者 <code>permitToken</code> 即可定位：</p><p><img src="https://cdn.itbob.cn/img/article/052/03.png" alt="03"></p><p><img src="https://cdn.itbob.cn/img/article/052/04.png" alt="04"></p><p>关键代码：</p><pre><code class="hljs javascript"><span class="hljs-string">&#x27;data&#x27;</span>: &#123;    <span class="hljs-string">&#x27;kw&#x27;</span>: kw,    <span class="hljs-string">&#x27;hostToken&#x27;</span>: _0x791532[<span class="hljs-string">&#x27;IIPmq&#x27;</span>](generateHostKey, kw),    <span class="hljs-string">&#x27;permitToken&#x27;</span>: _0x791532[_0x404f(<span class="hljs-string">&#x27;‫1df&#x27;</span>, <span class="hljs-string">&#x27;7Gn4&#x27;</span>)](generateWordKey, kw)&#125;</code></pre><p>这里的混淆可以手动跟一下，还原后如下：</p><pre><code class="hljs javascript"><span class="hljs-string">&#x27;data&#x27;</span>: &#123;    <span class="hljs-string">&#x27;kw&#x27;</span>: kw,    <span class="hljs-string">&#x27;hostToken&#x27;</span>: generateHostKey(kw),    <span class="hljs-string">&#x27;permitToken&#x27;</span>: generateWordKey(kw)&#125;</code></pre><p><code>kw</code> 是查询的域名，有用的就是 <code>generateHostKey()</code> 和 <code>generateWordKey()</code> 两个方法了，跟进去看，代码经过了 jsjiami v6 混淆：</p><p><img src="https://cdn.itbob.cn/img/article/052/05.png" alt="05"></p><p><img src="https://cdn.itbob.cn/img/article/052/06.png" alt="06"></p><p><img src="https://cdn.itbob.cn/img/article/052/07.png" alt="07"></p><h2 id="AST-脱混淆">AST 脱混淆</h2><p>jsjiami 混淆的特征其实和 OB 混淆是类似的：</p><ol><li>一般由一个大数组或者含有大数组的函数、一个数组位移操作的自执行函数、一个解密函数和加密后的函数四部分组成；</li><li>函数名和变量名通常以 _0x 或者 0x 开头，后接 1~6 位数字或字母组合；</li><li>数组位移操作的自执行函数里，有明显的 push、shift 关键字。</li></ol><p>本例中，<code>generateHostKey()</code> 方法在 <code>commo.js</code> 里，<code>generateWordKey()</code> 方法在 <code>generatetoken.js</code> 里，结构如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/052/08.png" alt="08"></p><p>观察 <code>generatetoken.js</code> 文件，可以发现这里面也有 <code>commo.js</code> 里面的 <code>generateHostKey()</code> 和 <code>getRandom()</code> 方法，从方法名来看貌似是重复了，实际上混淆还原后方法是一样的，所以这里我们只需要还原 <code>generatetoken.js</code> 就可以了。</p><h3 id="文件结构">文件结构</h3><ul><li>混淆 JS 文件：<code>generatetoken.js</code></li><li>AST 还原代码：<code>generatetokenAst.js</code></li><li>还原后的代码：<code>generatetokenNew.js</code></li></ul><h3 id="解密函数还原">解密函数还原</h3><p>在原来混淆后的 JS 里，解密函数是 <code>_0x530e</code>，首先观察整个 JS，调用了很多次解密函数，类似于：<code>_0x530e('1', '7XEq')</code>。</p><p>注意这里代码里面有一些特殊字符，类似于 <code>RLE</code>、<code>RLO</code> 之类的，如果在 VSCode 打开是一些 <code>U+202B</code>、<code>U+202E</code> 的字符，实际上这是 RTLO (Right-to-Left Override) 字符，<code>U+202B</code> 和 <code>U+202E</code> 的意思分别是根据内存顺序从左至右和从右至左显示字符，感兴趣的可以网上搜索了解一下。这里并不影响我们进行还原操作。但是如果直接复制过来的话就会导致前后文显示的顺序不对，所以本文中为了方便描述，粘贴的部分代码就手动去掉了这些字符。</p><p><img src="https://cdn.itbob.cn/img/article/052/09.png" alt="09"></p><p><img src="https://cdn.itbob.cn/img/article/052/10.png" alt="10"></p><p>所以第一步我们要还原一下解密函数，把所有 <code>_0x530e</code> 调用的地方直接替换成实际值，首先需要将大数组、自执行函数、加密函数和解密函数分割开，将代码放到 <a href="http://astexplorer.net">astexplorer.net</a> 看一下，也就是将 body 的前四部分和后面剩余部分分割开来，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/052/11.png" alt="11"></p><p>分割代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<span class="hljs-keyword">const</span> parse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>).parse;<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)<span class="hljs-comment">// 导入混淆代码并解析为 AST</span><span class="hljs-keyword">const</span> oldCode = fs.readFileSync(<span class="hljs-string">&quot;generatetoken.js&quot;</span>, &#123;<span class="hljs-attr">encoding</span>: <span class="hljs-string">&quot;utf-8&quot;</span>&#125;);<span class="hljs-keyword">const</span> astCode = parse(oldCode);<span class="hljs-comment">// 获取整个 AST 节点的长度</span><span class="hljs-keyword">let</span> astCodeLength = astCode.program.body.length<span class="hljs-comment">// 获取解密函数的名字 也就是 _0x530e</span><span class="hljs-keyword">let</span> decryptFunctionName = astCode.program.body[<span class="hljs-number">3</span>].id.name<span class="hljs-comment">// 分割加密函数和解密函数，即 body 的前四部分和后面剩余部分</span><span class="hljs-keyword">let</span> decryptFunction = astCode.program.body.slice(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>)<span class="hljs-keyword">let</span> encryptFunction = astCode.program.body.slice(<span class="hljs-number">4</span>, astCodeLength)<span class="hljs-comment">// 获取加密函数和解密函数的方法多种多样，比如可以挨个取值并转换成 JS 代码</span><span class="hljs-comment">// 这样做就不需要将解密函数赋值给整个 AST 节点了</span><span class="hljs-comment">// let decryptFunction = &quot;&quot;;</span><span class="hljs-comment">// for(let i=0; i&lt;4; i++)&#123;</span><span class="hljs-comment">//     decryptFunction += generate(astCode.program.body[i], &#123;compact: true&#125;).code</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// eval(decryptFunction);</span></code></pre><p>在上面的获取加密函数和解密函数的代码中，方法不是唯一的，多种多样，比如直接循环取 body 并转换成 JS 代码，比如直接人工把大数组、自执行函数和解密函数三部分，拿出来放到一个新文件里，然后导出解密方法，后续直接调用也可以。</p><p>在本例中，拿到解密函数后，需要将其赋值给整个 AST 节点，然后再将整个 AST 节点转换成 JavaScript 代码，这里注意有可能会检测代码是否格式化，所以建议转换要加一个 <code>compact</code> 参数，避免格式化，转换完成后 <code>eval</code> 执行一下，让数组位移操作完成，然后我们就可以直接调用解密函数，即 <code>_0x530e()</code>。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 将解密函数赋值给整个 AST 节点</span>astCode.program.body = decryptFunction<span class="hljs-comment">// 将 AST 节点转换成 JS 代码，并 eval 执行一下</span>decryptFunction = generate(astCode, &#123;<span class="hljs-attr">compact</span>: <span class="hljs-literal">true</span>&#125;).code<span class="hljs-built_in">eval</span>(decryptFunction);<span class="hljs-comment">// 测试一下，直接调用 _0x530e 函数可以正确拿到结果</span><span class="hljs-comment">// 输出 split</span><span class="hljs-comment">// console.log(_0x530e(&#x27;‮b&#x27;, &#x27;Zp9G&#x27;))</span></code></pre><p>现在我们能直接调用解密函数 <code>_0x530e()</code> 了，接下来要做的就是怎么把混淆代码中所有调用 <code>_0x530e()</code> 的地方替换成真实值，在此之前，我们要把加密函数（<code>generateKey()</code>、<code>generateHostKey()</code>、<code>generateWordKey()</code> 和 <code>getRandom()</code>）赋值给整个 AST 节点，此时整个节点就没有大数组、自执行函数和解密函数了，解密函数 <code>_0x530e()</code> 已经被写入内存，所以后面不影响我们调用。</p><p>老样子，还是先在 <a href="http://astexplorer.net">astexplorer.net</a> 看一下调用 <code>_0x530e()</code> 的地方，以 <code>_0x530e('b', 'Zp9G')</code> 为例，其真实值应该是 <code>split</code>，对比一下替换前后的结构，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/052/12.png" alt="12"></p><p><img src="https://cdn.itbob.cn/img/article/052/13.png" alt="13"></p><p>可以看到节点由原来的 <code>CallExpression</code> 变成了 <code>StringLiteral</code>，所以我们可以遍历 <code>CallExpression</code>，如果函数名为解密函数名，那就通过 <code>path.toString()</code> 方法获取节点源码，也就类似 <code>_0x530e('b', 'Zp9G')</code> 的源码，然后 <code>eval</code> 执行一下获取其真实值，再使用 <code>types.stringLiteral()</code> 构建 <code>StringLiteral</code> 节点，最后通过 <code>path.replaceInline()</code> 方法替换节点，遍历代码如下：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 将加密函数赋值给整个 AST 节点，此时整个节点就没有大数组、自执行函数和解密函数了</span>astCode.program.body = encryptFunction<span class="hljs-comment">// 调用解密函数，直接计算出类似以下方法的值并替换</span><span class="hljs-comment">// 混淆代码：_0x530e(&#x27;‮b&#x27;, &#x27;Zp9G&#x27;)</span><span class="hljs-comment">// 还原后：split</span><span class="hljs-keyword">const</span> visitor1 = &#123;    <span class="hljs-function"><span class="hljs-title">CallExpression</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">if</span> (path.node.callee.name === decryptFunctionName &amp;&amp; path.node.arguments.length === <span class="hljs-number">2</span>)&#123;            path.replaceInline(types.stringLiteral(<span class="hljs-built_in">eval</span>(path.toString())))        &#125;    &#125;&#125;<span class="hljs-comment">// 遍历节点</span>traverse(astCode, visitor1)<span class="hljs-comment">// 将 AST 节点转换成 JS 代码并写入到新文件里</span><span class="hljs-keyword">const</span> result = generate(astCode, &#123;<span class="hljs-attr">concise</span>:<span class="hljs-literal">true</span>&#125;).codefs.writeFile(<span class="hljs-string">&quot;./generatetokenNew.js&quot;</span>, result, (<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(err)&#125;))</code></pre><p>自此，第一步的解密函数还原就完成了，可以看一下还原前后的对比，如下图所示浅蓝色标记的地方，所有调用 <code>_0x530e()</code> 的地方都被还原了：</p><p><img src="https://cdn.itbob.cn/img/article/052/14.png" alt="14"></p><h3 id="大对象还原">大对象还原</h3><p>初步还原后我们的代码里就只剩下以下四个方法：</p><ul><li><code>generateKey()</code></li><li><code>generateHostKey()</code></li><li><code>generateWordKey()</code></li><li><code>getRandom()</code></li></ul><p>再观察代码，发现每个方法一开始都有个大的对象，他们分别是：</p><ul><li><code>_0x3b79c6</code></li><li><code>_0x278b2d</code></li><li><code>_0x4115c4</code></li><li><code>_0xd8ec33</code></li></ul><p>后续的代码也在不断调用这个对象的方法，比如 <code>_0x3b79c6[&quot;esdtg&quot;](_0x2e5848[&quot;length&quot;], 0x4)</code> 实际上就是 <code>_0x2e5848[&quot;length&quot;] != 0x4</code>，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/052/15.png" alt="15"></p><p>首先我们将这四个大的对象单独提取出来，还是保持原来的键值对样式，提取完成后删除这两个节点，遍历代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> functionName = &#123;    <span class="hljs-string">&quot;_0x3b79c6&quot;</span>: &#123;&#125;,    <span class="hljs-string">&quot;_0x278b2d&quot;</span>: &#123;&#125;,    <span class="hljs-string">&quot;_0x4115c4&quot;</span>: &#123;&#125;,    <span class="hljs-string">&quot;_0xd8ec33&quot;</span>: &#123;&#125;&#125;<span class="hljs-comment">// 单独提取出四个大对象</span><span class="hljs-keyword">const</span> visitor2 = &#123;    <span class="hljs-function"><span class="hljs-title">VariableDeclarator</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> functionName)&#123;            <span class="hljs-keyword">if</span> (path.node &amp;&amp; path.node.id.name == key) &#123;                <span class="hljs-keyword">const</span> properties = path.node.init.properties                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;properties.length; i++)&#123;                    functionName[key][properties[i].key.value] = properties[i].value                &#125;                <span class="hljs-comment">// 写入对象后就可以删除该节点了</span>                path.remove()            &#125;        &#125;    &#125;&#125;</code></pre><p>这里要注意，大的对象里面，有 <code>+</code>、<code>-</code>、<code>==</code> 之类的二项式计算，也有直接为字符串的，还有变成函数调用的，如下所示：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> _0x3b79c6 = &#123;    <span class="hljs-string">&#x27;MuRlB&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_0x3ca134, _0x50ee94</span>) </span>&#123;        <span class="hljs-keyword">return</span> _0x3ca134 + _0x50ee94;    &#125;,     <span class="hljs-string">&#x27;Ucwyj&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_0x32bfa3, _0x3b191b</span>) </span>&#123;        <span class="hljs-keyword">return</span> _0x32bfa3(_0x3b191b);    &#125;,     <span class="hljs-string">&#x27;YrYQW&#x27;</span>: <span class="hljs-string">&#x27;#IpValue&#x27;</span>&#125;</code></pre><p>针对不同的情况有不同的处理方法，同时还要注意传参和 return 返回的参数位置，不要还原后把 <code>a - b</code> 搞成 <code>b - a</code> 了，当然在本例中传入和返回的顺序是一样的，就不需要考虑这个问题。</p><h4 id="字符串还原">字符串还原</h4><p>首先来看字符串，有以下几种情况：</p><ul><li>以 <code>_0x3b79c6['YrYQW']</code> 为例，实际上其值为字符串 <code>'#IpValue'</code>，观察其结构，是一个 <code>MemberExpression</code>，在一个列表里；</li><li>以 <code>_0x278b2d['pjbyX']</code> 为例，实际上其值为字符串 <code>'3|2|1|4|5|0|6'</code>，观察其结构，是一个 <code>MemberExpression</code>，在一个字典里；</li><li>以 <code>_0x278b2d['CnTaO']</code> 为例，虽然也是一个 <code>MemberExpression</code>，也在一个字典里。但实际上是二项式计算，所以要排除在外。</li></ul><p><img src="https://cdn.itbob.cn/img/article/052/16.png" alt="16"></p><p><img src="https://cdn.itbob.cn/img/article/052/17.png" alt="17"></p><p><img src="https://cdn.itbob.cn/img/article/052/18.png" alt="18"></p><p>所以我们在写遍历代码时，同时要注意这三种情况，满足条件后直接取原来大对象对应的节点进行替换即可，遍历代码如下所示：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 函数替换，字符串替换：将类似 _0x3b79c6[&#x27;YrYQW&#x27;] 变成 &#x27;#IpValue&#x27;</span><span class="hljs-keyword">const</span> visitor3 = &#123;    <span class="hljs-function"><span class="hljs-title">MemberExpression</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> functionName)&#123;            <span class="hljs-keyword">if</span> (path.node.object &amp;&amp; path.node.object.name == key &amp;&amp; path.inList ) &#123;                path.replaceInline(functionName[key][path.node.property.value])            &#125;            <span class="hljs-keyword">if</span> (path.node.object &amp;&amp; path.node.object.name == key &amp;&amp; path.parent.property &amp;&amp; path.parent.property.value == <span class="hljs-string">&quot;split&quot;</span>) &#123;                path.replaceInline(functionName[key][path.node.property.value])            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="二项式计算替换">二项式计算替换</h4><p>再来看看二项式计算的情况，以 <code>_0x278b2d['CnTaO'](_0x691267[&quot;length&quot;], 0x1)</code> 为例，实际上是做减法运算，即 <code>_0x691267[&quot;length&quot;] - 0x1</code>，看一下替换前后对比：</p><p><img src="https://cdn.itbob.cn/img/article/052/19.png" alt="19"></p><p><img src="https://cdn.itbob.cn/img/article/052/20.png" alt="20"></p><p>对于这种情况，我们可以直接提取两个参数，然后提取大对象里对应方法的操作符，然后将参数和操作符直接连接起来组成新的节点（<code>binaryExpression</code>）并替换即可，遍历代码如下：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 函数替换，二项式计算：将类似 _0x278b2d[&#x27;CnTaO&#x27;](_0x691267[&quot;length&quot;], 0x1) 变成 _0x691267[&quot;length&quot;] - 0x1</span><span class="hljs-keyword">const</span> visitor4 = &#123;    <span class="hljs-function"><span class="hljs-title">CallExpression</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> functionName) &#123;            <span class="hljs-keyword">if</span> (path.node.callee &amp;&amp; path.node.callee.object &amp;&amp; path.node.callee.object.name == key) &#123;                <span class="hljs-keyword">let</span> func = functionName[key][path.node.callee.property.value]                <span class="hljs-keyword">if</span> (func.body.body[<span class="hljs-number">0</span>].argument.type == <span class="hljs-string">&quot;BinaryExpression&quot;</span>) &#123;                    <span class="hljs-keyword">let</span> operator = func.body.body[<span class="hljs-number">0</span>].argument.operator                    <span class="hljs-keyword">let</span> left = path.node.arguments[<span class="hljs-number">0</span>]                    <span class="hljs-keyword">let</span> right = path.node.arguments[<span class="hljs-number">1</span>]                    path.replaceInline(types.binaryExpression(operator, left, right))                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="方法调用还原">方法调用还原</h4><p>以 <code>_0x4115c4[&quot;PJbSm&quot;](getRandom, 0x64, 0x3e7)</code> 为例，实际上是 <code>getRandom(0x64, 0x3e7)</code>，看一下替换前后对比：</p><p><img src="https://cdn.itbob.cn/img/article/052/21.png" alt="21"></p><p><img src="https://cdn.itbob.cn/img/article/052/22.png" alt="22"></p><p>对于这种情况，传入的第一个参数为方法名称，后面的都是参数，那么可以直接取第一个元素为方法名称，使用 <code>slice(1)</code> 方法取后面所有的参数（因为后面的参数个数是不一定的），然后构造新的节点（<code>callExpression</code>）并替换即可，这部分遍历代码可以和前面二项式的替换相结合，代码如下：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 函数替换，二项式计算：将类似 _0x278b2d[&#x27;CnTaO&#x27;](_0x691267[&quot;length&quot;], 0x1) 变成 _0x691267[&quot;length&quot;] - 0x1</span><span class="hljs-comment">// 函数替换，方法调用：将类似 _0x4115c4[&quot;PJbSm&quot;](getRandom, 0x64, 0x3e7) 变成 getRandom(0x64, 0x3e7)</span><span class="hljs-keyword">const</span> visitor4 = &#123;    <span class="hljs-function"><span class="hljs-title">CallExpression</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> functionName) &#123;            <span class="hljs-keyword">if</span> (path.node.callee &amp;&amp; path.node.callee.object &amp;&amp; path.node.callee.object.name == key) &#123;                <span class="hljs-keyword">let</span> func = functionName[key][path.node.callee.property.value]                <span class="hljs-keyword">if</span> (func.body.body[<span class="hljs-number">0</span>].argument.type == <span class="hljs-string">&quot;BinaryExpression&quot;</span>) &#123;                    <span class="hljs-keyword">let</span> operator = func.body.body[<span class="hljs-number">0</span>].argument.operator                    <span class="hljs-keyword">let</span> left = path.node.arguments[<span class="hljs-number">0</span>]                    <span class="hljs-keyword">let</span> right = path.node.arguments[<span class="hljs-number">1</span>]                    path.replaceInline(types.binaryExpression(operator, left, right))                &#125;                <span class="hljs-keyword">if</span> (func.body.body[<span class="hljs-number">0</span>].argument.type == <span class="hljs-string">&quot;CallExpression&quot;</span>) &#123;                    <span class="hljs-keyword">let</span> identifier = path.node.arguments[<span class="hljs-number">0</span>]                    <span class="hljs-keyword">let</span> <span class="hljs-built_in">arguments</span> = path.node.arguments.slice(<span class="hljs-number">1</span>)                    path.replaceInline(types.callExpression(identifier, <span class="hljs-built_in">arguments</span>))                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>自此，第二步的大对象还原就完成了，可以看一下还原前后的对比，如下图所示浅蓝色标记的地方，所有调用四个大对象（<code>_0x3b79c6</code>、<code>_0x278b2d</code>、<code>_0x4115c4</code>、<code>_0xd8ec33</code>）的地方都被还原了：</p><p><img src="https://cdn.itbob.cn/img/article/052/23.png" alt="23"></p><h3 id="switch-case-反控制流平坦化">switch-case 反控制流平坦化</h3><p>经过前面几步的还原之后，我们发现 <code>generateHostKey()</code>、<code>generateWordKey()</code>、<code>getRandom()</code> 方法里都有一个 <code>switch-case</code> 的控制流，关于反控制流平坦化的讲解在我上期文章有很详细的介绍，不理解的可以看看上期文章，此处也不再赘述了，直接贴代码了：</p><pre><code class="hljs javascript"><span class="hljs-comment">// switch-case 反控制流平坦化</span><span class="hljs-keyword">const</span> visitor5 = &#123;    <span class="hljs-function"><span class="hljs-title">WhileStatement</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-comment">// switch 节点</span>        <span class="hljs-keyword">let</span> switchNode = path.node.body.body[<span class="hljs-number">0</span>];        <span class="hljs-comment">// switch 语句内的控制流数组名，本例中是 _0x28073a、_0x2efb35、_0x187fb8</span>        <span class="hljs-keyword">let</span> arrayName = switchNode.discriminant.object.name;        <span class="hljs-comment">// 获取控制流数组绑定的节点</span>        <span class="hljs-keyword">let</span> bindingArray = path.scope.getBinding(arrayName);        <span class="hljs-comment">// 获取节点整个表达式的参数、分割方法、分隔符</span>        <span class="hljs-keyword">let</span> init = bindingArray.path.node.init;        <span class="hljs-keyword">let</span> object = init.callee.object.value;        <span class="hljs-keyword">let</span> property = init.callee.property.value;        <span class="hljs-keyword">let</span> argument = init.arguments[<span class="hljs-number">0</span>].value;        <span class="hljs-comment">// 模拟执行 &#x27;3|2|1|4|5|0|6&#x27;[&#x27;split&#x27;](&#x27;|&#x27;) 语句</span>        <span class="hljs-keyword">let</span> array = object[property](argument)        <span class="hljs-comment">// 也可以直接取参数进行分割，方法不通用，比如分隔符换成 , 就不行了</span>        <span class="hljs-comment">// let array = init.callee.object.value.split(&#x27;|&#x27;);</span>        <span class="hljs-comment">// switch 语句内的控制流自增变量名，本例中是 _0x38c69e、_0x396880、_0x3b3dc7</span>        <span class="hljs-keyword">let</span> autoIncrementName = switchNode.discriminant.property.argument.name;        <span class="hljs-comment">// 获取控制流自增变量名绑定的节点</span>        <span class="hljs-keyword">let</span> bindingAutoIncrement = path.scope.getBinding(autoIncrementName);        <span class="hljs-comment">// 可选择的操作：删除控制流数组绑定的节点、自增变量名绑定的节点</span>        bindingArray.path.remove();        bindingAutoIncrement.path.remove();        <span class="hljs-comment">// 储存正确顺序的控制流语句</span>        <span class="hljs-keyword">let</span> replace = [];        <span class="hljs-comment">// 遍历控制流数组，按正确顺序取 case 内容</span>        array.forEach(<span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;                <span class="hljs-keyword">let</span> consequent = switchNode.cases[index].consequent;                <span class="hljs-comment">// 如果最后一个节点是 continue 语句，则删除 ContinueStatement 节点</span>                <span class="hljs-keyword">if</span> (types.isContinueStatement(consequent[consequent.length - <span class="hljs-number">1</span>])) &#123;                    consequent.pop();                &#125;                <span class="hljs-comment">// concat 方法拼接多个数组，即正确顺序的 case 内容</span>                replace = replace.concat(consequent);            &#125;        );        <span class="hljs-comment">// 替换整个 while 节点，两种方法都可以</span>        path.replaceWithMultiple(replace);        <span class="hljs-comment">// path.replaceInline(replace);</span>    &#125;&#125;</code></pre><h3 id="其他细节还原">其他细节还原</h3><p>到这里其实大部分混淆都已经还原了，已经很容易分析其逻辑了，还剩下一些细节，我们也还原一下，主要有以下细节：</p><ul><li>十六进制、Unicode 编码等，转正常字符；</li><li>对象属性还原，比如 <code>_0x3cbc20['length']</code> 转换成 <code>_0x3cbc20.length</code>；</li><li>表达式还原，比如 <code>!![]</code> 直接计算成 true；</li><li>删除未引用的变量，比如 <code>_0xodD= &quot;jsjiami.com.v6&quot;;</code>；</li><li>删除冗余逻辑代码，只保留 if 为 true 的。</li></ul><p>这些还原代码在我上期文章有详细讲过，结合代码，在 <a href="http://astexplorer.net">astexplorer.net</a> 对照其结构看，也能理解，同样也不赘述了，直接贴代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor5 = &#123;    <span class="hljs-comment">// 十六进制、Unicode 编码等，转正常字符</span>    <span class="hljs-string">&quot;StringLiteral|NumericLiteral&quot;</span>(path)&#123;        <span class="hljs-keyword">delete</span> path.node.extra;    &#125;,    <span class="hljs-comment">// _0x3cbc20[&quot;length&quot;] 转换成 _0x3cbc20.length</span>    <span class="hljs-function"><span class="hljs-title">MemberExpression</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">if</span> (path.node.property.type == <span class="hljs-string">&quot;StringLiteral&quot;</span>) &#123;            path.node.computed = <span class="hljs-literal">false</span>            path.node.property = types.identifier(path.node.property.value)        &#125;    &#125;,    <span class="hljs-comment">// 表达式还原，!![] 直接计算成 true</span>    <span class="hljs-string">&quot;BinaryExpression|UnaryExpression&quot;</span>(path) &#123;        <span class="hljs-keyword">let</span> &#123;confident, value&#125; = path.evaluate()        <span class="hljs-keyword">if</span> (confident)&#123;            path.replaceInline(types.valueToNode(value))        &#125;    &#125;,    <span class="hljs-comment">// 删除未引用的变量，比如 _0xodD = &quot;jsjiami.com.v6&quot;;</span>    <span class="hljs-function"><span class="hljs-title">AssignmentExpression</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">let</span> binding = path.scope.getBinding(path.node.left.name);        <span class="hljs-keyword">if</span> (!binding) &#123;            path.remove();        &#125;    &#125;&#125;<span class="hljs-comment">// 删除冗余逻辑代码，只保留 if 为 true 的</span><span class="hljs-keyword">const</span> visitor6 = &#123;    <span class="hljs-function"><span class="hljs-title">IfStatement</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">if</span>(path.node.test.type == <span class="hljs-string">&quot;BooleanLiteral&quot;</span>) &#123;            <span class="hljs-keyword">if</span>(path.node.test.value) &#123;                path.replaceInline(path.node.consequent.body)            &#125; <span class="hljs-keyword">else</span> &#123;                path.replaceInline(path.node.alternate.body)            &#125;        &#125;    &#125;&#125;</code></pre><p>自此 jajiami v6 混淆就还原完毕了，还原前后对比一下，代码量缩短了很多，逻辑也更加清楚了，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/052/24.png" alt="24"></p><p>最后结合 Python 代码，携带生成的 <code>hostToken</code> 和 <code>permitToken</code>，成功拿到备案号：</p><p><img src="https://cdn.itbob.cn/img/article/052/25.png" alt="25"></p><h2 id="完整代码">完整代码</h2><p>原混淆代码 <code>generatetoken.js</code>、AST 脱混淆代码 <code>generatetokenAst.js</code>、还原后的代码 <code>generatetokenNew.js</code>，以及 Python 测试代码均在 GitHub，均有详细注释，欢迎 Star。所有内容仅供学习交流，严禁用于商业用途、非法用途，否则由此产生的一切后果均与作者无关，在仓库中下载的文件学习完毕之后请于 24 小时内删除！</p><p>代码地址：<a href="https://github.com/TRHX/Python3-Spider-Practice">https://github.com/TRHX/Python3-Spider-Practice</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/ast.png&quot; alt=&quot;ast&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;本文章中所有内容仅供学习交流使用，不用于其他任</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>逆向进阶，利用 AST 技术还原 JavaScript 混淆代码</title>
    <link href="https://www.itbob.cn/article/051/"/>
    <id>https://www.itbob.cn/article/051/</id>
    <published>2022-04-25T09:00:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/ast.png" alt="ast"></p><h2 id="什么是-AST">什么是 AST</h2><p>AST（Abstract Syntax Tree），中文抽象语法树，简称语法树（Syntax Tree），是源代码的抽象语法结构的树状表现形式，树上的每个节点都表示源代码中的一种结构。语法树不是某一种编程语言独有的，JavaScript、Python、Java、Golang 等几乎所有编程语言都有语法树。</p><p>小时候我们得到一个玩具，总喜欢把玩具拆解成一个一个小零件，然后按照我们自己的想法，把零件重新组装起来，一个新玩具就诞生了。而 JavaScript 就像一台精妙运作的机器，通过 AST 解析，我们也可以像童年时拆解玩具一样，深入了解 JavaScript 这台机器的各个零部件，然后重新按照我们自己的意愿来组装。</p><p>AST 的用途很广，IDE 的语法高亮、代码检查、格式化、压缩、转译等，都需要先将代码转化成 AST 再进行后续的操作，ES5 和 ES6 语法差异，为了向后兼容，在实际应用中需要进行语法的转换，也会用到 AST。AST 并不是为了逆向而生，但做逆向学会了 AST，在解混淆时可以如鱼得水。</p><p>AST 有一个在线解析网站：<a href="https://astexplorer.net/">https://astexplorer.net/</a> ，顶部可以选择语言、编译器、是否开启转化等，如下图所示，区域①是源代码，区域②是对应的 AST 语法树，区域③是转换代码，可以对语法树进行各种操作，区域④是转换后生成的新代码。图中原来的 Unicode 字符经过操作之后就变成了正常字符。</p><p>语法树没有单一的格式，选择不同的语言、不同的编译器，得到的结果也是不一样的，在 JavaScript 中，编译器有 Acorn、Espree、Esprima、Recast、Uglify-JS 等，使用最多的是 Babel，后续的学习也是以 Babel 为例。</p><p><img src="https://cdn.itbob.cn/img/article/051/01.png" alt="01"></p><h2 id="AST-在编译中的位置">AST 在编译中的位置</h2><p>在编译原理中，编译器转换代码通常要经过三个步骤：词法分析（Lexical Analysis）、语法分析（Syntax Analysis）、代码生成（Code Generation），下图生动展示了这一过程：</p><p><img src="https://cdn.itbob.cn/img/article/051/02.png" alt="02"></p><h3 id="词法分析">词法分析</h3><p>词法分析阶段是编译过程的第一个阶段，这个阶段的任务是从左到右一个字符一个字符地读入源程序，然后根据构词规则识别单词，生成 token 符号流，比如 <code>isPanda('🐼')</code>，会被拆分成 <code>isPanda</code>，<code>(</code>，<code>'🐼'</code>，<code>)</code> 四部分，每部分都有不同的含义，可以将词法分析过程想象为不同类型标记的列表或数组。</p><p><img src="https://cdn.itbob.cn/img/article/051/03.gif" alt="03"></p><h3 id="语法分析">语法分析</h3><p>语法分析是编译过程的一个逻辑阶段，语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，比如“程序”，“语句”，“表达式”等，前面的例子中，<code>isPanda('🐼')</code> 就会被分析为一条表达语句 <code>ExpressionStatement</code>，<code>isPanda()</code> 就会被分析成一个函数表达式 <code>CallExpression</code>，<code>🐼</code> 就会被分析成一个变量 <code>Literal</code> 等，众多语法之间的依赖、嵌套关系，就构成了一个树状结构，即 AST 语法树。</p><p><img src="https://cdn.itbob.cn/img/article/051/04.gif" alt="04"></p><h3 id="代码生成">代码生成</h3><p>代码生成是最后一步，将 AST 语法树转换成可执行代码即可，在转换之前，我们可以直接操作语法树，进行增删改查等操作，例如，我们可以确定变量的声明位置、更改变量的值、删除某些节点等，我们将语句 <code>isPanda('🐼')</code> 修改为一个布尔类型的 <code>Literal</code>：<code>true</code>，语法树就有如下变化：</p><p><img src="https://cdn.itbob.cn/img/article/051/05.gif" alt="05"></p><h2 id="Babel-简介">Babel 简介</h2><p>Babel 是一个 JavaScript 编译器，也可以说是一个解析库，Babel 中文网：<a href="https://www.babeljs.cn/">https://www.babeljs.cn/</a> ，Babel 英文官网：<a href="https://babeljs.io/">https://babeljs.io/</a> ，Babel 内置了很多分析 JavaScript 代码的方法，我们可以利用 Babel 将 JavaScript 代码转换成 AST 语法树，然后增删改查等操作之后，再转换成 JavaScript 代码。</p><p>Babel 包含的各种功能包、API、各方法可选参数等，都非常多，本文不一一列举，在实际使用过程中，应当多查询官方文档，或者参考文末给出的一些学习资料。Babel 的安装和其他 Node 包一样，需要哪个安装哪个即可，比如 <code>npm install @babel/core @babel/parser @babel/traverse @babel/generator</code></p><p>在做逆向解混淆中，主要用到了 Babel 的以下几个功能包，本文也仅介绍以下几个功能包：</p><ol><li><code>@babel/core</code>：Babel 编译器本身，提供了 babel 的编译 API；</li><li><code>@babel/parser</code>：将 JavaScript 代码解析成 AST 语法树；</li><li><code>@babel/traverse</code>：遍历、修改 AST 语法树的各个节点；</li><li><code>@babel/generator</code>：将 AST 还原成 JavaScript 代码；</li><li><code>@babel/types</code>：判断、验证节点的类型、构建新 AST 节点等。</li></ol><p><img src="https://cdn.itbob.cn/img/article/051/06.png" alt="06"></p><h3 id="babel-core">@babel/core</h3><p>Babel 编译器本身，被拆分成了三个模块：<code>@babel/parser</code>、<code>@babel/traverse</code>、<code>@babel/generator</code>，比如以下方法的导入效果都是一样的：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>).parse;<span class="hljs-keyword">const</span> parse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/core&quot;</span>).parse;<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/core&quot;</span>).traverse</code></pre><h3 id="babel-parser">@babel/parser</h3><p><code>@babel/parser</code> 可以将 JavaScript 代码解析成 AST 语法树，其中主要提供了两个方法：</p><ul><li><code>parser.parse(code, [&#123;options&#125;])</code>：解析一段 JavaScript 代码；</li><li><code>parser.parseExpression(code, [&#123;options&#125;])</code>：考虑到了性能问题，解析单个 JavaScript 表达式。</li></ul><p>部分可选参数 <code>options</code>：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>allowImportExportEverywhere</code></td><td>默认 <code>import</code> 和 <code>export</code> 声明语句只能出现在程序的最顶层，设置为 <code>true</code> 则在任何地方都可以声明</td></tr><tr><td><code>allowReturnOutsideFunction</code></td><td>默认如果在顶层中使用 <code>return</code> 语句会引起错误，设置为 <code>true</code> 就不会报错</td></tr><tr><td><code>sourceType</code></td><td>默认为 <code>script</code>，当代码中含有 <code>import</code> 、<code>export</code> 等关键字时会报错，需要指定为 <code>module</code></td></tr><tr><td><code>errorRecovery</code></td><td>默认如果 babel 发现一些不正常的代码就会抛出错误，设置为 <code>true</code> 则会在保存解析错误的同时继续解析代码，错误的记录将被保存在最终生成的 AST 的 errors 属性中，当然如果遇到严重的错误，依然会终止解析</td></tr></tbody></table><p>举个例子看得比较清楚：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> code = <span class="hljs-string">&quot;const a = 1;&quot;</span>;<span class="hljs-keyword">const</span> ast = parser.parse(code, &#123;<span class="hljs-attr">sourceType</span>: <span class="hljs-string">&quot;module&quot;</span>&#125;)<span class="hljs-built_in">console</span>.log(ast)</code></pre><p><code>&#123;sourceType: &quot;module&quot;&#125;</code> 演示了如何添加可选参数，输出的就是 AST 语法树，这和在线网站 <a href="https://astexplorer.net/">https://astexplorer.net/</a> 解析出来的语法树是一样的：</p><p><img src="https://cdn.itbob.cn/img/article/051/07.png" alt="07"></p><h3 id="babel-generator">@babel/generator</h3><p><code>@babel/generator</code> 可以将 AST 还原成 JavaScript 代码，提供了一个 <code>generate</code> 方法：<code>generate(ast, [&#123;options&#125;], code)</code>。</p><p>部分可选参数 <code>options</code>：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>auxiliaryCommentBefore</code></td><td>在输出文件内容的头部添加注释块文字</td></tr><tr><td><code>auxiliaryCommentAfter</code></td><td>在输出文件内容的末尾添加注释块文字</td></tr><tr><td><code>comments</code></td><td>输出内容是否包含注释</td></tr><tr><td><code>compact</code></td><td>输出内容是否不添加空格，避免格式化</td></tr><tr><td><code>concise</code></td><td>输出内容是否减少空格使其更紧凑一些</td></tr><tr><td><code>minified</code></td><td>是否压缩输出代码</td></tr><tr><td><code>retainLines</code></td><td>尝试在输出代码中使用与源代码中相同的行号</td></tr></tbody></table><p>接着前面的例子，原代码是 <code>const a = 1;</code>，现在我们把 <code>a</code> 变量修改为 <code>b</code>，值 <code>1</code> 修改为 <code>2</code>，然后将 AST 还原生成新的 JS 代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> code = <span class="hljs-string">&quot;const a = 1;&quot;</span>;<span class="hljs-keyword">const</span> ast = parser.parse(code, &#123;<span class="hljs-attr">sourceType</span>: <span class="hljs-string">&quot;module&quot;</span>&#125;)ast.program.body[<span class="hljs-number">0</span>].declarations[<span class="hljs-number">0</span>].id.name = <span class="hljs-string">&quot;b&quot;</span>ast.program.body[<span class="hljs-number">0</span>].declarations[<span class="hljs-number">0</span>].init.value = <span class="hljs-number">2</span><span class="hljs-keyword">const</span> result = generate(ast, &#123;<span class="hljs-attr">minified</span>: <span class="hljs-literal">true</span>&#125;)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>最终输出的是 <code>const b=2;</code>，变量名和值都成功更改了，由于加了压缩处理，等号左右两边的空格也没了。</p><p>代码里 <code>&#123;minified: true&#125;</code> 演示了如何添加可选参数，这里表示压缩输出代码，<code>generate</code> 得到的 <code>result</code> 得到的是一个对象，其中的 <code>code</code> 属性才是最终的 JS 代码。</p><p>代码里 <code>ast.program.body[0].declarations[0].id.name</code> 是 a 在 AST 中的位置，<code>ast.program.body[0].declarations[0].init.value</code> 是 1 在 AST 中的位置，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/051/08.png" alt="08"></p><h3 id="babel-traverse">@babel/traverse</h3><p>当代码多了，我们不可能像前面那样挨个定位并修改，对于相同类型的节点，我们可以直接遍历所有节点来进行修改，这里就用到了 <code>@babel/traverse</code>，它通常和 <code>visitor</code> 一起使用，<code>visitor</code> 是一个对象，这个名字是可以随意取的，<code>visitor</code> 里可以定义一些方法来过滤节点，这里还是用一个例子来演示：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> code = <span class="hljs-string">`</span><span class="hljs-string">const a = 1500;</span><span class="hljs-string">const b = 60;</span><span class="hljs-string">const c = &quot;hi&quot;;</span><span class="hljs-string">const d = 787;</span><span class="hljs-string">const e = &quot;1244&quot;;</span><span class="hljs-string">`</span><span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">NumericLiteral</span>(<span class="hljs-params">path</span>)</span>&#123;        path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>    &#125;,    <span class="hljs-function"><span class="hljs-title">StringLiteral</span>(<span class="hljs-params">path</span>)</span>&#123;        path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>这里的原始代码定义了 abcde 五个变量，其值有数字也有字符串，我们在 AST 中可以看到对应的类型为 <code>NumericLiteral</code> 和 <code>StringLiteral</code>：</p><p><img src="https://cdn.itbob.cn/img/article/051/09.png" alt="09"></p><p>然后我们声明了一个 <code>visitor</code> 对象，然后定义对应类型的处理方法，<code>traverse</code> 接收两个参数，第一个是 AST 对象，第二个是 <code>visitor</code>，当 <code>traverse</code> 遍历所有节点，遇到节点类型为 <code>NumericLiteral</code> 和 <code>StringLiteral</code> 时，就会调用 <code>visitor</code> 中对应的处理方法，<code>visitor</code> 中的方法会接收一个当前节点的 <code>path</code> 对象，该对象的类型是 <code>NodePath</code>，该对象有非常多的属性，以下介绍几种最常用的：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>toString()</code></td><td>当前路径的源码</td></tr><tr><td><code>node</code></td><td>当前路径的节点</td></tr><tr><td><code>parent</code></td><td>当前路径的父级节点</td></tr><tr><td><code>parentPath</code></td><td>当前路径的父级路径</td></tr><tr><td><code>type</code></td><td>当前路径的类型</td></tr></tbody></table><p>PS：<code>path</code> 对象除了有很多属性以外，还有很多方法，比如替换节点、删除节点、插入节点、寻找父级节点、获取同级节点、添加注释、判断节点类型等，可在需要时查询相关文档或查看源码，后续介绍 <code>@babel/types</code> 部分将会举部分例子来演示，以后的实战文章中也会有相关实例，篇幅有限本文不再细说。</p><p>因此在上面的代码中，<code>path.node.value</code> 就拿到了变量的值，然后我们就可以进一步对其进行修改了。以上代码运行后，所有数字都会加上100后再乘以2，所有字符串都会被替换成 <code>I Love JavaScript!</code>，结果如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">3200</span>;<span class="hljs-keyword">const</span> b = <span class="hljs-number">320</span>;<span class="hljs-keyword">const</span> c = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>;<span class="hljs-keyword">const</span> d = <span class="hljs-number">1774</span>;<span class="hljs-keyword">const</span> e = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>;</code></pre><p>如果多个类型的节点，处理的方式都一样，那么还可以使用 <code>|</code> 将所有节点连接成字符串，将同一个方法应用到所有节点：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-string">&quot;NumericLiteral|StringLiteral&quot;</span>(path) &#123;        path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>    &#125;&#125;</code></pre><p><code>visitor</code> 对象有多种写法，以下几种写法的效果都是一样的：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">NumericLiteral</span>(<span class="hljs-params">path</span>)</span>&#123;        path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>    &#125;,    <span class="hljs-function"><span class="hljs-title">StringLiteral</span>(<span class="hljs-params">path</span>)</span>&#123;        path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>    &#125;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-attr">NumericLiteral</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>)</span>&#123;        path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>    &#125;,    <span class="hljs-attr">StringLiteral</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>)</span>&#123;        path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>    &#125;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-attr">NumericLiteral</span>: &#123;        <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span> &#123;            path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>        &#125;    &#125;,    <span class="hljs-attr">StringLiteral</span>: &#123;        <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span> &#123;            path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>        &#125;    &#125;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">if</span> (path.node.type === <span class="hljs-string">&quot;NumericLiteral&quot;</span>) &#123;            path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>        &#125;        <span class="hljs-keyword">if</span> (path.node.type === <span class="hljs-string">&quot;StringLiteral&quot;</span>) &#123;            path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>        &#125;    &#125;&#125;</code></pre><p>以上几种写法中有用到了 <code>enter</code> 方法，在节点的遍历过程中，进入节点（enter）与退出（exit）节点都会访问一次节点，<code>traverse</code> 默认在进入节点时进行节点的处理，如果要在退出节点时处理，那么在 <code>visitor</code> 中就必须声明 <code>exit</code> 方法。</p><h3 id="babel-types">@babel/types</h3><p><code>@babel/types</code> 主要用于构建新的 AST 节点，前面的示例代码为 <code>const a = 1;</code>，如果想要增加内容，比如变成 <code>const a = 1; const b = a * 5 + 1;</code>，就可以通过 <code>@babel/types</code> 来实现。</p><p>首先观察一下 AST 语法树，原语句只有一个 <code>VariableDeclaration</code> 节点，现在增加了一个：</p><p><img src="https://cdn.itbob.cn/img/article/051/10.png" alt="10"></p><p>那么我们的思路就是在遍历节点时，遍历到 <code>VariableDeclaration</code> 节点，就在其后面增加一个 <code>VariableDeclaration</code> 节点，生成  <code>VariableDeclaration</code> 节点，可以使用 <code>types.variableDeclaration()</code> 方法，在 types 中各种方法名称和我们在 AST 中看到的是一样的，只不过首字母是小写的，所以我们不需要知道所有方法的情况下，也能大致推断其方法名，只知道这个方法还不行，还得知道传入的参数是什么，可以查文档，不过这里推荐直接看源码，非常清晰明了，以 Pycharm 为例，按住 Ctrl 键，再点击方法名，就进到源码里了：</p><p><img src="https://cdn.itbob.cn/img/article/051/11.png" alt="11"></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">variableDeclaration</span>(<span class="hljs-params">kind: <span class="hljs-string">&quot;var&quot;</span> | <span class="hljs-string">&quot;let&quot;</span> | <span class="hljs-string">&quot;const&quot;</span>, declarations: <span class="hljs-built_in">Array</span>&lt;BabelNodeVariableDeclarator&gt;</span>)</span></code></pre><p>可以看到需要 <code>kind</code> 和 <code>declarations</code> 两个参数，其中 <code>declarations</code> 是 <code>VariableDeclarator</code> 类型的节点组成的列表，所以我们可以先写出以下 <code>visitor</code> 部分的代码，其中 <code>path.insertAfter()</code> 是在该节点之后插入新节点的意思：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">let</span> declaration = types.variableDeclaration(<span class="hljs-string">&quot;const&quot;</span>, [declarator])        path.insertAfter(declaration)    &#125;&#125;</code></pre><p>接下来我们还需要进一步定义 <code>declarator</code>，也就是 <code>VariableDeclarator</code> 类型的节点，查询其源码如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">variableDeclarator</span>(<span class="hljs-params">id: BabelNodeLVal, init?: BabelNodeExpression</span>)</span></code></pre><p>观察 AST，id 为 <code>Identifier</code> 对象，init 为 <code>BinaryExpression</code> 对象，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/051/12.png" alt="12"></p><p>先来处理 id，可以使用 <code>types.identifier()</code> 方法来生成，其源码为 <code>function identifier(name: string)</code>，name 在这里就是 b 了，此时 <code>visitor</code> 代码就可以这么写：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">let</span> declarator = types.variableDeclarator(types.identifier(<span class="hljs-string">&quot;b&quot;</span>), init)        <span class="hljs-keyword">let</span> declaration = types.variableDeclaration(<span class="hljs-string">&quot;const&quot;</span>, [declarator])        path.insertAfter(declaration)    &#125;&#125;</code></pre><p>然后再来看 init 该如何定义，首先仍然是看 AST 结构：</p><p><img src="https://cdn.itbob.cn/img/article/051/13.png" alt="13"></p><p>init 为 <code>BinaryExpression</code> 对象，left 左边是 <code>BinaryExpression</code>，right 右边是 <code>NumericLiteral</code>，可以用 <code>types.binaryExpression()</code> 方法来生成 init，其源码如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binaryExpression</span>(<span class="hljs-params"></span></span><span class="hljs-params"><span class="hljs-function">    operator: <span class="hljs-string">&quot;+&quot;</span> | <span class="hljs-string">&quot;-&quot;</span> | <span class="hljs-string">&quot;/&quot;</span> | <span class="hljs-string">&quot;%&quot;</span> | <span class="hljs-string">&quot;*&quot;</span> | <span class="hljs-string">&quot;**&quot;</span> | <span class="hljs-string">&quot;&amp;&quot;</span> | <span class="hljs-string">&quot;|&quot;</span> | <span class="hljs-string">&quot;&gt;&gt;&quot;</span> | <span class="hljs-string">&quot;&gt;&gt;&gt;&quot;</span> | <span class="hljs-string">&quot;&lt;&lt;&quot;</span> | <span class="hljs-string">&quot;^&quot;</span> | <span class="hljs-string">&quot;==&quot;</span> | <span class="hljs-string">&quot;===&quot;</span> | <span class="hljs-string">&quot;!=&quot;</span> | <span class="hljs-string">&quot;!==&quot;</span> | <span class="hljs-string">&quot;in&quot;</span> | <span class="hljs-string">&quot;instanceof&quot;</span> | <span class="hljs-string">&quot;&gt;&quot;</span> | <span class="hljs-string">&quot;&lt;&quot;</span> | <span class="hljs-string">&quot;&gt;=&quot;</span> | <span class="hljs-string">&quot;&lt;=&quot;</span>,</span></span><span class="hljs-params"><span class="hljs-function">    left: BabelNodeExpression | BabelNodePrivateName, </span></span><span class="hljs-params"><span class="hljs-function">    right: BabelNodeExpression</span></span><span class="hljs-params"><span class="hljs-function"></span>)</span></code></pre><p>此时 <code>visitor</code> 代码就可以这么写：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">let</span> init = types.binaryExpression(<span class="hljs-string">&quot;+&quot;</span>, left, right)        <span class="hljs-keyword">let</span> declarator = types.variableDeclarator(types.identifier(<span class="hljs-string">&quot;b&quot;</span>), init)        <span class="hljs-keyword">let</span> declaration = types.variableDeclaration(<span class="hljs-string">&quot;const&quot;</span>, [declarator])        path.insertAfter(declaration)    &#125;&#125;</code></pre><p>然后继续构造 left 和 right，和前面的方法一样，观察 AST 语法树，查询对应方法应该传入的参数，层层嵌套，直到把所有的节点都构造完毕，最终的 <code>visitor</code> 代码应该是这样的：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">let</span> left = types.binaryExpression(<span class="hljs-string">&quot;*&quot;</span>, types.identifier(<span class="hljs-string">&quot;a&quot;</span>), types.numericLiteral(<span class="hljs-number">5</span>))        <span class="hljs-keyword">let</span> right = types.numericLiteral(<span class="hljs-number">1</span>)        <span class="hljs-keyword">let</span> init = types.binaryExpression(<span class="hljs-string">&quot;+&quot;</span>, left, right)        <span class="hljs-keyword">let</span> declarator = types.variableDeclarator(types.identifier(<span class="hljs-string">&quot;b&quot;</span>), init)        <span class="hljs-keyword">let</span> declaration = types.variableDeclaration(<span class="hljs-string">&quot;const&quot;</span>, [declarator])        path.insertAfter(declaration)        path.stop()    &#125;&#125;</code></pre><p>注意：<code>path.insertAfter()</code> 插入节点语句后面加了一句 <code>path.stop()</code>，表示插入完成后立即停止遍历当前节点和后续的子节点，添加的新节点也是 <code>VariableDeclaration</code>，如果不加停止语句的话，就会无限循环插入下去。</p><p>插入新节点后，再转换成 JavaScript 代码，就可以看到多了一行新代码，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/051/14.png" alt="14"></p><h2 id="常见混淆还原">常见混淆还原</h2><p>了解了 AST 和 babel 后，就可以对 JavaScript 混淆代码进行还原了，以下是部分样例，带你进一步熟悉 babel 的各种操作。</p><h3 id="字符串还原">字符串还原</h3><p>文章开头的图中举了个例子，正常字符被换成了 Unicode 编码：</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>[<span class="hljs-string">&#x27;\u006c\u006f\u0067&#x27;</span>](<span class="hljs-string">&#x27;\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u006f\u0072\u006c\u0064\u0021&#x27;</span>)</code></pre><p>观察 AST 结构：</p><p><img src="https://cdn.itbob.cn/img/article/051/15.png" alt="15"></p><p>我们发现 Unicode 编码对应的是 <code>raw</code>，而 <code>rawValue</code> 和 <code>value</code> 都是正常的，所以我们可以将 <code>raw</code> 替换成 <code>rawValue</code> 或 <code>value</code> 即可，需要注意的是引号的问题，本来是 <code>console[&quot;log&quot;]</code>，你还原后变成了 <code>console[log]</code>，自然会报错的，除了替换值以外，这里直接删除 extra 节点，或者删除 raw 值也是可以的，所以以下几种写法都可以还原代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> code = <span class="hljs-string">`console[&#x27;\u006c\u006f\u0067&#x27;](&#x27;\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u006f\u0072\u006c\u0064\u0021&#x27;)`</span><span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">StringLiteral</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-comment">// 以下方法均可</span>        <span class="hljs-comment">// path.node.extra.raw = path.node.rawValue</span>        <span class="hljs-comment">// path.node.extra.raw = &#x27;&quot;&#x27; + path.node.value + &#x27;&quot;&#x27;</span>        <span class="hljs-comment">// delete path.node.extra</span>        <span class="hljs-keyword">delete</span> path.node.extra.raw    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>还原结果：</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>[<span class="hljs-string">&quot;log&quot;</span>](<span class="hljs-string">&quot;Hello world!&quot;</span>);</code></pre><h3 id="表达式还原">表达式还原</h3><p>之前写过 <a href="https://itrhx.blog.csdn.net/article/details/122057377">JSFuck 混淆的还原</a>，其中有介绍 <code>![]</code> 可表示 false，<code>!![]</code> 或者 <code>!+[]</code> 可表示 true，在一些混淆代码中，经常有这些操作，把简单的表达式复杂化，往往需要执行一下语句，才能得到真正的结果，示例代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = !![]+!![]+!![];<span class="hljs-keyword">const</span> b = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">12.34</span> * <span class="hljs-number">2.12</span>)<span class="hljs-keyword">const</span> c = <span class="hljs-number">10</span> &gt;&gt; <span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">1</span><span class="hljs-keyword">const</span> d = <span class="hljs-built_in">String</span>(<span class="hljs-number">21.3</span> + <span class="hljs-number">14</span> * <span class="hljs-number">1.32</span>)<span class="hljs-keyword">const</span> e = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;1.893&quot;</span> + <span class="hljs-string">&quot;45.9088&quot;</span>)<span class="hljs-keyword">const</span> f = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;23.2334&quot;</span> + <span class="hljs-string">&quot;21.89112&quot;</span>)<span class="hljs-keyword">const</span> g = <span class="hljs-number">20</span> &lt; <span class="hljs-number">18</span> ? <span class="hljs-string">&#x27;未成年&#x27;</span> : <span class="hljs-string">&#x27;成年&#x27;</span></code></pre><p>想要执行语句，我们需要了解 <code>path.evaluate()</code> 方法，该方法会对 path 对象进行执行操作，自动计算出结果，返回一个对象，其中的 <code>confident</code> 属性表示置信度，<code>value</code> 表示计算结果，使用 <code>types.valueToNode()</code> 方法创建节点，使用 <code>path.replaceInline()</code> 方法将节点替换成计算结果生成的新节点，替换方法有一下几种：</p><ul><li><code>replaceWith</code>：用一个节点替换另一个节点；</li><li><code>replaceWithMultiple</code>：用多个节点替换另一个节点；</li><li><code>replaceWithSourceString</code>：将传入的源码字符串解析成对应 Node 后再替换，性能较差，不建议使用；</li><li><code>replaceInline</code>：用一个或多个节点替换另一个节点，相当于同时有了前两个函数的功能。</li></ul><p>对应的 AST 处理代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)<span class="hljs-keyword">const</span> code = <span class="hljs-string">`</span><span class="hljs-string">const a = !![]+!![]+!![];</span><span class="hljs-string">const b = Math.floor(12.34 * 2.12)</span><span class="hljs-string">const c = 10 &gt;&gt; 3 &lt;&lt; 1</span><span class="hljs-string">const d = String(21.3 + 14 * 1.32)</span><span class="hljs-string">const e = parseInt(&quot;1.893&quot; + &quot;45.9088&quot;)</span><span class="hljs-string">const f = parseFloat(&quot;23.2334&quot; + &quot;21.89112&quot;)</span><span class="hljs-string">const g = 20 &lt; 18 ? &#x27;未成年&#x27; : &#x27;成年&#x27;</span><span class="hljs-string">`</span><span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-string">&quot;BinaryExpression|CallExpression|ConditionalExpression&quot;</span>(path) &#123;        <span class="hljs-keyword">const</span> &#123;confident, value&#125; = path.evaluate()        <span class="hljs-keyword">if</span> (confident)&#123;            path.replaceInline(types.valueToNode(value))        &#125;    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>最终结果：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">3</span>;<span class="hljs-keyword">const</span> b = <span class="hljs-number">26</span>;<span class="hljs-keyword">const</span> c = <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> d = <span class="hljs-string">&quot;39.78&quot;</span>;<span class="hljs-keyword">const</span> e = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;1.89345.9088&quot;</span>);<span class="hljs-keyword">const</span> f = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;23.233421.89112&quot;</span>);<span class="hljs-keyword">const</span> g = <span class="hljs-string">&quot;\u6210\u5E74&quot;</span>;</code></pre><h3 id="删除未使用变量">删除未使用变量</h3><p>有时候代码里会有一些并没有使用到的多余变量，删除这些多余变量有助于更加高效的分析代码，示例代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> b = a * <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> c = <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> d = b + <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> e = <span class="hljs-number">3</span>;<span class="hljs-built_in">console</span>.log(d)</code></pre><p>删除多余变量，首先要了解 <code>NodePath</code> 中的 <code>scope</code>，<code>scope</code> 的作用主要是查找标识符的作用域、获取并修改标识符的所有引用等，删除未使用变量主要用到了 <code>scope.getBinding()</code> 方法，传入的值是当前节点能够引用到的标识符名称，返回的关键属性有以下几个：</p><ul><li><code>identifier</code>：标识符的 Node 对象；</li><li><code>path</code>：标识符的 NodePath 对象；</li><li><code>constant</code>：标识符是否为常量；</li><li><code>referenced</code>：标识符是否被引用；</li><li><code> references</code>：标识符被引用的次数；</li><li><code>constantViolations</code>：如果标识符被修改，则会存放所有修改该标识符节点的 Path 对象；</li><li><code>referencePaths</code>：如果标识符被引用，则会存放所有引用该标识符节点的 Path 对象。</li></ul><p>所以我们可以通过 <code>constantViolations</code>、<code>referenced</code>、<code>references</code>、<code>referencePaths</code> 多个参数来判断变量是否可以被删除，AST 处理代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> code = <span class="hljs-string">`</span><span class="hljs-string">const a = 1;</span><span class="hljs-string">const b = a * 2;</span><span class="hljs-string">const c = 2;</span><span class="hljs-string">const d = b + 1;</span><span class="hljs-string">const e = 3;</span><span class="hljs-string">console.log(d)</span><span class="hljs-string">`</span><span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">VariableDeclarator</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">const</span> binding = path.scope.getBinding(path.node.id.name);        <span class="hljs-comment">// 如标识符被修改过，则不能进行删除动作。</span>        <span class="hljs-keyword">if</span> (!binding || binding.constantViolations.length &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 未被引用</span>        <span class="hljs-keyword">if</span> (!binding.referenced) &#123;            path.remove();        &#125;        <span class="hljs-comment">// 被引用次数为0</span>        <span class="hljs-comment">// if (binding.references === 0) &#123;</span>        <span class="hljs-comment">//     path.remove();</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// 长度为0，变量没有被引用过</span>        <span class="hljs-comment">// if (binding.referencePaths.length === 0) &#123;</span>        <span class="hljs-comment">//     path.remove();</span>        <span class="hljs-comment">// &#125;</span>    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>处理后的代码（未使用的 b、c、e 变量已被删除）：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> b = a * <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> d = b + <span class="hljs-number">1</span>;<span class="hljs-built_in">console</span>.log(d);</code></pre><h3 id="删除冗余逻辑代码">删除冗余逻辑代码</h3><p>有时候为了增加逆向难度，会有很多嵌套的 if-else 语句，大量判断为假的冗余逻辑代码，同样可以利用 AST 将其删除掉，只留下判断为真的，示例代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> example = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> a;    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;        a = <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) &#123;            a = <span class="hljs-number">2</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;            a = <span class="hljs-number">3</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> a;&#125;;</code></pre><p>观察 AST，判断条件对应的是 <code>test</code> 节点，if 对应的是 <code>consequent</code> 节点，else 对应的是 <code>alternate</code> 节点，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/051/16.png" alt="16"></p><p>AST 处理思路以及代码：</p><ol><li>筛选出 <code>BooleanLiteral</code> 和 <code>NumericLiteral</code> 节点，取其对应的值，即 <code>path.node.test.value</code>；</li><li>判断 <code>value</code> 值为真，则将节点替换成 <code>consequent</code> 节点下的内容，即 <code>path.node.consequent.body</code>；</li><li>判断 <code>value</code> 值为假，则替换成 <code>alternate</code> 节点下的内容，即 <code>path.node.alternate.body</code>；</li><li>有的 if 语句可能没有写 else，也就没有 <code>alternate</code>，所以这种情况下判断 <code>value</code> 值为假，则直接移除该节点，即 <code>path.remove()</code></li></ol><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/types&#x27;</span>);<span class="hljs-keyword">const</span> code = <span class="hljs-string">`</span><span class="hljs-string">const example = function () &#123;</span><span class="hljs-string">    let a;</span><span class="hljs-string">    if (false) &#123;</span><span class="hljs-string">        a = 1;</span><span class="hljs-string">    &#125; else &#123;</span><span class="hljs-string">        if (1) &#123;</span><span class="hljs-string">            a = 2;</span><span class="hljs-string">        &#125;</span><span class="hljs-string">        else &#123;</span><span class="hljs-string">            a = 3;</span><span class="hljs-string">        &#125;</span><span class="hljs-string">    &#125;</span><span class="hljs-string">    return a;</span><span class="hljs-string">&#125;;</span><span class="hljs-string">`</span><span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">if</span> (types.isBooleanLiteral(path.node.test) || types.isNumericLiteral(path.node.test)) &#123;            <span class="hljs-keyword">if</span> (path.node.test.value) &#123;                path.replaceInline(path.node.consequent.body);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (path.node.alternate) &#123;                    path.replaceInline(path.node.alternate.body);                &#125; <span class="hljs-keyword">else</span> &#123;                    path.remove()                &#125;            &#125;        &#125;    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>处理结果：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> example = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> a;  a = <span class="hljs-number">2</span>;  <span class="hljs-keyword">return</span> a;&#125;;</code></pre><h3 id="switch-case-反控制流平坦化">switch-case 反控制流平坦化</h3><p>控制流平坦化是混淆当中最常见的，通过 <code>if-else</code> 或者 <code>while-switch-case</code> 语句分解步骤，示例代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> _0x34e16a = <span class="hljs-string">&#x27;3,4,0,5,1,2&#x27;</span>[<span class="hljs-string">&#x27;split&#x27;</span>](<span class="hljs-string">&#x27;,&#x27;</span>);<span class="hljs-keyword">let</span> _0x2eff02 = <span class="hljs-number">0x0</span>;<span class="hljs-keyword">while</span> (!![]) &#123;    <span class="hljs-keyword">switch</span> (_0x34e16a[_0x2eff02++]) &#123;        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;0&#x27;</span>:            <span class="hljs-keyword">let</span> _0x38cb15 = _0x4588f1 + _0x470e97;            <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;1&#x27;</span>:            <span class="hljs-keyword">let</span> _0x1e0e5e = _0x37b9f3[_0x50cee0(<span class="hljs-number">0x2e0</span>, <span class="hljs-number">0x2e8</span>, <span class="hljs-number">0x2e1</span>, <span class="hljs-number">0x2e4</span>)];            <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;2&#x27;</span>:            <span class="hljs-keyword">let</span> _0x35d732 = [_0x388d4b(-<span class="hljs-number">0x134</span>, -<span class="hljs-number">0x134</span>, -<span class="hljs-number">0x139</span>, -<span class="hljs-number">0x138</span>)](_0x38cb15 &gt;&gt; _0x4588f1);            <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;3&#x27;</span>:            <span class="hljs-keyword">let</span> _0x4588f1 = <span class="hljs-number">0x1</span>;            <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;4&#x27;</span>:            <span class="hljs-keyword">let</span> _0x470e97 = <span class="hljs-number">0x2</span>;            <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;5&#x27;</span>:            <span class="hljs-keyword">let</span> _0x37b9f3 = <span class="hljs-number">0x5</span> || _0x38cb15;            <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">break</span>;&#125;</code></pre><p>AST 还原思路：</p><ol><li>获取控制流原始数组，将 <code>'3,4,0,5,1,2'['split'](',')</code> 之类的语句转化成 <code>['3','4','0','5','1','2']</code> 之类的数组，得到该数组之后，也可以选择把 split 语句对应的节点删除掉，因为最终代码里这条语句就没用了；</li><li>遍历第一步得到的控制流数组，依次取出每个值所对应的 case 节点；</li><li>定义一个数组，储存每个 case 节点 <code>consequent</code> 数组里面的内容，并删除 <code>continue</code> 语句对应的节点；</li><li>遍历完成后，将第三步的数组替换掉整个 while 节点，也就是 <code>WhileStatement</code>。</li></ol><p>不同思路，写法多样，对于如何获取控制流数组，可以有以下思路：</p><ol><li>获取到 <code>While</code> 语句节点，然后使用 <code>path.getAllPrevSiblings()</code> 方法获取其前面的所有兄弟节点，遍历每个兄弟节点，找到与 <code>switch()</code> 里面数组的变量名相同的节点，然后再取节点的值进行后续处理；</li><li>直接取 <code>switch()</code> 里面数组的变量名，然后使用 <code>scope.getBinding()</code> 方法获取到它绑定的节点，然后再取这个节点的值进行后续处理。</li></ol><p>所以 AST 处理代码就有两种写法，方法一：（code.js 即为前面的示例代码，为了方便操作，这里使用 fs 从文件中读取代码）</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<span class="hljs-keyword">const</span> code = fs.readFileSync(<span class="hljs-string">&quot;code.js&quot;</span>, &#123;<span class="hljs-attr">encoding</span>: <span class="hljs-string">&quot;utf-8&quot;</span>&#125;);<span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">WhileStatement</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-comment">// switch 节点</span>        <span class="hljs-keyword">let</span> switchNode = path.node.body.body[<span class="hljs-number">0</span>];        <span class="hljs-comment">// switch 语句内的控制流数组名，本例中是 _0x34e16a</span>        <span class="hljs-keyword">let</span> arrayName = switchNode.discriminant.object.name;        <span class="hljs-comment">// 获得所有 while 前面的兄弟节点，本例中获取到的是声明两个变量的节点，即 const _0x34e16a 和 let _0x2eff02</span>        <span class="hljs-keyword">let</span> prevSiblings = path.getAllPrevSiblings();        <span class="hljs-comment">// 定义缓存控制流数组</span>        <span class="hljs-keyword">let</span> array = []        <span class="hljs-comment">// forEach 方法遍历所有节点</span>        prevSiblings.forEach(<span class="hljs-function"><span class="hljs-params">pervNode</span> =&gt;</span> &#123;            <span class="hljs-keyword">let</span> &#123;id, init&#125; = pervNode.node.declarations[<span class="hljs-number">0</span>];            <span class="hljs-comment">// 如果节点 id.name 与 switch 语句内的控制流数组名相同</span>            <span class="hljs-keyword">if</span> (arrayName === id.name) &#123;                <span class="hljs-comment">// 获取节点整个表达式的参数、分割方法、分隔符</span>                <span class="hljs-keyword">let</span> object = init.callee.object.value;                <span class="hljs-keyword">let</span> property = init.callee.property.value;                <span class="hljs-keyword">let</span> argument = init.arguments[<span class="hljs-number">0</span>].value;                <span class="hljs-comment">// 模拟执行 &#x27;3,4,0,5,1,2&#x27;[&#x27;split&#x27;](&#x27;,&#x27;) 语句</span>                array = object[property](argument)                <span class="hljs-comment">// 也可以直接取参数进行分割，方法不通用，比如分隔符换成 | 就不行了</span>                <span class="hljs-comment">// array = init.callee.object.value.split(&#x27;,&#x27;);</span>            &#125;            <span class="hljs-comment">// 前面的兄弟节点就可以删除了</span>            pervNode.remove();        &#125;);        <span class="hljs-comment">// 储存正确顺序的控制流语句</span>        <span class="hljs-keyword">let</span> replace = [];        <span class="hljs-comment">// 遍历控制流数组，按正确顺序取 case 内容</span>        array.forEach(<span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;                <span class="hljs-keyword">let</span> consequent = switchNode.cases[index].consequent;                <span class="hljs-comment">// 如果最后一个节点是 continue 语句，则删除 ContinueStatement 节点</span>                <span class="hljs-keyword">if</span> (types.isContinueStatement(consequent[consequent.length - <span class="hljs-number">1</span>])) &#123;                    consequent.pop();                &#125;                <span class="hljs-comment">// concat 方法拼接多个数组，即正确顺序的 case 内容</span>                replace = replace.concat(consequent);            &#125;        );        <span class="hljs-comment">// 替换整个 while 节点，两种方法都可以</span>        path.replaceWithMultiple(replace);        <span class="hljs-comment">// path.replaceInline(replace);</span>    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>方法二：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<span class="hljs-keyword">const</span> code = fs.readFileSync(<span class="hljs-string">&quot;code.js&quot;</span>, &#123;<span class="hljs-attr">encoding</span>: <span class="hljs-string">&quot;utf-8&quot;</span>&#125;);<span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">WhileStatement</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-comment">// switch 节点</span>        <span class="hljs-keyword">let</span> switchNode = path.node.body.body[<span class="hljs-number">0</span>];        <span class="hljs-comment">// switch 语句内的控制流数组名，本例中是 _0x34e16a</span>        <span class="hljs-keyword">let</span> arrayName = switchNode.discriminant.object.name;        <span class="hljs-comment">// 获取控制流数组绑定的节点</span>        <span class="hljs-keyword">let</span> bindingArray = path.scope.getBinding(arrayName);        <span class="hljs-comment">// 获取节点整个表达式的参数、分割方法、分隔符</span>        <span class="hljs-keyword">let</span> init = bindingArray.path.node.init;        <span class="hljs-keyword">let</span> object = init.callee.object.value;        <span class="hljs-keyword">let</span> property = init.callee.property.value;        <span class="hljs-keyword">let</span> argument = init.arguments[<span class="hljs-number">0</span>].value;        <span class="hljs-comment">// 模拟执行 &#x27;3,4,0,5,1,2&#x27;[&#x27;split&#x27;](&#x27;,&#x27;) 语句</span>        <span class="hljs-keyword">let</span> array = object[property](argument)        <span class="hljs-comment">// 也可以直接取参数进行分割，方法不通用，比如分隔符换成 | 就不行了</span>        <span class="hljs-comment">// let array = init.callee.object.value.split(&#x27;,&#x27;);</span>        <span class="hljs-comment">// switch 语句内的控制流自增变量名，本例中是 _0x2eff02</span>        <span class="hljs-keyword">let</span> autoIncrementName = switchNode.discriminant.property.argument.name;        <span class="hljs-comment">// 获取控制流自增变量名绑定的节点</span>        <span class="hljs-keyword">let</span> bindingAutoIncrement = path.scope.getBinding(autoIncrementName);        <span class="hljs-comment">// 可选择的操作：删除控制流数组绑定的节点、自增变量名绑定的节点</span>        bindingArray.path.remove();        bindingAutoIncrement.path.remove();        <span class="hljs-comment">// 储存正确顺序的控制流语句</span>        <span class="hljs-keyword">let</span> replace = [];        <span class="hljs-comment">// 遍历控制流数组，按正确顺序取 case 内容</span>        array.forEach(<span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;                <span class="hljs-keyword">let</span> consequent = switchNode.cases[index].consequent;                <span class="hljs-comment">// 如果最后一个节点是 continue 语句，则删除 ContinueStatement 节点</span>                <span class="hljs-keyword">if</span> (types.isContinueStatement(consequent[consequent.length - <span class="hljs-number">1</span>])) &#123;                    consequent.pop();                &#125;                <span class="hljs-comment">// concat 方法拼接多个数组，即正确顺序的 case 内容</span>                replace = replace.concat(consequent);            &#125;        );        <span class="hljs-comment">// 替换整个 while 节点，两种方法都可以</span>        path.replaceWithMultiple(replace);        <span class="hljs-comment">// path.replaceInline(replace);</span>    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>以上代码运行后，原来的 <code>switch-case</code> 控制流就被还原了，变成了按顺序一行一行的代码，更加简洁明了：</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> _0x4588f1 = <span class="hljs-number">0x1</span>;<span class="hljs-keyword">let</span> _0x470e97 = <span class="hljs-number">0x2</span>;<span class="hljs-keyword">let</span> _0x38cb15 = _0x4588f1 + _0x470e97;<span class="hljs-keyword">let</span> _0x37b9f3 = <span class="hljs-number">0x5</span> || _0x38cb15;<span class="hljs-keyword">let</span> _0x1e0e5e = _0x37b9f3[_0x50cee0(<span class="hljs-number">0x2e0</span>, <span class="hljs-number">0x2e8</span>, <span class="hljs-number">0x2e1</span>, <span class="hljs-number">0x2e4</span>)];<span class="hljs-keyword">let</span> _0x35d732 = [_0x388d4b(-<span class="hljs-number">0x134</span>, -<span class="hljs-number">0x134</span>, -<span class="hljs-number">0x139</span>, -<span class="hljs-number">0x138</span>)](_0x38cb15 &gt;&gt; _0x4588f1);</code></pre><h2 id="参考资料">参考资料</h2><p>本文有参考以下资料，也是比较推荐的在线学习资料：</p><ul><li>Youtube 视频，Babel 入门：<a href="https://www.youtube.com/watch?v=UeVq_U5obnE">https://www.youtube.com/watch?v=UeVq_U5obnE</a></li><li>官方手册 Babel Handbook：<a href="https://github.com/jamiebuilds/babel-handbook">https://github.com/jamiebuilds/babel-handbook</a></li><li>非官方 Babel API 中文文档：<a href="https://evilrecluse.top/Babel-traverse-api-doc/">https://evilrecluse.top/Babel-traverse-api-doc/</a></li></ul><h2 id="END">END</h2><p>Babel 编译器国内的资料其实不是很多，多看源码、同时在线对照可视化的 AST 语法树，耐心一点儿一层一层分析即可，本文中的案例也只是最基本操作，实际遇到一些混淆还得视情况进行修改，比如需要加一些类型判断来限制等，后续会用实战来带领大家进一步熟悉解混淆当中的其他操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/ast.png&quot; alt=&quot;ast&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是-AST&quot;&gt;什么是 AST&lt;/h2&gt;
&lt;p&gt;AST（Abstract Syntax Tree），中文抽象语法树，简称语法树</summary>
      
    
    
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>网洛者反爬练习平台第七题：JSVMPZL 初体验</title>
    <link href="https://www.itbob.cn/article/050/"/>
    <id>https://www.itbob.cn/article/050/</id>
    <published>2022-04-06T05:39:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/javascript_reverse.png" alt="javascript_reverse"></p><h2 id="声明">声明</h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2 id="逆向目标">逆向目标</h2><ul><li>目标：网洛者反反爬虫练习平台第七题：JSVMPZL 初体验</li><li>链接：<a href="http://spider.wangluozhe.com/challenge/7">http://spider.wangluozhe.com/challenge/7</a></li><li>简介：平台注册需要邀请码，站长在群里，可后台回复交流群加群获取，或者直接加网站底部站长QQ获取。要求采集100页的全部数字，并计算所有数据加和。主要难点在于 vvv 大佬开发的 JS 混淆框架：jsvmpzl</li></ul><p><img src="https://cdn.itbob.cn/img/article/050/01.png" alt="01"></p><h2 id="逆向过程">逆向过程</h2><p>直接搜索，或者跟栈，可以轻松找到加密入口，打开 F12 有两个反调试，一是无限 debugger，右键 Never pause here 即可，二是定时器，控制台输入 <code>for (let i = 1; i &lt; 99999; i++) window.clearInterval(i);</code> 过掉即可。</p><p><img src="https://cdn.itbob.cn/img/article/050/02.png" alt="02"></p><p>跟进 <code>y__()</code>，就可以看到 jsvmpzl 混淆的代码了，如果有做过猿人学平台的题，会发现此混淆和猿人学第 18 题（ <a href="https://match.yuanrenxue.com/match/18">https://match.yuanrenxue.com/match/18</a> ）是一样的，在 <code>y__()</code> 第一行下个断点，观察 <code>__v_()</code> 第一个参数 <code>_</code>，<code>_[2][0]</code> 你会发现有关 MD5 算法的一些特征，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/050/03.png" alt="03"></p><p>那么我们直接大胆猜测一下，是不是就是某个数据经过 MD5 之后就是 <code>_signature</code> 了呢？再继续调试一下，注意 <code>arguments</code> 的变化：</p><p><img src="https://cdn.itbob.cn/img/article/050/04.png" alt="04"></p><p>很明显这个 <code>window.byted_acrawler(window.sign())</code> 应该就是生成 <code>_signature</code> 的语句，这个方法和某字节系的 <code>_signature</code> 生成的方法名称是一样的，直接在控制台输出一下可以拿到值，其中 <code>window.sign()</code> 是取的时间戳：</p><p><img src="https://cdn.itbob.cn/img/article/050/05.png" alt="05"></p><p>我们前面猜测是 MD5，直接验证一下，发现并不是的，即便是同一个时间戳，经过 <code>window.byted_acrawler()</code> 后得到的值每次也都不一样：</p><p><img src="https://cdn.itbob.cn/img/article/050/06.png" alt="06"></p><h3 id="Hook-关键方法">Hook 关键方法</h3><p>经过前面的分析，既然标准的 MD5 不行，那有没有可能是魔改的 MD5 呢？首先找个 JavaScript 标准的 MD5 代码看一下，比如：<a href="http://pajhome.org.uk/crypt/md5/md5.html">http://pajhome.org.uk/crypt/md5/md5.html</a></p><p><img src="https://cdn.itbob.cn/img/article/050/07.png" alt="07"></p><p>可以注意到，源码里面有很多 <code>md5_ff</code>、<code>md5_gg</code>、<code>md5_hh</code>、<code>md5_ii</code> 的方法，最后一个值都是固定的，那么有没有可能此题就是在标准 MD5 的基础上修改了一些默认值呢？所以我们可以直接 Hook 这些关键方法，在控制台输出传入的值，来一一对比一下，看看默认值是否是一样的，为了方便观察，我们还可以为输出语句加上颜色，Hook 代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> oldFF = _[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;md5_ff&#x27;</span>];<span class="hljs-keyword">let</span> oldGG = _[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;md5_gg&#x27;</span>];<span class="hljs-keyword">let</span> oldHH = _[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;md5_hh&#x27;</span>];<span class="hljs-keyword">let</span> oldII = _[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;md5_ii&#x27;</span>];<span class="hljs-keyword">let</span> color_white_red = <span class="hljs-string">&quot;color: white; background: red;&quot;</span><span class="hljs-keyword">let</span> color_white_grey = <span class="hljs-string">&quot;color: white; background: grey;&quot;</span><span class="hljs-keyword">let</span> color_white_darkcyan = <span class="hljs-string">&quot;color: white; background: darkcyan;&quot;</span><span class="hljs-keyword">let</span> color_white_green = <span class="hljs-string">&quot;color: white; background: green;&quot;</span><span class="hljs-keyword">let</span> color_white_orange = <span class="hljs-string">&quot;color: white; background: orange;&quot;</span>_[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;md5_ff&#x27;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d, e, f, g</span>) </span>&#123;    <span class="hljs-keyword">debugger</span>;    <span class="hljs-keyword">let</span> result = oldFF(a, b, c, d, e, f, g);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;%c Function: %c md5_ff %c Result: %c %s %c Params: %c %s, %s, %s, %s, %s, %s, %s &quot;</span>, color_white_red, color_white_grey, color_white_red, color_white_grey, result, color_white_red, color_white_grey, a, b, c, d, e, f, g)    <span class="hljs-keyword">return</span> result;&#125;;_[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;md5_gg&#x27;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d, e, f, g</span>) </span>&#123;    <span class="hljs-keyword">debugger</span>;    <span class="hljs-keyword">let</span> result = oldGG(a, b, c, d, e, f, g);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;%c Function: %c md5_gg %c Result: %c %s %c Params: %c %s, %s, %s, %s, %s, %s, %s &quot;</span>, color_white_red, color_white_darkcyan, color_white_red, color_white_darkcyan, result, color_white_red, color_white_darkcyan, a, b, c, d, e, f, g)    <span class="hljs-keyword">return</span> result;&#125;;_[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;md5_hh&#x27;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d, e, f, g</span>) </span>&#123;    <span class="hljs-keyword">debugger</span>;    <span class="hljs-keyword">let</span> result = oldHH(a, b, c, d, e, f, g);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;%c Function: %c md5_hh %c Result: %c %s %c Params: %c %s, %s, %s, %s, %s, %s, %s &quot;</span>, color_white_red, color_white_green, color_white_red, color_white_green, result, color_white_red, color_white_green, a, b, c, d, e, f, g)    <span class="hljs-keyword">return</span> result;&#125;;_[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;md5_ii&#x27;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d, e, f, g</span>) </span>&#123;    <span class="hljs-keyword">debugger</span>;    <span class="hljs-keyword">let</span> result = oldII(a, b, c, d, e, f, g);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;%c Function: %c md5_ii %c Result: %c %s %c Params: %c %s, %s, %s, %s, %s, %s, %s &quot;</span>, color_white_red, color_white_orange, color_white_red, color_white_orange, result, color_white_red, color_white_orange, a, b, c, d, e, f, g)    <span class="hljs-keyword">return</span> result;&#125;;</code></pre><p>Hook 代码写得比较死板，熟悉 JS 的大佬可自己优化一下，注意注入代码的时机，清除定时器后，断点运行到 <code>y__()</code> 方法后再注入，然后取消断点，一直下一步，就可以在控制台看到输出的参数了，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/050/08.png" alt="08"></p><p><img src="https://cdn.itbob.cn/img/article/050/09.png" alt="09"></p><p>与默认参数进行对比，可以发现 <code>md5_hh()</code> 里有两个默认参数被修改了：</p><p><img src="https://cdn.itbob.cn/img/article/050/10.png" alt="10"></p><p>默认的 <code>-722521979</code> 改成了 <code>-722521939</code>、<code>76029189</code> 改成了 <code>76029185</code>，本地代码修改一下即可：</p><pre><code class="hljs javascript"><span class="hljs-comment">/* ==================================</span><span class="hljs-comment"># @Time    : 2021-12-23</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: challenge_7.js</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ================================== */</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message</span><span class="hljs-comment"> * Digest Algorithm, as defined in RFC 1321.</span><span class="hljs-comment"> * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009</span><span class="hljs-comment"> * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet</span><span class="hljs-comment"> * Distributed under the BSD License</span><span class="hljs-comment"> * See http://pajhome.org.uk/crypt/md5 for more info.</span><span class="hljs-comment"> */</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * Configurable variables. You may need to tweak these to be compatible with</span><span class="hljs-comment"> * the server-side, but the defaults work in most cases.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> hexcase = <span class="hljs-number">0</span>;   <span class="hljs-comment">/* hex output format. 0 - lowercase; 1 - uppercase        */</span><span class="hljs-keyword">var</span> b64pad  = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-comment">/* base-64 pad character. &quot;=&quot; for strict RFC compliance   */</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * These are the functions you&#x27;ll usually want to call</span><span class="hljs-comment"> * They take string arguments and return either hex or base-64 encoded strings</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hex_md5</span>(<span class="hljs-params">s</span>)    </span>&#123; <span class="hljs-keyword">return</span> rstr2hex(rstr_md5(str2rstr_utf8(s))); &#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b64_md5</span>(<span class="hljs-params">s</span>)    </span>&#123; <span class="hljs-keyword">return</span> rstr2b64(rstr_md5(str2rstr_utf8(s))); &#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">any_md5</span>(<span class="hljs-params">s, e</span>) </span>&#123; <span class="hljs-keyword">return</span> rstr2any(rstr_md5(str2rstr_utf8(s)), e); &#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hex_hmac_md5</span>(<span class="hljs-params">k, d</span>)</span><span class="hljs-function">  </span>&#123; <span class="hljs-keyword">return</span> rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); &#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b64_hmac_md5</span>(<span class="hljs-params">k, d</span>)</span><span class="hljs-function">  </span>&#123; <span class="hljs-keyword">return</span> rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); &#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">any_hmac_md5</span>(<span class="hljs-params">k, d, e</span>)</span><span class="hljs-function">  </span>&#123; <span class="hljs-keyword">return</span> rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); &#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Perform a simple self-test to see if the VM is working</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">md5_vm_test</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> hex_md5(<span class="hljs-string">&quot;abc&quot;</span>).toLowerCase() == <span class="hljs-string">&quot;900150983cd24fb0d6963f7d28e17f72&quot;</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Calculate the MD5 of a raw string</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rstr_md5</span>(<span class="hljs-params">s</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> binl2rstr(binl_md5(rstr2binl(s), s.length * <span class="hljs-number">8</span>));&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Calculate the HMAC-MD5, of a key and some data (raw strings)</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rstr_hmac_md5</span>(<span class="hljs-params">key, data</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">var</span> bkey = rstr2binl(key);  <span class="hljs-keyword">if</span>(bkey.length &gt; <span class="hljs-number">16</span>) bkey = binl_md5(bkey, key.length * <span class="hljs-number">8</span>);  <span class="hljs-keyword">var</span> ipad = <span class="hljs-built_in">Array</span>(<span class="hljs-number">16</span>), opad = <span class="hljs-built_in">Array</span>(<span class="hljs-number">16</span>);  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++)  &#123;    ipad[i] = bkey[i] ^ <span class="hljs-number">0x36363636</span>;    opad[i] = bkey[i] ^ <span class="hljs-number">0x5C5C5C5C</span>;  &#125;  <span class="hljs-keyword">var</span> hash = binl_md5(ipad.concat(rstr2binl(data)), <span class="hljs-number">512</span> + data.length * <span class="hljs-number">8</span>);  <span class="hljs-keyword">return</span> binl2rstr(binl_md5(opad.concat(hash), <span class="hljs-number">512</span> + <span class="hljs-number">128</span>));&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Convert a raw string to a hex string</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rstr2hex</span>(<span class="hljs-params">input</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">try</span> &#123; hexcase &#125; <span class="hljs-keyword">catch</span>(e) &#123; hexcase=<span class="hljs-number">0</span>; &#125;  <span class="hljs-keyword">var</span> hex_tab = hexcase ? <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span> : <span class="hljs-string">&quot;0123456789abcdef&quot;</span>;  <span class="hljs-keyword">var</span> output = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">var</span> x;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; input.length; i++)  &#123;    x = input.charCodeAt(i);    output += hex_tab.charAt((x &gt;&gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0F</span>)           +  hex_tab.charAt( x        &amp; <span class="hljs-number">0x0F</span>);  &#125;  <span class="hljs-keyword">return</span> output;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Convert a raw string to a base-64 string</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rstr2b64</span>(<span class="hljs-params">input</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">try</span> &#123; b64pad &#125; <span class="hljs-keyword">catch</span>(e) &#123; b64pad=<span class="hljs-string">&#x27;&#x27;</span>; &#125;  <span class="hljs-keyword">var</span> tab = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;  <span class="hljs-keyword">var</span> output = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">var</span> len = input.length;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i += <span class="hljs-number">3</span>)  &#123;    <span class="hljs-keyword">var</span> triplet = (input.charCodeAt(i) &lt;&lt; <span class="hljs-number">16</span>)                | (i + <span class="hljs-number">1</span> &lt; len ? input.charCodeAt(i+<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">8</span> : <span class="hljs-number">0</span>)                | (i + <span class="hljs-number">2</span> &lt; len ? input.charCodeAt(i+<span class="hljs-number">2</span>)      : <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)    &#123;      <span class="hljs-keyword">if</span>(i * <span class="hljs-number">8</span> + j * <span class="hljs-number">6</span> &gt; input.length * <span class="hljs-number">8</span>) output += b64pad;      <span class="hljs-keyword">else</span> output += tab.charAt((triplet &gt;&gt;&gt; <span class="hljs-number">6</span>*(<span class="hljs-number">3</span>-j)) &amp; <span class="hljs-number">0x3F</span>);    &#125;  &#125;  <span class="hljs-keyword">return</span> output;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Convert a raw string to an arbitrary string encoding</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rstr2any</span>(<span class="hljs-params">input, encoding</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">var</span> divisor = encoding.length;  <span class="hljs-keyword">var</span> i, j, q, x, quotient;  <span class="hljs-comment">/* Convert to an array of 16-bit big-endian values, forming the dividend */</span>  <span class="hljs-keyword">var</span> dividend = <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">Math</span>.ceil(input.length / <span class="hljs-number">2</span>));  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; dividend.length; i++)  &#123;    dividend[i] = (input.charCodeAt(i * <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">8</span>) | input.charCodeAt(i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);  &#125;  <span class="hljs-comment">/*</span><span class="hljs-comment">   * Repeatedly perform a long division. The binary array forms the dividend,</span><span class="hljs-comment">   * the length of the encoding is the divisor. Once computed, the quotient</span><span class="hljs-comment">   * forms the dividend for the next step. All remainders are stored for later</span><span class="hljs-comment">   * use.</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">var</span> full_length = <span class="hljs-built_in">Math</span>.ceil(input.length * <span class="hljs-number">8</span> /                                    (<span class="hljs-built_in">Math</span>.log(encoding.length) / <span class="hljs-built_in">Math</span>.log(<span class="hljs-number">2</span>)));  <span class="hljs-keyword">var</span> remainders = <span class="hljs-built_in">Array</span>(full_length);  <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; full_length; j++)  &#123;    quotient = <span class="hljs-built_in">Array</span>();    x = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; dividend.length; i++)    &#123;      x = (x &lt;&lt; <span class="hljs-number">16</span>) + dividend[i];      q = <span class="hljs-built_in">Math</span>.floor(x / divisor);      x -= q * divisor;      <span class="hljs-keyword">if</span>(quotient.length &gt; <span class="hljs-number">0</span> || q &gt; <span class="hljs-number">0</span>)        quotient[quotient.length] = q;    &#125;    remainders[j] = x;    dividend = quotient;  &#125;  <span class="hljs-comment">/* Convert the remainders to the output string */</span>  <span class="hljs-keyword">var</span> output = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">for</span>(i = remainders.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)    output += encoding.charAt(remainders[i]);  <span class="hljs-keyword">return</span> output;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Encode a string as utf-8.</span><span class="hljs-comment"> * For efficiency, this assumes the input is valid utf-16.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">str2rstr_utf8</span>(<span class="hljs-params">input</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">var</span> output = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>;  <span class="hljs-keyword">var</span> x, y;  <span class="hljs-keyword">while</span>(++i &lt; input.length)  &#123;    <span class="hljs-comment">/* Decode utf-16 surrogate pairs */</span>    x = input.charCodeAt(i);    y = i + <span class="hljs-number">1</span> &lt; input.length ? input.charCodeAt(i + <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(<span class="hljs-number">0xD800</span> &lt;= x &amp;&amp; x &lt;= <span class="hljs-number">0xDBFF</span> &amp;&amp; <span class="hljs-number">0xDC00</span> &lt;= y &amp;&amp; y &lt;= <span class="hljs-number">0xDFFF</span>)    &#123;      x = <span class="hljs-number">0x10000</span> + ((x &amp; <span class="hljs-number">0x03FF</span>) &lt;&lt; <span class="hljs-number">10</span>) + (y &amp; <span class="hljs-number">0x03FF</span>);      i++;    &#125;    <span class="hljs-comment">/* Encode output as utf-8 */</span>    <span class="hljs-keyword">if</span>(x &lt;= <span class="hljs-number">0x7F</span>)      output += <span class="hljs-built_in">String</span>.fromCharCode(x);    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt;= <span class="hljs-number">0x7FF</span>)      output += <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0xC0</span> | ((x &gt;&gt;&gt; <span class="hljs-number">6</span> ) &amp; <span class="hljs-number">0x1F</span>),                                    <span class="hljs-number">0x80</span> | ( x         &amp; <span class="hljs-number">0x3F</span>));    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt;= <span class="hljs-number">0xFFFF</span>)      output += <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0xE0</span> | ((x &gt;&gt;&gt; <span class="hljs-number">12</span>) &amp; <span class="hljs-number">0x0F</span>),                                    <span class="hljs-number">0x80</span> | ((x &gt;&gt;&gt; <span class="hljs-number">6</span> ) &amp; <span class="hljs-number">0x3F</span>),                                    <span class="hljs-number">0x80</span> | ( x         &amp; <span class="hljs-number">0x3F</span>));    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt;= <span class="hljs-number">0x1FFFFF</span>)      output += <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0xF0</span> | ((x &gt;&gt;&gt; <span class="hljs-number">18</span>) &amp; <span class="hljs-number">0x07</span>),                                    <span class="hljs-number">0x80</span> | ((x &gt;&gt;&gt; <span class="hljs-number">12</span>) &amp; <span class="hljs-number">0x3F</span>),                                    <span class="hljs-number">0x80</span> | ((x &gt;&gt;&gt; <span class="hljs-number">6</span> ) &amp; <span class="hljs-number">0x3F</span>),                                    <span class="hljs-number">0x80</span> | ( x         &amp; <span class="hljs-number">0x3F</span>));  &#125;  <span class="hljs-keyword">return</span> output;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Encode a string as utf-16</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">str2rstr_utf16le</span>(<span class="hljs-params">input</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">var</span> output = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; input.length; i++)    output += <span class="hljs-built_in">String</span>.fromCharCode( input.charCodeAt(i)        &amp; <span class="hljs-number">0xFF</span>,                                  (input.charCodeAt(i) &gt;&gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>);  <span class="hljs-keyword">return</span> output;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">str2rstr_utf16be</span>(<span class="hljs-params">input</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">var</span> output = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; input.length; i++)    output += <span class="hljs-built_in">String</span>.fromCharCode((input.charCodeAt(i) &gt;&gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>,                                   input.charCodeAt(i)        &amp; <span class="hljs-number">0xFF</span>);  <span class="hljs-keyword">return</span> output;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Convert a raw string to an array of little-endian words</span><span class="hljs-comment"> * Characters &gt;255 have their high-byte silently ignored.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rstr2binl</span>(<span class="hljs-params">input</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">var</span> output = <span class="hljs-built_in">Array</span>(input.length &gt;&gt; <span class="hljs-number">2</span>);  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; output.length; i++)    output[i] = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; input.length * <span class="hljs-number">8</span>; i += <span class="hljs-number">8</span>)    output[i&gt;&gt;<span class="hljs-number">5</span>] |= (input.charCodeAt(i / <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>) &lt;&lt; (i%<span class="hljs-number">32</span>);  <span class="hljs-keyword">return</span> output;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Convert an array of little-endian words to a string</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binl2rstr</span>(<span class="hljs-params">input</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">var</span> output = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; input.length * <span class="hljs-number">32</span>; i += <span class="hljs-number">8</span>)    output += <span class="hljs-built_in">String</span>.fromCharCode((input[i&gt;&gt;<span class="hljs-number">5</span>] &gt;&gt;&gt; (i % <span class="hljs-number">32</span>)) &amp; <span class="hljs-number">0xFF</span>);  <span class="hljs-keyword">return</span> output;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Calculate the MD5 of an array of little-endian words, and a bit length.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binl_md5</span>(<span class="hljs-params">x, len</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-comment">/* append padding */</span>  x[len &gt;&gt; <span class="hljs-number">5</span>] |= <span class="hljs-number">0x80</span> &lt;&lt; ((len) % <span class="hljs-number">32</span>);  x[(((len + <span class="hljs-number">64</span>) &gt;&gt;&gt; <span class="hljs-number">9</span>) &lt;&lt; <span class="hljs-number">4</span>) + <span class="hljs-number">14</span>] = len;  <span class="hljs-keyword">var</span> a =  <span class="hljs-number">1732584193</span>;  <span class="hljs-keyword">var</span> b = -<span class="hljs-number">271733879</span>;  <span class="hljs-keyword">var</span> c = -<span class="hljs-number">1732584194</span>;  <span class="hljs-keyword">var</span> d =  <span class="hljs-number">271733878</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; x.length; i += <span class="hljs-number">16</span>)  &#123;    <span class="hljs-keyword">var</span> olda = a;    <span class="hljs-keyword">var</span> oldb = b;    <span class="hljs-keyword">var</span> oldc = c;    <span class="hljs-keyword">var</span> oldd = d;    a = md5_ff(a, b, c, d, x[i+ <span class="hljs-number">0</span>], <span class="hljs-number">7</span> , -<span class="hljs-number">680876936</span>);    d = md5_ff(d, a, b, c, x[i+ <span class="hljs-number">1</span>], <span class="hljs-number">12</span>, -<span class="hljs-number">389564586</span>);    c = md5_ff(c, d, a, b, x[i+ <span class="hljs-number">2</span>], <span class="hljs-number">17</span>,  <span class="hljs-number">606105819</span>);    b = md5_ff(b, c, d, a, x[i+ <span class="hljs-number">3</span>], <span class="hljs-number">22</span>, -<span class="hljs-number">1044525330</span>);    a = md5_ff(a, b, c, d, x[i+ <span class="hljs-number">4</span>], <span class="hljs-number">7</span> , -<span class="hljs-number">176418897</span>);    d = md5_ff(d, a, b, c, x[i+ <span class="hljs-number">5</span>], <span class="hljs-number">12</span>,  <span class="hljs-number">1200080426</span>);    c = md5_ff(c, d, a, b, x[i+ <span class="hljs-number">6</span>], <span class="hljs-number">17</span>, -<span class="hljs-number">1473231341</span>);    b = md5_ff(b, c, d, a, x[i+ <span class="hljs-number">7</span>], <span class="hljs-number">22</span>, -<span class="hljs-number">45705983</span>);    a = md5_ff(a, b, c, d, x[i+ <span class="hljs-number">8</span>], <span class="hljs-number">7</span> ,  <span class="hljs-number">1770035416</span>);    d = md5_ff(d, a, b, c, x[i+ <span class="hljs-number">9</span>], <span class="hljs-number">12</span>, -<span class="hljs-number">1958414417</span>);    c = md5_ff(c, d, a, b, x[i+<span class="hljs-number">10</span>], <span class="hljs-number">17</span>, -<span class="hljs-number">42063</span>);    b = md5_ff(b, c, d, a, x[i+<span class="hljs-number">11</span>], <span class="hljs-number">22</span>, -<span class="hljs-number">1990404162</span>);    a = md5_ff(a, b, c, d, x[i+<span class="hljs-number">12</span>], <span class="hljs-number">7</span> ,  <span class="hljs-number">1804603682</span>);    d = md5_ff(d, a, b, c, x[i+<span class="hljs-number">13</span>], <span class="hljs-number">12</span>, -<span class="hljs-number">40341101</span>);    c = md5_ff(c, d, a, b, x[i+<span class="hljs-number">14</span>], <span class="hljs-number">17</span>, -<span class="hljs-number">1502002290</span>);    b = md5_ff(b, c, d, a, x[i+<span class="hljs-number">15</span>], <span class="hljs-number">22</span>,  <span class="hljs-number">1236535329</span>);    a = md5_gg(a, b, c, d, x[i+ <span class="hljs-number">1</span>], <span class="hljs-number">5</span> , -<span class="hljs-number">165796510</span>);    d = md5_gg(d, a, b, c, x[i+ <span class="hljs-number">6</span>], <span class="hljs-number">9</span> , -<span class="hljs-number">1069501632</span>);    c = md5_gg(c, d, a, b, x[i+<span class="hljs-number">11</span>], <span class="hljs-number">14</span>,  <span class="hljs-number">643717713</span>);    b = md5_gg(b, c, d, a, x[i+ <span class="hljs-number">0</span>], <span class="hljs-number">20</span>, -<span class="hljs-number">373897302</span>);    a = md5_gg(a, b, c, d, x[i+ <span class="hljs-number">5</span>], <span class="hljs-number">5</span> , -<span class="hljs-number">701558691</span>);    d = md5_gg(d, a, b, c, x[i+<span class="hljs-number">10</span>], <span class="hljs-number">9</span> ,  <span class="hljs-number">38016083</span>);    c = md5_gg(c, d, a, b, x[i+<span class="hljs-number">15</span>], <span class="hljs-number">14</span>, -<span class="hljs-number">660478335</span>);    b = md5_gg(b, c, d, a, x[i+ <span class="hljs-number">4</span>], <span class="hljs-number">20</span>, -<span class="hljs-number">405537848</span>);    a = md5_gg(a, b, c, d, x[i+ <span class="hljs-number">9</span>], <span class="hljs-number">5</span> ,  <span class="hljs-number">568446438</span>);    d = md5_gg(d, a, b, c, x[i+<span class="hljs-number">14</span>], <span class="hljs-number">9</span> , -<span class="hljs-number">1019803690</span>);    c = md5_gg(c, d, a, b, x[i+ <span class="hljs-number">3</span>], <span class="hljs-number">14</span>, -<span class="hljs-number">187363961</span>);    b = md5_gg(b, c, d, a, x[i+ <span class="hljs-number">8</span>], <span class="hljs-number">20</span>,  <span class="hljs-number">1163531501</span>);    a = md5_gg(a, b, c, d, x[i+<span class="hljs-number">13</span>], <span class="hljs-number">5</span> , -<span class="hljs-number">1444681467</span>);    d = md5_gg(d, a, b, c, x[i+ <span class="hljs-number">2</span>], <span class="hljs-number">9</span> , -<span class="hljs-number">51403784</span>);    c = md5_gg(c, d, a, b, x[i+ <span class="hljs-number">7</span>], <span class="hljs-number">14</span>,  <span class="hljs-number">1735328473</span>);    b = md5_gg(b, c, d, a, x[i+<span class="hljs-number">12</span>], <span class="hljs-number">20</span>, -<span class="hljs-number">1926607734</span>);    a = md5_hh(a, b, c, d, x[i+ <span class="hljs-number">5</span>], <span class="hljs-number">4</span> , -<span class="hljs-number">378558</span>);    d = md5_hh(d, a, b, c, x[i+ <span class="hljs-number">8</span>], <span class="hljs-number">11</span>, -<span class="hljs-number">2022574463</span>);    c = md5_hh(c, d, a, b, x[i+<span class="hljs-number">11</span>], <span class="hljs-number">16</span>,  <span class="hljs-number">1839030562</span>);    b = md5_hh(b, c, d, a, x[i+<span class="hljs-number">14</span>], <span class="hljs-number">23</span>, -<span class="hljs-number">35309556</span>);    a = md5_hh(a, b, c, d, x[i+ <span class="hljs-number">1</span>], <span class="hljs-number">4</span> , -<span class="hljs-number">1530992060</span>);    d = md5_hh(d, a, b, c, x[i+ <span class="hljs-number">4</span>], <span class="hljs-number">11</span>,  <span class="hljs-number">1272893353</span>);    c = md5_hh(c, d, a, b, x[i+ <span class="hljs-number">7</span>], <span class="hljs-number">16</span>, -<span class="hljs-number">155497632</span>);    b = md5_hh(b, c, d, a, x[i+<span class="hljs-number">10</span>], <span class="hljs-number">23</span>, -<span class="hljs-number">1094730640</span>);    a = md5_hh(a, b, c, d, x[i+<span class="hljs-number">13</span>], <span class="hljs-number">4</span> ,  <span class="hljs-number">681279174</span>);    d = md5_hh(d, a, b, c, x[i+ <span class="hljs-number">0</span>], <span class="hljs-number">11</span>, -<span class="hljs-number">358537222</span>);    <span class="hljs-comment">// 注释掉的是默认值</span>    <span class="hljs-comment">// c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);</span>    c = md5_hh(c, d, a, b, x[i+ <span class="hljs-number">3</span>], <span class="hljs-number">16</span>, -<span class="hljs-number">722521939</span>);    <span class="hljs-comment">// b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);</span>    b = md5_hh(b, c, d, a, x[i+ <span class="hljs-number">6</span>], <span class="hljs-number">23</span>,  <span class="hljs-number">76029185</span>);    a = md5_hh(a, b, c, d, x[i+ <span class="hljs-number">9</span>], <span class="hljs-number">4</span> , -<span class="hljs-number">640364487</span>);    d = md5_hh(d, a, b, c, x[i+<span class="hljs-number">12</span>], <span class="hljs-number">11</span>, -<span class="hljs-number">421815835</span>);    c = md5_hh(c, d, a, b, x[i+<span class="hljs-number">15</span>], <span class="hljs-number">16</span>,  <span class="hljs-number">530742520</span>);    b = md5_hh(b, c, d, a, x[i+ <span class="hljs-number">2</span>], <span class="hljs-number">23</span>, -<span class="hljs-number">995338651</span>);    a = md5_ii(a, b, c, d, x[i+ <span class="hljs-number">0</span>], <span class="hljs-number">6</span> , -<span class="hljs-number">198630844</span>);    d = md5_ii(d, a, b, c, x[i+ <span class="hljs-number">7</span>], <span class="hljs-number">10</span>,  <span class="hljs-number">1126891415</span>);    c = md5_ii(c, d, a, b, x[i+<span class="hljs-number">14</span>], <span class="hljs-number">15</span>, -<span class="hljs-number">1416354905</span>);    b = md5_ii(b, c, d, a, x[i+ <span class="hljs-number">5</span>], <span class="hljs-number">21</span>, -<span class="hljs-number">57434055</span>);    a = md5_ii(a, b, c, d, x[i+<span class="hljs-number">12</span>], <span class="hljs-number">6</span> ,  <span class="hljs-number">1700485571</span>);    d = md5_ii(d, a, b, c, x[i+ <span class="hljs-number">3</span>], <span class="hljs-number">10</span>, -<span class="hljs-number">1894986606</span>);    c = md5_ii(c, d, a, b, x[i+<span class="hljs-number">10</span>], <span class="hljs-number">15</span>, -<span class="hljs-number">1051523</span>);    b = md5_ii(b, c, d, a, x[i+ <span class="hljs-number">1</span>], <span class="hljs-number">21</span>, -<span class="hljs-number">2054922799</span>);    a = md5_ii(a, b, c, d, x[i+ <span class="hljs-number">8</span>], <span class="hljs-number">6</span> ,  <span class="hljs-number">1873313359</span>);    d = md5_ii(d, a, b, c, x[i+<span class="hljs-number">15</span>], <span class="hljs-number">10</span>, -<span class="hljs-number">30611744</span>);    c = md5_ii(c, d, a, b, x[i+ <span class="hljs-number">6</span>], <span class="hljs-number">15</span>, -<span class="hljs-number">1560198380</span>);    b = md5_ii(b, c, d, a, x[i+<span class="hljs-number">13</span>], <span class="hljs-number">21</span>,  <span class="hljs-number">1309151649</span>);    a = md5_ii(a, b, c, d, x[i+ <span class="hljs-number">4</span>], <span class="hljs-number">6</span> , -<span class="hljs-number">145523070</span>);    d = md5_ii(d, a, b, c, x[i+<span class="hljs-number">11</span>], <span class="hljs-number">10</span>, -<span class="hljs-number">1120210379</span>);    c = md5_ii(c, d, a, b, x[i+ <span class="hljs-number">2</span>], <span class="hljs-number">15</span>,  <span class="hljs-number">718787259</span>);    b = md5_ii(b, c, d, a, x[i+ <span class="hljs-number">9</span>], <span class="hljs-number">21</span>, -<span class="hljs-number">343485551</span>);    a = safe_add(a, olda);    b = safe_add(b, oldb);    c = safe_add(c, oldc);    d = safe_add(d, oldd);  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>(a, b, c, d);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * These functions implement the four basic operations the algorithm uses.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">md5_cmn</span>(<span class="hljs-params">q, a, b, x, s, t</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">md5_ff</span>(<span class="hljs-params">a, b, c, d, x, s, t</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> md5_cmn((b &amp; c) | ((~b) &amp; d), a, b, x, s, t);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">md5_gg</span>(<span class="hljs-params">a, b, c, d, x, s, t</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> md5_cmn((b &amp; d) | (c &amp; (~d)), a, b, x, s, t);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">md5_hh</span>(<span class="hljs-params">a, b, c, d, x, s, t</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> md5_cmn(b ^ c ^ d, a, b, x, s, t);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">md5_ii</span>(<span class="hljs-params">a, b, c, d, x, s, t</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> md5_cmn(c ^ (b | (~d)), a, b, x, s, t);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Add integers, wrapping at 2^32. This uses 16-bit operations internally</span><span class="hljs-comment"> * to work around bugs in some JS interpreters.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safe_add</span>(<span class="hljs-params">x, y</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">var</span> lsw = (x &amp; <span class="hljs-number">0xFFFF</span>) + (y &amp; <span class="hljs-number">0xFFFF</span>);  <span class="hljs-keyword">var</span> msw = (x &gt;&gt; <span class="hljs-number">16</span>) + (y &gt;&gt; <span class="hljs-number">16</span>) + (lsw &gt;&gt; <span class="hljs-number">16</span>);  <span class="hljs-keyword">return</span> (msw &lt;&lt; <span class="hljs-number">16</span>) | (lsw &amp; <span class="hljs-number">0xFFFF</span>);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Bitwise rotate a 32-bit number to the left.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bit_rol</span>(<span class="hljs-params">num, cnt</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (<span class="hljs-number">32</span> - cnt));&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSignature</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> hex_md5(<span class="hljs-built_in">Date</span>.parse(<span class="hljs-built_in">Date</span>()).toString())&#125;<span class="hljs-built_in">console</span>.log(getSignature())</code></pre><p>Python 调用代码：</p><pre><code class="hljs python"><span class="hljs-comment"># ==================================</span><span class="hljs-comment"># --*-- coding: utf-8 --*--</span><span class="hljs-comment"># @Time    : 2021-12-23</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: challenge_7.py</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ==================================</span><span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> execjs<span class="hljs-keyword">import</span> requestschallenge_api = <span class="hljs-string">&quot;http://spider.wangluozhe.com/challenge/api/7&quot;</span>headers = &#123;    <span class="hljs-string">&quot;Cookie&quot;</span>: <span class="hljs-string">&quot;Cookie 替换成你的&quot;</span>,    <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;spider.wangluozhe.com&quot;</span>,    <span class="hljs-string">&quot;Origin&quot;</span>: <span class="hljs-string">&quot;http://spider.wangluozhe.com&quot;</span>,    <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;http://spider.wangluozhe.com/challenge/7&quot;</span>,    <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&quot;</span>,    <span class="hljs-string">&quot;X-Requested-With&quot;</span>: <span class="hljs-string">&quot;XMLHttpRequest&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_signature</span>():</span>    now = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(time.time())) + <span class="hljs-string">&quot;000&quot;</span>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;challenge_7.js&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:        wlz_js = execjs.<span class="hljs-built_in">compile</span>(f.read())    <span class="hljs-comment"># signature = wlz_js.call(&quot;getSignature&quot;)</span>    signature = wlz_js.call(<span class="hljs-string">&quot;hex_md5&quot;</span>, now)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;signature: &quot;</span>, signature)    <span class="hljs-keyword">return</span> signature<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>    result = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>):        data = &#123;            <span class="hljs-string">&quot;page&quot;</span>: page,            <span class="hljs-string">&quot;count&quot;</span>: <span class="hljs-number">10</span>,            <span class="hljs-string">&quot;_signature&quot;</span>: get_signature()        &#125;        response = requests.post(url=challenge_api, headers=headers, data=data).json()        <span class="hljs-built_in">print</span>(response)        <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> response[<span class="hljs-string">&quot;data&quot;</span>]:            result += d[<span class="hljs-string">&quot;value&quot;</span>]    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;结果为: &quot;</span>, result)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    main()</code></pre><p>这里还有一点小细节，如果是 Python 生成时间戳传入 JS 的 <code>hex_md5</code> 方法的话，要保证时间戳的最后三位为0，不然校验通不过，通常的写法是 <code>str(int(time.time() * 1000))</code>，这里要改一下：<code>str(int(time.time())) + &quot;000&quot;</code>，不用 Python 的话，也可以在 JS 里写个方法直接返回 <code>hex_md5(Date.parse(Date()).toString())</code> 也行。</p><p><strong>还有一个问题就是如果你找的 MD5 代码不规范，准确来说是和题目使用的 MD5 代码不太一样的话，有可能本地要改的地方就不止这两处了，所以尽量找一个方法名都一样的JS，能省不少事儿。</strong></p><h3 id="日志断点-插桩调试">日志断点 / 插桩调试</h3><p>除了 Hook 以外，我们还可以通过插桩调试的方式，将整个生成 <code>_signature</code> 的流程、涉及到的参数、生成的值，都通过日志的形式打印出来，逆向分析其逻辑。PS：插桩，即日志断点，鼠标右键选择 <code>Add logpoint</code> 即可添加一个日志断点，相当于 <code>console.log()</code>，此功能是 Chrome 73 版本新增的。</p><p><img src="https://cdn.itbob.cn/img/article/050/11.png" alt="11"></p><ul><li><strong>Add breakpoint</strong>：添加普通断点；</li><li><strong>Add conditional breakpoint</strong>：添加条件断点，满足条件才断下；</li><li><strong>Add logpoint</strong>：添加日志断点；</li><li><strong>Never pause here</strong>：永不在此处断下；</li><li><strong>Add script to ignore list</strong>：网站的部分 JS，比如 <code>jquery.min.js</code> 之类的库文件，我们单步调试的时候并不想进入到该文件中，那么可以将此类文件右键添加忽略掉。</li></ul><p>关键的日志断点有以下三处：</p><ul><li>第 605 行，<code>arguments</code> 为当前传入函数的参数值；</li><li>第 141 行，<code>___.join(vV_)</code> 为当前调用的方法名称，也会输出方法中的参数名称；</li><li>第 591 行，<code>__V(_, ___(u_), 0, 0, _U__).apply(void 0, y__(v___))</code> 为当前方法执行完毕的结果。</li></ul><p>肯定有人会疑惑，如何知道应该在这三个地方下日志断点呢？答案是只能自己单步、多步调试，找规律、仔细观察，就像交流群里的小小白大佬说的一样，屁股坐烂就行了。当然也不是只有这三个地方能输出对应的信息，有可能其他地方也可以，这就要看你自己调试了。</p><p><img src="https://cdn.itbob.cn/img/article/050/12.png" alt="12"></p><p><img src="https://cdn.itbob.cn/img/article/050/13.png" alt="13"></p><p><img src="https://cdn.itbob.cn/img/article/050/14.png" alt="14"></p><p>除了这三个地方的日志断点以外，建议还可以在第 606 行打个断点，这样每次执行一个方法就断下，本地就可以跟着同步调试，挨个对比传入的参数和得到的结果，不至于一下子输出的东西太多，不方便查找。</p><p>第一步，<code>gnature = window.byted_acrawler(window.sign())</code>：</p><p><img src="https://cdn.itbob.cn/img/article/050/15.png" alt="15"></p><p>下一步，sign 方法，取时间戳：</p><p><img src="https://cdn.itbob.cn/img/article/050/16.png" alt="16"></p><p>下一步，调用 <code>hex_md5()</code> 方法：</p><p><img src="https://cdn.itbob.cn/img/article/050/17.png" alt="17"></p><p>从这里就可以开始本地同步调试了，本地 MD5 下断点调试，可以看到得到的值不一样：</p><p><img src="https://cdn.itbob.cn/img/article/050/18.png" alt="18"></p><p>下一步，调用 <code>str2binl()</code> 方法，和本地得到的值是一样的：</p><p><img src="https://cdn.itbob.cn/img/article/050/19.png" alt="19"></p><p><img src="https://cdn.itbob.cn/img/article/050/20.png" alt="20"></p><p>下一步，调用 <code>core_md5()</code> 方法，得到的值和本地就不一样了，这里大致可以确定此方法内部与标准算法有差别了：</p><p><img src="https://cdn.itbob.cn/img/article/050/21.png" alt="21"></p><p><img src="https://cdn.itbob.cn/img/article/050/22.png" alt="22"></p><p>下一步，调用 <code>md5_ff()</code> 方法，得到的值是一样的：</p><p><img src="https://cdn.itbob.cn/img/article/050/23.png" alt="23"></p><p><img src="https://cdn.itbob.cn/img/article/050/24.png" alt="24"></p><p>以此类推，最终会找到两个不一样的地方，即 <code>md5_hh()</code> 两个默认参数被修改了。</p><p><code>-722521979</code> 被改成了 <code>-722521939</code>：</p><p><img src="https://cdn.itbob.cn/img/article/050/25.png" alt="25"></p><p><img src="https://cdn.itbob.cn/img/article/050/26.png" alt="26"></p><p><code>76029189</code> 被改成了 <code>76029185</code>：</p><p><img src="https://cdn.itbob.cn/img/article/050/27.png" alt="27"></p><p><img src="https://cdn.itbob.cn/img/article/050/28.png" alt="28"></p><p>最终提交结果，验证成功：</p><p><img src="https://cdn.itbob.cn/img/article/050/29.png" alt="29"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/javascript_reverse.png&quot; alt=&quot;javascript_reverse&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>拉勾网 traceparent、__lg_stoken__、X-S-HEADER 等参数逆向分析</title>
    <link href="https://www.itbob.cn/article/049/"/>
    <id>https://www.itbob.cn/article/049/</id>
    <published>2022-03-16T04:18:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/javascript_reverse.png" alt="javascript_reverse"></p><h2 id="声明">声明</h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2 id="逆向目标">逆向目标</h2><p>本次的目标是拉勾网职位的爬取，涉及到的一些关键参数如下：</p><ul><li>请求头参数：<code>traceparent</code>、<code>X-K-HEADER</code>、<code>X-S-HEADER</code>、<code>X-SS-REQ-HEADER</code>、<code>x-anit-forge-code</code>、<code>x-anit-forge-token</code></li><li>Cookie 值：<code>user_trace_token</code>、<code>X_HTTP_TOKEN</code>、<code>__lg_stoken__</code></li><li>POST 请求数据加密，返回的加密职位信息解密，AES 算法</li></ul><p>参数比较多，但事实上有些参数固定、或者直接不要，也是可以的，比如 Cookie 的三个值，请求头的 <code>X-K-HEADER</code>、<code>X-SS-REQ-HEADER</code> 等可以固定，<code>x-anit-forge-code</code> 和 <code>x-anit-forge-token</code> 可有可无。尽管如此，本文还是把每个参数的来源都分析了，可根据你实际情况灵活处理。</p><p>另外即便是把所有参数都补齐了，拉勾网对于单个 IP 还有频率限制，抓不了几次就要求登录，可自行搭配代理进行抓取，或者复制账号登录后的 cookies 到代码里，可以解除限制，如果是账号登录后访问，请求头多了两个参数，即 <code>x-anit-forge-code</code> 和 <code>x-anit-forge-token</code>，经过测试这两个参数其实不要也行。</p><h2 id="抓包分析">抓包分析</h2><p>搜索职位，点击翻页，就可以看到一条名为 positionAjax.json 的 Ajax 请求，不难判断这就是返回的职位信息。重点参数已在图中框出来了。</p><p>未登录，正常 IP，正常请求，Header 以及 Cookies：</p><p><img src="https://cdn.itbob.cn/img/article/049/01.png" alt="01"></p><p><img src="https://cdn.itbob.cn/img/article/049/02.png" alt="02"></p><p>异常 IP，登录账号后再请求，Header 以及 Cookies：</p><p><img src="https://cdn.itbob.cn/img/article/049/03.png" alt="03"></p><p><img src="https://cdn.itbob.cn/img/article/049/04.png" alt="04"></p><p>请求数据和返回数据都经过了加密：</p><p><img src="https://cdn.itbob.cn/img/article/049/05.png" alt="05"></p><h2 id="Cookies-参数">Cookies 参数</h2><p>先看 cookies 里的关键参数，主要是 <code>user_trace_token</code>、<code>X_HTTP_TOKEN</code> 和 <code>__lg_stoken__</code>。</p><h3 id="user-trace-token">user_trace_token</h3><p>通过接口返回的，直接搜索就可以找到，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/049/06.png" alt="06"></p><p><img src="https://cdn.itbob.cn/img/article/049/07.png" alt="07"></p><p>请求参数，time 是时间戳，a 值随便，没有都可以，不影响，其他值都是定值，获取的关键代码如下：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user_trace_token</span>() -&gt; <span class="hljs-built_in">str</span>:</span>    <span class="hljs-comment"># 获取 cookie 中的 user_trace_token</span>    json_url = <span class="hljs-string">&quot;https://a.脱敏处理.com/json&quot;</span>    headers = &#123;        <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;a.脱敏处理.com&quot;</span>,        <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com/&quot;</span>,        <span class="hljs-string">&quot;User-Agent&quot;</span>: UA    &#125;    params = &#123;        <span class="hljs-string">&quot;lt&quot;</span>: <span class="hljs-string">&quot;trackshow&quot;</span>,        <span class="hljs-string">&quot;t&quot;</span>: <span class="hljs-string">&quot;ad&quot;</span>,        <span class="hljs-string">&quot;v&quot;</span>: <span class="hljs-number">0</span>,        <span class="hljs-string">&quot;dl&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com/&quot;</span>,        <span class="hljs-string">&quot;dr&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com&quot;</span>,        <span class="hljs-string">&quot;time&quot;</span>: <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(time.time() * <span class="hljs-number">1000</span>))    &#125;    response = requests.get(url=json_url, headers=headers, params=params)    user_trace_token = response.cookies.get_dict()[<span class="hljs-string">&quot;user_trace_token&quot;</span>]    <span class="hljs-keyword">return</span> user_trace_token</code></pre><h3 id="X-HTTP-TOKEN">X_HTTP_TOKEN</h3><p>直接搜索没有值，直接上 Hook 大法，小白朋友不清楚的话可以看以前的文章，都有详细教程，这里不再细说。</p><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-meta">    &#x27;use strict&#x27;</span>;    <span class="hljs-keyword">var</span> cookieTemp = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">document</span>, <span class="hljs-string">&#x27;cookie&#x27;</span>, &#123;        <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hook捕获到cookie设置-&gt;&#x27;</span>, val);            <span class="hljs-keyword">if</span> (val.indexOf(<span class="hljs-string">&#x27;X_HTTP_TOKEN&#x27;</span>) != -<span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">debugger</span>;            &#125;            cookieTemp = val;            <span class="hljs-keyword">return</span> val;        &#125;,        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">return</span> cookieTemp;        &#125;    &#125;);&#125;)();</code></pre><p><img src="https://cdn.itbob.cn/img/article/049/08.png" alt="08"></p><p>往上跟栈调试，是一个小小的 OB 混淆，<code>_0x32e0d2</code> 就是最后的 <code>X_HTTP_TOKEN</code> 值了，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/049/09.png" alt="09"></p><p>直接梭哈，才300多行，不必扣了，全部 copy 下来，本地运行，发现会报错 document 未定义，定位到代码位置，下断点调试一下，发现是正则匹配 cookie 中的 <code>user_trace_token</code> 的值，那么我们直接定义一下即可：<code>var document = &#123;&quot;cookie&quot;: cookie&#125;</code>，cookie 值把 <code>user_trace_token</code> 传过来即可。</p><p><img src="https://cdn.itbob.cn/img/article/049/10.png" alt="10"></p><p>补全 document 后，再次运行，又会报错 window 未定义，再次定位到源码，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/049/11.png" alt="11"></p><p>分析一下，取了 window XMLHttpRequest 对象，向 wafcheck.json 这个接口发送了一个 Ajax GET 请求，然后取了 Response Header 的 Date 值赋值给 <code>_0x309ac8</code>，注意这个 Date 值比正常时间晚了8个小时，然而取 Date 值并没有什么用，因为后面又 new 了一个新 Date 标准时间，赋值给了 <code>_0x150c4d</code>，<code>new Date(_0x309ac8[_0x3551('0x2d')](/-/g, '/'))</code> 语句虽然用到了前面的旧 Date，然而实际上是 <code>replace()</code> 替换方法，与旧的 Date 并没有什么关系，然后调用 <code>Date.parse()</code> 方法将新 Date 转换成时间戳赋值给 <code>_0x4e6d5d</code>，所以不需要这么复杂，直接本地把 <code>_0x89ea429</code> 方法修改一下就行了：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 原方法</span><span class="hljs-comment">// function _0x89ea42() &#123;</span><span class="hljs-comment">//     var _0x372cc0 = null;</span><span class="hljs-comment">//     if (window[_0x3551(&#x27;0x26&#x27;)]) &#123;</span><span class="hljs-comment">//         _0x372cc0 = new window[(_0x3551(&#x27;0x26&#x27;))]();</span><span class="hljs-comment">//     &#125; else &#123;</span><span class="hljs-comment">//         _0x372cc0 = new ActiveObject(_0x3551(&#x27;0x27&#x27;));</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">//     _0x372cc0[_0x3551(&#x27;0x28&#x27;)](_0x3551(&#x27;0x29&#x27;), _0x3551(&#x27;0x2a&#x27;), ![]);</span><span class="hljs-comment">//     _0x372cc0[_0x3551(&#x27;0x2b&#x27;)](null);</span><span class="hljs-comment">//     var _0x309ac8 = _0x372cc0[_0x3551(&#x27;0x2c&#x27;)](&#x27;Date&#x27;);</span><span class="hljs-comment">//     var _0x150c4d = new Date(_0x309ac8[_0x3551(&#x27;0x2d&#x27;)](/-/g, &#x27;/&#x27;));</span><span class="hljs-comment">//     var _0x4e6d5d = Date[_0x3551(&#x27;0x2e&#x27;)](_0x150c4d);</span><span class="hljs-comment">//     return _0x4e6d5d / 0x3e8;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// 本地改写</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x89ea42</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> _0x150c4d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();    <span class="hljs-keyword">var</span> _0x4e6d5d = <span class="hljs-built_in">Date</span>.parse(_0x150c4d);    <span class="hljs-keyword">return</span> _0x4e6d5d / <span class="hljs-number">0x3e8</span>;&#125;</code></pre><p>本地测试 OK：</p><p><img src="https://cdn.itbob.cn/img/article/049/12.png" alt="12"></p><h3 id="lg-stoken"><strong>lg_stoken</strong></h3><p><code>__lg_stoken__</code> 这个参数是在点击搜索后才开始生成的，直接搜索同样没值，Hook 一下，往上跟栈，很容易找到生成位置：</p><p><img src="https://cdn.itbob.cn/img/article/049/13.png" alt="13"></p><p><img src="https://cdn.itbob.cn/img/article/049/14.png" alt="14"></p><p>可以看到 d 就是 <code>__lg_stoken__</code> 的值，<code>d = (new g()).a()</code>、<code>g = window.gt</code>，<code>window.gt</code> 实际上是调用了 <code>_0x11db59</code></p><p>跟进混淆的 JS 看一下，就会发现末尾的这段代码是关键，这里用到了 prototype 原型对象，我们直接 <code>window.gt.prototype.a()</code> 或者 <code>(new window.gt).a()</code> 就能获取到 <code>__lg_stoken__</code>，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/049/15.png" alt="15"></p><p>到这里也许你想下断点去调试一下，看看能不能扣个逻辑出来，但是你会发现刷新之后断不下，因为这个混淆 JS 文件是一直在变化的，之前的断点就不管用了，然后你就可能会想到直接替换掉这个 JS，让文件名固定下来，就可以断点调试了，如果你这样操作的话，重新刷新会发现一直在加载中，打开控制台会发现报错了，造成这样的原因就在于这个混淆 JS 不仅文件名会改变，他的内容也会改变，当然，内容也不仅仅是改变了变量名那么简单，有些值也是动态变化的，比如：</p><p><img src="https://cdn.itbob.cn/img/article/049/16.png" alt="16"></p><p>这里我们先不管那么多，直接把所有的混淆代码 copy 下来，先在本地调试一下，看看能不能跑通，调试过程中，先后会提示 <code>window is not defined</code>、<code>Cannot read properties of undefined (reading 'hostname')</code>，定位到代码，有个取 <code>window.location.hostname</code> 的操作，本地定义一下就行了：</p><p><img src="https://cdn.itbob.cn/img/article/049/17.png" alt="17"></p><p>再次调试又会报错 <code> Cannot read properties of undefined (reading 'substr')</code>，<code>substr()</code> 方法可在字符串中抽取从指定下标开始的、指定数目的字符，是字符串对象 stringObject 具有的方法，我们定位到代码，发现是 <code>window.location.search</code> 对象调用了 <code>substr()</code> 方法，所以同样的，我们本地也要补齐。</p><p><img src="https://cdn.itbob.cn/img/article/049/18.png" alt="18"></p><p>本地补齐参数后，运行结果与网页一致：</p><p><img src="https://cdn.itbob.cn/img/article/049/19.png" alt="19"></p><p>执行结果没问题了，那么还有一个问题，<code>window.location.search</code> 的值就是待加密参数了，是咋来的呢？我们直接搜索，就可以看到是一个接口302跳转的地址，用的时候直接取就行了，这个接口是你搜索内容组成的，搜索不同参数，这个跳转地址也是不一样的：</p><p><img src="https://cdn.itbob.cn/img/article/049/20.png" alt="20"></p><p>调试成功后，我们随便换一个搜索关键词，将得到的302跳转地址拿到这个 JS 中，加密一下，发现会报错，这说明混淆 JS 传入的参数和 JS 内容应该是相对应的，这里的做法是直接请求拿到这个 JS 文件内容，然后把要补的 window 和获取 <code>__lg_stoken__</code> 的方法加进去，然后直接执行就行了。</p><p>获取 <code>__lg_stoken__</code>  的关键代码如下（<code>original_data</code> 为原始搜索数据）：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_lg_stoken</span>(<span class="hljs-params">original_data: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">str</span>:</span>    <span class="hljs-comment"># 获取 cookie 中的 __lg_stoken__</span>    token_url = <span class="hljs-string">&quot;https://www.脱敏处理.com/wn/jobs&quot;</span>    token_headers = &#123;        <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.com&quot;</span>,        <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com/&quot;</span>,        <span class="hljs-string">&quot;User-Agent&quot;</span>: UA    &#125;    params = &#123;        <span class="hljs-string">&quot;kd&quot;</span>: original_data[<span class="hljs-string">&quot;kd&quot;</span>],        <span class="hljs-string">&quot;city&quot;</span>: original_data[<span class="hljs-string">&quot;city&quot;</span>]    &#125;    token_response = requests.get(url=token_url, params=params, headers=token_headers, cookies=global_cookies, allow_redirects=<span class="hljs-literal">False</span>)    <span class="hljs-keyword">if</span> token_response.status_code != <span class="hljs-number">302</span>:        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;获取跳转链接异常！检查 global_cookies 是否已包含 __lg_stoken__！&quot;</span>)    <span class="hljs-comment"># 获取 302 跳转的地址</span>    security_check_url = token_response.headers[<span class="hljs-string">&quot;Location&quot;</span>]    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;login&quot;</span> <span class="hljs-keyword">in</span> security_check_url:        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;IP 被关进小黑屋啦！需要登录！请补全登录后的 Cookie，或者自行添加代理！&quot;</span>)    parse_result = parse.urlparse(security_check_url)    <span class="hljs-comment"># url 的参数为待加密对象</span>    security_check_params = parse_result.query    <span class="hljs-comment"># 取 name 参数，为混淆 js 的文件名</span>    security_check_js_name = parse.parse_qs(security_check_params)[<span class="hljs-string">&quot;name&quot;</span>][<span class="hljs-number">0</span>]    <span class="hljs-comment"># 发送请求，获取混淆的 js</span>    js_url = <span class="hljs-string">&quot;https://www.脱敏处理.com/common-sec/dist/&quot;</span> + security_check_js_name + <span class="hljs-string">&quot;.js&quot;</span>    js_headers = &#123;        <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.com&quot;</span>,        <span class="hljs-string">&quot;Referer&quot;</span>: security_check_url,        <span class="hljs-string">&quot;User-Agent&quot;</span>: UA    &#125;    js_response = requests.get(url=js_url, headers=js_headers, cookies=global_cookies).text    <span class="hljs-comment"># 补全 js，添加 window 参数和一个方法，用于获取 __lg_stoken__ 的值</span>    lg_js = <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    window = &#123;</span><span class="hljs-string">        &quot;location&quot;: &#123;</span><span class="hljs-string">            &quot;hostname&quot;: &quot;www.脱敏处理.com&quot;,</span><span class="hljs-string">            &quot;search&quot;: &#x27;?%s&#x27;</span><span class="hljs-string">        &#125;</span><span class="hljs-string">    &#125;</span><span class="hljs-string">    function getLgStoken()&#123;</span><span class="hljs-string">        return window.gt.prototype.a()</span><span class="hljs-string">    &#125;</span><span class="hljs-string">    &quot;&quot;&quot;</span> % security_check_params + js_response    lg_stoken = execjs.<span class="hljs-built_in">compile</span>(lg_js).call(<span class="hljs-string">&quot;getLgStoken&quot;</span>)    <span class="hljs-keyword">return</span> lg_stoken</code></pre><h2 id="请求头参数">请求头参数</h2><p>请求头参数比较多，有 <code>traceparent</code>、<code>X-K-HEADER</code>、<code>X-S-HEADER</code>、<code>X-SS-REQ-HEADER</code>、<code>x-anit-forge-code</code>、<code>x-anit-forge-token</code>，其中最后两个 <code>x-anit</code> 开头的参数是登录后才有的，实际测试中，即便是登录了，不加这两个好像也行。不过还是分析一下吧。</p><h3 id="x-anit-forge-code-x-anit-forge-token">x-anit-forge-code / x-anit-forge-token</h3><p>这两个值是首次点击搜索生成的，第一次访问搜索接口，返回的 HTML 里面夹杂了一个 JSON 文件，里面的 <code>submitCode</code> 和 <code>submitToken</code> 就是 <code>x-anit-forge-code</code> 和 <code>x-anit-forge-token</code> 的值，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/049/21.png" alt="21"></p><p>请求这个接口要注意带上登录后的 cookies，有用的只有四个值，正确的 cookies 类似于：</p><pre><code class="hljs python">cookies = &#123;    <span class="hljs-string">&quot;login&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>,    <span class="hljs-string">&quot;gate_login_token&quot;</span>: <span class="hljs-string">&quot;54a31e93aa904a6bb9731bxxxxxxxxxxxxxx&quot;</span>,    <span class="hljs-string">&quot;_putrc&quot;</span>: <span class="hljs-string">&quot;9550E53D830BE8xxxxxxxxxxxxxx&quot;</span>,    <span class="hljs-string">&quot;JSESSIONID&quot;</span>: <span class="hljs-string">&quot;ABAAAECABIEACCA79BFxxxxxxxxxxxxxx&quot;</span>&#125;</code></pre><p>注意，JSESSIONID 即便不登录也会有，但是登录时应该会携带这个值，进行一个激活操作，如果你请求获取到的 submitCode、submitToken 为空，那么就有可能 JSESSIONID 是无效的，以上所有值都必须登录后复制过来！</p><p>获取 <code> x-anit-forge-code</code>、<code>x-anit-forge-token</code>  的关键代码如下（<code>original_data</code> 为原始搜索数据）：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_x_anit</span>(<span class="hljs-params">original_data: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-literal">None</span>:</span>    <span class="hljs-comment"># 更新 x-anit-forge-code 和 x-anit-forge-token</span>    url = <span class="hljs-string">&quot;https://www.脱敏处理.com/wn/jobs&quot;</span>    headers = &#123;        <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.com&quot;</span>,        <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com/&quot;</span>,        <span class="hljs-string">&quot;User-Agent&quot;</span>: UA    &#125;    params = &#123;        <span class="hljs-string">&quot;kd&quot;</span>: original_data[<span class="hljs-string">&quot;kd&quot;</span>],        <span class="hljs-string">&quot;city&quot;</span>: original_data[<span class="hljs-string">&quot;city&quot;</span>]    &#125;    response = requests.get(url=url, params=params, headers=headers, cookies=global_cookies)    tree = etree.HTML(response.text)    next_data_json = json.loads(tree.xpath(<span class="hljs-string">&quot;//script[@id=&#x27;__NEXT_DATA__&#x27;]/text()&quot;</span>)[<span class="hljs-number">0</span>])    submit_code = next_data_json[<span class="hljs-string">&quot;props&quot;</span>][<span class="hljs-string">&quot;tokenData&quot;</span>][<span class="hljs-string">&quot;submitCode&quot;</span>]    submit_token = next_data_json[<span class="hljs-string">&quot;props&quot;</span>][<span class="hljs-string">&quot;tokenData&quot;</span>][<span class="hljs-string">&quot;submitToken&quot;</span>]    <span class="hljs-comment"># 注意 JSESSIONID 必须是登录验证后的！</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> submit_code <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> submit_token:        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;submitCode &amp; submitToken 为空，请检查 JSESSIONID 是否正确！&quot;</span>)    <span class="hljs-keyword">global</span> x_anit    x_anit[<span class="hljs-string">&quot;x-anit-forge-code&quot;</span>] = submit_code    x_anit[<span class="hljs-string">&quot;x-anit-forge-token&quot;</span>] = submit_token</code></pre><h3 id="traceparent">traceparent</h3><p>同样的 Hook 大法，跟栈：</p><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> org = <span class="hljs-built_in">window</span>.XMLHttpRequest.prototype.setRequestHeader;    <span class="hljs-built_in">window</span>.XMLHttpRequest.prototype.setRequestHeader = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key, value</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hook 捕获到 %s 设置 -&gt; %s&#x27;</span>, key, value);        <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&#x27;traceparent&#x27;</span>) &#123;            <span class="hljs-keyword">debugger</span>;        &#125;        <span class="hljs-keyword">return</span> org.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);    &#125;;&#125;)();</code></pre><p><img src="https://cdn.itbob.cn/img/article/049/22.png" alt="22"></p><p><img src="https://cdn.itbob.cn/img/article/049/23.png" alt="23"></p><p>观察上面的代码，三元表达式，<code>t.sampled</code> 为 <code>true</code>，所以 <code>e</code> 值为 <code>01</code>，<code>n</code> 值为 <code>t.id</code>，重点在于 <code>t.traceId</code> 和 <code>t.id</code> 了，跟栈发现很难调，直接搜索关键字，可找到生成的位置：</p><p><img src="https://cdn.itbob.cn/img/article/049/24.png" alt="24"></p><p><img src="https://cdn.itbob.cn/img/article/049/25.png" alt="25"></p><p>把 <code>E()</code> 方法扣出来就行了，改写一下即可：</p><pre><code class="hljs javascript">getRandomValues = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;get-random-values&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">E</span>(<span class="hljs-params">t</span>) </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> b = [], w = <span class="hljs-number">0</span>; w &lt; <span class="hljs-number">256</span>; ++w)            b[w] = (w + <span class="hljs-number">256</span>).toString(<span class="hljs-number">16</span>).substr(<span class="hljs-number">1</span>);    <span class="hljs-keyword">var</span> T = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">16</span>);    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t</span>) </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e = [], n = <span class="hljs-number">0</span>; n &lt; t.length; n++)            e.push(b[t[n]]);        <span class="hljs-keyword">return</span> e.join(<span class="hljs-string">&quot;&quot;</span>)    &#125;(getRandomValues(T)).substr(<span class="hljs-number">0</span>, t)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTraceparent</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;00-&quot;</span> + E() + <span class="hljs-string">&quot;-&quot;</span> + E(<span class="hljs-number">16</span>) + <span class="hljs-string">&quot;-&quot;</span> + <span class="hljs-string">&quot;01&quot;</span>&#125;<span class="hljs-comment">// 测试输出</span><span class="hljs-comment">// console.log(getTraceparent())</span></code></pre><h3 id="X-K-HEADER-X-SS-REQ-HEADER">X-K-HEADER / X-SS-REQ-HEADER</h3><p><code>X-K-HEADER</code> 和 <code>X-SS-REQ-HEADER</code> 数据是一样的，只不过后者是键值对形式，先直接全局搜索关键字，发现都是从本地拿这两个值，清除 cookie 就为空了，那么直接搜索值，发现是 agreement 这个接口返回的，<code>secretKeyValue</code> 值就是我们要的，有可能浏览器抓包直接搜索的话搜索不到，使用抓包工具，比如 Fiddler 就能搜到了，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/049/26.png" alt="26"></p><p>这个接口是 post 请求，请求带了一个 json 数据，<code>secretKeyDecode</code>，直接搜索关键字，就一个值，定位跟栈：</p><p><img src="https://cdn.itbob.cn/img/article/049/27.png" alt="27"></p><p><code>zt()</code> 是从本地缓存中取，<code>At()</code> 是重新生成：</p><p><img src="https://cdn.itbob.cn/img/article/049/28.png" alt="28"></p><p>这里就非常明显了，t 是32位随机字符串，赋值为 <code>aesKey</code>，后面紧接着一个 RSA 加密了 <code>aesKey</code>，赋值为 <code>rsaEncryptData</code>，而 <code>rsaEncryptData</code> 就是前面 agreement 接口请求的 <code>secretKeyValue</code> 值。</p><p>这里先说一下，最终搜索职位请求的 data 和返回数据都是 AES 加密解密，会用到这个 <code>aesKey</code>，请求头的另一个参数 <code>X-S-HEADER</code> 也会用到，如果这个 key 没有经过 RSA 加密并通过 agreement 接口验证的话，是无效的，可以理解为 agreement 接口既是为了获取 <code>X-K-HEADER</code> 和 <code>X-SS-REQ-HEADER</code>，也是为了激活这个 <code>aesKey</code>。</p><p>这部分的 JS 代码和 Python 代码大致如下：</p><pre><code class="hljs javascript">JSEncrypt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;jsencrypt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAesKeyAndRsaEncryptData</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> aesKey = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t</span>) </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;</span>, r = <span class="hljs-string">&quot;&quot;</span>, n = <span class="hljs-number">0</span>; n &lt; t; n++) &#123;            <span class="hljs-keyword">var</span> i = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * e.length);            r += e.substring(i, i + <span class="hljs-number">1</span>)        &#125;        <span class="hljs-keyword">return</span> r    &#125;(<span class="hljs-number">32</span>);    <span class="hljs-keyword">var</span> e = <span class="hljs-keyword">new</span> JSEncrypt();    e.setPublicKey(<span class="hljs-string">&quot;-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnbJqzIXk6qGotX5nD521Vk/24APi2qx6C+2allfix8iAfUGqx0MK3GufsQcAt/o7NO8W+qw4HPE+RBR6m7+3JVlKAF5LwYkiUJN1dh4sTj03XQ0jsnd3BYVqL/gi8iC4YXJ3aU5VUsB6skROancZJAeq95p7ehXXAJfCbLwcK+yFFeRKLvhrjZOMDvh1TsMB4exfg+h2kNUI94zu8MK3UA7v1ANjfgopaE+cpvoulg446oKOkmigmc35lv8hh34upbMmehUqB51kqk9J7p8VMI3jTDBcMC21xq5XF7oM8gmqjNsYxrT9EVK7cezYPq7trqLX1fyWgtBtJZG7WMftKwIDAQAB-----END PUBLIC KEY-----&quot;</span>);    <span class="hljs-keyword">var</span> rsaEncryptData = e.encrypt(aesKey);    <span class="hljs-keyword">return</span> &#123;        <span class="hljs-string">&quot;aesKey&quot;</span>: aesKey,        <span class="hljs-string">&quot;rsaEncryptData&quot;</span>: rsaEncryptData    &#125;&#125;<span class="hljs-comment">// 测试输出</span><span class="hljs-comment">// console.log(getAesKeyAndRsaEncryptData())</span></code></pre><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_aes_key</span>() -&gt; <span class="hljs-literal">None</span>:</span>    <span class="hljs-comment"># 通过JS获取 AES Key，并通过接口激活，接口激活后会返回一个 secretKeyValue，后续请求头会用到</span>    <span class="hljs-keyword">global</span> aes_key, secret_key_value    url = <span class="hljs-string">&quot;https://gate.脱敏处理.com/system/agreement&quot;</span>    headers = &#123;        <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>,        <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;gate.脱敏处理.com&quot;</span>,        <span class="hljs-string">&quot;Origin&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com&quot;</span>,        <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com/&quot;</span>,        <span class="hljs-string">&quot;User-Agent&quot;</span>: UA    &#125;    encrypt_data = lagou_js.call(<span class="hljs-string">&quot;getAesKeyAndRsaEncryptData&quot;</span>)    aes_key = encrypt_data[<span class="hljs-string">&quot;aesKey&quot;</span>]    rsa_encrypt_data = encrypt_data[<span class="hljs-string">&quot;rsaEncryptData&quot;</span>]    data = &#123;<span class="hljs-string">&quot;secretKeyDecode&quot;</span>: rsa_encrypt_data&#125;    response = requests.post(url=url, headers=headers, json=data).json()    secret_key_value = response[<span class="hljs-string">&quot;content&quot;</span>][<span class="hljs-string">&quot;secretKeyValue&quot;</span>]</code></pre><h3 id="X-S-HEADER">X-S-HEADER</h3><p><code>X-S-HEADER</code> 你每次翻页都会改变，直接搜索关键字可定位：</p><p><img src="https://cdn.itbob.cn/img/article/049/29.png" alt="29"></p><p><img src="https://cdn.itbob.cn/img/article/049/30.png" alt="30"></p><p>中间有一个 SHA256 加密，最后返回的 <code>Rt(JSON.stringify(&#123;originHeader: JSON.stringify(e), code: t&#125;))</code> 就是 <code>X-S-HEADER</code> 的值了，<code>Rt()</code> 是一个 AES 加密，比较关键的，<code>Vt(r)</code> 是一个 URL，比如你搜索职位就是 positionAjax.json，搜索公司就是 companyAjax.json，可根据实际情况定制，然后 <code>Lt(t)</code> 就是搜索信息，字符串形式，包含了城市、页码、关键词等。</p><p>获取 <code>X-S-HEADER</code> 的 JS 代码大致如下：</p><pre><code class="hljs javascript">CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto-js&#x27;</span>)jt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">aesKey, originalData, u</span>) </span>&#123;    <span class="hljs-keyword">var</span> e = &#123;<span class="hljs-attr">deviceType</span>: <span class="hljs-number">1</span>&#125;      , t = <span class="hljs-string">&quot;&quot;</span>.concat(<span class="hljs-built_in">JSON</span>.stringify(e)).concat(u).concat(<span class="hljs-built_in">JSON</span>.stringify(originalData))      , t = (t = t, <span class="hljs-literal">null</span> === (t = CryptoJS.SHA256(t).toString()) || <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> === t ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : t.toUpperCase());    <span class="hljs-keyword">return</span> Rt(<span class="hljs-built_in">JSON</span>.stringify(&#123;        <span class="hljs-attr">originHeader</span>: <span class="hljs-built_in">JSON</span>.stringify(e),        <span class="hljs-attr">code</span>: t    &#125;), aesKey)&#125;Rt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t, aesKey</span>) </span>&#123;    <span class="hljs-keyword">var</span> Ot = CryptoJS.enc.Utf8.parse(<span class="hljs-string">&quot;c558Gq0YQK2QUlMc&quot;</span>),        Dt = CryptoJS.enc.Utf8.parse(aesKey),        t = CryptoJS.enc.Utf8.parse(t);    t = CryptoJS.AES.encrypt(t, Dt, &#123;        <span class="hljs-attr">iv</span>: Ot,        <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,        <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7    &#125;);    <span class="hljs-keyword">return</span> t.toString()&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getXSHeader</span>(<span class="hljs-params">aesKey, originalData, u</span>)</span>&#123;    <span class="hljs-keyword">return</span> jt(aesKey, originalData, u)&#125;<span class="hljs-comment">// 测试样例</span><span class="hljs-comment">// var url = &quot;https://www.脱敏处理.com/jobs/v2/positionAjax.json&quot;</span><span class="hljs-comment">// var aesKey = &quot;dgHY1qVeo/Z0yDaF5WV/EEXxYiwbr5Jt&quot;</span><span class="hljs-comment">// var originalData = &#123;&quot;first&quot;: &quot;true&quot;, &quot;needAddtionalResult&quot;: &quot;false&quot;, &quot;city&quot;: &quot;全国&quot;, &quot;pn&quot;: &quot;2&quot;, &quot;kd&quot;: &quot;Java&quot;&#125;</span><span class="hljs-comment">// console.log(getXSHeader(aesKey, originalData, url))</span></code></pre><h2 id="请求-返回数据解密">请求/返回数据解密</h2><p>前面抓包我们已经发现 positionAjax.json 是 POST 请求，Form Data 中的数据是加密的，返回的 data 也是加密的，我们分析请求头参数的时候，就涉及到 AES 加密解密，所以我们直接搜索 <code>AES.encrypt</code>、<code>AES.decrypt</code>，下断点调试：</p><p><img src="https://cdn.itbob.cn/img/article/049/31.png" alt="31"></p><p><img src="https://cdn.itbob.cn/img/article/049/32.png" alt="32"></p><p>非常明显了，这部分的 JS 代码大致如下：</p><pre><code class="hljs javascript">CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto-js&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRequestData</span>(<span class="hljs-params">aesKey, originalData</span>)</span>&#123;    <span class="hljs-keyword">return</span> Rt(<span class="hljs-built_in">JSON</span>.stringify(originalData), aesKey)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getResponseData</span>(<span class="hljs-params">encryptData, aesKey</span>)</span>&#123;    <span class="hljs-keyword">return</span> It(encryptData, aesKey)&#125;Rt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t, aesKey</span>) </span>&#123;    <span class="hljs-keyword">var</span> Ot = CryptoJS.enc.Utf8.parse(<span class="hljs-string">&quot;c558Gq0YQK2QUlMc&quot;</span>),        Dt = CryptoJS.enc.Utf8.parse(aesKey),        t = CryptoJS.enc.Utf8.parse(t);    t = CryptoJS.AES.encrypt(t, Dt, &#123;        <span class="hljs-attr">iv</span>: Ot,        <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,        <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7    &#125;);    <span class="hljs-keyword">return</span> t.toString()&#125;;It = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t, aesKey</span>) </span>&#123;    <span class="hljs-keyword">var</span> Ot = CryptoJS.enc.Utf8.parse(<span class="hljs-string">&quot;c558Gq0YQK2QUlMc&quot;</span>),    Dt = CryptoJS.enc.Utf8.parse(aesKey);    t = CryptoJS.AES.decrypt(t, Dt, &#123;        <span class="hljs-attr">iv</span>: Ot,        <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,        <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7    &#125;).toString(CryptoJS.enc.Utf8);    <span class="hljs-keyword">try</span> &#123;        t = <span class="hljs-built_in">JSON</span>.parse(t)    &#125; <span class="hljs-keyword">catch</span> (t) &#123;&#125;    <span class="hljs-keyword">return</span> t&#125;<span class="hljs-comment">// 测试样例，注意，encryptedData 数据太多，省略了，直接运行解密是会报错的</span><span class="hljs-comment">// var aesKey = &quot;dgHY1qVeo/Z0yDaF5WV/EEXxYiwbr5Jt&quot;</span><span class="hljs-comment">// var encryptedData = &quot;r4MqbduYxu3Z9sFL75xDhelMTCYPHLluKaurYgzEXlEQ1Rg......&quot;</span><span class="hljs-comment">// var originalData = &#123;&quot;first&quot;: &quot;true&quot;, &quot;needAddtionalResult&quot;: &quot;false&quot;, &quot;city&quot;: &quot;全国&quot;, &quot;pn&quot;: &quot;2&quot;, &quot;kd&quot;: &quot;Java&quot;&#125;</span><span class="hljs-comment">// console.log(getRequestData(aesKey, originalData))</span><span class="hljs-comment">// console.log(getResponseData(encryptedData, aesKey))</span></code></pre><p>大致的 Python 代码如下：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_header_params</span>(<span class="hljs-params">original_data: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">dict</span>:</span>    <span class="hljs-comment"># 后续请求数据所需的请求头参数</span>    <span class="hljs-comment"># 职位搜索 URL，如果是搜索公司，那就是 https://www.脱敏处理.com/jobs/companyAjax.json，根据实际情况更改</span>    u = <span class="hljs-string">&quot;https://www.脱敏处理.com/jobs/v2/positionAjax.json&quot;</span>    <span class="hljs-keyword">return</span> &#123;        <span class="hljs-string">&quot;traceparent&quot;</span>: lagou_js.call(<span class="hljs-string">&quot;getTraceparent&quot;</span>),        <span class="hljs-string">&quot;X-K-HEADER&quot;</span>: secret_key_value,        <span class="hljs-string">&quot;X-S-HEADER&quot;</span>: lagou_js.call(<span class="hljs-string">&quot;getXSHeader&quot;</span>, aes_key, original_data, u),        <span class="hljs-string">&quot;X-SS-REQ-HEADER&quot;</span>: json.dumps(&#123;<span class="hljs-string">&quot;secret&quot;</span>: secret_key_value&#125;)    &#125;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_encrypted_data</span>(<span class="hljs-params">original_data: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">str</span>:</span>    <span class="hljs-comment"># AES 加密原始数据</span>    encrypted_data = lagou_js.call(<span class="hljs-string">&quot;getRequestData&quot;</span>, aes_key, original_data)    <span class="hljs-keyword">return</span> encrypted_data<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_data</span>(<span class="hljs-params">original_data: <span class="hljs-built_in">dict</span>, encrypted_data: <span class="hljs-built_in">str</span>, header_params: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">dict</span>:</span>    <span class="hljs-comment"># 携带加密后的请求数据和完整请求头，拿到密文，AES 解密得到明文职位信息</span>    url = <span class="hljs-string">&quot;https://www.脱敏处理.com/jobs/v2/positionAjax.json&quot;</span>    referer = parse.urljoin(<span class="hljs-string">&quot;https://www.脱敏处理.com/wn/jobs?&quot;</span>, parse.urlencode(original_data))    headers = &#123;        <span class="hljs-comment"># &quot;content-type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,</span>        <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.com&quot;</span>,        <span class="hljs-string">&quot;Origin&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com&quot;</span>,        <span class="hljs-string">&quot;Referer&quot;</span>: referer,        <span class="hljs-string">&quot;traceparent&quot;</span>: header_params[<span class="hljs-string">&quot;traceparent&quot;</span>],        <span class="hljs-string">&quot;User-Agent&quot;</span>: UA,        <span class="hljs-string">&quot;X-K-HEADER&quot;</span>: header_params[<span class="hljs-string">&quot;X-K-HEADER&quot;</span>],        <span class="hljs-string">&quot;X-S-HEADER&quot;</span>: header_params[<span class="hljs-string">&quot;X-S-HEADER&quot;</span>],        <span class="hljs-string">&quot;X-SS-REQ-HEADER&quot;</span>: header_params[<span class="hljs-string">&quot;X-SS-REQ-HEADER&quot;</span>],    &#125;    <span class="hljs-comment"># 添加 x-anit-forge-code 和 x-anit-forge-token</span>    headers.update(x_anit)    data = &#123;<span class="hljs-string">&quot;data&quot;</span>: encrypted_data&#125;    response = requests.post(url=url, headers=headers, cookies=global_cookies, data=data).json()    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;status&quot;</span> <span class="hljs-keyword">in</span> response:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> response[<span class="hljs-string">&quot;status&quot;</span>] <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;操作太频繁&quot;</span> <span class="hljs-keyword">in</span> response[<span class="hljs-string">&quot;msg&quot;</span>]:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;获取数据失败！msg：%s！可以尝试补全登录后的 Cookies，或者添加代理！&quot;</span> % response[<span class="hljs-string">&quot;msg&quot;</span>])        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;获取数据异常！请检查数据是否完整！&quot;</span>)    <span class="hljs-keyword">else</span>:        response_data = response[<span class="hljs-string">&quot;data&quot;</span>]        decrypted_data = lagou_js.call(<span class="hljs-string">&quot;getResponseData&quot;</span>, response_data, aes_key)        <span class="hljs-keyword">return</span> decrypted_data</code></pre><p>最终整合所有代码，成功拿到数据：</p><p><img src="https://cdn.itbob.cn/img/article/049/33.png" alt="33"></p><h2 id="逆向小技巧">逆向小技巧</h2><p>浏览器开发者工具 Application - Storage 选项，可以一键清除所有 Cookies，也可以自定义存储配额：</p><p><img src="https://cdn.itbob.cn/img/article/049/34.png" alt="34"></p><p>Storage - Cookies 可以查看每个站点的所有 Cookies，HttpOnly 打勾的表示是服务器返回的，选中一条 Cookie，右键可以直接定位到哪个请求带了这个 Cookie，也可以直接编辑值，还可以删除单个 Cookie，当你登录了账号，但又需要清除某个 Cookie，且不想重新登录时，这个功能或许有用。</p><p><img src="https://cdn.itbob.cn/img/article/049/35.png" alt="35"></p><h2 id="完整代码">完整代码</h2><p>文中给出了部分关键代码，不能直接运行，部分细节可能没提及到，完整代码已放 GitHub，均有详细注释，欢迎 Star。所有内容仅供学习交流，严禁用于商业用途、非法用途，否则由此产生的一切后果均与作者无关，在仓库中下载的文件学习完毕之后请于 24 小时内删除！</p><p>仓库地址：<a href="https://github.com/TRHX/Python3-Spider-Practice">https://github.com/TRHX/Python3-Spider-Practice</a></p><h2 id="常见问题">常见问题</h2><ul><li><p>JS 代码里引用了三个库，npm install 安装一下即可，如果安装了还提示找不到库，那就是路径问题，推荐在当前目录下执行命令安装，或者在 Python 代码里指定完整路径，具体方法可自行百度。</p></li><li><p>jsencrypt 这个库，本地运行可能会报错 <code>window is not defined</code>，在 <code>\node_modules\jsencrypt\bin\jsencrypt.js</code> 源码中加入 <code>var window = global;</code> 即可，这是实现 RSA 加密的库，当然还有很多其他实现方法或者库，都可以。</p></li><li><p>execjs 执行 JS 的时候，可能会报编码错误 <code>&quot;gbk&quot; can't decode byte...</code>，有两种解决方法，一是找到官方源码 <a href="http://subprocess.py">subprocess.py</a>，搜索 <code>encoding=None</code> 改成 <code>encoding='utf-8'</code>，二是直接在 Python 代码里面加入以下代码即可：</p></li></ul><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partialsubprocess.Popen = partial(subprocess.Popen, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/javascript_reverse.png&quot; alt=&quot;javascript_reverse&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Python 中如何解决 asyncio 文件描述符最大数量限制问题</title>
    <link href="https://www.itbob.cn/article/048/"/>
    <id>https://www.itbob.cn/article/048/</id>
    <published>2022-02-23T02:18:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题复现">问题复现</h2><p>Windows 平台下，Python 版本 3.5，使用异步框架 asyncio，有时候会出现 <code>ValueError: too many file descriptors in select()</code> 的报错信息，今天我们就来聊一下为什么会出现这种问题，以及问题的一些解决方法。</p><p>写一个小 dome 复现这个问题（环境：Windows 64 位、Python 3.7）：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> aiohttp<span class="hljs-keyword">import</span> asyncionum = <span class="hljs-number">0</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">url</span>):</span>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> response:            <span class="hljs-keyword">global</span> num            num += <span class="hljs-number">1</span>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s ——&gt; %s&#x27;</span> % (<span class="hljs-built_in">str</span>(num), response.status))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tasks</span>():</span>    url = <span class="hljs-string">&#x27;https://www.baidu.com/s?ie=UTF-8&amp;wd=%s&#x27;</span>    task = [main(url % i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>)]    <span class="hljs-keyword">return</span> taskloop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks()))</code></pre><p>在打印 500 次左右后就会出现以下报错：</p><p><img src="https://cdn.itbob.cn/img/article/048/01.png" alt="01.png"></p><h2 id="问题分析">问题分析</h2><p>好像这个报错和 select 有关，那什么是 select 呢？要怎么解决呢？别急，我们首先来了解一下 asyncio 中的事件循环，即 EventLoop。</p><h3 id="事件循环-EventLoop">事件循环 EventLoop</h3><p>事件循环是 asyncio 的核心，异步任务的运行、任务完成之后的回调、网络 I/O 操作、子进程的运行，都是通过事件循环完成的，通俗来讲，事件循环所做的就是等待事件发生，然后再将每个事件与我们已明确与所述事件类型匹配的函数进行匹配。下图很好的展示了协程、事件循环之间的相互作用：</p><p><img src="https://cdn.itbob.cn/img/article/048/02.png" alt="02.png"></p><p>在 asyncio 中，主要提供了两种不同事件循环的实现方法：</p><ul><li><p><strong>SelectorEventLoop</strong>：基于 selectors 模块的事件循环，selectors 又是建立在底层的 I/O 复用模块 select 之上的，selectors 提供了高度封装和高效的 I/O 复用，也就是说 SelectorEventLoop 在底层就是使用了 select I/O 多路复用的机制。</p></li><li><p><strong>ProactorEventLoop</strong>：使用 IOCP 专为 Windows 构建的事件循环，IOCP 全称 I/O Completion Port，即 I/O 完成端口。它是支持多个同时发生的异步 I/O 操作的应用程序编程接口，它充分利用内核对象的调度，只使用少量的几个线程来处理和客户端的所有通信，消除了无谓的线程上下文切换，是 Windows 下性能最好的 I/O 模型，有关 IOCP 的详细介绍可参考<a href="https://docs.microsoft.com/en-ca/windows/win32/fileio/i-o-completion-ports">微软文档</a>。</p></li></ul><p>那么这两种方法有什么区别呢？在 asyncio 中什么时候用什么方法呢？</p><p>我们不妨看一下 asyncio 的源码，在 Python 3.7 中，无论在 Windows 还是 Linux 中都可以看到其默认的设置是 SelectorEventLoop：</p><p><img src="https://cdn.itbob.cn/img/article/048/03.png" alt="03.png"></p><p>我们也可以分别在 Windows 平台和 Linux 平台打印一下 EventLoop 对象（Python 3.7），可以看到默认都是 SelectorEventLoop：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncioloop = asyncio.get_event_loop()<span class="hljs-built_in">print</span>(loop)</code></pre><p>Windows：</p><p><img src="https://cdn.itbob.cn/img/article/048/04.png" alt="04.png"></p><p>Linux：</p><p><img src="https://cdn.itbob.cn/img/article/048/05.png" alt="05.png"></p><p>事实上，在 Python 3.7 以及之前的版本中，   所有平台默认使用的都是 SelectorEventLoop，在 Python 3.8 以及以后的版本中，Unix 平台默认使用的是 SelectorEventLoop，Windows 平台默认使用的是 ProactorEventLoop，这个差异可以在官方文档中看到。</p><ul><li>Python 3.7 文档：<a href="https://docs.python.org/3.7/library/asyncio-eventloop.html#event-loop-implementations">https://docs.python.org/3.7/library/asyncio-eventloop.html#event-loop-implementations</a></li><li>Python 3.8 文档：<a href="https://docs.python.org/3.8/library/asyncio-eventloop.html#event-loop-implementations">https://docs.python.org/3.8/library/asyncio-eventloop.html#event-loop-implementations</a></li></ul><p><img src="https://cdn.itbob.cn/img/article/048/06.png" alt="06.png"></p><p>说了这么多，这和 <code>ValueError: too many file descriptors in select()</code> 的报错问题有什么关系呢？select 到底是什么东西呢？</p><h3 id="I-O-多路复用">I/O 多路复用</h3><p>要了解 select，我们还要了解一下什么是 I/O 多路复用（I/O multiplexing），服务器端编程经常需要构造高性能的 I/O 模型，常见的 I/O 模型有同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用等；当需要同时处理多个客户端接入请求时，可以利用多线程或者 I/O 多路复用技术进行处理，I/O 多路复用技术就是为了解决进程或线程阻塞到某个 I/O 系统调用而出现的技术，使进程不阻塞于某个特定的 I/O 系统调用。</p><p><strong>select，poll，epoll 等都是 I/O 多路复用的一种机制</strong>，其中后两个在 Linux 中可用，Windows 仅支持 select，I/O 多路复用通过这种机制，可以监视多个描述符，一旦某个描述符就绪，一般是读就绪或者写就绪，就是在这个文件描述符进行读写操作之前，能够通知程序进行相应的读写操作。</p><h3 id="select-的缺点">select 的缺点</h3><p>I/O 多路复用这个概念被提出来以后， select 是第一个实现这个概念的，select 被实现以后，很快就暴露出了很多问题，其中一个缺点就是 <strong>select 在 Windows 中限制了文件描述符数量为 512 个，在 Linux 中限制为 1024 个</strong>，那么在前面的 dome 中，使用的是 Python 3.5，这个版本的 asyncio 默认使用了 SelectorEventLoop，底层调用的是 select，受 select 缺点的影响，并发量过高，就出现了 <code>ValueError: too many file descriptors in select()</code> 的报错信息。</p><h2 id="解决方法">解决方法</h2><h3 id="1-更换事件循环选择器">1.更换事件循环选择器</h3><p>如果你使用的是 Python 3.7 及以下的版本，那么在 Windows 平台，可以使用 ProactorEventLoop。在 Linux 平台可以使用 PollSelector。</p><p><strong>注意</strong>：如果你使用了 ProactorEventLoop，那么你将无法使用代理！这是 asyncio 的 bug，早在 2020 年 1 月就有人提过 <a href="https://github.com/aio-libs/aiohttp/issues/4536">issue</a>，目前仍然可以看到类似的 issue，官方貌似也还没办法解决，所以，如果您必须要使用代理，则可以参考后面的解决办法。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> selectors<span class="hljs-keyword">import</span> asyncio<span class="hljs-keyword">import</span> sys<span class="hljs-keyword">if</span> sys.platform == <span class="hljs-string">&#x27;win32&#x27;</span>:    loop = asyncio.ProactorEventLoop()    asyncio.set_event_loop(loop)<span class="hljs-keyword">else</span>:    selector = selectors.PollSelector()    loop = asyncio.SelectorEventLoop(selector)    asyncio.set_event_loop(loop)</code></pre><h3 id="2-限制并发量">2.限制并发量</h3><p>可以使用方法 <code>asyncio.Semaphore()</code> 来限制并发量，Semaphore 就是信号量的意思，Semaphore 管理一个内部计数器，该计数器在每次调用 <code>acquire()</code> 方法时递减，每次调用 <code>release()</code> 方法时递增，计数器永远不会低于零，当方法 <code>acquire()</code> 发现它为零时，它会阻塞，等待其他线程调用 <code>release()</code> 方法。通过限制并发量的方法来解决报错问题是个不错的选择。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> aiohttp<span class="hljs-keyword">import</span> asyncionum = <span class="hljs-number">0</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">url, semaphore</span>):</span>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> semaphore:        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:            <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> response:                <span class="hljs-keyword">global</span> num                num += <span class="hljs-number">1</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s ——&gt; %s&#x27;</span> % (<span class="hljs-built_in">str</span>(num), response.status))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tasks</span>():</span>    semaphore = asyncio.Semaphore(<span class="hljs-number">300</span>)                         <span class="hljs-comment"># 限制并发量为 300</span>    url = <span class="hljs-string">&#x27;https://www.baidu.com/s?ie=UTF-8&amp;wd=%s&#x27;</span>    task = [main(url % i, semaphore) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>)]    <span class="hljs-comment"># #总共 10000 任务</span>    <span class="hljs-keyword">return</span> taskloop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks()))</code></pre><h3 id="3-修改最大文件描述符限制">3.修改最大文件描述符限制</h3><h4 id="Windows">Windows</h4><p>在 Windows 中，最大文件描述符限制在 C 语言的头文件 Winsock2.h 中使用变量 <code>FD_SETSIZE</code> 进行定义，如果要修改它，可以通过在包含 Winsock2.h 之前将 <code>FD_SETSIZE</code> 定义为另一个值来修改，如果我们使用的编程语言是 Python 的话，是不太好对这个值进行修改的，可以参考微软官方文档：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-select">https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-select</a></p><h4 id="Linux">Linux</h4><p>在 Linux 平台，可以使用 <code>ulimit</code> 命令来修改最大文件描述符限制：</p><ul><li><p>查看当前会话最大文件描述符限制（默认1024）：<code>ulimit -n</code></p></li><li><p>临时修改限制，只对当前的会话有效：<code>ulimit -SHn 65536</code></p></li><li><p>永久修改限制，在 <code>/etc/security/limits.conf</code> 文件里新增以下内容：</p>  <pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>hard nofile 65536<span class="hljs-bullet">* </span>soft nofile 65536</code></pre></li></ul><p><code>ulimit</code> 命令参考：</p><pre><code class="hljs diff"><span class="hljs-deletion">-S使用软 (soft) 资源限制</span><span class="hljs-deletion">-H使用硬 (hard) 资源限制</span><span class="hljs-deletion">-a所有当前限制都被报告</span><span class="hljs-deletion">-b套接字缓存尺寸</span><span class="hljs-deletion">-c创建的核文件的最大尺寸</span><span class="hljs-deletion">-d一个进程的数据区的最大尺寸</span><span class="hljs-deletion">-e最高的调度优先级 (nice)</span><span class="hljs-deletion">-f有 shell 及其子进程可以写的最大文件尺寸</span><span class="hljs-deletion">-i最多的可以挂起的信号数</span><span class="hljs-deletion">-k分配给此进程的最大 kqueue 数量</span><span class="hljs-deletion">-l一个进程可以锁定的最大内存尺寸</span><span class="hljs-deletion">-m最大的内存进驻尺寸</span><span class="hljs-deletion">-n最多的打开的文件描述符个数</span><span class="hljs-deletion">-p管道缓冲区尺寸</span><span class="hljs-deletion">-qPOSIX 信息队列的最大字节数</span><span class="hljs-deletion">-r实时调度的最大优先级</span><span class="hljs-deletion">-s最大栈尺寸</span><span class="hljs-deletion">-t最大的CPU时间，以秒为单位</span><span class="hljs-deletion">-u最大用户进程数</span><span class="hljs-deletion">-v虚拟内存尺寸</span><span class="hljs-deletion">-x最大的文件锁数量</span><span class="hljs-deletion">-P最大伪终端数量</span><span class="hljs-deletion">-T最大线程数量</span></code></pre><h2 id="总结">总结</h2><p>asyncio 事件循环选择器，在 Python 3.7 以及之前的版本中，所有平台默认使用的都是 SelectorEventLoop，在 Python 3.8 以及以后的版本中，Unix 平台默认使用的是 SelectorEventLoop，Windows 平台默认使用的是 ProactorEventLoop。</p><p>select 在 Windows 中限制了文件描述符最大数量为 512 个，在 Linux 中限制为 1024 个。</p><p>要解决 <code>ValueError: too many file descriptors in select()</code> 的报错问题，根据您的平台和业务要求选择合理的解决方法：</p><h3 id="Windows-t2">Windows</h3><ol><li><p>通过 <code>asyncio.Semaphore()</code> 方法来限制并发量，通常设置在 300-500 比较合理，这是最优的做法；</p></li><li><p>更换 asyncio 的事件循环选择器为 ProactorEventLoop，<strong>注意：这将导致无法使用代理！</strong></p></li></ol><h3 id="Linux-t2">Linux</h3><ol><li><p>通过 <code>asyncio.Semaphore()</code> 方法来限制并发量，通常设置在 800-1000 比较合理；</p></li><li><p>通过 <code>ulimit</code> 命令来修改最大文件描述符限制；</p></li><li><p>更换 asyncio 的事件循环选择器为 PollSelector。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题复现&quot;&gt;问题复现&lt;/h2&gt;
&lt;p&gt;Windows 平台下，Python 版本 3.5，使用异步框架 asyncio，有时候会出现 &lt;code&gt;ValueError: too many file descriptors in select()&lt;/code&gt; 的报</summary>
      
    
    
    
    <category term="Python" scheme="https://www.itbob.cn/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>RPC 技术及其框架 Sekiro 在爬虫逆向中的应用，加密数据一把梭</title>
    <link href="https://www.itbob.cn/article/047/"/>
    <id>https://www.itbob.cn/article/047/</id>
    <published>2022-02-21T09:20:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/rpc.png" alt="rpc"></p><h2 id="什么是-RPC">什么是 RPC</h2><p><s>RPC，英文 RangPaCong，中文让爬虫，旨在为爬虫开路，秒杀一切，让爬虫畅通无阻！</s></p><p>开个玩笑，实际上 RPC 为远程过程调用，全称 Remote Procedure Call，是一种技术思想而非一种规范或协议。RPC 的诞生事实上离不开分布式的发展，RPC 主要解决了两个问题：</p><ol><li>解决了分布式系统中，服务之间的互相调用问题；</li><li>RPC 使得在远程调用时，像本地调用一样方便，让调用者感知不到远程调用的逻辑。</li></ol><p>RPC 的存在让构建分布式系统更加容易，相比于 HTTP 协议，RPC 采用二进制字节码传输，因此也更加高效、安全。在一个典型 RPC 的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，完整 RPC 架构图如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/047/01.jpg" alt="01"></p><h2 id="JSRPC">JSRPC</h2><p>RPC 技术是非常复杂的，对于我们搞爬虫、逆向的来说，不需要完全了解，只需要知道这项技术如何在逆向中应用就行了。</p><p>RPC 在逆向中，简单来说就是将本地和浏览器，看做是服务端和客户端，二者之间通过 WebSocket 协议进行 RPC 通信，在浏览器中将加密函数暴露出来，在本地直接调用浏览器中对应的加密函数，从而得到加密结果，不必去在意函数具体的执行逻辑，也省去了扣代码、补环境等操作，可以省去大量的逆向调试时间。我们以某团网页端的登录为例来演示 RPC 在逆向中的具体使用方法。（假设你已经有一定逆向基础，了解 WebSocket 协议，纯小白可以先看看以前的文章）</p><ul><li>主页（base64）：<code>aHR0cHM6Ly9wYXNzcG9ydC5tZWl0dWFuLmNvbS9hY2NvdW50L3VuaXRpdmVsb2dpbg==</code></li><li>参数：h5Fingerprint</li></ul><p>首先抓一下包，登录接口有一个超级长的参数 h5Fingerprint，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/047/02.png" alt="02"></p><p>直接搜一下就能找到加密函数：</p><p><img src="https://cdn.itbob.cn/img/article/047/03.png" alt="03"></p><p>其中 <code>utility.getH5fingerprint()</code> 传入的参数 <code>window.location.origin + url</code> 格式化后，参数如下：</p><pre><code class="hljs makefile">url = <span class="hljs-string">&quot;https://passport.脱敏处理.com/account/unitivelogin&quot;</span>params = &#123;    <span class="hljs-string">&quot;risk_partner&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,    <span class="hljs-string">&quot;risk_platform&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>,    <span class="hljs-string">&quot;risk_app&quot;</span>: <span class="hljs-string">&quot;-1&quot;</span>,    <span class="hljs-string">&quot;uuid&quot;</span>: <span class="hljs-string">&quot;96309b5f00ba4143b920.1644805104.1.0.0&quot;</span>,    <span class="hljs-string">&quot;token_id&quot;</span>: <span class="hljs-string">&quot;DNCmLoBpSbBD6leXFdqIxA&quot;</span>,    <span class="hljs-string">&quot;service&quot;</span>: <span class="hljs-string">&quot;www&quot;</span>,    <span class="hljs-string">&quot;continue&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com/account/settoken?continue=https%3A%2F%2Fwww.脱敏处理.com%2F&quot;</span>&#125;</code></pre><p>uuid 和 token_id 都可以直接搜到，不是本次研究重点，这里不再细说，接下来我们使用 RPC 技术，直接调用浏览器里的 <code>utility.getH5fingerprint()</code> 方法，首先在本地编写服务端代码，使其能够一直输入待加密字符串，接收并打印加密后的字符串：</p><pre><code class="hljs python"><span class="hljs-comment"># ==================================</span><span class="hljs-comment"># --*-- coding: utf-8 --*--</span><span class="hljs-comment"># @Time    : 2022-02-14</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: ws_server.py</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ==================================</span><span class="hljs-keyword">import</span> sys<span class="hljs-keyword">import</span> asyncio<span class="hljs-keyword">import</span> websockets<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">receive_massage</span>(<span class="hljs-params">websocket</span>):</span>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        send_text = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要加密的字符串: &quot;</span>)        <span class="hljs-keyword">if</span> send_text == <span class="hljs-string">&quot;exit&quot;</span>:            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Exit, goodbye!&quot;</span>)            <span class="hljs-keyword">await</span> websocket.send(send_text)            <span class="hljs-keyword">await</span> websocket.close()            sys.exit()        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">await</span> websocket.send(send_text)            response_text = <span class="hljs-keyword">await</span> websocket.recv()            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n加密结果：&quot;</span>, response_text)start_server = websockets.serve(receive_massage, <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">5678</span>)  <span class="hljs-comment"># 自定义端口</span>asyncio.get_event_loop().run_until_complete(start_server)asyncio.get_event_loop().run_forever()</code></pre><p>编写浏览器客户端 JS 代码，收到消息就直接 <code>utility.getH5fingerprint()</code> 得到加密参数并发送给服务端：</p><pre><code class="hljs javascript"><span class="hljs-comment">/* ==================================</span><span class="hljs-comment"># @Time    : 2022-02-14</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: ws_client.js</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ================================== */</span><span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">&quot;ws://127.0.0.1:5678&quot;</span>);  <span class="hljs-comment">// 自定义端口</span>ws.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Received Message: &quot;</span> + evt.data);    <span class="hljs-keyword">if</span> (evt.data == <span class="hljs-string">&quot;exit&quot;</span>) &#123;        ws.close();    &#125; <span class="hljs-keyword">else</span> &#123;        ws.send(utility.getH5fingerprint(evt.data))    &#125;&#125;;</code></pre><p>然后我们需要把客户端代码注入到网页中，这里方法有很多，比如抓包软件 Fiddler 替换响应、浏览器插件 ReRes 替换 JS、浏览器开发者工具 Overrides 重写功能等，也可以通过插件、油猴等注入 Hook 的方式插入，反正方法很多，对这些方法不太了解的朋友可以去看看以前的文章，都有介绍。</p><p>这里我们使用浏览器开发者工具 Overrides 重写功能，将 WebSocket 客户端代码加到加密的这个 JS 文件里并 Ctrl+S 保存，这里将其写成了 IIFE 自执行方式，这样做的原因是防止污染全局变量，不用自执行方式当然也是可以的。</p><p><img src="https://cdn.itbob.cn/img/article/047/04.png" alt="04"></p><p>然后先运行本地服务端代码，网页上先登录一遍，网页上先登录一遍，网页上先登录一遍，重要的步骤说三遍！然后就可以在本地传入待加密字符串，获取 <code>utility.getH5fingerprint()</code> 加密后的结果了：</p><p><img src="https://cdn.itbob.cn/img/article/047/05.png" alt="05"></p><h2 id="Sekiro">Sekiro</h2><p>通过前面的示例，可以发现自己写服务端太麻烦了，不易扩展，那这方面有没有现成的轮子呢？答案是有的，这里介绍两个项目：</p><ul><li>JsRPC-hliang：<a href="https://github.com/jxhczhl/JsRpc">https://github.com/jxhczhl/JsRpc</a></li><li>Sekiro：<a href="https://github.com/virjar/sekiro">https://github.com/virjar/sekiro</a></li></ul><p>JsRPC-hliang 是用 go 语言写的，是专门为 JS 逆向做的项目，而 Sekiro 功能更加强大，Sekiro 是由邓维佳大佬，俗称渣总，写的一个基于长链接和代码注入的 Android Private API 暴露框架，可以用在 APP 逆向、APP 数据抓取、Android 群控等场景，同时 Sekiro 也是目前公开方案唯一稳定的 JSRPC 框架，两者在 JS 逆向方面的使用方法其实都差不多，本文主要介绍一下 Sekiro 在 Web JS 逆向中的应用。</p><p>参考 Sekiro 文档，首先在本地编译项目：</p><ul><li><p>Linux &amp; Mac：执行脚本 <code>build_demo_server.sh</code>，之后得到产出发布压缩包：<code>sekiro-service-demo/target/sekiro-release-demo.zip</code></p></li><li><p>Windows：可以直接下载：<a href="https://oss.virjar.com/sekiro/sekiro-demo">https://oss.virjar.com/sekiro/sekiro-demo</a></p></li></ul><p>然后在本地运行（需要有 Java 环境，自行配置）：</p><ul><li>Linux &amp; Mac：<code>bin/sekiro.sh</code></li><li>Windows：<code>bin/sekiro.bat</code></li></ul><p>以 Windows 为例，启动后如下：</p><p><img src="https://cdn.itbob.cn/img/article/047/06.png" alt="06"></p><p>接下来就需要在浏览器里注入代码了，需要将作者提供的 sekiro_web_client.js（下载地址：<a href="https://sekiro.virjar.com/sekiro-doc/assets/sekiro_web_client.js%EF%BC%89">https://sekiro.virjar.com/sekiro-doc/assets/sekiro_web_client.js）</a> 注入到浏览器环境，然后通过 SekiroClient 和 Sekiro 服务器通信，即可直接 RPC 调用浏览器内部方法，官方提供的 SekiroClient 代码样例如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">guid</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">S4</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> (((<span class="hljs-number">1</span>+<span class="hljs-built_in">Math</span>.random())*<span class="hljs-number">0x10000</span>)|<span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>).substring(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> (S4()+S4()+<span class="hljs-string">&quot;-&quot;</span>+S4()+<span class="hljs-string">&quot;-&quot;</span>+S4()+<span class="hljs-string">&quot;-&quot;</span>+S4()+<span class="hljs-string">&quot;-&quot;</span>+S4()+S4()+S4());&#125;<span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> SekiroClient(<span class="hljs-string">&quot;wss://sekiro.virjar.com/business/register?group=ws-group&amp;clientId=&quot;</span>+guid());client.registerAction(<span class="hljs-string">&quot;clientTime&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">request, resolve, reject</span>)</span>&#123;    resolve(<span class="hljs-string">&quot;&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());&#125;)</code></pre><p>wss 链接里，如果是免费版，要将 business 改成 business-demo，解释一下涉及到的名词：</p><ul><li><strong>group</strong>：业务类型（接口组），每个业务一个 group，group 下面可以注册多个终端（SekiroClient），同时 group 可以挂载多个 Action；</li><li><strong>clientId</strong>：指代设备，多个设备使用多个机器提供 API 服务，提供群控能力和负载均衡能力；</li><li><strong>SekiroClient</strong>：服务提供者客户端，主要场景为手机/浏览器等。最终的 Sekiro 调用会转发到 SekiroClient。每个 client 需要有一个惟一的 clientId；</li><li><strong>registerAction</strong>：接口，同一个 group 下面可以有多个接口，分别做不同的功能；</li><li><strong>resolve</strong>：将内容传回给客户端的方法；</li><li><strong>request</strong>：客户端传过来的请求，如果请求里有多个参数，可以以键值对的方式从里面提取参数然后再做处理。</li></ul><p>说了这么多可能也不好理解，直接实战，还是以某团网页端登录为例，我们将 sekiro_web_client.js 与 SekiroClient 通信代码写在一起，然后根据需求，改写一下通信部分代码：</p><ol><li>ws 链接改为：<code>ws://127.0.0.1:5620/business-demo/register?group=rpc-test&amp;clientId=</code>，自定义 <code>group</code> 为 <code>rpc-test</code>；</li><li>注册一个事件 <code>registerAction</code> 为 <code>getH5fingerprint</code>；</li><li><code>resolve</code> 返回的结果为 <code>utility.getH5fingerprint(request[&quot;url&quot;])</code>，即加密并返回客户端传过来的 url 参数。</li></ol><p>完整代码如下（留意末尾 SekiroClient 通信代码部分的写法）：</p><pre><code class="hljs javascript"><span class="hljs-comment">/* ==================================</span><span class="hljs-comment"># @Time    : 2022-02-14</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: sekiro.js</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ================================== */</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-meta">    &#x27;use strict&#x27;</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SekiroClient</span>(<span class="hljs-params">wsURL</span>) </span>&#123;        <span class="hljs-built_in">this</span>.wsURL = wsURL;        <span class="hljs-built_in">this</span>.handlers = &#123;&#125;;        <span class="hljs-built_in">this</span>.socket = &#123;&#125;;        <span class="hljs-comment">// check</span>        <span class="hljs-keyword">if</span> (!wsURL) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;wsURL can not be empty!!&#x27;</span>)        &#125;        <span class="hljs-built_in">this</span>.webSocketFactory = <span class="hljs-built_in">this</span>.resolveWebSocketFactory();        <span class="hljs-built_in">this</span>.connect()    &#125;    SekiroClient.prototype.resolveWebSocketFactory = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;            <span class="hljs-keyword">var</span> theWebSocket = <span class="hljs-built_in">window</span>.WebSocket ? <span class="hljs-built_in">window</span>.WebSocket : <span class="hljs-built_in">window</span>.MozWebSocket;            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">wsURL</span>) </span>&#123;                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WindowWebSocketWrapper</span>(<span class="hljs-params">wsURL</span>) </span>&#123;                    <span class="hljs-built_in">this</span>.mSocket = <span class="hljs-keyword">new</span> theWebSocket(wsURL);                &#125;                WindowWebSocketWrapper.prototype.close = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                    <span class="hljs-built_in">this</span>.mSocket.close();                &#125;;                WindowWebSocketWrapper.prototype.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onMessageFunction</span>) </span>&#123;                    <span class="hljs-built_in">this</span>.mSocket.onmessage = onMessageFunction;                &#125;;                WindowWebSocketWrapper.prototype.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onOpenFunction</span>) </span>&#123;                    <span class="hljs-built_in">this</span>.mSocket.onopen = onOpenFunction;                &#125;;                WindowWebSocketWrapper.prototype.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onCloseFunction</span>) </span>&#123;                    <span class="hljs-built_in">this</span>.mSocket.onclose = onCloseFunction;                &#125;;                WindowWebSocketWrapper.prototype.send = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) </span>&#123;                    <span class="hljs-built_in">this</span>.mSocket.send(message);                &#125;;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WindowWebSocketWrapper(wsURL);            &#125;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> weex === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;            <span class="hljs-comment">// this is weex env : https://weex.apache.org/zh/docs/modules/websockets.html</span>            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;test webSocket for weex&quot;</span>);                <span class="hljs-keyword">var</span> ws = weex.requireModule(<span class="hljs-string">&#x27;webSocket&#x27;</span>);                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;find webSocket for weex:&quot;</span> + ws);                <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">wsURL</span>) </span>&#123;                    <span class="hljs-keyword">try</span> &#123;                        ws.close();                    &#125; <span class="hljs-keyword">catch</span> (e) &#123;                    &#125;                    ws.WebSocket(wsURL, <span class="hljs-string">&#x27;&#x27;</span>);                    <span class="hljs-keyword">return</span> ws;                &#125;            &#125; <span class="hljs-keyword">catch</span> (e) &#123;                <span class="hljs-built_in">console</span>.log(e);                <span class="hljs-comment">//ignore</span>            &#125;        &#125;        <span class="hljs-comment">//TODO support ReactNative</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> WebSocket === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">wsURL</span>) </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> theWebSocket(wsURL);            &#125;        &#125;        <span class="hljs-comment">// weex 和 PC环境的websocket API不完全一致，所以做了抽象兼容</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;the js environment do not support websocket&quot;</span>);    &#125;;    SekiroClient.prototype.connect = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;sekiro: begin of connect to wsURL: &#x27;</span> + <span class="hljs-built_in">this</span>.wsURL);        <span class="hljs-keyword">var</span> _this = <span class="hljs-built_in">this</span>;        <span class="hljs-comment">// 不check close，让</span>        <span class="hljs-comment">// if (this.socket &amp;&amp; this.socket.readyState === 1) &#123;</span>        <span class="hljs-comment">//     this.socket.close();</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-built_in">this</span>.socket = <span class="hljs-built_in">this</span>.webSocketFactory(<span class="hljs-built_in">this</span>.wsURL);        &#125; <span class="hljs-keyword">catch</span> (e) &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;sekiro: create connection failed,reconnect after 2s&quot;</span>);            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                _this.connect()            &#125;, <span class="hljs-number">2000</span>)        &#125;        <span class="hljs-built_in">this</span>.socket.onmessage(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;            _this.handleSekiroRequest(event.data)        &#125;);        <span class="hljs-built_in">this</span>.socket.onopen(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;sekiro: open a sekiro client connection&#x27;</span>)        &#125;);        <span class="hljs-built_in">this</span>.socket.onclose(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;sekiro: disconnected ,reconnection after 2s&#x27;</span>);            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                _this.connect()            &#125;, <span class="hljs-number">2000</span>)        &#125;);    &#125;;    SekiroClient.prototype.handleSekiroRequest = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requestJson</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;receive sekiro request: &quot;</span> + requestJson);        <span class="hljs-keyword">var</span> request = <span class="hljs-built_in">JSON</span>.parse(requestJson);        <span class="hljs-keyword">var</span> seq = request[<span class="hljs-string">&#x27;__sekiro_seq__&#x27;</span>];        <span class="hljs-keyword">if</span> (!request[<span class="hljs-string">&#x27;action&#x27;</span>]) &#123;            <span class="hljs-built_in">this</span>.sendFailed(seq, <span class="hljs-string">&#x27;need request param &#123;action&#125;&#x27;</span>);            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-keyword">var</span> action = request[<span class="hljs-string">&#x27;action&#x27;</span>];        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.handlers[action]) &#123;            <span class="hljs-built_in">this</span>.sendFailed(seq, <span class="hljs-string">&#x27;no action handler: &#x27;</span> + action + <span class="hljs-string">&#x27; defined&#x27;</span>);            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-keyword">var</span> theHandler = <span class="hljs-built_in">this</span>.handlers[action];        <span class="hljs-keyword">var</span> _this = <span class="hljs-built_in">this</span>;        <span class="hljs-keyword">try</span> &#123;            theHandler(request, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    _this.sendSuccess(seq, response)                &#125; <span class="hljs-keyword">catch</span> (e) &#123;                    _this.sendFailed(seq, <span class="hljs-string">&quot;e:&quot;</span> + e);                &#125;            &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">errorMessage</span>) </span>&#123;                _this.sendFailed(seq, errorMessage)            &#125;)        &#125; <span class="hljs-keyword">catch</span> (e) &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;error: &quot;</span> + e);            _this.sendFailed(seq, <span class="hljs-string">&quot;:&quot;</span> + e);        &#125;    &#125;;    SekiroClient.prototype.sendSuccess = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">seq, response</span>) </span>&#123;        <span class="hljs-keyword">var</span> responseJson;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> response == <span class="hljs-string">&#x27;string&#x27;</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                responseJson = <span class="hljs-built_in">JSON</span>.parse(response);            &#125; <span class="hljs-keyword">catch</span> (e) &#123;                responseJson = &#123;&#125;;                responseJson[<span class="hljs-string">&#x27;data&#x27;</span>] = response;            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> response == <span class="hljs-string">&#x27;object&#x27;</span>) &#123;            responseJson = response;        &#125; <span class="hljs-keyword">else</span> &#123;            responseJson = &#123;&#125;;            responseJson[<span class="hljs-string">&#x27;data&#x27;</span>] = response;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(responseJson)) &#123;            responseJson = &#123;                <span class="hljs-attr">data</span>: responseJson,                <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> (responseJson[<span class="hljs-string">&#x27;code&#x27;</span>]) &#123;            responseJson[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (responseJson[<span class="hljs-string">&#x27;status&#x27;</span>]) &#123;            responseJson[<span class="hljs-string">&#x27;status&#x27;</span>] = <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            responseJson[<span class="hljs-string">&#x27;status&#x27;</span>] = <span class="hljs-number">0</span>;        &#125;        responseJson[<span class="hljs-string">&#x27;__sekiro_seq__&#x27;</span>] = seq;        <span class="hljs-keyword">var</span> responseText = <span class="hljs-built_in">JSON</span>.stringify(responseJson);        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;response :&quot;</span> + responseText);        <span class="hljs-built_in">this</span>.socket.send(responseText);    &#125;;    SekiroClient.prototype.sendFailed = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">seq, errorMessage</span>) </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> errorMessage != <span class="hljs-string">&#x27;string&#x27;</span>) &#123;            errorMessage = <span class="hljs-built_in">JSON</span>.stringify(errorMessage);        &#125;        <span class="hljs-keyword">var</span> responseJson = &#123;&#125;;        responseJson[<span class="hljs-string">&#x27;message&#x27;</span>] = errorMessage;        responseJson[<span class="hljs-string">&#x27;status&#x27;</span>] = -<span class="hljs-number">1</span>;        responseJson[<span class="hljs-string">&#x27;__sekiro_seq__&#x27;</span>] = seq;        <span class="hljs-keyword">var</span> responseText = <span class="hljs-built_in">JSON</span>.stringify(responseJson);        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;sekiro: response :&quot;</span> + responseText);        <span class="hljs-built_in">this</span>.socket.send(responseText)    &#125;;    SekiroClient.prototype.registerAction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action, handler</span>) </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> action !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;an action must be string&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> handler !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;a handler must be function&quot;</span>);        &#125;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;sekiro: register action: &quot;</span> + action);        <span class="hljs-built_in">this</span>.handlers[action] = handler;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;    &#125;;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">guid</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">S4</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">return</span> (((<span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>.random()) * <span class="hljs-number">0x10000</span>) | <span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>).substring(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> (S4() + S4() + <span class="hljs-string">&quot;-&quot;</span> + S4() + <span class="hljs-string">&quot;-&quot;</span> + S4() + <span class="hljs-string">&quot;-&quot;</span> + S4() + <span class="hljs-string">&quot;-&quot;</span> + S4() + S4() + S4());    &#125;    <span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> SekiroClient(<span class="hljs-string">&quot;ws://127.0.0.1:5620/business-demo/register?group=rpc-test&amp;clientId=&quot;</span> + guid());    client.registerAction(<span class="hljs-string">&quot;getH5fingerprint&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request, resolve, reject</span>) </span>&#123;        resolve(utility.getH5fingerprint(request[<span class="hljs-string">&quot;url&quot;</span>]));    &#125;)&#125;)();</code></pre><p>与前面的方法一样，使用浏览器开发者工具 Overrides 重写功能，将上面的代码注入到网页 JS 里：</p><p><img src="https://cdn.itbob.cn/img/article/047/07.png" alt="07"></p><p>然后 Sekiro 为我们提供了一些 API：</p><ul><li>查看分组列表：<a href="http://127.0.0.1:5620/business-demo/groupList">http://127.0.0.1:5620/business-demo/groupList</a></li><li>查看队列状态：<a href="http://127.0.0.1:5620/business-demo/clientQueue?group=test">http://127.0.0.1:5620/business-demo/clientQueue?group=test</a></li><li>调用转发：<a href="http://127.0.0.1:5620/business-demo/invoke?group=test&amp;action=test&amp;param=testparm">http://127.0.0.1:5620/business-demo/invoke?group=test&amp;action=test&amp;param=testparm</a></li></ul><p>比如我们现在要调用 <code>utility.getH5fingerprint()</code> 加密方法该怎么办呢？很简单，代码注入到浏览器里后，首先还是要手动登录一遍，手动登录一遍，手动登录一遍，重要的事情说三遍！然后参考上面的调用转发 API 进行改写：</p><ul><li>我们自定义的分组 <code>group</code> 是 <code>rpc-test</code>；</li><li>事件 <code>action</code> 是 <code>getH5fingerprint</code>；</li><li>待加密参数名称为 <code>url</code>， 其值例如为：<code>https://www.baidu.com/</code></li></ul><p>那么我们的调用链接就应该是：<code>http://127.0.0.1:5620/business-demo/invoke?group=rpc-test&amp;action=getH5fingerprint&amp;url=https://www.baidu.com/</code>，直接浏览器打开，返回的字典，data 里面就是加密结果：</p><p><img src="https://cdn.itbob.cn/img/article/047/08.png" alt="08"></p><p>同样的，在本地用 Python 的话，直接 requests 就完事儿了：</p><p><img src="https://cdn.itbob.cn/img/article/047/09.png" alt="09"></p><p>我们前面是把 sekiro_web_client.js 复制下来和通信代码一起注入到浏览器的，这里我们还可以有更加优雅的方法，直接给 document 新创建一个 script，通过链接的形式插入 sekiro_web_client.js，这里需要注意一下几点问题：</p><ol><li>第一个是时机的问题，需要等待 document 这些元素加载完成才能建立 SekiroClient 通信，不然调用 SekiroClient 是会报错的，这里可以用 setTimeout 方法，该方法用于在指定的毫秒数后调用函数或计算表达式，将 SekiroClient 通信代码单独封装成一个函数，比如 <code>function startSekiro()</code>，然后等待 1-2 秒后再执行 SekiroClient 通信代码；</li><li>由于 SekiroClient 通信代码被封装成了函数，此时直接调用 <code>utility.getH5fingerprint</code> 是会提示未定义的，所以我们要先将其导为全局变量，比如 <code>window.getH5fingerprint = utility.getH5fingerprint</code>，后续直接调用 <code>window.getH5fingerprint</code> 即可。</li></ol><p>完整代码如下所示：</p><pre><code class="hljs javascript"><span class="hljs-comment">/* ==================================</span><span class="hljs-comment"># @Time    : 2022-02-14</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: sekiro.js</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ================================== */</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> newElement = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;script&quot;</span>);    newElement.setAttribute(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;text/javascript&quot;</span>);    newElement.setAttribute(<span class="hljs-string">&quot;src&quot;</span>, <span class="hljs-string">&quot;https://sekiro.virjar.com/sekiro-doc/assets/sekiro_web_client.js&quot;</span>);    <span class="hljs-built_in">document</span>.body.appendChild(newElement);    <span class="hljs-built_in">window</span>.getH5fingerprint = utility.getH5fingerprint    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">guid</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">S4</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">return</span> (((<span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>.random()) * <span class="hljs-number">0x10000</span>) | <span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>).substring(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> (S4() + S4() + <span class="hljs-string">&quot;-&quot;</span> + S4() + <span class="hljs-string">&quot;-&quot;</span> + S4() + <span class="hljs-string">&quot;-&quot;</span> + S4() + <span class="hljs-string">&quot;-&quot;</span> + S4() + S4() + S4());    &#125;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startSekiro</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> SekiroClient(<span class="hljs-string">&quot;ws://127.0.0.1:5620/business-demo/register?group=rpc-test&amp;clientId=&quot;</span> + guid());        client.registerAction(<span class="hljs-string">&quot;getH5fingerprint&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request, resolve, reject</span>) </span>&#123;            resolve(<span class="hljs-built_in">window</span>.getH5fingerprint(request[<span class="hljs-string">&quot;url&quot;</span>]));        &#125;)    &#125;    <span class="hljs-built_in">setTimeout</span>(startSekiro, <span class="hljs-number">2000</span>)&#125;)();</code></pre><p><img src="https://cdn.itbob.cn/img/article/047/10.png" alt="10"></p><h2 id="优缺点">优缺点</h2><p>目前如果不去逆向 JS 来实现加密参数的话，用得最多的就是自动化工具了，比如 Selenium、Puppeteer 等，很显然这些自动化工具配置繁琐、运行效率极低，而 RPC 技术不需要加载多余的资源，稳定性和效率明显都更高，RPC 不需要考虑浏览器指纹、各种环境，如果风控不严的话，高并发也是能够轻松实现的，相反，由于 RPC 是一直挂载在同一个浏览器上的，所以针对风控较严格的站点，比如检测 UA、IP 与加密参数绑定之类的，那么 PRC 调用太频繁就不太行了，当然也可以研究研究浏览器群控技术，操纵多个不同浏览器可以一定程度上缓解这个问题。总之 RPC 技术还是非常牛的，除了 JS 逆向，可以说是目前比较万能、高效的方法了，一定程度上做到了加密参数一把梭！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/rpc.png&quot; alt=&quot;rpc&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是-RPC&quot;&gt;什么是 RPC&lt;/h2&gt;
&lt;p&gt;&lt;s&gt;RPC，英文 RangPaCong，中文让爬虫，旨在为爬虫开路，秒杀一切</summary>
      
    
    
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>吾爱破解2022春节解题领红包之番外篇 Web 中级题解</title>
    <link href="https://www.itbob.cn/article/046/"/>
    <id>https://www.itbob.cn/article/046/</id>
    <published>2022-02-17T00:43:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逆向目标">逆向目标</h2><p>本次逆向的目标来源于吾爱破解 2022 春节解题领红包之番外篇 Web 中级题，吾爱破解每年都会有派送红包活动（送吾爱币），需要大家使出看家逆向本领来分析内容获得口令红包，今年一共有五个题，一个送分题，两个 Windows 题、一个 Android 题和一个 Web 题，本文分析的正是  Web 题，<strong>吾爱有规定活动结束前不要外泄口令、讨论分享分析过程，所以本文在活动结束后才发出来。</strong></p><p>此 Web 题题目是：小 D 最爱看的视频网站最近关站了，关站前他用 Fiddler 和 Web Archive 保存了一位主播的视频，但他发现存下来的文件无法播放。你能帮小 D 找回他的回忆吗？（.saz 与 .wacz 任选其一即可解题）</p><ul><li><p>活动地址：<a href="https://www.52pojie.cn/thread-1582582-1-1.html">https://www.52pojie.cn/thread-1582582-1-1.html</a></p></li><li><p>Web 题地址：<a href="https://www.52pojie.cn/home.php?mod=task&amp;do=view&amp;id=17">https://www.52pojie.cn/home.php?mod=task&amp;do=view&amp;id=17</a></p></li></ul><h2 id="HLS-流媒体传输协议">HLS 流媒体传输协议</h2><p>本题涉及到 HLS 流媒体传输协议，先简单介绍一下，了解的同志可直接跳过。</p><p>HLS 全称 HTTP Live Streaming，即基于 HTTP 的自适应码率流媒体传输协议，是苹果研发的动态码率自适应技术，它包括一个 M3U(8) 的索引文件，若干 TS 视频流文件，如果视频流文件是加密的，那就还会存在一个 key 加密串文件。</p><p>M3U8 文件是 M3U 的一种，只不过文件中存储的文本使用 UTF-8 字符编码，在极少数情况下，M3U8 文件可能会以 M3UP 扩展名保存。M3U8 文件是各种音频和视频播放程序使用的播放列表文件，它包含了媒体文件或媒体文件夹的路径或 URL，以及有关播放列表的相关信息。</p><p>TS 全称为 MPEG2-TS，TS 即 Transport Stream 传输流，又称 MPEG-TS、MTS、TP，这种格式的特点就是从视频流的任一片段开始都是可以独立解码的。</p><p>针对 TS 格式的文件，如果是未加密的，一般的播放器就能够直接播放，也可以使用 FFmpeg 等工具转换为其他格式，FFmpeg 也可以直接处理 M3U8 文件，自动解密合并转换 TS 文件，当然也有其他大佬写好的小工具，拖入 M3U8 文件就直接给你处理好了。</p><p><img src="https://cdn.itbob.cn/img/article/046/01.png" alt="01.png"></p><p>M3U8 文件内容的大致格式示例如下：</p><pre><code class="hljs awk"><span class="hljs-comment">#EXTM3U</span><span class="hljs-comment">#EXT-X-VERSION:3</span><span class="hljs-comment">#EXT-X-MEDIA-SEQUENCE:0</span><span class="hljs-comment">#EXT-X-ALLOW-CACHE:YES</span><span class="hljs-comment">#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://www.example.com/m3u8.key&quot;</span><span class="hljs-comment">#EXT-X-TARGETDURATION:5</span><span class="hljs-comment">#EXTINF:4.200000,</span>https:<span class="hljs-regexp">//</span>www.example.com<span class="hljs-regexp">/hls/</span>live_00000.ts<span class="hljs-comment">#EXTINF:4.166667,</span>https:<span class="hljs-regexp">//</span>www.example.com<span class="hljs-regexp">/hls/</span>live_00001.ts<span class="hljs-comment">#EXTINF:3.600000,</span>https:<span class="hljs-regexp">//</span>www.example.com<span class="hljs-regexp">/hls/</span>live_00002.ts<span class="hljs-comment">#EXTINF:2.516667,</span>https:<span class="hljs-regexp">//</span>www.example.com<span class="hljs-regexp">/hls/</span>live_00003.ts<span class="hljs-comment">#EXTINF:4.166667,</span>https:<span class="hljs-regexp">//</span>www.example.com<span class="hljs-regexp">/hls/</span>live_00004.ts<span class="hljs-comment">#EXTINF:4.166667,</span>https:<span class="hljs-regexp">//</span>www.example.com<span class="hljs-regexp">/hls/</span>live_00005.ts<span class="hljs-comment">#EXTINF:4.166667,</span>https:<span class="hljs-regexp">//</span>www.example.com<span class="hljs-regexp">/hls/</span>live_00006.ts<span class="hljs-comment">#EXTINF:1.716667,</span>https:<span class="hljs-regexp">//</span>www.example.com<span class="hljs-regexp">/hls/</span>live_00007.ts<span class="hljs-comment">#EXT-X-ENDLIST</span></code></pre><p>各标签含义如下：</p><ul><li><code>#EXTM3U</code>：m3u文件头，必须放在第一行，起标示作用；</li><li><code>#EXT-X-VERSION</code>：播放列表文件的兼容版本。若不存在此标记，则默认为协议的第一个版本；</li><li><code>#EXT-X-MEDIA-SEQUENCE</code>： 播放列表中的每个媒体 URI 都有一个唯一的整数序列号。URI 的序列号等于它之前的 URI 的序列号加一；</li><li><code>#EXT-X-ALLOW-CACHE</code>：指示客户端是否可以缓存下载的媒体片段以供以后重播；</li><li><code>#EXT-X-KEY</code>：TS 片段可以被加密，该标签指定加密方式（METHOD）、密钥的 URI 以及偏移量 IV 等信息，没有此标签表示未加密；</li><li><code>#EXT-X-TARGETDURATION</code>：每一份 TS 媒体文件的最大持续时间，以秒为单位；</li><li><code>#EXTINF</code>：每一份媒体文件的详细信息，包括媒体持续时间、媒体 URL 地址等；</li><li><code>#EXT-X-ENDLIST</code>：表示不再将媒体片段添加到播放列表文件中，一般位于文件结尾。</li></ul><p>完整格式、标准标签可参考 HLS 标准协议中，对 Playlist file 的介绍：<a href="https://datatracker.ietf.org/doc/html/draft-pantos-http-live-streaming-08">https://datatracker.ietf.org/doc/html/draft-pantos-http-live-streaming-08</a></p><h2 id="SAZ-分析">SAZ 分析</h2><p>在 Fiddler 软件中，使用 SAZ 格式用来保存和读取 HTTP/HTTPS 请求信息，打开该文件可以注意到一些重要的请求：script.bundle.js、live.m3u8、drm 以及八个 ts 视频流文件。</p><p>先来看看 m3u8 文件，可以看到是 AES-128 加密，加密的 key 文件地址为 <code>key://live</code>，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/046/02.png" alt="02.png"></p><p>一般情况下，要想解密 ts，必然会去请求 key 的地址，拿到 key 后再解密 ts，很显然此题的 key 地址不是一个合法的 URL 地址，当然此题的抓包记录可能是出题人伪造的，因为这个 Host 是 52tube.mmxxii，也不是一个合法的域名，最主要的是，抓包记录里没有 <code>key://live</code> 这条请求，那么很大概率真实的地址隐藏在 JS 里，从另一个方面来思考，如果这是完整的抓包记录，不管真实的 key 地址是啥，必然会在记录里出现！</p><p>有经验的朋友应该一眼就能看出来 drm 这条请求最有可能是拿 key 的操作了，第一是 drm 这个关键词在 ts 解密里经常会出现，搞得多的朋友应该见过不少，第二 ping 请求返回的 success，通过其名称和返回值来看也不像 key，剩下就只有 drm 了，查看返回值是乱码的，查看 Hex 值，32 位 16 进制数据，而正常的 key 应该是 16 位 16 进制数据，所以你如果直接拿这个数据当作 key 去解密，肯定也是失败的。</p><p>到这里我们应该有如下猜想：drm 返回的数据，经过了 script.bundle.js 二次处理就能得到正确的 key。</p><p><img src="https://cdn.itbob.cn/img/article/046/03.png" alt="03.png"></p><h2 id="JS-逆向">JS 逆向</h2><p>我们把抓包记录的 script.bundle.js，右键，save - response - response body，保存到本地。</p><p>格式化之后有 15000+ 行代码，又不能动态调试，从哪里找加密入口呢？可以大胆尝试一下：</p><ul><li>JS 里可能会检测到 m3u8 里存在 key 的 URI 之后，发送 /api/drm/ 这个请求，可以直接搜索 <code>/api/drm/</code> 或者 <code>key://live</code> 定位；</li><li>drm 是一个 post 请求，带有 h 和 id 两个参数，可以直接搜索 <code>post</code>、<code>id</code>、<code>h</code> 定位到大致位置。</li></ul><p><img src="https://cdn.itbob.cn/img/article/046/04.png" alt="04.png"></p><p>通过搜索可以发现如下可疑代码片段：</p><p><img src="https://cdn.itbob.cn/img/article/046/05.png" alt="05.png"></p><p>将关键代码提炼一下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params">t</span>) </span>&#123;    <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Uint8Array</span>(t)].map((<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> t.toString(<span class="hljs-number">16</span>).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>))).join(<span class="hljs-string">&quot;&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params">t, e</span>) </span>&#123;    <span class="hljs-keyword">let</span> r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(t.length);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; t.length; i++) r[i] = t[i] ^ e[i];    <span class="hljs-keyword">return</span> r&#125;<span class="hljs-keyword">let</span> e = <span class="hljs-string">&quot;/api/ping/&quot;</span>,    i = <span class="hljs-string">&quot;/api/drm/&quot;</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">a</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">t</span>.<span class="hljs-title">DefaultConfig</span>.<span class="hljs-title">loader</span> </span>&#123;    <span class="hljs-keyword">let</span> e = <span class="hljs-keyword">await</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">let</span> t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">16</span>);        crypto.getRandomValues(t);        <span class="hljs-keyword">let</span> e = n(t.buffer) + <span class="hljs-built_in">Date</span>.now() + <span class="hljs-built_in">Math</span>.random();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>((<span class="hljs-keyword">await</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t</span>) </span>&#123;            <span class="hljs-keyword">const</span> e = (<span class="hljs-keyword">new</span> TextEncoder).encode(t);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> crypto.subtle.digest(<span class="hljs-string">&quot;SHA-256&quot;</span>, e)        &#125; (e)).slice(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>))    &#125;();    <span class="hljs-keyword">var</span> r = <span class="hljs-keyword">new</span> URLSearchParams;    r.append(<span class="hljs-string">&quot;h&quot;</span>, n(e.buffer)),        r.append(<span class="hljs-string">&quot;id&quot;</span>, t);    <span class="hljs-keyword">var</span> a = &#123;        <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,        <span class="hljs-attr">headers</span>: &#123;            <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>        &#125;,        <span class="hljs-attr">body</span>: r    &#125;;    <span class="hljs-keyword">let</span> o = <span class="hljs-keyword">await</span> fetch(i, a),        l = <span class="hljs-keyword">await</span> o.arrayBuffer();    <span class="hljs-keyword">if</span> (<span class="hljs-number">32</span> !== l.byteLength) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Invalid response&quot;</span>);    <span class="hljs-keyword">let</span> u = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(l.slice(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>)),        c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(l.slice(<span class="hljs-number">16</span>, <span class="hljs-number">32</span>));    <span class="hljs-keyword">return</span> s(s(u, e), c)&#125;</code></pre><p>可以看到事实上在发送 <code>/api/drm/</code> 请求拿到结果后，先后取前后 16 位数据，然后经过了 s 方法的处理，最后返回的 <code>s(s(u, e), c)</code> 应该才是正确的 key，这里的重点在于 e 的值，上面有个方法，取了当前时间+随机值，经过 SHA-256 加密，再取前 16 位。</p><p>这里可以思考一下，这个 e 的值是不固定的，那么最后的 key 应该也是不固定的，同一个 TS 对应有无数个 key，我反正是没见过，不信的话尝试就用那个方法生成 e，你会发现最终的 key 是错误的。</p><p>仔细看一下，发送 post 请求对 h 值赋值的地方：<code>r.append(&quot;h&quot;, n(e.buffer))</code>，n 方法是转 16 进制，那么我们直接将 h 值倒推，从16进制转为10进制，这才是正确的 e 的值！然后 l 的值是 <code>/api/drm/</code> 请求返回的 32 位 16 进制数据转为 10 进制，剩下的就好说了，直接改写一下 JS 代码拿到正确的 key：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params">t, e</span>) </span>&#123;    <span class="hljs-keyword">let</span> r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(t.length);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; t.length; i++)        r[i] = t[i] ^ e[i];    <span class="hljs-keyword">return</span> r&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getKey</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">// /api/drm/ 请求表单的 h 值，16进制数据</span>    <span class="hljs-keyword">const</span> h = [<span class="hljs-string">&quot;7b&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;31&quot;</span>, <span class="hljs-string">&quot;1e&quot;</span>, <span class="hljs-string">&quot;6e&quot;</span>, <span class="hljs-string">&quot;31&quot;</span>, <span class="hljs-string">&quot;0f&quot;</span>, <span class="hljs-string">&quot;0d&quot;</span>, <span class="hljs-string">&quot;f0&quot;</span>, <span class="hljs-string">&quot;68&quot;</span>, <span class="hljs-string">&quot;d9&quot;</span>, <span class="hljs-string">&quot;ed&quot;</span>, <span class="hljs-string">&quot;e1&quot;</span>, <span class="hljs-string">&quot;04&quot;</span>, <span class="hljs-string">&quot;75&quot;</span>, <span class="hljs-string">&quot;a8&quot;</span>];    <span class="hljs-comment">// /api/drm/ 请求返回的32位16进制数据</span>    <span class="hljs-keyword">const</span> drm = [<span class="hljs-string">&quot;08&quot;</span>, <span class="hljs-string">&quot;A5&quot;</span>, <span class="hljs-string">&quot;E6&quot;</span>, <span class="hljs-string">&quot;C2&quot;</span>, <span class="hljs-string">&quot;C2&quot;</span>, <span class="hljs-string">&quot;61&quot;</span>, <span class="hljs-string">&quot;A8&quot;</span>, <span class="hljs-string">&quot;AC&quot;</span>, <span class="hljs-string">&quot;B4&quot;</span>, <span class="hljs-string">&quot;D7&quot;</span>, <span class="hljs-string">&quot;9C&quot;</span>, <span class="hljs-string">&quot;49&quot;</span>, <span class="hljs-string">&quot;AF&quot;</span>, <span class="hljs-string">&quot;16&quot;</span>, <span class="hljs-string">&quot;0A&quot;</span>, <span class="hljs-string">&quot;3A&quot;</span>, <span class="hljs-string">&quot;DA&quot;</span>, <span class="hljs-string">&quot;4E&quot;</span>, <span class="hljs-string">&quot;5C&quot;</span>, <span class="hljs-string">&quot;EA&quot;</span>, <span class="hljs-string">&quot;E1&quot;</span>, <span class="hljs-string">&quot;6F&quot;</span>, <span class="hljs-string">&quot;ED&quot;</span>, <span class="hljs-string">&quot;46&quot;</span>, <span class="hljs-string">&quot;EB&quot;</span>, <span class="hljs-string">&quot;6F&quot;</span>, <span class="hljs-string">&quot;49&quot;</span>, <span class="hljs-string">&quot;8C&quot;</span>, <span class="hljs-string">&quot;9B&quot;</span>, <span class="hljs-string">&quot;63&quot;</span>, <span class="hljs-string">&quot;D5&quot;</span>, <span class="hljs-string">&quot;3B&quot;</span>]    <span class="hljs-comment">// 转换为10进制数据，为 e 和 l 赋值</span>    <span class="hljs-keyword">const</span> e = [];    <span class="hljs-keyword">const</span> l = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;h.length; i++)    &#123;        e.push(<span class="hljs-built_in">parseInt</span>(h[i],<span class="hljs-number">16</span>))    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;drm.length; i++)    &#123;        l.push(<span class="hljs-built_in">parseInt</span>(drm[i],<span class="hljs-number">16</span>))    &#125;    <span class="hljs-keyword">const</span> u = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(l.slice(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>));    <span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(l.slice(<span class="hljs-number">16</span>, <span class="hljs-number">32</span>));    <span class="hljs-keyword">const</span> keyArray = s(s(u, e), c);    <span class="hljs-keyword">const</span> keyHex = <span class="hljs-keyword">new</span> Buffer.from(keyArray).toString(<span class="hljs-string">&#x27;hex&#x27;</span>);    <span class="hljs-keyword">const</span> keyBase64 = <span class="hljs-keyword">new</span> Buffer.from(keyArray).toString(<span class="hljs-string">&#x27;base64&#x27;</span>);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;keyArray: &quot;</span>, keyArray)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;keyHex: &quot;</span>, keyHex)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;keyBase64: &quot;</span>, keyBase64)&#125;getKey()<span class="hljs-comment">// 输出</span><span class="hljs-comment">// keyArray:  Uint8Array(16) [</span><span class="hljs-comment">//   169, 251, 139,  54,  77,</span><span class="hljs-comment">//    63,  74, 231, 175, 208,</span><span class="hljs-comment">//    12,  40, 213, 113, 170,</span><span class="hljs-comment">//   169</span><span class="hljs-comment">// ]</span><span class="hljs-comment">// keyHex:  a9fb8b364d3f4ae7afd00c28d571aaa9</span><span class="hljs-comment">// keyBase64:  qfuLNk0/Suev0Awo1XGqqQ==</span></code></pre><h2 id="TS-解密合并转换">TS 解密合并转换</h2><p>通过 JS 逆向我们拿到了 16进制和 base64 形式的  key，不管什么形式都可以拿来解密，这里介绍两种对 TS 媒体流解密、合并、转换的方法。</p><p>第一种方法是使用 FFmpeg 工具，FFmpeg 是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。官网地址：<a href="https://ffmpeg.org/">https://ffmpeg.org/</a> ，下载编译好的程序，将 bin 目录添加到环境变量即可。</p><p>首先我们要把 m3u8 文件和 ts 媒体流保存到同一个文件夹，由于是虚假的 Host，所以不能直接浏览器访问保存，可以直接在 Fiddler 里，右键，save - response - response body，保存到本地，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/046/06.png" alt="06.png"></p><p>然后就是保存密钥文件，这里要求密钥文件必须是16进制的数据，如果你直接将 key 以字符串形式保存的话，解密也是失败的，编辑 16 进制文件有专门的工具，比如 HxD、010 editor、winhex 等，以 HxD 为例，新建文件，写入我们前面通过 JS 逆向得到的 key 的 16 进制数据，存为 .key 文件，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/046/07.png" alt="07.png"></p><p>然后修改 m3u8 文件里 key 的地址、名称，建议将 key、m3u8、ts 文件都放同一个文件夹，这样 m3u8 文件里就不用添加资源路径了，不容易出错。</p><p><img src="https://cdn.itbob.cn/img/article/046/08.png" alt="08.png"></p><p>然后在当前文件夹，打开命令行输入命令：<code>ffmpeg -allowed_extensions ALL -i live.m3u8 -c copy live.mp4</code>，即可自动解密 ts，并合并转换为 .mp4 格式：</p><p><img src="https://cdn.itbob.cn/img/article/046/09.png" alt="09.png"></p><p><img src="https://cdn.itbob.cn/img/article/046/10.png" alt="10.png"></p><p>第二种方法就是使用大佬写的第三方小工具，这里推荐吾爱大佬逍遥一仙写的 M3U8 批量下载器，下载地址、使用方法见原贴：<a href="https://www.52pojie.cn/thread-1374045-1-1.html">https://www.52pojie.cn/thread-1374045-1-1.html</a></p><p>我们可以直接拖入处理好的 M3U8 文件，自动处理：</p><p><img src="https://cdn.itbob.cn/img/article/046/11.png" alt="11.png"></p><p>也可以选择其他 - 工具 - 合并助手，添加所有 TS 文件，输入 key 后自动处理：</p><p><img src="https://cdn.itbob.cn/img/article/046/12.png" alt="12.png"></p><p>处理完毕后的 mp4 文件默认在软件目录的 output 文件夹里面，解密后是一段动画，往后看会找到 flag：<code>flag&#123;like_sub_52tube&#125;</code> 为正确答案。</p><p><img src="https://cdn.itbob.cn/img/article/046/13.png" alt="13.png"></p><p><img src="https://cdn.itbob.cn/img/article/046/14.png" alt="14.png"></p><p><img src="https://cdn.itbob.cn/img/article/046/15.png" alt="15.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;逆向目标&quot;&gt;逆向目标&lt;/h2&gt;
&lt;p&gt;本次逆向的目标来源于吾爱破解 2022 春节解题领红包之番外篇 Web 中级题，吾爱破解每年都会有派送红包活动（送吾爱币），需要大家使出看家逆向本领来分析内容获得口令红包，今年一共有五个题，一个送分题，两个 Windows 题</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>CTF&amp;爬虫：掌握这些特征，一秒识别密文加密方式</title>
    <link href="https://www.itbob.cn/article/045/"/>
    <id>https://www.itbob.cn/article/045/</id>
    <published>2022-01-13T09:40:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/encryption_algorithm.png" alt="encryption_algorithm"></p><h2 id="前言">前言</h2><p>爬虫工程师在做加密参数逆向的时候，经常会遇到各种各样的加密算法、编码、混淆，每个算法都有其对应的特征，对于一些较小的网站，往往直接引用这些官方算法，没有进行魔改等其他操作，这种情况下，如果我们能熟悉常见算法的特征，通过密文就能猜测出使用的哪种算法、编码、混淆，将会大大提高工作效率！在 CTF 中通常也会有密码类的题目，掌握一些常见密文特征也是 CTFer 们必备的技能！</p><p>本文将介绍以下编码和加密算法的特征：</p><ul><li>编码：Base 系列、Unicode、Escape、URL、Hex；</li><li>算法：MD5、SHA 系列、HMAC 系列、RSA、AES、DES、3DES、RC4、Rabbit、SM 系列；</li><li>混淆：Obfuscator、JJEncode、AAEncode、JSFuck、Jother、Brainfuck、Ook!、Trivial brainfuck substitution；</li><li>其他：恺撒密码、栅栏密码、猪圈密码、摩斯密码、培根密码、维吉尼亚密码、与佛论禅、当铺密码。</li></ul><p>PS：常见加密算法原理以及在 Python 和 JavaScript 中的实现方法可参见以前的文章：<a href="https://www.itbob.cn/article/039/">爬虫常见加密解密算法总结</a></p><h2 id="编码系列">编码系列</h2><h3 id="Base-系列编码">Base 系列编码</h3><p>Base64 是我们最常见的编码，除此之外，其实还有 Base16、Base32、Base58、Base85、Base100 等，他们之间最明显的区别就是使用了不同数量的可打印字符对任意字节数据进行编码，比如 Base64 使用了64个可打印字符（A-Z、a-z、0-9、+、/），Base16 使用了16个可打印字符（A-F、0-9），这里主要讲怎么快速识别，其具体原理可自行百度，Base 系列主要特征如下：</p><ul><li>Base16：结尾没有等号，数字要多于字母；</li><li>Base32：字母要多于数字，明文数量超过10个，结尾可能会有很多等号；</li><li>Base58：结尾没有等号，字母要多于数字；</li><li>Base64：一般情况下结尾都会有1个或者2个等号，明文很少的时候可能没有；</li><li>Base85：等号一般出现在字符串中间，含有一些奇怪的字符；</li><li>Base100：密文由 Emoji 表情组成。</li></ul><p>示例：</p><table><thead><tr><th style="text-align:left">编码类型</th><th style="text-align:left">示例一</th><th>示例二</th></tr></thead><tbody><tr><td style="text-align:left">明文</td><td style="text-align:left">01234567890</td><td>administrators</td></tr><tr><td style="text-align:left">Base16</td><td style="text-align:left"><code>3031323334353637383930</code></td><td><code>61646D696E6973747261746F7273</code></td></tr><tr><td style="text-align:left">Base32</td><td style="text-align:left"><code>GAYTEMZUGU3DOOBZGA======</code></td><td><code>MFSG22LONFZXI4TBORXXE4Y=</code></td></tr><tr><td style="text-align:left">Base58</td><td style="text-align:left"><code>cX8j8pvGzppMKVb</code></td><td><code>BNF5dFLUTN5XwM1yLoF</code></td></tr><tr><td style="text-align:left">Base64</td><td style="text-align:left"><code>MDEyMzQ1Njc4OTA=</code></td><td><code>YWRtaW5pc3RyYXRvcnM=</code></td></tr><tr><td style="text-align:left">Base85</td><td style="text-align:left"><code>0JP==1c70M3&amp;rY</code></td><td><code>@:X4hDJ=06Eaa'.EcV</code></td></tr><tr><td style="text-align:left">Base100</td><td style="text-align:left"><code>🐧🐨🐩🐪🐫🐬🐭🐮🐯🐰🐧</code></td><td><code>👘👛👤👠👥👠👪👫👩👘👫👦👩👪</code></td></tr></tbody></table><h3 id="Unicode-编码">Unicode 编码</h3><p>Unicode 又称为统一码、万国码、单一码，是一种在计算机上使用的字符编码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。其主要特征如下：</p><ul><li>以 <code>\u</code>、<code>&amp;#</code> 或 <code>&amp;#x</code> 开头，后面是数字加字母组合</li></ul><p>PS：<code>\u</code> 开头和 <code>&amp;#x</code> 开头是一样的，都是16进制 Unicode 字符的不同写法，<code>&amp;#</code> 则是 Unicode 字符10进制的写法，此外，<code>&amp;#</code> 和 <code>&amp;#x</code> 开头的，也称为 HTML 字符实体转换，字符实体是用一个编号写入 HTML 代码中来代替一个字符，在 HTML 中，某些字符是预留的，如果希望正确地显示预留字符，就必须在 HTML 源代码中使用字符实体。</p><table><thead><tr><th>编码类型</th><th>示例一</th><th>示例二</th></tr></thead><tbody><tr><td>明文</td><td>12345</td><td>admin</td></tr><tr><td>Unicode</td><td><code>\u0031\u0032\u0033\u0034\u0035</code></td><td><code>\u0061\u0064\u006d\u0069\u006e</code></td></tr></tbody></table><h3 id="Escape-编码">Escape 编码</h3><p>Escape 编码又叫 %u 编码，Escape 编码就是字符对应 UTF-16BE 表示方式前面加 %u，Escape 不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： <code>* @ - _ + . / </code>，其他所有的字符都会被转义序列替换。其主要特征如下：</p><ul><li>以 <code>%u</code> 开头，后面是数字加字母组合</li></ul><table><thead><tr><th>编码类型</th><th>示例一</th><th>示例二</th></tr></thead><tbody><tr><td>明文</td><td>爬虫</td><td>我爱Python</td></tr><tr><td>Escape</td><td><code>%u722C%u866B</code></td><td><code>%u6211%u7231Python</code></td></tr></tbody></table><h3 id="URL-Hex-编码">URL / Hex 编码</h3><p>URL 和 Hex 编码的结果是一样的，不同的是当你用 URL 编码网址时是不会把 <code>http</code>、<code>https</code> 关键字和 <code>/</code>、<code>?</code>、<code>&amp;</code>、<code>=</code> 等连接符进行编码的，而 Hex 编码则全部转化了，其主要特征如下：</p><ul><li>以 <code>%</code> 开头，后面是数字加字母组合</li></ul><table><thead><tr><th>编码类型</th><th>示例</th></tr></thead><tbody><tr><td>明文</td><td><a href="https://www.kuaidaili.com/">https://www.kuaidaili.com/</a></td></tr><tr><td>Unicode</td><td><code>https://%77%77%77%2E%6B%75%61%69%64%61%69%6C%69%2E%63%6F%6D/</code></td></tr><tr><td>Hex</td><td><code>%68%74%74%70%73%3a%2f%2f%77%77%77%2e%6b%75%61%69%64%61%69%6c%69%2e%63%6f%6d%2f</code></td></tr></tbody></table><h2 id="加密算法">加密算法</h2><h3 id="MD5">MD5</h3><p>MD5 实质是一种消息摘要算法，一个数据的 MD5 值是唯一的，同一个数据不可能计算出多个不同的 MD5 值，但是，不同数据计算出来的 MD5 值是有可能一样的，知道一个 MD5 值，理论上是无法还原出它的原始数据的，MD5 是最容易辨别的，主要特征如下：</p><ul><li>密文一般为 16 位或者 32 位，其中 16 位是取的 32 位第 9~25 位的值；</li><li>组成方式为字母（a-f）和数字（0-9）混合，字母可以全部是大写或者小写。</li></ul><p>除了通过密文特征来判断以外，我们还可以搜索源代码，标准 MD5 的源码里是包含了一些特定的值的，没有这些特定值，就无法实现 MD5：</p><ul><li><code>0123456789ABCDEF</code>、<code>0123456789abcdef</code></li><li><code>1732584193</code>、<code>-271733879</code>、<code>-1732584194</code>、<code>271733878</code></li></ul><p>PS：某些特殊情况下，密文的长度也有可能不止 16 位或者 32 位，有可能是在官方算法上有一些魔改，通常也是在 16 位的基础上，左右填充了一些随机字符串。</p><p>示例：</p><table><thead><tr><th>编码类型</th><th>示例一</th><th>示例二</th></tr></thead><tbody><tr><td>明文</td><td>123456</td><td>admin</td></tr><tr><td>MD5（16位小写）</td><td><code>49ba59abbe56e057</code></td><td><code>7a57a5a743894a0e</code></td></tr><tr><td>MD5（16位大写）</td><td><code>49BA59ABBE56E057</code></td><td><code>7A57A5A743894A0E</code></td></tr><tr><td>MD5（32位小写）</td><td><code>e10adc3949ba59abbe56e057f20f883e</code></td><td><code>21232f297a57a5a743894a0e4a801fc3</code></td></tr><tr><td>MD5（32位大写）</td><td><code>E10ADC3949BA59ABBE56E057F20F883E</code></td><td><code>21232F297A57A5A743894A0E4A801FC3</code></td></tr></tbody></table><h3 id="SHA-系列">SHA 系列</h3><p>SHA 是比 MD5 更安全一点的摘要算法，SHA 通常指 SHA 家族算法，分别是 SHA-1、SHA-2、SHA-3，其中 SHA-2 是 SHA-224、SHA-256、SHA-384、SHA-512 的并称，SHA-3 是 SHA3-224、SHA3-256、SHA3-384、SHA3-512、SHAKE128、SHAKE256 的并称，其名字的后缀的数字就代表了结果的大小（bit），注意，SHAKE 算法结果的大小并不是固定的，其他算法特征如下：</p><ul><li>SHA-1：字母（a-f）和数字（0-9）混合，固定位数 40 位；</li><li>SHA-224/SHA3-224：字母（a-f）和数字（0-9）混合，固定位数 56 位；</li><li>SHA-256/SHA3-256：字母（a-f）和数字（0-9）混合，固定位数 64 位；</li><li>SHA-384/SHA3-384：字母（a-f）和数字（0-9）混合，固定位数 96 位；</li><li>SHA-512/SHA3-512：字母（a-f）和数字（0-9）混合，固定位数 128 位。</li></ul><p>示例：</p><table><thead><tr><th>编码类型</th><th>示例</th></tr></thead><tbody><tr><td>明文</td><td>123456</td></tr><tr><td>SHA-1</td><td><code>7c4a8d09ca3762af61e59520943dc26494f8941b</code></td></tr><tr><td>SHA-256</td><td><code>8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92</code></td></tr><tr><td>SHA3-256</td><td><code>c888c9ce9e098d5864d3ded6ebcc140a12142263bace3a23a36f9905f12bd64a</code></td></tr></tbody></table><h3 id="HMAC-系列">HMAC 系列</h3><p>HMAC 这种算法就是在 MD5、SHA 两种加密的基础上引入了秘钥，其密文也和 MD5、SHA 类似，密文的长度和使用的 MD5、SHA 算法对应密文的长度是一样的。特征如下：</p><ul><li>HMAC-MD5：字母（a-f）和数字（0-9）混合，位数一般为 32 位；</li><li>HMAC-SHA-1：字母（a-f）和数字（0-9）混合，固定位数 40 位；</li><li>HMAC-SHA-224 / HMAC-SHA3-224：字母（a-f）和数字（0-9）混合，固定位数 56 位；</li><li>HMAC-SHA-256 / HMAC-SHA3-256：字母（a-f）和数字（0-9）混合，固定位数 64 位；</li><li>HMAC-SHA-384 / HMAC-SHA3-384：字母（a-f）和数字（0-9）混合，固定位数 96 位；</li><li>HMAC-SHA-512 / HMAC-SHA3-512：字母（a-f）和数字（0-9）混合，固定位数 128 位。</li></ul><p>HMAC 和 SHA、MD5 的密文都很像，当无法确定是否为 HMAC 时，可以通过其名称搜索到加密方法，如果传入了密钥 key，说明就是 HMAC，当然你也可以直接当做是 SHA 或 MD5 来解，解密失败时就得考虑是否有密钥，是否为 HMAC 了，在 JS 中，通常一个 HMAC 加密方法是这样写的：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HmacSHA1Encrypt</span>(<span class="hljs-params">word, key</span>) </span>&#123;    <span class="hljs-keyword">return</span> CryptoJS.HmacSHA1(word, key).toString();&#125;</code></pre><p>示例（密钥 123456abcde）：</p><table><thead><tr><th>编码类型</th><th>示例</th></tr></thead><tbody><tr><td>明文</td><td>123456</td></tr><tr><td>HMAC-MD5</td><td><code>432bb95bb00005ddce4a1c757488ed95</code></td></tr><tr><td>HMAC-SHA-1</td><td><code>37a04076b7736c44460d330ee0d00014428b175e</code></td></tr><tr><td>HMAC-SHA-256</td><td><code>50cb1345366df11140fb91b43caaf69627e3f5529705ddf6b0d0cae67986e585</code></td></tr><tr><td>HMAC-SHA3-256</td><td><code>b808ed9f66436e89fba527a01d1d6044318fea8599d9f39bfb6bec4843964bf3</code></td></tr></tbody></table><h3 id="RSA">RSA</h3><p>RSA 加密算法是一种非对称加密算法，通过公钥加密结果，必须私钥解密。 同样私钥加密结果，公钥可以解密，应用非常广泛，在网站中通常使用 JSEncrypt 库来实现，其最大的特征就是有一个设置公钥的过程，我们可以通过以下方法来快速初步判断是否为 RSA 算法：</p><ul><li><p>搜索关键词 <code>new JSEncrypt()</code>，<code>JSEncrypt</code> 等，一般会使用 JSEncrypt 库，会有 new 一个实例对象的操作；</p></li><li><p>搜索关键词 <code>setPublicKey</code>、<code>setKey</code>、<code>setPrivateKey</code>、<code>getPublicKey</code> 等，一般实现的代码里都含有设置密钥的过程；</p></li><li><p>RSA 的私钥、公钥、明文、密文长度也有一定对应关系，也可以从这方面初步判断：</p><table><thead><tr><th style="text-align:left">私钥长度（Base64）</th><th style="text-align:left">公钥长度（Base64）</th><th style="text-align:left">明文长度</th><th style="text-align:left">密文长度</th></tr></thead><tbody><tr><td style="text-align:left">428</td><td style="text-align:left">128</td><td style="text-align:left">1~53</td><td style="text-align:left">88</td></tr><tr><td style="text-align:left">812</td><td style="text-align:left">216</td><td style="text-align:left">1~117</td><td style="text-align:left">172</td></tr><tr><td style="text-align:left">1588</td><td style="text-align:left">392</td><td style="text-align:left">1~245</td><td style="text-align:left">344</td></tr></tbody></table></li></ul><h3 id="AES、DES、3DES、RC4、Rabbit-等">AES、DES、3DES、RC4、Rabbit 等</h3><p>AES、DES、3DES、RC4、Rabbit 等加密算法的密文通常没有固定的长度，他们通常使用 crypto-js 来实现，比如 AES 加解密示例如下：</p><pre><code class="hljs javascript">CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;crypto-js&quot;</span>)<span class="hljs-keyword">var</span> key = CryptoJS.enc.Utf8.parse(<span class="hljs-string">&quot;0123456789abcdef&quot;</span>);<span class="hljs-keyword">var</span> iv = CryptoJS.enc.Utf8.parse(<span class="hljs-string">&quot;0123456789abcdef&quot;</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AESEncrypt</span>(<span class="hljs-params">word</span>) </span>&#123;    <span class="hljs-keyword">var</span> srcs = CryptoJS.enc.Utf8.parse(word);    <span class="hljs-keyword">var</span> encrypted = CryptoJS.AES.encrypt(srcs, key, &#123;        <span class="hljs-attr">iv</span>: iv,        <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,        <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7    &#125;);    <span class="hljs-keyword">return</span> encrypted.toString();&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AESDecrypt</span>(<span class="hljs-params">word</span>) </span>&#123;    <span class="hljs-keyword">var</span> srcs = word;    <span class="hljs-keyword">var</span> decrypt = CryptoJS.AES.decrypt(srcs, key, &#123;        <span class="hljs-attr">iv</span>: iv,        <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,        <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7    &#125;);    <span class="hljs-keyword">return</span> decrypt.toString(CryptoJS.enc.Utf8);&#125;<span class="hljs-built_in">console</span>.log(AESEncrypt(<span class="hljs-string">&quot;ITBOB&quot;</span>))<span class="hljs-built_in">console</span>.log(AESDecrypt(<span class="hljs-string">&quot;r78lMXzImDRcDx9ADakCmg==&quot;</span>))</code></pre><p>在 crypto-js 中，也有一些特定的关键字，我们可以通过搜索这些关键字来快速定位到 crypto-js：</p><ul><li><p><code>CryptoJS</code>、<code>crypto-js</code>、<code>iv</code>、<code>mode</code>、<code>padding</code>、<code>createEncryptor</code>、<code>createDecryptor</code></p></li><li><p><code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=</code>、<code>0xffffffff</code>、<code>0xffff</code></p></li></ul><p>定位到 CryptoJS 后，观察加密方法，比如 AES 就是 <code>CryptoJS.AES.encrypt</code>，DES 就是 <code>CryptoJS.DES.encrypt</code>，3DES 就是 <code>CryptoJS.TripleDES.encrypt</code>，注意他的 iv、mode、padding，拿下来就可以本地复现了。</p><h3 id="SM-系列">SM 系列</h3><p>SM 代表商密，即商业密码，是我国发布的一系列国产加密算法，SM 系列包括：SM1、SM2、SM3 、SM4、SM7、SM9，其中 SM1 和 SM7 的算法不公开，SM 系列算法在我国一些 gov 网站上有应用，有关国产加密算法前期文章有介绍：<a href="https://www.itbob.cn/article/041/">《认识 SM1/SM2/SM3/SM4/SM7/SM9/ZUC 国密算法》</a>，本文不再赘述。</p><p>在 SM 的 JavaScript 代码中一般会存在以下关键字，可以通过搜索关键字定位：</p><ul><li><code>SM2</code>、<code>SM3</code>、<code>SM4</code></li><li><code>FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF</code></li><li><code>FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC</code></li><li><code>28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93</code></li><li><code>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789</code></li><li><code>getPublicKeyFromPrivateKey</code>、<code>doEncrypt</code>、<code>doDecrypt</code>、<code>doSignature</code></li></ul><h2 id="混淆系列">混淆系列</h2><h3 id="Obfuscator">Obfuscator</h3><p>Obfuscator 就是混淆的意思，简称 OB 混淆，实战可参考以前的文章：<a href="https://itrhx.blog.csdn.net/article/details/121719631">【JS 逆向百例】W店UA，OB反混淆，抓包替换CORS跨域错误分析</a>，OB 混淆具有以下特征：</p><ul><li>一般由一个大数组或者含有大数组的函数、一个自执行函数、解密函数和加密后的函数四部分组成；</li><li>函数名和变量名通常以 <code>_0x</code> 或者 <code>0x</code> 开头，后接 1~6 位数字或字母组合；</li><li>自执行函数，进行移位操作，有明显的 push、shift 关键字；</li></ul><p>一段正常的代码如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hi</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello World!&quot;</span>);&#125;hi();</code></pre><p>经过 OB 混淆后的结果：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x3f26</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> _0x2dad75 = [<span class="hljs-string">&#x27;5881925kTCKCP&#x27;</span>, <span class="hljs-string">&#x27;Hello\x20World!&#x27;</span>, <span class="hljs-string">&#x27;600mDvfGa&#x27;</span>, <span class="hljs-string">&#x27;699564jYNxbu&#x27;</span>, <span class="hljs-string">&#x27;1083271cEvuvT&#x27;</span>, <span class="hljs-string">&#x27;log&#x27;</span>, <span class="hljs-string">&#x27;18sKjcFY&#x27;</span>, <span class="hljs-string">&#x27;214857eMgFSU&#x27;</span>, <span class="hljs-string">&#x27;77856FUKcuE&#x27;</span>, <span class="hljs-string">&#x27;736425OzpdFI&#x27;</span>, <span class="hljs-string">&#x27;737172JqcGMg&#x27;</span>];    _0x3f26 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> _0x2dad75;    &#125;;    <span class="hljs-keyword">return</span> _0x3f26();&#125;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_0x307c88, _0x4f8223</span>) </span>&#123;    <span class="hljs-keyword">var</span> _0x32807d = _0x1fe9, _0x330c58 = _0x307c88();    <span class="hljs-keyword">while</span> (!![]) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">var</span> _0x5d6354 = <span class="hljs-built_in">parseInt</span>(_0x32807d(<span class="hljs-number">0x6f</span>)) / <span class="hljs-number">0x1</span> + <span class="hljs-built_in">parseInt</span>(_0x32807d(<span class="hljs-number">0x6e</span>)) / <span class="hljs-number">0x2</span> + <span class="hljs-built_in">parseInt</span>(_0x32807d(<span class="hljs-number">0x70</span>)) / <span class="hljs-number">0x3</span> + -<span class="hljs-built_in">parseInt</span>(_0x32807d(<span class="hljs-number">0x69</span>)) / <span class="hljs-number">0x4</span> + <span class="hljs-built_in">parseInt</span>(_0x32807d(<span class="hljs-number">0x71</span>)) / <span class="hljs-number">0x5</span> + <span class="hljs-built_in">parseInt</span>(_0x32807d(<span class="hljs-number">0x6c</span>)) / <span class="hljs-number">0x6</span> * (<span class="hljs-built_in">parseInt</span>(_0x32807d(<span class="hljs-number">0x6a</span>)) / <span class="hljs-number">0x7</span>) + -<span class="hljs-built_in">parseInt</span>(_0x32807d(<span class="hljs-number">0x73</span>)) / <span class="hljs-number">0x8</span> * (<span class="hljs-built_in">parseInt</span>(_0x32807d(<span class="hljs-number">0x6d</span>)) / <span class="hljs-number">0x9</span>);            <span class="hljs-keyword">if</span> (_0x5d6354 === _0x4f8223) <span class="hljs-keyword">break</span>; <span class="hljs-keyword">else</span> _0x330c58[<span class="hljs-string">&#x27;push&#x27;</span>](_0x330c58[<span class="hljs-string">&#x27;shift&#x27;</span>]());        &#125; <span class="hljs-keyword">catch</span> (_0x3f18e4) &#123;            _0x330c58[<span class="hljs-string">&#x27;push&#x27;</span>](_0x330c58[<span class="hljs-string">&#x27;shift&#x27;</span>]());        &#125;    &#125;&#125;(_0x3f26, <span class="hljs-number">0xaa023</span>));<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x1fe9</span>(<span class="hljs-params">_0xa907e7, _0x410a46</span>) </span>&#123;    <span class="hljs-keyword">var</span> _0x3f261f = _0x3f26();    <span class="hljs-keyword">return</span> _0x1fe9 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_0x1fe950, _0x5a08da</span>) </span>&#123;        _0x1fe950 = _0x1fe950 - <span class="hljs-number">0x69</span>;        <span class="hljs-keyword">var</span> _0x82a06 = _0x3f261f[_0x1fe950];        <span class="hljs-keyword">return</span> _0x82a06;    &#125;, _0x1fe9(_0xa907e7, _0x410a46);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hi</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> _0x12a222 = _0x1fe9;    <span class="hljs-built_in">console</span>[_0x12a222(<span class="hljs-number">0x6b</span>)](_0x12a222(<span class="hljs-number">0x72</span>));&#125;hi();</code></pre><h3 id="JJEncode">JJEncode</h3><p>JJEncode、AAEncode、JSFuck 都是同一个作者，实战可参考以前的文章：<a href="https://itrhx.blog.csdn.net/article/details/121920783">【JS 逆向百例】网洛者反爬练习平台第二题：JJEncode 加密</a>，JJEncode 具有以下特征：</p><ul><li>大量 <code>$</code>、<code>_</code> 符号，大量重复的自定义变量；</li><li>仅由 18 个符号组成：<code>[]()!+,\&quot;$.:;_&#123;&#125;~=</code></li></ul><p>正常的一段 JS 代码：</p><pre><code class="hljs javascript">alert(<span class="hljs-string">&quot;Hello, JavaScript&quot;</span> )</code></pre><p>经过 JJEncode 混淆（自定义变量名为 $）之后的代码：</p><pre><code class="hljs javascript">$=~[];$=&#123;<span class="hljs-attr">___</span>:++$,<span class="hljs-attr">$$$$</span>:(![]+<span class="hljs-string">&quot;&quot;</span>)[$],<span class="hljs-attr">__$</span>:++$,<span class="hljs-attr">$_$_</span>:(![]+<span class="hljs-string">&quot;&quot;</span>)[$],<span class="hljs-attr">_$_</span>:++$,<span class="hljs-attr">$_$$</span>:(&#123;&#125;+<span class="hljs-string">&quot;&quot;</span>)[$],<span class="hljs-attr">$$_$</span>:($[$]+<span class="hljs-string">&quot;&quot;</span>)[$],<span class="hljs-attr">_$$</span>:++$,<span class="hljs-attr">$$$_</span>:(!<span class="hljs-string">&quot;&quot;</span>+<span class="hljs-string">&quot;&quot;</span>)[$],<span class="hljs-attr">$__</span>:++$,<span class="hljs-attr">$_$</span>:++$,<span class="hljs-attr">$$__</span>:(&#123;&#125;+<span class="hljs-string">&quot;&quot;</span>)[$],<span class="hljs-attr">$$_</span>:++$,<span class="hljs-attr">$$$</span>:++$,<span class="hljs-attr">$___</span>:++$,<span class="hljs-attr">$__$</span>:++$&#125;;$.$_=($.$_=$+<span class="hljs-string">&quot;&quot;</span>)[$.$_$]+($._$=$.$_[$.__$])+($.$$=($.$+<span class="hljs-string">&quot;&quot;</span>)[$.__$])+((!$)+<span class="hljs-string">&quot;&quot;</span>)[$._$$]+($.__=$.$_[$.$$_])+($.$=(!<span class="hljs-string">&quot;&quot;</span>+<span class="hljs-string">&quot;&quot;</span>)[$.__$])+($._=(!<span class="hljs-string">&quot;&quot;</span>+<span class="hljs-string">&quot;&quot;</span>)[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$=$.$+(!<span class="hljs-string">&quot;&quot;</span>+<span class="hljs-string">&quot;&quot;</span>)[$._$$]+$.__+$._+$.$+$.$$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$$+<span class="hljs-string">&quot;\&quot;&quot;</span>+$.$_$_+(![]+<span class="hljs-string">&quot;&quot;</span>)[$._$_]+$.$$$_+<span class="hljs-string">&quot;\\&quot;</span>+$.__$+$.$$_+$._$_+$.__+<span class="hljs-string">&quot;(\\\&quot;\\&quot;</span>+$.__$+$.__$+$.___+$.$$$_+(![]+<span class="hljs-string">&quot;&quot;</span>)[$._$_]+(![]+<span class="hljs-string">&quot;&quot;</span>)[$._$_]+$._$+<span class="hljs-string">&quot;,\\&quot;</span>+$.$__+$.___+<span class="hljs-string">&quot;\\&quot;</span>+$.__$+$.__$+$._$_+$.$_$_+<span class="hljs-string">&quot;\\&quot;</span>+$.__$+$.$$_+$.$$_+$.$_$_+<span class="hljs-string">&quot;\\&quot;</span>+$.__$+$._$_+$._$$+$.$$__+<span class="hljs-string">&quot;\\&quot;</span>+$.__$+$.$$_+$._$_+<span class="hljs-string">&quot;\\&quot;</span>+$.__$+$.$_$+$.__$+<span class="hljs-string">&quot;\\&quot;</span>+$.__$+$.$$_+$.___+$.__+<span class="hljs-string">&quot;\\\&quot;\\&quot;</span>+$.$__+$.___+<span class="hljs-string">&quot;)&quot;</span>+<span class="hljs-string">&quot;\&quot;&quot;</span>)())();</code></pre><h3 id="AAEncode">AAEncode</h3><p>JJEncode、AAEncode、JSFuck 都是同一个作者，实战可参考以前的文章：<a href="https://itrhx.blog.csdn.net/article/details/121920864">【JS 逆向百例】网洛者反爬练习平台第三题：AAEncode 加密</a>，AAEncode 具有以下特征：</p><ul><li>仅由日式表情符号组成</li></ul><p>正常的一段 JS 代码：</p><pre><code class="hljs javascript">alert(<span class="hljs-string">&quot;Hello, JavaScript&quot;</span>)</code></pre><p>经过 AAEncode 混淆之后的代码：</p><pre><code class="hljs javascript">ﾟωﾟﾉ= <span class="hljs-regexp">/｀ｍ´）ﾉ ~┻━┻   /</span><span class="hljs-regexp">/*´∇｀*/</span> [<span class="hljs-string">&#x27;_&#x27;</span>]; o=(ﾟｰﾟ)  =_=<span class="hljs-number">3</span>; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)=&#123;ﾟΘﾟ: <span class="hljs-string">&#x27;_&#x27;</span> ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ <span class="hljs-string">&#x27;_&#x27;</span>)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>)[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>) [c^_^o];(ﾟДﾟ) [<span class="hljs-string">&#x27;c&#x27;</span>] = ((ﾟДﾟ)+<span class="hljs-string">&#x27;_&#x27;</span>) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [<span class="hljs-string">&#x27;o&#x27;</span>] = ((ﾟДﾟ)+<span class="hljs-string">&#x27;_&#x27;</span>) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [<span class="hljs-string">&#x27;c&#x27;</span>]+(ﾟДﾟ) [<span class="hljs-string">&#x27;o&#x27;</span>]+(ﾟωﾟﾉ +<span class="hljs-string">&#x27;_&#x27;</span>)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>) [ﾟｰﾟ] + ((ﾟДﾟ) +<span class="hljs-string">&#x27;_&#x27;</span>) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>) [ﾟΘﾟ]+((ﾟｰﾟ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [<span class="hljs-string">&#x27;c&#x27;</span>]+((ﾟДﾟ)+<span class="hljs-string">&#x27;_&#x27;</span>) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [<span class="hljs-string">&#x27;o&#x27;</span>]+((ﾟｰﾟ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>) [ﾟΘﾟ];(ﾟДﾟ) [<span class="hljs-string">&#x27;_&#x27;</span>] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+<span class="hljs-string">&#x27;_&#x27;</span>) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>) [ﾟΘﾟ]+ (ﾟωﾟﾉ +<span class="hljs-string">&#x27;_&#x27;</span>) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=<span class="hljs-string">&#x27;\\&#x27;</span>; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +<span class="hljs-string">&#x27;_&#x27;</span>)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=<span class="hljs-string">&#x27;\&quot;&#x27;</span>;(ﾟДﾟ) [<span class="hljs-string">&#x27;_&#x27;</span>] ( (ﾟДﾟ) [<span class="hljs-string">&#x27;_&#x27;</span>] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (<span class="hljs-string">&#x27;_&#x27;</span>);</code></pre><h3 id="JSFuck">JSFuck</h3><p>JJEncode、AAEncode、JSFuck 都是同一个作者，实战可参考以前的文章：<a href="https://itrhx.blog.csdn.net/article/details/122057377">【JS 逆向百例】网洛者反爬练习平台第四题：JSFuck 加密</a>，JSFuck 具有以下特征：</p><ul><li>仅由 6 个符号组成：<code>[]()!+</code></li></ul><p>正常的一段 JS 代码：</p><pre><code class="hljs javascript">alert(<span class="hljs-number">1</span>)</code></pre><p>经过 JSFuck 混淆之后的代码类似于：</p><pre><code class="hljs javascript">[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(+(!+[]+!+[]+!+[]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]])+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]])()((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[+!+[]+[!+[]+!+[]+!+[]]]+[+!+[]]+([+[]]+![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[!+[]+!+[]+[+[]]])</code></pre><h3 id="Jother">Jother</h3><p>Jother 混淆和 JSFuck 有点儿类似，唯一的区别就是密文比 JSFuck 多了 <code>&#123;&#125;</code>，其解密方式和 JSFuck 是一样的，Jother 混淆现在不太常见了，也很难找到在线混淆之类的工具了，原作者有个在线页面也关闭了，不过仍然可以了解一下，Jother 混淆具有以下特征：</p><ul><li>仅由 8 个符号组成：<code>[]()!+&#123;&#125;</code></li></ul><p>正常的一段代码：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">anonymous</span>(<span class="hljs-params"></span></span><span class="hljs-params"><span class="hljs-function"></span>) </span>&#123;<span class="hljs-keyword">return</span> location&#125;</code></pre><p>经过 Jother 混淆之后的代码类似于：</p><pre><code class="hljs javascript">[][(![]+[])[!![]+!![]+!![]]+(&#123;&#125;+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]]+(&#123;&#125;+[])[+!![]]+(&#123;&#125;[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+(&#123;&#125;[[]]+[])[+[]]+(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+(&#123;&#125;+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(&#123;&#125;[[]]+[])[+[]]+(!![]+[])[+!![]]+(&#123;&#125;[[]]+[])[+!![]]+(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+(&#123;&#125;+[])[+!![]]+(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+(&#123;&#125;[[]]+[])[!![]+!![]+!![]+!![]+!![]]+(&#123;&#125;+[])[+!![]]+(&#123;&#125;[[]]+[])[+!![]])()</code></pre><h3 id="Brainfuck">Brainfuck</h3><p>Brainfuck 实际上是一种极小化的计算机语言，又称为 BF 语言，该语言以其极简主义着称，仅包含八个简单的命令、一个数据指针和一个指令指针，这种语言在爬虫领域也可以是一种反爬手段，可以视为一种混淆方式，虽然不常见🤔，这里给一个在线体验的网址：<a href="https://copy.sh/brainfuck/text.html">https://copy.sh/brainfuck/text.html</a> ，感兴趣的同志可以深入研究一下，Brainfuck 具有以下特征：</p><ul><li>仅由 <code>&lt;&gt;+-.[]</code> 组成；</li><li>大量的 <code>+-</code> 符号。</li></ul><p>正常的一段代码：</p><pre><code class="hljs javascript">alert(<span class="hljs-string">&quot;Hello, Brainfuck&quot;</span>)</code></pre><p>经过 Brainfuck 混淆之后的代码类似于：</p><pre><code class="hljs javascript">--[-----&gt;+&lt;]&gt;-----.+++++++++++.-------.+++++++++++++.++.+[---&gt;+&lt;]&gt;+.------.++[-&gt;++&lt;]&gt;.-[-&gt;+++++&lt;]&gt;++.+++++++..+++.[-&gt;+++++&lt;]&gt;+.------------.+[-&gt;++&lt;]&gt;.---[-----&gt;+&lt;]&gt;-.+++[-&gt;+++&lt;]&gt;++.++++++++.+++++.--------.-[---&gt;+&lt;]&gt;--.+[-&gt;+++&lt;]&gt;+.++++++++.+[++&gt;---&lt;]&gt;.+++++++.</code></pre><h3 id="Ook">Ook!</h3><p>Ook! 和 Brainfuck 的原理都是类似的，只不过符号有差异，同样的，这种语言在爬虫领域也可以是一种反爬手段，可以视为一种混淆方式，虽然不常见🤔，在线体验的网址：<a href="https://www.splitbrain.org/services/ook">https://www.splitbrain.org/services/ook</a> ，Ook! 具有以下特征：</p><ul><li>完整 Ook!：仅由 3 种符号组成 <code>Ook.</code>、<code>Ook?</code>、<code>Ook!</code></li><li>Short Ook!：仅由 3 种符号组成 <code>.!?</code></li></ul><p>正常的一段代码：</p><pre><code class="hljs javascript">alert(<span class="hljs-string">&quot;Hello, Ook!&quot;</span>)</code></pre><p>经过 Ook! 混淆之后的代码类似于：</p><pre><code class="hljs javascript">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook.</code></pre><h3 id="Trivial-brainfuck-substitution">Trivial brainfuck substitution</h3><p>Trivial brainfuck substitution 不是一种单一的编程语言，而是一大类编程语言，成员超过 20 个，前面提到的 Brainfuck、Ook! 都是其中的一员，在爬虫领域中，说实话这种稀奇古怪的混淆其实并不常见，但是在一些 CTF 中有可能会出现，作为爬虫工程师也可以了解了解😎，具体可以参考：<a href="https://esolangs.org/wiki/Trivial_brainfuck_substitution">https://esolangs.org/wiki/Trivial_brainfuck_substitution</a></p><h2 id="其他">其他</h2><h3 id="恺撒密码">恺撒密码</h3><p>恺撒密码（Caesar cipher）又称为恺撒加密、恺撒变换、变换加密，它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是 3 的时候，所有的字母 A 将被替换成 D，B 变成 E，以此类推。这个加密方法是以罗马共和时期恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。</p><p>根据偏移量的不同，还存在若干特定的恺撒密码名称：偏移量为10：Avocat（A→K）；偏移量为13：ROT13；偏移量为-5：Cassis (K 6)；偏移量为-6：Cassette (K 7)</p><p>示例（偏移量 3）：</p><ul><li><p>明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ</p></li><li><p>密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC</p></li></ul><h3 id="栅栏密码">栅栏密码</h3><p>栅栏密码就是把要加密的明文分成 N 个一组，然后把每组的第 1 个字连起来，形成一段无规律的话。栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多，一般不超过 30 个。</p><p>示例：明文为 THE LONGEST DAY MUST HAVE AN END。加密时，把将要传递的信息中的字母交替排成上下两行：</p><p>T E O G S D Y U T A E N N</p><p>H L N E T A M S H V A E D</p><p>将下面一行字母排在上面一行的后边组合成密文：</p><p>TEOGSDYUTAENN HLNETAMSHVAED</p><p>栅栏密码还有一种变种，称为栅栏密码 W 型，它会先把明文类似 W 形状进行排列，然后再按栏目顺序 1-N，取每一栏的所有字符值，组成加密后密文，比如字符串 123456789，采用栏目数为 3 时，明文将采用如下排列：<br>1—5—9<br>-2-4-6-8-<br>–3—7–<br>取每一栏所有字符串，组成加密后密文：159246837</p><h3 id="猪圈密码">猪圈密码</h3><p>猪圈密码也称为朱高密码、共济会暗号、共济会密码或共济会员密码，是一种以格子为基础的简单替代式密码。只能对字母加解密并且符号无法复制，粘贴后会直接显示明文，即使使用符号，也不会影响密码分析，亦可用在其它替代式的方法。曾经是美国内战时盟军使用的密码，目前仅在密码教学、各种竞赛中使用。</p><p><img src="https://cdn.itbob.cn/img/article/045/01.gif" alt="01.gif"></p><h3 id="摩斯密码">摩斯密码</h3><p>摩斯密码（Morse code），又称为摩尔斯电码、摩斯电码，是一种时通时断的信号代码，这种信号代码通过不同的排列顺序来表达不同的英文字母、数字和标点符号等。</p><p>26个字母的摩斯密码表</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">摩斯码</th><th style="text-align:left">字符</th><th style="text-align:left">摩斯码</th><th>字符</th><th>摩斯码</th><th>字符</th><th>摩斯码</th></tr></thead><tbody><tr><td style="text-align:left">A</td><td style="text-align:left"><code>．━</code></td><td style="text-align:left">B</td><td style="text-align:left"><code>━ ．．．</code></td><td>C</td><td><code>━ ．━ ．</code></td><td>D</td><td><code>━ ．．</code></td></tr><tr><td style="text-align:left">E</td><td style="text-align:left"><code>．</code></td><td style="text-align:left">F</td><td style="text-align:left"><code>．．━ ．</code></td><td>G</td><td><code>━ ━ ．</code></td><td>H</td><td><code>．．．．</code></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left"><code>．．</code></td><td style="text-align:left">J</td><td style="text-align:left"><code>．━ ━ ━</code></td><td>K</td><td><code>━ ．━</code></td><td>L</td><td><code>．━ ．．</code></td></tr><tr><td style="text-align:left">M</td><td style="text-align:left"><code>━ ━</code></td><td style="text-align:left">N</td><td style="text-align:left"><code>━ ．</code></td><td>O</td><td><code>━ ━ ━</code></td><td>P</td><td><code>．━ ━ ．</code></td></tr><tr><td style="text-align:left">Q</td><td style="text-align:left"><code>━ ━ ．━</code></td><td style="text-align:left">R</td><td style="text-align:left"><code>．━ ．</code></td><td>S</td><td><code>．．．</code></td><td>T</td><td><code>━</code></td></tr><tr><td style="text-align:left">U</td><td style="text-align:left"><code>．．━</code></td><td style="text-align:left">V</td><td style="text-align:left"><code>．．．━</code></td><td>W</td><td><code>．━ ━</code></td><td>X</td><td><code>━ ．．━</code></td></tr><tr><td style="text-align:left">Y</td><td style="text-align:left"><code>━ ．━ ━</code></td><td style="text-align:left">Z</td><td style="text-align:left"><code>━ ━ ．．</code></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>10个数字的摩斯密码表</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">摩斯码</th><th style="text-align:left">字符</th><th style="text-align:left">摩斯码</th><th>字符</th><th>摩斯码</th><th>字符</th><th>摩斯码</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left"><code>━ ━ ━ ━ ━</code></td><td style="text-align:left">1</td><td style="text-align:left"><code>．━ ━ ━ ━</code></td><td>2</td><td><code>．．━ ━ ━</code></td><td>3</td><td><code>．．．━ ━</code></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><code>．．．．━</code></td><td style="text-align:left">5</td><td style="text-align:left"><code>．．．．．</code></td><td>6</td><td><code>━ ．．．．</code></td><td>7</td><td><code>━ ━ ．．．</code></td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><code>━ ━ ━ ．．</code></td><td style="text-align:left">9</td><td style="text-align:left"><code>━ ━ ━ ━ ．</code></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>标点符号的摩斯密码表</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">摩斯码</th><th style="text-align:left">字符</th><th style="text-align:left">摩斯码</th><th>字符</th><th>摩斯码</th><th>字符</th><th>摩斯码</th></tr></thead><tbody><tr><td style="text-align:left">.</td><td style="text-align:left"><code>．━ ．━ ．━</code></td><td style="text-align:left">:</td><td style="text-align:left"><code>━ ━ ━ ．．．</code></td><td>,</td><td><code>━ ━ ．．━ ━</code></td><td>;</td><td><code>━ ．━ ．━ ．</code></td></tr><tr><td style="text-align:left">?</td><td style="text-align:left"><code>．．━ ━ ．．</code></td><td style="text-align:left">=</td><td style="text-align:left"><code>━ ．．．━</code></td><td>’</td><td><code>．━ ━ ━ ━ ．</code></td><td>/</td><td><code>━ ．．━ ．</code></td></tr><tr><td style="text-align:left">!</td><td style="text-align:left"><code>━ ．━ ．━ ━</code></td><td style="text-align:left">━</td><td style="text-align:left"><code>━ ．．．．━</code></td><td>_</td><td><code>．．━ ━ ．━</code></td><td>&quot;</td><td><code>．━ ．．━ ．</code></td></tr><tr><td style="text-align:left">(</td><td style="text-align:left"><code>━ ．━ ━ ．</code></td><td style="text-align:left">)</td><td style="text-align:left"><code>━ ．━ ━ ．━</code></td><td>$</td><td><code>．．．━ ．．━</code></td><td>&amp;</td><td><code>． ．．．</code></td></tr><tr><td style="text-align:left">@</td><td style="text-align:left"><code>．━ ━ ．━ ．</code></td><td style="text-align:left"></td><td style="text-align:left"></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="培根密码">培根密码</h3><p>培根密码，又名倍康尼密码（Bacon’s cipher）是由法兰西斯·培根发明的一种隐写术，它是一种本质上用二进制数设计的，没有用通常的0和1来表示，而是采用a和b，看到一串的a和b，并且五个一组，那么就是培根加密了。</p><p>第一种方式：</p><table><thead><tr><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th></tr></thead><tbody><tr><td>A</td><td>aaaaa</td><td>H</td><td>aabbb</td><td>O</td><td>abbba</td><td>V</td><td>babab</td></tr><tr><td>B</td><td>aaaab</td><td>I</td><td>abaaa</td><td>P</td><td>abbbb</td><td>W</td><td>babba</td></tr><tr><td>C</td><td>aaaba</td><td>J</td><td>abaab</td><td>Q</td><td>baaaa</td><td>X</td><td>babbb</td></tr><tr><td>D</td><td>aaabb</td><td>K</td><td>ababa</td><td>R</td><td>baaab</td><td>Y</td><td>bbaaa</td></tr><tr><td>E</td><td>aabaa</td><td>L</td><td>ababb</td><td>S</td><td>baaba</td><td>Z</td><td>bbaab</td></tr><tr><td>F</td><td>aabab</td><td>M</td><td>abbaa</td><td>T</td><td>baabb</td><td></td><td></td></tr><tr><td>G</td><td>aabba</td><td>N</td><td>abbab</td><td>U</td><td>babaa</td><td></td><td></td></tr></tbody></table><p>第二种方式：</p><table><thead><tr><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th></tr></thead><tbody><tr><td>a</td><td>AAAAA</td><td>h</td><td>AABBB</td><td>p</td><td>ABBBA</td><td>x</td><td>BABAB</td></tr><tr><td>b</td><td>AAAAB</td><td>i-j</td><td>ABAAA</td><td>q</td><td>ABBBB</td><td>y</td><td>BABBA</td></tr><tr><td>c</td><td>AAABA</td><td>k</td><td>ABAAB</td><td>r</td><td>BAAAA</td><td>z</td><td>BABBB</td></tr><tr><td>d</td><td>AAABB</td><td>l</td><td>ABABA</td><td>s</td><td>BAAAB</td><td></td><td></td></tr><tr><td>e</td><td>AABAA</td><td>m</td><td>ABABB</td><td>t</td><td>BAABA</td><td></td><td></td></tr><tr><td>f</td><td>AABAB</td><td>n</td><td>ABBAA</td><td>u-v</td><td>BAABB</td><td></td><td></td></tr><tr><td>g</td><td>AABBA</td><td>o</td><td>ABBAB</td><td>w</td><td>BABAA</td><td></td><td></td></tr></tbody></table><p>示例：</p><ul><li>明文：kuaidaili</li><li>密文：ABABABABAAAAAAAABAAAAAABBAAAAAABAAAABABBABAAA</li></ul><h3 id="维吉尼亚密码">维吉尼亚密码</h3><p>维吉尼亚密码是在凯撒密码基础上产生的一种加密方法，它将凯撒密码的全部25种位移排序为一张表，与原字母序列共同组成26行及26列的字母表。另外，维吉尼亚密码必须有一个密钥，这个密钥由字母组成，最少一个，最多可与明文字母数量相等。维吉尼亚密码表如下：</p><p><img src="https://cdn.itbob.cn/img/article/045/02.png" alt="02.png"></p><p>示例：</p><ul><li>明文：I’ve got it.</li><li>密钥：ok</li><li>密文：W’fs qcd wd.</li></ul><p>首先，密钥长度需要与明文长度相同，如果少于明文长度，则重复拼接直到相同。示例的明文长度为8个字母（非字母均被忽略），密钥会被程序补全为 <code>okokokok</code>，然后根据维吉尼亚密码表进行加密：明文第一个字母是 <code>I</code>，密钥第一个字母是 <code>o</code>，在表格中找到 <code>I</code> 列与 <code>o</code> 行相交点，字母 <code>W</code> 就是密文第一个字母，同理，<code>v</code> 列与 <code>k</code> 行交点字母是 <code>F</code>，<code>e</code> 列与 <code>o</code> 行交点字母是 <code>S</code>，以此类推。注意：维吉尼亚密码只对字母进行加密，不区分大小写，若文本中出现非字母字符会原样保留，如果输入多行文本，每行是单独加密的。</p><h3 id="与佛论禅">与佛论禅</h3><p>字符串转换后，是一些佛语，在线体验：<a href="https://keyfc.net/bbs/tools/tudoucode.aspx">https://keyfc.net/bbs/tools/tudoucode.aspx</a></p><p>示例：</p><ul><li>明文：爬虫</li><li>密文：佛曰：俱曳栗羅。諳故大多罰顛冥有諳姪帝罰知俱薩心俱智伊</li></ul><h3 id="当铺密码">当铺密码</h3><p>当铺密码在 CTF 比赛题目中出现过。该加密算法是根据当前汉字有多少笔画出头，对应的明文就是数字几。</p><p>示例：</p><ul><li>明文：王夫 井工 夫口 由中人 井中 夫夫 由中大</li><li>密文：67 84 70 123 82 77 125</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/encryption_algorithm.png&quot; alt=&quot;encryption_algorithm&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;爬虫工程师在做加密参数逆向的时</summary>
      
    
    
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="算法" scheme="https://www.itbob.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>某空气质量监测平台无限 debugger 以及数据动态加密分析</title>
    <link href="https://www.itbob.cn/article/044/"/>
    <id>https://www.itbob.cn/article/044/</id>
    <published>2022-01-10T09:30:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/javascript_reverse.png" alt="javascript_reverse"></p><h2 id="声明">声明</h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2 id="逆向目标">逆向目标</h2><ul><li>目标：某空气质量监测平台无限 debugger 以及请求数据、返回数据动态加密、解密</li><li>主页：<code>aHR0cHM6Ly93d3cuYXFpc3R1ZHkuY24v</code></li><li>接口：<code>aHR0cHM6Ly93d3cuYXFpc3R1ZHkuY24vYXBpbmV3L2FxaXN0dWR5YXBpLnBocA==</code></li></ul><h2 id="写在前面">写在前面</h2><p>这个站点更新频率很高，在我之前也已经有很多博主写了该站点的分析文章，近期有读者问请求数据的加密和返回数据的解密，发现其加解密 JS 变成了动态的，以前的那些文章提到的解决思路不太行了，但整体上来说也不是很难，只不过处理起来比较麻烦一点，还有一些小细节需要注意。</p><p>在网站的“关于系统”里可以看到，这个站貌似是个人开发者在维护，最早在2013年就有了，在友情赞助列表里，可以看到大多数都是一些环境、测绘、公共卫生相关的大学专业、研究院人员，可以猜测到这些数据对于他们的研究是非常有帮助的，再加上反爬更新频繁，可以看出站长饱受爬虫之苦，咱们也不想给站长添加负担，毕竟这种站点咱们应该支持，让他长久维护下去，<strong>所以本期只分析逻辑和少部分代码，就不放完整代码了，如果有相关专业人士确实需要抓取数据做研究的，可以通过邮件联系我。</strong></p><h2 id="绕过无限-debugger">绕过无限 debugger</h2><p>右键 F12，会提示右键被禁用，不要紧，使用快捷键 <code>Ctrl+Shift+i</code> 或者浏览器右上角，更多工具，开发者工具，照样能打开。</p><p><img src="https://cdn.itbob.cn/img/article/044/01.png" alt="01.png"></p><h3 id="方法一">方法一</h3><p>打开控制台后会进入第一个无限 debugger，往上跟一个栈，可以看到一个 try-catch 语句，你下断点会发现他会一直走 catch，调用 <code>setTimeout()</code> 方法，该方法用于在指定的毫秒数后调用函数或计算表达式，注意上面，是将 debugger 传递给了构造方法 constructor，所以这里我们有两种方法过掉 debugger，Hook 掉 constructor 或 setTimeout 都可以。</p><p><img src="https://cdn.itbob.cn/img/article/044/02.png" alt="02.png"></p><pre><code class="hljs javascript"><span class="hljs-comment">// 两种 Hook 任选一中</span><span class="hljs-comment">// Hook 构造方法</span><span class="hljs-built_in">Function</span>.prototype.constructor_ = <span class="hljs-built_in">Function</span>.prototype.constructor;<span class="hljs-built_in">Function</span>.prototype.constructor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-keyword">if</span>(a == <span class="hljs-string">&quot;debugger&quot;</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;&#125;;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Function</span>.prototype.constructor_(a);&#125;;<span class="hljs-comment">// Hook setTimeout</span><span class="hljs-keyword">var</span> setTimeout_ = <span class="hljs-built_in">setTimeout</span><span class="hljs-keyword">var</span> <span class="hljs-built_in">setTimeout</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">func, time</span>)</span>&#123;    <span class="hljs-keyword">if</span> (func == txsdefwsw)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;    &#125;    <span class="hljs-keyword">return</span> setTimeout_(func, time)&#125;</code></pre><p>然后就来到了第二个无限 debugger，同样跟栈，发现有个 setInterval 定时器和构造方法 constructor，类似的，我们 Hook 掉 constructor 或 setInterval 都可以。注意：定时器这里还检测了窗口高宽，即便是你过了 constructor 或 setInterval，如果不把开发者工具单独拿出来也是不行的，会不断输出“检测到非法调试”。</p><p><img src="https://cdn.itbob.cn/img/article/044/03.png" alt="03.png"></p><pre><code class="hljs javascript"><span class="hljs-comment">// Hook setInterval</span><span class="hljs-keyword">var</span> setInterval_ = <span class="hljs-built_in">setInterval</span><span class="hljs-built_in">setInterval</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">func, time</span>)</span>&#123;    <span class="hljs-keyword">if</span> (time == <span class="hljs-number">2000</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;    &#125;    <span class="hljs-keyword">return</span> setInterval_(func, time)&#125;</code></pre><p>我们观察到，其实这两个无限 debugger 都可以 Hook 构造方法来过掉，所以直接 Fiddler 注入该 Hook 构造方法的代码即可：</p><p><img src="https://cdn.itbob.cn/img/article/044/04.png" alt="04.png"></p><h3 id="方法二">方法二</h3><p>在我们遇到第二个无限 debugger 的时候，还可以直接跟栈到一个 city_realtime.php 的页面，里面有两个 eval 语句，执行第一个 eval 里面的语句你就会发现正是前面我们在 VM 虚拟机里面看到的 debugger 代码，所以这里理论上可以直接替换掉这个页面，去掉 eval 语句，就不会有无限 debugger 了，但是先告诉你，现在不行了，因为里面有加载了某个 JS，这个 JS 在后面加密解密中会用到，但是这个 JS 是动态的，每10分钟就会改变，我们后面还要通过此页面来获取动态的 JS，所以是不能替换的！这里只是提一下这个思路！</p><p><img src="https://cdn.itbob.cn/img/article/044/05.png" alt="05.png"></p><p><img src="https://cdn.itbob.cn/img/article/044/06.png" alt="06.png"></p><h3 id="方法三">方法三</h3><p>当然，这里还有一种最简单的方法，直接右键选择 Never pause here，永不在此处断下即可，同样还需要把开发者工具窗口单独拿出来，不然会一直输出“检测到非法调试”。</p><p><img src="https://cdn.itbob.cn/img/article/044/07.png" alt="07.png"></p><h2 id="抓包分析">抓包分析</h2><p>我们在实时监控页面，顺便点击查询一个城市，可以看到请求的 Form Data 和返回的数据都是加密的，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/044/08.png" alt="08.png"></p><h2 id="加密入口">加密入口</h2><p>由于是 XHR，所以我们直接跟栈，很容易找到加密的位置：</p><p><img src="https://cdn.itbob.cn/img/article/044/09.png" alt="09.png"></p><p><img src="https://cdn.itbob.cn/img/article/044/10.png" alt="10.png"></p><p>可以看到传递的 data 键值对：<code>&#123;hXM8NDFHN: p7crXYR&#125;</code>，键在这个 JS 里是写死的，值是通过一个方法 <code>pU14VhqrofroULds()</code> 得到的，这个方法需要传递两个参数，第一个是定值 GETDATA，第二个就是城市名称，我们再跟进看看这个方法是啥：</p><p><img src="https://cdn.itbob.cn/img/article/044/11.png" alt="11.png"></p><p>一些 appId、时间戳、城市等参数，做了一些 MD5、base64 的操作，返回的 param 就是我们要的值了。看起来不难，我们再找找返回的加密数据是如何解密的，我们注意到 ajax 请求有个 success 关键字，我们即便是不懂 JS 逻辑，也可以猜到应该是请求成功后的处理操作吧，如下图所示：传进来的 dzJMI 就是返回的加密的数据，经过 <code>db0HpCYIy97HkHS7RkhUn()</code> 方法后，就解密成功了：</p><p><img src="https://cdn.itbob.cn/img/article/044/12.png" alt="12.png"></p><p>跟进 <code>db0HpCYIy97HkHS7RkhUn()</code> 方法，可以看到是 AES+DES+BASE64 解密，传入的密钥 key 和偏移量 iv 都在头部有定义：</p><p><img src="https://cdn.itbob.cn/img/article/044/13.png" alt="13.png"></p><p><img src="https://cdn.itbob.cn/img/article/044/14.png" alt="14.png"></p><h2 id="动态-JS">动态 JS</h2><p>经过以上分析后，我们加密解密的逻辑都搞定了，但是你多调试一下就会发现，这一个加密解密的 JS 是动态变化的，定义的密钥 key 和偏移量 iv 都是隔段时间就会改变的，如果你在这段代码里下断点，停留时间过长，突然发现断点失效无法断下了，那就是 JS 变了，当前代码已经失效了。</p><p>我们随便薅两个不同的 JS 下来（提示：JS 每隔10分钟会变化，后文有详细分析），利用 PyCharm 的文件对比功能（依次选择 View - Compare With）可以总结出以下几个变化的地方（变量名的变化不算）：</p><ol><li>开头的8个参数的值：两个 aes key 和 iv，两个 des key 和 iv；</li></ol><p><img src="https://cdn.itbob.cn/img/article/044/15.png" alt="15.png"></p><ol start="2"><li>生成加密的 param 时，appId 是变化的，最后的加密分为 AES、DES 和没有加密，三种情况（这里是最容易忽略的地方，这里没有注意到，请求可能会提示 appId 无效的情况）：</li></ol><p><img src="https://cdn.itbob.cn/img/article/044/16.png" alt="16.png"></p><ol start="3"><li>最后发送请求时，data 键值对，其中的键也是变化的：</li></ol><p><img src="https://cdn.itbob.cn/img/article/044/17.png" alt="17.png"></p><p>变化的地方我们找到了，那我们怎么获取这个 JS 呢？因为这个 JS 的在 VM 虚拟机里，所以我们还要找到它的源头，是从哪里来的，我们抓包可以看到一个比较特殊的 JS，类似于 encrypt_xxxxxx.js，看这取名就知道不简单，返回的是一段 eval 包裹的代码：</p><p><img src="https://cdn.itbob.cn/img/article/044/18.png" alt="18.png"></p><p>对于 eval 我们已经很熟悉了，直接去掉 eval，让他执行一下，就可以看到正是我们需要的那段 JS：</p><p><img src="https://cdn.itbob.cn/img/article/044/19.png" alt="19.png"></p><p>这里有个小细节，如果你使用控制台，会发现它一直在打印 img 标签，影响我们的输入，这里可以直接跟进去下断点暂时阻止他运行就行了，不需要做其他操作浪费时间：</p><p><img src="https://cdn.itbob.cn/img/article/044/20.png" alt="20.png"></p><p>你以为到这里就差不多搞定了？错了，同样的这个 encrypt_xxxxxx.js 也藏有玄机：</p><ol><li>encrypt_xxxxxx.js 的名称是动态的，后面的 v 值是秒级时间戳，隔600秒，也就是十分钟就会改变，这个 JS 可以在 city_realtime.php 页面找到，还记得我们前面说过的绕过无限 debugger 不能替换此页面吗？我们要通过此页面来获取动态的 JS，所以是不能替换的！</li></ol><p><img src="https://cdn.itbob.cn/img/article/044/21.png" alt="21.png"></p><p><img src="https://cdn.itbob.cn/img/article/044/22.png" alt="22.png"></p><ol start="2"><li>encrypt_xxxxxx.js 返回的 JS，并不是所有的执行一遍 eval 就能得到明文代码了，它是 eval 和 base64 相结合的，第一遍都是 eval，但是后面就说不定了，有可能直接出结果，有可能需要 base64，有可能 base64 两遍，有可能两遍 base64 之后还要再 eval，总之，除了第一遍是 eval 以外，后面是否需要 base64 和 eval，以及需要的次数和先后顺序，都是不确定的！举几个例子：</li></ol><p><img src="https://cdn.itbob.cn/img/article/044/23.png" alt="23.png"></p><p><img src="https://cdn.itbob.cn/img/article/044/24.png" alt="24.png"></p><p><img src="https://cdn.itbob.cn/img/article/044/25.png" alt="25.png"></p><p>这里可能有人会问，你怎么看出来那是 base64 呢？很简单，直接在网站页面的控制台里输入 <code>dswejwehxt</code>，点击去看这个函数，就是 base64：</p><p><img src="https://cdn.itbob.cn/img/article/044/26.png" alt="26.png"></p><p>那么针对 encrypt_xxxxxx.js 内容不确定的情况，我们可以写一个方法，获取到 encrypt_xxxxxx.js 后，需要执行 eval 就执行 eval，需要执行 base64 就执行 base64，直到没有 eval 和 base64 即可，可以分别用字符串 <code>eval(function</code> 和 <code>dswejwehxt(</code> 来判断是否需要 eval 和 base64（当然也有其他方式，比如 <code>()</code> 的个数等），示例代码如下所示：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_decrypted_js</span>(<span class="hljs-params">encrypted_js_url</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    :param encrypted_js_url: encrypt_xxxxxx.js 的地址</span><span class="hljs-string">    :return: 解密后的 JS</span><span class="hljs-string">    &quot;&quot;&quot;</span>    decrypted_js = requests.get(url=encrypted_js_url, headers=headers).text    flag = <span class="hljs-literal">True</span>    <span class="hljs-keyword">while</span> flag:        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;eval(function&quot;</span> <span class="hljs-keyword">in</span> decrypted_js:            <span class="hljs-comment"># 需要执行 eval</span>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;需要执行 eval！&quot;</span>)            replace_js = decrypted_js.replace(<span class="hljs-string">&quot;eval(function&quot;</span>, <span class="hljs-string">&quot;(function&quot;</span>)            decrypted_js = execjs.<span class="hljs-built_in">eval</span>(replace_js)        <span class="hljs-keyword">elif</span> <span class="hljs-string">&quot;dswejwehxt(&quot;</span> <span class="hljs-keyword">in</span> decrypted_js:            <span class="hljs-comment"># 需要 base64 解码</span>            base64_num = decrypted_js.count(<span class="hljs-string">&quot;dswejwehxt(&quot;</span>)            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;需要 %s 次 base64 解码！&quot;</span> % base64_num)            decrypted_js = re.findall(<span class="hljs-string">r&quot;\(&#x27;(.*?)&#x27;\)&quot;</span>, decrypted_js)[<span class="hljs-number">0</span>]            num = <span class="hljs-number">0</span>            <span class="hljs-keyword">while</span> base64_num &gt; num:                decrypted_js = base64.b64decode(decrypted_js).decode()                num += <span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-comment"># 得到明文</span>            flag = <span class="hljs-literal">False</span>    <span class="hljs-comment"># print(decrypted_js)</span>    <span class="hljs-keyword">return</span> decrypted_js</code></pre><h2 id="本地改写">本地改写</h2><p>通过以上函数我们就拿到了动态的 JS 了，那么我们可以直接执行拿回来的 JS 吗？当然是不可以的，你可以自己本地执行一下，可以发现里面的 CryptoJS、Base64、hex_md5 都需要补齐才行，所以到这里我们就有两种做法：</p><ol><li>拿到解密后的动态 JS 后，动态 JS 和我们自己写的 Base64、hex_md5 等方法组成新的 JS 代码，执行新的 JS 代码拿到参数，这里还需要注意因为里面的其他方法名都是动态的，所以你还得想办法匹配到正确的方法名来调用才行，所以这种方法个人感觉还是稍微有点儿麻烦的；</li><li>我们本地自己写一个 JS，拿到解密后的动态 JS 后，把里面的 key、iv、appId、data 键名、param 是否需要 AES 或 DES 加密，这些信息都匹配出来，然后传给我们自己写的 JS，调用我们自己的方法拿到加密结果。</li></ol><p>虽然两种方法都很麻烦，但暂时也想不到更好的解决方法了，有比较好的想法的朋友可以留言说一说。</p><p>以第二种方法为例，我们本地的 JS 示例（main.js）：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;crypto-js&quot;</span>);<span class="hljs-keyword">var</span> BASE64 = &#123;    <span class="hljs-attr">encrypt</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>&#123;        <span class="hljs-keyword">return</span> CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(text))    &#125;,    <span class="hljs-attr">decrypt</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>&#123;        <span class="hljs-keyword">return</span> CryptoJS.enc.Base64.parse(text).toString(CryptoJS.enc.Utf8)    &#125;&#125;;<span class="hljs-keyword">var</span> DES = &#123;    <span class="hljs-attr">encrypt</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text, key, iv</span>) </span>&#123;        <span class="hljs-keyword">var</span> secretkey = (CryptoJS.MD5(key).toString()).substr(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>);        <span class="hljs-keyword">var</span> secretiv = (CryptoJS.MD5(iv).toString()).substr(<span class="hljs-number">24</span>, <span class="hljs-number">8</span>);        secretkey = CryptoJS.enc.Utf8.parse(secretkey);        secretiv = CryptoJS.enc.Utf8.parse(secretiv);        <span class="hljs-keyword">var</span> result = CryptoJS.DES.encrypt(text, secretkey, &#123;            <span class="hljs-attr">iv</span>: secretiv,            <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,            <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7        &#125;);        <span class="hljs-keyword">return</span> result.toString();    &#125;,    <span class="hljs-attr">decrypt</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text, key, iv</span>) </span>&#123;        <span class="hljs-keyword">var</span> secretkey = (CryptoJS.MD5(key).toString()).substr(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>);        <span class="hljs-keyword">var</span> secretiv = (CryptoJS.MD5(iv).toString()).substr(<span class="hljs-number">24</span>, <span class="hljs-number">8</span>);        secretkey = CryptoJS.enc.Utf8.parse(secretkey);        secretiv = CryptoJS.enc.Utf8.parse(secretiv);        <span class="hljs-keyword">var</span> result = CryptoJS.DES.decrypt(text, secretkey, &#123;            <span class="hljs-attr">iv</span>: secretiv,            <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,            <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7        &#125;);        <span class="hljs-keyword">return</span> result.toString(CryptoJS.enc.Utf8);    &#125;&#125;;<span class="hljs-keyword">var</span> AES = &#123;    <span class="hljs-attr">encrypt</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text, key, iv</span>) </span>&#123;        <span class="hljs-keyword">var</span> secretkey = (CryptoJS.MD5(key).toString()).substr(<span class="hljs-number">16</span>, <span class="hljs-number">16</span>);        <span class="hljs-keyword">var</span> secretiv = (CryptoJS.MD5(iv).toString()).substr(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>);        secretkey = CryptoJS.enc.Utf8.parse(secretkey);        secretiv = CryptoJS.enc.Utf8.parse(secretiv);        <span class="hljs-keyword">var</span> result = CryptoJS.AES.encrypt(text, secretkey, &#123;            <span class="hljs-attr">iv</span>: secretiv,            <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,            <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7        &#125;);        <span class="hljs-keyword">return</span> result.toString();    &#125;,    <span class="hljs-attr">decrypt</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text, key, iv</span>) </span>&#123;        <span class="hljs-keyword">var</span> secretkey = (CryptoJS.MD5(key).toString()).substr(<span class="hljs-number">16</span>, <span class="hljs-number">16</span>);        <span class="hljs-keyword">var</span> secretiv = (CryptoJS.MD5(iv).toString()).substr(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>);        secretkey = CryptoJS.enc.Utf8.parse(secretkey);        secretiv = CryptoJS.enc.Utf8.parse(secretiv);        <span class="hljs-keyword">var</span> result = CryptoJS.AES.decrypt(text, secretkey, &#123;            <span class="hljs-attr">iv</span>: secretiv,            <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,            <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7        &#125;);        <span class="hljs-keyword">return</span> result.toString(CryptoJS.enc.Utf8);    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDecryptedData</span>(<span class="hljs-params">data, AES_KEY_1, AES_IV_1, DES_KEY_1, DES_IV_1</span>) </span>&#123;    data = AES.decrypt(data, AES_KEY_1, AES_IV_1);    data = DES.decrypt(data, DES_KEY_1, DES_IV_1);    data = BASE64.decrypt(data);    <span class="hljs-keyword">return</span> data;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ObjectSort</span>(<span class="hljs-params">obj</span>) </span>&#123;    <span class="hljs-keyword">var</span> newObject = &#123;&#125;;    <span class="hljs-built_in">Object</span>.keys(obj).sort().map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>&#123;        newObject[key] = obj[key];    &#125;);    <span class="hljs-keyword">return</span> newObject;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRequestParam</span>(<span class="hljs-params">method, obj, appId</span>) </span>&#123;    <span class="hljs-keyword">var</span> clienttype = <span class="hljs-string">&#x27;WEB&#x27;</span>;    <span class="hljs-keyword">var</span> timestamp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()    <span class="hljs-keyword">var</span> param = &#123;        <span class="hljs-attr">appId</span>: appId,        <span class="hljs-attr">method</span>: method,        <span class="hljs-attr">timestamp</span>: timestamp,        <span class="hljs-attr">clienttype</span>: clienttype,        <span class="hljs-attr">object</span>: obj,        <span class="hljs-attr">secret</span>: CryptoJS.MD5(appId + method + timestamp + clienttype + <span class="hljs-built_in">JSON</span>.stringify(ObjectSort(obj))).toString()    &#125;;    param = BASE64.encrypt(<span class="hljs-built_in">JSON</span>.stringify(param));    <span class="hljs-keyword">return</span> param;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRequestAESParam</span>(<span class="hljs-params">requestMethod, requestCity, appId, AES_KEY_2, AES_IV_2</span>)</span>&#123;    <span class="hljs-keyword">var</span> param = getRequestParam(requestMethod, requestCity, appId);    <span class="hljs-keyword">return</span> AES.encrypt(param, AES_KEY_2, AES_IV_2);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRequestDESParam</span>(<span class="hljs-params">requestMethod, requestCity, appId, DES_KEY_2, DES_IV_2</span>)</span>&#123;    <span class="hljs-keyword">var</span> param = getRequestParam(requestMethod, requestCity, appId);    <span class="hljs-keyword">return</span> DES.encrypt(param, DES_KEY_2, DES_IV_2);&#125;</code></pre><p>我们匹配 JS 里面的各项参数的 Python 代码示例（匹配8个 key、iv 值、appId 和 param 的加密方式）：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_key_iv_appid</span>(<span class="hljs-params">decrypted_js</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    :param decrypted_js: 解密后的 encrypt_xxxxxx.js</span><span class="hljs-string">    :return: 请求必须的一些参数</span><span class="hljs-string">    &quot;&quot;&quot;</span>    key_iv = re.findall(<span class="hljs-string">r&#x27;const.*?&quot;(.*?)&quot;;&#x27;</span>, decrypted_js)    app_id = re.findall(<span class="hljs-string">r&quot;var appId.*?&#x27;(.*?)&#x27;;&quot;</span>, decrypted_js)    request_data_name = re.findall(<span class="hljs-string">r&quot;aqistudyapi.php.*?data.*?&#123;(.*?):&quot;</span>, decrypted_js, re.DOTALL)    <span class="hljs-comment"># 判断 param 是 AES 加密还是 DES 加密还是没有加密</span>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;AES.encrypt(param&quot;</span> <span class="hljs-keyword">in</span> decrypted_js:        request_param_encrypt = <span class="hljs-string">&quot;AES&quot;</span>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&quot;DES.encrypt(param&quot;</span> <span class="hljs-keyword">in</span> decrypted_js:        request_param_encrypt = <span class="hljs-string">&quot;DES&quot;</span>    <span class="hljs-keyword">else</span>:        request_param_encrypt = <span class="hljs-string">&quot;NO&quot;</span>    key_iv_appid = &#123;        <span class="hljs-comment"># key 和 iv 的位置和原来 js 里的是一样的</span>        <span class="hljs-string">&quot;aes_key_1&quot;</span>: key_iv[<span class="hljs-number">0</span>],        <span class="hljs-string">&quot;aes_iv_1&quot;</span>: key_iv[<span class="hljs-number">1</span>],        <span class="hljs-string">&quot;aes_key_2&quot;</span>: key_iv[<span class="hljs-number">2</span>],        <span class="hljs-string">&quot;aes_iv_2&quot;</span>: key_iv[<span class="hljs-number">3</span>],        <span class="hljs-string">&quot;des_key_1&quot;</span>: key_iv[<span class="hljs-number">4</span>],        <span class="hljs-string">&quot;des_iv_1&quot;</span>: key_iv[<span class="hljs-number">5</span>],        <span class="hljs-string">&quot;des_key_2&quot;</span>: key_iv[<span class="hljs-number">6</span>],        <span class="hljs-string">&quot;des_iv_2&quot;</span>: key_iv[<span class="hljs-number">7</span>],        <span class="hljs-string">&quot;app_id&quot;</span>: app_id[<span class="hljs-number">0</span>],        <span class="hljs-comment"># 发送请求的 data 的键名</span>        <span class="hljs-string">&quot;request_data_name&quot;</span>: request_data_name[<span class="hljs-number">0</span>].strip(),        <span class="hljs-comment"># 发送请求的 data 值需要哪种加密</span>        <span class="hljs-string">&quot;request_param_encrypt&quot;</span>: request_param_encrypt    &#125;    <span class="hljs-comment"># print(key_iv_appid)</span>    <span class="hljs-keyword">return</span> key_iv_appid</code></pre><p>我们发送请求以及解密返回值的 Python 代码示例（以北京为例）：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_data</span>(<span class="hljs-params">key_iv_appid</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    :param key_iv_appid: get_key_iv_appid() 方法返回的值</span><span class="hljs-string">    &quot;&quot;&quot;</span>    request_method = <span class="hljs-string">&quot;GETDATA&quot;</span>    request_city = &#123;<span class="hljs-string">&quot;city&quot;</span>: <span class="hljs-string">&quot;北京&quot;</span>&#125;    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;main.js&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:        execjs_ = execjs.<span class="hljs-built_in">compile</span>(f.read())    <span class="hljs-comment"># 根据不同加密方式调用不同方法获取请求加密的 param 参数</span>    request_param_encrypt = key_iv_appid[<span class="hljs-string">&quot;request_param_encrypt&quot;</span>]    <span class="hljs-keyword">if</span> request_param_encrypt == <span class="hljs-string">&quot;AES&quot;</span>:        param = execjs_.call(            <span class="hljs-string">&#x27;getRequestAESParam&#x27;</span>, request_method, request_city,            key_iv_appid[<span class="hljs-string">&quot;app_id&quot;</span>], key_iv_appid[<span class="hljs-string">&quot;aes_key_2&quot;</span>], key_iv_appid[<span class="hljs-string">&quot;aes_iv_2&quot;</span>]        )    <span class="hljs-keyword">elif</span> request_param_encrypt == <span class="hljs-string">&quot;DES&quot;</span>:        param = execjs_.call(            <span class="hljs-string">&#x27;getRequestDESParam&#x27;</span>, request_method, request_city,            key_iv_appid[<span class="hljs-string">&quot;app_id&quot;</span>], key_iv_appid[<span class="hljs-string">&quot;des_key_2&quot;</span>], key_iv_appid[<span class="hljs-string">&quot;des_iv_2&quot;</span>]        )    <span class="hljs-keyword">else</span>:        param = execjs_.call(<span class="hljs-string">&#x27;getRequestParam&#x27;</span>, request_method, request_city, key_iv_appid[<span class="hljs-string">&quot;app_id&quot;</span>])    data = &#123;        key_iv_appid[<span class="hljs-string">&quot;request_data_name&quot;</span>]: param    &#125;    response = requests.post(url=aqistudy_api, headers=headers, data=data).text    <span class="hljs-comment"># print(response)</span>    <span class="hljs-comment"># 对获取的加密数据解密</span>    decrypted_data = execjs_.call(        <span class="hljs-string">&#x27;getDecryptedData&#x27;</span>, response,        key_iv_appid[<span class="hljs-string">&quot;aes_key_1&quot;</span>], key_iv_appid[<span class="hljs-string">&quot;aes_iv_1&quot;</span>],        key_iv_appid[<span class="hljs-string">&quot;des_key_1&quot;</span>], key_iv_appid[<span class="hljs-string">&quot;des_iv_1&quot;</span>]    )    <span class="hljs-built_in">print</span>(json.loads(decrypted_data))</code></pre><p>运行结果，成功请求并解密返回值：</p><p><img src="https://cdn.itbob.cn/img/article/044/27.png" alt="27.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/javascript_reverse.png&quot; alt=&quot;javascript_reverse&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket 协议爬虫，智慧树扫码登录案例分析</title>
    <link href="https://www.itbob.cn/article/043/"/>
    <id>https://www.itbob.cn/article/043/</id>
    <published>2021-12-07T08:30:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/javascript_reverse.png" alt="javascript_reverse"></p><h2 id="声明">声明</h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2 id="逆向目标">逆向目标</h2><ul><li>目标：智慧树扫码登录，接口使用了 WebSocket 通信协议</li><li>主页：<code>aHR0cHM6Ly9wYXNzcG9ydC56aGlodWlzaHUuY29tL2xvZ2luI3FyQ29kZUxvZ2lu</code></li></ul><h2 id="WebSocket-简介">WebSocket 简介</h2><p>WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议，WebSocket 使得客户端和服务器之间的数据交换变得更加简单。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><p>WebSocket 协议简称为 WS 或者 WSS（WebSocket Secure），其发送请求的 URL 以 <code>ws://</code> 或者 <code>wss://</code> 开头，WSS 是 WS 的加密版本，类似于 HTTP 与 HTTPS。</p><p>WebSocket 协议的最大特点就是：服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。与 HTTP 的对比如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/043/01.png" alt="01.png"></p><h2 id="抓包分析">抓包分析</h2><p>来到智慧树的扫码登录页面，抓包选中 WS，用来筛选 WebSocket 请求，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/043/02.png" alt="02.png"></p><p>其中有一些比较特别的参数，是 HTTP/ HTTPS 请求中没有的：</p><ul><li><code>Upgrade: websocket</code>：表明这是 WebSocket 类型请求；</li><li><code>Sec-WebSocket-Version</code>：告诉服务器所使用的 Websocket Draft（协议版本），必须是 13；</li><li><code>Sec-WebSocket-Extensions</code>：协议扩展，某类协议可能支持多个扩展，通过它可以实现协议增强；</li><li><code>Sec-WebSocket-Key</code>：是 WebSocket 客户端发送的一个 base64 编码的密文，是浏览器随机生成的，要求服务端必须返回一个对应加密的 <code>Sec-WebSocket-Accept</code> 应答，否则客户端会抛出 <code>Error during WebSocket handshake</code> 错误，并关闭连接。</li></ul><p>我们先扫码登录一遍，再选择 Messages 选项卡，可以看到有一些数据交互，其中绿色的箭头是客户端发送给服务器的数据，红色箭头是服务器响应返回给客户端的数据，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/043/03.png" alt="03.png"></p><p>我们观察一下整个交互过程，当我们打开二维码页面后，也就是二维码加载出来的同时，WebSocket 连接就建立了，每隔8秒左右，客户端就主动发送一串字符串，服务端也返回相同的字符串，只不过是字典格式，当我们扫码成功时，服务端就返回扫码成功的信息，当我们点击登陆时，客户端又会返回扫码结果，如果成功，就有一个一次性密码 <code>oncePassword</code> 和一个 <code>uuid</code>，这两个参数肯定在后续的请求中会用到的。如果长时间不扫码的话，过段时间就会返回二维码已失效的信息，每隔8秒发送一次消息，正是为了保持连接以及获取二维码状态消息。</p><p>那么到这里就出现了两个问题：</p><ol><li><p>在来回交互发送的那串字符串，是怎么得来的？</p></li><li><p>在 Python 中应该如何实现 WebSocket 请求？</p></li><li><p>如何实现客户端每隔 8 秒发送一次数据的同时，实时接收服务端的信息？（观察请求扫码结果实时返回的，所以不能每隔 8 秒才接收一次）</p></li></ol><h2 id="参数获取">参数获取</h2><p>首先解决第一个问题，客户端发送的那串字符串是怎么来的，这里寻找加密字符串的方式和 HTTP/HTTPS 请求是一样的，在本例中，我们可以直接搜索这个字符串，发现是通过一个接口传过来的，其中 img 就是二维码图片的 base64 值，qrToken 就是客户端发送的那串字符串，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/043/04.png" alt="04.png"></p><p>这里需要注意的是，并不是所有的 WebSocket 请求都是如此的简单的，有的客户端发送的数据是 Binary Message（二进制数据）、或者更复杂的加密参数，直接搜索无法获取，针对这种情况，我们也有解决方法：</p><ol><li><p>已知创建 WebSocket 对象的语句为：<code>var Socket = new WebSocket(url, [protocol] );</code>，所以我们可以搜索 <code>new WebSocket</code> 定位到建立请求的位置。</p></li><li><p>已知一个 WebSocket 对象有以下相关事件，我们可以搜索对应事件处理程序代码来定位：</p></li></ol><table><thead><tr><th style="text-align:left">事件</th><th style="text-align:left">事件处理程序</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">open</td><td style="text-align:left">Socket.onopen</td><td style="text-align:left">连接建立时触发</td></tr><tr><td style="text-align:left">message</td><td style="text-align:left">Socket.onmessage</td><td style="text-align:left">客户端接收服务端数据时触发</td></tr><tr><td style="text-align:left">error</td><td style="text-align:left">Socket.onerror</td><td style="text-align:left">通信发生错误时触发</td></tr><tr><td style="text-align:left">close</td><td style="text-align:left">Socket.onclose</td><td style="text-align:left">连接关闭时触发</td></tr></tbody></table><ol start="3"><li>已知一个 WebSocket 对象有以下相关方法，我们可以搜索对应方法来定位：</li></ol><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Socket.send()</td><td style="text-align:left">使用连接发送数据</td></tr><tr><td style="text-align:left">Socket.close()</td><td style="text-align:left">关闭连接</td></tr></tbody></table><h2 id="Python-实现-WebSocket-请求">Python 实现 WebSocket 请求</h2><p>接着前面说，第二个问题，在 Python 中应该如何实现 WebSocket 请求？Python 库中用于连接 WebSocket 的有很多，比较常用、稳定的有 <a href="https://github.com/websocket-client/websocket-client">websocket-client</a>（非异步）、<a href="https://github.com/aaugustin/websockets">websockets</a>（异步）、<a href="https://github.com/asyncins/aiowebsocket">aiowebsocket</a>（异步）。在本案例中使用 websocket-client，这里还要注意第三个问题，对于客户端来说，要每隔 8 秒发送一次数据，对于服务端，我们需要实时接收服务端的信息，可以观察请求，扫码的结果是实时返回的，如果我们也每隔 8 秒才接收一次数据的话，有可能会丢失数据，而且也会使得整个程序的响应也不及时，效率变低。</p><p>在 websocket-client 官方文档中给我们提供了一个长连接的 demo，它实现了连续发送三次数据，并实时监听服务端返回的数据，其中的 <code>websocket.enableTrace(True)</code> 表示是否显示连接详细信息：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> websocket<span class="hljs-keyword">import</span> _thread<span class="hljs-keyword">import</span> time<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_message</span>(<span class="hljs-params">ws, message</span>):</span>    <span class="hljs-built_in">print</span>(message)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_error</span>(<span class="hljs-params">ws, error</span>):</span>    <span class="hljs-built_in">print</span>(error)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_close</span>(<span class="hljs-params">ws, close_status_code, close_msg</span>):</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;### closed ###&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_open</span>(<span class="hljs-params">ws</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">*args</span>):</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):            time.sleep(<span class="hljs-number">1</span>)            ws.send(<span class="hljs-string">&quot;Hello %d&quot;</span> % i)        time.sleep(<span class="hljs-number">1</span>)        ws.close()        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;thread terminating...&quot;</span>)    _thread.start_new_thread(run, ())<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    websocket.enableTrace(<span class="hljs-literal">True</span>)    ws = websocket.WebSocketApp(        <span class="hljs-string">&quot;ws://echo.websocket.org/&quot;</span>, on_open=on_open,        on_message=on_message, on_error=on_error, on_close=on_close    )    ws.run_forever()</code></pre><p>我们将其适当改造一下，客户端在 run 方法里，依然是每隔 8 秒发送一次 qr_token，实时接收服务端的消息，当“扫码成功”字样出现在消息里时，将得到的 <code>oncePassword</code> 和 <code>uuid</code> 存起来，然后关闭连接，逻辑代码如下所示，后续只要将二维码的获取逻辑接入就行了。（已脱敏处理，不能直接运行）</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> _thread<span class="hljs-keyword">import</span> websocketweb_socket_url = <span class="hljs-string">&quot;wss://appcomm-user.脱敏处理.com/app-commserv-user/websocket?qrToken=%s&quot;</span>qr_token = <span class="hljs-string">&quot;ca6e6cfb70de4f2f915b968aefcad404&quot;</span>once_password = <span class="hljs-string">&quot;&quot;</span>uuid = <span class="hljs-string">&quot;&quot;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss_on_message</span>(<span class="hljs-params">ws, message</span>):</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=============== [message] ===============&quot;</span>)    message = json.loads(message)    <span class="hljs-built_in">print</span>(message)    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;扫码成功&quot;</span> <span class="hljs-keyword">in</span> message[<span class="hljs-string">&quot;msg&quot;</span>]:        <span class="hljs-keyword">global</span> once_password, uuid        once_password = message[<span class="hljs-string">&quot;oncePassword&quot;</span>]        uuid = message[<span class="hljs-string">&quot;uuid&quot;</span>]        ws.close()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss_on_error</span>(<span class="hljs-params">ws, error</span>):</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=============== [error] ===============&quot;</span>)    <span class="hljs-built_in">print</span>(error)    ws.close()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss_on_close</span>(<span class="hljs-params">ws, close_status_code, close_msg</span>):</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=============== [closed] ===============&quot;</span>)    <span class="hljs-built_in">print</span>(close_status_code)    <span class="hljs-built_in">print</span>(close_msg)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss_on_open</span>(<span class="hljs-params">ws</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">*args</span>):</span>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:            ws.send(qr_token)            time.sleep(<span class="hljs-number">8</span>)    _thread.start_new_thread(run, (qr_token,))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss</span>():</span>    <span class="hljs-comment"># websocket.enableTrace(True)  # 是否显示连接详细信息</span>    ws = websocket.WebSocketApp(        web_socket_url % qr_token, on_open=wss_on_open,        on_message=wss_on_message, on_error=wss_on_error,        on_close=wss_on_close    )    ws.run_forever()</code></pre><h2 id="实现扫码登录">实现扫码登录</h2><p>最重要的 WebSocket 请求部分已经解决了，扫码拿到 <code>oncePassword</code> 和 <code>uuid</code> 后，后续的处理步骤就比较简单了，现在来理一下完整的步骤：</p><ol><li>请求首页，第一次获取 cookie，包含：INGRESSCOOKIE、JSESSIONID、SERVERID、acw_tc；</li><li>请求获取二维码接口，得到二维码的 base64 值和 qrToken；</li><li>建立 WebSocket 连接，扫描二维码，获取一次性密码 oncePassword 和 uuid（好像没什么用）；</li><li>请求一个登录接口，302 重定向，需要携带一次性密码，第二次获取 cookie，包含：CASLOGC、CASTGC，同时更新 SERVERID；</li><li>请求第 4 步 302 重定向地址，第三次获取 cookie，包含：SESSION；</li><li>携带完整 cookie，请求用户信息接口，获取真实用户名等信息。</li></ol><p>实际上 WebSocket 连接结束后，有很多请求，看起来都比较可以，但是经过测试，只有两个重定向比较有用，抓包如下：</p><p><img src="https://cdn.itbob.cn/img/article/043/05.png" alt="05.png"></p><h2 id="完整代码">完整代码</h2><p><strong>以下只演示部分关键代码，不能直接运行！</strong> 完整代码仓库地址：<a href="https://github.com/TRHX/Python3-Spider-Practice/">https://github.com/TRHX/Python3-Spider-Practice/</a></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> json<span class="hljs-keyword">import</span> base64<span class="hljs-keyword">import</span> _thread<span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> websocket<span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Imageweb_socket_url = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>get_login_qr_img_url = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>login_url = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>user_info_url = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>headers = &#123;    <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>,    <span class="hljs-string">&quot;Pragma&quot;</span>: <span class="hljs-string">&quot;no-cache&quot;</span>,    <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>,    <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36&quot;</span>&#125;qr_token = <span class="hljs-string">&quot;&quot;</span>once_password = <span class="hljs-string">&quot;&quot;</span>uuid = <span class="hljs-string">&quot;&quot;</span>cookie = &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cookies_first</span>():</span>    response = requests.get(url=login_url, headers=headers)    <span class="hljs-keyword">global</span> cookie    cookie = response.cookies.get_dict()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_login_qr_img</span>():</span>    response = requests.get(url=get_login_qr_img_url, headers=headers, cookies=cookie).json()    qr_img = response[<span class="hljs-string">&quot;img&quot;</span>]    <span class="hljs-keyword">global</span> qr_token    qr_token = response[<span class="hljs-string">&quot;qrToken&quot;</span>]    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;code.png&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:        f.write(base64.b64decode(qr_img))    image = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;code.png&#x27;</span>)    image.show()    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请扫描验证码! &quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss_on_message</span>(<span class="hljs-params">ws, message</span>):</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=============== [message] ===============&quot;</span>)    message = json.loads(message)    <span class="hljs-built_in">print</span>(message)    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;扫码成功&quot;</span> <span class="hljs-keyword">in</span> message[<span class="hljs-string">&quot;msg&quot;</span>]:        <span class="hljs-keyword">global</span> once_password, uuid        once_password = message[<span class="hljs-string">&quot;oncePassword&quot;</span>]        uuid = message[<span class="hljs-string">&quot;uuid&quot;</span>]        ws.close()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss_on_error</span>(<span class="hljs-params">ws, error</span>):</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=============== [error] ===============&quot;</span>)    <span class="hljs-built_in">print</span>(error)    ws.close()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss_on_close</span>(<span class="hljs-params">ws, close_status_code, close_msg</span>):</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=============== [closed] ===============&quot;</span>)    <span class="hljs-built_in">print</span>(close_status_code)    <span class="hljs-built_in">print</span>(close_msg)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss_on_open</span>(<span class="hljs-params">ws</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">*args</span>):</span>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:            ws.send(qr_token)            time.sleep(<span class="hljs-number">8</span>)    _thread.start_new_thread(run, (qr_token,))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss</span>():</span>    <span class="hljs-comment"># websocket.enableTrace(True)  # 是否显示连接详细信息</span>    ws = websocket.WebSocketApp(        web_socket_url % qr_token, on_open=wss_on_open,        on_message=wss_on_message, on_error=wss_on_error,        on_close=wss_on_close    )    ws.run_forever()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cookie_second</span>():</span>    <span class="hljs-keyword">global</span> cookie    params = &#123;        <span class="hljs-string">&quot;pwd&quot;</span>: once_password,        <span class="hljs-string">&quot;service&quot;</span>: <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>    &#125;    headers[<span class="hljs-string">&quot;Host&quot;</span>] = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>    headers[<span class="hljs-string">&quot;Referer&quot;</span>] = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>    response = requests.get(url=login_url, params=params, headers=headers, cookies=cookie, allow_redirects=<span class="hljs-literal">False</span>)    cookie.update(response.cookies.get_dict())    location = response.headers.get(<span class="hljs-string">&quot;Location&quot;</span>)    <span class="hljs-keyword">return</span> location<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cookie_third</span>(<span class="hljs-params">location</span>):</span>    <span class="hljs-keyword">global</span> cookie    headers[<span class="hljs-string">&quot;Host&quot;</span>] = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>    headers[<span class="hljs-string">&quot;Referer&quot;</span>] = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>    response = requests.get(url=location, headers=headers, cookies=cookie, allow_redirects=<span class="hljs-literal">False</span>)    cookie.update(response.cookies.get_dict())    location = response.headers.get(<span class="hljs-string">&quot;Location&quot;</span>)    <span class="hljs-keyword">return</span> location<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_login_user_info</span>():</span>    headers[<span class="hljs-string">&quot;Host&quot;</span>] = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>    headers[<span class="hljs-string">&quot;Origin&quot;</span>] = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>    headers[<span class="hljs-string">&quot;Referer&quot;</span>] = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>    params = &#123;<span class="hljs-string">&quot;time&quot;</span>: <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(time.time() * <span class="hljs-number">1000</span>))&#125;    response = requests.get(url=user_info_url, headers=headers, cookies=cookie, params=params)    <span class="hljs-built_in">print</span>(response.text)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>    <span class="hljs-comment"># 第一次获取 cookie，包含 INGRESSCOOKIE、JSESSIONID、SERVERID、acw_tc</span>    get_cookies_first()    <span class="hljs-comment"># 获取二维码</span>    get_login_qr_img()    <span class="hljs-comment"># websocket 扫码登录，返回一次性密码</span>    wss()    <span class="hljs-comment"># 第二次获取 cookie，更新 SERVERID、获取 CASLOGC、CASTGC</span>    location1 = get_cookie_second()    <span class="hljs-comment"># 第三次获取 cookie，获取 SESSION</span>    get_cookie_third(location1)    <span class="hljs-comment"># 获取登录用户信息</span>    get_login_user_info()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    main()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/javascript_reverse.png&quot; alt=&quot;javascript_reverse&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Loguru：Python 日志终极解决方案</title>
    <link href="https://www.itbob.cn/article/042/"/>
    <id>https://www.itbob.cn/article/042/</id>
    <published>2021-11-04T07:48:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/loguru.png" alt="loguru"></p><h2 id="日志的重要性">日志的重要性</h2><p>日志的作用非常重要，日志可以记录用户的操作、程序的异常，还可以为数据分析提供依据，日志的存在意义就是为了能够在程序在运行过程中记录错误，方便维护和调试，能够快速定位出错的地方，减少维护成本。每个程序员都应该知道，不是为了记录日志而记录日志，日志也不是随意记的。要实现能够只通过日志文件还原整个程序执行的过程，达到能透明地看到程序里执行情况，每个线程、每个过程到底执行到哪的目的。日志就像飞机的黑匣子一样，应当能够复原异常的整个现场乃至细节！</p><h2 id="常见日志记录方式">常见日志记录方式</h2><h3 id="一、print">一、print()</h3><p>最常见的是把输出函数 <code>print()</code> 当作日志记录的方式，直接打印各种提示信息，常见于个人练习项目里，通常是懒得单独配置日志，而且项目太小不需要日志信息，不需要上线，不需要持续运行，完整的项目不推荐直接打印日志信息，现实中也几乎没有人这么做。</p><h3 id="二、自写模板">二、自写模板</h3><p>我们可以在不少小项目里面看到作者自己写了一个日志模板，通常利用 <code>print()</code> 或者 <code>sys.stdout</code> 稍微封装一下即可实现简单的日志输出，这里的 <code>sys.stdout</code> 是 Python 中的标准输出流，<code>print()</code> 函数是对 <code>sys.stdout</code> 的高级封装，当我们在 Python 中打印对象调用 <code>print(obj)</code> 时候，事实上是调用了 <code>sys.stdout.write(obj+'\n')</code>，<code>print()</code> 将内容打印到了控制台，然后追加了一个换行符 <code>\n</code>。</p><p>自写日志模板适合比较小的项目，可以按照自己的喜好编写模板，不需要太多复杂配置，方便快捷，但是这种记录日志的方式并不是很规范，有可能你自己觉得阅读体验不错，但是别人在接触你的项目的时候往往需要花费一定的时间去学习日志的逻辑、格式、输出方式等，比较大的项目同样不推荐这种方法。</p><p>一个简单的自写日志模板举例：</p><p>日志模板 <a href="http://log.py">log.py</a>：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<span class="hljs-keyword">import</span> traceback<span class="hljs-keyword">import</span> datetime<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getnowtime</span>():</span>    <span class="hljs-keyword">return</span> datetime.datetime.now().strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_log</span>(<span class="hljs-params">content, level, *args</span>):</span>    sys.stdout.write(<span class="hljs-string">&quot;%s - %s - %s\n&quot;</span> % (getnowtime(), level, content))    <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> args:        sys.stdout.write(<span class="hljs-string">&quot;%s\n&quot;</span> % arg)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params">content, *args</span>):</span>    _log(content, <span class="hljs-string">&#x27;DEBUG&#x27;</span>, *args)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">info</span>(<span class="hljs-params">content, *args</span>):</span>    _log(content, <span class="hljs-string">&#x27;INFO&#x27;</span>, *args)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">warn</span>(<span class="hljs-params">content, *args</span>):</span>    _log(content, <span class="hljs-string">&#x27;WARN&#x27;</span>, *args)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">error</span>(<span class="hljs-params">content, *args</span>):</span>    _log(content, <span class="hljs-string">&#x27;ERROR&#x27;</span>, *args)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exception</span>(<span class="hljs-params">content</span>):</span>    sys.stdout.write(<span class="hljs-string">&quot;%s - %s\n&quot;</span> % (getnowtime(), content))    traceback.print_exc(file=sys.stdout)</code></pre><p>调用日志模块：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> loglog.info(<span class="hljs-string">&quot;This is log info!&quot;</span>)log.warn(<span class="hljs-string">&quot;This is log warn!&quot;</span>)log.error(<span class="hljs-string">&quot;This is log error!&quot;</span>)log.debug(<span class="hljs-string">&quot;This is log debug!&quot;</span>)people_info = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">20</span>&#125;<span class="hljs-keyword">try</span>:    gender = people_info[<span class="hljs-string">&quot;gender&quot;</span>]<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> error:    log.exception(error)</code></pre><p>日志输出：</p><pre><code class="hljs python"><span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">19</span> 09:<span class="hljs-number">50</span>:<span class="hljs-number">58</span> - INFO - This <span class="hljs-keyword">is</span> log info!<span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">19</span> 09:<span class="hljs-number">50</span>:<span class="hljs-number">58</span> - WARN - This <span class="hljs-keyword">is</span> log warn!<span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">19</span> 09:<span class="hljs-number">50</span>:<span class="hljs-number">58</span> - ERROR - This <span class="hljs-keyword">is</span> log error!<span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">19</span> 09:<span class="hljs-number">50</span>:<span class="hljs-number">58</span> - DEBUG - This <span class="hljs-keyword">is</span> log debug!<span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">19</span> 09:<span class="hljs-number">50</span>:<span class="hljs-number">58</span> - <span class="hljs-string">&#x27;gender&#x27;</span>Traceback (most recent call last):  File <span class="hljs-string">&quot;D:/python3Project/test.py&quot;</span>, line <span class="hljs-number">18</span>, <span class="hljs-keyword">in</span> &lt;module&gt;    gender = people_info[<span class="hljs-string">&quot;gender&quot;</span>]KeyError: <span class="hljs-string">&#x27;gender&#x27;</span></code></pre><h3 id="三、Logging">三、Logging</h3><p>在一个完整的项目中，大多数人都会引入专门的日志记录库，而 Python 自带的标准库 logging 就是专门为日志记录而生的，logging 模块定义的函数和类为应用程序和库的开发实现了一个灵活的事件日志系统。由标准库模块提供日志记录 API 的关键好处是所有 Python 模块都可以使用这个日志记录功能。所以，你的应用日志可以将你自己的日志信息与来自第三方模块的信息整合起来。</p><p>logging 模块虽然强大，但是其配置也是比较繁琐的，在大型项目中通常需要单独初始化日志、配置日志格式等等，我在日常使用中通常都会对 logging 做如下的封装写法，使日志可以按天保存，保留15天的日志，可以配置是否输出到控制台和文件，如下所示：</p><pre><code class="hljs python"><span class="hljs-comment"># 实现按天分割保留日志</span><span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> sys<span class="hljs-keyword">import</span> logging<span class="hljs-keyword">from</span> logging <span class="hljs-keyword">import</span> handlersPARENT_DIR = os.path.split(os.path.realpath(__file__))[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 父目录</span>LOGGING_DIR = os.path.join(PARENT_DIR, <span class="hljs-string">&quot;log&quot;</span>)              <span class="hljs-comment"># 日志目录</span>LOGGING_NAME = <span class="hljs-string">&quot;test&quot;</span>                                      <span class="hljs-comment"># 日志文件名</span>LOGGING_TO_FILE = <span class="hljs-literal">True</span>                                     <span class="hljs-comment"># 日志输出文件</span>LOGGING_TO_CONSOLE = <span class="hljs-literal">True</span>                                  <span class="hljs-comment"># 日志输出到控制台</span>LOGGING_WHEN = <span class="hljs-string">&#x27;D&#x27;</span>                                         <span class="hljs-comment"># 日志文件切分维度</span>LOGGING_INTERVAL = <span class="hljs-number">1</span>                                       <span class="hljs-comment"># 间隔少个 when 后，自动重建文件</span>LOGGING_BACKUP_COUNT = <span class="hljs-number">15</span>                                  <span class="hljs-comment"># 日志保留个数，0 保留所有日志</span>LOGGING_LEVEL = logging.DEBUG                              <span class="hljs-comment"># 日志等级</span>LOGGING_suffix = <span class="hljs-string">&quot;%Y.%m.%d.log&quot;</span>                            <span class="hljs-comment"># 旧日志文件名</span><span class="hljs-comment"># 日志输出格式</span>LOGGING_FORMATTER = <span class="hljs-string">&quot;%(levelname)s - %(asctime)s - process:%(process)d - %(filename)s - %(name)s - line:%(lineno)d - %(module)s - %(message)s&quot;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logging_init</span>():</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(LOGGING_DIR):        os.makedirs(LOGGING_DIR)    logger = logging.getLogger()    logger.setLevel(LOGGING_LEVEL)    formatter = logging.Formatter(LOGGING_FORMATTER)    <span class="hljs-keyword">if</span> LOGGING_TO_FILE:        file_handler = handlers.TimedRotatingFileHandler(filename=os.path.join(LOGGING_DIR, LOGGING_NAME), when=LOGGING_WHEN, interval=LOGGING_INTERVAL, backupCount=LOGGING_BACKUP_COUNT)        file_handler.suffix = LOGGING_suffix        file_handler.setFormatter(formatter)        logger.addHandler(file_handler)    <span class="hljs-keyword">if</span> LOGGING_TO_CONSOLE:        stream_handler = logging.StreamHandler(sys.stderr)        stream_handler.setFormatter(formatter)        logger.addHandler(stream_handler)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logging_test</span>():</span>    logging.info(<span class="hljs-string">&quot;This is log info!&quot;</span>)    logging.warning(<span class="hljs-string">&quot;This is log warn!&quot;</span>)    logging.error(<span class="hljs-string">&quot;This is log error!&quot;</span>)    logging.debug(<span class="hljs-string">&quot;This is log debug!&quot;</span>)    people_info = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">20</span>&#125;    <span class="hljs-keyword">try</span>:        gender = people_info[<span class="hljs-string">&quot;gender&quot;</span>]    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> error:        logging.exception(error)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    logging_init()    logging_test()</code></pre><p>输出日志：</p><pre><code class="hljs bash">INFO - 2021-10-19 11:28:10,103 - process:15144 - test.py - root - line:52 - <span class="hljs-built_in">test</span> - This is <span class="hljs-built_in">log</span> info!WARNING - 2021-10-19 11:28:10,105 - process:15144 - test.py - root - line:53 - <span class="hljs-built_in">test</span> - This is <span class="hljs-built_in">log</span> warn!ERROR - 2021-10-19 11:28:10,105 - process:15144 - test.py - root - line:54 - <span class="hljs-built_in">test</span> - This is <span class="hljs-built_in">log</span> error!DEBUG - 2021-10-19 11:28:10,105 - process:15144 - test.py - root - line:55 - <span class="hljs-built_in">test</span> - This is <span class="hljs-built_in">log</span> debug!ERROR - 2021-10-19 11:28:10,105 - process:15144 - test.py - root - line:61 - <span class="hljs-built_in">test</span> - <span class="hljs-string">&#x27;gender&#x27;</span>Traceback (most recent call last):  File <span class="hljs-string">&quot;D:/python3Project/test.py&quot;</span>, line 59, <span class="hljs-keyword">in</span> logging_test    gender = people_info[<span class="hljs-string">&quot;gender&quot;</span>]KeyError: <span class="hljs-string">&#x27;gender&#x27;</span></code></pre><p>它在控制台中是这样的：</p><p><img src="https://cdn.itbob.cn/img/article/042/01.png" alt="01.png"></p><p>当然，如果你不需要很复杂的功能，希望简洁一点，仅仅需要在控制台输出一下日志的话，也可以只进行简单的配置：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> logginglogging.basicConfig(level=logging.DEBUG, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)logging.getLogger()</code></pre><h2 id="更优雅的解决方案：Loguru">更优雅的解决方案：Loguru</h2><p>对于 logging 模块，即便是简单的使用，也需要自己定义格式，这里介绍一个更加优雅、高效、简洁的第三方模块：loguru，官方的介绍是：Loguru is a library which aims to bring enjoyable logging in Python. Loguru 旨在为 Python 带来愉快的日志记录。这里引用官方的一个 GIF 来快速演示其功能：</p><p><img src="https://cdn.itbob.cn/img/article/042/02.gif" alt="02.gif"></p><hr><h3 id="安装">安装</h3><p>Loguru 仅支持 Python 3.5 及以上的版本，使用 pip 安装即可：</p><pre><code class="hljs bash">pip install loguru</code></pre><hr><h3 id="开箱即用">开箱即用</h3><p>Loguru 的主要概念是只有一个：logger</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> loguru <span class="hljs-keyword">import</span> loggerlogger.info(<span class="hljs-string">&quot;This is log info!&quot;</span>)logger.warning(<span class="hljs-string">&quot;This is log warn!&quot;</span>)logger.error(<span class="hljs-string">&quot;This is log error!&quot;</span>)logger.debug(<span class="hljs-string">&quot;This is log debug!&quot;</span>)</code></pre><p>控制台输出：</p><p><img src="https://cdn.itbob.cn/img/article/042/03.png" alt="03.png"></p><p>可以看到不需要手动设置，Loguru 会提前配置一些基础信息，自动输出时间、日志级别、模块名、行号等信息，而且根据等级的不同，还自动设置了不同的颜色，方便观察，真正做到了开箱即用！</p><hr><h3 id="add-remove">add() / remove()</h3><p>如果想自定义日志级别，自定义日志格式，保存日志到文件该怎么办？与 logging 模块不同，不需要 Handler，不需要 Formatter，只需要一个 <code>add()</code> 函数就可以了，例如我们想把日志储存到文件：</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> loguru <span class="hljs-keyword">import</span> loggerlogger.add(<span class="hljs-string">&#x27;test.log&#x27;</span>)logger.debug(<span class="hljs-string">&#x27;this is a debug&#x27;</span>)</code></pre><p>我们不需要像 logging 模块一样再声明一个 FileHandler 了，就一行 <code>add()</code> 语句搞定，运行之后会发现目录下 test.log 里面同样出现了刚刚控制台输出的 debug 信息。</p><p>与 <code>add()</code> 语句相反，<code>remove()</code> 语句可以删除我们添加的配置：</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> loguru <span class="hljs-keyword">import</span> loggerlog_file = logger.add(<span class="hljs-string">&#x27;test.log&#x27;</span>)logger.debug(<span class="hljs-string">&#x27;This is log debug!&#x27;</span>)logger.remove(log_file)logger.debug(<span class="hljs-string">&#x27;This is another log debug!&#x27;</span>)</code></pre><p>此时控制台会输出两条 debug 信息：</p><pre><code class="hljs bash">2021-10-19 13:53:36.610 | DEBUG    | __main__:&lt;module&gt;:86 - This is <span class="hljs-built_in">log</span> debug!2021-10-19 13:53:36.611 | DEBUG    | __main__:&lt;module&gt;:88 - This is another <span class="hljs-built_in">log</span> debug!</code></pre><p>而 test.log 日志文件里面只有一条 debug  信息，原因就在于我们在第二条 debug 语句之前使用了 <code>remove()</code> 语句。</p><hr><h3 id="完整参数">完整参数</h3><p>Loguru 对输出到文件的配置有非常强大的支持，比如支持输出到多个文件，分级别分别输出，过大创建新文件，过久自动删除等等。 下面我们来详细看一下 <code>add()</code> 语句的详细参数：</p><p>基本语法：</p><pre><code class="hljs python">add(sink, *, level=<span class="hljs-string">&#x27;DEBUG&#x27;</span>, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;&lt;green&gt;&#123;time:YYYY-MM-DD HH:mm:ss.SSS&#125;&lt;/green&gt; | &lt;level&gt;&#123;level: &lt;8&#125;&lt;/level&gt; | &lt;cyan&gt;&#123;name&#125;&lt;/cyan&gt;:&lt;cyan&gt;&#123;function&#125;&lt;/cyan&gt;:&lt;cyan&gt;&#123;line&#125;&lt;/cyan&gt; - &lt;level&gt;&#123;message&#125;&lt;/level&gt;&#x27;</span>, <span class="hljs-built_in">filter</span>=<span class="hljs-literal">None</span>, colorize=<span class="hljs-literal">None</span>, serialize=<span class="hljs-literal">False</span>, backtrace=<span class="hljs-literal">True</span>, diagnose=<span class="hljs-literal">True</span>, enqueue=<span class="hljs-literal">False</span>, catch=<span class="hljs-literal">True</span>, **kwargs)</code></pre><p><strong>基本参数释义：</strong></p><ul><li><strong>sink</strong>：可以是一个 file 对象，例如 <code>sys.stderr</code> 或 <code>open('file.log', 'w')</code>，也可以是 <code>str</code> 字符串或者 <code>pathlib.Path</code> 对象，即文件路径，也可以是一个方法，可以自行定义输出实现，也可以是一个 logging 模块的 Handler，比如 FileHandler、StreamHandler 等，还可以是 <a href="https://docs.python.org/3/glossary.html#term-coroutine-function">coroutine function</a>，即一个返回协程对象的函数等。</li><li><strong>level</strong>：日志输出和保存级别。</li><li><strong>format</strong>：日志格式模板。</li><li><strong>filter</strong>：一个可选的指令，用于决定每个记录的消息是否应该发送到 sink。</li><li><strong>colorize</strong>：格式化消息中包含的颜色标记是否应转换为用于终端着色的 ansi 代码，或以其他方式剥离。 如果没有，则根据 sink 是否为 tty（电传打字机缩写） 自动做出选择。</li><li><strong>serialize</strong>：在发送到 sink 之前，是否应首先将记录的消息转换为 JSON 字符串。</li><li><strong>backtrace</strong>：格式化的异常跟踪是否应该向上扩展，超出捕获点，以显示生成错误的完整堆栈跟踪。</li><li><strong>diagnose</strong>：异常跟踪是否应显示变量值以简化调试。建议在生产环境中设置 <code>False</code>，避免泄露敏感数据。</li><li><strong>enqueue</strong>：要记录的消息是否应在到达 sink 之前首先通过多进程安全队列，这在通过多个进程记录到文件时很有用，这样做的好处还在于使日志记录调用是非阻塞的。</li><li><strong>catch</strong>：是否应自动捕获 sink 处理日志消息时发生的错误，如果为 <code>True</code>，则会在 <code>sys.stderr</code> 上显示异常消息，但该异常不会传播到 sink，从而防止应用程序崩溃。</li><li>*<strong>*kwargs</strong>：仅对配置协程或文件接收器有效的附加参数（见下文）。</li></ul><p><strong>当且仅当 sink 是协程函数时，以下参数适用：</strong></p><ul><li><strong>loop</strong>：将在其中调度和执行异步日志记录任务的事件循环。如果为 <code>None</code>，将使用 <code>asyncio.get_event_loop()</code> 返回的循环。</li></ul><p><strong>当且仅当 sink 是文件路径时，以下参数适用：</strong></p><ul><li><strong>rotation</strong>：一种条件，指示何时应关闭当前记录的文件并开始新的文件。</li><li>**retention **：过滤旧文件的指令，在循环或程序结束期间会删除旧文件。</li><li><strong>compression</strong>：日志文件在关闭时应转换为的压缩或存档格式。</li><li><strong>delay</strong>：是在配置 sink 后立即创建文件，还是延迟到第一条记录的消息时再创建。默认为 <code>False</code>。</li><li><strong>mode</strong>：内置 <code>open()</code> 函数的打开模式，默认为 <code>a</code>（以追加模式打开文件）。</li><li><strong>buffering</strong>：内置 <code>open()</code> 函数的缓冲策略，默认为<code>1</code>（行缓冲文件）。</li><li><strong>encoding</strong>：内置 <code>open()</code> 函数的文件编码，如果 <code>None</code>，则默认为 <a href="https://docs.python.org/3/library/locale.html#locale.getpreferredencoding"><code>locale.getpreferredencoding()</code></a>。</li><li>*<strong>*kwargs</strong>：其他传递给内置 <code>open()</code> 函数的参数。</li></ul><p>这么多参数可以见识到 <code>add()</code> 函数的强大之处，仅仅一个函数就能实现 logging 模块的诸多功能，接下来介绍几个比较常用的方法。</p><hr><h3 id="rotation-日志文件分隔">rotation 日志文件分隔</h3><p><code>add()</code> 函数的 rotation 参数，可以实现按照固定时间创建新的日志文件，比如设置每天 0 点新创建一个 log 文件：</p><pre><code class="hljs python">logger.add(<span class="hljs-string">&#x27;runtime_&#123;time&#125;.log&#x27;</span>, rotation=<span class="hljs-string">&#x27;00:00&#x27;</span>)</code></pre><p>设置超过 500 MB 新创建一个 log 文件：</p><pre><code class="hljs python">logger.add(<span class="hljs-string">&#x27;runtime_&#123;time&#125;.log&#x27;</span>, rotation=<span class="hljs-string">&quot;500 MB&quot;</span>)</code></pre><p>设置每隔一个周新创建一个 log 文件：</p><pre><code class="hljs python">logger.add(<span class="hljs-string">&#x27;runtime_&#123;time&#125;.log&#x27;</span>, rotation=<span class="hljs-string">&#x27;1 week&#x27;</span>)</code></pre><hr><h3 id="retention-日志保留时间">retention 日志保留时间</h3><p><code>add()</code> 函数的 retention 参数，可以设置日志的最长保留时间，比如设置日志文件最长保留 15 天：</p><pre><code class="hljs python">logger.add(<span class="hljs-string">&#x27;runtime_&#123;time&#125;.log&#x27;</span>, retention=<span class="hljs-string">&#x27;15 days&#x27;</span>)</code></pre><p>设置日志文件最多保留 10 个：</p><pre><code class="hljs python">logger.add(<span class="hljs-string">&#x27;runtime_&#123;time&#125;.log&#x27;</span>, retention=<span class="hljs-number">10</span>)</code></pre><p>也可以是一个 <code>datetime.timedelta</code> 对象，比如设置日志文件最多保留 5 个小时：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<span class="hljs-keyword">from</span> loguru <span class="hljs-keyword">import</span> loggerlogger.add(<span class="hljs-string">&#x27;runtime_&#123;time&#125;.log&#x27;</span>, retention=datetime.timedelta(hours=<span class="hljs-number">5</span>))</code></pre><hr><h3 id="compression-日志压缩格式">compression 日志压缩格式</h3><p><code>add()</code> 函数的 compression 参数，可以配置日志文件的压缩格式，这样可以更加节省存储空间，比如设置使用 zip 文件格式保存：</p><pre><code class="hljs python">logger.add(<span class="hljs-string">&#x27;runtime_&#123;time&#125;.log&#x27;</span>, compression=<span class="hljs-string">&#x27;zip&#x27;</span>)</code></pre><p>其格式支持：<code>gz</code>、<code>bz2</code>、<code>xz</code>、<code>lzma</code>、<code>tar</code>、<code>tar.gz</code>、<code>tar.bz2</code>、<code>tar.xz</code></p><hr><h3 id="字符串格式化">字符串格式化</h3><p>Loguru 在输出 log 的时候还提供了非常友好的字符串格式化功能，相当于 <code>str.format()</code>：</p><pre><code class="hljs python">logger.info(<span class="hljs-string">&#x27;If you are using Python &#123;&#125;, prefer &#123;feature&#125; of course!&#x27;</span>, <span class="hljs-number">3.6</span>, feature=<span class="hljs-string">&#x27;f-strings&#x27;</span>)</code></pre><p>输出：</p><pre><code class="hljs python"><span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">19</span> <span class="hljs-number">14</span>:<span class="hljs-number">59</span>:<span class="hljs-number">06.412</span> | INFO     | __main__:&lt;module&gt;:<span class="hljs-number">3</span> - If you are using Python <span class="hljs-number">3.6</span>, prefer f-strings of course!</code></pre><hr><h3 id="异常追溯">异常追溯</h3><p>在 Loguru 里可以直接使用它提供的装饰器就可以直接进行异常捕获，而且得到的日志是无比详细的：</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> loguru <span class="hljs-keyword">import</span> logger<span class="hljs-meta">@logger.catch</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_function</span>(<span class="hljs-params">x, y, z</span>):</span>    <span class="hljs-comment"># An error? It&#x27;s caught anyway!</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (x + y + z)my_function(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</code></pre><p>日志输出：</p><pre><code class="hljs python"><span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">19</span> <span class="hljs-number">15</span>:04:<span class="hljs-number">51.675</span> | ERROR    | __main__:&lt;module&gt;:<span class="hljs-number">10</span> - An error has been caught <span class="hljs-keyword">in</span> function <span class="hljs-string">&#x27;&lt;module&gt;&#x27;</span>, process <span class="hljs-string">&#x27;MainProcess&#x27;</span> (<span class="hljs-number">30456</span>), thread <span class="hljs-string">&#x27;MainThread&#x27;</span> (<span class="hljs-number">26268</span>):Traceback (most recent call last):&gt; File <span class="hljs-string">&quot;D:/python3Project\test.py&quot;</span>, line <span class="hljs-number">10</span>, <span class="hljs-keyword">in</span> &lt;module&gt;    my_function(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)    └ &lt;function my_function at <span class="hljs-number">0x014CDFA8</span>&gt;  File <span class="hljs-string">&quot;D:/python3Project\test.py&quot;</span>, line <span class="hljs-number">7</span>, <span class="hljs-keyword">in</span> my_function    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (x + y + z)                │   │   └ <span class="hljs-number">0</span>                │   └ <span class="hljs-number">0</span>                └ <span class="hljs-number">0</span>ZeroDivisionError: division by zero</code></pre><p>在控制台的输出是这样的：</p><p><img src="https://cdn.itbob.cn/img/article/042/04.png" alt="04.png"></p><p>相比 Logging，Loguru 无论是在配置方面、日志输出样式还是异常追踪，都远优于 Logging，使用 Loguru 无疑能提升开发人员效率。本文仅介绍了一些常用的方法，想要详细了解可参考 <a href="https://loguru.readthedocs.io/">Loguru 官方文档</a>或关注 <a href="https://github.com/Delgan/loguru">Loguru GitHub</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/loguru.png&quot; alt=&quot;loguru&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;日志的重要性&quot;&gt;日志的重要性&lt;/h2&gt;
&lt;p&gt;日志的作用非常重要，日志可以记录用户的操作、程序的异常，还可以为数据分</summary>
      
    
    
    
    <category term="Python" scheme="https://www.itbob.cn/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>认识 SM1/SM2/SM3/SM4/SM7/SM9/ZUC 国密算法</title>
    <link href="https://www.itbob.cn/article/041/"/>
    <id>https://www.itbob.cn/article/041/</id>
    <published>2021-11-04T04:39:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/sm_algorithm.png" alt="sm_algorithm"></p><h2 id="简介">简介</h2><p>国密即国家密码局认定的国产加密算法，爬虫工程师在做 JS 逆向的时候，会遇到各种各样的加密算法，其中 RSA、AES、SHA 等算法是最常见的，这些算法都是国外的，在我以前的文章里也有介绍：<a href="https://itrhx.blog.csdn.net/article/details/119250052">《史上最全总结！爬虫常见加密解密算法》</a></p><p>事实上从 2010 年开始，我国国家密码管理局就已经开始陆续发布了一系列国产加密算法，这其中就包括 SM1、SM2、SM3 、SM4、SM7、SM9、ZUC（祖冲之加密算法）等，SM 代表商密，即商业密码，是指用于商业的、不涉及国家秘密的密码技术。<strong>SM1 和 SM7 的算法不公开</strong>，其余算法都已成为 ISO/IEC 国际标准。</p><p>在这些国产加密算法中，<strong><font color=#B01B15>SM2、SM3、SM4 三种加密算法是比较常见的</font></strong>，在爬取部分 gov 网站时，也可能会遇到这些算法，所以作为爬虫工程师是有必要了解一下这些算法的，如下图所示某 gov 网站就使用了 SM2 和 SM4 加密算法：</p><p><img src="https://img-blog.csdnimg.cn/758cb19d1fbc4ec5ad7cc33781c2f34e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVFJIWCDigKIg6bKN5YuD,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt=""></p><hr><h2 id="算法概述">算法概述</h2><table><thead><tr><th style="text-align:center">算法名称</th><th style="text-align:center">算法类别</th><th style="text-align:center">应用领域</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">SM1</td><td style="text-align:center">对称（分组）加密算法</td><td style="text-align:center">芯片</td><td style="text-align:center">分组长度、密钥长度均为 128 比特</td></tr><tr><td style="text-align:center">SM2</td><td style="text-align:center">非对称（基于椭圆曲线 ECC）加密算法</td><td style="text-align:center">数据加密</td><td style="text-align:center">ECC 椭圆曲线密码机制 256 位，相比 RSA 处理速度快，消耗更少</td></tr><tr><td style="text-align:center">SM3</td><td style="text-align:center">散列（hash）函数算法</td><td style="text-align:center">完整性校验</td><td style="text-align:center">安全性及效率与 SHA-256 相当，压缩函数更复杂</td></tr><tr><td style="text-align:center">SM4</td><td style="text-align:center">对称（分组）加密算法</td><td style="text-align:center">数据加密和局域网产品</td><td style="text-align:center">分组长度、密钥长度均为 128 比特，计算轮数多</td></tr><tr><td style="text-align:center">SM7</td><td style="text-align:center">对称（分组）加密算法</td><td style="text-align:center">非接触式 IC 卡</td><td style="text-align:center">分组长度、密钥长度均为 128 比特</td></tr><tr><td style="text-align:center">SM9</td><td style="text-align:center">标识加密算法（IBE）</td><td style="text-align:center">端对端离线安全通讯</td><td style="text-align:center">加密强度等同于 3072 位密钥的 RSA 加密算法</td></tr><tr><td style="text-align:center">ZUC</td><td style="text-align:center">对称（序列）加密算法</td><td style="text-align:center">移动通信 4G 网络</td><td style="text-align:center">流密码</td></tr></tbody></table><hr><h2 id="算法详解">算法详解</h2><h3 id="SM1-分组加密算法">SM1 分组加密算法</h3><p>SM1 为分组加密算法，对称加密，分组长度和密钥长度都为 128 位，故对消息进行加解密时，若消息长度过长，需要进行分组，要消息长度不足，则要进行填充。算法安全保密强度及相关软硬件实现性能与 AES 相当，该算法不公开，仅以 IP 核的形式存在于芯片中，调用该算法时，需要通过加密芯片的接口进行调用，采用该算法已经研制了系列芯片、智能 IC 卡、智能密码钥匙、加密卡、加密机等安全产品，广泛应用于电子政务、电子商务及国民经济的各个应用领域（包括国家政务通、警务通等重要领域），一般了解的人比较少，爬虫工程师也不会遇到这种加密算法。</p><h3 id="椭圆曲线公钥加密算法">椭圆曲线公钥加密算法</h3><p>SM2 为椭圆曲线（ECC）公钥加密算法，非对称加密，SM2 算法和 RSA 算法都是公钥加密算法，SM2 算法是一种更先进安全的算法，在我们国家商用密码体系中被用来替换 RSA 算法，在不少 gov 网站会见到此类加密算法。我国学者对椭圆曲线密码的研究从 20 世纪 80 年代开始，目前已取得不少成果，SM2 椭圆曲线公钥密码算法比 RSA 算法有以下优势：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">SM2</th><th style="text-align:center">RSA</th></tr></thead><tbody><tr><td style="text-align:center">安全性</td><td style="text-align:center">256 位 SM2 强度已超过 RSA-2048</td><td style="text-align:center">一般</td></tr><tr><td style="text-align:center">算法结构</td><td style="text-align:center">基本椭圆曲线（ECC）</td><td style="text-align:center">基于特殊的可逆模幂运算</td></tr><tr><td style="text-align:center">计算复杂度</td><td style="text-align:center">完全指数级</td><td style="text-align:center">亚指数级</td></tr><tr><td style="text-align:center">存储空间（密钥长度）</td><td style="text-align:center">192-256 bit</td><td style="text-align:center">2048-4096 bit</td></tr><tr><td style="text-align:center">秘钥生成速度</td><td style="text-align:center">较 RSA 算法快百倍以上</td><td style="text-align:center">慢</td></tr><tr><td style="text-align:center">解密加密速度</td><td style="text-align:center">较快</td><td style="text-align:center">一般</td></tr></tbody></table><h3 id="杂凑算法">杂凑算法</h3><p>SM3 为密码杂凑算法，采用密码散列（hash）函数标准，用于替代 MD5/SHA-1/SHA-2 等国际算法，是在 SHA-256 基础上改进实现的一种算法，消息分组长度为 512 位，摘要值长度为 256 位，其中使用了异或、模、模加、移位、与、或、非运算，由填充、迭代过程、消息扩展和压缩函数所构成。在商用密码体系中，SM3 主要用于数字签名及验证、消息认证码生成及验证、随机数生成等。据国家密码管理局表示，其安全性及效率要高于 MD5 算法和 SHA-1 算法，与 SHA-256 相当。</p><h3 id="分组加密算法">分组加密算法</h3><p>SM4 为无线局域网标准的分组加密算法，对称加密，用于替代 DES/AES 等国际算法，SM4 算法与 AES 算法具有相同的密钥长度和分组长度，均为 128 位，故对消息进行加解密时，若消息长度过长，需要进行分组，要消息长度不足，则要进行填充。加密算法与密钥扩展算法都采用 32 轮非线性迭代结构，解密算法与加密算法的结构相同，只是轮密钥的使用顺序相反，解密轮密钥是加密轮密钥的逆序。</p><table><thead><tr><th></th><th>SM4</th><th>DES</th><th>AES</th></tr></thead><tbody><tr><td>计算轮数</td><td>32</td><td>16（3DES 为 16*3）</td><td>10/12/14</td></tr><tr><td>密码部件</td><td>S 盒、非线性变换、线性变换、合成变换</td><td>标准算术和逻辑运算、先替换后置换，不含线性变换</td><td>S 盒、行移位变换、列混合变换、圈密钥加变换（AddRoundKey）</td></tr></tbody></table><h3 id="分组加密算法-t2">分组加密算法</h3><p>SM7 为分组加密算法，对称加密，该算法不公开，应用包括身份识别类应用（非接触式 IC 卡、门禁卡、工作证、参赛证等），票务类应用（大型赛事门票、展会门票等），支付与通卡类应用（积分消费卡、校园一卡通、企业一卡通等）。爬虫工程师基本上不会遇到此类算法。</p><h3 id="标识加密算法">标识加密算法</h3><p>SM9 为标识加密算法（Identity-Based Cryptography），非对称加密，标识加密将用户的标识（如微信号、邮件地址、手机号码、QQ 号等）作为公钥，省略了交换数字证书和公钥过程，使得安全系统变得易于部署和管理，适用于互联网应用的各种新兴应用的安全保障，如基于云技术的密码服务、电子邮件安全、智能终端保护、物联网安全、云存储安全等等。这些安全应用可采用手机号码或邮件地址作为公钥，实现数据加密、身份认证、通话加密、通道加密等。在商用密码体系中，SM9 主要用于用户的身份认证，据新华网公开报道，SM9 的加密强度等同于 3072 位密钥的 RSA 加密算法。</p><h3 id="祖冲之算法">祖冲之算法</h3><p>ZUC 为流密码算法，对称加密，该机密性算法可适用于 3GPP LTE 通信中的加密和解密，该算法包括祖冲之算法（ZUC）、机密性算法（128-EEA3）和完整性算法（128-EIA3）三个部分。已经被国际组织 3GPP 推荐为 4G 无线通信的第三套国际加密和完整性标准的候选算法。</p><hr><h2 id="编程语言实现">编程语言实现</h2><h3 id="Python-语言实现">Python 语言实现</h3><p>在 Python 里面并没有比较官方的库来实现国密算法，这里仅列出了其中两个较为完善的第三方库，需要注意的是，SM1 和 SM7 算法不公开，目前大多库仅实现了 SM2、SM3、SM4 三种密算法。</p><ul><li>snowland-smx-python：<a href="https://gitee.com/snowlandltd/snowland-smx-python">https://gitee.com/snowlandltd/snowland-smx-python</a></li><li>gmssl：<a href="https://github.com/duanhongyi/gmssl">https://github.com/duanhongyi/gmssl</a></li><li>gmssl-python：<a href="https://github.com/gongxian-ding/gmssl-python">https://github.com/gongxian-ding/gmssl-python</a></li></ul><p>其中 gmssl-python 是 gmssl 的改进版，gmssl-python 新增支持了 SM9 算法，不过截止本文编写时，gmssl-python 并未发布 pypi，也未 PR 到 gmssl，使用 <code>pip install gmssl</code> 安装的 gmssl 不支持 SM9 算法。若要使用 SM9 算法，可下载 gmssl-python 源码手动安装。</p><p>以 gmssl 的 SM2 算法为例，实现如下（其他算法和详细用法可参考其官方文档）：</p><p>SM2 加密（encrypt）和解密（decrypt）：</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> gmssl <span class="hljs-keyword">import</span> sm2<span class="hljs-comment"># 16 进制的公钥和私钥</span>private_key = <span class="hljs-string">&#x27;00B9AB0B828FF68872F21A837FC303668428DEA11DCD1B24429D0C99E24EED83D5&#x27;</span>public_key = <span class="hljs-string">&#x27;B9C9A6E04E9C91F7BA880429273747D7EF5DDEB0BB2FF6317EB00BEF331A83081A6994B8993F3F5D6EADDDB81872266C87C018FB4162F5AF347B483E24620207&#x27;</span>sm2_crypt = sm2.CryptSM2(public_key=public_key, private_key=private_key)<span class="hljs-comment"># 待加密数据和加密后数据为 bytes 类型</span>data = <span class="hljs-string">b&quot;this is the data to be encrypted&quot;</span>enc_data = sm2_crypt.encrypt(data)dec_data = sm2_crypt.decrypt(enc_data)<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;enc_data: &#x27;</span>, enc_data.<span class="hljs-built_in">hex</span>())<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;dec_data: &#x27;</span>, dec_data)<span class="hljs-comment"># enc_data:  3cb96dd2e0b6c24df8e22a5da3951d061a6ee6ce99f46a446426feca83e501073288b1553ca8d91fad79054e26696a27c982492466dafb5ed06a573fb09947f2aed8dfae243b095ab88115c584bb6f0814efe2f338a00de42b244c99698e81c7913c1d82b7609557677a36681dd10b646229350ad0261b51ca5ed6030d660947</span><span class="hljs-comment"># dec_data:  b&#x27;this is the data to be encrypted&#x27;</span></code></pre><p>SM2 签名（sign）和校验（verify）：</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> gmssl <span class="hljs-keyword">import</span> sm2, func<span class="hljs-comment"># 16 进制的公钥和私钥</span>private_key = <span class="hljs-string">&#x27;00B9AB0B828FF68872F21A837FC303668428DEA11DCD1B24429D0C99E24EED83D5&#x27;</span>public_key = <span class="hljs-string">&#x27;B9C9A6E04E9C91F7BA880429273747D7EF5DDEB0BB2FF6317EB00BEF331A83081A6994B8993F3F5D6EADDDB81872266C87C018FB4162F5AF347B483E24620207&#x27;</span>sm2_crypt = sm2.CryptSM2(public_key=public_key, private_key=private_key)<span class="hljs-comment"># 待签名数据为 bytes 类型</span>data = <span class="hljs-string">b&quot;this is the data to be signed&quot;</span>random_hex_str = func.random_hex(sm2_crypt.para_len)<span class="hljs-comment">#  16 进制</span>sign = sm2_crypt.sign(data, random_hex_str)verify = sm2_crypt.verify(sign, data)<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;sign: &#x27;</span>, sign)<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;verify: &#x27;</span>, verify)<span class="hljs-comment"># sign:  45cfe5306b1a87cf5d0034ef6712babdd1d98547e75bcf89a17f3bcb617150a3f111ab05597601bab8c41e2b980754b74ebe9a169a59db37d549569910ae273a</span><span class="hljs-comment"># verify:  True</span></code></pre><h3 id="JavaScript-语言实现">JavaScript 语言实现</h3><p>在 JavaScript 中已有比较成熟的实现库，这里推荐 sm-crypto，目前支持 SM2、SM3 和 SM4，需要注意的是，SM2 非对称加密的结果由 C1、C2、C3 三部分组成，其中 C1 是生成随机数的计算出的椭圆曲线点，C2 是密文数据，C3 是 SM3 的摘要值，最开始的国密标准的结果是按 C1C2C3 顺序的，新标准的是按 C1C3C2 顺序存放的，sm-crypto 支持设置 cipherMode，也就是 C1C2C3 的排列顺序。</p><p>sm-crypto：<a href="https://www.npmjs.com/package/sm-crypto">https://www.npmjs.com/package/sm-crypto</a></p><p>以 SM2 算法为例，实现如下（其他算法和详细用法可参考其官方文档）：</p><p>SM2 加密（encrypt）和解密（decrypt）：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sm2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;sm-crypto&#x27;</span>).sm2<span class="hljs-comment">// 1 - C1C3C2，0 - C1C2C3，默认为1</span><span class="hljs-keyword">const</span> cipherMode = <span class="hljs-number">1</span><span class="hljs-comment">// 获取密钥对</span><span class="hljs-keyword">let</span> keypair = sm2.generateKeyPairHex()<span class="hljs-keyword">let</span> publicKey = keypair.publicKey   <span class="hljs-comment">// 公钥</span><span class="hljs-keyword">let</span> privateKey = keypair.privateKey <span class="hljs-comment">// 私钥</span><span class="hljs-keyword">let</span> msgString = <span class="hljs-string">&quot;this is the data to be encrypted&quot;</span><span class="hljs-keyword">let</span> encryptData = sm2.doEncrypt(msgString, publicKey, cipherMode)    <span class="hljs-comment">// 加密结果</span><span class="hljs-keyword">let</span> decryptData = sm2.doDecrypt(encryptData, privateKey, cipherMode) <span class="hljs-comment">// 解密结果</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;encryptData: &quot;</span>, encryptData)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;decryptData: &quot;</span>, decryptData)<span class="hljs-comment">// encryptData:  ddf261103fae06d0efe20ea0fe0d82bcc170e8efd8eeae24e9559b3835993f0ed2acb8ba6782fc21941ee74ca453d77664a5cb7dbb91517e6a3b0c27db7ce587ae7af54f8df48d7fa822b7062e2af66c112aa57de94d12ba28e5ba96bf4439d299b41da4a5282d054696adc64156d248049d1eb1d0af28d76b542fe8a95d427e</span><span class="hljs-comment">// decryptData:  this is the data to be encrypted</span></code></pre><p>SM2 签名（sign）和校验（verify）：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sm2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;sm-crypto&#x27;</span>).sm2<span class="hljs-comment">// 获取密钥对</span><span class="hljs-keyword">let</span> keypair = sm2.generateKeyPairHex()<span class="hljs-keyword">let</span> publicKey = keypair.publicKey   <span class="hljs-comment">// 公钥</span><span class="hljs-keyword">let</span> privateKey = keypair.privateKey <span class="hljs-comment">// 私钥</span><span class="hljs-comment">// 纯签名 + 生成椭圆曲线点</span><span class="hljs-keyword">let</span> msgString = <span class="hljs-string">&quot;this is the data to be signed&quot;</span><span class="hljs-keyword">let</span> sigValueHex = sm2.doSignature(msgString, privateKey)                    <span class="hljs-comment">// 签名</span><span class="hljs-keyword">let</span> verifyResult = sm2.doVerifySignature(msgString, sigValueHex, publicKey) <span class="hljs-comment">// 验签结果</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;sigValueHex: &quot;</span>, sigValueHex)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;verifyResult: &quot;</span>, verifyResult)<span class="hljs-comment">// sigValueHex:  924cbb9f2b5adb554ef77129ff1e3a00b2da42017ad3ec2f806d824a77646987ba8c8c4fb94576c38bc11ae69cc98ebbb40b5d47715171ec7dcea913dfc6ccc1</span><span class="hljs-comment">// verifyResult:  true</span></code></pre><h3 id="其他语言实现以及参考资料">其他语言实现以及参考资料</h3><ul><li>Java 语言实现：<ul><li><a href="https://github.com/bcgit/bc-csharp">https://github.com/bcgit/bc-csharp</a></li><li><a href="https://github.com/xjfuuu/SM2_SM3_SM4Encrypt">https://github.com/xjfuuu/SM2_SM3_SM4Encrypt</a></li></ul></li><li>Go 语言实现：<a href="https://github.com/tjfoc/gmsm">https://github.com/tjfoc/gmsm</a></li><li>开源国密算法工具箱：<a href="http://gmssl.org/">http://gmssl.org/</a></li><li>国密算法源代码下载：<a href="http://www.scctc.org.cn/templates/Download/index.aspx?nodeid=71">http://www.scctc.org.cn/templates/Download/index.aspx?nodeid=71</a></li><li>国家密码管理局：<a href="https://www.sca.gov.cn/">https://www.sca.gov.cn/</a></li><li>密码标准委员会：<a href="http://www.gmbz.org.cn/">http://www.gmbz.org.cn/</a></li></ul><hr><h2 id="附：GM-T-密码行业标准">附：GM/T 密码行业标准</h2><ul><li><a href="http://www.gmbz.org.cn/main/viewfile/20180117202410524608.html">GM/T 0001.1-2012：祖冲之序列密码算法：第1部分：算法描述</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180107233806310781.html">GM/T 0001.2-2012：祖冲之序列密码算法：第2部分：基于祖冲之算法的机密性算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180107234058336917.html">GM/T 0001.3-2012：祖冲之序列密码算法：第3部分：基于祖冲之算法的完整性算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180108015515787986.html">GM/T 0003.1-2012：SM2 椭圆曲线公钥密码算法第1部分：总则</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180108023346264349.html">GM/T 0003.2-2012：SM2 椭圆曲线公钥密码算法第2部分：数字签名算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180108023456003485.html">GM/T 0003.3-2012：SM2 椭圆曲线公钥密码算法第3部分：密钥交换协议</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180108023602687857.html">GM/T 0003.4-2012：SM2 椭圆曲线公钥密码算法第4部分：公钥加密算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/2018010802371372251.html">GM/T 0003.5-2012：SM2 椭圆曲线公钥密码算法第5部分：参数定义</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180108023812835219.html">GM/T 0004-2012：SM3 密码杂凑算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180108015408199368.html">GM/T 0002-2012：SM4 分组密码算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/2018011002473633053.html">GM/T 0044.1-2016：SM9 标识密码算法 第1部分：总则</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180110024900801385.html">GM/T 0044.2-2016：SM9 标识密码算法 第2部分：数字签名算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180110025010004565.html">GM/T 0044.3-2016：SM9 标识密码算法 第3部分：密钥交换协议</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180110025115084846.html">GM/T 0044.4-2016：SM9 标识密码算法 第4部分：密钥封装机制和公钥加密算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180110025229918536.html">GM/T 0044.5-2016：SM9 标识密码算法 第5部分：参数定义</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/sm_algorithm.png&quot; alt=&quot;sm_algorithm&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;国密即国家密码局认定的国产加密算法，爬虫工程师在做 JS 逆向</summary>
      
    
    
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="算法" scheme="https://www.itbob.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>爬虫逆向基础，理解 JavaScript 模块化编程 webpack</title>
    <link href="https://www.itbob.cn/article/040/"/>
    <id>https://www.itbob.cn/article/040/</id>
    <published>2021-10-23T23:00:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/webpack.png" alt="webpack"></p><h2 id="简介">简介</h2><p>在分析一些站点的 JavaScript 代码时，比较简单的代码，函数通常都是一个一个的，例如：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a&quot;</span>)&#125;</code></pre><p>但是稍微复杂一点的站点，通常会遇到类似如下的代码结构：</p><pre><code class="hljs javascript">!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params">t</span>) </span>&#123;        <span class="hljs-keyword">return</span> i[t].call(a, b, c, d)    &#125;&#125;([    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t, e</span>) </span>&#123;&#125;,     <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t, e, n</span>) </span>&#123;&#125;,     <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t, e, r</span>) </span>&#123;&#125;,     <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t, e, o</span>) </span>&#123;&#125;]);</code></pre><p>这种写法在 JavaScript 中很常见，对于熟悉 JavaScript 的人来说可能非常简单，但是爬虫工程师大多数都是用 Python 或者 Java 来写代码的，看到这种语法就有可能懵了，由于在剥离 JS 加密代码时会经常遇到，所以理解这种语法对于爬虫工程师来说是非常重要的。</p><p>这种写法貌似没有官方的名称，相当于进行了模块化编程，因此大多数人称其为 webpack，上面的示例看起来比较费劲，简单优化一下：</p><pre><code class="hljs javascript">!<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">allModule</span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useModule</span>(<span class="hljs-params">whichModule</span>) </span>&#123;        allModule[whichModule].call(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;hello world!&quot;</span>);    &#125;    useModule(<span class="hljs-number">0</span>)&#125;([    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">module0</span>(<span class="hljs-params">param</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;module0: &quot;</span> + param)&#125;,    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">module1</span>(<span class="hljs-params">param</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;module1: &quot;</span> + param)&#125;,    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">module2</span>(<span class="hljs-params">param</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;module2: &quot;</span> + param)&#125;,]);</code></pre><p>运行以上代码，会输出 <code>module0: hello world!</code>，相信通过浅显易懂的变量名和函数名，应该就可以看懂大致含义了，调用 <code>useModule(0)</code>，从所有函数里选择第一个，将 <code>hello world!</code> 传递给 <code>module0</code> 并输出。</p><p>仔细观察以上代码，我们会发现主要用到了 <code>!function()&#123;&#125;()</code> 和 <code>function.call()</code> 语法，接下来就一一介绍一下。</p><hr><h2 id="函数声明与函数表达式">函数声明与函数表达式</h2><p>在 ECMAScript（JavaScript 的一个标准）中，有两个最常用的创建函数对象的方法，即使用函数声明或者函数表达式，ECMAScript 规范明确了一点，即函数声明必须始终带有一个标识符，也就是我们所说的函数名，而函数表达式则可以省略。</p><p>函数声明，会给函数指定一个名字，会在代码执行以前被加载到作用域中，所以<strong>调用函数在函数声明之前或之后都是可以的</strong>：</p><pre><code class="hljs javascript">test(<span class="hljs-string">&quot;Hello World!&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">arg</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(arg)&#125;</code></pre><p>函数表达式，创建一个匿名函数，然后将这个匿名函数赋给一个变量，在代码执行到函数表达式的时候才会有定义，所以<strong>调用函数在函数表达式之后才能正确运行</strong>，否则是会报错的：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> test = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(arg)&#125;test(<span class="hljs-string">&quot;Hello World!&quot;</span>)</code></pre><hr><h2 id="IIFE-立即调用函数表达式">IIFE 立即调用函数表达式</h2><p>IIFE 全称 Immediately-invoked Function Expressions，译为立即调用函数表达式，也称为自执行函数、立即执行函数、自执行匿名函数等，IIFE 是一种语法，这种模式本质上就是函数表达式（命名的或者匿名的）在创建后立即执行。当函数变成立即执行的函数表达式时，表达式中的变量不能从外部访问。IIFE 主要用来隔离作用域，避免污染。</p><hr><h3 id="IIFE-基本语法">IIFE 基本语法</h3><p>IIFE 的写法非常灵活，主要有以下几种格式：</p><p>1、匿名函数前面加上一元操作符，后面加上 <code>()</code>：</p><pre><code class="hljs javascript">!<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I AM IIFE&quot;</span>)&#125;();-<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I AM IIFE&quot;</span>)&#125;();+<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I AM IIFE&quot;</span>)&#125;();~<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I AM IIFE&quot;</span>)&#125;();</code></pre><p>2、匿名函数后面加上 <code>()</code>，然后再用 <code>()</code> 将整个括起来：</p><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I AM IIFE&quot;</span>)&#125;());</code></pre><p>3、先用 <code>()</code> 将匿名函数括起来，再在后面加上 <code>()</code>：</p><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I AM IIFE&quot;</span>)&#125;)();</code></pre><p>4、使用箭头函数表达式，先用 <code>()</code> 将箭头函数表达式括起来，再在后面加上 <code>()</code>：</p><pre><code class="hljs javascript">(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I AM IIFE&quot;</span>)&#125;)()</code></pre><p>5、匿名函数前面加上 <code>void</code> 关键字，后面加上 <code>()</code>， <code>void</code> 指定要计算或运行一个表达式，但是不返回值：</p><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I AM IIFE&quot;</span>)&#125;();</code></pre><p>有的时候，我们还有可能见到立即执行函数前面后分号的情况，例如：</p><pre><code class="hljs javascript">;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I AM IIFE&quot;</span>)&#125;());!<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I AM IIFE&quot;</span>)&#125;()</code></pre><p>这是因为立即执行函数通常作为一个单独模块使用一般是没有问题的，但是还是建议在立即执行函数前面或者后面加上分号，这样可以有效地与前面或者后面的代码进行隔离，否则可能出现意想不到的错误。</p><hr><h3 id="IIFE-参数传递">IIFE 参数传递</h3><p>将参数放在末尾的 <code>()</code> 里即可实现参数传递：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;I AM IIFE&quot;</span>;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">param</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(param)&#125;)(text);<span class="hljs-comment">// I AM IIFE</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> dict = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-string">&quot;20&quot;</span>&#125;;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(dict.name);&#125;)(dict);<span class="hljs-comment">// Bob</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) &#123;        sum += list[i];    &#125;    <span class="hljs-built_in">console</span>.log(sum);&#125;)(list);<span class="hljs-comment">// 15</span></code></pre><hr><h2 id="Function-prototype-call-apply-bind">Function.prototype.call() / apply() / bind()</h2><p><code>Function.prototype.call()</code>、<code>Function.prototype.apply()</code>、<code>Function.prototype.bind()</code> 都是比较常用的方法。它们的作用一模一样，即<strong>改变函数中的 <code>this</code> 指向</strong>，它们的区别如下：</p><ul><li><code>call()</code> 方法会立即执行这个函数，接受一个多个参数，参数之间用逗号隔开；</li><li><code>apply()</code> 方法会立即执行这个函数，接受一个包含多个参数的数组；</li><li><code>bind()</code> 方法不会立即执行这个函数，返回的是一个修改过后的函数，便于稍后调用，接受的参数和 <code>call()</code> 一样。</li></ul><hr><h3 id="call">call()</h3><p><code>call()</code> 方法接受多个参数，第一个参数 thisArg 指定了函数体内 this 对象的指向，如果这个函数处于非严格模式下，指定为 null 或 undefined 时会自动替换为指向全局对象（浏览器中就是 window 对象），在严格模式下，函数体内的 this 还是为 null。从第二个参数开始往后，每个参数被依次传入函数，基本语法如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>.call(thisArg, arg1, arg2, ...)</code></pre><p>示例：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(a + b + c)&#125;test.call(<span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment">// 6</span></code></pre><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.lastName)&#125;<span class="hljs-keyword">var</span> data = &#123;<span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Doe&quot;</span>&#125;test.call(data)  <span class="hljs-comment">// John Doe</span></code></pre><hr><h3 id="apply">apply()</h3><p><code>apply()</code> 方法接受两个参数，第一个参数 thisArg 与 <code>call()</code> 方法一致，第二个参数为一个带下标的集合，从 ECMAScript 第5版开始，这个集合可以为数组，也可以为类数组，<code>apply()</code> 方法把这个集合中的元素作为参数传递给被调用的函数，基本语法如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>.apply(thisArg, [arg1, arg2, ...])</code></pre><p>示例：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(a + b + c)&#125;test.apply(<span class="hljs-literal">null</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])  <span class="hljs-comment">// 6</span></code></pre><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.lastName)&#125;<span class="hljs-keyword">var</span> data = &#123;<span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Doe&quot;</span>&#125;test.apply(data)  <span class="hljs-comment">// John Doe</span></code></pre><hr><h3 id="bind">bind()</h3><p><code>bind()</code> 方法和 <code>call()</code> 接受的参数是相同的，只不过 <code>bind()</code> 返回的是一个函数，基本语法如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>.bind(thisArg, arg1, arg2, ...)</code></pre><p>示例：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(a + b + c)&#125;test.bind(<span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)()  <span class="hljs-comment">// 6</span></code></pre><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.lastName)&#125;<span class="hljs-keyword">var</span> data = &#123;<span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Doe&quot;</span>&#125;test.bind(data)()  <span class="hljs-comment">// John Doe</span></code></pre><hr><h2 id="理解-webpack">理解 webpack</h2><p>有了以上知识后，我们再来理解一下模块化编程，也就是前面所说的 webpack 写法：</p><pre><code class="hljs javascript">!<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">allModule</span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useModule</span>(<span class="hljs-params">whichModule</span>) </span>&#123;        allModule[whichModule].call(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;hello world!&quot;</span>);    &#125;    useModule(<span class="hljs-number">0</span>)&#125;([    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">module0</span>(<span class="hljs-params">param</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;module0: &quot;</span> + param)&#125;,    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">module1</span>(<span class="hljs-params">param</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;module1: &quot;</span> + param)&#125;,    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">module2</span>(<span class="hljs-params">param</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;module2: &quot;</span> + param)&#125;,]);</code></pre><p>首先，这整个代码是一个 IIFE 立即调用函数表达式，传递的参数是一个数组，里面包含三个方法，分别是 <code>module0</code>、<code>module1</code> 和 <code>module2</code>，可以将其视为三个模块，那么 IIFE 接受的参数 <code>allModule</code> 就包含这三个模块，IIFE 里面还包含一个函数 <code>useModule()</code>，可以将其视为模块加载器，即要使用哪个模块，示例中 <code>useModule(0)</code> 即表示调用第一个模块，函数里面使用 <code>call()</code> 方法改变函数中的 <code>this</code> 指向并传递参数，调用相应的模块进行输出。</p><hr><h2 id="改写-webpack">改写 webpack</h2><p>对于我们爬虫逆向当中经常遇到的 webpack 模块化的写法，可以很容易对其进行改写，以下以一段加密代码为例：</p><pre><code class="hljs javascript">CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;crypto-js&quot;</span>)!<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">func</span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">acvs</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> kk = func[<span class="hljs-number">1</span>].call(<span class="hljs-literal">null</span>, <span class="hljs-number">1e3</span>);        <span class="hljs-keyword">var</span> data = &#123;            <span class="hljs-attr">r</span>: <span class="hljs-string">&quot;I LOVE PYTHON&quot;</span>,            <span class="hljs-attr">e</span>: kk,            <span class="hljs-attr">i</span>: <span class="hljs-string">&quot;62bs819idl00oac2&quot;</span>,            <span class="hljs-attr">k</span>: <span class="hljs-string">&quot;0123456789abcdef&quot;</span>        &#125;        <span class="hljs-keyword">return</span> func[<span class="hljs-number">0</span>].call(data);    &#125;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;加密文本：&quot;</span> + acvs())    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">odsc</span>(<span class="hljs-params">account</span>) </span>&#123;        <span class="hljs-keyword">var</span> cr = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">var</span> regExp = <span class="hljs-regexp">/(^\d&#123;7,8&#125;$)|(^0\d&#123;10,12&#125;$)/</span>;        <span class="hljs-keyword">if</span> (regExp.test(account)) &#123;            cr = <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> cr;    &#125;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mkle</span>(<span class="hljs-params">account</span>) </span>&#123;        <span class="hljs-keyword">var</span> cr = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">var</span> regExp = <span class="hljs-regexp">/^([a-zA-Z0-9_\.\-\+])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]&#123;2,4&#125;)+$/</span>;        <span class="hljs-keyword">if</span> (regExp.test(account)) &#123;            cr = <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> cr;    &#125;&#125;([    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = <span class="hljs-string">&quot;&quot;</span>, t = <span class="hljs-number">0</span>; t &lt; <span class="hljs-built_in">this</span>.r.length; t++) &#123;            <span class="hljs-keyword">var</span> o = <span class="hljs-built_in">this</span>.e ^ <span class="hljs-built_in">this</span>.r.charCodeAt(t);            n += <span class="hljs-built_in">String</span>.fromCharCode(o)        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">encodeURIComponent</span>(n)    &#125;,    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.ceil(x * <span class="hljs-built_in">Math</span>.random())    &#125;,    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;        <span class="hljs-keyword">var</span> a = CryptoJS.MD5(<span class="hljs-built_in">this</span>.k);        <span class="hljs-keyword">var</span> c = CryptoJS.enc.Utf8.parse(a);        <span class="hljs-keyword">var</span> d = CryptoJS.AES.encrypt(e, c, &#123;            <span class="hljs-attr">iv</span>: <span class="hljs-built_in">this</span>.i        &#125;);        <span class="hljs-keyword">return</span> d + <span class="hljs-string">&quot;&quot;</span>    &#125;,    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;        <span class="hljs-keyword">var</span> b = CryptoJS.MD5(<span class="hljs-built_in">this</span>.k);        <span class="hljs-keyword">var</span> d = CryptoJS.enc.Utf8.parse(b);        <span class="hljs-keyword">var</span> a = CryptoJS.AES.decrypt(e, d, &#123;            <span class="hljs-attr">iv</span>: <span class="hljs-built_in">this</span>.i        &#125;).toString(CryptoJS.enc.Utf8);        <span class="hljs-keyword">return</span> a    &#125;]);</code></pre><p>可以看到关键的加密入口函数是 <code>acvs()</code>，<code>acvs()</code> 里面又调用了 IIFE 参数列表里面的第一个和第二个函数，剩下的其他函数都是干扰项，而第一个函数中用到了 r 和 e 参数，将其直接传入即可，最终改写如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params">r, e</span>) </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = <span class="hljs-string">&quot;&quot;</span>, t = <span class="hljs-number">0</span>; t &lt; r.length; t++) &#123;        <span class="hljs-keyword">var</span> o = e ^ r.charCodeAt(t);        n += <span class="hljs-built_in">String</span>.fromCharCode(o)    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">encodeURIComponent</span>(n)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.ceil(x * <span class="hljs-built_in">Math</span>.random())&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">acvs</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> kk = b(<span class="hljs-number">1e3</span>);    <span class="hljs-keyword">var</span> r = <span class="hljs-string">&quot;I LOVE PYTHON&quot;</span>;    <span class="hljs-keyword">return</span> a(r, kk);&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;加密文本：&quot;</span> + acvs())</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/webpack.png&quot; alt=&quot;webpack&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;在分析一些站点的 JavaScript 代码时，比较简单的代码，函数通常都是一个一</summary>
      
    
    
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>爬虫常见加密解密算法总结</title>
    <link href="https://www.itbob.cn/article/039/"/>
    <id>https://www.itbob.cn/article/039/</id>
    <published>2021-07-28T07:25:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/encryption_algorithm.png" alt="encryption_algorithm"></p><h2 id="简介">简介</h2><p>本文总结了在爬虫中常见的各种加密算法、编码算法的原理、在 JavaScript 中和 Python 中的基本实现方法，遇到 JS 加密的时候可以快速还原加密过程，有的网站在加密的过程中可能还经过了其他处理，但是大致的方法是一样的。</p><p>常见加密算法：</p><ol><li>对称加密（加密解密密钥相同）：DES、3DES、AES、RC4、Rabbit</li><li>非对称加密（区分公钥和私钥）：RSA、DSA、ECC</li><li>消息摘要算法/签名算法：MD5、SHA、HMAC、PBKDF2</li></ol><p>常见编码算法：Base64</p><h3 id="JavaScript-加密解密模块">JavaScript 加密解密模块</h3><h4 id="Crypto-JS">Crypto-JS</h4><p>Crypto-JS 支持 MD5、SHA、RIPEMD-160、HMAC、PBKDF2、AES、DES、3DES（Triple DES）、Rabbit、RC4 等，<strong>不支持 RSA、ECC</strong>，是应用比较广的加密模块，使用命令 <code>npm install crypto-js</code> 安装。</p><p>参考资料：</p><ul><li><p>Crypto-JS 文档：<a href="https://cryptojs.gitbook.io/docs/">https://cryptojs.gitbook.io/docs/</a></p></li><li><p>Crypto-JS Github：<a href="https://github.com/brix/crypto-js">https://github.com/brix/crypto-js</a></p></li></ul><h4 id="Node-RSA">Node-RSA</h4><p>Node-RSA 对  RSA 算法提供了支持，使用命令 <code>npm install node-rsa </code> 安装。</p><p>参考资料：Node-RSA Github：<a href="https://github.com/rzcoder/node-rsa">https://github.com/rzcoder/node-rsa</a></p><h4 id="JSEncrypt">JSEncrypt</h4><p>参考资料：JSEncrypt 对  RSA 算法提供了更加全面的支持，使用命令 <code>npm install jsencrypt </code> 安装。</p><ul><li>JSEncrypt 文档：<a href="http://travistidwell.com/jsencrypt/">http://travistidwell.com/jsencrypt/</a></li><li>JSEncrypt Github：<a href="https://github.com/travist/jsencrypt">https://github.com/travist/jsencrypt</a></li></ul><h3 id="Python-加密解密库">Python 加密解密库</h3><h4 id="Cryptodome-Crypto">Cryptodome &amp; Crypto</h4><p>在 Python 中有很多算法是通过第三方库 Cryptodome 或者 Crypto 来实现的，Cryptodome 几乎是 Crypto 的替代品，Crypto 已经停止更新好多年了，有很多未知错误，所以<strong>不建议安装 Crypto ！</strong></p><p>Cryptodome 支持几乎所有主流加密算法，包括 MD5、SHA、BLAKE2b、BLAKE2s、HMAC、PBKDF2、AES、DES、3DES（Triple DES）、ECC、RSA、RC4 等。</p><p>Cryptodome 使用命令 <code>pip install pycryptodome</code> 进行安装，Crypto 使用命令 <code>pip install pycrypto </code> 进行安装。</p><p>参考资料：</p><ul><li><p>Crypto 库：<a href="https://www.dlitz.net/software/pycrypto/">https://www.dlitz.net/software/pycrypto/</a></p></li><li><p>Cryptodome 库：<a href="https://www.pycryptodome.org/en/latest/">https://www.pycryptodome.org/en/latest/</a></p></li></ul><h4 id="Hashlib">Hashlib</h4><p>Python 的标准库 hashlib 提供了常见的摘要算法，如 MD5，SHA、BLAKE2b、BLAKE2s 等。</p><p>参考资料：</p><ul><li>hashlib 库：<a href="https://docs.python.org/3/library/hashlib.html">https://docs.python.org/3/library/hashlib.html</a></li><li>廖雪峰 hashlib：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017686752491744">https://www.liaoxuefeng.com/wiki/1016959663602400/1017686752491744</a></li></ul><h4 id="HMAC">HMAC</h4><p>Python 的标准库 hmac 对 HMAC 算法提供了支持。</p><p>参考资料：</p><ul><li>hmac 库：<a href="https://docs.python.org/3/library/hmac.html">https://docs.python.org/3/library/hmac.html</a></li><li>廖雪峰 hmac：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1183198304823296">https://www.liaoxuefeng.com/wiki/1016959663602400/1183198304823296</a></li></ul><h4 id="pyDes">pyDes</h4><p>Python 的第三方库 pyDes 对 DES 算法提供了支持。使用命令 <code>pip install pydes</code> 进行安装。</p><p>参考资料：pyDes 库：<a href="https://github.com/twhiteman/pyDes">https://github.com/twhiteman/pyDes</a></p><h4 id="ESA">ESA</h4><p>Python 的第三方库 rsa 对 RSA 算法提供了支持。使用命令 <code>pip install rsa</code> 进行安装。</p><p>参考资料：rsa 库：<a href="https://stuvel.eu/python-rsa-doc/">https://stuvel.eu/python-rsa-doc/</a></p><h2 id="加密解密基本参数">加密解密基本参数</h2><p>在一些对称和非对称加密算法中，经常会用到以下三个参数：初始向量 iv、加密模式 mode、填充方式 padding，先介绍一下这三个参数的含义和作用：</p><h3 id="初始向量-iv">初始向量 iv</h3><p>在密码学中，初始向量（initialization vector，缩写为 iv），又称初始变数（starting variable，缩写为 sv），与密钥结合使用，作为加密数据的手段，它是一个固定长度的值，iv 的长度取决于加密方法，通常与使用的加密密钥或密码块的长度相当，一般在使用过程中会要求它是随机数或拟随机数，使用随机数产生的初始向量才能达到语义安全，让攻击者难以对原文一致且使用同一把密钥生成的密文进行破解。</p><p>参考资料：维基百科：<a href="https://en.wikipedia.org/wiki/Initialization_vector">https://en.wikipedia.org/wiki/Initialization_vector</a></p><h3 id="加密模式-mode">加密模式 mode</h3><p>目前流行的加密和数字认证算法，都是采用块加密方式，就是将需要加密的明文分成固定大小的数据块，然后对其执行密码算法，得到密文。数据块的大小通常采用跟密钥一样的长度。加密模式在加密算法的基础上发展出来，同时也可以独立于加密算法而存在，加密模式定义了怎样通过重复利用加密算法将大于一个数据块大小的明文转化为密文，描述了加密每一数据块的过程。目前利用较多的加密模式有以下几种：</p><ul><li><p><strong>ECB：Electronic Code Book（电子码本模式）</strong>，是一种基础的加密方式，密文被分割成分组长度相等的块（不足补齐），然后单独一个个加密，一个个输出组成密文。</p></li><li><p><strong>CBC：Cipher Block Chaining（密码块链接模式）</strong>，是一种循环模式，前一个分组的密文和当前分组的明文异或操作后再加密，这样做的目的是增强破解难度。</p></li><li><p><strong>PCBC：Propagating Cipher Block Chaining（填充密码块链接模式）</strong>，也称为明文密码块链接模式（Plaintext Cipher Block Chaining），是一种可以使密文中的微小更改在解密时导致明文大部分错误的模式，并在加密的时候也具有同样的特性。</p></li><li><p><strong>CFB：Cipher Feedback（密码反馈模式）</strong>，可以将块密码变为自同步的流密码，类似于 CBC，CFB 的解密过程几乎就是颠倒的 CBC 的加密过程。</p></li><li><p><strong>OFB：Output Feedback（输出反馈模式）</strong>，可以将块密码变成同步的流密码，它产生密钥流的块，然后将其与明文块进行异或，得到密文。与其它流密码一样，密文中一个位的翻转会使明文中同样位置的位也产生翻转。</p></li><li><p><strong>CTR：Counter mode（计数器模式）</strong>，也被称为 ICM 模式（Integer Counter Mode，整数计数模式）和 SIC 模式（Segmented Integer Counter），在 CTR 模式中，有一个自增的算子，这个算子用密钥加密之后的输出和明文异或的结果得到密文，相当于一次一密。这种加密方式简单快速，安全可靠，而且可以并行加密，但是在计算器不能维持很长的情况下，密钥只能使用一次。</p></li></ul><p>参考资料：维基百科：<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation</a></p><h3 id="填充方式-padding">填充方式 padding</h3><p>块密码只能对确定长度的数据块进行处理，而消息的长度通常是可变的。因此部分模式最后一块数据在加密前需要进行填充。有数种填充方法，其中最简单的一种是在明文的最后填充空字符以使其长度为块长度的整数倍。常见填充方式有以下几种：</p><ul><li><p><strong>PKCS7</strong>：在填充时首先获取需要填充的字节长度 = 块长度 - （数据长度 % 块长度）, 在填充字节序列中所有字节填充为需要填充的字节长度值。</p></li><li><p><strong>PKCS5</strong>：PKCS5 作为 PKCS7 的子集算法，概念上没有什么区别，只是在 blockSize 上固定为 8 bytes，即块大小固定为 8 字节。</p></li><li><p><strong>ZeroPadding</strong>：在填充时首先获取需要填充的字节长度 = 块长度 - （数据长度 % 块长度）, 在填充字节序列中所有字节填充为 0 。</p></li><li><p><strong>ISO10126</strong>：在填充时首先获取需要填充的字节长度 = 块长度 - （数据长度 % 块长度），在填充字节序列中最后一个字节填充为需要填充的字节长度值，填充字节中其余字节均填充随机数值。</p></li><li><p><strong>ANSIX923</strong>：在填充时首先获取需要填充的字节长度 = 块长度 - （数据长度 % 块长度），在填充字节序列中最后一个字节填充为需要填充的字节长度值，填充字节中其余字节均填充数字零。</p></li></ul><p>参考资料：</p><ul><li>维基百科：<a href="https://en.wikipedia.org/wiki/Padding_(cryptography)">https://en.wikipedia.org/wiki/Padding_(cryptography)</a></li><li>PKCS7/PKCS5 填充算法：<a href="https://segmentfault.com/a/1190000019793040">https://segmentfault.com/a/1190000019793040</a></li></ul><h2 id="Base64">Base64</h2><p>简介：Base64 是一种用 64 个字符来表示任意二进制数据的方法。</p><p>参考资料：</p><ul><li>Base64 百度百科：<a href="https://baike.baidu.com/item/base64/8545775">https://baike.baidu.com/item/base64/8545775</a></li><li>Base64 维基百科：<a href="https://en.wikipedia.org/wiki/Base64">https://en.wikipedia.org/wiki/Base64</a></li></ul><h3 id="JavaScript-实现">JavaScript 实现</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 引用 crypto-js 加密模块</span><span class="hljs-keyword">var</span> CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto-js&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">base64Encode</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> srcs = CryptoJS.enc.Utf8.parse(text);    <span class="hljs-keyword">var</span> encodeData = CryptoJS.enc.Base64.stringify(srcs);    <span class="hljs-keyword">return</span> encodeData&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">base64Decode</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> srcs = CryptoJS.enc.Base64.parse(encodeData);    <span class="hljs-keyword">var</span> decodeData = srcs.toString(CryptoJS.enc.Utf8);    <span class="hljs-keyword">return</span> decodeData&#125;<span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;I love Python!&quot;</span><span class="hljs-keyword">var</span> encodeData = base64Encode()<span class="hljs-keyword">var</span> decodeData = base64Decode()<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Base64 编码: &quot;</span>, encodeData)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Base64 解码: &quot;</span>, decodeData)<span class="hljs-comment">// Base64 编码:  SSBsb3ZlIFB5dGhvbiE=</span><span class="hljs-comment">// Base64 解码:  I love Python!</span></code></pre><h3 id="Python-实现">Python 实现</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">base64_encode</span>(<span class="hljs-params">text</span>):</span>    encode_data = base64.b64encode(text.encode())    <span class="hljs-keyword">return</span> encode_data<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">base64_decode</span>(<span class="hljs-params">encode_data</span>):</span>    decode_data = base64.b64decode(encode_data)    <span class="hljs-keyword">return</span> decode_data<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    text = <span class="hljs-string">&#x27;I love Python!&#x27;</span>    encode_data = base64_encode(text)    decode_data = base64_decode(encode_data)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Base64 编码：&#x27;</span>, encode_data)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Base64 解码：&#x27;</span>, decode_data)<span class="hljs-comment"># Base64 编码： b&#x27;SSBsb3ZlIFB5dGhvbiE=&#x27;</span><span class="hljs-comment"># Base64 解码： b&#x27;I love Python!&#x27;</span></code></pre><h2 id="MD5">MD5</h2><p>简介：全称 MD5 消息摘要算法（英文名称：MD5 Message-Digest Algorithm），又称哈希算法、散列算法，由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于 1992 年作为 RFC 1321 被公布，用以取代 MD4 算法。摘要算法是单向加密的，也就是说明文通过摘要算法加密之后，是不能解密的。摘要算法的第二个特点密文是固定长度的，它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。之所以叫摘要算法，它的算法就是提取明文重要的特征。所以，两个不同的明文，使用了摘要算法之后，有可能他们的密文是一样的，不过这个概率非常的低。</p><p>参考资料：</p><ul><li>RFC 1321：<a href="https://datatracker.ietf.org/doc/rfc1321/">https://datatracker.ietf.org/doc/rfc1321/</a></li><li>MD5 维基百科：<a href="https://en.wikipedia.org/wiki/MD5">https://en.wikipedia.org/wiki/MD5</a></li></ul><h3 id="JavaScript-实现-t2">JavaScript 实现</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 引用 crypto-js 加密模块</span><span class="hljs-keyword">var</span> CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto-js&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MD5Test</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;I love python!&quot;</span>    <span class="hljs-keyword">return</span> CryptoJS.MD5(text).toString()&#125;<span class="hljs-built_in">console</span>.log(MD5Test())  <span class="hljs-comment">// 21169ee3acd4a24e1fcb4322cfd9a2b8</span></code></pre><h3 id="Python-实现-t2">Python 实现</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">md5_test1</span>():</span>    md5 = hashlib.new(<span class="hljs-string">&#x27;md5&#x27;</span>, <span class="hljs-string">&#x27;I love python!&#x27;</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))    <span class="hljs-built_in">print</span>(md5.hexdigest())<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">md5_test2</span>():</span>    md5 = hashlib.md5()    md5.update(<span class="hljs-string">&#x27;I love &#x27;</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))    md5.update(<span class="hljs-string">&#x27;python!&#x27;</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))    <span class="hljs-built_in">print</span>(md5.hexdigest())<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    md5_test1()  <span class="hljs-comment"># 21169ee3acd4a24e1fcb4322cfd9a2b8</span>    md5_test2()  <span class="hljs-comment"># 21169ee3acd4a24e1fcb4322cfd9a2b8</span></code></pre><h2 id="PBKDF2">PBKDF2</h2><p>简介：英文名称：Password-Based Key Derivation Function 2，PBKDF2 是 RSA 实验室的公钥加密标准（PKCS）系列的一部分，2017 年发布的 RFC 8018 （PKCS #5 v2.1）推荐使用 PBKDF2 进行密码散列。PBKDF2 将伪随机函数（例如 HMAC），把明文和一个盐值（salt）作为输入参数，然后进行重复运算，并最终产生密钥，如果重复的次数足够大，破解的成本就会变得很高。</p><p>参考资料：</p><ul><li>RFC 8018：<a href="https://datatracker.ietf.org/doc/rfc8018/">https://datatracker.ietf.org/doc/rfc8018/</a></li><li>PBKDF2 维基百科：<a href="https://en.wikipedia.org/wiki/PBKDF2">https://en.wikipedia.org/wiki/PBKDF2</a></li></ul><h3 id="JavaScript-实现-t3">JavaScript 实现</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 引用 crypto-js 加密模块</span><span class="hljs-keyword">var</span> CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto-js&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pbkdf2Encrypt</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;I love Python!&quot;</span>    <span class="hljs-keyword">var</span> salt = <span class="hljs-string">&quot;43215678&quot;</span>    <span class="hljs-comment">// key 长度 128，10 次重复运算</span>    <span class="hljs-keyword">var</span> encryptedData = CryptoJS.PBKDF2(text, salt, &#123;<span class="hljs-attr">keySize</span>: <span class="hljs-number">128</span>/<span class="hljs-number">32</span>,<span class="hljs-attr">iterations</span>: <span class="hljs-number">10</span>&#125;);    <span class="hljs-keyword">return</span> encryptedData.toString()&#125;<span class="hljs-built_in">console</span>.log(pbkdf2Encrypt())  <span class="hljs-comment">// 7fee6e8350cfe96314c76aaa6e853a50</span></code></pre><h3 id="Python-实现-t3">Python 实现</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii<span class="hljs-keyword">from</span> Cryptodome.Hash <span class="hljs-keyword">import</span> SHA1<span class="hljs-keyword">from</span> Cryptodome.Protocol.KDF <span class="hljs-keyword">import</span> PBKDF2text = <span class="hljs-string">&#x27;I love Python!&#x27;</span>salt = <span class="hljs-string">b&#x27;43215678&#x27;</span>result = PBKDF2(text,  salt, count=<span class="hljs-number">10</span>, hmac_hash_module=SHA1)result = binascii.hexlify(result)<span class="hljs-built_in">print</span>(result)<span class="hljs-comment"># b&#x27;7fee6e8350cfe96314c76aaa6e853a50&#x27;</span></code></pre><h2 id="SHA">SHA</h2><p>简介：全称安全哈希算法（英文名称：Secure Hash Algorithm），由美国国家安全局（NSA）所设计，主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA），SHA 通常指 SHA 家族的五个算法，分别是 SHA-1、SHA-224、SHA-256、SHA-384、SHA-512，后四者有时并称为 SHA-2，SHA 是比 MD5 更安全一点的摘要算法，MD5 的密文是 32 位，而 SHA-1 是 40 位，版本越强，密文越长，代价是速度越慢。</p><p>参考资料：</p><ul><li>RFC 3174：<a href="https://datatracker.ietf.org/doc/rfc3174/">https://datatracker.ietf.org/doc/rfc3174/</a></li><li>SHA 维基百科：<a href="https://en.wikipedia.org/wiki/Secure_Hash_Algorithms">https://en.wikipedia.org/wiki/Secure_Hash_Algorithms</a></li></ul><h3 id="JavaScript-实现-t4">JavaScript 实现</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 引用 crypto-js 加密模块</span><span class="hljs-keyword">var</span> CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto-js&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SHA1Encrypt</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;I love python!&quot;</span>    <span class="hljs-keyword">return</span> CryptoJS.SHA1(text).toString();&#125;<span class="hljs-built_in">console</span>.log(SHA1Encrypt())  <span class="hljs-comment">// 23c02b203bd2e2ca19da911f1d270a06d86719fb</span></code></pre><h3 id="Python-实现-t4">Python 实现</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sha1_test1</span>():</span>    sha1 = hashlib.new(<span class="hljs-string">&#x27;sha1&#x27;</span>, <span class="hljs-string">&#x27;I love python!&#x27;</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))    <span class="hljs-built_in">print</span>(sha1.hexdigest())<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sha1_test2</span>():</span>    sha1 = hashlib.sha1()    sha1.update(<span class="hljs-string">&#x27;I love python!&#x27;</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))    <span class="hljs-built_in">print</span>(sha1.hexdigest())<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    sha1_test1()  <span class="hljs-comment"># 23c02b203bd2e2ca19da911f1d270a06d86719fb</span>    sha1_test2()  <span class="hljs-comment"># 23c02b203bd2e2ca19da911f1d270a06d86719fb</span></code></pre><h2 id="HMAC-t2">HMAC</h2><p>简介：全称散列消息认证码、密钥相关的哈希运算消息认证码（英文名称：Hash-based Message Authentication Code 或者 Keyed-hash Message Authentication Code），于 1996 年提出，1997 年作为 RFC 2104 被公布，HMAC 加密算法是一种安全的基于加密 Hash 函数和共享密钥的消息认证协议，它要求通信双方共享密钥 key、约定算法、对报文进行 Hash 运算，形成固定长度的认证码。通信双方通过认证码的校验来确定报文的合法性。</p><p>参考资料：</p><ul><li>RFC 2104：<a href="https://datatracker.ietf.org/doc/rfc2104/">https://datatracker.ietf.org/doc/rfc2104/</a></li><li>HMAC 维基百科：<a href="https://en.wikipedia.org/wiki/HMAC">https://en.wikipedia.org/wiki/HMAC</a></li></ul><h3 id="JavaScript-实现-t5">JavaScript 实现</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 引用 crypto-js 加密模块</span><span class="hljs-keyword">var</span> CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto-js&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HMACEncrypt</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;I love python!&quot;</span>    <span class="hljs-keyword">var</span> key = <span class="hljs-string">&quot;secret&quot;</span>    <span class="hljs-keyword">return</span> CryptoJS.HmacMD5(text, key).toString();    <span class="hljs-comment">// return CryptoJS.HmacSHA1(text, key).toString();</span>    <span class="hljs-comment">// return CryptoJS.HmacSHA256(text, key).toString();</span>&#125;<span class="hljs-built_in">console</span>.log(HMACEncrypt())</code></pre><h3 id="Python-实现-t5">Python 实现</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> hmac<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hmac_test1</span>():</span>    message = <span class="hljs-string">b&#x27;I love python!&#x27;</span>    key = <span class="hljs-string">b&#x27;secret&#x27;</span>    md5 = hmac.new(key, message, digestmod=<span class="hljs-string">&#x27;MD5&#x27;</span>)    <span class="hljs-built_in">print</span>(md5.hexdigest())<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hmac_test2</span>():</span>    key = <span class="hljs-string">&#x27;secret&#x27;</span>.encode(<span class="hljs-string">&#x27;utf8&#x27;</span>)    sha1 = hmac.new(key, digestmod=<span class="hljs-string">&#x27;sha1&#x27;</span>)    sha1.update(<span class="hljs-string">&#x27;I love &#x27;</span>.encode(<span class="hljs-string">&#x27;utf8&#x27;</span>))    sha1.update(<span class="hljs-string">&#x27;Python!&#x27;</span>.encode(<span class="hljs-string">&#x27;utf8&#x27;</span>))    <span class="hljs-built_in">print</span>(sha1.hexdigest())<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    hmac_test1()  <span class="hljs-comment"># 9c503a1f852edcc3526ea56976c38edf</span>    hmac_test2()  <span class="hljs-comment"># 2d8449a4292d4bbeed99ce9ea570880d6e19b61a</span></code></pre><h2 id="DES">DES</h2><p>简介：全称数据加密标准（英文名称：Data Encryption Standard），加密与解密使用同一密钥，属于对称加密算法，1977 年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），DES 是一个分组加密算法，使用 56 位的密钥（一般认为密钥是 64 位，但是密钥的每个第 8 位设置为奇偶校验位，所以实际上有效位只有 56 位），由于 56 位密钥长度相对较短，所以 DES 是不安全的，现在基本上已被更高级的加密标准 AES 取代。</p><ul><li>mode 支持：CBC，CFB，CTR，CTRGladman，ECB，OFB 等。</li><li>padding 支持：ZeroPadding，NoPadding，AnsiX923，Iso10126，Iso97971，Pkcs7 等。</li></ul><p>参考资料：</p><ul><li>RFC 4772：<a href="https://datatracker.ietf.org/doc/rfc4772/">https://datatracker.ietf.org/doc/rfc4772/</a></li><li>DES 维基百科：<a href="https://en.wikipedia.org/wiki/Data_Encryption_Standard">https://en.wikipedia.org/wiki/Data_Encryption_Standard</a></li></ul><h3 id="JavaScript-实现-t6">JavaScript 实现</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 引用 crypto-js 加密模块</span><span class="hljs-keyword">var</span> CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto-js&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">desEncrypt</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> key = CryptoJS.enc.Utf8.parse(desKey),        iv = CryptoJS.enc.Utf8.parse(desIv),        srcs = CryptoJS.enc.Utf8.parse(text),        <span class="hljs-comment">// CBC 加密模式，Pkcs7 填充方式</span>        encrypted = CryptoJS.DES.encrypt(srcs, key, &#123;            <span class="hljs-attr">iv</span>: iv,            <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,            <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7        &#125;);    <span class="hljs-keyword">return</span> encrypted.toString();&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">desDecrypt</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> key = CryptoJS.enc.Utf8.parse(desKey),        iv = CryptoJS.enc.Utf8.parse(desIv),        srcs = encryptedData,        <span class="hljs-comment">// CBC 加密模式，Pkcs7 填充方式</span>        decrypted = CryptoJS.DES.decrypt(srcs, key, &#123;            <span class="hljs-attr">iv</span>: iv,            <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,            <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7        &#125;);    <span class="hljs-keyword">return</span> decrypted.toString(CryptoJS.enc.Utf8);&#125;<span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;I love Python!&quot;</span>       <span class="hljs-comment">// 待加密对象</span><span class="hljs-keyword">var</span> desKey = <span class="hljs-string">&quot;6f726c64f2c2057&quot;</span>    <span class="hljs-comment">// 密钥</span><span class="hljs-keyword">var</span> desIv = <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span>    <span class="hljs-comment">// 初始向量</span><span class="hljs-keyword">var</span> encryptedData = desEncrypt()<span class="hljs-keyword">var</span> decryptedData = desDecrypt()<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;加密字符串: &quot;</span>, encryptedData)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;解密字符串: &quot;</span>, decryptedData)<span class="hljs-comment">// 加密字符串:  +ndbEkWNw2QAfIYQtwC14w==</span><span class="hljs-comment">// 解密字符串:  I love Python!</span></code></pre><h3 id="Python-实现-t6">Python 实现</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii<span class="hljs-comment"># 加密模式 CBC，填充方式 PAD_PKCS5</span><span class="hljs-keyword">from</span> pyDes <span class="hljs-keyword">import</span> des, CBC, PAD_PKCS5<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">des_encrypt</span>(<span class="hljs-params">key, text, iv</span>):</span>    k = des(key, CBC, iv, pad=<span class="hljs-literal">None</span>, padmode=PAD_PKCS5)    en = k.encrypt(text, padmode=PAD_PKCS5)    <span class="hljs-keyword">return</span> binascii.b2a_hex(en)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">des_decrypt</span>(<span class="hljs-params">key, text, iv</span>):</span>    k = des(key, CBC, iv, pad=<span class="hljs-literal">None</span>, padmode=PAD_PKCS5)    de = k.decrypt(binascii.a2b_hex(text), padmode=PAD_PKCS5)    <span class="hljs-keyword">return</span> de<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    secret_key = <span class="hljs-string">&#x27;12345678&#x27;</span>   <span class="hljs-comment"># 密钥</span>    text = <span class="hljs-string">&#x27;I love Python!&#x27;</span>   <span class="hljs-comment"># 加密对象</span>    iv = secret_key           <span class="hljs-comment"># 偏移量</span>    secret_str = des_encrypt(secret_key, text, iv)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;加密字符串：&#x27;</span>, secret_str)    clear_str = des_decrypt(secret_key, secret_str, iv)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;解密字符串：&#x27;</span>, clear_str)<span class="hljs-comment"># 加密字符串： b&#x27;302d3abf2421169239f829b38a9545f1&#x27;</span><span class="hljs-comment"># 解密字符串： b&#x27;I love Python!&#x27;</span></code></pre><h2 id="3DES">3DES</h2><p>简介：全称三重数据加密算法（英文名称：Triple Data Encryption Standard、 Triple Data Encryption Algorithm、TDES、TDEA），是对称加密算法中的一种。70 年代初由 IBM 研发，后 1977 年被美国国家标准局采纳为数据加密标准，它相当于是对每个数据块应用三次 DES 加密算法。由于计算机运算能力的增强，原版 DES 密码的密钥长度变得容易被暴力破解；3DES 即是设计用来提供一种相对简单的方法，即通过增加 DES 的密钥长度来避免破解，所以严格来说 3DES 不是设计一种全新的块密码算法。</p><ul><li>mode 支持：CBC，CFB，CTR，CTRGladman，ECB，OFB 等。</li><li>padding 支持：ZeroPadding，NoPadding，AnsiX923，Iso10126，Iso97971，Pkcs7 等。</li></ul><p>参考资料：</p><ul><li>RFC 1851：<a href="https://datatracker.ietf.org/doc/rfc1851/">https://datatracker.ietf.org/doc/rfc1851/</a></li><li>3DES 维基百科：<a href="https://en.wikipedia.org/wiki/Triple_DES">https://en.wikipedia.org/wiki/Triple_DES</a></li></ul><h3 id="JavaScript-实现-t7">JavaScript 实现</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 引用 crypto-js 加密模块</span><span class="hljs-keyword">var</span> CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto-js&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tripleDesEncrypt</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> key = CryptoJS.enc.Utf8.parse(desKey),        iv = CryptoJS.enc.Utf8.parse(desIv),        srcs = CryptoJS.enc.Utf8.parse(text),        <span class="hljs-comment">// ECB 加密方式，Iso10126 填充方式</span>        encrypted = CryptoJS.TripleDES.encrypt(srcs, key, &#123;            <span class="hljs-attr">iv</span>: iv,            <span class="hljs-attr">mode</span>: CryptoJS.mode.ECB,            <span class="hljs-attr">padding</span>: CryptoJS.pad.Iso10126        &#125;);    <span class="hljs-keyword">return</span> encrypted.toString();&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tripleDesDecrypt</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> key = CryptoJS.enc.Utf8.parse(desKey),        iv = CryptoJS.enc.Utf8.parse(desIv),        srcs = encryptedData,        <span class="hljs-comment">// ECB 加密方式，Iso10126 填充方式</span>        decrypted = CryptoJS.TripleDES.decrypt(srcs, key, &#123;            <span class="hljs-attr">iv</span>: iv,            <span class="hljs-attr">mode</span>: CryptoJS.mode.ECB,            <span class="hljs-attr">padding</span>: CryptoJS.pad.Iso10126        &#125;);    <span class="hljs-keyword">return</span> decrypted.toString(CryptoJS.enc.Utf8);&#125;<span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;I love Python!&quot;</span>       <span class="hljs-comment">// 待加密对象</span><span class="hljs-keyword">var</span> desKey = <span class="hljs-string">&quot;6f726c64f2c2057c&quot;</span>    <span class="hljs-comment">// 密钥</span><span class="hljs-keyword">var</span> desIv = <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span>    <span class="hljs-comment">// 偏移量</span><span class="hljs-keyword">var</span> encryptedData = tripleDesEncrypt()<span class="hljs-keyword">var</span> decryptedData = tripleDesDecrypt()<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;加密字符串: &quot;</span>, encryptedData)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;解密字符串: &quot;</span>, decryptedData)<span class="hljs-comment">// 加密字符串:  3J0NX7x6GbewjjhoW2HKqg==</span><span class="hljs-comment">// 解密字符串:  I love Python!</span></code></pre><h3 id="Python-实现-t7">Python 实现</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> Cryptodome.Cipher <span class="hljs-keyword">import</span> DES3<span class="hljs-keyword">from</span> Cryptodome <span class="hljs-keyword">import</span> Random<span class="hljs-comment"># 需要补位，str不是16的倍数那就补足为16的倍数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_to_16</span>(<span class="hljs-params">value</span>):</span>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(value) % <span class="hljs-number">16</span> != <span class="hljs-number">0</span>:        value += <span class="hljs-string">&#x27;\0&#x27;</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>.encode(value)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">des_encrypt</span>(<span class="hljs-params">key, text, iv</span>):</span>    <span class="hljs-comment"># 加密模式 OFB</span>    cipher_encrypt = DES3.new(add_to_16(key), DES3.MODE_OFB, iv)    encrypted_text = cipher_encrypt.encrypt(text.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))    <span class="hljs-keyword">return</span> encrypted_text<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">des_decrypt</span>(<span class="hljs-params">key, text, iv</span>):</span>    <span class="hljs-comment"># 加密模式 OFB</span>    cipher_decrypt = DES3.new(add_to_16(key), DES3.MODE_OFB, iv)    decrypted_text = cipher_decrypt.decrypt(text)    <span class="hljs-keyword">return</span> decrypted_text<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    key = <span class="hljs-string">&#x27;12345678&#x27;</span>            <span class="hljs-comment"># 密钥，16 位</span>    text = <span class="hljs-string">&#x27;I love Python!&#x27;</span>     <span class="hljs-comment"># 加密对象</span>    iv = Random.new().read(DES3.block_size)  <span class="hljs-comment"># DES3.block_size == 8</span>    secret_str = des_encrypt(key, text, iv)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;加密字符串：&#x27;</span>, secret_str)    clear_str = des_decrypt(key, secret_str, iv)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;解密字符串：&#x27;</span>, clear_str)<span class="hljs-comment"># 加密字符串： b&#x27;\xa5\x8a\xd4R\x99\x16j\xba?vg\xf2\xb6\xa9&#x27;</span><span class="hljs-comment"># 解密字符串： b&#x27;I love Python!&#x27;</span></code></pre><h2 id="AES">AES</h2><p>简介：全称高级加密标准（英文名称：Advanced Encryption Standard），在密码学中又称 Rijndael 加密法，由美国国家标准与技术研究院 （NIST）于 2001 年发布，并在 2002 年成为有效的标准，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES，已经被多方分析且广为全世界所使用，它本身只有一个密钥，即用来实现加密，也用于解密。</p><ul><li>mode 支持：CBC，CFB，CTR，CTRGladman，ECB，OFB 等。</li><li>padding 支持：ZeroPadding，NoPadding，AnsiX923，Iso10126，Iso97971，Pkcs7 等。</li></ul><p>参考资料：</p><ul><li>RFC 3268：<a href="https://datatracker.ietf.org/doc/rfc3268/">https://datatracker.ietf.org/doc/rfc3268/</a></li><li>AES 维基百科：<a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">https://en.wikipedia.org/wiki/Advanced_Encryption_Standard</a></li></ul><h3 id="JavaScript-实现-t8">JavaScript 实现</h3> <pre><code class="hljs javascript"><span class="hljs-comment">// 引用 crypto-js 加密模块</span><span class="hljs-keyword">var</span> CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto-js&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aesEncrypt</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> key = CryptoJS.enc.Utf8.parse(aesKey),        iv = CryptoJS.enc.Utf8.parse(aesIv),        srcs = CryptoJS.enc.Utf8.parse(text),        <span class="hljs-comment">// CBC 加密方式，Pkcs7 填充方式</span>        encrypted = CryptoJS.AES.encrypt(srcs, key, &#123;            <span class="hljs-attr">iv</span>: iv,            <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,            <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7        &#125;);    <span class="hljs-keyword">return</span> encrypted.toString();&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aesDecrypt</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> key = CryptoJS.enc.Utf8.parse(aesKey),        iv = CryptoJS.enc.Utf8.parse(aesIv),        srcs = encryptedData,        <span class="hljs-comment">// CBC 加密方式，Pkcs7 填充方式</span>        decrypted = CryptoJS.AES.decrypt(srcs, key, &#123;            <span class="hljs-attr">iv</span>: iv,            <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,            <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7        &#125;);    <span class="hljs-keyword">return</span> decrypted.toString(CryptoJS.enc.Utf8);&#125;<span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;I love Python!&quot;</span>       <span class="hljs-comment">// 待加密对象</span><span class="hljs-keyword">var</span> aesKey = <span class="hljs-string">&quot;6f726c64f2c2057c&quot;</span>   <span class="hljs-comment">// 密钥，16 倍数</span><span class="hljs-keyword">var</span> aesIv = <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span>    <span class="hljs-comment">// 偏移量，16 倍数</span><span class="hljs-keyword">var</span> encryptedData = aesEncrypt()<span class="hljs-keyword">var</span> decryptedData = aesDecrypt()<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;加密字符串: &quot;</span>, encryptedData)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;解密字符串: &quot;</span>, decryptedData)<span class="hljs-comment">// 加密字符串:  dZL7TLJR786VGvuUvqYGoQ==</span><span class="hljs-comment">// 解密字符串:  I love Python!</span></code></pre><h3 id="Python-实现-t8">Python 实现</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<span class="hljs-keyword">from</span> Cryptodome.Cipher <span class="hljs-keyword">import</span> AES<span class="hljs-comment"># 需要补位，str不是16的倍数那就补足为16的倍数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_to_16</span>(<span class="hljs-params">value</span>):</span>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(value) % <span class="hljs-number">16</span> != <span class="hljs-number">0</span>:        value += <span class="hljs-string">&#x27;\0&#x27;</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>.encode(value)<span class="hljs-comment"># 加密方法</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aes_encrypt</span>(<span class="hljs-params">key, t, iv</span>):</span>    aes = AES.new(add_to_16(key), AES.MODE_CBC, add_to_16(iv))  <span class="hljs-comment"># 初始化加密器</span>    encrypt_aes = aes.encrypt(add_to_16(t))                    <span class="hljs-comment"># 先进行 aes 加密</span>    encrypted_text = <span class="hljs-built_in">str</span>(base64.encodebytes(encrypt_aes), encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># 执行加密并转码返回 bytes</span>    <span class="hljs-keyword">return</span> encrypted_text<span class="hljs-comment"># 解密方法</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aes_decrypt</span>(<span class="hljs-params">key, t, iv</span>):</span>    aes = AES.new(add_to_16(key), AES.MODE_CBC, add_to_16(iv))         <span class="hljs-comment"># 初始化加密器</span>    base64_decrypted = base64.decodebytes(t.encode(encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>))  <span class="hljs-comment"># 优先逆向解密 base64 成 bytes</span>    decrypted_text = <span class="hljs-built_in">str</span>(aes.decrypt(base64_decrypted), encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>).replace(<span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment"># 执行解密密并转码返回str</span>    <span class="hljs-keyword">return</span> decrypted_text<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    secret_key = <span class="hljs-string">&#x27;12345678&#x27;</span>   <span class="hljs-comment"># 密钥</span>    text = <span class="hljs-string">&#x27;I love Python!&#x27;</span>   <span class="hljs-comment"># 加密对象</span>    iv = secret_key           <span class="hljs-comment"># 初始向量</span>    encrypted_str = aes_encrypt(secret_key, text, iv)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;加密字符串：&#x27;</span>, encrypted_str)    decrypted_str = aes_decrypt(secret_key, encrypted_str, iv)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;解密字符串：&#x27;</span>, decrypted_str)<span class="hljs-comment"># 加密字符串： lAVKvkQh+GtdNpoKf4/mHA==</span><span class="hljs-comment"># 解密字符串： I love Python!</span></code></pre><h2 id="RC4">RC4</h2><p>简介：英文名称：Rivest Cipher 4，也称为 ARC4 或 ARCFOUR，是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。RC4 是有线等效加密（WEP）中采用的加密算法，也曾经是 TLS 可采用的算法之一，该算法的速度可以达到 DES 加密的 10 倍左右，且具有很高级别的非线性，虽然它在软件方面的简单性和速度非常出色，但在 RC4 中发现了多个漏洞，它特别容易受到攻击，RC4 作为一种老旧的验证和加密算法易于受到黑客攻击，现在逐渐不推荐使用了。</p><p>参考资料：</p><ul><li>RFC 7465：<a href="https://datatracker.ietf.org/doc/rfc7465/">https://datatracker.ietf.org/doc/rfc7465/</a></li><li>RC4 维基百科：<a href="https://en.wikipedia.org/wiki/RC4">https://en.wikipedia.org/wiki/RC4</a></li></ul><h3 id="JavaScript-实现-t9">JavaScript 实现</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 引用 crypto-js 加密模块</span><span class="hljs-keyword">var</span> CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto-js&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RC4Encrypt</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> CryptoJS.RC4.encrypt(text, key).toString();&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RC4Decrypt</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> CryptoJS.RC4.decrypt(encryptedData, key).toString(CryptoJS.enc.Utf8);&#125;<span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;I love Python!&quot;</span><span class="hljs-keyword">var</span> key = <span class="hljs-string">&quot;6f726c64f2c2057c&quot;</span><span class="hljs-keyword">var</span> encryptedData = RC4Encrypt()<span class="hljs-keyword">var</span> decryptedData = RC4Decrypt()<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;加密字符串: &quot;</span>, encryptedData)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;解密字符串: &quot;</span>, decryptedData)<span class="hljs-comment">// 加密字符串:  U2FsdGVkX18hMm9WWdoEQGPolnXzlg9ryArdGNwv</span><span class="hljs-comment">// 解密字符串:  I love Python!</span></code></pre><h3 id="Python-实现-t9">Python 实现</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<span class="hljs-keyword">from</span> Cryptodome.Cipher <span class="hljs-keyword">import</span> ARC4<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rc4_encrypt</span>(<span class="hljs-params">key, t</span>):</span>    enc = ARC4.new(key.encode(<span class="hljs-string">&#x27;utf8&#x27;</span>))    res = enc.encrypt(t.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))    res = base64.b64encode(res)    <span class="hljs-keyword">return</span> res<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rc4_decrypt</span>(<span class="hljs-params">key, t</span>):</span>    data = base64.b64decode(t)    enc = ARC4.new(key.encode(<span class="hljs-string">&#x27;utf8&#x27;</span>))    res = enc.decrypt(data)    <span class="hljs-keyword">return</span> res<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    secret_key = <span class="hljs-string">&#x27;12345678&#x27;</span>   <span class="hljs-comment"># 密钥</span>    text = <span class="hljs-string">&#x27;I love Python!&#x27;</span>   <span class="hljs-comment"># 加密对象</span>    encrypted_str = rc4_encrypt(secret_key, text)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;加密字符串：&#x27;</span>, encrypted_str)    decrypted_str = rc4_decrypt(secret_key, encrypted_str)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;解密字符串：&#x27;</span>, decrypted_str)<span class="hljs-comment"># 加密字符串： b&#x27;8tNVu3/U/veJR2KgyBw=&#x27;</span><span class="hljs-comment"># 解密字符串： b&#x27;I love Python!&#x27;</span></code></pre><h2 id="Rabbit">Rabbit</h2><p>简介：Rabbit 加密算法是一个高性能的流密码加密方式，2003 年首次被提出，它从 128 位密钥和 64 位初始向量（iv）创建一个密钥流。</p><p>参考资料：</p><ul><li>RFC 4503：<a href="https://datatracker.ietf.org/doc/rfc4503/">https://datatracker.ietf.org/doc/rfc4503/</a></li><li>Rabbit 维基百科：<a href="https://en.wikipedia.org/wiki/Rabbit_(cipher)">https://en.wikipedia.org/wiki/Rabbit_(cipher)</a></li></ul><h3 id="JavaScript-实现-t10">JavaScript 实现</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 引用 crypto-js 加密模块</span><span class="hljs-keyword">var</span> CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto-js&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rabbitEncrypt</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> CryptoJS.Rabbit.encrypt(text, key).toString();&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rabbitDecrypt</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> CryptoJS.Rabbit.decrypt(encryptedData, key).toString(CryptoJS.enc.Utf8);&#125;<span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;I love Python!&quot;</span><span class="hljs-keyword">var</span> key = <span class="hljs-string">&quot;6f726c64f2c2057&quot;</span><span class="hljs-keyword">var</span> encryptedData = rabbitEncrypt()<span class="hljs-keyword">var</span> decryptedData = rabbitDecrypt()<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;加密字符串: &quot;</span>, encryptedData)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;解密字符串: &quot;</span>, decryptedData)<span class="hljs-comment">// 加密字符串:  U2FsdGVkX1+ZVCHRXlhmG5Xw87YPWMNIBlbukuh8</span><span class="hljs-comment">// 解密字符串:  I love Python!</span></code></pre><h3 id="Python-实现-t10">Python 实现</h3><p>目前没有找到有第三方库可以直接实现 Rabbit 算法，在 Python 中实现可以参考：<a href="https://asecuritysite.com/encryption/rabbit2">https://asecuritysite.com/encryption/rabbit2</a></p><h2 id="RSA">RSA</h2><p>简介：英文名称：Rivest-Shamir-Adleman，是 1977 年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的，RSA 就是他们三人姓氏开头字母拼在一起组成的，RSA 加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。它被普遍认为是目前比较优秀的公钥方案之一。RSA是第一个能同时用于加密和数字签名的算法，它能够抵抗到目前为止已知的所有密码攻击。</p><p>参考资料：</p><ul><li>RSA 维基百科：<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">https://en.wikipedia.org/wiki/RSA_(cryptosystem)</a></li></ul><h3 id="JavaScript-实现-t11">JavaScript 实现</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 引用 node-rsa 加密模块</span><span class="hljs-keyword">var</span> NodeRSA = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;node-rsa&#x27;</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rsaEncrypt</span>(<span class="hljs-params"></span>) </span>&#123;    pubKey = <span class="hljs-keyword">new</span> NodeRSA(publicKey,<span class="hljs-string">&#x27;pkcs8-public&#x27;</span>);    <span class="hljs-keyword">var</span> encryptedData = pubKey.encrypt(text, <span class="hljs-string">&#x27;base64&#x27;</span>);    <span class="hljs-keyword">return</span> encryptedData&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rsaDecrypt</span>(<span class="hljs-params"></span>) </span>&#123;    priKey = <span class="hljs-keyword">new</span> NodeRSA(privatekey,<span class="hljs-string">&#x27;pkcs8-private&#x27;</span>);    <span class="hljs-keyword">var</span> decryptedData = priKey.decrypt(encryptedData, <span class="hljs-string">&#x27;utf8&#x27;</span>);    <span class="hljs-keyword">return</span> decryptedData&#125;<span class="hljs-keyword">var</span> key = <span class="hljs-keyword">new</span> NodeRSA(&#123;<span class="hljs-attr">b</span>: <span class="hljs-number">512</span>&#125;);                    <span class="hljs-comment">//生成512位秘钥</span><span class="hljs-keyword">var</span> publicKey = key.exportKey(<span class="hljs-string">&#x27;pkcs8-public&#x27;</span>);    <span class="hljs-comment">//导出公钥</span><span class="hljs-keyword">var</span> privatekey = key.exportKey(<span class="hljs-string">&#x27;pkcs8-private&#x27;</span>);  <span class="hljs-comment">//导出私钥</span><span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;I love Python!&quot;</span><span class="hljs-keyword">var</span> encryptedData = rsaEncrypt()<span class="hljs-keyword">var</span> decryptedData = rsaDecrypt()<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;公钥:\n&quot;</span>, publicKey)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;私钥:\n&quot;</span>, privatekey)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;加密字符串: &quot;</span>, encryptedData)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;解密字符串: &quot;</span>, decryptedData)<span class="hljs-comment">/*</span><span class="hljs-comment">公钥:</span><span class="hljs-comment"> -----BEGIN PUBLIC KEY-----</span><span class="hljs-comment">MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAOV1BwTJSVce/QjJAro5fXG9WzOpal09</span><span class="hljs-comment">Qtv1yuXKE81vZSNTHxW6dICwPT/kjCfC3bA5Qs6wnYBANuwD6wlAS0UCAwEAAQ==</span><span class="hljs-comment">-----END PUBLIC KEY-----</span><span class="hljs-comment">私钥:</span><span class="hljs-comment"> -----BEGIN PRIVATE KEY-----</span><span class="hljs-comment">MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEA5XUHBMlJVx79CMkC</span><span class="hljs-comment">ujl9cb1bM6lqXT1C2/XK5coTzW9lI1MfFbp0gLA9P+SMJ8LdsDlCzrCdgEA27APr</span><span class="hljs-comment">CUBLRQIDAQABAkAiXwJbJC+5PioXG80tyhjRZdT4iyMkrl2Kh2oKO9f1iLaBXLya</span><span class="hljs-comment">D0HW82wFh+cUy8GcMl9jse8DE8wd1TdORmHhAiEA/rwmWjXHVgDqcH/fqk8Ufku0</span><span class="hljs-comment">fXvs56h5QDoh1so5vokCIQDmmL3JDW6Y7RuK2qwFbHBZtYPRFRVdn5X1oqU2FOSX</span><span class="hljs-comment">3QIhAOVTjVN5RtNuT6Cn/jvcpZ5tmTe+8TA8w6vGqeAsfn/BAiBvKKIUEQ2HWoU0</span><span class="hljs-comment">YkUaODPQiteIKomqIAvB5S2O7HNlYQIgWMuLUxGZbbcAmIX+YmRXuET97S7OWv+z</span><span class="hljs-comment">WHVfb/rbXtI=</span><span class="hljs-comment">-----END PRIVATE KEY-----</span><span class="hljs-comment">加密字符串:  hHXTF1K3w55Wd6OSjVYtqxceJ5VhlySNUahel9pwKD92Ef7wIT7DYPuJRKiqz5tuHtUqujbmbZBSL0qDE/EA+A==</span><span class="hljs-comment">解密字符串:  I love Python!</span><span class="hljs-comment">*/</span></code></pre><h3 id="Python-实现-t11">Python 实现</h3><p>模块：rsa：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> rsa<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rsa_encrypt</span>(<span class="hljs-params">pu_key, t</span>):</span>    <span class="hljs-comment"># 公钥加密</span>    rsa = rsa.encrypt(t.encode(<span class="hljs-string">&quot;utf-8&quot;</span>), pu_key)    <span class="hljs-keyword">return</span> rsa<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rsa_decrypt</span>(<span class="hljs-params">pr_key, t</span>):</span>    <span class="hljs-comment"># 私钥解密</span>    rsa = rsa.decrypt(t, pr_key).decode(<span class="hljs-string">&quot;utf-8&quot;</span>)    <span class="hljs-keyword">return</span> rsa<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    public_key, private_key = rsa.newkeys(<span class="hljs-number">512</span>)   <span class="hljs-comment"># 生成公钥、私钥</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;公钥：&#x27;</span>, public_key)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;私钥：&#x27;</span>, private_key)    text = <span class="hljs-string">&#x27;I love Python!&#x27;</span>  <span class="hljs-comment"># 加密对象</span>    encrypted_str = rsa_encrypt(public_key, text)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;加密字符串：&#x27;</span>, encrypted_str)    decrypted_str = rsa_decrypt(private_key, encrypted_str)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;解密字符串：&#x27;</span>, decrypted_str)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">公钥： PublicKey(7636479066127060956100056267701318377455704072072698049978592945665550579944731953431504993757594103617537700972424661030900303472123028864161050235168613, 65537)</span><span class="hljs-string">私钥： PrivateKey(7636479066127060956100056267701318377455704072072698049978592945665550579944731953431504993757594103617537700972424661030900303472123028864161050235168613, 65537, 3850457767980968449796700480128630632818465005441846698224554128042451115530564586537997896922067523638756079019054611200173122138274839877369624069360253, 4713180694194659323798858305046043997526301456820208338158979730140812744181638767, 1620238976946735819854194349514460863335347861649166352709029254680140139)</span><span class="hljs-string">加密字符串： b&quot;\x1aaeps\xa0c&#125;\xb6\xcf\xa3\xb0\xbb\xedA\x7f&#125;\x03\xdc\xd5\x1c\x9b\xdb\xda\xf9q\x80[=\xf5\x91\r\xd0&#x27;f\xce\x1f\x01\xef\xa5\xdb3\x96\t0qIxF\xbd\x11\xd6\xb25\xc5\xe1pM\xb4M\xc2\xd4\x03\xa6&quot;</span><span class="hljs-string">解密字符串： I love Python!</span><span class="hljs-string">&#x27;&#x27;&#x27;</span></code></pre><p>模块 Cryptodome：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<span class="hljs-keyword">from</span> Cryptodome.PublicKey <span class="hljs-keyword">import</span> RSA<span class="hljs-keyword">from</span> Cryptodome.Cipher <span class="hljs-keyword">import</span> PKCS1_v1_5data = <span class="hljs-string">&quot;cKK8B2rWwfwWeXhz&quot;</span>public_key = <span class="hljs-string">&quot;MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAM1xhOWaThSMpfxFsjV5YaWOFHt+6RvS+zH2Pa47VVr8PkZYnRaaKKy2MYBuEh7mZfM/R1dUXTgu0gp6VTNeNQkCAwEAAQ==&quot;</span>rsa_key = RSA.import_key(base64.b64decode(public_key))  <span class="hljs-comment"># 导入读取到的公钥</span>cipher = PKCS1_v1_5.new(rsa_key)                        <span class="hljs-comment"># 生成对象</span>cipher_text = base64.b64encode(cipher.encrypt(data.encode(encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)))<span class="hljs-built_in">print</span>(cipher_text)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/encryption_algorithm.png&quot; alt=&quot;encryption_algorithm&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;本文总结了在爬虫中常见的各种加</summary>
      
    
    
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="算法" scheme="https://www.itbob.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
