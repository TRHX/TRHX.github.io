<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BOB&#39;S BLOG</title>
  
  <subtitle>一入 IT 深似海 从此学习无绝期</subtitle>
  <link href="https://www.itbob.cn/atom.xml" rel="self"/>
  
  <link href="https://www.itbob.cn/"/>
  <updated>2023-05-04T15:20:00.000Z</updated>
  <id>https://www.itbob.cn/</id>
  
  <author>
    <name>BOB</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>抖音滑块验证码 captchaBody 逆向分析，JSVMP 纯算法还原</title>
    <link href="https://www.itbob.cn/article/070/"/>
    <id>https://www.itbob.cn/article/070/</id>
    <published>2023-05-04T15:20:00.000Z</published>
    <updated>2023-05-04T15:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#mu-biao">目标</a></li><li><a href="#zhua-bao-qing-kuang">抓包情况</a></li><li><a href="#can-shu-ni-xiang">参数逆向</a><ul><li><a href="#fp">fp</a></li><li><a href="#captchabody">captchaBody</a><ul><li><a href="#san-ge-shu-zu">三个数组</a></li><li><a href="#shu-zu-2-32-wei">数组 2（32位）</a></li><li><a href="#shu-zu-3-shang-qian-wei">数组 3（上千位）</a></li></ul></li><li><a href="#gui-ji-sheng-cheng">轨迹生成</a></li></ul></li><li><a href="#jie-guo-yan-zheng">结果验证</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="mu-biao">目标</span></h2><ul><li>目标：字节系滑块验证码，某音、某店、某头条、某量算数、某瓜视频等通用，captchaBody 参数逆向分析，JSVMP 纯算法还原</li><li>主页：<code>aHR0cHM6Ly9meGcuamlucml0ZW1haS5jb20v</code></li></ul><p>字节的滑块参数也是 VMP，和某音的 <code>X-Bogus</code> 类似的，<strong>本文有些细节就不再重复描述了</strong>，有不了解的推荐先看看以前的文章：《<a href="https://mp.weixin.qq.com/s/SsZ4XWRXBeqx9VQEeKDsJA">【JS 逆向百例】某音 X-Bogus 逆向分析，JSVMP 纯算法还原</a>》，验证码有个 <code>fp</code> 参数，这个参数过了验证码之后，重命名为 <code>s_v_web_id</code> 加到 cookie 里去请求，就可以不带 <code>X-Bogus</code> 拿数据。<strong>本文的案例以某店的登录为例对验证码进行逆向分析。</strong></p><h2><span id="zhua-bao-qing-kuang">抓包情况</span></h2><p><code>send_activation_code/v2</code> 接口，请求参数包含了加密后的手机号、<code>aid</code> 等参数，其中 <code>aid</code> 应该是用来区分不同网站的，每个网站都不一样，<code>msToken</code>、<code>X-Bogus</code> 参数在这里不校验，置空就行。</p><p>返回的 <code>verify_center_decision_conf</code> 里，有 <code>detail</code> 等值，后续接口会用到。</p><p><img src="https://cdn.itbob.cn/img/article/070/01.png" alt="01"></p><p><img src="https://cdn.itbob.cn/img/article/070/02.png" alt="02"></p><p><code>captcha/get</code> 接口，请求参数里包含前面接口返回的 <code>detail</code>、<code>server_sdk_env</code> 等参数，<code>fp</code> 参数可通过 JS 生成，后续会讲怎么来的。返回数据里包含了验证码图片 URL、<code>challenge_code</code>、<code>id</code>、<code>tip_y</code> 等参数，这些后续同样也会用到的。</p><p><img src="https://cdn.itbob.cn/img/article/070/03.png" alt="03"></p><p><img src="https://cdn.itbob.cn/img/article/070/04.png" alt="04"></p><p><code>captcha/verify</code> 接口，提交验证，<code>xx-tt-dd</code> 为定值，<code>captchaBody</code> 是重点，通过 vmp 将轨迹等参数进行了加密处理，返回值 code 为 200 则表示通过。</p><p><img src="https://cdn.itbob.cn/img/article/070/05.png" alt="05"></p><p><img src="https://cdn.itbob.cn/img/article/070/06.png" alt="06"></p><h2><span id="can-shu-ni-xiang">参数逆向</span></h2><p>其他参数没啥可讲的，很简单，这里讲一下 <code>fp</code> 和 <code>captchaBody</code>。</p><h3><span id="fp">fp</span></h3><p><code>fp</code> 参数可以下个 XHR 断点，然后往前跟栈，栈可能有点多，但可以发现主要逻辑都在 <code>captcha.js</code> 里，同时 <code>fp</code> 参数前面有固定字符串 <code>verify_</code>，所以可以直接搜索这个字符串就能找到生成的位置。</p><p><img src="https://cdn.itbob.cn/img/article/070/07.png" alt="07"></p><p><img src="https://cdn.itbob.cn/img/article/070/08.png" alt="08"></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">k</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> e = <span class="hljs-string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;</span>.split(<span class="hljs-string">&quot;&quot;</span>)    , t = e.length    , n = (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>).getTime().toString(<span class="hljs-number">36</span>)    , r = [];    r[<span class="hljs-number">8</span>] = r[<span class="hljs-number">13</span>] = r[<span class="hljs-number">18</span>] = r[<span class="hljs-number">23</span>] = <span class="hljs-string">&quot;_&quot;</span>,        r[<span class="hljs-number">14</span>] = <span class="hljs-string">&quot;4&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> o, i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">36</span>; i++)        r[i] || (o = <span class="hljs-number">0</span> | <span class="hljs-built_in">Math</span>.random() * t,                 r[i] = e[<span class="hljs-number">19</span> == i ? <span class="hljs-number">3</span> &amp; o | <span class="hljs-number">8</span> : o]);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;verify_&quot;</span> + n + <span class="hljs-string">&quot;_&quot;</span> + r.join(<span class="hljs-string">&quot;&quot;</span>)&#125;</code></pre><p>除此之外，前面已经提到过了，cookie 里的 <code>s_v_web_id</code> 值也就是 <code>fp</code> 的值，所以还可以通过 Hook cookie 的方法来快速定位。</p><p><img src="https://cdn.itbob.cn/img/article/070/09.png" alt="09"></p><h3><span id="captchabody">captchaBody</span></h3><p><code>captchaBody</code> 是字节滑块的重点，跟栈可以发现主要逻辑在 <code>captcha.js</code> 里。</p><p><img src="https://cdn.itbob.cn/img/article/070/10.png" alt="10"></p><p>从最后一个 <code>captcha.js</code> 的栈开始，也就是 send 方法这里，可以看到 f 就是 <code>captchaBody</code>，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/070/11.png" alt="11"></p><p>再往上走几步，就可以看到和 <code>X-Bogus</code> 一毛一样的 VMP 了，下图中的 w 就有 <code>captchaBody</code> 的值：</p><p><img src="https://cdn.itbob.cn/img/article/070/12.png" alt="12"></p><p>然后就正式进入插桩找逻辑的流程了，和之前 <code>X-Bogus</code> 一样，在两个大的 if 这里下日志断点：</p><p><img src="https://cdn.itbob.cn/img/article/070/13.png" alt="13"></p><p><img src="https://cdn.itbob.cn/img/article/070/14.png" alt="14"></p><p>这里就有很多细节了，首先是为什么这么多 <code>if</code>、<code>return undefined</code>，这是为了防止循环引用导致异常，有异常日志就不能正常输出，导致缺失一部分日志，下图可以解释这一现象：</p><p><img src="https://cdn.itbob.cn/img/article/070/15.png" alt="15"></p><p>还有就是我怎么知道 <code>key == '13'</code> 等等就会发生异常呢？当然一开始并不知道，不加这些 if，在控制台会看到一些报错，每一个报错修复一下就多了这些 if 判断了。</p><p><img src="https://cdn.itbob.cn/img/article/070/16.png" alt="16"></p><p>关于这个日志断点的写法，之前 <code>X-Bogus</code> 的文章有非常详细的介绍，当然这个写法多种多样的，可能还有更优的写法，能实现目标就行，这里就不再啰嗦了。</p><p>还有一个细节就是 <code>位置 2-1</code> 和 <code>位置 2-2</code>，通过调试、观察、搜索可以发现 VMP 一共有七处，在不知道到底在哪个 VMP 生成 <code>captchaBody</code> 的情况下，可以在这七个地方都下日志断点，分别用位置 1 至 7 来区分。</p><p><img src="https://cdn.itbob.cn/img/article/070/17.png" alt="17"></p><p>当然也不能太死板，日志太多了也不好，比如第三个 VMP 的第二个 if 语句，也就是 <code>位置 3-2</code> 这里，日志会巨多，会给你卡死，这种就不要输出了，经过调试，大多数的逻辑在 <code>位置 7-2</code>，可以先从这里开始看。</p><p>滑动验证码，等待日志输出完毕，搜索 <code>captchaBody</code> 的值，看看第一次出现的位置是哪里，这里又双叒叕得注意，由于日志内容太长，控制台会自动折叠一部分，即便你右键 save 日志，折叠的部分也是没有的，在搜索的时候，折叠部分也不在搜索范围内，所以我们需要把折叠的展开，才能正确找到第一次出现的地方！</p><p>如下图所示，没展开之前搜索结果 34 个，第一次出现的位置是 <code>位置 7-2 索引C 0 索引S 2952 值w</code>：</p><p><img src="https://cdn.itbob.cn/img/article/070/18.png" alt="18"></p><p>展开之后搜索结果 63 个，第一次出现的位置是 <code>位置 7-2 索引C 10 索引S 2876 值w</code>，这个位置才是正确的地方：</p><p><img src="https://cdn.itbob.cn/img/article/070/19.png" alt="19"></p><p>注意啦，这个索引值，有可能并不是每个人都一样的，但按道理来讲只要 JS 文件一样，断点一样，这些索引值应该也是一样的，我这里的 JS 版本为：<a href="https://lf-cdn-tos.bytescm.com/obj/static/secsdk-captcha/cn2/2.26.17/captcha.js">https://lf-cdn-tos.bytescm.com/obj/static/secsdk-captcha/cn2/2.26.17/captcha.js</a></p><p>后续还是老套路，<strong>依次往上找每个值的第一次出现的位置，在相应的索引处下条件断点，然后单步跟逻辑</strong>，把每个参数都理清楚就行了，步骤有点多，后续我就直接展示最关键的步骤了，不需要什么高级技能，最重要的就是细心+耐心！</p><h4><span id="san-ge-shu-zu">三个数组</span></h4><p><code>位置 7-2 索引C 10 索引S 2876 值w</code>：第一次出现 captchaBody。</p><p><code>位置 7-2 索引C 4 索引S 2874 值w</code>：一个 Uint8Array 数组，先经过 <code>String.fromCharCode()</code> 方法将其转换为字符，再经过 <code>window.btoa()</code> 方法，也就是 base64 生成 captchaBody，我们将该数组称为<strong>数组 A</strong>。</p><p><img src="https://cdn.itbob.cn/img/article/070/20.png" alt="20"></p><p><code>位置 7-2 索引C 28 索引S 2792 值w</code>： 第一次出现完整 Uint8Array 数组 A。</p><p><code>位置 7-2 索引C 16 索引S 2790 值w</code>：两个 Uint8Array 数组合并组成数组 A。其中一个数组前 38 位有值，剩下的都是 0 填充，如下图所示的 g 值，另一个数组长度不一定，但通常是好几千，如下图所示的 m 值，我们将其称为<strong>数组 3</strong>。</p><p><img src="https://cdn.itbob.cn/img/article/070/21.png" alt="21"></p><p><code>位置 7-2 索引C 16 索引S 2750 值w</code>：两个 Uint8Array 数组合并组成上一步的 38 位数组，其中一个数组前 6 位有值，且为定值，剩下的都是 0 填充，如下图所示的 g 值，我们将其称为<strong>数组 1</strong>，另一个数组长度 32 位，如下图所示的 m 值，我们将其称为<strong>数组 2</strong>。</p><p><img src="https://cdn.itbob.cn/img/article/070/22.png" alt="22"></p><p>这段步骤附上我的分析日志：</p><pre><code class="hljs yaml"><span class="hljs-string">======================================</span> <span class="hljs-string">合并数组</span> <span class="hljs-number">1</span><span class="hljs-string">、2、3</span> <span class="hljs-string">======================================</span><span class="hljs-string">数组</span> <span class="hljs-number">1</span> <span class="hljs-string">为定值：[116,</span> <span class="hljs-number">99</span><span class="hljs-string">,</span> <span class="hljs-number">6</span><span class="hljs-string">,</span> <span class="hljs-number">16</span><span class="hljs-string">,</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-number">0</span><span class="hljs-string">]</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">16</span> <span class="hljs-string">索引S</span> <span class="hljs-number">2750</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">合并第1和第2数组</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">16</span> <span class="hljs-string">索引S</span> <span class="hljs-number">2790</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">合并第2和第3数组</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">28</span> <span class="hljs-string">索引S</span> <span class="hljs-number">2792</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">第一次出现完整大数组</span> <span class="hljs-string">A</span><span class="hljs-string">======================================</span> <span class="hljs-string">生成</span> <span class="hljs-string">captchaBody</span> <span class="hljs-string">======================================</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">4</span>  <span class="hljs-string">索引S</span> <span class="hljs-number">2874</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">E(大数组</span> <span class="hljs-string">A)</span> <span class="hljs-string">=&gt;</span> <span class="hljs-string">btoa(大数组)</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">10</span> <span class="hljs-string">索引S</span> <span class="hljs-number">2876</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">第一次出现</span> <span class="hljs-string">captchaBody</span></code></pre><p><strong>总结一下三个数组处理逻辑：</strong></p><pre><code class="hljs text">数组 1：6 位，定值 [116, 99, 6, 16, 0, 0]；数组 2：32 位；数组 3：数组长度不一定，但通常是好几千；数组 A：由 数组1 + 数组2 + 数组3 组成；captchaBody：由数组 A 先经过 String.fromCharCode() 方法转换为字符，再由 base64 编码得到。</code></pre><p>数组 1 是定值，所以接下来只需要查找数组 2、3 是怎么来的就行了。</p><h4><span id="shu-zu-2-32-wei">数组 2（32位）</span></h4><p>先看数组 2，也就是 32 位的这个数组怎么来的。</p><p><code>位置 7-2 索引C 29 索引S 2526 值w</code>：第一次出现数组 2。</p><p><code>位置 7-2 索引C 4  索引S 2524 值w</code>：将一个 32 位长度的字符串，每一个字符转换成对应的 Unicode 编码，得到数组 2。</p><p><img src="https://cdn.itbob.cn/img/article/070/23.png" alt="23"></p><p>然后就是往上找这个 32 位字符串怎么来的，这里就直接贴上我找的日志：</p><pre><code class="hljs yaml"><span class="hljs-string">======================================</span> <span class="hljs-string">数组</span> <span class="hljs-number">2</span> <span class="hljs-string">逻辑======================================</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">16</span> <span class="hljs-string">索引S</span> <span class="hljs-number">880</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">w[2]</span> <span class="hljs-string">=</span> <span class="hljs-string">Math.random()</span>     <span class="hljs-string">=&gt;</span>  <span class="hljs-number">0.09380310471283848</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">24</span> <span class="hljs-string">索引S</span> <span class="hljs-number">882</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">w[3]</span> <span class="hljs-string">=</span> [<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span><span class="hljs-string">...&#x27;y&#x27;</span>,<span class="hljs-string">&#x27;z&#x27;</span>]  <span class="hljs-string">=&gt;</span>  <span class="hljs-number">0</span><span class="hljs-number">-9</span><span class="hljs-string">、A-Z、a-z</span> <span class="hljs-string">组成</span> <span class="hljs-number">62</span> <span class="hljs-string">位数组</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">30</span> <span class="hljs-string">索引S</span> <span class="hljs-number">886</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">w[3]</span> <span class="hljs-string">=</span> <span class="hljs-string">w[3].length</span> <span class="hljs-string">=</span> <span class="hljs-number">62</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">42</span> <span class="hljs-string">索引S</span> <span class="hljs-number">892</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">w[2]</span> <span class="hljs-string">=</span> <span class="hljs-string">w[3]</span> <span class="hljs-string">*</span> <span class="hljs-string">w[2]</span>       <span class="hljs-string">=&gt;</span>  <span class="hljs-number">62</span> <span class="hljs-string">*</span> <span class="hljs-number">0.09380310471283848</span> <span class="hljs-string">=</span> <span class="hljs-number">5.815792492195985</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">48</span> <span class="hljs-string">索引S</span> <span class="hljs-number">894</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">w[1]</span> <span class="hljs-string">=</span> <span class="hljs-string">w[1]</span> <span class="hljs-string">|</span> <span class="hljs-string">w[2]</span>       <span class="hljs-string">=&gt;</span>  <span class="hljs-number">0</span> <span class="hljs-string">|</span> <span class="hljs-number">5.815792492195985</span> <span class="hljs-string">=</span> <span class="hljs-number">5</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">31</span> <span class="hljs-string">索引S</span> <span class="hljs-number">896</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">y</span> <span class="hljs-string">=</span> <span class="hljs-string">w[1],</span> <span class="hljs-string">l[10]</span> <span class="hljs-string">=</span> <span class="hljs-string">w[y]</span>   <span class="hljs-string">=&gt;</span>  <span class="hljs-string">l[10]</span> <span class="hljs-string">=</span> <span class="hljs-number">5</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">24</span> <span class="hljs-string">索引S</span> <span class="hljs-number">900</span> <span class="hljs-string">值w:</span> <span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">24</span> <span class="hljs-string">索引S</span> <span class="hljs-number">904</span> <span class="hljs-string">值w:</span> <span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">24</span> <span class="hljs-string">索引S</span> <span class="hljs-number">908</span> <span class="hljs-string">值w:</span> <span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">24</span> <span class="hljs-string">索引S</span> <span class="hljs-number">912</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">y</span> <span class="hljs-string">=</span> <span class="hljs-string">l[10],</span> <span class="hljs-string">w[4]</span> <span class="hljs-string">=</span> <span class="hljs-string">y</span>      <span class="hljs-string">=&gt;</span>  <span class="hljs-string">w[4]</span> <span class="hljs-string">=</span> <span class="hljs-number">5</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">25</span> <span class="hljs-string">索引S</span> <span class="hljs-number">916</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">w[3]</span> <span class="hljs-string">=</span> <span class="hljs-string">w[3][w[4]]</span>        <span class="hljs-string">=&gt;</span>  <span class="hljs-string">w[3]</span> <span class="hljs-string">=</span> [<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span><span class="hljs-string">...&#x27;y&#x27;</span>,<span class="hljs-string">&#x27;z&#x27;</span>][<span class="hljs-number">5</span>] <span class="hljs-string">=</span> <span class="hljs-string">&#x27;5&#x27;</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">13</span> <span class="hljs-string">索引S</span> <span class="hljs-number">918</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">w[1][0]</span> <span class="hljs-string">=</span> <span class="hljs-string">w[3]</span>           <span class="hljs-string">=&gt;</span>  <span class="hljs-string">w[1]</span> <span class="hljs-string">=</span> [<span class="hljs-string">&#x27;5&#x27;</span>]<span class="hljs-string">上述步骤一直重复，w[1][0]</span> <span class="hljs-string">=</span> <span class="hljs-string">w[3]、w[1][1]</span> <span class="hljs-string">=</span> <span class="hljs-string">w[3]、</span> <span class="hljs-string">w[1][2]</span> <span class="hljs-string">=</span> <span class="hljs-string">w[3]</span> <span class="hljs-string">以此类推</span><span class="hljs-string">直到</span> <span class="hljs-string">w[1]</span> <span class="hljs-string">累积成一个</span> <span class="hljs-number">32</span> <span class="hljs-string">位数组后：[&quot;5&quot;,&quot;B&quot;,&quot;q&quot;,&quot;j&quot;,&quot;3&quot;,...,&quot;T&quot;,&quot;Z&quot;,&quot;v&quot;,&quot;K&quot;,&quot;j&quot;]</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">16</span> <span class="hljs-string">索引S</span> <span class="hljs-number">966</span>  <span class="hljs-string">值w:</span>  <span class="hljs-string">g.join(m)</span>  <span class="hljs-string">=&gt;</span>  [<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;q&quot;</span>,<span class="hljs-string">&quot;j&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">...</span>,<span class="hljs-string">&quot;T&quot;</span>,<span class="hljs-string">&quot;Z&quot;</span>,<span class="hljs-string">&quot;v&quot;</span>,<span class="hljs-string">&quot;K&quot;</span>,<span class="hljs-string">&quot;j&quot;</span>]<span class="hljs-string">.join(&quot;&quot;)</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">4</span>  <span class="hljs-string">索引S</span> <span class="hljs-number">2524</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">E(m)</span>       <span class="hljs-string">=&gt;</span>  <span class="hljs-string">v(&quot;5Bqj3BmgfWfa7W6AnapzbdqbO0lTZvKj&quot;)</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">29</span> <span class="hljs-string">索引S</span> <span class="hljs-number">2526</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">第一次出现数组</span> <span class="hljs-number">2</span></code></pre><p><strong>归纳一下数组 2 的生成步骤：</strong></p><pre><code class="hljs text">Math.random() 方法生成一个随机数；生成一个由 0-9、A-Z、a-z 组成 62 位数组 [&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;...&#x27;y&#x27;,&#x27;z&#x27;]；取 62 位数组的长度为定值 62；0 | 62 * 随机数，得到一个整数；上一步整数当作索引，取 62 位数组里的一个元素，放到一个新数组里；重复以上步骤，直到取了 32 个元素，即新数组长度为 32；将新 32 位数组经过 .join(&quot;&quot;) 方法转换为 32 位的字符串；将 32 位字符串，每一个字符转换成对应的 Unicode 编码，得到数组 2</code></pre><p>进一步总结：<strong>实际上这么多骚操作，就是在  62 位数组里随机取值，组成 32 位字符串，再转 Unicode 就行了</strong>，本地复现很简单：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRandomStr</span>(<span class="hljs-params">count</span>) </span>&#123;    <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;G&quot;</span>,<span class="hljs-string">&quot;H&quot;</span>,<span class="hljs-string">&quot;I&quot;</span>,<span class="hljs-string">&quot;J&quot;</span>,<span class="hljs-string">&quot;K&quot;</span>,<span class="hljs-string">&quot;L&quot;</span>,<span class="hljs-string">&quot;M&quot;</span>,<span class="hljs-string">&quot;N&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;P&quot;</span>,<span class="hljs-string">&quot;Q&quot;</span>,<span class="hljs-string">&quot;R&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;T&quot;</span>,<span class="hljs-string">&quot;U&quot;</span>,<span class="hljs-string">&quot;V&quot;</span>,<span class="hljs-string">&quot;W&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;Y&quot;</span>,<span class="hljs-string">&quot;Z&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>,<span class="hljs-string">&quot;g&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;i&quot;</span>,<span class="hljs-string">&quot;j&quot;</span>,<span class="hljs-string">&quot;k&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;m&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;q&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,<span class="hljs-string">&quot;s&quot;</span>,<span class="hljs-string">&quot;t&quot;</span>,<span class="hljs-string">&quot;u&quot;</span>,<span class="hljs-string">&quot;v&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>,<span class="hljs-string">&quot;z&quot;</span>];    <span class="hljs-keyword">var</span> i = arr.length, min = i - count, index;    <span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">while</span> (i-- &gt; min) &#123;        index = <span class="hljs-built_in">Math</span>.floor((i + <span class="hljs-number">1</span>) * <span class="hljs-built_in">Math</span>.random());        str += arr[index]    &#125;    <span class="hljs-keyword">return</span> str&#125;<span class="hljs-keyword">var</span> randomStr = getRandomStr(<span class="hljs-number">32</span>)<span class="hljs-keyword">var</span> array2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(Buffer.from(randomStr));</code></pre><h4><span id="shu-zu-3-shang-qian-wei">数组 3（上千位）</span></h4><p>再来看数组 3，也就是有好几千位的这个数组怎么来的。</p><p><code>位置 7-2 索引C 31 索引S 614 值w</code>：第一次出现数组 3，到这里就可以看到有 <code>AES</code> 相关字样，稍微往前翻翻还能看到 <code>AES-GCM</code>、<code>iv</code>、<code>key</code> 等字样，这里其实就可以大胆猜测一下了，这个数组 3 的长度很长但不是固定的，肯定是和轨迹之类的有关，会随着轨迹的长短变化而变化，中间还可能用到了 AES 或者 AES-GCM 加密算法。</p><p><img src="https://cdn.itbob.cn/img/article/070/24.png" alt="24"></p><p><img src="https://cdn.itbob.cn/img/article/070/25.png" alt="25"></p><p>这里直接搜索这个数组 3，会发现就只有这一个结果，那么就看上一步，下条件断点看看。</p><p><code>位置 7-2 索引C 26 索引S 610 值w</code>：这里的 w[1] 为 <code>Uint8Array()</code> 方法，w[2] 为 <code>ArrayBuffer</code> 对象，<code>new Uint8Array(ArrayBuffer) </code> 就得到数组 3 了。</p><p><img src="https://cdn.itbob.cn/img/article/070/26.png" alt="26"></p><p>接下来的重点就是找一下 <code>ArrayBuffer</code> 对象怎么来的，这个对象在日志里是搜索不到的（当然也可以改一下日志的写法，判断一下类型，是 <code>ArrayBuffer</code> 对象的话，给它转成 <code>Uint8Array</code> 打印出来，不过太麻烦了没这必要），一般的思路是按照打印的日志，挨个往上找，看看在哪里生成这个 <code>ArrayBuffer</code>，不过这样稍稍有点儿麻烦，下面介绍一个取巧的思路。</p><p>观察日志，<code>位置 7-2 索引C 31 索引S 614 值w</code> 这个地方是第一次出现数组 3 的地方，往前几步，<code>位置 7-2 索引C 0 索引S 642 值w</code> 这个地方又有一个大数组，我们称其为<strong>数组 3-A</strong>，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/070/27.png" alt="27"></p><p>大胆猜测 <code>ArrayBuffer</code> 的生成，与数组 3-A 有关，接下来的思路就是从数组 3-A 第一次出现的地方开始，一直单步跟，看能不能生成，以及怎么生成 <code>ArrayBuffer</code> 的。</p><p><code>位置 7-2 索引C 10 索引S 568 值w</code>：第一次出现数组 3-A。</p><p><code>位置 7-2 索引C 16 索引S 574 值w</code>：这里出现了 <code>SubtleCrypto.encrypt()</code> 方法，查一下文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/SubtleCrypto">https://developer.mozilla.org/zh-CN/docs/Web/API/SubtleCrypto</a> ，可以知道这里就是使用了 AES-GCM 加密算法，返回的是一个 <code>Promise</code> 异步对象，而加密的对象正是数组 3-A，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/070/28.png" alt="28"></p><p><code>位置 7-2 索引C 16 索引S 640 值w</code>：走到这里的时候 <code>Promise.then()</code> 将 AES-GCM 加密结果给到 <code>arguments</code>，这里第一次出现了 <code>ArrayBuffer</code>，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/070/29.png" alt="29"></p><p><img src="https://cdn.itbob.cn/img/article/070/30.png" alt="30"></p><p>确定了是 AES-GCM 加密，我们本地应该怎样实现呢？这里给出 JS 和 Python 版本的实现方法（PS：不知道怎么实现建议直接问 ChatGPT）：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aesEncrypt</span>(<span class="hljs-params">text, key, iv</span>) </span>&#123;    <span class="hljs-comment">// 创建加密器</span>    <span class="hljs-keyword">const</span> cipher = Crypto.createCipheriv(<span class="hljs-string">&#x27;aes-256-gcm&#x27;</span>, key, iv);    <span class="hljs-comment">// 加密明文</span>    <span class="hljs-keyword">const</span> ciphertextPart1 = cipher.update(text, <span class="hljs-string">&#x27;utf8&#x27;</span>);    <span class="hljs-keyword">const</span> ciphertextPart2 = cipher.final();    <span class="hljs-comment">// 获取 GCM 校验值</span>    <span class="hljs-keyword">const</span> tag = cipher.getAuthTag();    <span class="hljs-comment">// 将加密结果和 GCM 校验值拼接</span>    <span class="hljs-keyword">const</span> ciphertext = Buffer.concat([ciphertextPart1, ciphertextPart2, tag]);    <span class="hljs-keyword">return</span> ciphertext;&#125;<span class="hljs-keyword">const</span> key = Buffer.from(<span class="hljs-string">&#x27;adaae7a5ef9f301a445888beb9205be2f83660246b8153d8a677794e0d2af7de&#x27;</span>, <span class="hljs-string">&#x27;hex&#x27;</span>)<span class="hljs-keyword">const</span> iv = Buffer.from(<span class="hljs-string">&#x27;b963490c4e5b50bce2c77d06&#x27;</span>, <span class="hljs-string">&#x27;hex&#x27;</span>)<span class="hljs-keyword">const</span> plaintext = <span class="hljs-string">&#x27;This is a secret message.&#x27;</span>;<span class="hljs-keyword">const</span> encryptedData = aesEncrypt(plaintext, key, iv)<span class="hljs-built_in">console</span>.log(encryptedData)<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(encryptedData))<span class="hljs-built_in">console</span>.log(encryptedData.toString(<span class="hljs-string">&#x27;hex&#x27;</span>))</code></pre><pre><code class="hljs python"><span class="hljs-keyword">from</span> binascii <span class="hljs-keyword">import</span> hexlify<span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AESkey = <span class="hljs-built_in">bytes</span>.fromhex(<span class="hljs-string">&#x27;adaae7a5ef9f301a445888beb9205be2f83660246b8153d8a677794e0d2af7de&#x27;</span>)nonce = <span class="hljs-built_in">bytes</span>.fromhex(<span class="hljs-string">&#x27;b963490c4e5b50bce2c77d06&#x27;</span>)plaintext = <span class="hljs-string">b&#x27;This is a secret message.&#x27;</span>crypto = AES.new(key=key, mode=AES.MODE_GCM, nonce=nonce)ciphertext, tag = crypto.encrypt_and_digest(plaintext)encrypted_data = hexlify(ciphertext + tag).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<span class="hljs-built_in">print</span>(encrypted_data)</code></pre><p>走到这儿了，我们还需要搞定三个东西：AES-GCM 的 key 和 iv，以及被加密对象数组 3-A 是怎么来的。套路都是一样的，这里我也直接贴上我的分析笔记了：</p><pre><code class="hljs yaml"><span class="hljs-string">======================================</span> <span class="hljs-string">数组</span> <span class="hljs-number">3</span> <span class="hljs-string">逻辑======================================</span><span class="hljs-string">//</span> <span class="hljs-string">AES-GCM</span> <span class="hljs-string">key、iv</span> <span class="hljs-string">逻辑</span>           <span class="hljs-string">位置</span> <span class="hljs-number">6</span><span class="hljs-number">-1</span> <span class="hljs-string">索引C</span> <span class="hljs-number">2</span>  <span class="hljs-string">索引S</span> <span class="hljs-number">184</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">String.fromCharCode</span> <span class="hljs-string">生成</span> <span class="hljs-number">128</span> <span class="hljs-string">位字符串</span> <span class="hljs-string">s4,</span> <span class="hljs-string">为固定值</span>  <span class="hljs-string">=&gt;</span>  <span class="hljs-string">4dd4c2e6b83...38aadd58</span><span class="hljs-string">位置</span> <span class="hljs-number">6</span><span class="hljs-number">-1</span> <span class="hljs-string">索引C</span> <span class="hljs-number">31</span> <span class="hljs-string">索引S</span> <span class="hljs-number">190</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">第一次出现固定</span> <span class="hljs-number">128</span> <span class="hljs-string">位字符串</span> <span class="hljs-string">s4</span><span class="hljs-string">位置</span> <span class="hljs-number">6</span><span class="hljs-number">-1</span> <span class="hljs-string">索引C</span> <span class="hljs-number">4</span>  <span class="hljs-string">索引S</span> <span class="hljs-number">206</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">SHA512(前面数组</span> <span class="hljs-number">2</span> <span class="hljs-string">里的随机字符串)</span>  <span class="hljs-string">=&gt;</span>  <span class="hljs-string">SHA512(&quot;5Bqj3BmgfWfa7W6AnapzbdqbO0lTZvKj&quot;)</span> <span class="hljs-string">生成数组</span> <span class="hljs-number">3</span><span class="hljs-string">-D3</span><span class="hljs-string">位置</span> <span class="hljs-number">6</span><span class="hljs-number">-1</span> <span class="hljs-string">索引C</span> <span class="hljs-number">34</span> <span class="hljs-string">索引S</span> <span class="hljs-number">208</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">第一次出现数组</span> <span class="hljs-number">3</span><span class="hljs-string">-D3</span><span class="hljs-string">位置</span> <span class="hljs-number">6</span><span class="hljs-number">-1</span> <span class="hljs-string">索引C</span> <span class="hljs-number">16</span> <span class="hljs-string">索引S</span> <span class="hljs-number">232</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">数组</span> <span class="hljs-number">3</span><span class="hljs-string">-D3.toString()</span> <span class="hljs-string">生成字符串</span> <span class="hljs-string">s3</span><span class="hljs-string">位置</span> <span class="hljs-number">6</span><span class="hljs-number">-1</span> <span class="hljs-string">索引C</span> <span class="hljs-number">31</span> <span class="hljs-string">索引S</span> <span class="hljs-number">234</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">第一次出现字符串</span> <span class="hljs-string">s3</span><span class="hljs-string">位置</span> <span class="hljs-number">6</span><span class="hljs-number">-1</span> <span class="hljs-string">索引C</span> <span class="hljs-number">40</span> <span class="hljs-string">索引S</span> <span class="hljs-number">246</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">字符串</span> <span class="hljs-string">s3</span> <span class="hljs-string">+</span> <span class="hljs-string">字符串</span> <span class="hljs-string">s4</span> <span class="hljs-string">得到长字符串</span> <span class="hljs-string">s2</span><span class="hljs-string">位置</span> <span class="hljs-number">6</span><span class="hljs-number">-1</span> <span class="hljs-string">索引C</span> <span class="hljs-number">16</span> <span class="hljs-string">索引S</span> <span class="hljs-number">280</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">CryptoJS.enc.Hex.parse(长字符串</span> <span class="hljs-string">s2)</span> <span class="hljs-string">得到数组</span> <span class="hljs-number">3</span><span class="hljs-string">-D2</span><span class="hljs-string">位置</span> <span class="hljs-number">6</span><span class="hljs-number">-1</span> <span class="hljs-string">索引C</span> <span class="hljs-number">31</span> <span class="hljs-string">索引S</span> <span class="hljs-number">282</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">第一次出现数组</span> <span class="hljs-number">3</span><span class="hljs-string">-D2</span><span class="hljs-string">位置</span> <span class="hljs-number">6</span><span class="hljs-number">-1</span> <span class="hljs-string">索引C</span> <span class="hljs-number">4</span>  <span class="hljs-string">索引S</span> <span class="hljs-number">298</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">SHA512(数组</span> <span class="hljs-number">3</span><span class="hljs-string">-D2)</span> <span class="hljs-string">得到数组</span> <span class="hljs-number">3</span><span class="hljs-string">-D1</span><span class="hljs-string">位置</span> <span class="hljs-number">6</span><span class="hljs-number">-1</span> <span class="hljs-string">索引C</span> <span class="hljs-number">34</span> <span class="hljs-string">索引S</span> <span class="hljs-number">300</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">第一次出现数组</span> <span class="hljs-number">3</span><span class="hljs-string">-D1</span><span class="hljs-string">位置</span> <span class="hljs-number">6</span><span class="hljs-number">-1</span> <span class="hljs-string">索引C</span> <span class="hljs-number">16</span> <span class="hljs-string">索引S</span> <span class="hljs-number">324</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">数组</span> <span class="hljs-number">3</span><span class="hljs-string">-D1.toString()</span> <span class="hljs-string">生成长字符串</span> <span class="hljs-string">s1</span><span class="hljs-string">位置</span> <span class="hljs-number">6</span><span class="hljs-number">-1</span> <span class="hljs-string">索引C</span> <span class="hljs-number">31</span> <span class="hljs-string">索引S</span> <span class="hljs-number">326</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">第一次出现长字符串</span> <span class="hljs-string">s1</span><span class="hljs-string">位置</span> <span class="hljs-number">6</span><span class="hljs-number">-1</span> <span class="hljs-string">索引C</span> <span class="hljs-number">16</span> <span class="hljs-string">索引S</span> <span class="hljs-number">450</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">key</span> <span class="hljs-string">=</span> <span class="hljs-string">长字符串</span> <span class="hljs-string">s1.substring(0,</span> <span class="hljs-number">64</span><span class="hljs-string">)</span><span class="hljs-string">位置</span> <span class="hljs-number">6</span><span class="hljs-number">-1</span> <span class="hljs-string">索引C</span> <span class="hljs-number">16</span> <span class="hljs-string">索引S</span> <span class="hljs-number">484</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">iv</span> <span class="hljs-string">=</span> <span class="hljs-string">长字符串</span> <span class="hljs-string">s1.substring(64,</span> <span class="hljs-number">88</span><span class="hljs-string">)</span><span class="hljs-string">//</span> <span class="hljs-string">数组</span> <span class="hljs-number">3</span> <span class="hljs-string">逻辑</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">16</span> <span class="hljs-string">索引S</span> <span class="hljs-number">1838</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">CryptoJS.enc.Utf8.parse(unescape(encodeURIComponent(JSON.stringify(轨迹))))</span> <span class="hljs-string">得到数组</span> <span class="hljs-number">3</span><span class="hljs-string">-C2</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">29</span> <span class="hljs-string">索引S</span> <span class="hljs-number">1840</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">第一次出现数组</span> <span class="hljs-number">3</span><span class="hljs-string">-C2</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">4</span>  <span class="hljs-string">索引S</span> <span class="hljs-number">1866</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">SHA512(JSON.stringify(轨迹))</span> <span class="hljs-string">得到数组</span> <span class="hljs-number">3</span><span class="hljs-string">-C1-1</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">34</span> <span class="hljs-string">索引S</span> <span class="hljs-number">1868</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">第一次出现数组</span> <span class="hljs-number">3</span><span class="hljs-string">-C1-1</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">16</span> <span class="hljs-string">索引S</span> <span class="hljs-number">1892</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">数组</span> <span class="hljs-number">3</span><span class="hljs-string">-C1-1.toString()</span> <span class="hljs-string">生成一个字符串</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">29</span> <span class="hljs-string">索引S</span> <span class="hljs-number">1894</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">第一次出现字符串</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">16</span> <span class="hljs-string">索引S</span> <span class="hljs-number">1936</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">CryptoJS.enc.Hex.parse</span> <span class="hljs-string">方法将字符串处理成数组</span> <span class="hljs-number">3</span><span class="hljs-string">-C1</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">29</span> <span class="hljs-string">索引S</span> <span class="hljs-number">1938</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">第一次出现数组</span> <span class="hljs-number">3</span><span class="hljs-string">-C1</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">16</span> <span class="hljs-string">索引S</span> <span class="hljs-number">1998</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">concat</span> <span class="hljs-string">方法拼接数组</span> <span class="hljs-number">3</span><span class="hljs-string">-C1</span> <span class="hljs-string">和数组</span> <span class="hljs-number">3</span><span class="hljs-string">-C2</span> <span class="hljs-string">得到数组</span> <span class="hljs-number">3</span><span class="hljs-string">-B</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">29</span> <span class="hljs-string">索引S</span> <span class="hljs-number">2000</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">第一次出现数组</span> <span class="hljs-number">3</span><span class="hljs-string">-B</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">16</span> <span class="hljs-string">索引S</span> <span class="hljs-number">564</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">数组</span> <span class="hljs-number">3</span><span class="hljs-string">-B</span> <span class="hljs-string">.toString()</span> <span class="hljs-string">生成一个大字符串</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">4</span>  <span class="hljs-string">索引S</span> <span class="hljs-number">566</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">大字符串经过</span> <span class="hljs-string">g()</span> <span class="hljs-string">方法生成数组</span> <span class="hljs-number">3</span><span class="hljs-string">-A</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">10</span> <span class="hljs-string">索引S</span> <span class="hljs-number">568</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">第一次出现数组</span> <span class="hljs-number">3</span><span class="hljs-string">-A</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">16</span> <span class="hljs-string">索引S</span> <span class="hljs-number">574</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">SubtleCrypto.encrypt()</span> <span class="hljs-string">=&gt;</span> <span class="hljs-string">AES-GCM</span> <span class="hljs-string">加密数组</span> <span class="hljs-number">3</span><span class="hljs-string">-A,</span> <span class="hljs-string">返回</span> <span class="hljs-string">Promise</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">34</span> <span class="hljs-string">索引S</span> <span class="hljs-number">576</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">w[2]</span> <span class="hljs-string">=</span> <span class="hljs-string">Promise</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">30</span> <span class="hljs-string">索引S</span> <span class="hljs-number">578</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">w[2]</span> <span class="hljs-string">=</span> <span class="hljs-string">Promise.then()</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">36</span> <span class="hljs-string">索引S</span> <span class="hljs-number">584</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">y</span> <span class="hljs-string">=</span> <span class="hljs-string">w[2],</span> <span class="hljs-string">w[2]</span> <span class="hljs-string">=</span> <span class="hljs-string">w[1],</span> <span class="hljs-string">w[1]</span> <span class="hljs-string">=</span> <span class="hljs-string">y</span>  <span class="hljs-string">=&gt;</span> <span class="hljs-string">w[1]</span> <span class="hljs-string">=</span> <span class="hljs-string">Promise.then(),</span> <span class="hljs-string">w[2]</span> <span class="hljs-string">=</span> <span class="hljs-string">Promise</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">2</span>  <span class="hljs-string">索引S</span> <span class="hljs-number">586</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">w[3]</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">37</span> <span class="hljs-string">索引S</span> <span class="hljs-number">592</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">w[3]</span> <span class="hljs-string">=</span> <span class="hljs-string">t()</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">10</span> <span class="hljs-string">索引S</span> <span class="hljs-number">634</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">w[3]</span> <span class="hljs-string">=</span> [<span class="hljs-string">t()</span>]<span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">16</span> <span class="hljs-string">索引S</span> <span class="hljs-number">640</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">执行</span> <span class="hljs-string">Promise.then(),</span> <span class="hljs-string">加密结果赋值给</span> <span class="hljs-string">t()</span> <span class="hljs-string">里的</span> <span class="hljs-string">arguments,</span> <span class="hljs-string">第一次出现</span> <span class="hljs-string">ArrayBuffer</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">0</span>  <span class="hljs-string">索引S</span> <span class="hljs-number">642</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">最后一次出现数组</span> <span class="hljs-number">3</span><span class="hljs-string">-A</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">27</span> <span class="hljs-string">索引S</span> <span class="hljs-number">598</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">没啥用</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">11</span> <span class="hljs-string">索引S</span> <span class="hljs-number">602</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">没啥用</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">24</span> <span class="hljs-string">索引S</span> <span class="hljs-number">606</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">没啥用</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">26</span> <span class="hljs-string">索引S</span> <span class="hljs-number">610</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">new</span> <span class="hljs-string">w[1](w[2])</span> <span class="hljs-string">=&gt;</span> <span class="hljs-string">new</span> <span class="hljs-string">Uint8Array(ArrayBuffer)</span><span class="hljs-string">位置</span> <span class="hljs-number">7</span><span class="hljs-number">-2</span> <span class="hljs-string">索引C</span> <span class="hljs-number">31</span> <span class="hljs-string">索引S</span> <span class="hljs-number">614</span> <span class="hljs-string">值w:</span>  <span class="hljs-string">第一次出现数组</span> <span class="hljs-number">3</span></code></pre><p>以上日志中涉及到的部分方法：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">u</span>(<span class="hljs-params">e</span>) </span>&#123;  <span class="hljs-keyword">var</span> t = e.map;  <span class="hljs-keyword">return</span> e === <span class="hljs-built_in">Array</span>.prototype || e <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> &amp;&amp; t === <span class="hljs-built_in">Array</span>.prototype.map ? t : t&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">g</span>(<span class="hljs-params">e</span>) </span>&#123;  <span class="hljs-keyword">var</span> t;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(u(t = e.match(<span class="hljs-regexp">/[\da-f]&#123;2&#125;/gi</span>)).call(t, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(e, <span class="hljs-number">16</span>)  &#125;))&#125;</code></pre><p><strong>总结一下数组 3 的生成步骤：</strong></p><pre><code class="hljs text">固定字符串 4dd4c2e6b83...38aadd58 + SHA512(数组 2 里的随机字符串) 组成一个长字符串 s2；SHA512(CryptoJS.enc.Hex.parse(长字符串 s2)).toString() 得到长字符串 s1；AES-GCM key 的值为：长字符串 s1.substring(0, 64)；AES-GCM iv 的值为：长字符串 s1.substring(64, 88)；CryptoJS.enc.Utf8.parse(unescape(encodeURIComponent(JSON.stringify(轨迹)))) 得到数组 3-C2；CryptoJS.enc.Hex.parse(SHA512(JSON.stringify(轨迹)).toString()) 得到 数组 3-C1；数组 3-C1.concat(数组 3-C2)得到数组 3-B；g(数组 3-B.toString()) 得到数组 3-A；new Uint8Array(AES-GCM 加密数组 3-A) 得到数组 3。</code></pre><p>至此，captchaBody 的逻辑就找完了，还是比较简单的，现在就缺一个轨迹参数了。</p><h3><span id="gui-ji-sheng-cheng">轨迹生成</span></h3><p>根据我们前面的分析日志可知，数组 3 的生成逻辑中，<code>位置 7-2 索引C 16 索引S 1838 值w</code> 和 <code>位置 7-2 索引C 4  索引S 1866 值w</code> 这两个地方对轨迹进行了加密，先将轨迹 copy 下来看看结构。</p><p><img src="https://cdn.itbob.cn/img/article/070/31.png" alt="31"></p><p><img src="https://cdn.itbob.cn/img/article/070/32.png" alt="32"></p><p><code>modified_img_width</code>、<code>detRes</code> 为定值，<code>id</code> 为 <code>captcha/get</code> 接口返回的，然后主要就是 <code>reply</code> 和 <code>reply2</code>、<code>models</code> 和 <code>models2</code> 以及 <code>log_params</code>。</p><p>轨迹里主要有两个记录点：</p><p><code>位置 4-1 索引j 0 索引C 2584 值x</code>：记录鼠标在验证码区域移动的轨迹，该轨迹为 <code>models[&quot;z&quot;]</code> 的值。</p><p><code>位置 4-1 索引j 0 索引C 1776 值x</code>：记录鼠标滑动滑块的轨迹，该轨迹为 <code>reply</code> 的值，根据缺口距离伪造就行了。</p><p><img src="https://cdn.itbob.cn/img/article/070/33.png" alt="33"></p><p><img src="https://cdn.itbob.cn/img/article/070/34.png" alt="34"></p><p><code>位置 4-1 索引j 29 索引C 2134 值x</code>：第一次出现 <code>models[&quot;x&quot;]</code>，大致为鼠标第一次进入验证码弹框区域的坐标。</p><p><code>位置 4-1 索引j 29 索引C 2098 值x</code>：第一次出现 <code>models[&quot;y&quot;]</code>，大致为鼠标最后一次进入验证码滑条区域的坐标。</p><p>而 <code>models[&quot;m&quot;]</code> 则可以在 <code>models[&quot;z&quot;]</code> 的基础上随机增减一些值即可，至此 <code>reply</code> 和 <code>models</code> 就处理完了，还有对应的 <code>reply2</code> 和 <code>models2</code>，都是在 <code>reply</code> 和 <code>models</code> 的基础上进行取值，自己找一下规律就可以了，也可以观察日志找一下怎么取值的，而 <code>log_params</code> 里，会有一些 <code>challenge_code</code> 等参数，都可以在之前的接口返回参数里找到值，<code>log_params</code> 里也有 <code>models</code> 和 <code>models2</code>，区别就在于 <code>log_params</code> 里的没有 <code>models[&quot;m&quot;]</code> 和 <code>models2[&quot;m&quot;]</code>，其他值都一样。</p><p>至此所有参数就都搞定了，<strong>还有一个细节需要注意一下，那就是提交验证太快了也不行，在请求 <code>captcha/verify</code> 接口之前睡眠两三秒就行了！</strong></p><h2><span id="jie-guo-yan-zheng">结果验证</span></h2><p>测试通过率在 98% 左右：</p><p><img src="https://cdn.itbob.cn/img/article/070/35.png" alt="35"></p><p>测试将通过验证码的 <code>fp</code> 值作为 cookie 的 <code>s_v_web_id</code>，可以免 <code>X-Bogus</code> 验证采集数据，以下是采集评论示例：</p><p><img src="https://cdn.itbob.cn/img/article/070/36.png" alt="36"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>数美验证全家桶逆向分析以及 AST 获取动态参数</title>
    <link href="https://www.itbob.cn/article/069/"/>
    <id>https://www.itbob.cn/article/069/</id>
    <published>2023-04-20T12:20:00.000Z</published>
    <updated>2023-04-20T12:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#mu-biao">目标</a></li><li><a href="#zhua-bao-fen-xi">抓包分析</a></li><li><a href="#ni-xiang-fen-xi">逆向分析</a><ul><li><a href="#captchauuid">captchaUuid</a></li><li><a href="#12-ge-jia-mi-can-shu">12 个加密参数</a></li></ul></li><li><a href="#jie-guo-yan-zheng">结果验证</a></li><li><a href="#ast-huo-qu-dong-tai-can-shu">AST 获取动态参数</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="mu-biao">目标</span></h2><ul><li>目标：数美全家桶，包括：滑块、文字点选、图标点选、语序点选、空间推理、无感验证</li><li>地址：</li></ul><pre><code class="hljs gcode"><span class="hljs-comment">// 官网体验地址</span>aHR<span class="hljs-number">0</span>cH<span class="hljs-name">M6</span>Ly<span class="hljs-number">93</span>d<span class="hljs-number">3</span>cuaX<span class="hljs-symbol">NodW1</span>laS<span class="hljs-number">5</span>jb<span class="hljs-number">20</span>vdHJpYWwvY<span class="hljs-number">2</span>FwdG<span class="hljs-symbol">NoYS5</span>od<span class="hljs-name">G1</span>s<span class="hljs-comment">// 官方隐藏地址</span>aHR<span class="hljs-number">0</span>cH<span class="hljs-name">M6</span>Ly<span class="hljs-number">9</span>jYX<span class="hljs-symbol">N0</span>YXRpYy<span class="hljs-number">5</span>mZW<span class="hljs-number">5</span><span class="hljs-symbol">na29</span>uZ<span class="hljs-number">2</span><span class="hljs-symbol">Nsb3</span>VkLm<span class="hljs-symbol">NuL3</span>ByL<span class="hljs-number">3</span>YxLjAu<span class="hljs-symbol">NC9</span>kZW<span class="hljs-number">1</span>vLmh<span class="hljs-number">0</span>bWw=<span class="hljs-comment">// 某红书验证页面</span>aHR<span class="hljs-number">0</span>cH<span class="hljs-name">M6</span>Ly<span class="hljs-number">93</span>d<span class="hljs-number">3</span>cueGlhb<span class="hljs-number">2</span>hvbmdzaHUuY<span class="hljs-number">29</span>tL<span class="hljs-number">3</span>dlYi<span class="hljs-number">1</span>sb<span class="hljs-number">2</span>dpbi<span class="hljs-number">9</span>jYXB<span class="hljs-number">0</span>Y<span class="hljs-number">2</span>hh</code></pre><p>数美不同类型验证码核心的 JS 都是一样的，只是个别参数有微小差别，主要以滑块为例来分析，通过 JS 代码以及官方文档可以看出数美是有无感验证的，但是官网体验地址里并没有放出来，官方有一个隐藏地址，里面的 demo 是最全的，包括无感，可以去上面给出的第二个地址里查看；数美的加密参数包含了 DES 加密算法，参数名以及 DES Key 不定时会变化，本文也会分析如何利用 AST 来获取动态的参数。</p><p><img src="https://cdn.itbob.cn/img/article/069/01.png" alt="01"></p><h2><span id="zhua-bao-fen-xi">抓包分析</span></h2><p><code>conf</code> 接口，获取配置，主要是获取核心的 <code>captcha-sdk.min.js</code> 的地址，请求参数解释：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>organization</code></td><td>数美分配的公司标识，一般是每个网站唯一，写死即可</td></tr><tr><td><code>appId</code></td><td>应用标识，区分不同应用，数美后台可以管理</td></tr><tr><td><code>callback</code></td><td>回调参数</td></tr><tr><td><code>lang</code></td><td>语言，<code>zh-cn</code> 简体中文、<code>zh-tw</code> 繁体中文、<code>en</code> 英文</td></tr><tr><td><code>model</code></td><td>模式，<code>slide</code> 滑块、<code>auto_slide</code> 无感验证、<code>select</code> 文字点选、<code>icon_select</code> 图标点选、<code>seq_select</code> 语序点选、<code>spatial_select</code> 空间推理</td></tr><tr><td><code>sdkver</code></td><td>这个 sdk 版本是 <code>captcha-sdk.min.js</code> 内部写死的</td></tr><tr><td><code>channel</code></td><td>推广渠道，数美后台可以管理</td></tr><tr><td><code>captchaUuid</code></td><td>32位随机字符串，与业务方自身埋点数据配合，便于后续定位问题或进行数据统计</td></tr><tr><td><code>rversion</code></td><td><code>captcha-sdk.min.js</code> 版本号</td></tr></tbody></table><p><img src="https://cdn.itbob.cn/img/article/069/02.png" alt="02"></p><p>返回结果重点看 <code>captcha-sdk.min.js</code> 文件地址，如下图所示有个 <code>v1.0.4-171</code>，本文中我们称 <code>v1.0.4</code> 为大版本，<code>171</code> 为小版本，小版本不定时会更新，版本号不断升高。</p><p><img src="https://cdn.itbob.cn/img/article/069/03.png" alt="03"></p><p>然后就是 <code>register</code> 接口，不同类型，返回的数据都大同小异，其中 <code>bg</code> 是背景图片，<code>fg</code> 是滑块，文字点选、空间推理中 <code>order</code> 是提示信息，<code>k</code>、<code>l</code>、<code>rid</code> 三个参数后续会用到。</p><p><img src="https://cdn.itbob.cn/img/article/069/04.png" alt="04"></p><p><img src="https://cdn.itbob.cn/img/article/069/05.png" alt="05"></p><p><img src="https://cdn.itbob.cn/img/article/069/06.png" alt="06"></p><p>最后就是 <code>fverify</code> 验证接口，有类似下图红框中的 12 个参数，都是通过 JS 生成的，其参数名会根据 <code>captcha-sdk.min.js</code> 的变化而变化，其中有个最长的类似于下图的 <code>ep</code> 值，包含了轨迹加密。返回值里参数解释：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>code</code></td><td><code>1100</code>：成功；<code>1901</code>：QPS超限；<code>1902</code>：参数不合法；<code>1903</code>：服务失败；<code>9101</code>：无权限操作</td></tr><tr><td><code>riskLevel</code></td><td>处置建议，<code>PASS</code>：正常，建议直接放行；<code>REJECT</code>：违规，建议直接拦截</td></tr></tbody></table><p><img src="https://cdn.itbob.cn/img/article/069/07.png" alt="07"></p><p><img src="https://cdn.itbob.cn/img/article/069/08.png" alt="08"></p><h2><span id="ni-xiang-fen-xi">逆向分析</span></h2><p>跟栈会发现核心逻辑在 <code>captcha-sdk.min.js</code> 里，这个 JS 类似于 OB 混淆（以前的文章介绍过，此处不再细说）：</p><p><img src="https://cdn.itbob.cn/img/article/069/09.png" alt="09"></p><p>这里可以自己写 AST 还原一下，为了方便我们直接使用 v_jstools 解混淆：</p><p><img src="https://cdn.itbob.cn/img/article/069/10.png" alt="10"></p><p>然后替换掉原来的 <code>captcha-sdk.min.js</code>，如果你测试的是官网的体验页面，使用 Fiddler 替换时要注意可能有跨域问题，需要利用 Filters 功能，设置响应头 <code>Access-Control-Allow-Origin</code> 字段值为当前域名：</p><p><img src="https://cdn.itbob.cn/img/article/069/11.png" alt="11"></p><p><img src="https://cdn.itbob.cn/img/article/069/12.png" alt="12"></p><p>如果你没注意到这个跨域问题，可能会替换之后发现没替换成功，原因是数美的资源有四个域名，其中一个宕了便会启用另一个，你替换其中一个报错了就会自动跳转另一个，所以看起来你并没有替换成功：</p><p><img src="https://cdn.itbob.cn/img/article/069/13.png" alt="13"></p><p><strong>PS：若替换的 JS 格式化了，那么你在网页上滑动也是校验失败的，因为 JS 里检测了格式化，将 JS 压缩成一行再替换即可，具体检测的位置后文会讲到。</strong></p><h3><span id="captchauuid">captchaUuid</span></h3><p>直接搜索关键词下断点，经过多次调试会发现第一个出现 <code>captchaUuid</code> 的地方是在 <code>smcp.min.js</code>，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/069/14.png" alt="14"></p><p>这里的栈并不多，来回跟栈也没发现是哪里生成的，此时可以从初始位置也就是 <code>embed.html</code> 初始化验证码的地方开始单步跟：</p><p><img src="https://cdn.itbob.cn/img/article/069/15.png" alt="15"></p><p>单步跟进去会发现一个 <code>getCaptchaUuid()</code> 的方法，将此方法扣出来即可。</p><p><img src="https://cdn.itbob.cn/img/article/069/16.png" alt="16"></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateTimeFormat</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()    , t = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;        <span class="hljs-keyword">return</span> +n &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span> + n : n.toString();    &#125;;    <span class="hljs-keyword">return</span> ((e.getFullYear().toString() + t(e.getMonth() + <span class="hljs-number">1</span>)) + t(e.getDate()) + t(e.getHours()) + t(e.getMinutes())) + t(e.getSeconds());&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCaptchaUuid</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> c = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">var</span> o = <span class="hljs-string">&quot;ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678&quot;</span>;    <span class="hljs-keyword">var</span> s = o.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">18</span>; a++) &#123;        c += o.charAt(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * s));    &#125;    <span class="hljs-keyword">return</span> generateTimeFormat() + c;&#125;</code></pre><h3><span id="12-ge-jia-mi-can-shu">12 个加密参数</span></h3><p>直接跟栈就很容易找到，如下图所示的位置，D 就是生成的所有参数，此外，也可以通过搜索关键字 <code>getEncryptContent</code> 或者直接搜索参数名称来定位。</p><p><img src="https://cdn.itbob.cn/img/article/069/17.png" alt="17"></p><p>可以发现上图里就有四个加密参数，都用到了 <code>getEncryptContent</code> 这个加密方法，加密方法传入两个参数，一个是待加密参数，一个是 DES Key，这四个待加密参数分别为 <code>appId</code> 值、<code>channel</code> 值、<code>lang</code> 值和一个 <code>getSafeParams</code> 方法。</p><p><img src="https://cdn.itbob.cn/img/article/069/18.png" alt="18"></p><p>重点跟进 <code>getEncryptContent</code> 方法看看，一个控制流，挑几个重点的讲一下，第一步是获取一个 <code>key</code>，这个 <code>key</code> 是在前面设置的，后续会讲到，实际上这个 <code>key</code> 没啥用。</p><p><img src="https://cdn.itbob.cn/img/article/069/19.png" alt="19"></p><p>然后会有一个 <code>isJsFormat</code> 的格式化检测函数，正常应该是 false 的，如果你格式化了就为 true，也就会导致 f 的值为时间戳加数美的域名，这个 f 值后续是 DES 的 Key，不对的话自然怎么滑都不会通过。</p><p><img src="https://cdn.itbob.cn/img/article/069/20.png" alt="20"></p><p>然后就是 DES  加密了，这个 DES 是标准的加密算法，下图中传入的 1 和 0 表示的是加密，0 和 0 则表示解密，解密的情况也有，后续会遇到，<code>mode</code> 为 <code>ECB</code>，<code>padding</code> 为 <code>ZeroPadding</code>，不需要 <code>iv</code>，可以直接扣代码，或者直接引库即可。</p><p><img src="https://cdn.itbob.cn/img/article/069/21.png" alt="21"></p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;crypto-js&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DESEncrypt</span>(<span class="hljs-params">key, word</span>) </span>&#123;    <span class="hljs-keyword">var</span> key_ = CryptoJS.enc.Utf8.parse(key);    <span class="hljs-keyword">var</span> srcs = CryptoJS.enc.Utf8.parse(word);    <span class="hljs-keyword">var</span> encrypted = CryptoJS.DES.encrypt(srcs, key_, &#123;        <span class="hljs-attr">mode</span>: CryptoJS.mode.ECB,        <span class="hljs-attr">padding</span>: CryptoJS.pad.ZeroPadding    &#125;);    <span class="hljs-keyword">return</span> encrypted.toString();&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DESDecrypt</span>(<span class="hljs-params">key, word</span>) </span>&#123;    <span class="hljs-keyword">var</span> key_ = CryptoJS.enc.Utf8.parse(key);    <span class="hljs-keyword">var</span> decrypt = CryptoJS.DES.decrypt(word, key_, &#123;        <span class="hljs-attr">mode</span>: CryptoJS.mode.ECB,        <span class="hljs-attr">padding</span>: CryptoJS.pad.ZeroPadding    &#125;);    <span class="hljs-keyword">return</span> decrypt.toString(CryptoJS.enc.Utf8);&#125;</code></pre><p>这里的四个值就分析完了，还有八个值是在前面生成的，如下图所示 x 的值即为其他八个值，往前看是一个函数生成的，往里面跟即可。</p><p><img src="https://cdn.itbob.cn/img/article/069/22.png" alt="22"></p><p>跟进来是一个 <code>getMouseAction</code> 方法，里面先是挨个取值，后续会对这些值进行 DES 加密，下图中的 a、c 参数就是 <code>register</code> 接口返回的 k、l 值，s 参数是对 <code>register</code> 接口返回的 k 值进行解密操作：</p><p><img src="https://cdn.itbob.cn/img/article/069/23.png" alt="23"></p><p>上图中 <code>u = this._data</code> 里面的值，根据滑块、点选、无感模式的不同，也有所差异，以下代码中，以 <code>baseData</code> 来表示 <code>this._data</code> 的值，根据模式的不同，可分为三类，大致构成如下：</p><p>滑块（<code>slide</code>）：</p><pre><code class="hljs javascript"><span class="hljs-comment">/* </span><span class="hljs-comment">track：滑动轨迹（x, y, t），distance：滑动距离，randomNum：生成两数之间的随机值，示例：</span><span class="hljs-comment">var track = [[0, -2, 0], [62, 1, 98], [73, 4, 205], [91, 3, 303], [123, -3, 397], [136, 8, 502], [160, 0, 599], [184, 0, 697], [169, 0, 797]]</span><span class="hljs-comment">var distance = 169</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> baseData = &#123;&#125;baseData.mouseData = trackbaseData.startTime = <span class="hljs-number">0</span>baseData.endTime = track[track.length - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] + randomNum(<span class="hljs-number">100</span>, <span class="hljs-number">500</span>)baseData.mouseEndX = distancebaseData.trueWidth = <span class="hljs-number">300</span>baseData.trueHeight = <span class="hljs-number">150</span>baseData.selectData = []baseData.blockWidth = <span class="hljs-number">40</span></code></pre><p>滑块轨迹生成代码：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_sm_track</span>(<span class="hljs-params">distance</span>):</span>    track_length = random.randint(<span class="hljs-number">4</span>, <span class="hljs-number">10</span>)    track = [[<span class="hljs-number">0</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">0</span>]]    m = distance % track_length    e = <span class="hljs-built_in">int</span>(distance / track_length)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(track_length):        x = (i + <span class="hljs-number">1</span>) * e + m + random.randint(<span class="hljs-number">20</span>, <span class="hljs-number">40</span>)        y = -<span class="hljs-number">2</span> + (random.randint(-<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))        t = (i + <span class="hljs-number">1</span>) * <span class="hljs-number">100</span> + random.randint(-<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)        <span class="hljs-keyword">if</span> i == track_length - <span class="hljs-number">1</span>:            x = distance            track.append([x, y, t])        <span class="hljs-keyword">else</span>:            track.append([x, y, t])    logger.info(<span class="hljs-string">&quot;track: %s&quot;</span> % track)    <span class="hljs-keyword">return</span> track</code></pre><p>点选类（文字点选 <code>select</code>、图标点选 <code>icon_select</code>、语序点选 <code>seq_select</code>、空间推理 <code>spatial_select</code>）：</p><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><span class="hljs-comment">coordinate：点选坐标（x, y），randomNum：生成两数之间的随机值，示例：</span><span class="hljs-comment">var coordinate = [[171, 101], [88, 102], [138, 109], [225, 100]]</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> baseData = &#123;&#125;<span class="hljs-keyword">var</span> time_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()coordinate.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">co</span>) </span>&#123;    co[<span class="hljs-number">0</span>] = co[<span class="hljs-number">0</span>] / <span class="hljs-number">300</span>    co[<span class="hljs-number">1</span>] = co[<span class="hljs-number">1</span>] / <span class="hljs-number">150</span>    co[<span class="hljs-number">2</span>] = time_    time_ += randomNum(<span class="hljs-number">100</span>, <span class="hljs-number">500</span>)&#125;)baseData.mouseData = coordinatebaseData.startTime = time_ - randomNum(<span class="hljs-number">800</span>, <span class="hljs-number">20000</span>)baseData.endTime = coordinate[coordinate.length - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]baseData.mouseEndX = <span class="hljs-number">0</span>baseData.trueWidth = <span class="hljs-number">300</span>baseData.trueHeight = <span class="hljs-number">150</span>baseData.selectData = coordinatebaseData.blockWidth = <span class="hljs-literal">undefined</span></code></pre><p>无感（<code>auto_slide</code>）：</p><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><span class="hljs-comment">randomNum：生成两数之间的随机值</span><span class="hljs-comment">*/</span><span class="hljs-keyword">var</span> baseData = &#123;&#125;baseData.mouseData = [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]baseData.startTime = <span class="hljs-number">0</span>baseData.endTime = randomNum(<span class="hljs-number">100</span>, <span class="hljs-number">500</span>)baseData.mouseEndX = <span class="hljs-number">260</span>baseData.trueWidth = <span class="hljs-number">300</span>baseData.trueHeight = <span class="hljs-number">150</span>baseData.selectData = []baseData.blockWidth = <span class="hljs-number">40</span></code></pre><p>这些值生成完了之后，就是挨个通过 <code>getEncryptContent</code> 进行加密，前面已经分析过，实际上就是 DES 加密，可以看到分为点选、滑块和无感三类，其中 DES Key 也是会每隔一段时间变化的：</p><p><img src="https://cdn.itbob.cn/img/article/069/24.png" alt="24"></p><p>再往下走还有三个加密参数，待加密值是定值，然后将 s 的值（也就是前面 <code>register</code> 接口返回的 k 经过 DES 解密后的值赋值给了 <code>this._data.__key</code>）。</p><p><img src="https://cdn.itbob.cn/img/article/069/25.png" alt="25"></p><p>至此所有加密参数就搞完了。</p><h2><span id="jie-guo-yan-zheng">结果验证</span></h2><p><img src="https://cdn.itbob.cn/img/article/069/26.png" alt="26"></p><p><img src="https://cdn.itbob.cn/img/article/069/27.png" alt="27"></p><p><img src="https://cdn.itbob.cn/img/article/069/28.png" alt="28"></p><p><img src="https://cdn.itbob.cn/img/article/069/29.png" alt="29"></p><p><img src="https://cdn.itbob.cn/img/article/069/30.png" alt="30"></p><p><img src="https://cdn.itbob.cn/img/article/069/31.png" alt="31"></p><h2><span id="ast-huo-qu-dong-tai-can-shu">AST 获取动态参数</span></h2><p>前面说了，<code>/v1.0.4-171/captcha-sdk.min.js</code> 文件地址，我们称 <code>v1.0.4</code> 为大版本，<code>171</code> 为小版本，小版本每隔一段时间会更新，版本号会不断升高，具体更新周期是多少？这里推荐一个方法 <code>document.lastModified</code>，该方法记录的是物理网页的最后修改时间，我们直接访问 JS 地址，就可以直接查看不同版本的 JS 是啥时候更新的了，多对比几个版本，发现更新间隔时间并没有太明显的规律，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/069/32.png" alt="32"></p><p><img src="https://cdn.itbob.cn/img/article/069/33.png" alt="33"></p><p><img src="https://cdn.itbob.cn/img/article/069/34.png" alt="34"></p><p>不同版本里面的 12 个加密参数的名称和 DES 加密的 Key 都不一样，我们可以利用 AST 来动态获取这 12 个参数，经过测试，以下版本均可正常提取：</p><ul><li><code>v1.0.4-148</code> ~ <code>v1.0.4-171</code></li><li><code>v1.0.3-147</code> ~ <code>v1.0.3-171</code></li><li><code>v1.0.1-147</code> ~ <code>v1.0.1-171</code></li></ul><p>截止本文发布，小版本 <code>171</code> 为最新，<code>v1.0.4</code> 小版本从 <code>148</code> 开始，<code>v1.0.3</code>、<code>v1.0.1</code> 在 <code>147</code> 以前没有混淆，可自行正则匹配，暂未发现其他大版本，如有遇到不能适配的，可联系我瞅瞅，以下是完整的代码分享。</p><p><strong>PS：此 AST 代码仅实现对动态参数的提取，并非还原所有的混淆，提取出来的结果是有序、未去重的，后续按索引取就行。</strong></p><p><img src="https://cdn.itbob.cn/img/article/069/35.png" alt="35"></p><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><span class="hljs-comment">@File   :  get_dynamic_params_ast.js</span><span class="hljs-comment">@Time   :  2023-04-04</span><span class="hljs-comment">@Author :  公众号：K哥爬虫</span><span class="hljs-comment">@Desc   :  数美验证，动态读取 captcha-sdk.min.js，AST 提取动态参数</span><span class="hljs-comment">@Version:  1.0.1 / 1.0.3 / 1.0.4 通用</span><span class="hljs-comment">@Url    :  https://castatic.fengkongcloud.cn/pr/auto-build/v1.0.4-171/captcha-sdk.min.js</span><span class="hljs-comment">*/</span><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<span class="hljs-keyword">const</span> parse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>).parse;<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDynamicParams</span>(<span class="hljs-params">oldCode</span>)</span>&#123;    <span class="hljs-comment">// 导入混淆代码并解析为 AST</span>    <span class="hljs-keyword">const</span> astCode = parse(oldCode);    <span class="hljs-comment">// 获取整个 AST 节点的长度</span>    <span class="hljs-keyword">let</span> astCodeLength = astCode.program.body.length    <span class="hljs-comment">// 获取数组位移函数的名称，如 _0x86bf</span>    <span class="hljs-keyword">let</span> arrDisplacementFuncName = <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; astCodeLength; i++) &#123;        <span class="hljs-keyword">let</span> astCodeBody = astCode.program.body[i]        <span class="hljs-keyword">if</span> (astCodeBody.type == <span class="hljs-string">&quot;FunctionDeclaration&quot;</span> &amp;&amp; astCodeBody.params.length === <span class="hljs-number">2</span>) &#123;            arrDisplacementFuncName = astCodeBody.id.name        &#125;    &#125;    <span class="hljs-comment">// console.log(&quot;arrDisplacementFuncName: &quot;, arrDisplacementFuncName)</span>    <span class="hljs-comment">// 获取大数组以及数组位移代码</span>    <span class="hljs-keyword">let</span> decryptFunction = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; astCodeLength; i++) &#123;        <span class="hljs-keyword">if</span> (astCode.program.body[i].type == <span class="hljs-string">&quot;FunctionDeclaration&quot;</span>) &#123;            decryptFunction += generate(astCode.program.body[i]).code        &#125;        <span class="hljs-keyword">if</span> (astCode.program.body[i].type == <span class="hljs-string">&quot;ExpressionStatement&quot;</span>) &#123;            <span class="hljs-keyword">let</span> expressions = astCode.program.body[i].expression.expressions            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>; a &lt; expressions.length; a++) &#123;                <span class="hljs-keyword">if</span> (expressions[a].type == <span class="hljs-string">&quot;CallExpression&quot;</span> &amp;&amp; expressions[a].callee.type == <span class="hljs-string">&quot;FunctionExpression&quot;</span> &amp;&amp; expressions[a].arguments.length == <span class="hljs-number">2</span>) &#123;                    <span class="hljs-keyword">let</span> expressionStatement = types.expressionStatement(expressions[a])                    decryptFunction += generate(expressionStatement).code                &#125;            &#125;        &#125;    &#125;    <span class="hljs-built_in">eval</span>(decryptFunction)    <span class="hljs-comment">// 获取所有引用了解密函数的变量名</span>    <span class="hljs-keyword">let</span> allReplacedFunc = []    <span class="hljs-keyword">let</span> tmpReplacedFunc1 = [arrDisplacementFuncName]    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        <span class="hljs-keyword">let</span> tmpReplacedFunc2 = []        traverse(astCode, &#123;            <span class="hljs-function"><span class="hljs-title">VariableDeclarator</span>(<span class="hljs-params">path</span>)</span> &#123;                <span class="hljs-keyword">if</span> (path.node.init &amp;&amp; path.node.init.type == <span class="hljs-string">&quot;Identifier&quot;</span> &amp;&amp; tmpReplacedFunc1.indexOf(path.node.init.name)) &#123;                    tmpReplacedFunc2.push(path.node.id.name)                    path.remove()                &#125;            &#125;        &#125;)        <span class="hljs-keyword">if</span> (!tmpReplacedFunc2.length) &#123;            <span class="hljs-keyword">break</span>        &#125;        allReplacedFunc = allReplacedFunc.concat(tmpReplacedFunc2)        tmpReplacedFunc1 = tmpReplacedFunc2    &#125;    <span class="hljs-comment">// console.log(JSON.stringify(allReplacedFunc))</span>    <span class="hljs-comment">// 解密函数还原</span>    traverse(astCode, &#123;        <span class="hljs-function"><span class="hljs-title">CallExpression</span>(<span class="hljs-params">path</span>)</span> &#123;            <span class="hljs-keyword">let</span> calleeName = path.node.callee.name;            <span class="hljs-keyword">if</span> (allReplacedFunc.indexOf(calleeName) &gt; -<span class="hljs-number">1</span>) &#123;                <span class="hljs-comment">// 先替换函数名称 _0xbce966(0x936) ==&gt; _0x86bf(0x936)</span>                <span class="hljs-keyword">let</span> callee = types.identifier(arrDisplacementFuncName)                <span class="hljs-keyword">let</span> argument = path.node.arguments                path.replaceInline(types.callExpression(callee, argument));                <span class="hljs-comment">// 直接计算结果并替换</span>                path.replaceInline(types.stringLiteral(<span class="hljs-built_in">eval</span>(path.toString())));            &#125;        &#125;    &#125;)    <span class="hljs-comment">// 大对象还原</span>    <span class="hljs-keyword">let</span> allObject = &#123;&#125;    traverse(astCode, &#123;        <span class="hljs-function"><span class="hljs-title">VariableDeclarator</span>(<span class="hljs-params">path</span>)</span> &#123;            <span class="hljs-keyword">if</span> (path.node.init &amp;&amp; path.node.init.type == <span class="hljs-string">&quot;ObjectExpression&quot;</span> &amp;&amp; path.node.init.properties.length &gt; <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">let</span> name = path.node.id.name                <span class="hljs-keyword">let</span> properties = path.node.init.properties                allObject[name] = &#123;&#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; properties.length; i++) &#123;                    allObject[name][properties[i].key.value] = properties[i].value                &#125;                path.remove()            &#125;        &#125;    &#125;)    <span class="hljs-comment">// 函数替换，字符串替换：将类似 _0x3b79c6[&#x27;YrYQW&#x27;] 变成 &#x27;#IpValue&#x27;</span>    traverse(astCode, &#123;        <span class="hljs-function"><span class="hljs-title">MemberExpression</span>(<span class="hljs-params">path</span>)</span> &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> allObject) &#123;                <span class="hljs-keyword">if</span> (path.node.object &amp;&amp; path.node.object.name == key &amp;&amp; path.inList) &#123;                    path.replaceInline(allObject[key][path.node.property.value])                &#125;                <span class="hljs-keyword">if</span> (path.node.object &amp;&amp; path.node.object.name == key &amp;&amp; path.parent.property &amp;&amp; path.parent.property.value == <span class="hljs-string">&quot;split&quot;</span>) &#123;                    path.replaceInline(allObject[key][path.node.property.value])                &#125;                <span class="hljs-keyword">if</span> (path.node.object &amp;&amp; path.node.object.name == key &amp;&amp; path.parent.type == <span class="hljs-string">&quot;SwitchCase&quot;</span>) &#123;                    path.replaceInline(allObject[key][path.node.property.value])                &#125;            &#125;        &#125;    &#125;)    <span class="hljs-comment">// 获取动态post参数和加密的key</span>    <span class="hljs-keyword">let</span> parametersList = [];    traverse(astCode, &#123;        <span class="hljs-function"><span class="hljs-title">AssignmentExpression</span>(<span class="hljs-params">path</span>)</span> &#123;            <span class="hljs-keyword">let</span> left = path.node.left            <span class="hljs-keyword">let</span> right = path.node.right            <span class="hljs-keyword">if</span> (right.callee &amp;&amp; right.callee.property &amp;&amp; right.callee.property.value == <span class="hljs-string">&quot;getEncryptContent&quot;</span>) &#123;                parametersList.push([left.property.value, right.arguments[<span class="hljs-number">1</span>].value])            &#125;        &#125;,        <span class="hljs-function"><span class="hljs-title">CallExpression</span>(<span class="hljs-params">path</span>)</span> &#123;            <span class="hljs-keyword">let</span> <span class="hljs-built_in">arguments</span> = path.node.arguments            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length == <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>].callee &amp;&amp; <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>].callee.property &amp;&amp; <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>].callee.property.value == <span class="hljs-string">&quot;getEncryptContent&quot;</span>) &#123;                parametersList.push([<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>].value, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>].arguments[<span class="hljs-number">1</span>].value])            &#125;        &#125;    &#125;)    <span class="hljs-comment">// 将 AST 节点转换成 JS 代码并写入到新文件里</span>    <span class="hljs-comment">// const result = generate(astCode).code</span>    <span class="hljs-comment">// fs.writeFile(&quot;./new.js&quot;, result, (err =&gt; &#123;console.log(err)&#125;))</span>    <span class="hljs-keyword">return</span> parametersList&#125;<span class="hljs-comment">// 从本地读取一份 captcha-sdk</span><span class="hljs-keyword">const</span> oldCode = fs.readFileSync(<span class="hljs-string">&quot;captcha-sdk.v1.0.4-171.js&quot;</span>, &#123;<span class="hljs-attr">encoding</span>: <span class="hljs-string">&quot;utf-8&quot;</span>&#125;);<span class="hljs-keyword">const</span> parametersList = getDynamicParams(oldCode)<span class="hljs-built_in">console</span>.log(parametersList)<span class="hljs-built_in">console</span>.log(parametersList.length)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>百度滑块、点选、旋转验证码 v1、v2 逆向分析</title>
    <link href="https://www.itbob.cn/article/068/"/>
    <id>https://www.itbob.cn/article/068/</id>
    <published>2023-04-06T12:20:00.000Z</published>
    <updated>2023-04-06T12:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#zhua-bao-fen-xi">抓包分析</a></li><li><a href="#ni-xiang-fen-xi-fs">逆向分析 fs</a></li><li><a href="#xuan-zhuan-jiao-du-shi-bie">旋转角度识别</a></li><li><a href="#v2-ban-ben-fen-xi">v2 版本分析</a></li><li><a href="#qi-ta-wen-ti">其他问题</a></li><li><a href="#jie-guo-yan-zheng">结果验证</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：百度滑块验证码、点选验证码、旋转验证码，v1、v2 逆向分析</li><li>v1 旋转验证码：</li></ul><pre><code class="hljs text">aHR0cHM6Ly93YXBwYXNzLmJhaWR1LmNvbS9zdGF0aWMvY2FwdGNoYS90dXhpbmcuaHRtbD9haz0zM2M0ODg4NGI3ZGY4M2Q0MjMwZTA3Y2JjZDBkMDdmZCZiYWNrdXJsPWh0dHBzJTNBJTJGJTJGYWlxaWNoYS5iYWlkdS5jb20mdGltZXN0YW1wPTE2MzE0MzQ0MjUmc2lnbmF0dXJlPWM2ODRhODJiNzk4MjAyOTg3NWJmZDhlMGE2NjBiNzdm</code></pre><ul><li>v2 旋转验证码：</li></ul><pre><code class="hljs text">aHR0cHM6Ly93YXBwYXNzLmJhaWR1LmNvbS9zdGF0aWMvY2FwdGNoYS90dXhpbmcuaHRtbD8mYWs9YzI3YmJjODlhZmNhMDQ2MzY1MGFjOWJkZTY4ZWJlMDY=</code></pre><ul><li>v2 滑块验证码：</li></ul><pre><code class="hljs text">aHR0cHM6Ly93YXBwYXNzLmJhaWR1LmNvbS9zdGF0aWMvY2FwdGNoYS90dXhpbmcuaHRtbD8mYW1wO2FrPWMyN2JiYzg5YWZjYTA0NjM2NTBhYzliZGU2OGViZTA2</code></pre><ul><li>v2 点选验证码：</li></ul><pre><code class="hljs text">aHR0cHM6Ly93YXBwYXNzLmJhaWR1LmNvbS92Ni9nZXRQYXNz</code></pre><p>PS：v1、v2 是作者自己为了区分而命名的版本号，主要依据是核心 JS 文件分为 mkd.js 和 mkd_v2.js 两个版本，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/068/01.png" alt="01"></p><p>此外，在界面上也有所区别，v2 版本的旋转、滑块图片有很明显的阴影、线条干扰，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/068/02.png" alt="02"></p><p>上面给的地址中，点选验证码的地址有时候是点选，有时候会变成旋转，估计是异常等级不同导致的，此外，传闻还有一种无感验证，不过作者到处找也没找到个地址，估计逻辑都是差不多的，无感验证如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/068/03.png" alt="03"></p><h2><span id="zhua-bao-fen-xi">抓包分析</span></h2><p>以下以 v1 旋转验证码为例（v2 接口名称不一样，但逻辑是一样的），第一次 <code>viewlog</code> 接口，请求的 <code>ak</code> 是固定值，当然不同场景不同网站是不一样的，<code>callback</code> 回调值，<code>_</code> 时间戳，返回值 <code>as</code>、<code>tk</code> 都是后面会用到的。</p><p><img src="https://cdn.itbob.cn/img/article/068/04.png" alt="04"></p><p><img src="https://cdn.itbob.cn/img/article/068/05.png" alt="05"></p><p>然后是一个 <code>getstyle</code> 接口，其中的 <code>tk</code> 就是前面 <code>viewlog</code> 接口返回的，返回值里 <code>backstr</code> 后续参数加密会用到，<code>img</code> 就是旋转图片地址，<code>info</code> 是一些版权信息。</p><p><img src="https://cdn.itbob.cn/img/article/068/06.png" alt="06"></p><p><img src="https://cdn.itbob.cn/img/article/068/07.png" alt="07"></p><p>旋转验证码开始验证，此时第二次出现 <code>viewlog</code> 接口，<code>as</code> 和 <code>tk</code> 参数是第一次 <code>viewlog</code> 返回的，<code>fs</code> 参数需要我们逆向，包含了旋转角度等信息，如果旋转角度正确且参数没问题，则返回值里的 <code>op</code> 为 1，另外返回的 <code>ds</code> 和 <code>tk</code> 后续还会用到。</p><p><img src="https://cdn.itbob.cn/img/article/068/08.png" alt="08"></p><p><img src="https://cdn.itbob.cn/img/article/068/09.png" alt="09"></p><p>上一步验证走完后，并不意味着通过验证了，后续还会有一个 <code>viewlog/c</code> 的接口需要进一步验证，其中的 <code>tk</code>、<code>ds</code> 参数就是上一步返回的，如果验证失败，返回值 <code>code</code> 为 1，验证成功，<code>code</code> 则为 0。</p><p><img src="https://cdn.itbob.cn/img/article/068/10.png" alt="10"></p><p><img src="https://cdn.itbob.cn/img/article/068/11.png" alt="11"></p><p><img src="https://cdn.itbob.cn/img/article/068/12.png" alt="12"></p><h2><span id="ni-xiang-fen-xi-fs">逆向分析 fs</span></h2><p>接下来分析主要加密参数 <code>fs</code>，跟栈到 mkd.js：</p><p><img src="https://cdn.itbob.cn/img/article/068/13.png" alt="13"></p><p><img src="https://cdn.itbob.cn/img/article/068/14.png" alt="14"></p><p>可以看到 <code>o</code> 就是 <code>fs</code>，而 <code>o</code> 又是 <code>r.rzData</code> 经过加密后得到的，输出一下 <code>r.rzData</code>，结构如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/068/15.png" alt="15"></p><p>重要参数：</p><ul><li><code>ac_c</code>：一看就知道和旋转的角度有关；</li><li><code>backstr</code>：<code>getstyle</code> 接口返回的；</li><li><code>cl</code>：x，y 坐标以及时间戳，量一下就知道这个坐标是鼠标点击下面那个滑动条按钮的时候的坐标；</li><li><code>mv</code>：鼠标轨迹，鼠标动一下就记录一下坐标和时间戳；</li><li><code>cr</code>：屏幕长宽高等信息；</li><li>其他值都是空或者0。</li></ul><p>实际测试，<code>cl</code> 和 <code>mv</code> 都不校验，写死或者置空都行，当然想要自己伪造一下也是可以的，量一下滑动按钮在屏幕中的位置，<code>cl</code> 根据这个位置随机生成就行了。重点看看 <code>ac_c</code>，直接搜索即可定位：</p><p><img src="https://cdn.itbob.cn/img/article/068/16.png" alt="16"></p><p><img src="https://cdn.itbob.cn/img/article/068/17.png" alt="17"></p><p>可以看到这个值的计算方法为 <code>parseFloat(o / a).toFixed(2)</code>，<code>a</code> 是定值 212，实际上就是滑动条能够滑动的最大长度，<code>o</code> 是滑动的距离，如果我们识别出来的是旋转角度 <code>angle</code>，则 <code>ac_c</code> 计算方法如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = angle * <span class="hljs-number">212</span> / <span class="hljs-number">360</span><span class="hljs-keyword">var</span> ac_c = <span class="hljs-built_in">parseFloat</span>(o / <span class="hljs-number">212</span>).toFixed(<span class="hljs-number">2</span>)<span class="hljs-comment">// 也可以直接写成：</span><span class="hljs-keyword">var</span> ac_c = <span class="hljs-built_in">parseFloat</span>(angle / <span class="hljs-number">360</span>).toFixed(<span class="hljs-number">2</span>)</code></pre><p><code>r.rzData</code> 搞定后，就只有个 <code>r.encrypt()</code> 方法了，直接跟进去就是我们熟悉的 AES 算法，其中 iv 是 <code>viewlog</code> 接口返回的 as 值加上一个定值 <code>appsapi0</code>，其他就不用多说了。至此加密参数就搞完了，还是非常简单的。</p><p><img src="https://cdn.itbob.cn/img/article/068/18.png" alt="18"></p><p><img src="https://cdn.itbob.cn/img/article/068/19.png" alt="19"></p><h2><span id="xuan-zhuan-jiao-du-shi-bie">旋转角度识别</span></h2><p>这里推荐一个国外大佬的 RotNet 项目，可以用于预测图像的旋转角度以纠正其方向，还有基于此项目开发的，Nanda 大佬的 RotateCaptchaBreak、另一个大佬的 rotate-captcha-crack 等，链接如下：</p><ul><li><a href="https://github.com/d4nst/RotNet">https://github.com/d4nst/RotNet</a></li><li><a href="https://github.com/chencchen/RotateCaptchaBreak">https://github.com/chencchen/RotateCaptchaBreak</a></li><li><a href="https://github.com/Starry-OvO/rotate-captcha-crack">https://github.com/Starry-OvO/rotate-captcha-crack</a></li></ul><p>深度学习大佬可以基于这些项目进一步训练，像我这种对这方面一窍不通的当然是选择打码平台了，<a href="https://www.jfbym.com/register/TG17764">云码打码</a>还不错，只不过官网只放出了 v1 版本没有阴影干扰的，找他们客服可以拿到 v2 版本有阴影干扰的类型，这里就不多说了，免得被认为是打广告了哈哈哈。</p><p><img src="https://cdn.itbob.cn/img/article/068/20.png" alt="20"></p><h2><span id="v2-ban-ben-fen-xi">v2 版本分析</span></h2><p>v2 版本和 v1 版本基本上差不多，区别在于 <code>rzData</code> 的结构不太一样，<code>ac_c</code> 的计算方法不一样，以及 AES 的 IV 不一样，先看 AES 的 IV，v2 版本是 as 值加上固定值 <code>appsapi2</code>：</p><p><img src="https://cdn.itbob.cn/img/article/068/21.png" alt="21"></p><p>然后再看看 <code>rzData</code>，<code>common</code> 字段下基本上就是 v1 的 <code>rzData</code> 的格式，<code>captchalist</code> 下，至少有 <code>spin-0</code>（旋转）、``puzzle-0<code>（滑块）、</code>click-0<code>（点选）三种，</code>ac_c` 依旧是旋转角度占比、滑动占比以及点选坐标信息，其他的依旧是写死或者置空就行。</p><p><img src="https://cdn.itbob.cn/img/article/068/22.png" alt="22"></p><p>然后就是 <code>ac_c</code> 的计算方法了，首先是旋转验证码，直接搜索 <code>ac_c</code>：</p><p><img src="https://cdn.itbob.cn/img/article/068/23.png" alt="23"></p><p>往上跟栈，有个 percent 的地方，一个三目表达式，e 是固定值 290，<code>e - 52 = 238</code>，238 也就是滑动条能够滑动的最大长度：</p><p><img src="https://cdn.itbob.cn/img/article/068/24.png" alt="24"></p><p>如果我们识别出来的是旋转角度 <code>angle</code>，则 <code>ac_c</code> 计算方法如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> distance = angle * <span class="hljs-number">238</span> / <span class="hljs-number">360</span><span class="hljs-keyword">var</span> ac_c = <span class="hljs-built_in">Number</span>((distance / (<span class="hljs-number">290</span> - <span class="hljs-number">52</span>)).toFixed(<span class="hljs-number">2</span>))<span class="hljs-comment">// 也可以直接写成：</span><span class="hljs-keyword">var</span> ac_c = <span class="hljs-built_in">Number</span>((angle / <span class="hljs-number">360</span>).toFixed(<span class="hljs-number">2</span>))</code></pre><p>而对于滑块验证码就有所不同，同样是这个地方的三目表达式，但是要走后面的逻辑：</p><p><img src="https://cdn.itbob.cn/img/article/068/25.png" alt="25"></p><p>如果我们识别出来的是滑动距离 <code>distance</code>，则滑块 <code>ac_c</code> 的计算方法如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ac_c = <span class="hljs-built_in">Number</span>((distance / <span class="hljs-number">290</span>).toFixed(<span class="hljs-number">2</span>))</code></pre><p>同样对于点选验证码来说，也不一样，<code>ac_c</code> 的值是点击的 xy 坐标以及时间戳：</p><p><img src="https://cdn.itbob.cn/img/article/068/26.png" alt="26"></p><h2><span id="qi-ta-wen-ti">其他问题</span></h2><p>前面我们说了百度的验证应该有两次，对于第二次验证，也就是 v1 的 <code>viewlog/c</code> 接口，v2 的 <code>cap/c</code> 接口，即便你第一次校验通过了，这个 c 接口校验也有可能不通过，出现这种情况的原因是通过的时间太短了，随机 <code>time.sleep</code> 1-3 秒即可，如果时间太短，c 接口可能会报以下验证错误：</p><pre><code class="hljs json">&#123;&#x27;code&#x27;: <span class="hljs-number">1</span>, &#x27;isRectified&#x27;: False, &#x27;msg&#x27;: &#x27;Verification Failed&#x27;&#125;</code></pre><p>还有一种情况就是提示<code>存在安全风险，请再次验证</code>，出现这种情况你会发现去浏览器手动滑也是一样的，所以在本地加个再次验证的逻辑就行了，一般来说第二次验证就能通过。</p><pre><code class="hljs json">&#123;&#x27;code&#x27;: <span class="hljs-number">0</span>, &#x27;msg&#x27;: &#x27;success&#x27;, &#x27;data&#x27;: &#123;&#x27;f&#x27;: &#123;&#x27;feedback&#x27;: &#x27;https:<span class="hljs-comment">//www.baidu.com/passport/ufosubmit.html&#x27;, &#x27;reason&#x27;: &#x27;存在安全风险，请再次验证&#x27;&#125;&#125;&#125;</span></code></pre><p>然后就是请求 header 里没有 <code>Referer</code> 或者 <code>Referer</code> 不正确的话，会报错：</p><pre><code class="hljs json"><span class="hljs-comment">// v1 没有 Referer</span>&#123;&#x27;code&#x27;: <span class="hljs-number">1</span>, &#x27;msg&#x27;: &#x27;Unregistered Host&#x27;&#125;<span class="hljs-comment">// v1 Referer 不正确</span>&#123;&#x27;code&#x27;: <span class="hljs-number">1</span>, &#x27;msg&#x27;: &#x27;Invalid Request&#x27;, &#x27;data&#x27;: []&#125;<span class="hljs-comment">// v2 没有 Referer 或者 Referer 不正确</span>&#123;&#x27;code&#x27;: <span class="hljs-number">100600</span>, &#x27;msg&#x27;: &#x27;Unauthorized Host&#x27;&#125;</code></pre><p>还有一个小技巧，如果你想自己验证一下旋转的角度对不对，怎么去测量这个角度呢？我们可以借助一些做图软件，简单点儿的比如美图秀秀，新建一个画布，然后直接将验证码图片拖进去，就可以自由旋转了，旋转的时候软件会自动标注出旋转的角度，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/068/27.png" alt="27"></p><h2><span id="jie-guo-yan-zheng">结果验证</span></h2><p><img src="https://cdn.itbob.cn/img/article/068/28.png" alt="28"></p><p><img src="https://cdn.itbob.cn/img/article/068/29.png" alt="29"></p><p><img src="https://cdn.itbob.cn/img/article/068/30.png" alt="30"></p><p><img src="https://cdn.itbob.cn/img/article/068/31.png" alt="31"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>极验全家桶细节避坑总结</title>
    <link href="https://www.itbob.cn/article/067/"/>
    <id>https://www.itbob.cn/article/067/</id>
    <published>2023-03-19T16:00:00.000Z</published>
    <updated>2023-03-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#qian-yan">前言</a></li><li><a href="#guan-yu-w-zhi">关于 w 值</a></li><li><a href="#guan-yu-shi-jian-jian-ge">关于时间间隔</a></li><li><a href="#guan-yu-challenge">关于 challenge</a></li><li><a href="#guan-yu-c-he-s">关于 c 和 s</a></li><li><a href="#guan-yu-liang-ci-get-php-he-ajax-php-qing-qiu">关于两次 get.php 和 ajax.php 请求</a></li><li><a href="#guan-yu-zhi-neng-zu-he-yan-zheng">关于智能组合验证</a></li><li><a href="#guan-yu-kou-w-de-suan-fa">关于扣 w 的算法</a><ul><li><a href="#passtime">passtime</a></li><li><a href="#pow-sign-he-pow-msg">pow_sign 和 pow_msg</a></li><li><a href="#sui-ji-bian-hua-de-zi-fu-chuan">随机变化的字符串</a></li><li><a href="#sui-ji-bian-hua-de-jian-zhi-dui">随机变化的键值对</a></li><li><a href="#bu-huan-jing-zhong-ke-neng-yong-dao-de-fang-fa">补环境中可能用到的方法</a></li></ul></li><li><a href="#guan-yu-yan-zheng-ma-de-shi-bie">关于验证码的识别</a></li><li><a href="#guan-yu-gui-ji-de-sheng-cheng">关于轨迹的生成</a></li><li><a href="#qi-ta-ke-neng-de-bao-cuo">其他可能的报错</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="qian-yan">前言</span></h2><p>某验的验证码总体来说还是很简单的，但是也有一些细节可能要注意一下，<strong>如果你扣完算法发现验证报各种各样的错误，或者在官网的 demo 能验证通过，在其他网站却验证失败</strong>，那么就可以看看本文总结的细节你有没有注意到。</p><p>除此之外，本文还分享了一些验证码的识别方案、轨迹的处理，这些方法大多来自网络上其他大佬的分享，直接百度就能搜到，本文只是做了一个归纳总结。</p><h2><span id="guan-yu-w-zhi">关于 w 值</span></h2><p>三代里面，有几个接口请求都有 w，但除了最后一个校验接口 <code>ajax.php</code> 以外，其他接口的 w 可以置空，但也不完全都是这样，比如三代的一键通过模式（无感验证），在请求 <code>get.php</code> 接口获取 c 和 s 值的时候，同样校验了 w 值，因此需要获取两次 w 值，而这两次 w 值的生成方式还不太一样，需要自己细心分两次扣一下。如果你第一次不带 w，或者 w 生成错误，就会报以下错误：</p><pre><code class="hljs json">&#123;&#x27;status&#x27;: &#x27;error&#x27;, &#x27;error&#x27;: &#x27;param decrypt error&#x27;, &#x27;user_error&#x27;: &#x27;网络不给力&#x27;, &#x27;error_code&#x27;: &#x27;error_03&#x27;&#125;</code></pre><h2><span id="guan-yu-shi-jian-jian-ge">关于时间间隔</span></h2><p>三代里面，整个流程走得太快了也是不行的，需要在生成 w 值之后，随机停留个 2 秒左右，以三代的点选（文字点选、图标点选、语序点选、空间推理）为例，如果整得太快了验证失败会报以下错误：</p><pre><code class="hljs json">&#123;&#x27;status&#x27;: &#x27;success&#x27;, &#x27;data&#x27;: &#123;&#x27;result&#x27;: &#x27;fail&#x27;, &#x27;msg&#x27;: [&#x27;duration short&#x27;]&#125;&#125;</code></pre><h2><span id="guan-yu-challenge">关于 challenge</span></h2><p>三代里面，有个 challenge 参与了很多接口的请求，三代滑块比较特殊，第一次获取到了一个 challenge，后面的第二个 <code>get.php</code> 请求返回数据里会有一个新的 challenge，新的 challenge 比第一次的 challenge 多了两位数，后续的请求要用这个新的 challenge 才行，不然的话会报以下错误：</p><pre><code class="hljs json">&#123;&#x27;success&#x27;: <span class="hljs-number">0</span>, &#x27;message&#x27;: &#x27;fail&#x27;&#125;</code></pre><h2><span id="guan-yu-c-he-s">关于 c 和 s</span></h2><p>三代里面，有个 c 和 s 的值参与了 w 的计算，点选系列和滑块，第一次 <code>get.php</code> 请求会返回一个 c 和 s，第二次 <code>get.php</code> 请求也会返回一个 c 和 s，两次的 c 一般是不变的，但 s 会变，生成 w 要用第二次  <code>get.php</code> 返回的 s 才行，不然的话会报以下错误：</p><pre><code class="hljs json">&#123;&#x27;success&#x27;: <span class="hljs-number">0</span>, &#x27;message&#x27;: &#x27;forbidden&#x27;&#125;</code></pre><h2><span id="guan-yu-liang-ci-get-php-he-ajax-php-qing-qiu">关于两次 get.php 和 ajax.php 请求</span></h2><p>同样还是三代里面，点选系列和滑块，会有两次以 <code>get.php</code> 和 <code>ajax.php</code> 结尾的请求，第一次的 <code>get.php</code> 返回的是一些主题、域名、提示文字等信息，第一次的 <code>ajax.php</code> 返回的是验证码的类型，这两次请求返回的数据虽然对我们没太大用处，但是我们还是得发起请求，不然后续的请求就不对，必须得按照他这个顺序来才行。</p><h2><span id="guan-yu-zhi-neng-zu-he-yan-zheng">关于智能组合验证</span></h2><p>智能组合验证说白了就是事先不知道是什么类型，四代在很多网站都是选择智能模式，处理方法也很简单，事先把所有类型都准备好，然后通过接口返回的验证码类型来接入不同的逻辑。</p><p>三代判断逻辑：第一次的 <code>ajax.php</code> 接口，返回值会告诉你是点选 (<code>click</code>) 还是滑块 (<code>slide</code>)，其中点选又分为文字点选、图标点选、语序点选和空间推理，它们的类型都为 <code>click</code>，这个时候就要进行第二次判断，第二次 <code>get.php</code> 返回的 <code>pic_type</code> 字段，会告诉你是文字点选 (<code>word</code>)、图标点选 (<code>icon</code>)、语序点选 (<code>phrase</code>) 还是空间推理 (<code>space</code>)。</p><p>四代判断逻辑：四代更简洁，<code>load</code> 接口会有一个 <code>captcha_type</code> 字段，会直接告诉你是滑块、点选（以及哪种类型的点选）、五子棋还是九宫格等。</p><h2><span id="guan-yu-kou-w-de-suan-fa">关于扣 w 的算法</span></h2><p>扣 w 的算法，里面也有一些细节，某些参数也值得注意。</p><h3><span id="passtime">passtime</span></h3><p>不管是二代、三代还是四代，生成 w 的时候经常有个 <code>passtime</code> 参与了计算，这个值分为两种情况，如果是滑块，这个值应该是滑动花费的时间，因为滑块的轨迹里包含了时间，所以应该直接取轨迹的最后一个时间值即可，即 <code>track[track.length - 1][2]</code>，以三代为例，如果这个值和你轨迹里的时间不一致，就会报以下错误：</p><pre><code class="hljs json">&#123;&#x27;success&#x27;: <span class="hljs-number">0</span>, &#x27;message&#x27;: &#x27;forbidden&#x27;&#125;</code></pre><p><img src="https://cdn.itbob.cn/img/article/067/01.png" alt="01"></p><p>除了滑块，其他情况下，这个值写死就行，不过还是建议写个随机值：<code>Math.floor((Math.random()*500) + 4000)</code></p><h3><span id="pow-sign-he-pow-msg">pow_sign 和 pow_msg</span></h3><p>这两个参数是四代里独有的，如果你是在 <a href="http://gt4.geetest.com">gt4.geetest.com</a> 进行调试，你会发现 <code>pow_msg</code> 的组成格式如下：</p><pre><code class="hljs json"><span class="hljs-number">1</span>|<span class="hljs-number">0</span>|md5|datetime|captcha_id|lot_number||随机字符串</code></pre><p>而 <code>pow_sign</code> 则是 <code>pow_msg</code> 经过 MD5 加密后的值，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/067/02.png" alt="02"></p><p>这里你可能不注意的话，直接按照这个格式写死了，特别是最后一个随机值，真的随机其实是不行的，真随机就会导致你在某些网站里能通过，某些网站不能通过。搜索 <code>pow_sign</code> 或者 <code>pow_msg</code> 的 Unicode 值，总共就三个地方，都下个断点，刷新一下网页，断下之后仔细分析，其实是有三种算法的，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/067/03.png" alt="03"></p><p>上图中第 6819 行的 h 就是随机值，后续会根据不同算法进行计算，判断这个随机值是否满足一些条件，满足才是正确的，可以在  load 接口返回的 <code>pow_detail</code> 字段判断是 MD5、SHA1 还是 SHA256，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/067/04.png" alt="04"></p><p>这一段的处理逻辑扣出来就是这样的：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;crypto-js&quot;</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRandomString</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-number">65536</span> * (<span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>.random()) | <span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>).substring(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> e() + e() + e() + e();&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_pow</span>(<span class="hljs-params">pow_detail, captcha_id, lot_number</span>) </span>&#123;    <span class="hljs-keyword">var</span> n = pow_detail.hashfunc;    <span class="hljs-keyword">var</span> i = pow_detail.version;    <span class="hljs-keyword">var</span> r = pow_detail.bits;    <span class="hljs-keyword">var</span> s = pow_detail.datetime;    <span class="hljs-keyword">var</span> o = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">var</span> a = r % <span class="hljs-number">4</span>;    <span class="hljs-keyword">var</span> u = <span class="hljs-built_in">parseInt</span>(r / <span class="hljs-number">4</span>, <span class="hljs-number">10</span>);    <span class="hljs-keyword">var</span> c = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">g</span>(<span class="hljs-params">e, t</span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(t + <span class="hljs-number">1</span>).join(e);    &#125;(<span class="hljs-string">&quot;0&quot;</span>, u);    <span class="hljs-keyword">var</span> _ = i + <span class="hljs-string">&quot;|&quot;</span> + r + <span class="hljs-string">&quot;|&quot;</span> + n + <span class="hljs-string">&quot;|&quot;</span> + s + <span class="hljs-string">&quot;|&quot;</span> + captcha_id + <span class="hljs-string">&quot;|&quot;</span> + lot_number + <span class="hljs-string">&quot;|&quot;</span> + o + <span class="hljs-string">&quot;|&quot;</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">var</span> h = getRandomString()          , l = _ + h          , p = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">switch</span> (n) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;md5&quot;</span>:            p = CryptoJS.MD5(l).toString();            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sha1&quot;</span>:            p = CryptoJS.SHA1(l).toString();            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sha256&quot;</span>:            p = CryptoJS.SHA256(l).toString();        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == a) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> === p.indexOf(c))                <span class="hljs-keyword">return</span> &#123;                    <span class="hljs-string">&quot;pow_msg&quot;</span>: _ + h,                    <span class="hljs-string">&quot;pow_sign&quot;</span>: p                &#125;;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> === p.indexOf(c)) &#123;            <span class="hljs-keyword">var</span> f = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>              , d = p[u];            <span class="hljs-keyword">switch</span> (a) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                f = <span class="hljs-number">7</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                f = <span class="hljs-number">3</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:                f = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">if</span> (d &lt;= f)                <span class="hljs-keyword">return</span> &#123;                    <span class="hljs-string">&quot;pow_msg&quot;</span>: _ + h,                    <span class="hljs-string">&quot;pow_sign&quot;</span>: p                &#125;;        &#125;    &#125;&#125;<span class="hljs-comment">// 测试用例</span><span class="hljs-comment">// var pow_detail = &#123;</span><span class="hljs-comment">//     bits: 0,</span><span class="hljs-comment">//     datetime: &quot;2023-02-09T11:04:17.687400+08:00&quot;,</span><span class="hljs-comment">//     hashfunc: &quot;md5&quot;,</span><span class="hljs-comment">//     version: &quot;1&quot;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// var captcha_id = &quot;08c16c99330a5a1d6b7f4371bbd5a978&quot;</span><span class="hljs-comment">// var lot_number = &quot;1417b7e362b748429003c412b3aa300c&quot;</span><span class="hljs-comment">// console.log(get_pow(pow_detail, captcha_id, lot_number))</span></code></pre><p>只有经过这样处理，才能保证 <code>pow_sign</code> 和 <code>pow_msg</code> 是正确的，才能适配不同网站、不同算法的验证。</p><h3><span id="sui-ji-bian-hua-de-zi-fu-chuan">随机变化的字符串</span></h3><p>不管是哪一代，都会有一个 16 位随机字符串参与了 w 的加密计算，这个随机字符串一般都会用到两次，这两次要保证是一样的才行。</p><p><img src="https://cdn.itbob.cn/img/article/067/05.png" alt="05"></p><p>如果这个字符串两次不一样，二、三代验证会报错如下：</p><pre><code class="hljs json">&#123;&#x27;status&#x27;: &#x27;error&#x27;, &#x27;error&#x27;: &#x27;param decrypt error&#x27;, &#x27;user_error&#x27;: &#x27;网络不给力&#x27;, &#x27;error_code&#x27;: &#x27;error_03&#x27;&#125;</code></pre><p>四代验证会报错如下：</p><pre><code class="hljs json">&#123;&#x27;status&#x27;: &#x27;error&#x27;, &#x27;code&#x27;: &#x27;<span class="hljs-number">-50002</span>&#x27;, &#x27;msg&#x27;: &#x27;param decrypt error&#x27;, &#x27;desc&#x27;: &#123;&#x27;type&#x27;: &#x27;defined error&#x27;&#125;&#125;</code></pre><h3><span id="sui-ji-bian-hua-de-jian-zhi-dui">随机变化的键值对</span></h3><p>三四代生成 w 的过程中会有一个随机键值对，每隔一段时间就会变化，类似于 <code>&#123;h9s9: '1803797734'&#125;</code>，这个键值对写死也可以，貌似不影响，但如果非要和网页一样随机起来应该怎么做呢？</p><p>以三代滑块为例，断点到 o 参数生成的地方，后续有个 <code>lang</code> 和 <code>ep</code> 组成的 s 参数，经过 <code>window[$_CAHJd(744)](s)</code> 处理后，s 里就新增了一个键值对（不同类型略有差别，但生成的位置一定离 o 不远，仔细跟即可），如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/067/06.png" alt="06"></p><p>跟进去，会来到 <code>gct.xxx.js</code> 里，也是经过了一个方法后，就多了这个键值对：</p><p><img src="https://cdn.itbob.cn/img/article/067/07.png" alt="07"></p><p>这个 gct 的 js 具体地址可以在前面的 <code>get.php</code> 之类的请求里拿到，由于里面是不断变化的，所以可以采取动态请求这个 js，动态导出获取这个值，一个简单的逻辑如下：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<span class="hljs-keyword">import</span> execjs<span class="hljs-keyword">import</span> requestsheaders = &#123;    <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36&quot;</span>,&#125;<span class="hljs-comment"># gct js 路径</span>gct_path = <span class="hljs-string">&quot;https://static.geetest.com/static/js/gct.b71a9027509bc6bcfef9fc6a196424f5.js&quot;</span>gct_js = requests.get(gct_path, headers=headers).text<span class="hljs-comment"># 正则匹配需要调用的方法名称</span>function_name = re.findall(<span class="hljs-string">r&quot;\)\)\&#123;return (.*?)\(&quot;</span>, gct_js)[<span class="hljs-number">0</span>]<span class="hljs-comment"># 查找需要插入全局导出代码的位置</span>break_position = gct_js.find(<span class="hljs-string">&quot;return function(t)&#123;&quot;</span>)<span class="hljs-comment"># window.gct 全局导出方法</span>gct_js_new = gct_js[:break_position] + <span class="hljs-string">&quot;window.gct=&quot;</span> + function_name + <span class="hljs-string">&quot;;&quot;</span> + gct_js[break_position:]<span class="hljs-comment"># 添加自定义方法调用 window.gct 获取键值对</span>gct_js_new = <span class="hljs-string">&quot;window = global;&quot;</span> + gct_js_new + <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">function getGct()&#123;</span><span class="hljs-string">    var e = &#123;&quot;lang&quot;: &quot;zh&quot;, &quot;ep&quot;: &quot;test data&quot;&#125;;</span><span class="hljs-string">    window.gct(e);</span><span class="hljs-string">    delete e[&quot;lang&quot;];</span><span class="hljs-string">    delete e[&quot;ep&quot;];</span><span class="hljs-string">    return e;</span><span class="hljs-string">&#125;&quot;&quot;&quot;</span>gct = execjs.<span class="hljs-built_in">compile</span>(gct_js_new).call(<span class="hljs-string">&quot;getGct&quot;</span>)<span class="hljs-built_in">print</span>(gct)<span class="hljs-comment"># &#123;&#x27;h9s9&#x27;: &#x27;1803797734&#x27;&#125;</span></code></pre><h3><span id="bu-huan-jing-zhong-ke-neng-yong-dao-de-fang-fa">补环境中可能用到的方法</span></h3><p>补环境可能会遇到 <code>window.crypto.getRandomValues()</code> 方法，例如三代滑块的位置如下：</p><p><img src="https://cdn.itbob.cn/img/article/067/08.png" alt="08"></p><p>可以用以下代码来实现：</p><pre><code class="hljs javascript"><span class="hljs-built_in">window</span> = <span class="hljs-built_in">global</span>;<span class="hljs-built_in">window</span>.crypto = &#123;    <span class="hljs-attr">getRandomValues</span>: getRandomValues_&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randoms</span>(<span class="hljs-params">min, max</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (max - min + <span class="hljs-number">1</span>) + min)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRandomValues_</span>(<span class="hljs-params">buf</span>) </span>&#123;    <span class="hljs-keyword">var</span> min = <span class="hljs-number">0</span>,    max = <span class="hljs-number">255</span>;    <span class="hljs-keyword">if</span> (buf.length &gt; <span class="hljs-number">65536</span>) &#123;        <span class="hljs-keyword">var</span> e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();        e.code = <span class="hljs-number">22</span>;        e.message = <span class="hljs-string">&#x27;Failed to execute \&#x27;getRandomValues\&#x27; : The &#x27;</span> + <span class="hljs-string">&#x27;ArrayBufferView\&#x27;s byte length (&#x27;</span> + buf.length + <span class="hljs-string">&#x27;) exceeds the &#x27;</span> + <span class="hljs-string">&#x27;number of bytes of entropy available via this API (65536).&#x27;</span>;        e.name = <span class="hljs-string">&#x27;QuotaExceededError&#x27;</span>;        <span class="hljs-keyword">throw</span> e;    &#125;    <span class="hljs-keyword">if</span> (buf <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Uint16Array</span>) &#123;        max = <span class="hljs-number">65535</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (buf <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Uint32Array</span>) &#123;        max = <span class="hljs-number">4294967295</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> buf) &#123;        buf[element] = randoms(min, max);    &#125;    <span class="hljs-keyword">return</span> buf;&#125;<span class="hljs-comment">// 测试</span><span class="hljs-comment">// var a = new Uint32Array(256);</span><span class="hljs-comment">// console.log(window.crypto.getRandomValues(a))</span></code></pre><p>另外，还有个用到 <code>window.performance.timing</code> 的地方，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/067/09.png" alt="09"></p><p>这个主要是一些性能指标，直接搞个时间戳随机加值就行了：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timing</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> now = <span class="hljs-built_in">Date</span>.now()    <span class="hljs-keyword">var</span> tim = &#123;        <span class="hljs-string">&quot;navigationStart&quot;</span>: now,        <span class="hljs-string">&quot;unloadEventStart&quot;</span>: now + <span class="hljs-number">200</span>,        <span class="hljs-string">&quot;unloadEventEnd&quot;</span>: now + <span class="hljs-number">200</span>,        <span class="hljs-string">&quot;redirectStart&quot;</span>: <span class="hljs-number">0</span>,        <span class="hljs-string">&quot;redirectEnd&quot;</span>: <span class="hljs-number">0</span>,        <span class="hljs-string">&quot;fetchStart&quot;</span>: now + <span class="hljs-number">100</span>,        <span class="hljs-string">&quot;domainLookupStart&quot;</span>: now + <span class="hljs-number">150</span>,        <span class="hljs-string">&quot;domainLookupEnd&quot;</span>: now + <span class="hljs-number">250</span>,        <span class="hljs-string">&quot;connectStart&quot;</span>: now + <span class="hljs-number">30</span>,        <span class="hljs-string">&quot;connectEnd&quot;</span>: now + <span class="hljs-number">50</span>,        <span class="hljs-string">&quot;secureConnectionStart&quot;</span>: now + <span class="hljs-number">52</span>,        <span class="hljs-string">&quot;requestStart&quot;</span>: now + <span class="hljs-number">72</span>,        <span class="hljs-string">&quot;responseStart&quot;</span>: now + <span class="hljs-number">91</span>,        <span class="hljs-string">&quot;responseEnd&quot;</span>: now + <span class="hljs-number">92</span>,        <span class="hljs-string">&quot;domLoading&quot;</span>: now + <span class="hljs-number">99</span>,        <span class="hljs-string">&quot;domInteractive&quot;</span>: now + <span class="hljs-number">105</span>,        <span class="hljs-string">&quot;domContentLoadedEventStart&quot;</span>: now + <span class="hljs-number">105</span>,        <span class="hljs-string">&quot;domContentLoadedEventEnd&quot;</span>: now + <span class="hljs-number">111</span>,        <span class="hljs-string">&quot;domComplete&quot;</span>: now + <span class="hljs-number">111</span>,        <span class="hljs-string">&quot;loadEventStart&quot;</span>: now + <span class="hljs-number">111</span>,        <span class="hljs-string">&quot;loadEventEnd&quot;</span>: now + <span class="hljs-number">111</span>,    &#125;    <span class="hljs-keyword">return</span> tim&#125;</code></pre><h2><span id="guan-yu-yan-zheng-ma-de-shi-bie">关于验证码的识别</span></h2><p>识别主要有三种方法，第一个是会深度学习的话，自己用 OpenCV 之类的去识别，第二个当然是非常牛逼的 ddddocr（<a href="https://github.com/sml2h3/ddddocr%EF%BC%89%EF%BC%8C%E8%BF%98%E6%94%AF%E6%8C%81%E8%87%AA%E5%B7%B1%E8%AE%AD%E7%BB%83%EF%BC%8C%E6%98%AF%E4%B8%8D%E9%94%99%E7%9A%84%E9%80%89%E6%8B%A9%EF%BC%8C%E5%BD%93%E7%84%B6%E4%B9%9F%E6%9C%89%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E5%BC%80%E6%BA%90%E5%BA%93%EF%BC%8C%E8%BF%99%E9%87%8C%E5%B0%B1%E4%B8%8D%E4%B8%80%E4%B8%80%E4%B8%BE%E4%BE%8B%E4%BA%86%EF%BC%8C%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%B0%B1%E6%98%AF%E6%89%93%E7%A0%81%E5%B9%B3%E5%8F%B0%EF%BC%8C%E8%BF%99%E9%87%8C%E6%8E%A8%E8%8D%90%E4%BA%91%E7%A0%81%E6%89%93%E7%A0%81%EF%BC%8C%E5%8F%AF%E9%80%9A%E8%BF%87%E6%88%91%E7%9A%84%E9%93%BE%E6%8E%A5%E6%B3%A8%E5%86%8C%EF%BC%9Ahttps://www.jfbym.com/register/TG17764">https://github.com/sml2h3/ddddocr），还支持自己训练，是不错的选择，当然也有一些其他开源库，这里就不一一举例了，第三个就是打码平台，这里推荐云码打码，可通过我的链接注册：https://www.jfbym.com/register/TG17764</a> ，自己去官网看，支持非常多的类型，甚至谷歌验证码都可以，价格也不贵，实测成功率 99%，还是不错的。这里贴一个 OpenCV 识别滑块的源码（来源于互联网收集），效果还不错：</p><pre><code class="hljs python"><span class="hljs-comment"># CV2 识别滑块缺口距离</span><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> PIL<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">imshow</span>(<span class="hljs-params">img, winname=<span class="hljs-string">&#x27;test&#x27;</span>, delay=<span class="hljs-number">0</span></span>):</span>    <span class="hljs-string">&quot;&quot;&quot;cv2展示图片&quot;&quot;&quot;</span>    cv2.imshow(winname, img)    cv2.waitKey(delay)    cv2.destroyAllWindows()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pil_to_cv2</span>(<span class="hljs-params">img</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    pil转cv2图片</span><span class="hljs-string">    :param img: pil图像, &lt;type &#x27;PIL.JpegImagePlugin.JpegImageFile&#x27;&gt;</span><span class="hljs-string">    :return: cv2图像, &lt;type &#x27;numpy.ndarray&#x27;&gt;</span><span class="hljs-string">    &quot;&quot;&quot;</span>    img = cv2.cvtColor(np.asarray(img), cv2.COLOR_RGB2BGR)    <span class="hljs-keyword">return</span> img<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bytes_to_cv2</span>(<span class="hljs-params">img</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    二进制图片转cv2</span><span class="hljs-string">    :param img: 二进制图片数据, &lt;type &#x27;bytes&#x27;&gt;</span><span class="hljs-string">    :return: cv2图像, &lt;type &#x27;numpy.ndarray&#x27;&gt;</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 将图片字节码bytes, 转换成一维的numpy数组到缓存中</span>    img_buffer_np = np.frombuffer(img, dtype=np.uint8)    <span class="hljs-comment"># 从指定的内存缓存中读取一维numpy数据, 并把数据转换(解码)成图像矩阵格式</span>    img_np = cv2.imdecode(img_buffer_np, <span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> img_np<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cv2_open</span>(<span class="hljs-params">img, flag=<span class="hljs-literal">None</span></span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    统一输出图片格式为cv2图像, &lt;type &#x27;numpy.ndarray&#x27;&gt;</span><span class="hljs-string">    :param img: &lt;type &#x27;bytes&#x27;/&#x27;numpy.ndarray&#x27;/&#x27;str&#x27;/&#x27;Path&#x27;/&#x27;PIL.JpegImagePlugin.JpegImageFile&#x27;&gt;</span><span class="hljs-string">    :param flag: 颜色空间转换类型, default: None</span><span class="hljs-string">        eg: cv2.COLOR_BGR2GRAY（灰度图）</span><span class="hljs-string">    :return: cv2图像, &lt;numpy.ndarray&gt;</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(img, <span class="hljs-built_in">bytes</span>):        img = bytes_to_cv2(img)    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(img, (<span class="hljs-built_in">str</span>, Path)):        img = cv2.imread(<span class="hljs-built_in">str</span>(img))    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(img, np.ndarray):        img = img    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(img, PIL.Image.Image):        img = pil_to_cv2(img)    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;输入的图片类型无法解析: <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(img)&#125;</span>&#x27;</span>)    <span class="hljs-keyword">if</span> flag <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:        img = cv2.cvtColor(img, flag)    <span class="hljs-keyword">return</span> img<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_distance</span>(<span class="hljs-params">bg, tp, im_show=<span class="hljs-literal">False</span>, save_path=<span class="hljs-literal">None</span></span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    :param bg: 背景图路径或 Path 对象或图片二进制</span><span class="hljs-string">               eg: &#x27;assets/bg.jpg&#x27;、Path(&#x27;assets/bg.jpg&#x27;)</span><span class="hljs-string">    :param tp: 缺口图路径或 Path 对象或图片二进制</span><span class="hljs-string">               eg: &#x27;assets/tp.jpg&#x27;、Path(&#x27;assets/tp.jpg&#x27;)</span><span class="hljs-string">    :param im_show: 是否显示结果, &lt;type &#x27;bool&#x27;&gt;; default: False</span><span class="hljs-string">    :param save_path: 保存路径, &lt;type &#x27;str&#x27;/&#x27;Path&#x27;&gt;; default: None</span><span class="hljs-string">    :return: 缺口位置</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 读取图片</span>    bg_img = cv2_open(bg)    tp_gray = cv2_open(tp, flag=cv2.COLOR_BGR2GRAY)    <span class="hljs-comment"># 金字塔均值漂移</span>    bg_shift = cv2.pyrMeanShiftFiltering(bg_img, <span class="hljs-number">5</span>, <span class="hljs-number">50</span>)    <span class="hljs-comment"># 边缘检测</span>    tp_gray = cv2.Canny(tp_gray, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>)    bg_gray = cv2.Canny(bg_shift, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>)    <span class="hljs-comment"># 目标匹配</span>    result = cv2.matchTemplate(bg_gray, tp_gray, cv2.TM_CCOEFF_NORMED)    <span class="hljs-comment"># 解析匹配结果</span>    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)    distance = max_loc[<span class="hljs-number">0</span>]    <span class="hljs-keyword">if</span> save_path <span class="hljs-keyword">or</span> im_show:        <span class="hljs-comment"># 需要绘制的方框高度和宽度</span>        tp_height, tp_width = tp_gray.shape[:<span class="hljs-number">2</span>]        <span class="hljs-comment"># 矩形左上角点位置</span>        x, y = max_loc        <span class="hljs-comment"># 矩形右下角点位置</span>        _x, _y = x + tp_width, y + tp_height        <span class="hljs-comment"># 绘制矩形</span>        bg_img = cv2_open(bg)        cv2.rectangle(bg_img, (x, y), (_x, _y), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)        <span class="hljs-comment"># 保存缺口识别结果到背景图</span>        <span class="hljs-keyword">if</span> save_path:            save_path = Path(save_path).resolve()            save_path = save_path.parent / <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;save_path.stem&#125;</span><span class="hljs-subst">&#123;save_path.suffix&#125;</span>&quot;</span>            save_path = save_path.__str__()            cv2.imwrite(save_path, bg_img)        <span class="hljs-comment"># 显示缺口识别结果</span>        <span class="hljs-keyword">if</span> im_show:            imshow(bg_img)    <span class="hljs-keyword">return</span> distance<span class="hljs-comment"># with open(&quot;./img/slide_bg.jpg&quot;, &quot;rb&quot;) as f:</span><span class="hljs-comment">#     bg_img = f.read()</span><span class="hljs-comment"># with open(&quot;./img/slide_slice.png&quot;, &quot;rb&quot;) as f:</span><span class="hljs-comment">#     slice_img = f.read()</span><span class="hljs-comment"># distance = get_distance(bg_img, slice_img)</span><span class="hljs-comment"># print(distance)</span></code></pre><h2><span id="guan-yu-gui-ji-de-sheng-cheng">关于轨迹的生成</span></h2><p>轨迹主要是针对滑块的，可以利用贝塞尔曲线、缓动函数等，来生成正确的轨迹，基于贝塞尔曲线的可以参考：<a href="https://github.com/2833844911/gurs">https://github.com/2833844911/gurs</a> ，吾爱上也有个大佬利用 <code>tanh</code> 和 <code>arctan</code> 函数整合生成轨迹的：<a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1162979">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1162979</a></p><p>基于缓动函数的可以参考以下代码（来源于互联网收集）：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__ease_out_expo</span>(<span class="hljs-params">sep</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    缓动函数 easeOutExpo</span><span class="hljs-string">    参考：https://easings.net/zh-cn#easeOutExpo</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">if</span> sep == <span class="hljs-number">1</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> - <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, -<span class="hljs-number">10</span> * sep)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_slide_track</span>(<span class="hljs-params">distance</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    根据滑动距离生成滑动轨迹</span><span class="hljs-string">    :param distance: 需要滑动的距离</span><span class="hljs-string">    :return: 滑动轨迹&lt;type &#x27;list&#x27;&gt;: [[x,y,t], ...]</span><span class="hljs-string">        x: 已滑动的横向距离</span><span class="hljs-string">        y: 已滑动的纵向距离, 除起点外, 均为0</span><span class="hljs-string">        t: 滑动过程消耗的时间, 单位: 毫秒</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(distance, <span class="hljs-built_in">int</span>) <span class="hljs-keyword">or</span> distance &lt; <span class="hljs-number">0</span>:        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;distance类型必须是大于等于0的整数: distance: <span class="hljs-subst">&#123;distance&#125;</span>, type: <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(distance)&#125;</span>&quot;</span>)    <span class="hljs-comment"># 初始化轨迹列表</span>    slide_track = [        [random.randint(-<span class="hljs-number">50</span>, -<span class="hljs-number">10</span>), random.randint(-<span class="hljs-number">50</span>, -<span class="hljs-number">10</span>), <span class="hljs-number">0</span>],        [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],    ]    <span class="hljs-comment"># 共记录count次滑块位置信息</span>    count = <span class="hljs-number">30</span> + <span class="hljs-built_in">int</span>(distance / <span class="hljs-number">2</span>)    <span class="hljs-comment"># 初始化滑动时间</span>    t = random.randint(<span class="hljs-number">50</span>, <span class="hljs-number">100</span>)    <span class="hljs-comment"># 记录上一次滑动的距离</span>    _x = <span class="hljs-number">0</span>    _y = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(count):        <span class="hljs-comment"># 已滑动的横向距离</span>        x = <span class="hljs-built_in">round</span>(__ease_out_expo(i / count) * distance)        <span class="hljs-comment"># 滑动过程消耗的时间</span>        t += random.randint(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)        <span class="hljs-keyword">if</span> x == _x:            <span class="hljs-keyword">continue</span>        slide_track.append([x, _y, t])        _x = x    slide_track.append(slide_track[-<span class="hljs-number">1</span>])    <span class="hljs-keyword">return</span> slide_track</code></pre><h2><span id="qi-ta-ke-neng-de-bao-cuo">其他可能的报错</span></h2><pre><code class="hljs javascript"><span class="hljs-comment">// challenge 不对</span>geetest_xxxxxxxxxxxxx(&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;illegal challenge&quot;</span>, <span class="hljs-string">&quot;user_error&quot;</span>: <span class="hljs-string">&quot;网络不给力&quot;</span>, <span class="hljs-string">&quot;error_code&quot;</span>: <span class="hljs-string">&quot;error_23&quot;</span>&#125;)<span class="hljs-comment">// w 生成不对</span>geetest_xxxxxxxxxxxxx(&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;param decrypt error&quot;</span>, <span class="hljs-string">&quot;user_error&quot;</span>: <span class="hljs-string">&quot;网络不给力&quot;</span>, <span class="hljs-string">&quot;error_code&quot;</span>: <span class="hljs-string">&quot;error_03&quot;</span>&#125;)<span class="hljs-comment">// 滑动验证没有轨迹</span>geetest_xxxxxxxxxxxxx(&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;not proof&quot;</span>, <span class="hljs-string">&quot;user_error&quot;</span>: <span class="hljs-string">&quot;网络不给力&quot;</span>, <span class="hljs-string">&quot;error_code&quot;</span>: <span class="hljs-string">&quot;error_21&quot;</span>&#125;)<span class="hljs-comment">// 轨迹、缺口距离、参数问题</span>geetest_xxxxxxxxxxxxx(&#123;<span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;fail&quot;</span>&#125;)geetest_xxxxxxxxxxxxx(&#123;<span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;forbidden&quot;</span>&#125;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>极验三代、四代点选类验证码逆向分析</title>
    <link href="https://www.itbob.cn/article/066/"/>
    <id>https://www.itbob.cn/article/066/</id>
    <published>2023-03-15T11:00:00.000Z</published>
    <updated>2023-03-15T11:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#tong-xun-liu-cheng">通讯流程</a></li><li><a href="#san-dai-zhua-bao-qing-kuang">三代抓包情况</a></li><li><a href="#san-dai-ni-xiang-fen-xi">三代逆向分析</a><ul><li><a href="#w-can-shu-ni-xiang">w 参数逆向</a></li></ul></li><li><a href="#jie-guo-yan-zheng">结果验证</a></li><li><a href="#si-dai-zhua-bao-qing-kuang">四代抓包情况</a></li><li><a href="#si-dai-ni-xiang-fen-xi">四代逆向分析</a><ul><li><a href="#w-can-shu">w 参数</a></li></ul></li><li><a href="#jie-guo-yan-zheng-1">结果验证</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：某验三代、四代点选类验证码（文字、字序、图标、九宫格）逆向分析</li><li>三代主页：<code>aHR0cHM6Ly93d3cuZ2VldGVzdC5jb20vc2hvdw==</code></li><li>四代主页：<code>aHR0cHM6Ly9ndDQuZ2VldGVzdC5jb20v</code></li></ul><h2><span id="tong-xun-liu-cheng">通讯流程</span></h2><p>接口相关：</p><p><img src="https://cdn.itbob.cn/img/article/066/01.png" alt="01"></p><p>完整流程：</p><p><img src="https://cdn.itbob.cn/img/article/066/02.jpg" alt="02"></p><h2><span id="san-dai-zhua-bao-qing-kuang">三代抓包情况</span></h2><p>通过抓包发现，<code>register-click-official</code> 接口会返回 <code>challenge</code> 和 <code>gt</code> 值，为 <code>get.php</code> 接口的关键请求参数：</p><p><img src="https://cdn.itbob.cn/img/article/066/03.png" alt="03"></p><p><code>get.php</code> 会返回 <code>c</code> 和 <code>s</code>，同样后面会用到，这个接口的 <code>w</code> 值与三代无感不同，可以置空：</p><p><img src="https://cdn.itbob.cn/img/article/066/04.png" alt="04"></p><p>点击按钮进行验证，会弹出文字点选框，此时抓包到第一个 <code>ajax.php</code> 接口，虽然只返回了验证码类型，没什么关键参数，但是不请求会报错，点击文字进行验证后，抓到第二个 <code>ajax.php</code> 接口，返回验证结果及 <code>validate</code> 参数的值，该值登录接口会用到：</p><p><img src="https://cdn.itbob.cn/img/article/066/05.png" alt="05"></p><h2><span id="san-dai-ni-xiang-fen-xi">三代逆向分析</span></h2><h3><span id="w-can-shu-ni-xiang">w 参数逆向</span></h3><p>从 <code>ajax.php</code> 接口处跟栈或者直接搜索特征码 <code>&quot;\u0077&quot;</code> 即可定位到 <code>w</code> 参数值生成的位置，位于 <code>click.3.0.7.js</code> 文件的第 5839 行：</p><p><img src="https://cdn.itbob.cn/img/article/066/06.png" alt="06"></p><p><code>p + l = w</code>，关键代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> l = n[$_CACJJ(<span class="hljs-number">716</span>)](), h = X[$_CADAG(<span class="hljs-number">338</span>)](ae[$_CACJJ(<span class="hljs-number">130</span>)](o), n[$_CADAG(<span class="hljs-number">711</span>)]()), p = w[$_CADAG(<span class="hljs-number">776</span>)](h)</code></pre><p>先来看看 l 参数，跟到 <code>n[$_CACJJ(716)]</code> 中去，<code>this[$_CBFJA(711)](e)</code> 为十六位随机字符串，跟到 <code>this[$_CBFJA(711)]</code> 中将算法扣下来即可：</p><p><img src="https://cdn.itbob.cn/img/article/066/07.png" alt="07"></p><p>因此 t 是将十六位随机字符串加密后得到的，这里为 RSA 加密，从原型链中跟进去即可找到公钥和模值，将代码扣下来或者直接用库都行，至此 l 值分析完了，接下来是 h 值，<code>n[$_CADAG(711)]()</code> 同样是十六位随机字符串，h 参数的加密方法为 <code>X[$_CADAG(338)]</code>，跟进去打断分析会发现是 AES 加密，初始向量 iv 为 <code>0000000000000000</code>：</p><p><img src="https://cdn.itbob.cn/img/article/066/08.png" alt="08"></p><p>o 值的关键参数如下：</p><ul><li>passtime：图片加载时间</li><li>a：点选文字位置</li><li>pic：背景图片链接</li><li>tt：将 c、s、鼠标信息等进行加密，某些值可以固定，加密方法直接扣下来即可</li><li><code>h9s9: &quot;1816378497&quot;</code>：该键值对每天变化，扣法往期文章讲过</li><li>rp：将 gt、challenge、passtime 经过 MD5 加密</li></ul><p>将 h 经过 <code>w[$_CADAG(776)]</code> 方法加密后得到 p，跟进去扣下来即可，三代图标、语序除了 a 的写法，其他逻辑都是一样的。</p><h2><span id="jie-guo-yan-zheng">结果验证</span></h2><p><img src="https://cdn.itbob.cn/img/article/066/09.png" alt="09"></p><h2><span id="si-dai-zhua-bao-qing-kuang">四代抓包情况</span></h2><p>抓包，<code>load</code> 接口返回值如下：</p><p><img src="https://cdn.itbob.cn/img/article/066/10.png" alt="10"></p><ul><li>captcha_type：验证码类型，文字点选为 word</li><li>gct_path：gct4 文件路径</li><li>lot_number：生成 pow_msg、w 的关键参数</li><li>pow_detail：bits、datetime、hashfunc 都与 w 参数有关</li><li>payload：verify 请求参数</li><li>process_token：verify 请求参数</li><li>ques：各文字图片的链接</li></ul><p>点击验证后，<code>verify</code> 接口返回校验结果及 login 请求参数：</p><p><img src="https://cdn.itbob.cn/img/article/066/11.png" alt="11"></p><ul><li>result：校验结果，成功即 success，失败为 fail</li><li>captcha_id：验证码 id</li><li>captcha_output：login 请求参数</li><li>gen_time：login 请求参数</li><li>lot_number：login 请求参数</li><li>pass_token：login 请求参数</li></ul><p><code>login</code> 接口验证登录成功则返回：</p><p><img src="https://cdn.itbob.cn/img/article/066/12.png" alt="12"></p><h2><span id="si-dai-ni-xiang-fen-xi">四代逆向分析</span></h2><h3><span id="w-can-shu">w 参数</span></h3><p>与三代文字点选一样，四代的 w 参数同样直接搜索 <code>&quot;\u0077&quot;</code> 即可定位到，r 为 w 参数的值：</p><p><img src="https://cdn.itbob.cn/img/article/066/13.png" alt="13"></p><p>r 参数定义在第 6096 行，内容如下：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> r = (<span class="hljs-number">0</span>, d[$_CBHIU(<span class="hljs-number">47</span>)])(f[$_CBHHP(<span class="hljs-number">47</span>)][$_CBHIU(<span class="hljs-number">541</span>)](e), i)</code></pre><p>跟进到 <code>d[$_CBHIU(47)]</code> 中，<code>(0, d[$_DIEHV(186)])(c) + u</code> 即 w 值：</p><p><img src="https://cdn.itbob.cn/img/article/066/14.png" alt="14"></p><p>u 定义在第 11461 行：</p><pre><code class="hljs JavaScript">u = <span class="hljs-keyword">new</span> l[($_DIEIo(<span class="hljs-number">47</span>))]()[$_DIEIo(<span class="hljs-number">1443</span>)](i)</code></pre><p>由上可知，u 是将 i 经过加密后得到的值，i 定义在上面一行，跟进去会发现是十六位随机字符串，u 的加密方式为 RSA，公钥和模值如下，将加密算法扣下来或者直接用库都可：</p><p><img src="https://cdn.itbob.cn/img/article/066/15.png" alt="15"></p><p><code>(0, d[$_DIEHV(186)])(c)</code> 是将 c 进行了加密处理，c 定义在第 11462 行：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> c = s[a][$_DIEIo(<span class="hljs-number">1488</span>)][$_DIEIo(<span class="hljs-number">1443</span>)](e, i);</code></pre><p>i 上文讲了，为十六位随机字符串，e 中 <code>device_id</code>、<code>lot_number</code> 由 <code>load</code> 接口返回，<code>userresponse</code>  为点选坐标，<code>pow_msg</code> 为 <code>&quot;1|0|md5|&quot; + datetime + &quot;|&quot; +  captcha_id + &quot;|&quot; + lot_number + &quot;||&quot; + 16位随机数</code>，<code>pow_msg</code> 经过 MD5 加密即为 <code>pow_sign</code>，<code>&quot;f019&quot;:&quot;1024281898&quot;</code> 为动态变化的键值对，在往期四代滑块的文章中均有详细介绍，其他值固定即可：</p><p><img src="https://cdn.itbob.cn/img/article/066/16.png" alt="16"></p><p>接下来跟进到 <code>s[a][$_DIEIo(1488)][$_DIEIo(1443)]</code> 中，c 为 AES 加密，扣代码或者直接用库：</p><p><img src="https://cdn.itbob.cn/img/article/066/17.png" alt="17"></p><p>四代图标、字序、九宫格除了 userresponse 的写法，其他逻辑都是一样的。</p><h2><span id="jie-guo-yan-zheng">结果验证</span></h2><p><img src="https://cdn.itbob.cn/img/article/066/18.png" alt="18"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>极验四代五子棋、消消乐验证码逆向分析</title>
    <link href="https://www.itbob.cn/article/065/"/>
    <id>https://www.itbob.cn/article/065/</id>
    <published>2023-03-14T06:00:00.000Z</published>
    <updated>2023-03-15T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#tong-xun-liu-cheng">通讯流程</a></li><li><a href="#xiao-xiao-le-liu-cheng-fen-xi">消消乐流程分析</a></li><li><a href="#ni-xiang-fen-xi">逆向分析</a><ul><li><a href="#w-can-shu">w 参数</a></li></ul></li><li><a href="#xiao-xiao-le-jie-guo-yan-zheng">消消乐结果验证</a></li><li><a href="#wu-zi-qi-liu-cheng-fen-xi">五子棋流程分析</a></li><li><a href="#wu-zi-qi-jie-guo-yan-zheng">五子棋结果验证</a></li><li><a href="#wu-zi-qi-he-xiao-xiao-le-suan-fa">五子棋和消消乐算法</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li><p>目标：某验四代消消乐、五子棋验证码，w 参数逆向及算法分析</p></li><li><p>行为验证 4.0 demo：<code>aHR0cHM6Ly9ndDQuZ2VldGVzdC5jb20v</code></p></li><li><p>加密算法：RSA、AES、MD5</p></li></ul><h2><span id="tong-xun-liu-cheng">通讯流程</span></h2><p><img src="https://cdn.itbob.cn/img/article/065/01.png" alt="01"></p><h2><span id="xiao-xiao-le-liu-cheng-fen-xi">消消乐流程分析</span></h2><p><img src="https://cdn.itbob.cn/img/article/065/02.png" alt="02"></p><p>进入网页后，F12 进行抓包，选择消消乐验证码，抓包到 <code>load</code> 接口：</p><p><img src="https://cdn.itbob.cn/img/article/065/03.png" alt="03"></p><ul><li><code>captcha_id</code>：验证码 id，固定值，四代滑块文章中有讲；</li><li><code>challenge</code>：动态变化，由 <code>gtc4.js</code> 文件生成，四代滑块文章中有讲；</li><li><code>client_type</code>：web 端；</li><li><code>risk_type</code>：验证码类型，例如滑块为 slide，无感为 ai，消消乐为 match；</li><li><code>lang</code>：语言；</li><li><code>callback</code>：回调参数，<code>geetest_</code> + 时间戳。</li></ul><p>响应预览中返回的关键内容如下：</p><p><img src="https://cdn.itbob.cn/img/article/065/04.png" alt="04"></p><ul><li><code>captcha_type</code>：验证码类型；</li><li><code>gct_path</code>：gct4 文件路径；</li><li><code>lot_number</code>：生成 pow_msg、w 的关键参数；</li><li><code>payload</code>：verify 请求参数；</li><li><code>datetime</code>：ISO 8601 扩展格式的日期，生成 pow_msg 的关键参数；</li><li><code>process_token</code>：verify 请求参数；</li><li><code>ques</code>：消消乐矩阵（3x3），每个数字代表一种颜色，将三个相同数字换到同一列或同一行即可通过。</li></ul><p>点击验证按钮，弹出消消乐验证码，移动图案之后，抓包到 <code>verify</code> 校验接口：</p><p><img src="https://cdn.itbob.cn/img/article/065/05.png" alt="05"></p><ul><li><code>captcha_id</code>：与 load 请求头中的 captcha_id 一致；</li><li><code>client_type</code>：web 端；</li><li><code>lot_number</code>：load 响应返回；</li><li><code>risk_type</code>：验证码类型；</li><li><code>payload</code>：load 响应返回；</li><li><code>process_token</code>：load 响应返回；</li><li><code>payload_protocol</code>：1；</li><li><code>pt</code>：1；</li><li><code>w</code>：加密参数，由轨迹、passtime、userresponse 等参数加密得到；</li><li><code>callback</code>：回调参数，<code>geetest_</code> + 时间戳。</li></ul><p>响应预览中返回的内容如下，result 值为 success 即校验通过，fail 即校验失败，携带 seccode 下的五个参数请求 login 接口，即可登录成功：</p><p><img src="https://cdn.itbob.cn/img/article/065/06.png" alt="06"></p><h2><span id="ni-xiang-fen-xi">逆向分析</span></h2><h3><span id="w-can-shu">w 参数</span></h3><p>四代的基本流程都是差不多的，直接搜索特征值 <code>&quot;\u0077&quot;</code> 即可定位到 w 参数生成的位置，先全局搜索 <code>&quot;\u0077&quot;</code>，找到对应的 js 文件，点击进去格式化后，再 ctrl + f 局部搜索定位关键位置：</p><p><img src="https://cdn.itbob.cn/img/article/065/07.png" alt="07"></p><p>在第 6251 行打下断点，移动图案即会断住，<code>r</code> 即 <code>w</code> 参数的值：</p><p><img src="https://cdn.itbob.cn/img/article/065/08.png" alt="08"></p><p>跟进 r 生成的位置，其定义在第 6237 行，可以看到加密方式与四代滑块是一样的：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> r = (<span class="hljs-number">0</span>,d.default)(f.default.stringify(e), i)</code></pre><p>唯一不同的就是 e 中参数值的构成，以下是四代滑块与消消乐的对比：</p><p><img src="https://cdn.itbob.cn/img/article/065/09.png" alt="09"></p><p>可以看到不同点在于四代滑块 e 中参数包括 <code>setLeft</code>（缺口距离）、<code>track</code>（滑动轨迹），自然消消乐是没有的，<code>userresponse</code> 在滑块中是数值计算，而消消乐中是交换的两个图片的坐标，举个例子：</p><p><img src="https://cdn.itbob.cn/img/article/065/10.png" alt="10"></p><p>上图中的验证码，接口返回的 <code>ques</code> 值为：</p><pre><code class="hljs javascript">ques = [    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],     [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>],     [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]]</code></pre><p><code>ques[0]</code>、<code>ques[1]</code>、<code>ques[2]</code> 分别对应验证码的第0列、第1列、第2列，注意是列，不是行！而我们只需要关心 ques 数组里的交换即可，正确应该交换第0行第1列和第0行第0列，那么 <code>userresponse</code> 的值应该为：<code>[[0, 1], [0, 0]]</code>。</p><p>其他参数值的生成都是一样的方式，具体可以阅读 K 哥往期文章<a href="https://mp.weixin.qq.com/s/zNb1uyzwU7a5n-zfRbN3bw">《【验证码逆向专栏】某验四代滑块验证码逆向分析》</a>，这里就不再重复写了。</p><h2><span id="xiao-xiao-le-jie-guo-yan-zheng">消消乐结果验证</span></h2><p>只要 JS 和交换的坐标没问题，成功率就为 100%。</p><p><img src="https://cdn.itbob.cn/img/article/065/11.png" alt="11"></p><h2><span id="wu-zi-qi-liu-cheng-fen-xi">五子棋流程分析</span></h2><p><img src="https://cdn.itbob.cn/img/article/065/12.png" alt="12"></p><p>五子棋的流程跟消消乐一样，进入网页后，F12 进行抓包，选择五子棋验证码，抓包到 <code>load</code> 接口：</p><p><img src="https://cdn.itbob.cn/img/article/065/13.png" alt="13"></p><ul><li><code>captcha_id</code>：验证码 id，固定值，四代滑块文章中有讲；</li><li><code>challenge</code>：动态变化，由 <code>gtc4.js</code> 文件生成，四代滑块文章中有讲；</li><li><code>client_type</code>：web 端；</li><li><code>risk_type</code>：验证码类型，例如滑块为 slide，无感为 ai，五子棋为 winlinze；</li><li><code>lang</code>：语言；</li><li><code>callback</code>：回调参数，geetest_ + 时间戳。</li></ul><p>响应预览中返回的关键内容如下：</p><p><img src="https://cdn.itbob.cn/img/article/065/14.png" alt="14"></p><ul><li><code>captcha_type</code>：验证码类型；</li><li><code>gct_path</code>：gct4 文件路径；</li><li><code>lot_number</code>：生成 pow_msg、w 的关键参数；</li><li><code>payload</code>：verify 请求参数；</li><li><code>datetime</code>：ISO 8601 扩展格式的日期，生成 pow_msg 的关键参数；</li><li><code>process_token</code>：verify 请求参数；</li><li><code>ques</code>：五子棋矩阵（5x5），每个数字代表一种颜色，0 表示空位，将五个相同数字换到同一列、同一行或对角线上即可通过。</li></ul><p>其他的与消消乐是一样的，e 参数如下，其中 <code>userresponse</code> 就是需要交换的两个棋子的坐标：</p><p><img src="https://cdn.itbob.cn/img/article/065/15.png" alt="15"></p><h2><span id="wu-zi-qi-jie-guo-yan-zheng">五子棋结果验证</span></h2><p>同样的，只要 JS 和交换的坐标没问题，成功率就为 100%。</p><p><img src="https://cdn.itbob.cn/img/article/065/16.png" alt="16"></p><h2><span id="wu-zi-qi-he-xiao-xiao-le-suan-fa">五子棋和消消乐算法</span></h2><p>以下是消消乐和五子棋坐标交换的 Python 算法，注意是交换坐标的算法哟，不是全部的代码哈，消消乐大概30来行，五子棋大概60来行，还是很简单的，有需要的可以看看。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">match_algorithm</span>(<span class="hljs-params">ques</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;消消乐算法&quot;&quot;&quot;</span>    <span class="hljs-comment"># 横向查找</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_x</span>(<span class="hljs-params">matrix</span>):</span>        <span class="hljs-keyword">for</span> index, array <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(matrix):            unique_list = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(array))            two_num = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> unique_list <span class="hljs-keyword">if</span> array.count(x) == <span class="hljs-number">2</span>]            <span class="hljs-keyword">if</span> two_num:                one_num = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> unique_list <span class="hljs-keyword">if</span> array.count(x) == <span class="hljs-number">1</span>]                one_num_index = array.index(one_num[<span class="hljs-number">0</span>])                <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span>:                    <span class="hljs-keyword">if</span> matrix[index+<span class="hljs-number">1</span>][one_num_index] == two_num[<span class="hljs-number">0</span>]:                        <span class="hljs-keyword">return</span> [[index+<span class="hljs-number">1</span>, one_num_index], [index, one_num_index]]                <span class="hljs-keyword">if</span> index == <span class="hljs-number">1</span>:                    <span class="hljs-keyword">if</span> matrix[index-<span class="hljs-number">1</span>][one_num_index] == two_num[<span class="hljs-number">0</span>]:                        <span class="hljs-keyword">return</span> [[index-<span class="hljs-number">1</span>, one_num_index], [index, one_num_index]]                    <span class="hljs-keyword">if</span> matrix[index+<span class="hljs-number">1</span>][one_num_index] == two_num[<span class="hljs-number">0</span>]:                        <span class="hljs-keyword">return</span> [[index+<span class="hljs-number">1</span>, one_num_index], [index, one_num_index]]                <span class="hljs-keyword">if</span> index == <span class="hljs-number">2</span>:                    <span class="hljs-keyword">if</span> matrix[index-<span class="hljs-number">1</span>][one_num_index] == two_num[<span class="hljs-number">0</span>]:                        <span class="hljs-keyword">return</span> [[index-<span class="hljs-number">1</span>, one_num_index], [index, one_num_index]]    <span class="hljs-comment"># 纵向查找</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_y</span>(<span class="hljs-params">matrix</span>):</span>        <span class="hljs-comment"># 转置原数组</span>        transposition_array = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">list</span>, <span class="hljs-built_in">zip</span>(*matrix)))        x_result = check_x(transposition_array)        actual_result = [[x_result[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], x_result[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]], [x_result[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], x_result[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]]]        <span class="hljs-keyword">return</span> actual_result    result = check_x(ques)    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:        result = check_y(ques)    <span class="hljs-keyword">return</span> result<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">winlinze_algorithm</span>(<span class="hljs-params">ques</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;五子棋算法&quot;&quot;&quot;</span>    <span class="hljs-comment"># 横向查找</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_x</span>(<span class="hljs-params">matrix</span>):</span>        <span class="hljs-keyword">for</span> index1, array1 <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(matrix):            unique_list = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(array1))            four_num = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> unique_list <span class="hljs-keyword">if</span> array1.count(x) == <span class="hljs-number">4</span> <span class="hljs-keyword">and</span> x != <span class="hljs-number">0</span>]            <span class="hljs-keyword">if</span> four_num:                one_num = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> unique_list <span class="hljs-keyword">if</span> array1.count(x) == <span class="hljs-number">1</span>]                one_num_index = array1.index(one_num[<span class="hljs-number">0</span>])                <span class="hljs-keyword">for</span> index2, array2 <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(matrix):                    <span class="hljs-keyword">for</span> arr <span class="hljs-keyword">in</span> array2:                        <span class="hljs-keyword">if</span> four_num[<span class="hljs-number">0</span>] == arr <span class="hljs-keyword">and</span> index2 != index1:                            arr_index = array2.index(arr)                            <span class="hljs-keyword">return</span> [[index2, arr_index], [index1, one_num_index]]    <span class="hljs-comment"># 纵向查找</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_y</span>(<span class="hljs-params">matrix</span>):</span>        transposition_array = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">list</span>, <span class="hljs-built_in">zip</span>(*matrix)))        x_result = check_x(transposition_array)        <span class="hljs-keyword">if</span> x_result:            actual_result = [[x_result[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], x_result[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]], [x_result[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], x_result[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]]]            <span class="hljs-keyword">return</span> actual_result    <span class="hljs-comment"># 对角查找(左 → 右: \)</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_left_to_right</span>(<span class="hljs-params">matrix</span>):</span>        array_left_to_right = []        <span class="hljs-keyword">for</span> index1, array1 <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(matrix):            array_left_to_right.append(array1[index1])        unique_list = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(array_left_to_right))        four_num = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> unique_list <span class="hljs-keyword">if</span> array_left_to_right.count(x) == <span class="hljs-number">4</span> <span class="hljs-keyword">and</span> x != <span class="hljs-number">0</span>]        <span class="hljs-keyword">if</span> four_num:            one_num = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> unique_list <span class="hljs-keyword">if</span> array_left_to_right.count(x) == <span class="hljs-number">1</span>]            one_num_index = array_left_to_right.index(one_num[<span class="hljs-number">0</span>])            <span class="hljs-keyword">for</span> index2, array2 <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(matrix):                <span class="hljs-keyword">for</span> index3, array3 <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(array2):                    <span class="hljs-keyword">if</span> four_num[<span class="hljs-number">0</span>] == array3 <span class="hljs-keyword">and</span> index2 != index3:                        <span class="hljs-keyword">return</span> [[index2, index3], [one_num_index, one_num_index]]    <span class="hljs-comment"># 对角查找(右 → 左: /)</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_right_to_left</span>(<span class="hljs-params">matrix</span>):</span>        reverse_matrix = [m[::-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> matrix]        res = check_left_to_right(reverse_matrix)        actual_result = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res:            <span class="hljs-keyword">if</span> i[<span class="hljs-number">1</span>] &lt; <span class="hljs-number">2</span>:                actual_result.append([i[<span class="hljs-number">0</span>], i[<span class="hljs-number">1</span>]+<span class="hljs-number">2</span>])            <span class="hljs-keyword">elif</span> i[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">2</span>:                actual_result.append([i[<span class="hljs-number">0</span>], i[<span class="hljs-number">1</span>]-<span class="hljs-number">2</span>])            <span class="hljs-keyword">else</span>:                actual_result.append([i[<span class="hljs-number">0</span>], i[<span class="hljs-number">1</span>]])        <span class="hljs-keyword">return</span> actual_result    result = check_x(ques)    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:        result = check_y(ques)    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:        result = check_left_to_right(ques)    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:        result = check_right_to_left(ques)    <span class="hljs-keyword">return</span> result<span class="hljs-comment"># 消消乐示例</span>match_ques = [    [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],     [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>],     [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>]]<span class="hljs-comment"># 五子棋示例</span>winlinze_ques = [    [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],     [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>],     [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],     [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>],     [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]match_result = match_algorithm(match_ques)winlinze_result = winlinze_algorithm(winlinze_ques)<span class="hljs-built_in">print</span>(match_result)<span class="hljs-built_in">print</span>(winlinze_result)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>极验三代、四代无感验证（一键通过）逆向分析</title>
    <link href="https://www.itbob.cn/article/064/"/>
    <id>https://www.itbob.cn/article/064/</id>
    <published>2023-02-20T06:00:00.000Z</published>
    <updated>2023-02-20T06:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#tong-xun-liu-cheng">通讯流程</a></li><li><a href="#san-dai-zhua-bao-qing-kuang">三代抓包情况</a></li><li><a href="#san-dai-ni-xiang-fen-xi">三代逆向分析</a><ul><li><a href="#di-yi-ge-w-zhi">第一个 w  值</a></li><li><a href="#di-er-ge-w-zhi">第二个 w 值</a></li></ul></li><li><a href="#san-dai-jie-guo-yan-zheng">三代结果验证</a></li><li><a href="#si-dai-zhua-bao-qing-kuang">四代抓包情况</a></li><li><a href="#si-dai-ni-xiang-fen-xi">四代逆向分析</a><ul><li><a href="#w-can-shu">w 参数</a></li></ul></li><li><a href="#si-dai-jie-guo-yan-zheng">四代结果验证</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：某验三代、四代一键通过模式（无感验证）逆向分析</li><li>三代主页：<code>aHR0cHM6Ly93d3cuZ2VldGVzdC5jb20vZGVtby9mdWxscGFnZS5odG1s</code></li><li>四代主页：<code>aHR0cHM6Ly9ndDQuZ2VldGVzdC5jb20v</code></li></ul><h2><span id="tong-xun-liu-cheng">通讯流程</span></h2><p>接口相关：</p><p><img src="https://cdn.itbob.cn/img/article/064/01.png" alt="01"></p><p>完整流程：</p><p><img src="https://cdn.itbob.cn/img/article/064/02.jpg" alt="02"></p><h2><span id="san-dai-zhua-bao-qing-kuang">三代抓包情况</span></h2><p><code>register-fullpage</code> 会返回 <code>challenge</code> 和 <code>gt</code> 值，后期有用到。</p><p><img src="https://cdn.itbob.cn/img/article/064/03.png" alt="03"></p><p><code>get.php</code> 会返回 <code>c</code> 和 <code>s</code>，同样后期会用到，这个请求同样需要 <code>w</code> 值，在某验的点选滑块里，这个请求可以不要 <code>w</code> 值，但在三代无感里，必须得要，不然最后是会验证失败的，可能不带 <code>w</code> 请求，返回的 <code>s</code> 是个假的值，导致最后验证失败。</p><p><img src="https://cdn.itbob.cn/img/article/064/04.png" alt="04"></p><p><code>ajax.php</code> 验证是否成功，同样需要 <code>w</code> 值，成功则会返回一个 <code>validate</code>。</p><p><img src="https://cdn.itbob.cn/img/article/064/05.png" alt="05"></p><h2><span id="san-dai-ni-xiang-fen-xi">三代逆向分析</span></h2><h3><span id="di-yi-ge-w-zhi">第一个  w  值</span></h3><p>相信看过K哥以前滑块、点选的文章，对于定位 <code>w</code> 的值很熟练了，这里也是类似的，<code>&quot;\u0077&quot;</code> 就是 <code>&quot;w&quot;</code>，其值为 <code>i + r</code>，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/064/06.png" alt="06"></p><p>主要就是 r、o、i 的值，关键代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> r = t[$_CFAGw(<span class="hljs-number">1326</span>)]()  , o = $_BFx()[$_CFAGw(<span class="hljs-number">1367</span>)](pe[$_CFAFP(<span class="hljs-number">416</span>)](t[$_CFAGw(<span class="hljs-number">353</span>)]), t[$_CFAGw(<span class="hljs-number">1393</span>)]())  , i = O[$_CFAGw(<span class="hljs-number">1375</span>)](o)</code></pre><p>先看看 r，跟进去就是我们熟悉的 RSA 了，和以前的处理一样，把代码扣下来或者用库都行。</p><p><img src="https://cdn.itbob.cn/img/article/064/07.png" alt="07"></p><p>同样需要注意的是上图中 <code>this[$_CHCFe(1393)]()</code> 也是个随机字符串，会遇到多次，但整体一次验证下来都是相同的值，不然验证会失败，点选、滑块等一系列都一样的。</p><p><img src="https://cdn.itbob.cn/img/article/064/08.png" alt="08"></p><p><img src="https://cdn.itbob.cn/img/article/064/09.png" alt="09"></p><p>然后是 o 的值，这里和以前一样，跟进去看仍然是 AES 加密。<code> t[$_CFAGw(1393)]()</code> 依旧是随机字符串。</p><p><img src="https://cdn.itbob.cn/img/article/064/10.png" alt="10"></p><p>中间这一串 <code>pe[$_CFAFP(416)](t[$_CFAGw(353)])</code>，也没啥特别的，除了 <code>gt</code> 和 <code>challenge</code>，其他都是定值，最后面那一串 <code>i</code> 的值，实测写死、置空都行。</p><p><img src="https://cdn.itbob.cn/img/article/064/11.png" alt="11"></p><p>然后继续跟进 <code>i</code>，把前面 <code>o</code> 的值转换成一个大的字符串，这里也不是很复杂，直接扣代码即可：</p><p><img src="https://cdn.itbob.cn/img/article/064/12.png" alt="12"></p><p><img src="https://cdn.itbob.cn/img/article/064/13.png" alt="13"></p><p>然后 <code>i + r</code> 就是 <code>w</code> 的值了，到这里第一个 <code>w</code> 的值就搞完了。</p><h3><span id="di-er-ge-w-zhi">第二个 w 值</span></h3><p>第二个 w 的值和以往的地方都不太一样，不过通过跟栈的方式也很容易找到，来到有个 <code>var n = &#123;&#125;;</code> 的地方，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/064/14.png" alt="14"></p><p><code>t[$_CGABi(1436)]</code> 就是 w 值，也就是 <code>t['$_CEDO']</code>，前面定义了 <code>var t = this</code>，经过第 8215 行的 <code>t[$_CGAAX(1462)]()</code> 之后，就有了 w 的值，所以要跟进去重点看这一行。</p><p><img src="https://cdn.itbob.cn/img/article/064/15.png" alt="15"></p><p>如上图所示，e、t、n、r 中涉及到一些浏览器环境值的计算，当然还有鼠标移动等相关数据的计算，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/064/16.png" alt="16"></p><p>而实际测试发现这四个值直接置空也可以，在本例中可以，不知道是否有其他案例校验更加严格，知道的朋友可以在评论区提出来，再往下，会遇到很多给变量赋值的地方，如下图所示，G 是 MD5 方法，中间的 <code>O[$_CGBFp(948)]</code> 和以前类似，返回一个对象中的 <code>res</code> 和 <code>end</code> 相加，这里就不再赘述了。</p><p><img src="https://cdn.itbob.cn/img/article/064/17.png" alt="17"></p><p><code>i[$_CGBGa(1415)]</code> 这里就是将每个变量和值挨个相加，组成一个大的字符串。</p><p><img src="https://cdn.itbob.cn/img/article/064/18.png" alt="18"></p><p>然后到 r 这里，就多了一个 <code>captcha_token</code>，然后用 <code>&#123;&#125;</code> 将所有数据包了起来。</p><p><img src="https://cdn.itbob.cn/img/article/064/19.png" alt="19"></p><p>这些数据我们格式化一下，大致结构如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/064/20.png" alt="20"></p><p>其中 <code>ep</code> 里面的 <code>ven</code>、<code>ren</code> 是显卡相关信息，<code>fp</code>、<code>lp</code> 是取了两个鼠标移动的位置信息，直接写死为 <code>null</code> 也可以，<code>tm</code> 就是 <code>window.performance.timing</code> 的一些东西，自己随便伪造一下就行了。</p><p>最后一步 <code>i[$_CGDBA(1436)]</code>，随机字符串为 key，将前面的数据 r 进行 AES 加密，得到我们最终的 w 值，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/064/21.png" alt="21"></p><h2><span id="san-dai-jie-guo-yan-zheng">三代结果验证</span></h2><p><img src="https://cdn.itbob.cn/img/article/064/22.png" alt="22"></p><h2><span id="si-dai-zhua-bao-qing-kuang">四代抓包情况</span></h2><p><code>load</code> 接口返回值如下：</p><p><img src="https://cdn.itbob.cn/img/article/064/23.png" alt="23"></p><ul><li><p>captcha_type：验证码类型，无感为 ai</p></li><li><p>gct_path：gct4 文件路径</p></li><li><p>lot_number：生成 pow_msg、w 的关键参数</p></li><li><p>payload：verify 请求参数</p></li><li><p>datetime：ISO 8601 扩展格式的日期，生成 pow_msg 的关键参数</p></li><li><p>process_token：verify 请求参数</p></li></ul><p><code>verify</code> 接口返回值如下：</p><p><img src="https://cdn.itbob.cn/img/article/064/24.png" alt="24"></p><ul><li>captcha_id：验证码 id</li><li>captcha_output：login 请求参数</li><li>gen_time：login 请求参数</li><li>lot_number：login 请求参数</li><li>pass_token：login 请求参数</li></ul><p><code>login</code> 接口验证登录成功：</p><p><img src="https://cdn.itbob.cn/img/article/064/25.png" alt="25"></p><h2><span id="si-dai-ni-xiang-fen-xi">四代逆向分析</span></h2><h3><span id="w-can-shu">w 参数</span></h3><p>与三代无感一样，四代无感 w 参数同样直接搜索 <code>&quot;\u0077&quot;</code> 即可定位到，r 为 w 参数的值：</p><p><img src="https://cdn.itbob.cn/img/article/064/26.png" alt="26"></p><p>r 参数定义在第 6237 行，内容如下：</p><pre><code class="hljs JavaScript">(<span class="hljs-number">0</span>,d[$_CBHHO(<span class="hljs-number">84</span>)])(f[$_CBHIE(<span class="hljs-number">84</span>)][$_CBHHO(<span class="hljs-number">562</span>)](e), i)d[<span class="hljs-string">&quot;default&quot;</span>])(f[<span class="hljs-string">&quot;default&quot;</span>][<span class="hljs-string">&quot;stringify&quot;</span>](e), i)</code></pre><p>由上可知，r 是将 i 参数和转为字符串的 e 参数加密得到的，跟进到 <code>d[$_CBHHO(84)]</code> 中，加密函数定义在第 11669 行，在第 11707 行打下断在，返回值为 r 参数的值，即 w 值：</p><p><img src="https://cdn.itbob.cn/img/article/064/27.png" alt="27"></p><pre><code class="hljs JavaScript">(<span class="hljs-number">0</span>,d[$_DIEHS(<span class="hljs-number">177</span>)])(c) + ud[<span class="hljs-string">&quot;arrayToHex&quot;</span>)(c) + u</code></pre><p>这里是将 c 数组转换成了十六进制的字符串然后加上 u 得到的 r 值，<code>d[$_DIEHS(177)]</code> 跟进去直接扣出来即可，c 定义在第 11705 行：</p><pre><code class="hljs prolog">var c = s[a][$<span class="hljs-symbol">_DIEIq</span>(<span class="hljs-number">1403</span>)][$<span class="hljs-symbol">_DIEHS</span>(<span class="hljs-number">1498</span>)](e, i);var c = s[<span class="hljs-number">1</span>][<span class="hljs-string">&quot;symmetrical&quot;</span>][<span class="hljs-string">&quot;encrypt&quot;</span>](e, i);</code></pre><p>e 后文分析，i 为 16 位字符串：</p><p><img src="https://cdn.itbob.cn/img/article/064/28.png" alt="28"></p><p>i 定义在第 11702 行，跟进到 <code>d[$_DIEIq(103)]</code> 方法中，i 为 16 位随机数：</p><p><img src="https://cdn.itbob.cn/img/article/064/29.png" alt="29"></p><p>e 参数内容如下：</p><p><img src="https://cdn.itbob.cn/img/article/064/30.png" alt="30"></p><p><code>device_id</code>、<code>lot_number</code> 由 <code>load</code> 接口返回，<code>pow_msg</code> 为 <code>&quot;1|0|md5|&quot; + datetime + &quot;|&quot; +  captcha_id + &quot;|&quot; + lot_number + &quot;||&quot; + 16位随机数</code>，<code>pow_msg</code> 经过 MD5 加密即为 <code>pow_sign</code>，<code>&quot;l0zs&quot;:&quot;53502544&quot;</code> 为动态变化的键值对，在往期四代滑块的文章中均有详细介绍，接下来跟进到 <code>s[a][$_DIEIq(1403)][$_DIEHS(1498)]</code> 中，c 为 AES 加密，扣代码或者直接引库：</p><p><img src="https://cdn.itbob.cn/img/article/064/31.png" alt="31"></p><p>u 定义在第 11704 行，i 为十六位随机字符串：</p><pre><code class="hljs ini"><span class="hljs-attr">u</span> = new l[(<span class="hljs-variable">$_DIEHS</span>(<span class="hljs-number">84</span>))]()[<span class="hljs-variable">$_DIEIq</span>(<span class="hljs-number">1498</span>)](i)<span class="hljs-comment">;</span><span class="hljs-attr">u</span> = new l[<span class="hljs-string">&quot;default&quot;</span>]()[<span class="hljs-string">&quot;encrypt&quot;</span>](i)<span class="hljs-comment">;</span></code></pre><p>跟进到加密函数 <code>l[($_DIEHS(84))]</code> 中，在第 12725 行，于 12741 行打下断点，可以看到这里就是个 RSA 加密，扣代码或者直接引库即可：</p><p><img src="https://cdn.itbob.cn/img/article/064/32.png" alt="32"></p><h2><span id="si-dai-jie-guo-yan-zheng">四代结果验证</span></h2><p><img src="https://cdn.itbob.cn/img/article/064/33.png" alt="33"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>吾爱破解 2023 春节解题领红包之 Web 题解</title>
    <link href="https://www.itbob.cn/article/063/"/>
    <id>https://www.itbob.cn/article/063/</id>
    <published>2023-02-05T16:00:00.000Z</published>
    <updated>2023-02-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#ti-mu-jian-jie">题目简介</a></li><li><a href="#chu-ji-nan-du">初级难度</a><ul><li><a href="#flag1">flag1</a></li><li><a href="#flag2">flag2</a></li><li><a href="#flag3">flag3</a></li><li><a href="#flag4">flag4</a></li><li><a href="#flaga">flagA</a></li></ul></li><li><a href="#zhong-ji-nan-du">中级难度</a><ul><li><a href="#flag5">flag5</a></li><li><a href="#flag6">flag6</a></li><li><a href="#flag7">flag7</a></li><li><a href="#flag8">flag8</a></li><li><a href="#flagb">flagB</a></li></ul></li><li><a href="#gao-ji-nan-du">高级难度</a><ul><li><a href="#flag9">flag9</a></li><li><a href="#flag10">flag10</a></li><li><a href="#flag11">flag11</a></li><li><a href="#flag12">flag12</a></li><li><a href="#flagc">flagC</a></li></ul></li></ul><!-- tocstop --><hr><p><img src="https://cdn.itbob.cn/img/article/063/01.jpg" alt="01"></p><p>（图作者 | 吾爱破解@Ps出来的小赵）</p><p>吾爱破解每年都有个解题领红包活动，今年也不例外，需要我们使出看家逆向本领来分析内容获得口令红包，根据难度等级不同会获得不同数量的吾爱币，活动持续到元宵节结束。活动一共有十个题，本文仅分享 Web 初级、中级、高级三个题的逆向思路。</p><p>活动地址：<a href="https://www.52pojie.cn/thread-1738015-1-1.html">https://www.52pojie.cn/thread-1738015-1-1.html</a></p><h2><span id="ti-mu-jian-jie">题目简介</span></h2><p>三个 Web 题的线索都在一个视频里：<a href="https://www.bilibili.com/video/BV123411R7K6/">https://www.bilibili.com/video/BV123411R7K6/</a></p><p>视频中包含 12 个静态 flag: flag1~flag12，另外还需要寻找到 3 个动态 flag: flagA~flagC。 本题总共有 3 个难度，每个难度提交 4 个静态 flag 和 1 个动态 flag 就算通过。</p><ul><li>初级难度为 flag1~flag4 与 flagA</li><li>中级难度为 flag5~flag8 与 flagB</li><li>高级难度为 flag9~flag12 与 flagC</li></ul><p><img src="https://cdn.itbob.cn/img/article/063/02.png" alt="02"></p><h2><span id="chu-ji-nan-du">初级难度</span></h2><h3><span id="flag1">flag1</span></h3><p>flag1 直接在视频中给出了，<code>flag1&#123;52pojiehappynewyear&#125;</code></p><p><img src="https://cdn.itbob.cn/img/article/063/03.png" alt="03"></p><h3><span id="flag2">flag2</span></h3><p>flag2 藏在二维码里，拿手机扫一下会打开一个网址，网址后面跟了一个 <code>flag2&#123;878a48f2&#125;</code>，当然直接搜二维码在线解码也行，上传上去就能看到文本信息。</p><p><img src="https://cdn.itbob.cn/img/article/063/04.png" alt="04"></p><p><img src="https://cdn.itbob.cn/img/article/063/05.png" alt="05"></p><h3><span id="flag3">flag3</span></h3><p>在视频 25 秒左右，右下角会出现一串字符 <code>iodj3&#123;06i95dig&#125;</code>，这里肯定是一个 flag，注意观察 flag 是四个字母，iodj 也是四个字母，可以大胆猜测这就是 flag3，在字母上动了手脚，数字和括号没变，极大可能是恺撒密码，恺撒密码是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文，例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E。这里 <code>iodj</code> 每个字母分别向前偏移3，刚好就是 <code>flag</code>，以此类推，最终结果就是 <code>flag3&#123;06f95afd&#125;</code>。</p><p><img src="https://cdn.itbob.cn/img/article/063/06.png" alt="06"></p><h3><span id="flag4">flag4</span></h3><p>flag4 比较鸡贼，没在视频里，而是藏在视频作者的签名里（鼠标无意间瞎晃找到的），解密发现是 Base64，最终结果为 <code>flag4&#123;9cb91117&#125;</code>。</p><p><img src="https://cdn.itbob.cn/img/article/063/07.png" alt="07"></p><p><img src="https://cdn.itbob.cn/img/article/063/08.png" alt="08"></p><h3><span id="flaga">flagA</span></h3><p>视频里给了一个网址 <code>2023challenge.52pojie.cn</code>，提示说了这个网站似乎无法访问，但网站的确在运行，它和吾爱破解主站是同一台服务器，可能是域名解析的问题。</p><p><img src="https://cdn.itbob.cn/img/article/063/09.png" alt="09"></p><p>既然都说了是域名解析问题，那我们就分别在线检测一下 <code>2023challenge.52pojie.cn</code> 和主站 <code>52pojie.cn</code> 的解析设置，首先可以发现 <code>2023challenge.52pojie.cn</code> 的 TXT 记录里有个 flagB，这个后面再说，与主站对比发现 A 记录里少了 <code>124.232.185.97</code>，提示也说了和主站是同一台服务器，所以我们可以在本地 host 里加上这个记录即可访问。</p><p><img src="https://cdn.itbob.cn/img/article/063/10.png" alt="10"></p><p><img src="https://cdn.itbob.cn/img/article/063/11.png" alt="11"></p><p><img src="https://cdn.itbob.cn/img/article/063/12.png" alt="12"></p><p>访问网站 <code>https://2023challenge.52pojie.cn/</code>，可以在 <code>Response Header</code> 里找到一个 <code>X-Dynamic-Flag</code>，也就是动态 flagA，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/063/13.png" alt="13"></p><p>既然是动态的，那就不可能直接是 <code>flagA&#123;Header X-52PoJie-Uid Not Found&#125;</code>，很明显给的提示是 Header 里缺少了 <code>X-52PoJie-Uid</code>，所以我们在请求的时候 Header 里加上这个字段试试，Python 代码如下：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> requestsheaders = &#123;    <span class="hljs-string">&quot;X-52PoJie-Uid&quot;</span>: <span class="hljs-string">&quot;2002241&quot;</span>,  <span class="hljs-comment"># 你的吾爱破解 UID</span>    <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;2023challenge.52pojie.cn&quot;</span>,    <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36&quot;</span>&#125;url = <span class="hljs-string">&quot;https://2023challenge.52pojie.cn/&quot;</span>response = requests.get(url, headers=headers)flagA = response.headers[<span class="hljs-string">&quot;X-Dynamic-Flag&quot;</span>]<span class="hljs-built_in">print</span>(flagA)</code></pre><p>查看返回的 Header 里的 <code>X-Dynamic-Flag</code>，就是正确的 flagA，有个过期时间，在过期前提交即可。</p><p><img src="https://cdn.itbob.cn/img/article/063/14.png" alt="14"></p><h2><span id="zhong-ji-nan-du">中级难度</span></h2><h3><span id="flag5">flag5</span></h3><p>在视频第30秒左右的时候，会出现类似发电报的声音，这就是摩斯密码（摩尔斯电码），对着下表听就完事儿了，当然还有更准确的方法，那就是分析音频的频谱图，更加直观，音频的分析后文 flag8 再说，这里的正确答案是 <code>flag5&#123;eait&#125;</code>。</p><p><img src="https://cdn.itbob.cn/img/article/063/15.png" alt="15"></p><h3><span id="flag6">flag6</span></h3><p>flag6 比较直观，视频开头就直接给出了，电话拨号声就是 flag6。</p><p><img src="https://cdn.itbob.cn/img/article/063/16.png" alt="16"></p><p>重点在于如何识别拨号的数字，这里涉及到一个双音多频信号（DTMF）的概念，双音多频由高频群和低频群组成，高低频群各包含4个频率。一个高频信号和一个低频信号叠加组成一个组合信号，代表一个数字。可以使用 Python 读取音频来识别，也有现成的工具 DTMF2NUM 可以识别，具体介绍参考：<a href="https://bbs.qsnctf.com/thread-318-1-1.html">https://bbs.qsnctf.com/thread-318-1-1.html</a> ，里面有下载链接。使用录音工具将这段拨号音录成 wav 格式，然后通过工具识别得到 <code>flag6&#123;590124&#125;</code>。</p><p><img src="https://cdn.itbob.cn/img/article/063/17.png" alt="17"></p><h3><span id="flag7">flag7</span></h3><p>视频中，第22秒左右，上方出现的一串 0101 的东西，这就是 flag7，实际上是二进制形式的 ASCII 码，八位一个字符，例如 <code>01100110</code> 对应的 ASCII 码就是 <code>f</code>，找个在线工具转换一下就可以得到 <code>flag7&#123;5d06be63&#125;</code>。</p><pre><code class="hljs toml">01100110 01101100 01100001 01100111 00110111 01111011 00110101 01100100 00110000 00110110 01100010 01100101 00110110 00110011 01111101</code></pre><p><img src="https://cdn.itbob.cn/img/article/063/18.png" alt="18"></p><p><img src="https://cdn.itbob.cn/img/article/063/19.png" alt="19"></p><h3><span id="flag8">flag8</span></h3><p>flag8 藏在这个视频的音频里，同样将音频录下来，用 Audacity 软件打开此音频，选择频谱图，就可以看到 <code>flag8&#123;c394d7&#125;</code>，同样前面的 flag5 其实除了直接用耳朵听以外，也可以通过这个频谱图查看。</p><p><img src="https://cdn.itbob.cn/img/article/063/20.png" alt="20"></p><h3><span id="flagb">flagB</span></h3><p>flagB 在前面推理 flagA 的时候已经遇到了，线索在 <code>2023challenge.52pojie.cn</code> 的域名解析，TXT 记录里，计算方法就是自己的 uid 加上字符串 <code>_happy_new_year_</code> 加上时间戳除以 600 并向下取整后的值，经过 md5 加密后，取前八位即可。</p><pre><code class="hljs javascript">flagB&#123;substr(md5(uid+\_happy_new_year_\+floor(timestamp/<span class="hljs-number">600</span>)),<span class="hljs-number">0</span>,<span class="hljs-number">8</span>)&#125;</code></pre><p><img src="https://cdn.itbob.cn/img/article/063/21.png" alt="21"></p><h2><span id="gao-ji-nan-du">高级难度</span></h2><h3><span id="flag9">flag9</span></h3><p>仔细听这个视频，在结尾，也就是大概40秒的时候，依稀有一段杂音，单独将这一段录下来，反向播放，就会发现说的正是 flag9，正确答案是 <code>flag9&#123;21c5f8&#125;</code>。</p><p><img src="https://cdn.itbob.cn/img/article/063/22.png" alt="22"></p><h3><span id="flag10">flag10</span></h3><p>flag10 太难了没找到，有知道的小伙伴可以分享一下。</p><h3><span id="flag11">flag11</span></h3><p>视频里，底下一串 <code>++++[&gt;</code> 的东西就是 flag11，这一串是 Brainfuck 语言，是一种非常接近图灵机的编程语言。可以直接使用在线工具转换即可：<a href="https://www.splitbrain.org/services/ook">https://www.splitbrain.org/services/ook</a> ，正确答案是 <code>flag11&#123;63418de7&#125;</code>。</p><pre><code class="hljs to">++++++++++[&gt;++++++++++&gt;++++++++++&gt;+++++&gt;++++++++++++&lt;&lt;&lt;&lt;-]&gt;++.++++++.&gt;---.&lt;-----.&gt;&gt;-..&gt;+++.&lt;+++++.---.+.---.+++++++.&lt;+++.+.&gt;-.&gt;++.</code></pre><p><img src="https://cdn.itbob.cn/img/article/063/23.png" alt="23"></p><p><img src="https://cdn.itbob.cn/img/article/063/24.png" alt="24"></p><h3><span id="flag12">flag12</span></h3><p>仔细观察视频你会发现，开头的背景是灰色的，在第20秒左右，颜色就加深了，其实开始的背景图是有猫腻的，用到了图片盲水印技术，flag12 就藏在背景图片里，原理就是使用傅里叶变换把原图变为频谱图，再叠加水印，将含水印的频谱图进行傅里叶逆变换得到含水印的图像。蚁景网络安全的这篇文章有详细的介绍：<a href="https://blog.csdn.net/YJ_12340/article/details/127087949">https://blog.csdn.net/YJ_12340/article/details/127087949</a> ，我们直接使用文中的方法，使用 Python 处理图片后即可得到 <code>flag12&#123;3ac97e24&#125;</code>。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-comment"># 读取为灰度图像，52pj.png 为视频开头的背景截图</span>img = cv2.imread(<span class="hljs-string">&#x27;52pj.png&#x27;</span>, <span class="hljs-number">0</span>)f = np.fft.fft2(img)<span class="hljs-comment"># 将图像中的低频部分移动到图像的中心</span>fshift = np.fft.fftshift(f)<span class="hljs-comment"># 取绝对值：将复数变化成实数，目的为了将数据变化到较小的范围（比如0-255）</span>s1 = np.log(np.<span class="hljs-built_in">abs</span>(f))s2 = np.log(np.<span class="hljs-built_in">abs</span>(fshift))plt.subplot(<span class="hljs-number">121</span>), plt.imshow(s1, <span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;original&#x27;</span>)plt.subplot(<span class="hljs-number">122</span>), plt.imshow(s2, <span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;center&#x27;</span>)plt.show()</code></pre><p>下图可能平台会有压缩看不清，自己照着处理一下即可。</p><p><img src="https://cdn.itbob.cn/img/article/063/25.png" alt="25"></p><h3><span id="flagc">flagC</span></h3><p>flagC 是动态的，还得回到 <code>https://2023challenge.52pojie.cn/</code> 这个网站上来。</p><p><img src="https://cdn.itbob.cn/img/article/063/26.png" alt="26"></p><p>点击登陆后，来到 <code>login</code> 页面，让我们提交 UID，但是这个输入框无法输入，修改一下源码，将 <code>disabled</code> 删除即可。</p><p><img src="https://cdn.itbob.cn/img/article/063/27.png" alt="27"></p><p>然后输入我们的 UID，提示您不是 admin，你没有权限获取 flag。</p><p><img src="https://cdn.itbob.cn/img/article/063/28.png" alt="28"></p><p>抓包分析一下，发现在点击提交后，<code>Response Headers</code> 有个 <code>Set-Cookie</code>，而这个 cookie 由三段组成，以 <code>.</code> 分隔，很明显是一个 JWT（JSON Web Token）。</p><p><img src="https://cdn.itbob.cn/img/article/063/29.png" alt="29"></p><p>JWT 是可以解密的，来到 <code>jwt.io</code> 这个网站，解密后可以发现 payload 部分包含了我们的 uid 和 role 角色信息，此刻我们是普通的 user，直接将其改为 admin 即可，将生成的新 JWT 拿来重新提交，即可拿到正确的 flagC。</p><p><img src="https://cdn.itbob.cn/img/article/063/30.png" alt="30"></p><p><img src="https://cdn.itbob.cn/img/article/063/31.png" alt="31"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>极验业务安全，深知 V2 业务风控逆向分析</title>
    <link href="https://www.itbob.cn/article/062/"/>
    <id>https://www.itbob.cn/article/062/</id>
    <published>2023-01-16T12:42:00.000Z</published>
    <updated>2023-01-16T12:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#shen-zhi-jian-jie">深知简介</a></li><li><a href="#zhua-bao-fen-xi">抓包分析</a></li><li><a href="#ni-xiang-fen-xi">逆向分析</a><ul><li><a href="#huo-qu-h-zhi">获取 h 值</a></li><li><a href="#huo-qu-e-zhi">获取 e 值</a></li><li><a href="#huo-qu-l-zhi">获取 l 值</a></li><li><a href="#jin-yi-bu-chu-li-l">进一步处理 l</a></li></ul></li><li><a href="#jie-guo-yan-zheng">结果验证</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><p><img src="https://cdn.itbob.cn/img/article/062/01.gif" alt="01"></p><ul><li>目标：某验深知 V2 业务风控逆向分析</li><li>主页：<code>aHR0cHM6Ly93d3cuZ2VldGVzdC5jb20vZGVtby9kay12Mi5odG1s</code></li></ul><h2><span id="shen-zhi-jian-jie">深知简介</span></h2><p>某验深知通过无感采集客户端数据，对用户的环境、标识、行为操作等进行智能化分析，结合业务场景有效识别有潜在风险的用户。整个识别过程不干扰用户，不打断业务既有流程。完整通讯流程如下：</p><p><img src="https://cdn.itbob.cn/img/article/062/02.jpg" alt="02"></p><h2><span id="zhua-bao-fen-xi">抓包分析</span></h2><p>访问首页，会引入一个 <code>v2.sense.js</code>，后面接了个 <code>id</code>，需要将其提取出来，后续有用到，当然一般情况下，同一个业务这个 <code>id</code> 应该是一样的，直接复制下来写死也行。</p><p><img src="https://cdn.itbob.cn/img/article/062/03.png" alt="03"></p><p>接着有个 <code>gettype</code> 的请求，这里主要返回一些资源路径，其中有个 <code>gct.xxx.js</code>，这个 JS 名称每隔一段时间就会变化，这个 JS 会生成一个键值对，例如 <code>&#123;'xnbw': '1158444372'&#125;</code>，JS 变化，这个键值对也会变化，这个键值对参与了后面加密参数的生成，在某验系列产品中都有这个东西，少量测试将其固定发现也可以通过验证，盲猜大量请求或者某些校验严格的网站可能有影响，建议还是动态去请求这个 JS 来获取最新的键值对，这个后文具体再说。</p><p><img src="https://cdn.itbob.cn/img/article/062/04.png" alt="04"></p><p>然后是 <code>judge</code> 的请求，这个请求页面一加载就完成了，不需要手动点击请求，其中 <code>Query String Parameters</code> 里有个 <code>app_id</code> 就是我们前面提到的 <code>id</code>，<code>Request Payload</code> 就是一串超长的字符串，这个也是我们需要逆向的参数。该请求如果验证成功，会返回一个 <code>session_id</code>。</p><p><img src="https://cdn.itbob.cn/img/article/062/05.png" alt="05"></p><p><img src="https://cdn.itbob.cn/img/article/062/06.png" alt="06"></p><p>然后就是业务接口了，本例中业务接口是 <code>verify-dk-v2</code>，也就是一个登录接口，带上前面 <code>judge</code> 接口返回的 <code>session_id</code> 即可请求成功。</p><p><img src="https://cdn.itbob.cn/img/article/062/07.png" alt="07"></p><p><img src="https://cdn.itbob.cn/img/article/062/08.png" alt="08"></p><h2><span id="ni-xiang-fen-xi">逆向分析</span></h2><p>由于我们逆向的参数 <code>Request Payload</code> 没有键名导致不能直接搜索关键字，所以只能跟栈或者下个 XHR 断点，跟栈可以在 <code>sense.2.3.0.js</code> 第 6144 行找到一个 <code>e + h[AUJ_(1173)]</code>，这个就是正确的 <code>Request Payload</code> 值。</p><p><img src="https://cdn.itbob.cn/img/article/062/09.png" alt="09"></p><p>上图中其实核心代码就四行，后文也是围绕这四行代码来分析的：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> h = o[AUJ_(<span class="hljs-number">1156</span>)]()  , e = CoUE[ymDv(<span class="hljs-number">24</span>)](NFeB)  , l = EbF_[ymDv(<span class="hljs-number">409</span>)](e, h[ymDv(<span class="hljs-number">1194</span>)])  , e = DWYi[ymDv(<span class="hljs-number">1137</span>)](l)</code></pre><h3><span id="huo-qu-h-zhi">获取 h 值</span></h3><p>先来看 h 的值，由一个方法生成一个对象，对象里面分别是 <code>aeskey</code> 和 <code>rsa</code>，每次也都是随机变化的。</p><p><img src="https://cdn.itbob.cn/img/article/062/10.png" alt="10"></p><p>继续跟到这个方法里，重点在于 e 和 t 的值，最后返回的就是 <code>&#123;aeskey: e, rsa: t&#125;</code>。</p><p><img src="https://cdn.itbob.cn/img/article/062/11.png" alt="11"></p><p>先看这个 e 的值，也就是 <code>RwyT()</code> 方法，搞过某验其他产品的就知道这里是 16 位随机值。</p><p><img src="https://cdn.itbob.cn/img/article/062/12.png" alt="12"></p><p>然后 t 的值，和某验其他系列产品一样，用到了 RSA 加密算法，这里图中 <code>BPqG()</code> 就是 RSA 算法，t 的值就是 RSA 加密后的结果，扣的时候注意找到算法开头的地方，将整个 <code>BPqG()</code> 方法扣下来即可。</p><p><img src="https://cdn.itbob.cn/img/article/062/13.png" alt="13"></p><p><img src="https://cdn.itbob.cn/img/article/062/14.png" alt="14"></p><h3><span id="huo-qu-e-zhi">获取 e 值</span></h3><p>接下来是 e 的值，<code>e = CoUE[ymDv(24)](NFeB)</code>，很明显是将 <code>NFeB</code> 的值进行了处理，<code>NFeB</code> 是个对象，里面有一些 <code>data</code>、<code>id</code> 等信息，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/062/15.png" alt="15"></p><p>所以我们得先找一下 <code>NFeB</code> 这个值是怎么来的，直接搜索发现只有四个地方，在第 6109 行就是定义的地方，挨个看，首先有个 s 参数，将 id 传入到一个函数进行处理，函数没啥特别的，直接扣就行，通常经过处理后，s 的值为空，即 <code>s=&quot;&quot;</code>。</p><p><img src="https://cdn.itbob.cn/img/article/062/16.png" alt="16"></p><p>再来看有个 u 值，由一个方法生成了一大串包含很多感叹号的字符串，本案例实际测试中，直接将这个值置空也行，可能其他校验严格或者大批量请求的情况下，说不定也会校验的，所以我们最好也跟进去找一下生成逻辑。</p><p><img src="https://cdn.itbob.cn/img/article/062/17.png" alt="17"></p><p>跟进这个方法，里面是一些浏览器环境的值，比如屏幕高宽、canvas、ua、浏览器插件、时间、时区、语言等等，基本上都能写死，后续会将这些值以 <code>!!</code> 相连接最终生成 u 的值。</p><p><img src="https://cdn.itbob.cn/img/article/062/18.png" alt="18"></p><p>然后继续看，接下来是 c 值，是一个对象，值为 <code>&#123;&quot;key&quot;:0,&quot;value&quot;:[]&#125;</code>，我这里直接写死了。</p><p><img src="https://cdn.itbob.cn/img/article/062/19.png" alt="19"></p><p>再往下就是 <code>NFeB</code> 了：</p><p><img src="https://cdn.itbob.cn/img/article/062/20.png" alt="20"></p><p>Unicode 转换一下，简单解一下混淆，就长下面这样：</p><pre><code class="hljs javascript">NFeB = &#123;    <span class="hljs-string">&quot;id&quot;</span>: a[<span class="hljs-string">&quot;id&quot;</span>],    <span class="hljs-string">&quot;page_id&quot;</span>: a[<span class="hljs-string">&quot;page_id&quot;</span>],    <span class="hljs-string">&quot;lang&quot;</span>: a[<span class="hljs-string">&quot;lang&quot;</span>] || AUJ_(<span class="hljs-number">31</span>),    <span class="hljs-string">&quot;data&quot;</span>: &#123;        <span class="hljs-string">&quot;insights&quot;</span>: u || <span class="hljs-literal">null</span>,        <span class="hljs-string">&quot;track_key&quot;</span>: c[<span class="hljs-string">&quot;value&quot;</span>] ? c[<span class="hljs-string">&quot;key&quot;</span>] : <span class="hljs-literal">null</span>,        <span class="hljs-string">&quot;track&quot;</span>: c[<span class="hljs-string">&quot;value&quot;</span>] || <span class="hljs-literal">null</span>,        <span class="hljs-string">&quot;ep&quot;</span>: o[<span class="hljs-string">&quot;KZrg&quot;</span>](i),        <span class="hljs-string">&quot;eco&quot;</span>: <span class="hljs-built_in">window</span>[<span class="hljs-string">&quot;GEERANDOMTOKEN&quot;</span>] || <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-string">&quot;ww3&quot;</span>: <span class="hljs-string">&quot;&quot;</span>    &#125;&#125;;</code></pre><p><code>id</code> 不用说，<code>page_id</code> 就是个时间戳，<code>lang</code> 中文就是 <code>zh-cn</code>，<code>insights</code> 是前面得到的 <code>u</code> 值，<code>track_key</code>、<code>track</code> 取 <code>c</code> 的键和值，<code>ep</code> 将 <code>i</code> 传入了一个函数进行处理，<code>i</code> 是固定的字符串 <code>client</code>，这个 <code>KZrg</code> 方法可以跟进去看看，里面其实有很多都是定值，唯一需要注意的是 <code>t[&quot;tm&quot;]</code> 这个值，和某验其他系列一样，是 <code>window.performance.timing</code> 的值，自己获取一下时间戳随机加减伪造一下就行了。</p><p><img src="https://cdn.itbob.cn/img/article/062/21.png" alt="21"></p><p>然后就是 <code>eco</code> 的值，取的 <code>window.GEERANDOMTOKEN</code>，打印一下 window，除了有这个 token 以外，还可以看到 <code>localStore</code>、<code>session</code> 里面也有这个值。</p><p><img src="https://cdn.itbob.cn/img/article/062/22.png" alt="22"></p><p><img src="https://cdn.itbob.cn/img/article/062/23.png" alt="23"></p><p>由于某验的 JS 都是混淆后的，不太好定位这个值生成的地方，所以拿出我们的 Hook 大法，先清除一下缓存，不然的话是 Hook 不到值的，Hook 代码如下：</p><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> token = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">window</span>, <span class="hljs-string">&#x27;GEERANDOMTOKEN&#x27;</span>, &#123;        <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;GEERANDOMTOKEN-&gt;&#x27;</span>, val);            <span class="hljs-keyword">debugger</span>;            token = val;            <span class="hljs-keyword">return</span> val;        &#125;,        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;            <span class="hljs-keyword">return</span> token;        &#125;    &#125;);&#125;)();</code></pre><p><img src="https://cdn.itbob.cn/img/article/062/24.png" alt="24"></p><p>断下后往前跟栈，<code>window[o] = t</code>，<code>o</code> 就是 <code>GEERANDOMTOKEN</code>，<code>t</code> 就是我们想要的值。</p><p><img src="https://cdn.itbob.cn/img/article/062/25.png" alt="25"></p><p>往上就可以找到 <code>t</code> 的生成方法，核心就是生成一个 32 位的随机字符串，然后加上时间戳，再进行 MD5 加密得到最终值，生成位置以及实现的代码如下：</p><p><img src="https://cdn.itbob.cn/img/article/062/26.png" alt="26"></p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> MD5 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;md5&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getToken</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">var</span> t = MD5(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> t = [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;G&quot;</span>,<span class="hljs-string">&quot;H&quot;</span>,<span class="hljs-string">&quot;I&quot;</span>,<span class="hljs-string">&quot;J&quot;</span>,<span class="hljs-string">&quot;K&quot;</span>,<span class="hljs-string">&quot;L&quot;</span>,<span class="hljs-string">&quot;M&quot;</span>,<span class="hljs-string">&quot;N&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;P&quot;</span>,<span class="hljs-string">&quot;Q&quot;</span>,<span class="hljs-string">&quot;R&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;T&quot;</span>,<span class="hljs-string">&quot;U&quot;</span>,<span class="hljs-string">&quot;V&quot;</span>,<span class="hljs-string">&quot;W&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;Y&quot;</span>,<span class="hljs-string">&quot;Z&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>,<span class="hljs-string">&quot;g&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;i&quot;</span>,<span class="hljs-string">&quot;j&quot;</span>,<span class="hljs-string">&quot;k&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;m&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;q&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,<span class="hljs-string">&quot;s&quot;</span>,<span class="hljs-string">&quot;t&quot;</span>,<span class="hljs-string">&quot;u&quot;</span>,<span class="hljs-string">&quot;v&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>,<span class="hljs-string">&quot;z&quot;</span>], n = <span class="hljs-string">&quot;&quot;</span>, r = <span class="hljs-number">0</span>; r &lt; e; r++)            n += t[<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">61</span> * <span class="hljs-built_in">Math</span>.random(), <span class="hljs-number">10</span>)];        <span class="hljs-keyword">return</span> n;    &#125;(<span class="hljs-number">32</span>) + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime());    <span class="hljs-keyword">return</span> t;&#125;</code></pre><p>当你把以上这些参数都搞完了，你可能认为都齐了，其实不然，后面接着还有一句 <code>Yvwp(NFeB, r)</code>，将 r 的值增加到了 <code>NFeB</code> 里，这个 r 的值类似于 <code>&#123;olbo: &quot;1588069361&quot;&#125;</code>，这个键值对都是每隔一段时间会变的，这个在某验系列其他文章里也提过。</p><p><img src="https://cdn.itbob.cn/img/article/062/27.png" alt="27"></p><p>进一步分析，这个 r 是传进来的，所以往上跟栈，有个 <code>r[psPG(1183)]()</code> 方法就生成了这个对象：</p><p><img src="https://cdn.itbob.cn/img/article/062/28.png" alt="28"></p><p>继续跟到这个方法里去，首先定义了 e 这个对象，然后赋值 <code>e = &#123;ep: &quot;test data&quot;, lang: &quot;zh&quot;&#125;</code>，然后经过 <code>window[tYlM(1126)]()</code> 方法处理后，e 里面就新增了 <code>&#123;olbo: &quot;1588069361&quot;&#125;</code>，后续将 ep 和 lang 两个值删除后返回。</p><p><img src="https://cdn.itbob.cn/img/article/062/29.png" alt="29"></p><p>所以我们继续跟进 <code>window[tYlM(1126)]()</code> 方法，会跳转到 gct.xxxx.js 里，这个 JS 就是我们开头讲过的，他的名称会每隔一段时间变化，内容也会变，所以导致生成的键值对也会变化，继续跟，有个 <code>t[e] = xxx</code> 的语句，其中 e 和等号右边的值，就是我们需要的键值对。</p><p><img src="https://cdn.itbob.cn/img/article/062/30.png" alt="30"></p><p>这个键值对在我们本地也可以动态获取，只需要请求正确的 JS 文件，将要调用的方法全局导出就行了，以下给一个我的处理方法示例（注意里面请求 url 已经脱敏处理，所以不可直接运行，自行抓包补上）：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> json<span class="hljs-keyword">import</span> execjs<span class="hljs-keyword">import</span> requests<span class="hljs-keyword">from</span> loguru <span class="hljs-keyword">import</span> loggerheaders = &#123;    <span class="hljs-string">&quot;user-agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36&quot;</span>,&#125;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_gct</span>():</span>    url = <span class="hljs-string">&quot;https://dkapi.脱敏处理.com/deepknow/v2/gettype&quot;</span>    params = &#123;        <span class="hljs-string">&quot;callback&quot;</span>: <span class="hljs-string">&quot;脱敏处理_&quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(time.time() * <span class="hljs-number">1000</span>))    &#125;    response = requests.get(url, headers=headers, params=params).text    response = json.loads(re.findall(<span class="hljs-string">r&quot;geetest_\d+\((.*?)\)&quot;</span>, response)[<span class="hljs-number">0</span>])    <span class="hljs-comment"># gettype 接口返回的 gct.xxx.js 的地址</span>    gct_path = <span class="hljs-string">&quot;https://static.脱敏处理.com&quot;</span> + response[<span class="hljs-string">&quot;gct_path&quot;</span>]    logger.info(<span class="hljs-string">&quot;gct_path: %s&quot;</span> % gct_path)    gct_js = requests.get(gct_path, headers=headers).text    <span class="hljs-comment"># 正则匹配需要调用的方法名称</span>    function_name = re.findall(<span class="hljs-string">r&quot;\)\)\&#123;return (.*?)\(&quot;</span>, gct_js)[<span class="hljs-number">0</span>]    <span class="hljs-comment"># 查找需要插入全局导出代码的位置</span>    break_position = gct_js.find(<span class="hljs-string">&quot;return function(t)&#123;&quot;</span>)    <span class="hljs-comment"># window.gct 全局导出方法</span>    gct_js_new = gct_js[:break_position] + <span class="hljs-string">&quot;window.gct=&quot;</span> + function_name + <span class="hljs-string">&quot;;&quot;</span> + gct_js[break_position:]    <span class="hljs-comment"># 添加自定义方法调用 window.gct 获取键值对</span>    gct_js_new = <span class="hljs-string">&quot;window = global;&quot;</span> + gct_js_new + <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    function getGct()&#123;</span><span class="hljs-string">        var e = &#123;&quot;lang&quot;: &quot;zh&quot;, &quot;ep&quot;: &quot;test data&quot;&#125;;</span><span class="hljs-string">        window.gct(e);</span><span class="hljs-string">        delete e[&quot;lang&quot;];</span><span class="hljs-string">        delete e[&quot;ep&quot;];</span><span class="hljs-string">        return e;</span><span class="hljs-string">    &#125;&quot;&quot;&quot;</span>    gct = execjs.<span class="hljs-built_in">compile</span>(gct_js_new).call(<span class="hljs-string">&quot;getGct&quot;</span>)    logger.info(<span class="hljs-string">&quot;gct: %s&quot;</span> % gct)    <span class="hljs-keyword">return</span> gct</code></pre><p>到这里我们 <code>NFeB</code> 就生成完毕了，回到 <code>e</code> 的值，这里其实就是把 <code>NFeB</code> 转成字符串，直接 <code>JSON.stringify()</code> 即可。</p><p><img src="https://cdn.itbob.cn/img/article/062/31.png" alt="31"></p><h3><span id="huo-qu-l-zhi">获取 l 值</span></h3><p>l 的值比较简单，就是将前面生成的 <code>h[&quot;aeskey&quot;]</code> 作为 key，<code>e</code> 作为待加密字符串，经过 AES 加密后即可得到 l 的值。</p><p><img src="https://cdn.itbob.cn/img/article/062/32.png" alt="32"></p><p>本地复现如下（有些变量名称不一样无影响，我是直接复用的某验其他产品的方法）：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;crypto-js&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aesEncrypt</span>(<span class="hljs-params">e, i</span>) </span>&#123;    <span class="hljs-keyword">var</span> key = CryptoJS.enc.Utf8.parse(i),    iv = CryptoJS.enc.Utf8.parse(<span class="hljs-string">&quot;0000000000000000&quot;</span>),    srcs = CryptoJS.enc.Utf8.parse(e),    encrypted = CryptoJS.AES.encrypt(srcs, key, &#123;        <span class="hljs-attr">iv</span>: iv,        <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,        <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7    &#125;);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> r = encrypted, o = r.ciphertext.words, i = r.ciphertext.sigBytes, s = [], a = <span class="hljs-number">0</span>; a &lt; i; a++) &#123;        <span class="hljs-keyword">var</span> c = o[a &gt;&gt;&gt; <span class="hljs-number">2</span>] &gt;&gt;&gt; <span class="hljs-number">24</span> - a % <span class="hljs-number">4</span> * <span class="hljs-number">8</span> &amp; <span class="hljs-number">255</span>;        s.push(c);    &#125;    <span class="hljs-keyword">return</span> s;&#125;</code></pre><h3><span id="jin-yi-bu-chu-li-l">进一步处理 l</span></h3><p>最后一步 <code>e = DWYi[ymDv(1137)](l)</code>，将 l 的值经过了 <code>tc_t</code> 这个方法进行处理，就会得到最终 <code>Request Payload</code> 的一部分。</p><p><img src="https://cdn.itbob.cn/img/article/062/33.png" alt="33"></p><p>跟进这个 <code>tc_t</code> 方法，又是熟悉的 <code>return e[&quot;res&quot;] + e[&quot;end&quot;]</code>，同样和某验其他产品一样的。</p><p><img src="https://cdn.itbob.cn/img/article/062/34.png" alt="34"></p><p>跟到处理 e 的这个方法里，最后返回的是 <code>&#123;&quot;res&quot;: a, &quot;end&quot;: s&#125;</code>，没啥特别的，直接扣即可，这里注意和某验其他产品里的方法有些小区别，里面有些常量的值是不一样的，最开始我直接复用了其他产品的方法，发现结果是错的。</p><p><img src="https://cdn.itbob.cn/img/article/062/35.png" alt="35"></p><p>自此整个流程分析完毕，最终 <code>e + h[AUJ_(1173)]</code> 的值与 <code>Request Payload</code> 的值一致。</p><p><img src="https://cdn.itbob.cn/img/article/062/36.png" alt="36"></p><p><img src="https://cdn.itbob.cn/img/article/062/37.png" alt="37"></p><h2><span id="jie-guo-yan-zheng">结果验证</span></h2><p><img src="https://cdn.itbob.cn/img/article/062/38.png" alt="38"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>极验行为验证，四代滑块验证码逆向分析</title>
    <link href="https://www.itbob.cn/article/061/"/>
    <id>https://www.itbob.cn/article/061/</id>
    <published>2023-01-03T13:30:00.000Z</published>
    <updated>2023-01-03T13:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#tong-xun-liu-cheng">通讯流程</a></li><li><a href="#yan-zheng-ma-liu-cheng-fen-xi">验证码流程分析</a></li><li><a href="#ni-xiang-fen-xi">逆向分析</a><ul><li><a href="#captcha-id-can-shu">captcha_id 参数</a></li><li><a href="#challenge-can-shu">challenge 参数</a></li><li><a href="#w-can-shu">w 参数</a></li></ul></li><li><a href="#jie-guo-yan-zheng">结果验证</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：某验四代滑块验证码，w 参数逆向</li><li>主页：<code>aHR0cHM6Ly9ndDQuZ2VldGVzdC5jb20v</code></li><li>加密算法：RSA、AES</li></ul><h2><span id="tong-xun-liu-cheng">通讯流程</span></h2><p><img src="https://cdn.itbob.cn/img/article/061/01.png" alt="01"></p><h2><span id="yan-zheng-ma-liu-cheng-fen-xi">验证码流程分析</span></h2><p>进入网页后，打开开发者人员工具进行抓包，点击滑动拼图验证，此时还未点击按钮开始验证，抓到了一个名为 <code>load?captcha_id=xxx</code> 的包，<code>Query String Parameters</code> 包含了一些参数：</p><p><img src="https://cdn.itbob.cn/img/article/061/02.png" alt="02"></p><ul><li><code>captcha_id</code>：验证码 id，固定值，由 <code>adaptive-captcha-demo.js</code> 文件生成，后文分析；</li><li><code>challenge</code>：动态变化，由 <code>gtc4.js</code> 文件生成，后文分析；</li><li><code>client_type</code>：表示 web 端；</li><li><code>risk_type</code>：验证码类型，例如滑块为 slide，无感为 ai；</li><li><code>lang</code>：语言；</li><li><code>callback</code>：geetest_ + 时间戳，主要作用是防止缓存。</li></ul><p>响应预览中返回的关键内容如下，相较于三代，底图未做混淆：</p><p><img src="https://cdn.itbob.cn/img/article/061/03.png" alt="03"></p><ul><li><code>bg</code>：背景图片地址；</li><li><code>captcha_type</code>：验证码类型；</li><li><code>gct_path</code>：gct4 文件路径；</li><li><code>lot_number</code>：后续生成 pow_msg、w 的关键参数；</li><li><code>payload</code>：后续 verify 请求接口需要的参数；</li><li><code>datetime</code>：ISO 8601扩展格式的日期，后续生成 pow_msg 的关键参数；</li><li><code>process_token</code>：后续 verify 请求接口需要的参数；</li><li><code>slice</code>：滑块图片地址。</li></ul><p>点击按钮开始验证，弹出滑块验证码，滑动滑块，抓包到 <code>verify?captcha_id=xxx</code>，<code>Query String Parameters</code> 同样包含了一些参数：</p><p><img src="https://cdn.itbob.cn/img/article/061/04.png" alt="04"></p><ul><li><code>captcha_id</code>：与 load 接口请求头中的 captcha_id 一致；</li><li><code>client_type</code>：表示 web 端；</li><li><code>lot_number</code>：load 接口返回的；</li><li><code>risk_type</code>：与 load 接口中的一致，表示验证码类型；</li><li><code>payload</code>：load 接口返回的；</li><li><code>process_token</code>：load 接口返回的；</li><li><code>w</code>：加密参数，由轨迹、滑动时间、滑动距离、userresponse、device_id、pow_msg 等参数加密得到；</li><li><code>callback</code>：geetest_ + 时间戳，主要作用是防止缓存。</li></ul><p>响应预览中返回的内容如下，result 值为 fail 即校验失败，success 为校验通过，通过后携带 seccode 下的参数进行后续业务请求：</p><p><img src="https://cdn.itbob.cn/img/article/061/05.png" alt="05"></p><h2><span id="ni-xiang-fen-xi">逆向分析</span></h2><h3><span id="captcha-id-can-shu">captcha_id 参数</span></h3><p>全局搜索 <code>captcha_id</code>，跟进到 gt4.js 文件中：</p><p><img src="https://cdn.itbob.cn/img/article/061/06.png" alt="06"></p><p>进去后在第 307 行打上断点，刷新页面即会断住，此时 <code>captcha_id</code> 参数的值已经生成，同时 challenge 参数定义在下一行：</p><p><img src="https://cdn.itbob.cn/img/article/061/07.png" alt="07"></p><p>向上跟栈到 value，即 <code>adaptive-captcha-demo.js</code> 文件中，会发现其是个固定值，实际上这个值是每个网站不一样，是管理员在极验后台申请得到的：</p><p><img src="https://cdn.itbob.cn/img/article/061/08.png" alt="08"></p><h3><span id="challenge-can-shu">challenge 参数</span></h3><p>前面提到，<code>challenge</code> 参数定义在 <code>captcha_id</code> 参数的下一行，在 gt4.js 文件的第 309 行打下断点：</p><p><img src="https://cdn.itbob.cn/img/article/061/09.png" alt="09"></p><p>可以看到，challenge 参数的值由 <code>uuid</code> 函数生成，扣出即可。</p><h3><span id="w-can-shu">w 参数</span></h3><p>从 <code>verify?captcha_id=xxx</code> 接口的堆栈处跟栈进去：</p><p><img src="https://cdn.itbob.cn/img/article/061/10.png" alt="10"></p><p>打下断点滑动滑块断住后，向上跟栈到 s 处，如果做过某验三代滑块的话，第 6249 行有个很熟悉的东西，<code>&quot;\u0077&quot;: r</code>，<code>&quot;\u0077&quot;</code> 即字母 w 的 Unicode 值，r 即 w 参数的值：</p><p><img src="https://cdn.itbob.cn/img/article/061/11.png" alt="11"></p><p>r 参数定义在第 6237 行，e 也是跟三代类似的参数，r 是将 i 参数和转为字符串的 e 参数加密得到的：</p><p><img src="https://cdn.itbob.cn/img/article/061/12.png" alt="12"></p><p>向上跟栈，找到 e 参数中各部分定义生成的位置，跟到 <code>$_BHIH</code> 中，_ 中先生成了四个键值对：</p><p><img src="https://cdn.itbob.cn/img/article/061/13.png" alt="13"></p><p><code>passtime</code> 和 <code>track</code> 是熟悉的滑动时间和轨迹，<code>setLeft</code> 为识别出来的缺口距离，<code>userresponse</code> 定义在 19593 行， a 为 <code>setLeft</code> 参数的值，<code>t[$_GDFCG(1909)]</code> 为定值 1.0059466666666665：</p><pre><code class="hljs JavaScript">a / t[$_GDFCG(<span class="hljs-number">1909</span>)] + <span class="hljs-number">2</span></code></pre><p>接着跟到 <code>$_BCFj</code> 中，e 定义在第 6201 行，下面几行定义了 e 中的 <code>device_id</code>、<code>lot_number</code>、<code>pow_msg</code>、<code>pow_sign</code>：</p><p><img src="https://cdn.itbob.cn/img/article/061/14.png" alt="14"></p><p><code>device_id</code> 同一个网站是固定值，<code>lot_number</code> 是 load 响应返回的，控制台打印一下 <code>pow_msg</code>、<code>pow_sign</code> 的结果：</p><p><img src="https://cdn.itbob.cn/img/article/061/15.png" alt="15"></p><p><code>pow_msg</code> 很明显是由几部分组成的，<code>pow_sign</code> 经过加密，向上跟栈到 init 中，分别定义在第 5837 行和第 5838 行，为 d 字典的键，根据键名取值：</p><p><img src="https://cdn.itbob.cn/img/article/061/16.png" alt="16"></p><p>d 定义在第 5835 行，这部分还原一下就很明显了：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> c = t[<span class="hljs-string">&quot;toDataURL&quot;</span>]()[<span class="hljs-string">&quot;replace&quot;</span>](<span class="hljs-string">&quot;data:image/png;base64,&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)    , _ = <span class="hljs-keyword">new</span> w[<span class="hljs-string">&quot;default&quot;</span>][<span class="hljs-string">&quot;MD5&quot;</span>]()[<span class="hljs-string">&quot;hex&quot;</span>](c);a[<span class="hljs-string">&quot;options&quot;</span>][<span class="hljs-string">&quot;deviceId&quot;</span>] = _;<span class="hljs-keyword">var</span> h = a[<span class="hljs-string">&quot;options&quot;</span>]    , l = h[<span class="hljs-string">&quot;powDetail&quot;</span>]    , p = h[<span class="hljs-string">&quot;lotNumber&quot;</span>]    , f = h[<span class="hljs-string">&quot;captchaId&quot;</span>]    , d = v[<span class="hljs-string">&quot;default&quot;</span>](p, f, l[<span class="hljs-string">&quot;hashfunc&quot;</span>], l[<span class="hljs-string">&quot;version&quot;</span>], l[<span class="hljs-string">&quot;bits&quot;</span>], l[<span class="hljs-string">&quot;datetime&quot;</span>], <span class="hljs-string">&quot;&quot;</span>)</code></pre><p>跟进到 <code>v[&quot;default&quot;]</code> 中，函数定义在第 6945 行，于 6978 行打下断点：</p><p><img src="https://cdn.itbob.cn/img/article/061/17.png" alt="17"></p><p><code>pow_msg</code> 由 <code>_ + h</code> 得到，<code>_</code> 定义在第 6960 行：</p><pre><code class="hljs JavaScript">_ = i + <span class="hljs-string">&quot;|&quot;</span> + r + <span class="hljs-string">&quot;|&quot;</span> + n + <span class="hljs-string">&quot;|&quot;</span> + s + <span class="hljs-string">&quot;|&quot;</span> + t + <span class="hljs-string">&quot;|&quot;</span> + e + <span class="hljs-string">&quot;|&quot;</span> + o + <span class="hljs-string">&quot;|&quot;</span>;</code></pre><ul><li>i：<code>l[&quot;version&quot;]</code></li><li>r：<code>l[&quot;bits&quot;]</code></li><li>n：<code>l[&quot;hashfunc&quot;]</code></li><li>s：<code>l[&quot;datetime&quot;]</code></li><li>t：<code>f, h[&quot;captchaId&quot;]</code></li><li>e：<code>p, h[&quot;lotNumber&quot;]</code></li><li>o：<code>&quot;&quot;</code></li></ul><p>h 定义在第 6269 行，跟进去是 16 位随机数字符串，<code>pow_sign</code> 为 p，就是 <code>pow_msg</code> 经过 MD5 加密得到的：</p><p><img src="https://cdn.itbob.cn/img/article/061/18.png" alt="18"></p><p>至此这四个也分析完了，还差以下这部分：</p><p><img src="https://cdn.itbob.cn/img/article/061/19.png" alt="19"></p><p>em 等定值就不分析了，注意 <code>kqg5：&quot;1557244628&quot;</code>，这个参数值和三代滑块中一样，每隔几个小时会改变，向上跟栈到 <code>$_BCFj</code> 中，在第 6207 行打下断点，此时 e 中这个值还未生成：</p><p><img src="https://cdn.itbob.cn/img/article/061/20.png" alt="20"></p><p>下一行打下断点，下步断点，即执行完 <code>n[$_CBHIE(791)](e);</code> 后，这个参数值就生成了，证明是 <code>n[$_CBHIE(791)]</code> 方法生成的，跟进去：</p><p><img src="https://cdn.itbob.cn/img/article/061/21.png" alt="21"></p><p>跳转到第 5766 行，在第 5779 行打下断点，此时的 n 中还未生成此参数：</p><p><img src="https://cdn.itbob.cn/img/article/061/22.png" alt="22"></p><p>执行了 <code>_gct(n)</code> 后即生成：</p><p><img src="https://cdn.itbob.cn/img/article/061/23.png" alt="23"></p><p>可见其生成位置在 <code>_gct</code> 方法中，跟进去后到 gct4.js 文件，和三代大差不差：</p><p><img src="https://cdn.itbob.cn/img/article/061/24.png" alt="24"></p><p>可以将值导出，至此 e 就分析完了，接着回到第 6238 行，跟进到加密函数 <code>d[$_CBHHO(84)]</code> 中，定义在第 11669 行，<code>d[$_DIEHS(177)](c) + u</code> 即 r 参数的值，c 为一个大数组，u 明显也经过加密了，所以 r 参数的值就是数组 c 加密后再加上 u 得到的：</p><p><img src="https://cdn.itbob.cn/img/article/061/25.png" alt="25"></p><p>先跟进到 u，其定义在第 11705 行，解混淆后如下：</p><pre><code class="hljs JavaScript">u = <span class="hljs-keyword">new</span> l[<span class="hljs-string">&quot;default&quot;</span>]()[<span class="hljs-string">&quot;encrypt&quot;</span>](i);</code></pre><p>所以 u 是 i 经过加密后得到的，i 定义在第 11702 行：</p><pre><code class="hljs JavaScript">i = (<span class="hljs-number">0</span>,d[$_DIEIq(<span class="hljs-number">103</span>)])()</code></pre><p>跟进到 <code>d[$_DIEIq(103)]</code> 中，定义在第 852 行，又是熟悉的 16 位随机数：</p><p><img src="https://cdn.itbob.cn/img/article/061/26.png" alt="26"></p><p>i 是随机数，跟进到加密函数 <code>l[($_DIEHS(84))]</code> 中，在第 12725 行，于 12741 行打下断点，可以看到这里就是个 RSA 加密，扣代码或者直接引库即可：</p><p><img src="https://cdn.itbob.cn/img/article/061/27.png" alt="27"></p><p>回到 c 参数，c 参数的值为一个大数组，其定义在第 11705 行，解混淆后内容如下：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> c = s[a][<span class="hljs-string">&quot;symmetrical&quot;</span>][<span class="hljs-string">&quot;encrypt&quot;</span>](e, i);</code></pre><p>e 之前分析完了，i 为随机数，两个参数已经分析完了，跟进到加密方法中，在第 12174 行，于 12186 行打下断点，控制台打印一下混淆部分内容，很熟悉的东西，这里就是 AES 加密，iv 为初始向量，加密模式为 CBC：</p><p><img src="https://cdn.itbob.cn/img/article/061/28.png" alt="28"></p><p>c 参数最后又被 <code>d[$_DIEHS(177)]</code> 函数加密，跟进后，定义在第 547 行，直接扣下来改改即可：</p><p><img src="https://cdn.itbob.cn/img/article/061/29.png" alt="29"></p><h2><span id="jie-guo-yan-zheng">结果验证</span></h2><p><img src="https://cdn.itbob.cn/img/article/061/30.png" alt="30"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>极验行为验证，三代滑块验证码逆向分析</title>
    <link href="https://www.itbob.cn/article/060/"/>
    <id>https://www.itbob.cn/article/060/</id>
    <published>2022-12-21T11:00:00.000Z</published>
    <updated>2022-12-26T03:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#tong-xun-liu-cheng">通讯流程</a></li><li><a href="#zhua-bao-fen-xi">抓包分析</a></li><li><a href="#ni-xiang-fen-xi">逆向分析</a><ul><li><a href="#w-can-shu">w 参数</a><ul><li><a href="#u-can-shu">u 参数</a></li><li><a href="#l-can-shu">l 参数</a></li></ul></li><li><a href="#di-tu-huan-yuan">底图还原</a></li><li><a href="#cuo-wu-jie-guo">错误结果</a></li><li><a href="#jie-guo-yan-zheng">结果验证</a></li></ul></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：某验三代滑块验证码，底图还原及 w 参数逆向</li><li>验证码 demo 列表：<code>aHR0cHM6Ly93d3cuZ2VldGVzdC5jb20vZGVtby8=</code></li><li>滑块验证码：<code>aHR0cHM6Ly93d3cuZ2VldGVzdC5jb20vZGVtby9zbGlkZS1mbG9hdC5odG1s</code></li><li>加密算法：RSA、AES、MD5</li></ul><h2><span id="tong-xun-liu-cheng">通讯流程</span></h2><p>接口相关：</p><p><img src="https://cdn.itbob.cn/img/article/060/01.png" alt="01"></p><p>完整流程：</p><p><img src="https://cdn.itbob.cn/img/article/060/02.jpg" alt="02"></p><h2><span id="zhua-bao-fen-xi">抓包分析</span></h2><p>进入网页后，打开开发者人员工具进行抓包</p><p>1.未点击按钮进行验证之前，Network 中抓包到了以下信息：</p><p><img src="https://cdn.itbob.cn/img/article/060/03.png" alt="03"></p><p><code>register-slide?t=xxx</code>：注册滑块请求，响应预览中返回的信息中重要的是 gt 和 challenge，gt 是固定值，不同网页对应不同的 gt 值，类似于特征码，challenge 的值每次刷新页面都会变化，gt 参数会通过 url string 的形式传递给 gettype.php：</p><p><img src="https://cdn.itbob.cn/img/article/060/04.png" alt="04"></p><p><code>gettype.php?gt=xxx&amp;callback=xxx</code>：获取验证码，HTTP 请求中不同的请求方式和设置不同的 Content-Type 时，参数传递的方式会不一样，一般为 Query String Parameters、Form Data、Request Payload，这里是 Query String Parameters，在 GET 请求时，参数会以 url string 的形式进行传递，即 ? 后的字符串则为其请求参数，并以 &amp; 作为分隔符，这里传递了 gt 参数的值以及 callback，callback 为 geetest_ + 时间戳：</p><p><img src="https://cdn.itbob.cn/img/article/060/05.png" alt="05"></p><p>响应预览中返回了一些 js 文件及对应的版本号：</p><p><img src="https://cdn.itbob.cn/img/article/060/06.png" alt="06"></p><p>第一个<code> get.php?xxx</code>，url 中传递了一些参数，关键部分如下：</p><ul><li><code>gt</code>：register-slide 响应返回的 gt 值；</li><li><code>challenge</code>：register-slide 响应返回的 challenge 值；</li><li><code>w</code>：对轨迹、滑动时间等进行加密后的参数，该网站第一个 w 值可以直接置空；</li><li><code>callback</code>：geetest_ + 时间戳。</li></ul><p><img src="https://cdn.itbob.cn/img/article/060/07.png" alt="07"></p><p>响应内容如下，这里没什么需要注意的，feedback 就是某验的帮助中心：</p><p><img src="https://cdn.itbob.cn/img/article/060/08.png" alt="08"></p><p>2.点击按钮进行验证之后，Network 中抓包到了以下信息：</p><p><img src="https://cdn.itbob.cn/img/article/060/09.png" alt="09"></p><p>第一个 <code>ajax.php?xxx</code>，url 中传递了一些参数，关键部分如下：</p><ul><li><code>gt</code>：register-slide 响应返回的 gt 值；</li><li><code>challenge</code>：register-slide 响应返回的 challenge 值；</li><li><code>w</code>：对轨迹、滑动时间等进行加密后的参数，该网站第二个 w 值也可以直接置空；</li><li><code>callback</code>：geetest_ + 时间戳。</li></ul><p><img src="https://cdn.itbob.cn/img/article/060/10.png" alt="10"></p><p>响应返回验证码模式，滑块验证码为 slide，点选验证码为 click：</p><p><img src="https://cdn.itbob.cn/img/article/060/11.png" alt="11"></p><p>第二个 <code>get.php?xxx</code>，url 中传递了一些参数，关键部分如下：</p><ul><li><code>gt</code>：register-slide 响应返回的 gt 值；</li><li><code>challenge</code>：register-slide 响应返回的 challenge 值；</li><li><code>callback</code>：geetest_ + 时间戳。</li></ul><p><img src="https://cdn.itbob.cn/img/article/060/12.png" alt="12"></p><p>这个响应返回了很多关键内容：</p><ul><li><code>bg</code>：被打乱的带缺口背景图，需要还原，<code>372fe236d.webp</code></li></ul><p><img src="https://cdn.itbob.cn/img/article/060/13.png" alt="13"></p><ul><li><code>fullbg</code>：被打乱的完整背景图，需要还原，<code>7bfaaa72b.webp</code></li></ul><p><img src="https://cdn.itbob.cn/img/article/060/14.png" alt="14"></p><ul><li><code>slice</code>：滑块图片，不需要还原，<code>372fe236d.png</code></li></ul><p><img src="https://cdn.itbob.cn/img/article/060/15.png" alt="15"></p><ul><li><code>c</code>：关键参数，与后面 aa 参数的值有关，固定值；</li><li><code>s</code>：关键参数，与后面 aa 参数的值有关。</li></ul><p><img src="https://cdn.itbob.cn/img/article/060/16.png" alt="16"></p><p>第二个 <code>ajax.php?xxx</code>，url 中传递了一些参数，关键部分如下：</p><ul><li><code>gt</code>：register-slide 响应返回的 gt 值；</li><li><code>challenge</code>：register-slide 响应返回的 challenge 值 + 两位字符串，注意多了两位，是第二个 get.php?xxx 返回值中得到的；</li><li><code>w</code>：对轨迹、滑动时间等进行加密后的参数，需要通过逆向得到；</li><li><code>callback</code>：geetest_ + 时间戳。</li></ul><p><img src="https://cdn.itbob.cn/img/article/060/17.png" alt="17"></p><p>滑动滑块验证通过即会返回以下内容：</p><p><img src="https://cdn.itbob.cn/img/article/060/18.png" alt="18"></p><p>失败则会返回：</p><p><img src="https://cdn.itbob.cn/img/article/060/19.png" alt="19"></p><h2><span id="ni-xiang-fen-xi">逆向分析</span></h2><h3><span id="w-can-shu">w 参数</span></h3><p>跟到 w 参数的值方法很多，以下讲两种：</p><p>1.很简便，w 参数在 js 文件中有特征码，点击按钮进行验证之后，ctrl + shift + f 全局搜索 <code>&quot;\u0077&quot;</code>，因为 <code>\u0077</code> 就是 w 的 Unicode 编码，然后点击进入 slide.7.8.9.js 文件中，7.8.9 为当前版本，注意没点击验证的话是不会有这个 js 文件的：</p><p><img src="https://cdn.itbob.cn/img/article/060/20.png" alt="20"></p><p>进入后点击左下角 <code>&#123;&#125;</code> 大括号，格式化文件，再 ctrl + f  局部搜索 <code>&quot;\u0077&quot;</code>，只有一个结果，在第 6086 行，在第 6088 行打下断点，滑动滑块即会断住，h + u 即为 w 参数的值：</p><p><img src="https://cdn.itbob.cn/img/article/060/21.png" alt="21"></p><p>2.通过 Initiator 跟栈，跟进到 <code>$_CId</code> 中：</p><p><img src="https://cdn.itbob.cn/img/article/060/22.png" alt="22"></p><p>进去同样格式化后，会跳转到第 4583 行，在该行打下断点：</p><p><img src="https://cdn.itbob.cn/img/article/060/23.png" alt="23"></p><p>向上跟栈到 <code>$_CCBv</code> 中同样会找到刚刚的位置：</p><p><img src="https://cdn.itbob.cn/img/article/060/24.png" alt="24"></p><p>由以上分析可知，w 参数是 h 和 u 相加得到的，所以找到定义的位置，看看是怎么构造生成的，u 参数定义在第 6077 行，h 参数定义在第 6079 行，内容如下：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> u = r[$_CAIAt(<span class="hljs-number">754</span>)](), l = V[$_CAIAt(<span class="hljs-number">353</span>)](gt[$_CAIAt(<span class="hljs-number">218</span>)](o), r[$_CAIAt(<span class="hljs-number">756</span>)]()), h = m[$_CAIAt(<span class="hljs-number">782</span>)](l)</code></pre><p>可以看到，h 参数是传入了 l 参数后经过 <code>m[$_CAIAt(782)]</code> 方法处理后得到的，所以依次往下分析，现在看看 u 参数是怎么生成的：</p><h4><span id="u-can-shu">u 参数</span></h4><p>u 参数通过 <code>r[$_CAIAt(754)]</code> 方法生成，选中后跟进到方法定义位置：</p><p><img src="https://cdn.itbob.cn/img/article/060/25.png" alt="25"></p><p>会跳转到第 6218 行，在 6227 行 return 处打下断点，重新拖动滑块，即会断住：</p><p><img src="https://cdn.itbob.cn/img/article/060/26.png" alt="26"></p><p>e 为 u 参数的值，其定义在第 6266 行：</p><pre><code class="hljs JavaScript">e = <span class="hljs-keyword">new</span> U()[$_CBGAZ(<span class="hljs-number">353</span>)](<span class="hljs-built_in">this</span>[$_CBGAZ(<span class="hljs-number">756</span>)](!<span class="hljs-number">0</span>));</code></pre><p>在控制台中打印输出一下各部分内容：</p><p><img src="https://cdn.itbob.cn/img/article/060/27.png" alt="27"></p><pre><code class="hljs JavaScript">e = <span class="hljs-keyword">new</span> U()[<span class="hljs-string">&quot;encrypt&quot;</span>](<span class="hljs-built_in">this</span>[<span class="hljs-string">&quot;$_CCEc&quot;</span>](!<span class="hljs-number">0</span>));</code></pre><p>从打印出来的结果可以看出，e 参数的值可能是将 16 位的随机字符串加密后得到的，跟进到 <code>this[$_CBGAZ(756)]</code> 中验证一下：</p><p><img src="https://cdn.itbob.cn/img/article/060/28.png" alt="28"></p><p>跳转到第 6208 行，在第 6214 行 return 处打下断点：</p><p><img src="https://cdn.itbob.cn/img/article/060/29.png" alt="29"></p><p><code>Ot</code> 即 16 为字符串，<code>Ot = rt()</code>，跟进到 <code>rt</code> 函数中，在第 4213 行，于第 4219 行打下断点后会发现，16 位字符串是由四个 <code>t()</code> 方法的结果相加得到的：</p><p><img src="https://cdn.itbob.cn/img/article/060/30.png" alt="30"></p><p>跟进到 <code>t()</code> 方法的定义位置，在第 4203 行，第 4208 行即为随机字符串算法：</p><p><img src="https://cdn.itbob.cn/img/article/060/31.png" alt="31"></p><p>还原混淆后内容如下，<code>Math.random()</code> 是随机选取大于等于 0.0 且小于 1.0 的伪随机 double 值，<code>toString(16)</code> 为十六进制字符串：</p><pre><code class="hljs javascript">(<span class="hljs-number">65536</span> * (<span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>[<span class="hljs-string">&quot;random&quot;</span>]()) | <span class="hljs-number">0</span>)[<span class="hljs-string">&quot;toString&quot;</span>](<span class="hljs-number">16</span>)[<span class="hljs-string">&quot;substring&quot;</span>](<span class="hljs-number">1</span>)</code></pre><p>JavaScript 复现：</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">random</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> random_str = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-number">4</span>; index++) &#123;        random_str += (<span class="hljs-number">65536</span> * (<span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>[<span class="hljs-string">&quot;random&quot;</span>]()) | <span class="hljs-number">0</span>)[<span class="hljs-string">&quot;toString&quot;</span>](<span class="hljs-number">16</span>)[<span class="hljs-string">&quot;substring&quot;</span>](<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> random_str;&#125;</code></pre><p><code>this[&quot;$_CCEc&quot;]</code> 分析完了，那 <code>new U()[&quot;encrypt&quot;]</code> 是什么呢，选中 <code>new U()</code> 后，从原型链中可以看到 <code>setPublic</code>，根据经验很有可能就是 RSA 加密设置公钥，加解密相关算法可以查看往期文章 <a href="https://www.itbob.cn/article/045/">CTF&amp;爬虫：掌握这些特征，一秒识别密文加密方式</a>：</p><p><img src="https://cdn.itbob.cn/img/article/060/32.png" alt="32"></p><p>跟进去查看一下：</p><p><img src="https://cdn.itbob.cn/img/article/060/33.png" alt="33"></p><p>跳转到第 2908 行，在第 2922 行断住后，<code>$_BACAs(332)</code> 的值为 <code>&quot;Invalid RSA public key&quot;</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/34.png" alt="34"></p><p>第 2908 行，ut 函数传入了两个值，t 为公钥值，e 为公钥模数，都是固定值：</p><ul><li><code>t</code>：<code>&quot;00C1E3934D1614465B33053E7F48EE4EC87B14B95EF88947713D25EECBFF7E74C7977D02DC1D9451F79DD5D1C10C29ACB6A9B4D6FB7D0A0279B6719E1772565F09AF627715919221AEF91899CAE08C0D686D748B20A3603BE2318CA6BC2B59706592A9219D0BF05C9F65023A21D2330807252AE0066D59CEEFA5F2748EA80BAB81&quot;</code></li><li><code>e</code>：<code>&quot;10001&quot;</code></li></ul><p>这里可以直接引库复现，也可以选择将算法部分扣下来，局部搜索 <code>var U = function</code>，在第 2043 行，将整个自执行函数扣下来，这里随机数后期写成固定值，后面也有随机数，不然会造成传参不匹配：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> U = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 此处过长，省略</span>&#125;();<span class="hljs-comment">// 随机数, 一组四个数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">t</span>(<span class="hljs-params"></span>) </span>&#123;    random_str = (<span class="hljs-number">65536</span> * (<span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>[<span class="hljs-string">&quot;random&quot;</span>]()) | <span class="hljs-number">0</span>)[<span class="hljs-string">&quot;toString&quot;</span>](<span class="hljs-number">16</span>)[<span class="hljs-string">&quot;substring&quot;</span>](<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> random_str;&#125;<span class="hljs-comment">// 随机数, 四个数一组, 四组</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRandomStr</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> t() + t() + t() + t();&#125;<span class="hljs-comment">// u 值</span><span class="hljs-keyword">var</span> u = <span class="hljs-keyword">new</span> U()[<span class="hljs-string">&#x27;encrypt&#x27;</span>](getRandomStr());<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;u 参数的值为:&#x27;</span>, u);</code></pre><p>运行后报错提示，<code>QBLnx is not defined</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/35.png" alt="35"></p><p>其定义在第 136 行，是个函数对象，补上即可：</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">QBLnx</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</code></pre><p>运行后报错提示，<code>$_IBAe is not a function</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/36.png" alt="36"></p><p>搜索后可知，其定义在第 128 行：</p><p><img src="https://cdn.itbob.cn/img/article/060/37.png" alt="37"></p><p>跟进过去将该部分扣下来：</p><pre><code class="hljs JavaScript">QBLnx.$_CM = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> QBLnx.$_Ak.$_DBGGT === <span class="hljs-string">&#x27;function&#x27;</span> ? QBLnx.$_Ak.$_DBGGT.apply(QBLnx.$_Ak, <span class="hljs-built_in">arguments</span>) : QBLnx.$_Ak.$_DBGGT;&#125;;</code></pre><p>接着报错提示，<code>Cannot read property '$_DBGGT' of undefined</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/38.png" alt="38"></p><p>定义在第 7 行，直接将 <code>QBLnx.$_Ak</code> 整个扣下来即可，然后会报错提示，window 和 ht 未定义，ht 为 navigator：</p><p><img src="https://cdn.itbob.cn/img/article/060/39.png" alt="39"></p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">window</span> = &#123;    <span class="hljs-string">&quot;navigator&quot;</span>: &#123;        <span class="hljs-string">&quot;appName&quot;</span>: <span class="hljs-string">&quot;Netscape&quot;</span>,    &#125;,&#125;ht = <span class="hljs-built_in">window</span>[<span class="hljs-string">&quot;navigator&quot;</span>];</code></pre><p>又报错提示，<code>QBLnx.$_Db is not a function</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/40.png" alt="40"></p><p>其定义在第 132 行，扣下来补上：</p><pre><code class="hljs JavaScript">QBLnx.$_Db = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> QBLnx.$_BP.$_DBHGJ === <span class="hljs-string">&#x27;function&#x27;</span> ? QBLnx.$_BP.$_DBHGJ.apply(QBLnx.$_BP, <span class="hljs-built_in">arguments</span>) : QBLnx.$_BP.$_DBHGJ;&#125;;</code></pre><p>报错提示，<code>Cannot read property '$_DBHGJ' of undefined</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/41.png" alt="41"></p><p>通过搜索，其定义在第 68 行，将 <code>QBLnx.$_BP</code> 整个扣下来即可，至此，u 参数成功复现：</p><p><img src="https://cdn.itbob.cn/img/article/060/42.png" alt="42"></p><h4><span id="l-can-shu">l 参数</span></h4><p>u 参数解决后，接着需要分析 l 参数，内容如下：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 混淆</span>l = V[$_CAIAt(<span class="hljs-number">353</span>)](gt[$_CAIAt(<span class="hljs-number">218</span>)](o), r[$_CAIAt(<span class="hljs-number">756</span>)]());<span class="hljs-comment">// 未混淆</span>l = V[<span class="hljs-string">&quot;encrypt&quot;</span>](gt[<span class="hljs-string">&quot;stringify&quot;</span>](o), r[<span class="hljs-string">&quot;$_CCEc&quot;</span>]());</code></pre><p>可以知道，l 参数的结果是将 <code>gt[&quot;stringify&quot;](o)</code> 和 <code>r[&quot;$_CCEc&quot;]()</code> 加密后得到的，先来分析 <code>r[&quot;$_CCEc&quot;]()</code> ，选中后跟进进去，跳转到了熟悉的第 6208 行，就是之前的 16 位随机字符串：</p><p><img src="https://cdn.itbob.cn/img/article/060/43.png" alt="43"></p><p>将这里写成跟之前一样的固定值， <code>gt[&quot;stringify&quot;](o)</code> 返回的是 JSON 格式的数据，由 o 参数生成：</p><p><img src="https://cdn.itbob.cn/img/article/060/44.png" alt="44"></p><p>对比分析以下 o 参数中，哪些是定值，哪些是动态变化的，可以看到箭头所指的值都不一样了：</p><p><img src="https://cdn.itbob.cn/img/article/060/45.png" alt="45"></p><ul><li><code>userresponse</code>：滑动距离 + challenge 的值；</li><li><code>passtime</code>：滑块滑动时间；</li><li><code>imgload</code>：图片加载时间；</li><li><code>aa</code>：轨迹加密；</li><li><code>ep-tm</code>：<code>window[&quot;performance&quot;][&quot;timing&quot;]</code> 相关；</li><li><code>mocq</code>：每天 key、value 会变，后文分析；</li><li><code>rp</code>：gt + 32 位 challenge + passtime，再经过 MD5 加密。</li></ul><p>接下来对关键值进行分析，先来分析下 <code>userresponse</code>，o 定义在第 6012 行：</p><p><img src="https://cdn.itbob.cn/img/article/060/46.png" alt="46"></p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> o = &#123;    <span class="hljs-string">&quot;lang&quot;</span>: i[$_CAIAt(<span class="hljs-number">116</span>)] || $_CAHJd(<span class="hljs-number">103</span>),    <span class="hljs-string">&quot;userresponse&quot;</span>: H(t, i[$_CAHJd(<span class="hljs-number">182</span>)]),    <span class="hljs-string">&quot;passtime&quot;</span>: n,    <span class="hljs-string">&quot;imgload&quot;</span>: r[$_CAIAt(<span class="hljs-number">750</span>)],    <span class="hljs-string">&quot;aa&quot;</span>: e,    <span class="hljs-string">&quot;ep&quot;</span>: r[$_CAHJd(<span class="hljs-number">714</span>)]()&#125;;</code></pre><p><code>userresponse</code> 定义在第 6014 行，需要分析 <code>H(t, i[$_CAHJd(182)])</code>，控制台打印一下：</p><p><img src="https://cdn.itbob.cn/img/article/060/47.png" alt="47"></p><p>t 为滑动滑块的距离，需要注意的是 <code>i[$_CAHJd(182)]</code> 为第二个 <code>ajax.php?xxx</code> 传递的 <code>challenge</code>，比注册请求时的 <code>challenge</code> 长两位，再将 H 参数扣下来即可，其定义在第 704 行，报错提示，<code>$_CJFA is not defined</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/48.png" alt="48"></p><p>定义在第 159 行：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> $_CJEl = QBLnx.$_CM, $_CJDa = [<span class="hljs-string">&#x27;$_CJHo&#x27;</span>].concat($_CJEl), $_CJFA = $_CJDa[<span class="hljs-number">1</span>];</code></pre><p>至此，<code>userresponse</code> 成功复现，接下来看 <code>passtime</code>，<code>n</code> 值此时已经生成了，为 1010，向上跟栈到 <code>$_CGlj</code> 中：</p><p><img src="https://cdn.itbob.cn/img/article/060/49.png" alt="49"></p><p><code>n[$_DAAAV(871)]</code> 为 <code>passtime</code> 值，定义在第 8164 行，为滑动结束时间 - 开始时间：</p><p><img src="https://cdn.itbob.cn/img/article/060/50.png" alt="50"></p><p>接下来分析下 <code>aa</code> 参数，其定义在第 6017 行，值由参数 <code>e</code> 传递，同样向上跟栈到 <code>$_CGlj</code> 中，为第 8168 行的 l 值，l 定义在第 8167 行，三个参数加密后得到：</p><p><img src="https://cdn.itbob.cn/img/article/060/51.png" alt="51"></p><ul><li><code>n[$_DAAAV(913)][$_CJJJb(1066)]()</code> ：轨迹加密后的结果；</li><li><code>n[$_DAAAV(69)][$_CJJJb(1097)]</code> ：c 值，在第二个 <code>get.php?xxx</code> 返回的响应中得到；</li><li><code>n[$_DAAAV(69)][$_CJJJb(319)]</code> ：s 值，在第二个 <code>get.php?xxx</code> 返回的响应中得到。</li></ul><p><img src="https://cdn.itbob.cn/img/article/060/52.png" alt="52"></p><p>接下来跟进到 <code>n[$_DAAAV(913)][$_CJJJb(1066)]</code> 中，分析下轨迹是如何加密的，在第 4065 行，于第 4133 行打下断点，第 4108 行的 <code>this[$_BEHAL(343)]</code> 即为轨迹值，关于轨迹算法后面会专门出一期文章：</p><p><img src="https://cdn.itbob.cn/img/article/060/53.png" alt="53"></p><p>将整个算法部分抠出来，先将轨迹值固定，写成参数传递进去，不然会报错提示，<code>Cannot read property 'length' of undefined</code>，因为轨迹值是别的算法生成的，不传值即为空，运行程序，会报错提示，<code>ct is not defined</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/54.png" alt="54"></p><p>ct 定义在第 4223 行，扣下来，报错提示，<code>(intermediate value)[$_BEHAL(...)] is not a function</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/55.png" alt="55"></p><p>定义在第 4326 行，补上以下内容，即可复现：</p><pre><code class="hljs JavaScript">ct[<span class="hljs-string">&quot;prototype&quot;</span>] = &#123;<span class="hljs-string">&quot;\u0024\u005f\u0043\u0041\u0051&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t</span>) </span>&#123;        <span class="hljs-keyword">var</span> $_BFFJi = QBLnx.$_CM            , $_BFFIX = [<span class="hljs-string">&#x27;$_BFGCq&#x27;</span>].concat($_BFFJi)            , $_BFGAT = $_BFFIX[<span class="hljs-number">1</span>];        $_BFFIX.shift();        <span class="hljs-keyword">var</span> $_BFGBV = $_BFFIX[<span class="hljs-number">0</span>];        <span class="hljs-keyword">var</span> e = <span class="hljs-built_in">this</span>[$_BFFJi(<span class="hljs-number">461</span>)];        <span class="hljs-keyword">if</span> (e[$_BFGAT(<span class="hljs-number">419</span>)])            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ct(e[$_BFFJi(<span class="hljs-number">419</span>)](t));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = [], r = <span class="hljs-number">0</span>, i = e[$_BFGAT(<span class="hljs-number">125</span>)]; r &lt; i; r += <span class="hljs-number">1</span>)            n[r] = t(e[r], r, <span class="hljs-built_in">this</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ct(n);    &#125;,&#125;;</code></pre><p>结果对比一致：</p><p><img src="https://cdn.itbob.cn/img/article/060/56.png" alt="56"></p><p>后面三个参数的值都分析完了，回到第 8167 行 l 处，跟进到 <code>n[$_DAAAV(913)][$_DAAAV(1059)]</code> 中，在第 4135 行，扣下来即可：</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAA</span>(<span class="hljs-params">t, e, n</span>) </span>&#123;    <span class="hljs-keyword">var</span> $_BEIJl = QBLnx.$_CM      , $_BEIIt = [<span class="hljs-string">&#x27;$_BEJC_&#x27;</span>].concat($_BEIJl)      , $_BEJAy = $_BEIIt[<span class="hljs-number">1</span>];    $_BEIIt.shift();    <span class="hljs-keyword">var</span> $_BEJBr = $_BEIIt[<span class="hljs-number">0</span>];    <span class="hljs-keyword">if</span> (!e || !n)        <span class="hljs-keyword">return</span> t;    <span class="hljs-keyword">var</span> r, i = <span class="hljs-number">0</span>, o = t, s = e[<span class="hljs-number">0</span>], a = e[<span class="hljs-number">2</span>], _ = e[<span class="hljs-number">4</span>];    <span class="hljs-keyword">while</span> (r = n[$_BEIJl(<span class="hljs-number">229</span>)](i, <span class="hljs-number">2</span>)) &#123;        i += <span class="hljs-number">2</span>;        <span class="hljs-keyword">var</span> c = <span class="hljs-built_in">parseInt</span>(r, <span class="hljs-number">16</span>)          , u = <span class="hljs-built_in">String</span>[$_BEJAy(<span class="hljs-number">237</span>)](c)          , l = (s * c * c + a * c + _) % t[$_BEJAy(<span class="hljs-number">125</span>)];        o = o[$_BEJAy(<span class="hljs-number">229</span>)](<span class="hljs-number">0</span>, l) + u + o[$_BEJAy(<span class="hljs-number">229</span>)](l);    &#125;    <span class="hljs-keyword">return</span> o;&#125;;</code></pre><p>将 c 和 s 写为固定值，对比结果一致：</p><p><img src="https://cdn.itbob.cn/img/article/060/57.png" alt="57"></p><p>aa 参数分析完成，接下来分析 rp 参数，定义在第 6076 行：</p><p><img src="https://cdn.itbob.cn/img/article/060/58.png" alt="58"></p><pre><code class="hljs JavaScript"><span class="hljs-comment">// 混淆</span>o[$_CAIAt(<span class="hljs-number">791</span>)] = X(i[$_CAIAt(<span class="hljs-number">104</span>)] + i[$_CAIAt(<span class="hljs-number">182</span>)][$_CAHJd(<span class="hljs-number">139</span>)](<span class="hljs-number">0</span>, <span class="hljs-number">32</span>) + o[$_CAHJd(<span class="hljs-number">704</span>)]);<span class="hljs-comment">// 未混淆</span>o[<span class="hljs-string">&quot;rp&quot;</span>] = X(i[<span class="hljs-string">&quot;gt&quot;</span>] + i[<span class="hljs-string">&quot;challenge&quot;</span>][<span class="hljs-string">&quot;slice&quot;</span>](<span class="hljs-number">0</span>, <span class="hljs-number">32</span>) + o[<span class="hljs-string">&quot;passtime&quot;</span>]);</code></pre><p>后面三个参数都很明显了，跟进到 X 函数中，在第 1876 行，扣下来即可，对比结果一致：</p><p><img src="https://cdn.itbob.cn/img/article/060/59.png" alt="59"></p><p>这里是 MD5 加密，也可以直接通过引库复现：</p><p><img src="https://cdn.itbob.cn/img/article/060/60.png" alt="60"></p><p>ep 定义在第 6018 行，跟进到 <code>r[$_CAHJd(714)]</code> 中，tm 参数定义在第 6239 行：</p><p><img src="https://cdn.itbob.cn/img/article/060/61.png" alt="61"></p><p>跟进 <code>new bt()[$_CBGEC(760)]</code> 中，在第 5268 行打下断点，tm 结果如下：</p><p><img src="https://cdn.itbob.cn/img/article/060/62.png" alt="62"></p><p>o 中这个键值对内容每天都会变化：</p><p><img src="https://cdn.itbob.cn/img/article/060/63.png" alt="63"></p><p>在第 6021 行打下断点，此时的 o 中还没有生成以上键值对：</p><p><img src="https://cdn.itbob.cn/img/article/060/64.png" alt="64"></p><p>接着往下找，第 6026 行 <code>a = window[$_CAHJd(744)](s)</code> 执行之后 s 中生成了以上的键值对，所以跟进到 <code>window[$_CAHJd(744)]</code> 中，会跳转到 <code>gct.xxxxxxxx.js</code> 文件中，这个文件的路径可以从 get.php 接口获取到：</p><p><img src="https://cdn.itbob.cn/img/article/060/65.png" alt="65"></p><p>在该文件的第 1253 行打下断点，可以看到此时的 t 中已经生成了 <code>h9s9: &quot;1803797734&quot;</code> ：</p><p><img src="https://cdn.itbob.cn/img/article/060/66.png" alt="66"></p><p>跟进到 <code>StJC</code> 方法中，其定义在第 1202 行，在第 1208 行打下断点，键值对在此处生成，可以通过全局导出调用：</p><p><img src="https://cdn.itbob.cn/img/article/060/67.png" alt="67"></p><p>至此，参数 o 复现完毕，回到第 6078 行，分析完 <code>V[$_CAIAt(353)]</code> l 即完成，跟进，定义在第 3218 行，在第 3230 行打下断点，这里为 AES 加密，初始向量 iv 值为 <code>&quot;0000000000000000&quot;</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/68.png" alt="68"></p><p>直接引库复现：</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aesV</span>(<span class="hljs-params">o_text, random_str</span>) </span>&#123;    <span class="hljs-keyword">var</span> key = CryptoJS.enc.Utf8.parse(random_str);    <span class="hljs-keyword">var</span> iv = CryptoJS.enc.Utf8.parse(<span class="hljs-string">&quot;0000000000000000&quot;</span>);    <span class="hljs-keyword">var</span> srcs = CryptoJS.enc.Utf8.parse(o_text);    <span class="hljs-keyword">var</span> encrypted = CryptoJS.AES.encrypt(srcs, key, &#123;        <span class="hljs-attr">iv</span>: iv,        <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,        <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7    &#125;);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> r = encrypted, o = r.ciphertext.words, i = r.ciphertext.sigBytes, s = [], a = <span class="hljs-number">0</span>; a &lt; i; a++) &#123;        <span class="hljs-keyword">var</span> c = o[a &gt;&gt;&gt; <span class="hljs-number">2</span>] &gt;&gt;&gt; <span class="hljs-number">24</span> - a % <span class="hljs-number">4</span> * <span class="hljs-number">8</span> &amp; <span class="hljs-number">255</span>;        s.push(c);    &#125;    <span class="hljs-keyword">return</span> s;&#125;;</code></pre><p>对比结果一致：</p><p><img src="https://cdn.itbob.cn/img/article/060/69.png" alt="69"></p><p>l 参数分析完毕，终于只剩下一个 h 了，<code>m[$_CAIAt(782)](l)</code> 即将 l 加密后得到的，跟进 <code>m[$_CAIAt(782)]</code>，定义在第 1568 行，在第 1575 行打下断点，为 e 中两个 value 值相加：</p><p><img src="https://cdn.itbob.cn/img/article/060/70.png" alt="70"></p><p>e 定义在第 1574 行，t 为传入的 l 参数，跟进到 <code>this[$_GFJn(264)]</code> 中，在第 1523 行，复现如下：</p><p><img src="https://cdn.itbob.cn/img/article/060/71.png" alt="71"></p><p>校验结果一致：</p><p><img src="https://cdn.itbob.cn/img/article/060/72.png" alt="72"></p><p>w 参数至此终于全部复现完成！</p><h3><span id="di-tu-huan-yuan">底图还原</span></h3><p>前文说过，拿到的完整背景图以及带缺口背景图都是被打乱了的，这里需要还原才能计算滑动距离以及轨迹等，极验的底图是通过 Canvas 绘制出来的，直接打下事件断点：</p><p><img src="https://cdn.itbob.cn/img/article/060/73.png" alt="73"></p><p>点击按钮进行验证即会断住，格式化后跳转到第 295 行，</p><p><img src="https://cdn.itbob.cn/img/article/060/74.png" alt="74"></p><p>简单解一波混淆，会清晰一些：</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">$_BEG</span>(<span class="hljs-params">t, e</span>) </span>&#123;    <span class="hljs-keyword">var</span> $_DAHHo = QBLnx.$_Db()[<span class="hljs-number">12</span>][<span class="hljs-number">19</span>];    <span class="hljs-keyword">for</span> (; $_DAHHo !== QBLnx.$_Db()[<span class="hljs-number">15</span>][<span class="hljs-number">16</span>];) &#123;        <span class="hljs-keyword">switch</span> ($_DAHHo) &#123;            <span class="hljs-keyword">case</span> QBLnx.$_Db()[<span class="hljs-number">15</span>][<span class="hljs-number">19</span>]:                t = t[<span class="hljs-string">&quot;$_CGz&quot;</span>],                e = e[<span class="hljs-string">&quot;$_CGz&quot;</span>];                <span class="hljs-keyword">var</span> n = t[<span class="hljs-string">&quot;width&quot;</span>]                    , r = t[<span class="hljs-string">&quot;height&quot;</span>]                    , i = h[<span class="hljs-string">&quot;createElement&quot;</span>](<span class="hljs-string">&quot;canvas&quot;</span>);                i[<span class="hljs-string">&quot;width&quot;</span>] = n,                i[<span class="hljs-string">&quot;height&quot;</span>] = r;                $_DAHHo = QBLnx.$_Db()[<span class="hljs-number">3</span>][<span class="hljs-number">18</span>];                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> QBLnx.$_Db()[<span class="hljs-number">0</span>][<span class="hljs-number">18</span>]:                <span class="hljs-keyword">var</span> o = i[<span class="hljs-string">&quot;getContext&quot;</span>](<span class="hljs-string">&quot;2d&quot;</span>);                o[<span class="hljs-string">&quot;drawImage&quot;</span>](t, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);                <span class="hljs-keyword">var</span> s = e[<span class="hljs-string">&quot;getContext&quot;</span>](<span class="hljs-string">&quot;2d&quot;</span>);                $_DAHHo = QBLnx.$_Db()[<span class="hljs-number">0</span>][<span class="hljs-number">17</span>];                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> QBLnx.$_Db()[<span class="hljs-number">12</span>][<span class="hljs-number">17</span>]:                e[<span class="hljs-string">&quot;height&quot;</span>] = <span class="hljs-number">160</span>,                e[<span class="hljs-string">&quot;width&quot;</span>] = <span class="hljs-number">260</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> a = r / <span class="hljs-number">2</span>, _ = <span class="hljs-number">0</span>; _ &lt; <span class="hljs-number">52</span>; _ += <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">var</span> c = Ut[_] % <span class="hljs-number">26</span> * <span class="hljs-number">12</span> + <span class="hljs-number">1</span>                        , u = <span class="hljs-number">25</span> &lt; Ut[_] ? a : <span class="hljs-number">0</span>                        , l = o[<span class="hljs-string">&quot;getImageData&quot;</span>](c, u, <span class="hljs-number">10</span>, a);                    s[<span class="hljs-string">&quot;putImageData&quot;</span>](l, _ % <span class="hljs-number">26</span> * <span class="hljs-number">10</span>, <span class="hljs-number">25</span> &lt; _ ? a : <span class="hljs-number">0</span>);                &#125;                $_DAHHo = QBLnx.$_Db()[<span class="hljs-number">15</span>][<span class="hljs-number">16</span>];                <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;</code></pre><p>控制流平坦化混淆，可以通过 AST 技术解混淆，AST 相关可以看往期文章：<a href="https://www.itbob.cn/article/051/">逆向进阶，利用 AST 技术还原 JavaScript 混淆代码</a>，这里就不对此进行讲解了，这里就是 Canvas 绘图的过程，关键乱序算法部分在 <code>QBLnx.$_Db()[12][17]</code> 中：</p><pre><code class="hljs JavaScript">e[<span class="hljs-string">&quot;height&quot;</span>] = <span class="hljs-number">160</span>,e[<span class="hljs-string">&quot;width&quot;</span>] = <span class="hljs-number">260</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> a = r / <span class="hljs-number">2</span>, _ = <span class="hljs-number">0</span>; _ &lt; <span class="hljs-number">52</span>; _ += <span class="hljs-number">1</span>) &#123;    <span class="hljs-keyword">var</span> c = Ut[_] % <span class="hljs-number">26</span> * <span class="hljs-number">12</span> + <span class="hljs-number">1</span>        , u = <span class="hljs-number">25</span> &lt; Ut[_] ? a : <span class="hljs-number">0</span>        , l = o[<span class="hljs-string">&quot;getImageData&quot;</span>](c, u, <span class="hljs-number">10</span>, a);    s[<span class="hljs-string">&quot;putImageData&quot;</span>](l, _ % <span class="hljs-number">26</span> * <span class="hljs-number">10</span>, <span class="hljs-number">25</span> &lt; _ ? a : <span class="hljs-number">0</span>);&#125;</code></pre><p>原图比例为 312 x 160，宽为 320，长为 160：</p><p><img src="https://cdn.itbob.cn/img/article/060/75.png" alt="75"></p><p><code>e[&quot;height&quot;] = 160</code>、<code>e[&quot;width&quot;] = 260</code> 指还原后的图片比例为 260 x 160，a 的值为 r / 2 即 80，就是将整张图片分为了上下两等分，再将图片纵向切割为了 26 等份，Ut 数组的长度为 52，<code>Ut[_]</code> 即依次取数组中的元素，<code>Ut</code> 数组即为图片还原的顺序，是固定的，<code>25 &lt; Ut[_] ? a : 0 </code> 判断图片是上半部分还是下半部分，<code>_ % 26 * 10</code> 表示每个小块取 10 px 像素，正确图片的顺序为：</p><p><img src="https://cdn.itbob.cn/img/article/060/76.png" alt="76"></p><pre><code class="hljs JavaScript">[<span class="hljs-number">39</span>,<span class="hljs-number">38</span>,<span class="hljs-number">48</span>,<span class="hljs-number">49</span>,<span class="hljs-number">41</span>,<span class="hljs-number">40</span>,<span class="hljs-number">46</span>,<span class="hljs-number">47</span>,<span class="hljs-number">35</span>,<span class="hljs-number">34</span>,<span class="hljs-number">50</span>,<span class="hljs-number">51</span>,<span class="hljs-number">33</span>,<span class="hljs-number">32</span>,<span class="hljs-number">28</span>,<span class="hljs-number">29</span>,<span class="hljs-number">27</span>,<span class="hljs-number">26</span>,<span class="hljs-number">36</span>,<span class="hljs-number">37</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">44</span>,<span class="hljs-number">45</span>,<span class="hljs-number">43</span>,<span class="hljs-number">42</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">23</span>,<span class="hljs-number">22</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">21</span>,<span class="hljs-number">20</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">25</span>,<span class="hljs-number">24</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">10</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">19</span>,<span class="hljs-number">18</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>]</code></pre><p>示例：</p><p><img src="https://cdn.itbob.cn/img/article/060/77.png" alt="77"></p><p>Python 复现：</p><pre><code class="hljs JavaScript">def restore_picture():    img_list = [<span class="hljs-string">&quot;./乱序缺口背景图.png&quot;</span>, <span class="hljs-string">&quot;./乱序背景图.png&quot;</span>]    <span class="hljs-keyword">for</span> index, img <span class="hljs-keyword">in</span> enumerate(img_list):        image = Image.open(img)        s = Image.new(<span class="hljs-string">&quot;RGBA&quot;</span>, (<span class="hljs-number">260</span>, <span class="hljs-number">160</span>))        ut = [<span class="hljs-number">39</span>, <span class="hljs-number">38</span>, <span class="hljs-number">48</span>, <span class="hljs-number">49</span>, <span class="hljs-number">41</span>, <span class="hljs-number">40</span>, <span class="hljs-number">46</span>, <span class="hljs-number">47</span>, <span class="hljs-number">35</span>, <span class="hljs-number">34</span>, <span class="hljs-number">50</span>, <span class="hljs-number">51</span>, <span class="hljs-number">33</span>, <span class="hljs-number">32</span>, <span class="hljs-number">28</span>, <span class="hljs-number">29</span>, <span class="hljs-number">27</span>, <span class="hljs-number">26</span>, <span class="hljs-number">36</span>, <span class="hljs-number">37</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>, <span class="hljs-number">43</span>,<span class="hljs-number">42</span>,<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">23</span>, <span class="hljs-number">22</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">21</span>, <span class="hljs-number">20</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">25</span>, <span class="hljs-number">24</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">19</span>, <span class="hljs-number">18</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>]        height_half = <span class="hljs-number">80</span>        <span class="hljs-keyword">for</span> inx <span class="hljs-keyword">in</span> range(<span class="hljs-number">52</span>):            c = ut[inx] % <span class="hljs-number">26</span> * <span class="hljs-number">12</span> + <span class="hljs-number">1</span>            u = height_half <span class="hljs-keyword">if</span> ut[inx] &gt; <span class="hljs-number">25</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>            l_ = image.crop(box=(c, u, c + <span class="hljs-number">10</span>, u + <span class="hljs-number">80</span>))            s.paste(l_, box=(inx % <span class="hljs-number">26</span> * <span class="hljs-number">10</span>, <span class="hljs-number">80</span> <span class="hljs-keyword">if</span> inx &gt; <span class="hljs-number">25</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>))        <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span>:            s.save(<span class="hljs-string">&quot;./缺口背景图片.png&quot;</span>)        <span class="hljs-attr">else</span>:            s.save(<span class="hljs-string">&quot;./背景图片.png&quot;</span>)</code></pre><p>还原后如下：</p><p><img src="https://cdn.itbob.cn/img/article/060/78.png" alt="78"></p><h3><span id="cuo-wu-jie-guo">错误结果</span></h3><pre><code class="hljs JavaScript"><span class="hljs-comment">// challenge 不对</span>geetest_xxxxxxxxxxxxx(&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;illegal challenge&quot;</span>, <span class="hljs-string">&quot;user_error&quot;</span>: <span class="hljs-string">&quot;\u7f51\u7edc\u4e0d\u7ed9\u529b&quot;</span>, <span class="hljs-string">&quot;error_code&quot;</span>: <span class="hljs-string">&quot;error_23&quot;</span>&#125;)<span class="hljs-comment">// w 不对</span>geetest_xxxxxxxxxxxxx(&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;param decrypt error&quot;</span>, <span class="hljs-string">&quot;user_error&quot;</span>: <span class="hljs-string">&quot;\u7f51\u7edc\u4e0d\u7ed9\u529b&quot;</span>, <span class="hljs-string">&quot;error_code&quot;</span>: <span class="hljs-string">&quot;error_03&quot;</span>&#125;)<span class="hljs-comment">// 无轨迹</span>geetest_xxxxxxxxxxxxx(&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;not proof&quot;</span>, <span class="hljs-string">&quot;user_error&quot;</span>: <span class="hljs-string">&quot;\u7f51\u7edc\u4e0d\u7ed9\u529b&quot;</span>, <span class="hljs-string">&quot;error_code&quot;</span>: <span class="hljs-string">&quot;error_21&quot;</span>&#125;)<span class="hljs-comment">// 轨迹、缺口距离、参数问题</span>geetest_xxxxxxxxxxxxx(&#123;<span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;fail&quot;</span>&#125;)geetest_xxxxxxxxxxxxx(&#123;<span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;forbidden&quot;</span>&#125;)</code></pre><h3><span id="jie-guo-yan-zheng">结果验证</span></h3><p>100 次大概 95% 的成功率：</p><p><img src="https://cdn.itbob.cn/img/article/060/79.jpg" alt="79"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>极验行为验证，二代滑块验证码逆向分析</title>
    <link href="https://www.itbob.cn/article/059/"/>
    <id>https://www.itbob.cn/article/059/</id>
    <published>2022-12-18T12:00:00.000Z</published>
    <updated>2022-12-18T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#zhua-bao-qing-kuang">抓包情况</a></li><li><a href="#ni-xiang-fen-xi">逆向分析</a><ul><li><a href="#huo-qu-h7z-zhi">获取 H7z 值</a></li><li><a href="#huo-qu-r7z-zhi">获取 r7z 值</a><ul><li><a href="#huo-qu-userresponse-zhi">获取 userresponse 值</a></li><li><a href="#huo-qu-passtime-zhi">获取 passtime  值</a></li><li><a href="#huo-qu-imgload-zhi">获取 imgload 值</a></li><li><a href="#huo-qu-aa-zhi">获取 aa 值</a></li><li><a href="#huo-qu-ep-zhi">获取 ep 值</a></li><li><a href="#huo-qu-rp-zhi">获取 rp 值</a></li></ul></li><li><a href="#huo-qu-w-zhi">获取 w 值</a></li></ul></li><li><a href="#jie-guo-yan-zheng">结果验证</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：某验二代滑块验证码逆向分析</li><li>主页：<code>aHR0cDovL3d3dy5qc2dzai5nb3YuY246NTg4ODgvbWluaS9uZXR3ZWIvU01MaWJyYXJ5LmpzcA==</code></li><li>说明：大多数逻辑其实和三四代都一样，相同的就简写了，有疑惑的地方可以看以前的文章</li><li><a href="https://www.itbob.cn/article/060/">某验行为验证，三代滑块验证码逆向分析</a></li><li><a href="https://www.itbob.cn/article/061/">某验行为验证，四代滑块验证码逆向分析</a></li></ul><h2><span id="zhua-bao-qing-kuang">抓包情况</span></h2><p>主页点击搜索就会跳出二代的验证码，<code>netWebServlet.json</code> 的请求，会返回 <code>challenge</code> 和 <code>gt</code>。</p><p><img src="https://cdn.itbob.cn/img/article/059/01.png" alt="01"></p><p>有个 <code>get.php</code> 的请求，返回了一个新的 <code>challenge</code>，这个请求之后的操作，都要用这个新的 <code>challenge</code>，不然是验证不成功的，其他的还有验证码背景图片、乱序图片地址、<code>c</code>、<code>s</code> 等值，之前写过三代的文章，都是类似的，这里就不一一分析了。</p><p><img src="https://cdn.itbob.cn/img/article/059/02.png" alt="02"></p><p>然后是 <code>ajax.php</code> 验证是否通过，通过之后返回一个 <code>validate</code>，请求里同样是需要我们逆向的 <code>w</code> 参数：</p><p><img src="https://cdn.itbob.cn/img/article/059/03.png" alt="03"></p><p><img src="https://cdn.itbob.cn/img/article/059/04.png" alt="04"></p><p>然后同样还是 <code>netWebServlet.json</code> 接口，带上 <code>get.php</code> 请求返回的 <code>challenge</code> 以及 <code>ajax.php</code> 返回的 <code>validate</code>，请求拿到一个 <code>name</code> 的字段。</p><p><img src="https://cdn.itbob.cn/img/article/059/05.png" alt="05"></p><p><img src="https://cdn.itbob.cn/img/article/059/06.png" alt="06"></p><p>后续的搜索数据，带上这个 <code>name</code> 就行了：</p><p><img src="https://cdn.itbob.cn/img/article/059/07.png" alt="07"></p><h2><span id="ni-xiang-fen-xi">逆向分析</span></h2><p>搞过三、四代的都知道我们可以直接搜索 <code>w</code> 的 Unicode 值 <code>\u0077</code> 即可定位，但是二代则不是 Unicode，而是16进制的编码，搜索 <code>\x77</code> 即可定位，当然按照正常流程，跟栈也能很容易找到加密的位置。</p><p><img src="https://cdn.itbob.cn/img/article/059/08.png" alt="08"></p><h3><span id="huo-qu-h7z-zhi">获取 H7z 值</span></h3><p>从上图中可以知道 <code>w</code> 的值为 <code>r7z + H7z</code>，先看 <code>H7z</code>。</p><p><img src="https://cdn.itbob.cn/img/article/059/09.png" alt="09"></p><p>跟进这个方法，来到一大串控制流，这里还是推荐用 AST 还原一下，后续可能有一些循环啥的，硬跟的话容易出错，当然直接全部扣一把梭也是可以的，<code>H7z</code> 的核心其实就是 RSA 加密随机字符串，三代四代都有，这里就不细讲了。</p><p><img src="https://cdn.itbob.cn/img/article/059/10.png" alt="10"></p><h3><span id="huo-qu-r7z-zhi">获取 r7z 值</span></h3><p>然后就是 <code>r7z</code>，主要由以下两句代码生成：</p><p><img src="https://cdn.itbob.cn/img/article/059/11.png" alt="11"></p><pre><code class="hljs javascript">q7z = n0B[M9r.R8z(<span class="hljs-number">699</span>)](h7B[M9r.C8z(<span class="hljs-number">105</span>)](Y7z), V7z[M9r.R8z(<span class="hljs-number">818</span>)]())r7z = p7B[M9r.R8z(<span class="hljs-number">260</span>)](q7z)</code></pre><p>可以看到其中有个变量 <code>Y7z</code> 参与了计算，先来看看他是怎么来的，直接搜索即可定位，可以发现同样是16进制的编码，由五个值组成：<code>userresponse</code>、<code>passtime</code>、<code>imgload</code>、<code>aa</code>、<code>ep</code></p><p><img src="https://cdn.itbob.cn/img/article/059/12.png" alt="12"></p><h4><span id="huo-qu-userresponse-zhi">获取 userresponse 值</span></h4><p>挨个分析，首先是 <code>userresponse</code>，将滑动距离和 <code>challenge</code> 的值传入一个方法，得到一个 9 位字符串：</p><p><img src="https://cdn.itbob.cn/img/article/059/13.png" alt="13"></p><p>上图中 <code>g7z</code> 就是滑动距离，搜索可以看到定义的地方，尺子量一下对比一下，和滑动的距离是一致的：</p><p><img src="https://cdn.itbob.cn/img/article/059/14.png" alt="14"></p><p><img src="https://cdn.itbob.cn/img/article/059/15.png" alt="15"></p><p>然后再来看看那个方法，跟进去之后也是一大串 <code>switch-case</code> 控制流：</p><p><img src="https://cdn.itbob.cn/img/article/059/16.png" alt="16"></p><p>还原一下代码如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUserResponse</span>(<span class="hljs-params">L0z, o0z</span>) </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j0z = o0z.slice(<span class="hljs-number">32</span>), c0z = [], X0z = <span class="hljs-number">0</span>; X0z &lt; j0z.length; X0z++)&#123;        <span class="hljs-keyword">var</span> K0z = j0z.charCodeAt(X0z);        c0z[X0z] = K0z &gt; <span class="hljs-number">57</span> ? K0z - <span class="hljs-number">87</span> : K0z - <span class="hljs-number">48</span>;    &#125;    j0z = <span class="hljs-number">36</span> * c0z[<span class="hljs-number">0</span>] + c0z[<span class="hljs-number">1</span>];    <span class="hljs-keyword">var</span> k0z = <span class="hljs-built_in">Math</span>.round(L0z) + j0z;    o0z = o0z.slice(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>);    <span class="hljs-keyword">var</span> n0z, f0z = [[], [], [], [], []], Q0z = &#123;&#125;, N0z = <span class="hljs-number">0</span>;    X0z = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i0z = o0z.length; i0z &gt; X0z; X0z++)&#123;        n0z = o0z.charAt(X0z), Q0z[n0z] || (Q0z[n0z] = <span class="hljs-number">1</span>, f0z[N0z].push(n0z), N0z++, N0z = <span class="hljs-number">5</span> == N0z ? <span class="hljs-number">0</span> : N0z);    &#125;    <span class="hljs-keyword">var</span> y0z, v0z = k0z, B0z = <span class="hljs-number">4</span>, x0z = <span class="hljs-string">&quot;&quot;</span>, I0z = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>];    <span class="hljs-keyword">while</span> ( v0z &gt; <span class="hljs-number">0</span>) &#123;        v0z - I0z[B0z] &gt;= <span class="hljs-number">0</span> ? (y0z = <span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">Math</span>.random() * f0z[B0z].length, <span class="hljs-number">10</span>),        x0z += f0z[B0z][y0z], v0z -= I0z[B0z]) : (f0z.splice(B0z, <span class="hljs-number">1</span>),        I0z.splice(B0z, <span class="hljs-number">1</span>), B0z -= <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> x0z;&#125;</code></pre><h4><span id="huo-qu-passtime-zhi">获取 passtime  值</span></h4><p><code>passtime</code>  不用考虑是怎么通过函数获取的，含义就是滑动完成所花费的时间，直接取轨迹的最后一个值即可，这个也和三四代是一样的，获取语句为：<code>var passtime = track[track.length - 1][2]</code>，如下图所示，轨迹的最后一个值时间为 871，<code>passtime</code> 的值同样也为 871。</p><p><img src="https://cdn.itbob.cn/img/article/059/17.png" alt="17"></p><p><img src="https://cdn.itbob.cn/img/article/059/18.png" alt="18"></p><h4><span id="huo-qu-imgload-zhi">获取 imgload 值</span></h4><p><code>imgload</code> 也没啥特别的，从字面意思猜测应该是图片加载耗时，实测直接写死即可，或者整个随机值就行。</p><h4><span id="huo-qu-aa-zhi">获取 aa 值</span></h4><p><code>aa</code> 的值就是 <code>F7z</code>，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/059/19.png" alt="19"></p><p>搜索 <code>F7z</code>，定位到下图所示的地方，向一个方法中传入了一个时间戳：</p><p><img src="https://cdn.itbob.cn/img/article/059/20.png" alt="20"></p><p>跟进去同样是 <code>switch-case</code> 控制流，需要注意的是下图中 <code>c7B[M9r.R8z(781)](M9r.R8z(764), K1z)</code> 的值其实就是轨迹。</p><p><img src="https://cdn.itbob.cn/img/article/059/21.png" alt="21"></p><p>这段控制流还原一下就变成这样了：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getF7z</span>(<span class="hljs-params">track</span>)</span>&#123;    <span class="hljs-keyword">var</span> o5r = <span class="hljs-number">6</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> N1z, X1z = s6z(track), f1z = [], B1z = [], o1z = [], t1z = <span class="hljs-number">0</span>, j1z = X1z.length; t1z &lt; j1z; t1z++)&#123;        <span class="hljs-keyword">if</span> (o5r * (o5r + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span> + <span class="hljs-number">8</span>) &#123;            N1z = u6z(X1z[t1z]),            N1z ? B1z.push(N1z) : (f1z.push(O6z(X1z[t1z][<span class="hljs-number">0</span>])),            B1z.push(O6z(X1z[t1z][<span class="hljs-number">1</span>]))),            o1z.push(O6z(X1z[t1z][<span class="hljs-number">2</span>]));            o5r = o5r &gt;= <span class="hljs-number">17705</span> ? o5r / <span class="hljs-number">3</span> : o5r * <span class="hljs-number">3</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> f1z.join(<span class="hljs-string">&quot;&quot;</span>) + <span class="hljs-string">&quot;!!&quot;</span> + B1z.join(<span class="hljs-string">&quot;&quot;</span>) + <span class="hljs-string">&quot;!!&quot;</span> + o1z.join(<span class="hljs-string">&quot;&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s6z</span>(<span class="hljs-params">F6z</span>)</span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> Y6z, g6z, a6z, E6z = [], D6z = <span class="hljs-number">0</span>, P6z = [], J6z = <span class="hljs-number">0</span>, l6z = F6z.length - <span class="hljs-number">1</span>; J6z &lt; l6z; J6z++) &#123;        Y6z = <span class="hljs-built_in">Math</span>.round(F6z[J6z + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - F6z[J6z][<span class="hljs-number">0</span>]),        g6z = <span class="hljs-built_in">Math</span>.round(F6z[J6z + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - F6z[J6z][<span class="hljs-number">1</span>]),        a6z = <span class="hljs-built_in">Math</span>.round(F6z[J6z + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - F6z[J6z][<span class="hljs-number">2</span>]),        P6z.push([Y6z, g6z, a6z]),        <span class="hljs-number">0</span> == Y6z &amp;&amp; <span class="hljs-number">0</span> == g6z &amp;&amp; <span class="hljs-number">0</span> == a6z || (<span class="hljs-number">0</span> == Y6z &amp;&amp; <span class="hljs-number">0</span> == g6z ? D6z += a6z : (E6z.push([Y6z, g6z, a6z + D6z]), D6z = <span class="hljs-number">0</span>));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> !== D6z &amp;&amp; E6z.push([Y6z, g6z, D6z]), E6z;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">O6z</span>(<span class="hljs-params">r6z</span>)</span>&#123;    <span class="hljs-keyword">var</span> d6z = <span class="hljs-string">&quot;()*,-./0123456789:?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqr&quot;</span>      , m6z = d6z.length      , Z6z = <span class="hljs-string">&quot;&quot;</span>      , H6z = <span class="hljs-built_in">Math</span>.abs(r6z)      , W6z = <span class="hljs-built_in">parseInt</span>(H6z / m6z);    W6z &gt;= m6z &amp;&amp; (W6z = m6z - <span class="hljs-number">1</span>), W6z &amp;&amp; (Z6z = d6z.charAt(W6z)), H6z %= m6z;    <span class="hljs-keyword">var</span> q6z = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">return</span> r6z &lt; <span class="hljs-number">0</span> &amp;&amp; (q6z += <span class="hljs-string">&quot;!&quot;</span>), Z6z &amp;&amp; (q6z += <span class="hljs-string">&quot;$&quot;</span>), q6z + Z6z + d6z.charAt(H6z);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">u6z</span>(<span class="hljs-params">R6z</span>)</span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> z6z = [[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]], h6z = <span class="hljs-number">0</span>, C6z = z6z.length; h6z &lt; C6z; h6z++)&#123;        <span class="hljs-keyword">if</span> (R6z[<span class="hljs-number">0</span>] == z6z[h6z][<span class="hljs-number">0</span>] &amp;&amp; R6z[<span class="hljs-number">1</span>] == z6z[h6z][<span class="hljs-number">1</span>])&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;stuvwxyz~&quot;</span>[h6z]        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>以上只是 <code>F7z</code> 第一次生成的地方，后面还有二次处理，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/059/22.png" alt="22"></p><p>同样跟进去，三个传入的参数分别是第一次生成的 <code>F7z</code>、<code>get.php</code> 请求返回的 <code>c</code> 和 <code>s</code> 参数。</p><p><img src="https://cdn.itbob.cn/img/article/059/23.png" alt="23"></p><p>同样是一段控制流，还原后如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getF7z2</span>(<span class="hljs-params">Q1z, v1z, T1z</span>)</span>&#123;    <span class="hljs-keyword">var</span> i1z, x1z = <span class="hljs-number">0</span>, c1z = Q1z, y1z = v1z[<span class="hljs-number">0</span>], k1z = v1z[<span class="hljs-number">2</span>], L1z = v1z[<span class="hljs-number">4</span>];    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">if</span> (i1z = T1z.substr(x1z, <span class="hljs-number">2</span>))&#123;            x1z += <span class="hljs-number">2</span>;            <span class="hljs-keyword">var</span> n1z = <span class="hljs-built_in">parseInt</span>(i1z, <span class="hljs-number">16</span>)              , M1z = <span class="hljs-built_in">String</span>.fromCharCode(n1z)              , I1z = (y1z * n1z * n1z + k1z * n1z + L1z) % Q1z.length;            c1z = c1z.substr(<span class="hljs-number">0</span>, I1z) + M1z + c1z.substr(I1z);        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> c1z        &#125;    &#125;    <span class="hljs-keyword">return</span> Q1z&#125;</code></pre><p>至此 <code>aa</code> 参数分析完毕！</p><h4><span id="huo-qu-ep-zhi">获取 ep 值</span></h4><p><code>ep</code> 的值就是一个版本号，此处是 <code>&#123;'v': '6.0.9'&#125;</code>，写死即可。</p><p><img src="https://cdn.itbob.cn/img/article/059/24.png" alt="24"></p><h4><span id="huo-qu-rp-zhi">获取 rp 值</span></h4><p>自此 <code>Y7z</code> 的第一步生成就分析完毕了，注意接下来还有一步，向 <code>Y7z</code> 里新增了一个 <code>rp</code> 参数：</p><p><img src="https://cdn.itbob.cn/img/article/059/25.png" alt="25"></p><p>这个值的组成看起来很长，实际上是将 gt、challenge 前 32 位以及 passtime 相加经过 MD5 加密后得到的。</p><pre><code class="hljs javascript">Y7z[<span class="hljs-string">&quot;rp&quot;</span>] = md5(gt + challenge.slice(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>) + passtime)</code></pre><p><img src="https://cdn.itbob.cn/img/article/059/26.png" alt="26"></p><p>上图中 <code>I0B</code> 就是 MD5 方法，跟进去其实是可以看到很多 MD5 特征的，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/059/27.png" alt="27"></p><p>自此 <code>Y7z</code> 的值就搞定了，然后接着前面的看，也就是 <code>q7z</code> 的值，同样和三四代一样的，<code>encrypt</code> 是 AES 加密，<code>Y7z</code> 经过 <code>JSON.stringify()</code> 处理为字符串作为待加密对象，后面是 16 为随机字符串作为 AES 的 Key，注意这里的随机字符串应该和获取 <code>H7z</code> 值时的随机字符串一致，不然是验证不成功的。</p><p><img src="https://cdn.itbob.cn/img/article/059/28.png" alt="28"></p><p>然后下一步就是获取 <code>r7z</code> 的值，将上一步得到的 <code>q7z</code> 经过一个方法进行处理，跟进方法，又是和三四代一样的，熟悉的 <code>res + end</code>，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/059/29.png" alt="29"></p><p>直接扣代码，或者直接使用三代的代码即可：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">$_GJF</span>(<span class="hljs-params">e</span>) </span>&#123;    <span class="hljs-keyword">var</span> t = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789()&quot;</span>;    <span class="hljs-keyword">return</span> e &lt; <span class="hljs-number">0</span> || e &gt;= t[<span class="hljs-string">&quot;length&quot;</span>] ? <span class="hljs-string">&quot;.&quot;</span> : t[<span class="hljs-string">&quot;charAt&quot;</span>](e);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">$_HBO</span>(<span class="hljs-params">e, t</span>) </span>&#123;    <span class="hljs-keyword">return</span> e &gt;&gt; t &amp; <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">$_HCX</span>(<span class="hljs-params">e, o</span>) </span>&#123;    <span class="hljs-keyword">var</span> i = <span class="hljs-built_in">this</span>;    o || (o = i);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> t = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, t</span>) </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>, r = <span class="hljs-number">24</span> - <span class="hljs-number">1</span>; <span class="hljs-number">0</span> &lt;= r; r -= <span class="hljs-number">1</span>)            <span class="hljs-number">1</span> === $_HBO(t, r) &amp;&amp; (n = (n &lt;&lt; <span class="hljs-number">1</span>) + $_HBO(e, r));        <span class="hljs-keyword">return</span> n;    &#125;, n = <span class="hljs-string">&quot;&quot;</span>, r = <span class="hljs-string">&quot;&quot;</span>, s = e.length, a = <span class="hljs-number">0</span>; a &lt; s; a += <span class="hljs-number">3</span>) &#123;        <span class="hljs-keyword">var</span> c;        <span class="hljs-keyword">if</span> (a + <span class="hljs-number">2</span> &lt; s)            c = (e[a] &lt;&lt; <span class="hljs-number">16</span>) + (e[a + <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>) + e[a + <span class="hljs-number">2</span>],            n += $_GJF(t(c, <span class="hljs-number">7274496</span>)) + $_GJF(t(c, <span class="hljs-number">9483264</span>)) + $_GJF(t(c, <span class="hljs-number">19220</span>)) + $_GJF(t(c, <span class="hljs-number">235</span>));        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">var</span> _ = s % <span class="hljs-number">3</span>;            <span class="hljs-number">2</span> == _ ? (c = (e[a] &lt;&lt; <span class="hljs-number">16</span>) + (e[a + <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>),            n += $_GJF(t(c, <span class="hljs-number">7274496</span>)) + $_GJF(t(c, <span class="hljs-number">9483264</span>)) + $_GJF(t(c, <span class="hljs-number">19220</span>)),            r = <span class="hljs-string">&quot;.&quot;</span>) : <span class="hljs-number">1</span> == _ &amp;&amp; (c = e[a] &lt;&lt; <span class="hljs-number">16</span>,            n += $_GJF(t(c, <span class="hljs-number">7274496</span>)) + $_GJF(t(c, <span class="hljs-number">9483264</span>)),            r = <span class="hljs-string">&quot;.&quot;</span> + <span class="hljs-string">&quot;.&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> &#123;        <span class="hljs-string">&quot;res&quot;</span>: n,        <span class="hljs-string">&quot;end&quot;</span>: r    &#125;;&#125;</code></pre><h3><span id="huo-qu-w-zhi">获取 w 值</span></h3><p>自此 <code>w</code> 的就已经出来了，<code>r7z + H7z</code> 即为 <code>w</code> 的值。</p><p><img src="https://cdn.itbob.cn/img/article/059/30.png" alt="30"></p><h2><span id="jie-guo-yan-zheng">结果验证</span></h2><p>测试过掉验证码抓取数据成功：</p><p><img src="https://cdn.itbob.cn/img/article/059/31.png" alt="31"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>云片行为验证，滑动验证码、点选验证码逆向分析</title>
    <link href="https://www.itbob.cn/article/058/"/>
    <id>https://www.itbob.cn/article/058/</id>
    <published>2022-11-26T08:51:00.000Z</published>
    <updated>2022-11-26T08:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#zhua-bao-fen-xi">抓包分析</a></li><li><a href="#ni-xiang-fen-xi">逆向分析</a><ul><li><a href="#tu-pian-jie-kou">图片接口</a></li><li><a href="#yan-zheng-jie-kou">验证接口</a></li></ul></li><li><a href="#jie-guo-yan-zheng">结果验证</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：某片的滑动验证码和点选验证码逆向</li><li>主页：<code>aHR0cHM6Ly93d3cueXVucGlhbi5jb20vcHJvZHVjdC9jYXB0Y2hh</code></li></ul><p><img src="https://cdn.itbob.cn/img/article/058/01.png" alt="01"></p><h2><span id="zhua-bao-fen-xi">抓包分析</span></h2><p>验证码图片获取接口，GET 请求，包含四个参数：<code>cb</code>、<code>i</code>、<code>k</code>、<code>captchaId</code>，有时候可能也会有 <code>token</code> 参数，那是因为不是第一次加载图片，比如刷新图片，会将之前接口的 <code>token</code> 值带上。</p><p><img src="https://cdn.itbob.cn/img/article/058/02.png" alt="02"></p><p>接口返回，如果是滑动验证码，则 <code>bg</code> 是背景图，<code>front</code> 是滑块图，还有个 <code>token</code> 值后续会用到。</p><p><img src="https://cdn.itbob.cn/img/article/058/03.png" alt="03"></p><p>如果是点选验证码，则 <code>captchaImage</code> 是底图，<code>wordsImage</code> 是需要点击的文字，同样的有个 <code>token</code> 值后续会用到。</p><p><img src="https://cdn.itbob.cn/img/article/058/04.png" alt="04"></p><p>验证接口，包含五个参数：<code>cb</code>、<code>i</code>、<code>k</code>、<code>token</code>、<code>captchaId</code>，其中 <code>token</code> 就是获取验证码接口返回的。</p><p><img src="https://cdn.itbob.cn/img/article/058/05.png" alt="05"></p><p><img src="https://cdn.itbob.cn/img/article/058/06.png" alt="06"></p><h2><span id="ni-xiang-fen-xi">逆向分析</span></h2><h3><span id="tu-pian-jie-kou">图片接口</span></h3><p>先来看看获取验证码图片的接口，全局搜索关键字 <code>captchaId</code> 即可定位到 key 为 <code>jsonpRequest</code> 的地方，下图中的 <code>t</code> 就是完整的接口 URL 了：</p><p><img src="https://cdn.itbob.cn/img/article/058/07.png" alt="07"></p><p>往上挨个找，先看看 <code>captchaId</code>，其实就是 <code>this.APP_ID</code>，多次刷新你会发现，对于滑块来讲，是定值 <code>974cd565f11545b6a5006d10dc324281</code>，对于点选来讲，是定值 <code>e1e7be036f9242c7aed023438af66f46</code>，这两个值在一个 JS 里是写死的，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/058/08.png" alt="08"></p><p><img src="https://cdn.itbob.cn/img/article/058/09.png" alt="09"></p><p>再往上看，<code>HOSTS</code> 啥的是定值就不用说了，<code>cb</code> 就是 <code>r</code>，<code>i</code> 就是 <code>a.i</code>，<code>k</code> 就是 <code>a.k</code>，通过 <code>concat()</code> 方法连接起来，所以只需要搞定 <code>r</code> 和 <code>a</code> 的值就行了，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/058/10.png" alt="10"></p><p><code>a</code> 的值是通过 <code>encrypt(e)</code> 得到的，<code>e</code> 里面有 <code>fp</code>、<code>address</code>、<code>yp_riddler_id</code> 等值，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/058/11.png" alt="11"></p><p>先看看这个 <code>encrypt</code> 方法，最终返回的是 <code>i</code> 和 <code>k</code>，瞧瞧这熟悉的 <code>iv</code>、<code>parse</code>，一看就是 AES、DES 之类的，试一下就知道了，或者跟进 <code>lt.a.encrypt()</code> 看看他的源码，对比一下标准算法里的源码，就可以发现是 AES，<code>k</code> 就很明显了，RSA 加密，公钥啥的一搜就有。</p><p><img src="https://cdn.itbob.cn/img/article/058/12.png" alt="12"></p><p>然后往上有个 <code>yp_riddler_id</code>，貌似是从 cookie 中拿的，直接搜索这个关键字，可以找到其设置值的地方，就是一个 UUID，其中有个 <code>window.performance.now()</code> 方法，其作用是返回一个当前页面执行的时间的时间戳，用来精确计算程序执行时间，在 node 实现方法如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> perf = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;perf_hooks&#x27;</span>);performance = perf.performance.now()<span class="hljs-built_in">console</span>.log(performance);</code></pre><p><img src="https://cdn.itbob.cn/img/article/058/13.png" alt="13"></p><p><img src="https://cdn.itbob.cn/img/article/058/14.png" alt="14"></p><p>然后再往上有个 <code>e.fp = this.fingerprint</code>，这里用到的应该是一个指纹库：<a href="https://github.com/fingerprintjs/fingerprintjs">https://github.com/fingerprintjs/fingerprintjs</a> ，感兴趣的可以了解一下，同一个浏览器得到的指纹是一样的，这里固定即可。</p><p><img src="https://cdn.itbob.cn/img/article/058/15.png" alt="15"></p><p>然后就是 <code>r</code> 的值，<code>preAdd</code> 方法，直接扣就行了</p><p><img src="https://cdn.itbob.cn/img/article/058/16.png" alt="16"></p><p><img src="https://cdn.itbob.cn/img/article/058/17.png" alt="17"></p><p>然后这个 <code>e</code> 的值，再传到 <code>jsonpRequest</code> 之前就已经有一些值了，所以我们还得往前跟栈看看：</p><p><img src="https://cdn.itbob.cn/img/article/058/18.png" alt="18"></p><p>来到 <code>getCaptcha</code> 这里，没啥特别的，扣就完事儿了，其中有个 <code>browserInfo</code> 是浏览器的一些东西，copy 下来就行了。</p><p><img src="https://cdn.itbob.cn/img/article/058/19.png" alt="19"></p><h3><span id="yan-zheng-jie-kou">验证接口</span></h3><p>验证接口最后也是走的 <code>jsonpRequest</code>，和前面的获取图片接口类似，不同之处就是传入的 <code>e</code> 里面包含的值不一样，先来看看滑块：</p><p><img src="https://cdn.itbob.cn/img/article/058/20.png" alt="20"></p><p>包含 <code>distanceX</code> 和 <code>points</code>，很明显 <code>points</code> 就是轨迹了，再往前跟看看，如下图所示，我们只需要 <code>i</code> 和 <code>r</code> 参数就行了，参数是一些图片高宽，固定就行，<code>offsetX</code> 是滑动的距离。</p><p><img src="https://cdn.itbob.cn/img/article/058/21.png" alt="21"></p><p>主要看看这个轨迹 <code>i = this.reducePoints()</code>，跟进 <code>reducePoints()</code> 方法里，<code>this.position</code> 是轨迹信息，这个方法对轨迹做了一些处理再返回的，直接把逻辑扣下来即可。</p><p><img src="https://cdn.itbob.cn/img/article/058/22.png" alt="22"></p><p>滑块就到这儿了，再来看看点选验证，同样的还是 <code>jsonpRequest</code>，传入的 <code>e</code> 包含了三个点的坐标。</p><p><img src="https://cdn.itbob.cn/img/article/058/23.png" alt="23"></p><p>同样往上跟栈，这里的 <code>this.position</code> 才是真实坐标，后面每个坐标分别对 x 和 y 与图片的宽和高进行相除，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/058/24.png" alt="24"></p><h2><span id="jie-guo-yan-zheng">结果验证</span></h2><p><img src="https://cdn.itbob.cn/img/article/058/25.png" alt="25"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>安居客滑动验证码逆向分析</title>
    <link href="https://www.itbob.cn/article/057/"/>
    <id>https://www.itbob.cn/article/057/</id>
    <published>2022-11-08T09:35:00.000Z</published>
    <updated>2022-11-26T08:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#zhua-bao-fen-xi">抓包分析</a></li><li><a href="#dinfo-sheng-cheng">dInfo 生成</a></li><li><a href="#getinfotp-jie-mi">getInfoTp 解密</a></li><li><a href="#data-sheng-cheng">data 生成</a></li><li><a href="#gui-ji-chu-li">轨迹处理</a></li><li><a href="#jie-guo-yan-zheng">结果验证</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：安某客滑动验证码逆向分析</li><li>主页：<code>aHR0cHM6Ly93d3cuYW5qdWtlLmNvbS9jYXB0Y2hhLXZlcmlmeS8/Y2FsbGJhY2s9c2hpZWxkJmZyb209YW50aXNwYW0=</code></li></ul><p><img src="https://cdn.itbob.cn/img/article/057/01.png" alt="01"></p><h2><span id="zhua-bao-fen-xi">抓包分析</span></h2><p>首页请求，有个初始化函数，其中有个 <code>sessionId</code> 后续会用到。</p><p><img src="https://cdn.itbob.cn/img/article/057/02.png" alt="02"></p><p>然后有个 <code>getInfoTp</code> 的请求，<code>Form Data</code> 里有个 <code>dInfo</code> 是加密参数，返回值里 <code>info</code> 也是加密的，包含了图片信息，返回值 <code>responseId</code> 在后续的请求也会用到。</p><p><img src="https://cdn.itbob.cn/img/article/057/03.png" alt="03"></p><p>滑动之后，有个 <code>checkInfoTp</code> 请求，<code>Form Data</code> 里有个 <code>data</code> 是加密参数，包含了轨迹信息，返回值 <code>message</code> 可以看到是否校验成功。</p><p><img src="https://cdn.itbob.cn/img/article/057/04.png" alt="04"></p><p>整体流程就是：请求首页获取 <code>sessionId</code>，请求 <code>getInfoTp</code> 获取图片信息和 <code>responseId</code>，请求 <code>checkInfoTp</code> 校验是否成功，中间涉及到 <code>dInfo</code> 和 <code>data</code> 两个加密参数，以及 <code>getInfoTp</code> 返回得到的 <code>info</code> 的解密。</p><h2><span id="dinfo-sheng-cheng">dInfo 生成</span></h2><p>先来看 <code>getInfoTp</code> 请求的 <code>dInfo</code> 参数，直接搜索可定位，刷新断下，大致就可以看出是 AES 加密，传入了 <code>sessionId</code> 和一个 <code>_taN()</code> 函数的返回值：</p><p><img src="https://cdn.itbob.cn/img/article/057/05.png" alt="05"></p><p><code>_taN()</code> 函数是一些 URL，UA 之类的信息，可以写死：</p><p><img src="https://cdn.itbob.cn/img/article/057/06.png" alt="06"></p><p>往里跟就可以看到 AES 算法了：</p><p><img src="https://cdn.itbob.cn/img/article/057/07.png" alt="07"></p><p>这里简简单单扣一下，JavaScript 代码如下：</p><pre><code class="hljs javascript"><span class="hljs-comment">/* ==================================</span><span class="hljs-comment"># @Time    : 2021-12-14</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: ajk.js</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ================================== */</span><span class="hljs-keyword">var</span> CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto-js&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AESEncrypt</span>(<span class="hljs-params">_cRV, _2undefinedp</span>) </span>&#123;    _2undefinedp = _2undefinedp.split(<span class="hljs-string">&quot;&quot;</span>).reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_PUi, _JrX, _JP9</span>) </span>&#123;        <span class="hljs-keyword">return</span> _JP9 % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? _PUi + <span class="hljs-string">&quot;&quot;</span> : _PUi + _JrX;    &#125;, <span class="hljs-string">&quot;&quot;</span>);    _2undefinedp = CryptoJS.enc.Utf8.parse(_2undefinedp);    _cRV = <span class="hljs-string">&quot;string&quot;</span> == <span class="hljs-keyword">typeof</span> _cRV ? _cRV : <span class="hljs-built_in">JSON</span>.stringify(_cRV);    _cRV = CryptoJS.AES.encrypt(_cRV, _2undefinedp, &#123;        <span class="hljs-attr">iv</span>: _2undefinedp,        <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,        <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7    &#125;);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">encodeURIComponent</span>(_cRV.toString())&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">u</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> &#123;        <span class="hljs-string">&quot;sdkv&quot;</span>: <span class="hljs-string">&quot;3.0.1&quot;</span>,        <span class="hljs-string">&quot;busurl&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com/captcha-verify/?callback=shield&amp;from=antispam&quot;</span>,        <span class="hljs-string">&quot;useragent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36&quot;</span>,        <span class="hljs-string">&quot;clienttype&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDInfo</span>(<span class="hljs-params">sessionId</span>)</span>&#123;    <span class="hljs-keyword">return</span> AESEncrypt(u(), sessionId)&#125;<span class="hljs-comment">// 测试样例</span><span class="hljs-keyword">var</span> sessionId = <span class="hljs-string">&quot;a8b339ec0c26459598786fee1cce8dc2&quot;</span><span class="hljs-built_in">console</span>.log(getDInfo(sessionId))</code></pre><p>这段逻辑也可以用 Python 来实现，关键代码如下（脱敏处理，不能直接运行）：</p><pre><code class="hljs python"><span class="hljs-comment"># ==================================</span><span class="hljs-comment"># --*-- coding: utf-8 --*--</span><span class="hljs-comment"># @Time    : 2021-12-14</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: ajk.py</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ==================================</span><span class="hljs-keyword">import</span> json<span class="hljs-keyword">import</span> base64<span class="hljs-keyword">import</span> requests<span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<span class="hljs-keyword">from</span> loguru <span class="hljs-keyword">import</span> logger<span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> quote_plus<span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<span class="hljs-keyword">from</span> Crypto.Util.Padding <span class="hljs-keyword">import</span> pad, unpad<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AESAlgorithm</span>:</span><span class="hljs-meta">    @staticmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encrypt</span>(<span class="hljs-params">aes_key_iv, text</span>):</span>        <span class="hljs-string">&quot;&quot;&quot; 对明文进行加密 &quot;&quot;&quot;</span>        cipher = AES.new(key=<span class="hljs-built_in">bytes</span>(aes_key_iv, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>), mode=AES.MODE_CBC, iv=<span class="hljs-built_in">bytes</span>(aes_key_iv, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>))        result = base64.b64encode(cipher.encrypt(pad(text.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), <span class="hljs-number">16</span>))).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)        result = quote_plus(result)        <span class="hljs-keyword">return</span> result<span class="hljs-meta">    @staticmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decrypt</span>(<span class="hljs-params">aes_key_iv, text</span>):</span>        <span class="hljs-string">&quot;&quot;&quot; 对密文进行解密 &quot;&quot;&quot;</span>        cipher = AES.new(key=<span class="hljs-built_in">bytes</span>(aes_key_iv, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>), mode=AES.MODE_CBC, iv=<span class="hljs-built_in">bytes</span>(aes_key_iv, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>))        result = unpad(cipher.decrypt(base64.b64decode(text)), <span class="hljs-number">16</span>).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)        <span class="hljs-keyword">return</span> result<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AJKSlide</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, index_url, user_agent</span>):</span>        self.aes = AESAlgorithm()        self.index_url = index_url        self.user_agent = user_agent        self.headers = &#123;<span class="hljs-string">&quot;user-agent&quot;</span>: self.user_agent&#125;    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_session_id</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot; 获取 sessionId &quot;&quot;&quot;</span>        response = requests.get(url=self.index_url, headers=self.headers).text        session_id = etree.HTML(response).xpath(<span class="hljs-string">&quot;//input[@name=&#x27;sessionId&#x27;]/@value&quot;</span>)[<span class="hljs-number">0</span>]        logger.info(<span class="hljs-string">f&quot;sessionId ==&gt; <span class="hljs-subst">&#123;session_id&#125;</span>&quot;</span>)        <span class="hljs-keyword">return</span> session_id<span class="hljs-meta">    @staticmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_aes_key_iv</span>(<span class="hljs-params">session_id</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;设置 AES key 和 iv&quot;&quot;&quot;</span>        aes_key_iv = <span class="hljs-string">&#x27;&#x27;</span>        <span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(session_id):            <span class="hljs-keyword">if</span> index % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:                aes_key_iv += value        logger.info(<span class="hljs-string">f&quot;处理 sessionId 获取 aes key iv ==&gt; <span class="hljs-subst">&#123;aes_key_iv&#125;</span>&quot;</span>)        <span class="hljs-keyword">return</span> aes_key_iv    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_d_info</span>(<span class="hljs-params">self, aes_key_iv</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;获取 dInfo&quot;&quot;&quot;</span>        sdk_info = &#123;            <span class="hljs-string">&quot;sdkv&quot;</span>: <span class="hljs-string">&quot;3.0.1&quot;</span>,            <span class="hljs-string">&quot;busurl&quot;</span>: self.index_url,            <span class="hljs-string">&quot;useragent&quot;</span>: self.user_agent,            <span class="hljs-string">&quot;clienttype&quot;</span>: <span class="hljs-number">1</span>        &#125;        d_info = self.aes.encrypt(aes_key_iv, json.dumps(sdk_info))        logger.info(<span class="hljs-string">f&#x27;dInfo ==&gt; <span class="hljs-subst">&#123;d_info&#125;</span>&#x27;</span>)        <span class="hljs-keyword">return</span> d_info    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, session_id=<span class="hljs-literal">None</span></span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> session_id:            session_id = self.get_session_id()        aes_key_iv = self.get_aes_key_iv(session_id)        self.get_d_info(aes_key_iv)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    UA = <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&quot;</span>    index_url_ = <span class="hljs-string">&quot;https://www.脱敏处理.com/captcha-verify/?callback=shield&amp;from=antispam&quot;</span>    ajk_slide = AJKSlide(index_url_, UA)    ajk_slide.run()</code></pre><h2><span id="getinfotp-jie-mi">getInfoTp 解密</span></h2><p><code>getInfoTp</code> 这个接口返回的 <code>info</code> 的值是加密的，前面我们已经知道用到了 AES 加密算法，这里可以直接猜测也是用的的 AES 来解密的，找到 <code>AESDecrypt</code> 这个方法，下个断点，刷新发现断下之后传入了两个参数，第一个正是 <code>info</code> 的内容，第二个则是 <code>sessionId</code>。</p><p><img src="https://cdn.itbob.cn/img/article/057/08.png" alt="08"></p><p><img src="https://cdn.itbob.cn/img/article/057/09.png" alt="09"></p><p>解密结果可以看到滑块的图片地址等信息：</p><p><img src="https://cdn.itbob.cn/img/article/057/10.png" alt="10"></p><h2><span id="data-sheng-cheng">data 生成</span></h2><p>接下来就是 <code>checkInfoTp</code> 提交验证了，要搞清楚提交的 <code>data</code> 是什么东西，同样搜索打断点，如下图所示 <code>_5DD</code> 就是 <code>data</code> 值，传过来的。</p><p><img src="https://cdn.itbob.cn/img/article/057/11.png" alt="11"></p><p>往上跟栈，可以看到 <code>_Ug0</code> 里面有个 <code>track</code> 参数，这明显就是轨迹了，同样最后的结果经过了 AES 加密。</p><p><img src="https://cdn.itbob.cn/img/article/057/12.png" alt="12"></p><p>再往上跟，可以看到 <code>_Ug0</code> 由三个参数组成，<code>x</code> 是水平滑动的距离，<code>track</code> 是轨迹，<code>p</code> 是定值。</p><p><img src="https://cdn.itbob.cn/img/article/057/13.png" alt="13"></p><h2><span id="gui-ji-chu-li">轨迹处理</span></h2><p>轨迹生成前，得先识别缺口得到要滑动的距离，方式有很多，比如 <code>OpenCV</code>、开源的 <code>ddddocr</code>，或者直接打码平台都行，这里唯一要注意的一点就是图片是有缩放的，原始尺寸 <code>480 × 270 px</code> 渲染后的尺寸 <code>280 × 158 px</code>，比例大概是 <code>1:0.5833333333333333</code>，可以先将图片进行缩放后再识别，也可以先识别距离后再将距离进行缩放。</p><p><img src="https://cdn.itbob.cn/img/article/057/14.png" alt="14"></p><p>轨迹的处理，该站点校验并不太严格，所以可以自己写一下，关于滑块的轨迹处理，主要有缩放法、本地轨迹库、根据一些函数来生成轨迹，如缓动函数、贝塞尔曲线等，以后再单独写一篇文章来介绍，本例中可以使用缩放法，先采集一条正常的，手动滑出来的轨迹，然后根据识别出的实际距离和样本轨迹中的距离相比，得到一个比值，然后将样本中的 x 值和时间值都做一个对应的缩放，生成新的轨迹，主要代码如下：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_track</span>(<span class="hljs-params">distance</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;生成轨迹，样本距离为 126&quot;&quot;&quot;</span>    ratio = distance / <span class="hljs-number">126</span>    new_track = <span class="hljs-string">&quot;&quot;</span>    base_track = <span class="hljs-string">&quot;29,11,0|29,11,11|29,11,26|33,11,56|34,11,66|36,11,67|39,11,76|41,11,83|43,11,86|46,11,92|49,11,98|50,11,102|52,11,106|53,11,111|55,11,116|57,11,118|59,11,123|60,11,126|62,11,132|64,12,134|65,12,138|66,12,142|68,12,148|69,12,151|70,13,155|71,13,158|72,13,164|74,13,166|75,13,170|76,14,174|77,14,180|79,14,182|81,14,186|82,14,196|84,14,198|86,14,207|87,15,212|89,15,219|90,15,223|92,15,230|93,15,234|94,15,239|95,15,243|98,15,246|100,15,250|102,15,260|105,15,262|106,15,266|108,15,270|109,16,276|111,16,278|113,16,283|115,16,286|117,16,291|118,16,294|119,16,298|121,16,302|123,16,309|124,16,311|125,16,315|126,16,319|129,16,324|130,16,327|131,16,331|132,16,334|132,16,388|132,16,522|133,16,566|134,16,574|135,16,575|136,16,594|137,16,620|138,16,625|139,16,652|140,16,657|141,17,676|141,18,680|142,18,684|143,18,688|144,18,716|145,18,724|146,18,796|147,19,828|148,19,860|149,19,888|149,19,890|150,19,916|151,20,932|152,20,936|152,20,1021|153,20,1150|154,20,1152|155,20,1236|155,20,1388|155,20,1522|155,20,1717|&quot;</span>    base_track = base_track.split(<span class="hljs-string">&quot;|&quot;</span>)[:-<span class="hljs-number">1</span>]    <span class="hljs-keyword">for</span> track <span class="hljs-keyword">in</span> base_track:        t = track.split(<span class="hljs-string">&quot;,&quot;</span>)        new_track += <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(<span class="hljs-built_in">int</span>(t[<span class="hljs-number">0</span>]) * ratio)) + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-built_in">str</span>(t[<span class="hljs-number">1</span>]) + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(<span class="hljs-built_in">int</span>(t[<span class="hljs-number">2</span>]) * ratio)) + <span class="hljs-string">&quot;|&quot;</span>        logger.info(<span class="hljs-string">f&quot;new_track ==&gt; <span class="hljs-subst">&#123;new_track&#125;</span>&quot;</span>)        <span class="hljs-keyword">return</span> new_track</code></pre><h2><span id="jie-guo-yan-zheng">结果验证</span></h2><p>整个过程比较简单，验证成功。</p><p><img src="https://cdn.itbob.cn/img/article/057/15.png" alt="15"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>抖音短视频 X-Bogus 逆向分析，JSVMP 纯算法还原</title>
    <link href="https://www.itbob.cn/article/056/"/>
    <id>https://www.itbob.cn/article/056/</id>
    <published>2022-10-16T11:00:00.000Z</published>
    <updated>2022-11-02T16:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/javascript_reverse.png" alt="javascript_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#shi-me-shi-jsvmp">什么是 JSVMP？</a></li><li><a href="#jsvmp-you-na-xie-xue-xi-zi-liao">JSVMP 有哪些学习资料？</a></li><li><a href="#jsvmp-ni-xiang-fang-fa-you-na-xie">JSVMP 逆向方法有哪些？</a></li><li><a href="#zhua-bao-qing-kuang">抓包情况</a></li><li><a href="#ni-xiang-fen-xi">逆向分析</a></li><li><a href="#cha-zhuang-fen-xi">插桩分析</a></li><li><a href="#28-ge-zi-fu-sheng-cheng-luo-ji">28个字符生成逻辑</a></li><li><a href="#luan-ma-zi-fu-chuan-sheng-cheng-luo-ji">乱码字符串生成逻辑</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：某音短视频网页端用户信息接口 X-Bogus 参数</li><li>接口：<code>aHR0cHM6Ly93d3cuZG91eWluLmNvbS9hd2VtZS92MS93ZWIvdXNlci9wcm9maWxlL290aGVyLw==</code></li></ul><h2><span id="shi-me-shi-jsvmp">什么是 JSVMP？</span></h2><p>JSVMP 全称 Virtual Machine based code Protection for JavaScript，即 JS 代码虚拟化保护方案。</p><p>JSVMP 的概念最早应该是由西北大学2015级硕士研究生匡开圆，在其2018年的学位论文中提出的，论文标题为：《基于 WebAssembly 的 JavaScript 代码虚拟化保护方法研究与实现》，同年还申请了国家专利，专利名称：《一种基于前端字节码技术的 JavaScript 虚拟化保护方法》，网上可以直接搜到，也可<a href="https://pan.baidu.com/s/1KJWJOgB8JeQx11p6ZJZBUg?pwd=6666">点击此链接</a>（密码6666），免费获取原版高清无水印的论文和专利。本文就简单介绍一下 JSVMP，想要详细了解，当然还是建议去读一下这篇论文。</p><p><img src="https://cdn.itbob.cn/img/article/056/01.png" alt="01"></p><p>JSVMP 的核心是在 JavaScript 代码保护过程中引入代码虚拟化思想，实现源代码的虚拟化过程，将目标代码转换成自定义的字节码，这些字节码只有特殊的解释器才能识别，隐藏目标代码的关键逻辑。在匡开圆的论文中，利用 WebAssembly 技术实现了特殊的虚拟解释器，通过编译隐藏解释器的执行逻辑。JSVMP 的保护流程如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/02.png" alt="02"></p><p>一个完整的 JSVMP 保护系统，大致的架构应该是这样子的：服务器端读取 JavaScript 代码 —&gt; 词法分析 —&gt; 语法分析 —&gt; 生成AST语法树 —&gt; 生成私有指令 —&gt; 生成对应私有解释器，将私有指令加密与私有解释器发送给浏览器，然后一边解释，一边执行。</p><p><img src="https://cdn.itbob.cn/img/article/056/03.png" alt="03"></p><h2><span id="jsvmp-you-na-xie-xue-xi-zi-liao">JSVMP 有哪些学习资料？</span></h2><p>除了匡开圆的论文以外，还有以下文章也值得学习：</p><ul><li><a href="https://mp.weixin.qq.com/s/YDx5Dr-HDfAm-sAqeWW0qg">H5应用加固防破解-js虚拟机保护方案浅谈</a></li><li><a href="https://blog.csdn.net/w2sft/article/details/120843310">JS加密？用虚拟机opcode保护JS源码</a></li><li><a href="https://bbs.pediy.com/thread-261414.htm">给&quot;某音&quot;的js虚拟机写一个编译器</a></li></ul><h2><span id="jsvmp-ni-xiang-fang-fa-you-na-xie">JSVMP 逆向方法有哪些？</span></h2><p>就目前来讲，JSVMP 的逆向方法有三种（自动化不算）：RPC 远程调用，补环境，日志断点还原算法，其中日志断点也称为插桩，找到关键位置，输出关键参数的日志信息，从结果往上倒推生成逻辑，以达到算法还原的目的，RPC 技术以前写过文章，补环境的方式以后有时间再写，本文主要介绍如何使用插桩来还原算法。</p><h2><span id="zhua-bao-qing-kuang">抓包情况</span></h2><p>随便来到某个博主主页，抓包后搜索可发现一个接口，返回的是 JSON 数据，里面包含了博主某音号，认证信息、签名，关注、粉丝、获赞等，请求 <code>Query String Parameters</code> 里包含了一个 <code>X-Bogus</code> 参数，每次请求会改变，此外还有 <code>sec_user_id</code> 是博主主页 URL 后面那一串，<code>webid</code> 直接请求主页返回内容里就有，<code>msToken</code> 与 cookie 有关，清除 cookie 访问，就没这个参数了，实测该接口不验证 <code>webid</code> 和 <code>msToken</code>，直接置空即可。</p><p><img src="https://cdn.itbob.cn/img/article/056/04.png" alt="04"></p><p><img src="https://cdn.itbob.cn/img/article/056/05.png" alt="05"></p><h2><span id="ni-xiang-fen-xi">逆向分析</span></h2><p>这条请求是 XHR 请求，所以直接下个 XHR 断点，当 URL 中包含 <code>X-Bogus</code> 参数时就断下：</p><p><img src="https://cdn.itbob.cn/img/article/056/06.png" alt="06"></p><p><img src="https://cdn.itbob.cn/img/article/056/07.png" alt="07"></p><p>往前跟栈，来到一个叫 webmssdk.js 的 JS 文件，这里就是生成参数的主要 JS 逻辑了，也就是 JSVMP，整体上做了一个混淆，这里可以使用 AST 来解混淆，以前同样也写过 AST 的文章，这里还原混淆不是重点，咱们直接使用 V 佬的插件 <a href="https://github.com/cilame/v_jstools">v_jstools</a> 来还原：</p><p><img src="https://cdn.itbob.cn/img/article/056/08.png" alt="08"></p><p>还原后使用浏览器的 Overrides 替换功能将 webmssdk.js 替换掉，往上跟栈，如下图所示，到 W 这里就已经生成了 <code>X-Bogus</code> 了，<code>this.openArgs[1]</code> 就是携带了 <code>X-Bogus</code> 的完整 URL，仔细观察这段代码，有很多三元表达式，当 M 的值为 15 时，就会走到这段逻辑，U 的值生成之后，有一个 <code>S[C] = U</code> 的操作。</p><p><img src="https://cdn.itbob.cn/img/article/056/09.png" alt="09"></p><p>再往上看代码，S 是一个数组，单步调试的话会发现代码会一直走这个 <code>if-else</code> 的逻辑，几乎每一步都有 S 数组的参与，不断往里面增删改查值，for 循环里面的 I 值，决定着后续 if 语句的走向，这里也就是插桩的关键所在，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/10.png" alt="10"></p><h2><span id="cha-zhuang-fen-xi">插桩分析</span></h2><p>大的 for 循环和 if-else 逻辑有两个地方，为了保证最后的日志更加详细完整，在这两个地方都下个日志断点（右键 <code>Add logpoint</code>），断点内容为：</p><pre><code class="hljs text">&quot;位置 1&quot;, &quot;索引I&quot;, I, &quot;索引A&quot;, A, &quot;值S: &quot;, JSON.stringify(S, function(key, value) &#123;if (value == window) &#123;return undefined&#125; return value&#125;)&quot;位置 2&quot;, &quot;索引I&quot;, I, &quot;索引A&quot;, A, &quot;值S: &quot;, JSON.stringify(S, function(key, value) &#123;if (value == window) &#123;return undefined&#125; return value&#125;)</code></pre><p><img src="https://cdn.itbob.cn/img/article/056/11.png" alt="11"></p><p>插桩输出 S 的时候为什么要写这么长一串呢？首先 <code>JSON.stringify()</code> 方法的作用是将 JavaScript 值转换为 JSON 字符串，基础语法是 <code>JSON.stringify(value[, replacer [, space]])</code>，如果不将其转换成 JSON，那么 S 的值，输出可能是这样的：<code>[empty, Array(26), 1, Array(0)]</code>，你看不到 Array 数组里面具体的值，该方法有个可选参数 replacer，如果 replacer 为函数，则 <code>JSON.stringify</code> 将调用该函数，并传入每个成员的键和值，在函数中可以对成员进行处理，最后返回处理后的值，如果此函数返回 undefined，则排除该成员，举个例子：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj1 = &#123;<span class="hljs-attr">key1</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-attr">key2</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeValue</span>(<span class="hljs-params">key, value</span>) </span>&#123;    <span class="hljs-keyword">if</span> (value == <span class="hljs-string">&#x27;value2&#x27;</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ITBOB&#x27;</span>    &#125; <span class="hljs-keyword">return</span> value&#125;<span class="hljs-keyword">var</span> obj2 = <span class="hljs-built_in">JSON</span>.stringify(obj1, changeValue)<span class="hljs-built_in">console</span>.log(obj2)<span class="hljs-comment">// 输出：&#123;&quot;key1&quot;:&quot;value1&quot;,&quot;key2&quot;:&quot;ITBOB&quot;&#125;</span></code></pre><p>上面的代码中 <code>JSON.stringify</code> 传入了一个函数，当 <code>value</code> 为 <code>value2</code> 的时候就将其替换成字符串 <code>ITBOB</code>，接下来我们演示一下当 <code>value</code> 为 <code>window</code> 时，会发生什么：</p><p><img src="https://cdn.itbob.cn/img/article/056/12.png" alt="12"></p><p>根据报错我们可以看到这里由于循环引用导致异常，要知道在插桩的时候，如果插桩内容有报错，就会导致不能正常输出日志，这样就会缺失一部分日志，这种情况我们就可以加个函数处理一下，让 value 为 window 的时候，JSON 处理的时候函数返回 undefined，排除该成员，其他成员正常输出，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/13.png" alt="13"></p><p>以上就是日志断点为什么要这样写的原因，下好日志断点后，注意前面我们下的 XHR 断点不要取消，然后刷新网页，控制台就开始打印日志了，因为有很多 XHR 请求都包含了 X-Bogus，如果你 XHR 断点取消了，日志就会一直打印直到卡死。日志输出完毕后，大约有8千多条，搜索就能看到最后一条日志 X-Bogus 已经生成了：</p><p><img src="https://cdn.itbob.cn/img/article/056/14.png" alt="14"></p><h2><span id="28-ge-zi-fu-sheng-cheng-luo-ji">28个字符生成逻辑</span></h2><p>直接在打印的日志页面右键 <code>save as..</code>，将日志导出到本地进行分析。<code>X-Bogus</code> 由28个字符组成，现在要做的就是看 <code>DFSzswVOAATANH89SMHZqF9WX7n6</code> 这28个字符是怎么来的，在日志里搜索这个字符串，找到第一次出现的地方，观察一下可以发现，他是逐个字符依次生成的，如下图红框所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/15.png" alt="15"></p><p>在上图中，第8511行，X-Bogus 字符串的下一个元素是 null，到了第8512行，就生成数字6了，那么在这两步之间就是数字6的生成逻辑，这个时候我们看第8511行的日志断点是 <code>位置 2 索引I 16 索引A 738</code>，那么我们回到原网页，在位置2，下一个条件断点（右键 <code>Add conditional breakpoint</code>），当 <code>I == 16 &amp;&amp; A == 738 &amp;&amp; S[7] &amp;&amp; S[7] == 21</code> 时就断下。之所以要加 <code>S[7]</code> 是因为 <code>索引I 16 索引A 738</code> 的位置有很多，在日志里搜一下大概有40多个，多加个限制条件就可以缩小范围，当然有可能加了多个条件仍然有多个位置都满足，这就需要你细心观察了，通过断点断下的时候看看控制台前面输出的日志来判断是不是我们想要的位置。这也是一个小细节，一定要找准位置，千万别搞混了。（提示一下，像我这样下断点的话，一般情况下会断下两次，第二次是满足要求的）</p><p>（注意：本文描述的日志的多少行、断点的具体位置、变量的具体值，可能会有所变化，以你的实际情况为准，但思路是一样的）</p><p><img src="https://cdn.itbob.cn/img/article/056/16.png" alt="16"></p><p>刷新网页，断下之后开始单步跟，来到下图所示的地方：</p><p><img src="https://cdn.itbob.cn/img/article/056/17.png" alt="17"></p><p>到这里之后，就不要下一步了，再下一步有可能整个语句就执行完毕了，其中的细节你看不到，所以这里我们在控制台挨个输入看看：</p><p><img src="https://cdn.itbob.cn/img/article/056/18.png" alt="18"></p><p>可以看到实际上的逻辑就是返回指定位置的字符，y 的值就是 <code>S[5]</code>，m 的值就是 <code>S[4]</code>，经过多次调试发现 m 的值是固定的，M 就是 <code>charAt()</code> 方法，我们再看看我们本地的日志，<code>S[5]</code> 的值为 <code>[20]</code>，<code>charAt()</code> 取值出来就是6，逻辑完全正确。</p><p><img src="https://cdn.itbob.cn/img/article/056/19.png" alt="19"></p><p>现在我们还需要知道这个20是怎么来的，继续往上看，找到20第一次出现的地方，在第8510行，那么我们就要使其在上一步断下，也就是第8509行，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/20.png" alt="20"></p><p>第8509行的索引信息为 <code>位置 2 索引I 47 索引A 730</code>，同样的下条件断点观察怎么生成的：</p><p><img src="https://cdn.itbob.cn/img/article/056/21.png" alt="21"></p><p><img src="https://cdn.itbob.cn/img/article/056/22.png" alt="22"></p><p>可以看到逻辑是 <code>S[5] &amp; S[6]</code>，再看我们本地 <code>S[5] = 5647508</code>、<code>S[6] = 63 </code>，<code>5647508 &amp; 63 = 20</code>，逻辑正确，20就是这么来的。接下来又开始找 <code>5647508</code> 和 <code>63</code> 是怎么生成的，同样在生成的上一步，也就是8508行下个条件断点，这行的索引为 <code>位置 2 索引I 72 索引A 726</code>。</p><p><img src="https://cdn.itbob.cn/img/article/056/23.png" alt="23"></p><p><img src="https://cdn.itbob.cn/img/article/056/24.png" alt="24"></p><p><img src="https://cdn.itbob.cn/img/article/056/25.png" alt="25"></p><p>可以看到 63 是直接 <code>q[A]</code> 生成的，q 是一个大数组，A 就是索引为 726，q 这个大数组怎么来的先不用管，而 <code>5647508</code> 这个大数字，搜索一下，发现有很多，咱们也先放着，到这里咱们可以总结一下最后一个字符的生成步骤如下：</p><pre><code class="hljs text">short_str = &quot;Dkdpgh4ZKsQB80/Mfvw36XI1R25-WUAlEi7NLboqYTOPuzmFjJnryx9HVGcaStCe=&quot;q[726] = 635647508 &amp; 63 = 20short_str.charAt(20) = &#x27;6&#x27;</code></pre><p>然后接日志着往上看，看倒数第二个字母是怎么来的，方法也和前面演示的一样，不断往前下条件断点，这里就不再逐步演示了，当你找完四个数字后，就可以开始看 <code>5647508</code> 这个大数字怎么来的了，搜索这个数字，同样的找到第一次出现的地方，在其前一步下条件断点，步骤捋出来会发现有一个乱码字符串经过 <code>charCodeAt()</code> 操作，再加上一些位运算得到的，乱码字符串类似下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/26.png" alt="26"></p><p>至于这个乱码字符串怎么来的，我们后面再讲，到这里先总结一下，首先我们的 <code>X-Bogus = DFSz swVO AATA NH89 SMHZ qF9W X7n6</code>，将其看成每四个为一组，之所以这么分组，是因为你经过分析后会发现，每一组的每一个字符生成流程都是一样的，这里以最后两组为例，流程大致如下：</p><pre><code class="hljs in">short_str = &quot;Dkdpgh4ZKsQB80/Mfvw36XI1R25-WUAlEi7NLboqYTOPuzmFjJnryx9HVGcaStCe=&quot;X-Bogus = DFSz swVO AATA NH89 SMHZ qF9W X7n6============== 第6组【qF9W】==============&quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;.charCodeAt(15) = 158q[342] = 16158 &lt;&lt; 16 = 10354688&quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;.charCodeAt(16) = 253q[408] = 8253 &lt;&lt; 8 = 6476810354688 | 64768 = 10419456&quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;.charCodeAt(17) = 156156 | 10419456 = 10419612q[520] = 1651507210419612 &amp; 16515072 = 10223616q[532] = 1810223616 &gt;&gt; 18 = 39short_str.charAt(39) = &#x27;q&#x27;q[590]= 25804810419612 &amp; 258048 = 192512q[602] = 12192512 &gt;&gt; 12 = 47short_str.charAt(47) = &#x27;F&#x27;q[660] = 403210419612 &amp; 4032 = 3456q[668] = 63456 &gt;&gt; 6 = 54short_str.charAt(54) = &#x27;9&#x27;q[726] = 6310419612 &amp; 63 = 28short_str.charAt(28) = &#x27;W&#x27;============== 第7组【X7n6】==============&quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;.charCodeAt(18) = 86q[342] = 1686 &lt;&lt; 16 = 5636096&quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;.charCodeAt(19) = 44q[408] = 844 &lt;&lt; 8 = 112645636096 | 11264 = 5647360&quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;.charCodeAt(20) = 148148 | 5647360 = 5647508q[520] = 165150725647508 &amp; 16515072 = 5505024q[532] = 185505024 &gt;&gt; 18 = 21short_str.charAt(21) = &#x27;X&#x27;q[590] = 2580485647508 &amp; 258048 = 139264q[602] = 12139264 &gt;&gt; 12 = 34short_str.charAt(34) = &#x27;7&#x27;q[660] = 40325647508 &amp; 4032 = 3200q[668] = 63200 &gt;&gt; 6 = 50short_str.charAt(50) = &#x27;n&#x27;q[726] = 635647508 &amp; 63 = 20short_str.charAt(20) = &#x27;6&#x27;</code></pre><p>将流程对比一下就可以发现，每个步骤 q 里面的取值都是一样的，这个可以直接写死，不同之处就在于最开始的 <code>charCodeAt()</code> 操作，也就是返回乱码字符串指定位置字符的 Unicode 编码，第7组依次是 18、19、20，第6组依次是15、16、17，以此类推，第1组刚好是0、1、2，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/27.png" alt="27"></p><p>每一组的逻辑都是一样的，我们就可以写个通用方法，依次生成七组字符串，最后拼接成完整的 <code>X-Bogus</code>，代码如下：（乱码字符串的生成后文会讲）</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getXBogus</span>(<span class="hljs-params">originalString</span>)</span>&#123;    <span class="hljs-comment">// 生成乱码字符串</span>    <span class="hljs-keyword">var</span> garbledString = getGarbledString(originalString);    <span class="hljs-keyword">var</span> XBogus = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-comment">// 依次生成七组字符串</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">20</span>; i += <span class="hljs-number">3</span>) &#123;        <span class="hljs-keyword">var</span> charCodeAtNum0 = garbledString.charCodeAt(i);        <span class="hljs-keyword">var</span> charCodeAtNum1 = garbledString.charCodeAt(i + <span class="hljs-number">1</span>);        <span class="hljs-keyword">var</span> charCodeAtNum2 = garbledString.charCodeAt(i + <span class="hljs-number">2</span>);        <span class="hljs-keyword">var</span> baseNum = charCodeAtNum2 | charCodeAtNum1 &lt;&lt; <span class="hljs-number">8</span> | charCodeAtNum0 &lt;&lt; <span class="hljs-number">16</span>;        <span class="hljs-comment">// 依次生成四个字符</span>        <span class="hljs-keyword">var</span> str1 = short_str[(baseNum &amp; <span class="hljs-number">16515072</span>) &gt;&gt; <span class="hljs-number">18</span>];        <span class="hljs-keyword">var</span> str2 = short_str[(baseNum &amp; <span class="hljs-number">258048</span>) &gt;&gt; <span class="hljs-number">12</span>];        <span class="hljs-keyword">var</span> str3 = short_str[(baseNum &amp; <span class="hljs-number">4032</span>) &gt;&gt; <span class="hljs-number">6</span>];        <span class="hljs-keyword">var</span> str4 = short_str[baseNum &amp; <span class="hljs-number">63</span>];        XBogus += str1 + str2 + str3 + str4;    &#125;    <span class="hljs-keyword">return</span> XBogus;&#125;</code></pre><h2><span id="luan-ma-zi-fu-chuan-sheng-cheng-luo-ji">乱码字符串生成逻辑</span></h2><p>在进行下一步之前，我们要注意两点：</p><ul><li><p>文章演示有些变量前后不对应，因为每次插桩的值都是会变的，看流程就行了，流程是正确的；</p></li><li><p>我们日志输出是经过 <code>JSON.stringify</code> 处理了的，有些步骤是向某个函数传入乱码字符串进行处理，你会发现处理后的结果和日志不一致，这是正常的。</p></li></ul><p>乱码字符串的生成相对来说稍微复杂一点，但思路仍然一样，这里就不一一截图展示了，直接用日志描述一下关键步骤，注意以下日志是正向的步骤，就不逆着推了，建议自己先逆着把流程走一走，再来看这个步骤就看得懂了。</p><p><strong>Step1</strong>：首先对 URL 后面的参数，也就是 <code>Query String Parameters</code> 进行两次 MD5、两次转 <code>Uint8Array</code> 处理，最后得到的 <code>Uint8Array</code> 对象在后面的步骤中用得到，步骤如下：</p><pre><code class="hljs text">位置 1 索引I 4  索引A 134：将 URL 后面的参数进行 MD5 加密得到字符串位置 1 索引I 16 索引A 460：将上一步的字符串转换为 Uint8Array 对象位置 1 索引I 4  索引A 134：将上一步的 Uint8Array 对象进行 MD5 加密，得到字符串位置 1 索引I 29 索引A 472：将上一步的字符串转换为 Uint8Array 对象</code></pre><p>上述步骤中，我们将最终得到的结果命名为 <code>uint8Array</code>，关键代码实现如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> md5 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;md5&quot;</span>);<span class="hljs-comment">// 字符串转换为 Uint8Array 对象，缺失的变量自行补齐</span>_0x5960a2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> c = a.length &gt;&gt; <span class="hljs-number">1</span>, e = c &lt;&lt; <span class="hljs-number">1</span>, b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(c), d = <span class="hljs-number">0</span>, f = <span class="hljs-number">0</span>; f &lt; e; ) &#123;        b[d++] = _0x511f86[a.charCodeAt(f++)] &lt;&lt; <span class="hljs-number">4</span> | _0x511f86[a.charCodeAt(f++)];    &#125;    <span class="hljs-keyword">return</span> b;&#125;<span class="hljs-comment">// originalString: URL 后面的原始参数</span><span class="hljs-keyword">var</span> uint8Array = _0x5960a2(md5(_0x5960a2(md5(originalString))));</code></pre><p><strong>Step2</strong>：生成两个大数，一个是时间戳，我们称之为 <code>fixedString1</code>，另一个调用某个方法生成，我们称之为 <code>fixedString2</code>。</p><pre><code class="hljs text">fixedString1位置 1 索引I 43 索引A 806：1663385262240 / 1000 = 1663385262.24fixedString2位置 1 索引I 16 索引A 834：M.apply(null, []) = 536919696</code></pre><p>上述步骤中，M 对应以下方法，缺失的方法自行补齐（其中 <code>_0x229792</code> 是创建 <code>canvas</code>）：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x2996f8</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> _0x4b3b53 || (_0xb55f3e.perf ? -<span class="hljs-number">1</span> : (_0x4b3b53 = _0x229792(<span class="hljs-number">3735928559</span>), _0x4b3b53));    &#125; <span class="hljs-keyword">catch</span> (a) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p><strong>Step3</strong>：先后生成两个数组，我们称之为 <code>array1</code>、<code>array2</code>，<code>array2</code> 就是由 <code>array1</code> 的元素位置变换后得来的，严格来讲，<code>array1</code> 不是一个完整的数组，而是一个个数字，这一点可以在日志中体现出来，为了方便我们就直接将其视为一个数组，两个数组都有19个元素，步骤如下：</p><pre><code class="hljs text">array1[0] 至 array1[3] 为定值array1[4]位置 1 索引I 25 索引A 946：uint8Array[14]array1[5]位置 1 索引I 25 索引A 970：uint8Array[15]array1[6] 至 array1[7] 与 post 提交的 form data 有关array1[8] 至 array1[9] 与 ua 有关，与 Step1 类似array1[10]位置 1 索引I 52 索引A 1090：fixedString1 &gt;&gt; 24 = 99位置 1 索引I 47 索引A 1098：99 &amp; 255 = 99array1[11]位置 1 索引I 52 索引A 1122：fixedString1 &gt;&gt; 16 = 25417位置 1 索引I 47 索引A 1130：25417 &amp; 255 = 73array1[12]位置 1 索引I 52 索引A 1154：fixedString1 &gt;&gt; 8 = 6506755位置 1 索引I 47 索引A 1162：6506755 &amp; 255 = 3array1[13]位置 1 索引I 52 索引A 1186：fixedString1 &gt;&gt; 0 = 241位置 1 索引I 47 索引A 1194：241 &amp; 255 = 241array1[14]位置 1 索引I 52 索引A 1218：fixedString2 &gt;&gt; 24 = 32位置 1 索引I 47 索引A 1226：32 &amp; 255 = 32array1[15]位置 1 索引I 52 索引A 1250：fixedString2 &gt;&gt; 16 = 8192位置 1 索引I 47 索引A 1258：8192 &amp; 255 = 0array1[16]位置 1 索引I 52 索引A 1282：fixedString2 &gt;&gt; 8 = 2097342位置 1 索引I 47 索引A 1290：2097342 &amp; 255 = 190array1[17]位置 1 索引I 52 索引A 1314：fixedString2 &gt;&gt; 0 = 536919696位置 1 索引I 47 索引A 1322：536919696 &amp; 255 = 144array1[18]位置 1 索引I 27 索引A 1352：array1.reduce(function(a, b) &#123; return a ^ b; &#125;); = 100array1 完整值如下位置 1 索引I 27 索引A 1538：64,1.00390625,1,8,9,185,69,63,74,125,99,73,3,241,32,0,190,144,100array2 由 array1 元素交换位置而来：array2 = [array1[0], array1[2], array1[4], array1[6], array1[8], array1[10], array1[12], array1[14], array1[16], array1[18], array1[1], array1[3], array1[5], array1[7], array1[9], array1[11], array1[13], array1[15], array1[17]]array2 完整值如下array2 = [64,1,9,69,74,99,3,32,190,100,1.00390625,8,185,63,125,73,241,0,144]</code></pre><p><strong>Step4</strong>：将 Step3 得到的 array2 经过转换得到乱码字符串，步骤如下：</p><pre><code class="hljs text">位置 1 索引I 16 索引A 1706：_0x2f2740.apply(null, array2) = &quot;@\u0000\u0001\u000eíxE?\u0016c%&gt;® \u0000¾ó&quot;位置 1 索引I 16 索引A 1760：_0x46fa4c.apply(null, [&quot;ÿ&quot;, &quot;@\u0000\u0001\u000e\t¹E?J&#125;cI\u0003ñ \u0000¾d&quot;]) = &quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;位置 1 索引I 16 索引A 1812：_0x2b6720.apply(null, [2, 255, &quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;]) = &quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;</code></pre><p>其中用到的函数：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x2f2740</span>(<span class="hljs-params">a, c, e, b, d, f, t, n, o, i, r, _, x, u, s, l, v, h, g</span>) </span>&#123;    <span class="hljs-keyword">let</span> w = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">19</span>);    <span class="hljs-keyword">return</span> w[<span class="hljs-number">0</span>] = a,    w[<span class="hljs-number">1</span>] = r,    w[<span class="hljs-number">2</span>] = c,    w[<span class="hljs-number">3</span>] = _,    w[<span class="hljs-number">4</span>] = e,    w[<span class="hljs-number">5</span>] = x,    w[<span class="hljs-number">6</span>] = b,    w[<span class="hljs-number">7</span>] = u,    w[<span class="hljs-number">8</span>] = d,    w[<span class="hljs-number">9</span>] = s,    w[<span class="hljs-number">10</span>] = f,    w[<span class="hljs-number">11</span>] = l,    w[<span class="hljs-number">12</span>] = t,    w[<span class="hljs-number">13</span>] = v,    w[<span class="hljs-number">14</span>] = n,    w[<span class="hljs-number">15</span>] = h,    w[<span class="hljs-number">16</span>] = o,    w[<span class="hljs-number">17</span>] = g,    w[<span class="hljs-number">18</span>] = i,    <span class="hljs-built_in">String</span>.fromCharCode.apply(<span class="hljs-literal">null</span>, w);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x46fa4c</span>(<span class="hljs-params">a, c</span>) </span>&#123;    <span class="hljs-keyword">let</span> e, b = [], d = <span class="hljs-number">0</span>, f = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">256</span>; a++) &#123;        b[a] = a;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c = <span class="hljs-number">0</span>; c &lt; <span class="hljs-number">256</span>; c++) &#123;        d = (d + b[c] + a.charCodeAt(c % a.length)) % <span class="hljs-number">256</span>,        e = b[c],        b[c] = b[d],        b[d] = e;    &#125;    <span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>;    d = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>; a &lt; c.length; a++) &#123;        t = (t + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>,        d = (d + b[t]) % <span class="hljs-number">256</span>,        e = b[t],        b[t] = b[d],        b[d] = e,        f += <span class="hljs-built_in">String</span>.fromCharCode(c.charCodeAt(a) ^ b[(b[t] + b[d]) % <span class="hljs-number">256</span>]);    &#125;    <span class="hljs-keyword">return</span> f;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x583250</span>(<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode(a);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x2b6720</span>(<span class="hljs-params">a, c, e</span>) </span>&#123;    <span class="hljs-keyword">return</span> _0x583250(a) + _0x583250(c) + e;&#125;</code></pre><p>自此，整个流程就走完了。可以用 JavaScript 来实现整个算法，用 Python 也可以，完善代码后随便请求一个博主主页，简单解析几个数据，输出正常：</p><p><img src="https://cdn.itbob.cn/img/article/056/28.png" alt="28"></p><p><img src="https://cdn.itbob.cn/img/article/056/29.png" alt="29"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/javascript_reverse.png&quot; alt=&quot;javascript_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>APP 逆向，Frida 初体验，root 检测与加密字符串定位</title>
    <link href="https://www.itbob.cn/article/055/"/>
    <id>https://www.itbob.cn/article/055/</id>
    <published>2022-09-12T10:00:00.000Z</published>
    <updated>2022-11-02T16:46:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/app_reverse.png" alt="app_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#an-zhuang-adb">安装 ADB</a></li><li><a href="#an-zhuang-frida">安装 Frida</a></li><li><a href="#ni-xiang-fen-xi">逆向分析</a><ul><li><a href="#jie-he-python-shi-yong">结合 Python 使用</a></li><li><a href="#frida-ming-ling">frida 命令</a></li></ul></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>设备：Google Pixel4，Android 10，已 root</li><li>APP：UnCrackable-Level1.apk（来源：<a href="https://github.com/OWASP/owasp-mastg/tree/master/Crackmes">https://github.com/OWASP/owasp-mastg/tree/master/Crackmes</a> ）</li><li>APP 检测了 root，如果手机 root 了，会强制退出 APP，过了 root 检测后，还需要输入一个字符串进行校验。</li></ul><h2><span id="an-zhuang-adb">安装 ADB</span></h2><p>adb（Android Debug Bridge）即安卓调试桥，安装后可以在电脑上与手机进行交互，Android Studio 等工具里面会自带 adb，有时候我们并不想下载这么大的工具，所以这里介绍一下 Android SDK Platform-Tools，它是 Android SDK 的一个组件，它包括与 Android 平台交互的工具，主要是 adb 和 fastboot，官方下载地址：<a href="https://developer.android.com/studio/releases/platform-tools">https://developer.android.com/studio/releases/platform-tools</a> ，下载完成后将该目录添加到环境变量，USB 连接手机，手机上设置允许 USB 调试，使用命令 <code>adb version</code> 可查看版本信息，<code>adb devices</code> 可以查看当前连接的设备，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/055/01.png" alt="01"></p><h2><span id="an-zhuang-frida">安装 Frida</span></h2><p>Frida 是一款基于 Python + JavaScript 的 Hook 与调试框架，首先电脑端使用命令 <code>pip install frida-tools</code> 安装 frida 模块（此命令默认会安装最新版的 frida 和 frida-tools，如），然后下载 frida-server，下载地址：<a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a></p><p>frida-server 要根据你电脑端安装的 frida 版本和手机的 CPU 架构来选择对应的，使用命令 <code>frida --version</code> 可以查看 frida 版本，使用命令 <code>adb shell</code> 进入手机，输入 <code>getprop ro.product.cpu.abi</code> 查看 CPU 架构，如下图所示，我这里 frida 是 15.2.2 版本，手机 CPU 为 arm64，所以我下载的是 <code>frida-server-15.2.2-android-arm64.xz</code>。</p><p>某些 Android 低版本使用高版本 frida 可能有问题，遇到问题可尝试降低 frida 版本来解决。</p><p><img src="https://cdn.itbob.cn/img/article/055/02.png" alt="02"></p><p><img src="https://cdn.itbob.cn/img/article/055/03.png" alt="03"></p><p>将下载好的 frida-server 使用 <code>adb push</code> 命令传到手机的 <code>/data/local/tmp/</code> 目录下，并给予 777 读、写、执行的权限，然后直接运行 frida-server，正常不会有任何输出，当然也可以使用 &amp; 等方式让其在后台运行。</p><p><img src="https://cdn.itbob.cn/img/article/055/04.png" alt="04"></p><p>然后另开一个 cmd 使用命令 <code>frida-ps -U </code> 可查看手机进程，有输出则正常。</p><p><img src="https://cdn.itbob.cn/img/article/055/05.png" alt="05"></p><h2><span id="ni-xiang-fen-xi">逆向分析</span></h2><p>使用 <code>adb install</code> 命令安装 UnCrackable-Level1.apk，打开该 APP，会检测到 root，出现 <code>Root detected!</code> 的提示，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/055/06.png" alt="06"></p><p>使用 JEB、JADX、GDA 等工具反编译 apk，直接搜索关键字 <code>Root detected!</code> 即可定位到检测的地方：</p><p><img src="https://cdn.itbob.cn/img/article/055/07.png" alt="07"></p><p>可以看到图中有三个检测方法 <code>c.a()</code>、<code>c.b()</code>、<code>c.c()</code>，其中一个返回为真，则弹出 <code>Root detected!</code>，然后前面还有一个 <code>onClick</code> 方法，如果点击 OK 按钮，则触发 <code>System.exit(0);</code>，即退出 APP，先点进三个检测方法看看：</p><p><code>a()</code> 方法通过检测 Android 系统环境变量中是否有 su 文件来判断是否被 root；</p><p><code>b()</code> 方法通过检测 <code>Build.TAGS</code> 中是否包含字符串 <code>test-keys</code> 来判断是否被 root；</p><p><code>c()</code> 方法通过检测指定路径下是否包含指定的文件来判断是否被 root。</p><p><img src="https://cdn.itbob.cn/img/article/055/08.png" alt="08"></p><p>所以我们这里就有多种过掉检测的方法：</p><p>方法一：Hook 三个检测方法，让它们都返回 false，不再执行后续的 a 方法，就不会退出 APP 了：</p><pre><code class="hljs javascript">Java.perform(    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook begin&quot;</span>)        <span class="hljs-keyword">var</span> vantagePoint = Java.use(<span class="hljs-string">&quot;sg.vantagepoint.a.c&quot;</span>)        vantagePoint.a.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook vantagepoint.a.c.a&quot;</span>)            <span class="hljs-built_in">this</span>.a();            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        vantagePoint.b.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook vantagepoint.a.c.b&quot;</span>)            <span class="hljs-built_in">this</span>.b();            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        vantagePoint.c.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook vantagepoint.a.c.c&quot;</span>)            <span class="hljs-built_in">this</span>.c();            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;)</code></pre><p>方法二：Hook <code>a()</code> 方法，置空，什么都不做，不弹出对话框，也不退出 APP：</p><pre><code class="hljs javascript">Java.perform(    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook begin&quot;</span>)        <span class="hljs-keyword">var</span> mainActivity = Java.use(<span class="hljs-string">&quot;sg.vantagepoint.uncrackable1.MainActivity&quot;</span>);        mainActivity.a.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook mainActivity.a&quot;</span>)        &#125;    &#125;)</code></pre><p>方法三：Hook <code>onClick()</code> 方法，点击 OK 后不让其退出 APP，注意这里是内部类的 Hook 写法：</p><pre><code class="hljs javascript">Java.perform(    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook begin&quot;</span>)        <span class="hljs-keyword">var</span> mainActivity$<span class="hljs-number">1</span> = Java.use(<span class="hljs-string">&quot;sg.vantagepoint.uncrackable1.MainActivity$1&quot;</span>);        mainActivity$<span class="hljs-number">1.</span>onClick.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook mainActivity$1.onClick&quot;</span>)        &#125;    &#125;)</code></pre><p>方法四：Hook <code>System.exit()</code> 方法，点击 OK 后不让其退出 APP：</p><pre><code class="hljs javascript">Java.perform(    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook begin&quot;</span>)        <span class="hljs-keyword">var</span> javaSystem = Java.use(<span class="hljs-string">&quot;java.lang.System&quot;</span>);        javaSystem.exit.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook system.exit&quot;</span>)        &#125;    &#125;)</code></pre><p>root 检测过掉之后，APP 还要输入一个字符串，输入错误会提示 <code>That's not it. Try again.</code>，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/055/09.png" alt="09"></p><p>分析 Java 代码，有一个 <code>if-else</code> 判断，obj 为输入的字符串，<code>a.a(obj)</code> 判断为真，就表示输入正确。</p><p><img src="https://cdn.itbob.cn/img/article/055/10.png" alt="10"></p><p>跟到 <code>a.a()</code> 方法，可以看到 <code>bArr</code> 是内置的字符串，通过 <code>equals()</code> 方法比较输入的 <code>str</code> 是否和 <code>bArr</code> 相等：</p><p><img src="https://cdn.itbob.cn/img/article/055/11.png" alt="11"></p><p><code>bArr</code> 的值，主要经过 <code>sg.vantagepoint.a.a.a()</code> 方法处理后得到，继续跟进去可以发现是 AES 加密算法：</p><p><img src="https://cdn.itbob.cn/img/article/055/12.png" alt="12"></p><p>这里就可以直接 Hook <code>sg.vantagepoint.a.a.a()</code>，直接拿到加密后的值，也就是我们要的正确字符串，由于这里返回的是 ASCII 码，所以我们还需要在 JavaScript 代码中使用 <code>String.fromCharCode()</code> 将其转换成正常字符，Hook 代码如下：</p><pre><code class="hljs javascript">Java.perform(    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">var</span> cryptoAES = Java.use(<span class="hljs-string">&quot;sg.vantagepoint.a.a&quot;</span>);        cryptoAES.a.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bArr, bArr2</span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook cryptoAES&quot;</span>)            <span class="hljs-keyword">var</span> secret = <span class="hljs-string">&quot;&quot;</span>;            <span class="hljs-keyword">var</span> decryptValue = <span class="hljs-built_in">this</span>.a(bArr, bArr2);            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] DecryptValue:&quot;</span>, decryptValue)            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i &lt; decryptValue.length; i++)&#123;              secret += <span class="hljs-built_in">String</span>.fromCharCode(decryptValue[i]);            &#125;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Secret:&quot;</span>, secret)            <span class="hljs-keyword">return</span> decryptValue;        &#125;    &#125;)</code></pre><p>运行 Hook 脚本有两种方式，一是结合 Python 使用，二是直接通过 frida 命令使用脚本，注入 Hook 代码也有个时机问题，有时候需要在 APP 启动就开始 Hook，有时候可以等 APP 启动加载完毕了再 Hook，本例中，过 root 检测的时候，如果采用第一、二种方法，即 Hook 三个检测方法或者 a 方法，那就需要在 APP 启动的时候就 Hook，如果采用第三、四种方法，即 Hook  <code>onClick()</code> 或者 <code>System.exit()</code> 方法，那么等 APP 启动了再 Hook 也可以。</p><h3><span id="jie-he-python-shi-yong">结合 Python 使用</span></h3><p>首先来看一下结合 Python 怎么使用，JavaScript 代码如下（frida-hook.js）：</p><pre><code class="hljs javascript"><span class="hljs-comment">/* ==================================</span><span class="hljs-comment"># @Time    : 2022-08-29</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: frida-hook.js</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ================================== */</span>Java.perform(    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook begin&quot;</span>)        <span class="hljs-comment">// 方法一：Hook 三个检测方法，让它们都返回 false，不再执行后续的 a 方法，就不会退出 APP 了</span>        <span class="hljs-comment">// var vantagePoint = Java.use(&quot;sg.vantagepoint.a.c&quot;)</span>        <span class="hljs-comment">// vantagePoint.a.implementation = function()&#123;</span>        <span class="hljs-comment">//     console.log(&quot;[*] Hook vantagepoint.a.c.a&quot;)</span>        <span class="hljs-comment">//     this.a();</span>        <span class="hljs-comment">//     return false;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// vantagePoint.b.implementation = function()&#123;</span>        <span class="hljs-comment">//     console.log(&quot;[*] Hook vantagepoint.a.c.b&quot;)</span>        <span class="hljs-comment">//     this.b();</span>        <span class="hljs-comment">//     return false;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// vantagePoint.c.implementation = function()&#123;</span>        <span class="hljs-comment">//     console.log(&quot;[*] Hook vantagepoint.a.c.c&quot;)</span>        <span class="hljs-comment">//     this.c();</span>        <span class="hljs-comment">//     return false;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// 方法二：Hook a() 方法，置空，什么都不做，不弹出对话框，也不退出 APP</span>        <span class="hljs-comment">// var mainActivity = Java.use(&quot;sg.vantagepoint.uncrackable1.MainActivity&quot;);</span>        <span class="hljs-comment">// mainActivity.a.implementation = function()&#123;</span>        <span class="hljs-comment">//    console.log(&quot;[*] Hook mainActivity.a&quot;)</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// 方法三：Hook onClick() 方法，点击 OK 后不让其退出 APP</span>        <span class="hljs-comment">// var mainActivity$1 = Java.use(&quot;sg.vantagepoint.uncrackable1.MainActivity$1&quot;);</span>        <span class="hljs-comment">// mainActivity$1.onClick.implementation = function()&#123;</span>        <span class="hljs-comment">//     console.log(&quot;[*] Hook mainActivity$1.onClick&quot;)</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// 方法四：Hook System.exit 方法，点击 OK 后不让其退出 APP</span>        <span class="hljs-keyword">var</span> javaSystem = Java.use(<span class="hljs-string">&quot;java.lang.System&quot;</span>);        javaSystem.exit.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook system.exit&quot;</span>)        &#125;        <span class="hljs-keyword">var</span> cryptoAES = Java.use(<span class="hljs-string">&quot;sg.vantagepoint.a.a&quot;</span>);        cryptoAES.a.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bArr, bArr2</span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook cryptoAES&quot;</span>)            <span class="hljs-keyword">var</span> secret = <span class="hljs-string">&quot;&quot;</span>;            <span class="hljs-keyword">var</span> decryptValue = <span class="hljs-built_in">this</span>.a(bArr, bArr2);            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] DecryptValue:&quot;</span>, decryptValue)            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i &lt; decryptValue.length; i++)&#123;              secret += <span class="hljs-built_in">String</span>.fromCharCode(decryptValue[i]);            &#125;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Secret:&quot;</span>, secret)            <span class="hljs-keyword">return</span> decryptValue;        &#125;    &#125;)</code></pre><p>Python 代码如下（<a href="http://frida-hook.py">frida-hook.py</a>）：</p><pre><code class="hljs python"><span class="hljs-comment"># ==================================</span><span class="hljs-comment"># --*-- coding: utf-8 --*--</span><span class="hljs-comment"># @Time    : 2022-08-29</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: frida-hook.py</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ==================================</span><span class="hljs-keyword">import</span> sys<span class="hljs-keyword">import</span> frida<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_message</span>(<span class="hljs-params">message, data</span>):</span>    <span class="hljs-keyword">if</span> message[<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;send&#x27;</span>:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[*] &#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(message[<span class="hljs-string">&#x27;payload&#x27;</span>]))    <span class="hljs-keyword">else</span>:        <span class="hljs-built_in">print</span>(message)<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./frida-hook.js&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> fp:    hook_string = fp.read()<span class="hljs-comment"># 方式一：attach 模式，已经启动的 APP</span>process = frida.get_usb_device(-<span class="hljs-number">1</span>).attach(<span class="hljs-string">&quot;Uncrackable1&quot;</span>)script = process.create_script(hook_string)script.on(<span class="hljs-string">&quot;message&quot;</span>, on_message)script.load()sys.stdin.read()<span class="hljs-comment"># 方式二，spawn 模式，重启 APP</span><span class="hljs-comment"># device = frida.get_usb_device(-1)</span><span class="hljs-comment"># pid = device.spawn([&quot;owasp.mstg.uncrackable1&quot;])</span><span class="hljs-comment"># process = device.attach(pid)</span><span class="hljs-comment"># script = process.create_script(hook_string)</span><span class="hljs-comment"># script.on(&quot;message&quot;, on_message)</span><span class="hljs-comment"># script.load()</span><span class="hljs-comment"># device.resume(pid)</span><span class="hljs-comment"># sys.stdin.read()</span></code></pre><p>Python 代码中，attach 模式 Hook 已经存在的进程，spawn 模式会重启 APP，启动一个新的进程并挂起，在启动的同时注入 frida 代码，适用于在进程启动前的一些 Hook，attach 模式传入的是 APP 名称，spawn 模式传入的是 APP 包名，查看 APP 名称和包名的方法有很多，这里介绍两个 frida 命令，<code>frida-ps -Uai</code>：列出安装的程序，<code>frida-ps -Ua</code>：列出正在运行中的程序，如下图所示，本例中 <code>Uncrackable1</code> 就是 APP 名称，<code>owasp.mstg.uncrackable1</code> 就是包名：</p><p><img src="https://cdn.itbob.cn/img/article/055/13.png" alt="13"></p><p>运行 Python 代码，注意手机端也要启动 frida-server，过掉 root 检测后，先随便输入字符串，点击 VERIFY 就会 Hook 到正确的字符串为 <code>I want to believe</code>，再次输入正确的字符串，即可验证成功。</p><p><img src="https://cdn.itbob.cn/img/article/055/14.png" alt="14"></p><h3><span id="frida-ming-ling">frida 命令</span></h3><p>不使用 Python，也可以直接使用 frida 命令来实现，和前面 Python  一样也有两种模式，同样的一个是 APP 名一个是包名：</p><p><code>frida -U Uncrackable1 -l .\frida-hook.js</code>：attach 模式，APP 启动后注入 frida 代码；</p><p><code>frida -U -f owasp.mstg.uncrackable1 -l .\frida-hook.js --no-pause</code>：spawn 模式，重启 APP，启动的同时注入 frida 代码。</p><p><img src="https://cdn.itbob.cn/img/article/055/15.png" alt="15"></p><p>至此，我们完美绕过了 root 检测，并成功找到了正确的字符串。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/app_reverse.png&quot; alt=&quot;app_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;!-</summary>
      
    
    
    
    <category term="APP 逆向实战" scheme="https://www.itbob.cn/categories/APP-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="APP 逆向实战" scheme="https://www.itbob.cn/tags/APP-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>人均瑞数系列，瑞数 5 代 JS 逆向分析</title>
    <link href="https://www.itbob.cn/article/054/"/>
    <id>https://www.itbob.cn/article/054/</id>
    <published>2022-09-01T05:00:00.000Z</published>
    <updated>2022-11-02T15:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/javascript_reverse.png" alt="javascript_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#qian-yan">前言</a></li><li><a href="#cookie-ru-kou-ding-wei">Cookie 入口定位</a></li><li><a href="#vm-dai-ma-yi-ji-ts-bian-liang-huo-qu">VM 代码以及 $_ts 变量获取</a></li><li><a href="#shan-yong-watch-gen-zong-gong-neng">善用 Watch 跟踪功能</a></li><li><a href="#gen-zhan-fen-xi">跟栈分析</a></li><li><a href="#hou-zhui-sheng-cheng">后缀生成</a></li><li><a href="#zhi-wen-sheng-cheng">指纹生成</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="qian-yan">前言</span></h2><p><img src="https://cdn.itbob.cn/img/article/054/01.png" alt="01"></p><p>瑞数动态安全 Botgate（机器人防火墙）以“动态安全”技术为核心，通过动态封装、动态验证、动态混淆、动态令牌等技术对服务器网页底层代码持续动态变换，增加服务器行为的“不可预测性”，实现了从用户端到服务器端的全方位“主动防护”，为各类 Web、HTML5 提供强大的安全保护。</p><p>在往期的文章<a href="https://www.itbob.cn/article/053/">《国内 Web 防护天花板，瑞数 4 代 JS 逆向分析》</a>中，详细介绍了瑞数的特征、如何区分不同版本、瑞数的代码结构以及各自的作用，本文就不再赘述了，不了解的同志可以先去看看之前的文章。</p><h2><span id="cookie-ru-kou-ding-wei">Cookie 入口定位</span></h2><p>本文案例中瑞数 5 代网站为：<code>aHR0cHM6Ly93d3cubm1wYS5nb3YuY24vZGF0YXNlYXJjaC9ob21lLWluZGV4Lmh0bWw=</code></p><p>定位 Cookie，首选 Hook 来的最快，通过 Fiddler 插件、油猴脚本、浏览器插件等方式注入以下 Hook 代码：</p><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 严谨模式 检查所有错误</span><span class="hljs-meta">    &#x27;use strict&#x27;</span>;    <span class="hljs-comment">// document 为要hook的对象 这里是hook的cookie</span>    <span class="hljs-keyword">var</span> cookieTemp = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">document</span>, <span class="hljs-string">&#x27;cookie&#x27;</span>, &#123;        <span class="hljs-comment">// hook set方法也就是赋值的方法 </span>        <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;                <span class="hljs-comment">// 这样就可以快速给下面这个代码行下断点</span>                <span class="hljs-comment">// 从而快速定位设置cookie的代码</span>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hook捕获到cookie设置-&gt;&#x27;</span>, val);                <span class="hljs-keyword">debugger</span>;                cookieTemp = val;                <span class="hljs-keyword">return</span> val;        &#125;,        <span class="hljs-comment">// hook get 方法也就是取值的方法 </span>        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;            <span class="hljs-keyword">return</span> cookieTemp;        &#125;    &#125;);&#125;)();</code></pre><p>断下之后往上跟栈，可以看到组装 Cookie 后赋值给 <code>document.cookie</code> 的代码，类似如下结构：</p><p><img src="https://cdn.itbob.cn/img/article/054/02.png" alt="02"></p><p>继续往上跟栈，和4代瑞数类似，<code>(772, 1)</code> 的位置是入口，4代有一次生成假 cookie 的过程，5代就没有了，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/054/03.png" alt="03"></p><p>再往前跟栈，来到首页代码，这里就是我们熟悉的 call 位置了，图中 <code>_$ug</code> 实际上是 eval 方法，传入的第一个参数 <code>_$Cs</code> 是 Window 对象，第二个对象 <code>_$Dm</code> 是我们前面看到的 VM 虚拟机中的 IIFE 自执行代码。</p><p><img src="https://cdn.itbob.cn/img/article/054/04.png" alt="04"></p><h2><span id="vm-dai-ma-yi-ji-ts-bian-liang-huo-qu">VM 代码以及 $_ts 变量获取</span></h2><p>获取 VM 代码和 <code>$_ts</code> 变量是第一步，和4代类似，复制外链 JS（例如 <code>fjtvkgf7LVI2.a670748.js</code>）的代码和 412 页面的自执行代码到文件，本地直接运行即可，需要轻度补一下环境，缺啥补啥，大致补一下 window、location、document 就行了，补的具体内容可以直接在浏览器控制台使用 <code>copy()</code> 命令复制过来，然后 VM 代码我们就可以直接 Hook eval 的方式得到，这里 <code>$_ts</code> 变量的获取和4代有点儿区别，4代我们的做法是运行完代码后直接取 <code>window.$_ts</code> 就行了，5代运行完代码后会有一个清空 <code>$_ts</code> 的操作，可以自己跟栈看一下逻辑，要么把清空的逻辑删了，要么定义一个全局变量，然后直接在 call 的地方将 <code>$_ts</code> 的值导出来：</p><p><img src="https://cdn.itbob.cn/img/article/054/05.png" alt="05"></p><p>大致的补环境代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> eval_js = <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">var</span> rs_ts = <span class="hljs-string">&quot;&quot;</span><span class="hljs-built_in">window</span> = &#123;    <span class="hljs-attr">$_ts</span>: &#123;&#125;,    <span class="hljs-attr">eval</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;        eval_js = data    &#125;&#125;location = &#123;    <span class="hljs-string">&quot;ancestorOrigins&quot;</span>: &#123;&#125;,    <span class="hljs-string">&quot;href&quot;</span>: <span class="hljs-string">&quot;https://脱敏处理/datasearch/home-index.html&quot;</span>,    <span class="hljs-string">&quot;origin&quot;</span>: <span class="hljs-string">&quot;https://脱敏处理&quot;</span>,    <span class="hljs-string">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;https:&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.cn&quot;</span>,    <span class="hljs-string">&quot;hostname&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.cn&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,    <span class="hljs-string">&quot;pathname&quot;</span>: <span class="hljs-string">&quot;/datasearch/home-index.html&quot;</span>,    <span class="hljs-string">&quot;search&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,    <span class="hljs-string">&quot;hash&quot;</span>: <span class="hljs-string">&quot;&quot;</span>&#125;<span class="hljs-built_in">document</span> = &#123;    <span class="hljs-string">&quot;scripts&quot;</span>: [<span class="hljs-string">&quot;script&quot;</span>, <span class="hljs-string">&quot;script&quot;</span>]&#125;</code></pre><p>获取 VM 代码以及 <code>$_ts</code> 变量：</p><p><img src="https://cdn.itbob.cn/img/article/054/06.png" alt="06"></p><h2><span id="shan-yong-watch-gen-zong-gong-neng">善用 Watch 跟踪功能</span></h2><p>在跟栈分析之前，有必要了解一下浏览器开发者工具的 Watch 功能，它能够持续跟踪某个变量的值，对于瑞数这种控制流很多的情况，设置相应的变量跟踪，能够让你知道你现在处于哪个控制流中，以及生成的数组的变化，不至于跟着跟着不知道到哪一步了。如下图所示，<code>_$S8</code> 表示目前正处于第 279 号大控制流，<code>_$5x</code> 表示大控制流下的哪个分支，<code>_$mz</code> 表示 128 位大数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/07.png" alt="07"></p><h2><span id="gen-zhan-fen-xi">跟栈分析</span></h2><p>老样子，本地替换一套 412 页面的代码，固定下来，然后开始跟栈分析。直接从 <code>(772, 1)</code> 开始跟（文中说的第多少号控制流、第几步均为作者自己的叫法，第多少步并不代表实际上的步骤，仅表示关键步骤）：</p><p><img src="https://cdn.itbob.cn/img/article/054/08.png" alt="08"></p><p>单步进来，<code>_$qh</code> 是传进来的参数 1，即将进入 742 号控制流：</p><p><img src="https://cdn.itbob.cn/img/article/054/09.png" alt="09"></p><p>进入 742 号控制流，第 1 步通过一个方法获取了一个时间戳，进入这个方法内部，对时间戳进行了差值计算，会发现有两个变量 <code>_$tb</code> 和 <code>_$t1</code> 已经生成了值：</p><p><img src="https://cdn.itbob.cn/img/article/054/10.png" alt="10"></p><p><img src="https://cdn.itbob.cn/img/article/054/11.png" alt="11"></p><p>这两个值也是时间戳，怎么来的？直接搜索这两个变量，搜索结果有几个全部打上断点，刷新断下后往前跟栈，会发现是最开始走了一遍 703 号控制流：</p><p><img src="https://cdn.itbob.cn/img/article/054/12.png" alt="12"></p><p>先单步跟一遍 703 号控制流，703 号控制流第 1 步是进入 699 号控制流，返回一个数组，没有特别的，直接扣代码即可：</p><p><img src="https://cdn.itbob.cn/img/article/054/13.png" alt="13"></p><p>703 号控制流第 2、3 步分别取数组的值：</p><p><img src="https://cdn.itbob.cn/img/article/054/14.png" alt="14"></p><p><img src="https://cdn.itbob.cn/img/article/054/15.png" alt="15"></p><p>703 号控制流第 4、5、6 步生成两个时间戳并赋值给前面提到的 <code>_$tb</code>、<code>_$t1</code> 变量，涉及到的方法也没有什么特别的，缺啥搜啥补啥即可：</p><p><img src="https://cdn.itbob.cn/img/article/054/16.png" alt="16"></p><p><img src="https://cdn.itbob.cn/img/article/054/17.png" alt="17"></p><p><img src="https://cdn.itbob.cn/img/article/054/18.png" alt="18"></p><p>703 号控制流第 7 步，这里修改了 <code>$_ts</code> 的某个值（VM 代码中，<code>$_ts</code> 被赋值给了另一个变量，下图中是 <code>_$iw</code>），<code>_$iw._$uq</code> 原本的值是 <code>_$ou</code>，修改后的值是 181，这个值也是后面关键 4 位数组中的其中一个，具体逻辑后面再讲。</p><p><img src="https://cdn.itbob.cn/img/article/054/19.png" alt="19"></p><p>703 号控制流结束，我们继续前面的  742 号控制流，742 号控制流第 2 步，将前面生成的时间戳赋值给另一个变量。</p><p><img src="https://cdn.itbob.cn/img/article/054/20.png" alt="20"></p><p>742 号控制流第 3 步，进入 279 号控制流，279 号控制流是生成 128 位数组的关键。</p><p><img src="https://cdn.itbob.cn/img/article/054/21.png" alt="21"></p><p>进入 279 号控制流，第 1 步定义了一个变量：</p><p><img src="https://cdn.itbob.cn/img/article/054/22.png" alt="22"></p><p>279 号控制流，第 2 步，进入 157 号控制流，157 号控制流主要是做自动化检测</p><p><img src="https://cdn.itbob.cn/img/article/054/23.png" alt="23"></p><p><img src="https://cdn.itbob.cn/img/article/054/24.png" alt="24"></p><p>279 号控制流，第 3、4、5 步，做了一些运算，一些全局变量的值会改变，后续的数组里会用到。</p><p><img src="https://cdn.itbob.cn/img/article/054/25.png" alt="25"></p><p><img src="https://cdn.itbob.cn/img/article/054/26.png" alt="26"></p><p><img src="https://cdn.itbob.cn/img/article/054/27.png" alt="27"></p><p>279 号控制流，第 6 步，初始化了一个 128 位的空数组，后续的操作都是为了往这个数组里面填充值。</p><p><img src="https://cdn.itbob.cn/img/article/054/28.png" alt="28"></p><p>279 号控制流，第 7 步，进入 695 号控制流，生成一个 20 位的数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/29.png" alt="29"></p><p>进入 695 号控制流看一下，第 1 步，取 <code>$_ts</code> 的一个值，生成 16 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/30.png" alt="30"></p><p>695 号控制流，第 2 步，取 <code>$_ts</code> 里的四个值，与前面的 16 位数组一起组成 20 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/31.png" alt="31"></p><p>这里注意这四个值怎么来的，以第二个值 <code>_$iw._$KI</code> 为例，搜索发现有一条语句 <code>_$iw._$KI = _$iw[_$iw._$KI](_$bl, _$n2);</code>，首先等号右边取 <code>_$iw._$KI</code> 的值为 <code>_$Mo</code>，然后 <code>_$iw[&quot;_$Mo&quot;]</code> 实际上就是 <code>_$iw._$Mo</code>，前面的定义 <code>_$iw._$Mo = _$1D</code>，<code>_$1D</code> 是个方法，所以原语句相当于 <code>_$iw._$KI = _$1D(_$bl, _$n2)</code>，其他三个值的来源也是类似的。</p><p><img src="https://cdn.itbob.cn/img/article/054/32.png" alt="32"></p><p>695 号控制流结束，回到 279 号控制流，第 8 步，将前面的时间戳转换成了一个 8 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/33.png" alt="33"></p><p>279 号控制流，第 9 步，往 128 位数组里面添加了一个值。</p><p><img src="https://cdn.itbob.cn/img/article/054/34.png" alt="34"></p><p><code>_$ae</code> 这个值怎么来的？搜索下断点并跟栈，发现是开头走了第 178 号控制流得来的，跟着走一遍即可。</p><p><img src="https://cdn.itbob.cn/img/article/054/35.png" alt="35"></p><p><img src="https://cdn.itbob.cn/img/article/054/36.png" alt="36"></p><p>279 号控制流，第 10 步，又往 128 位数组里面添加了一个值，这个值是开始 279 号控制流传过来的。</p><p><img src="https://cdn.itbob.cn/img/article/054/37.png" alt="37"></p><p><img src="https://cdn.itbob.cn/img/article/054/38.png" alt="38"></p><p>279 号控制流，第 11、12、13、14 步，时间戳相关计算，然后生成两个 2 位数组。注意这里面的两个变量，<code>_$ll</code> 和 <code>_$ed</code>，在刷新 cookie、生成后缀的时候可能是有值的，仅访问主页没有值不影响。</p><p><img src="https://cdn.itbob.cn/img/article/054/39.png" alt="39"></p><p><img src="https://cdn.itbob.cn/img/article/054/40.png" alt="40"></p><p><img src="https://cdn.itbob.cn/img/article/054/41.png" alt="41"></p><p><img src="https://cdn.itbob.cn/img/article/054/42.png" alt="42"></p><p>279 号控制流，第 15 步，往 128 位数组里面添加了一个 4 位数组 <code>_$bl</code>，搜索也可以找到是通过 723 号控制流得来的。</p><p><img src="https://cdn.itbob.cn/img/article/054/43.png" alt="43"></p><p><img src="https://cdn.itbob.cn/img/article/054/44.png" alt="44"></p><p>这里的 723 号控制流，实际上是取了 <code>$_ts</code> 某个值进行运算，生成 16 位数组，然后截取前 4 位数组返回的。</p><p><img src="https://cdn.itbob.cn/img/article/054/45.png" alt="45"></p><p><img src="https://cdn.itbob.cn/img/article/054/46.png" alt="46"></p><p>279 号控制流，第 16 步，往 128 位数组里面添加了一个 8 位数组 <code>_$Yb</code>。</p><p><img src="https://cdn.itbob.cn/img/article/054/47.png" alt="47"></p><p>8 位数组 <code>_$Yb</code> 同样搜索打断点，可以在一个赋值语句断下：</p><p><img src="https://cdn.itbob.cn/img/article/054/48.png" alt="48"></p><p>可以看到 <code>_$EJ</code> 的值就是 <code>_$Yb</code>，往前跟栈，会发现先后经过了 657 号、10 号、777 号控制流，其中 777 号控制流是入口：</p><p><img src="https://cdn.itbob.cn/img/article/054/49.png" alt="49"></p><p><img src="https://cdn.itbob.cn/img/article/054/50.png" alt="50"></p><p><img src="https://cdn.itbob.cn/img/article/054/51.png" alt="51"></p><p>如果单步跟 777 号控制流，你会发现步骤较多，中间有些语句不好处理，且容易跟丢，所以我们这里就直接关注 657 号控制流就行了，777 号控制流直接到 10 号控制流，再到 657 号控制流，中间的一些过程暂时不管，跟到缺什么的时候再说（后续有很多取值赋值等操作都是在 777 号控制流里实现的，可以注意一下），这段逻辑在本地表现的代码如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/054/52.png" alt="52"></p><p>这里直接单步跟一下 657 号控制流，第 1、2 步 new 了一个方法。</p><p><img src="https://cdn.itbob.cn/img/article/054/53.png" alt="53"></p><p><img src="https://cdn.itbob.cn/img/article/054/54.png" alt="54"></p><p>这里就要注意了，容易跟丢，先进入 <code>_$bH</code> 方法打上断点，然后下一个断点就走到里面了，接着在单步调试，会进到另一个小的控制流里面，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/054/55.png" alt="55"></p><p><img src="https://cdn.itbob.cn/img/article/054/56.png" alt="56"></p><p>开始单步跟第 96 号小控制流，第 1 步定义了一个变量。</p><p><img src="https://cdn.itbob.cn/img/article/054/57.png" alt="57"></p><p>96 号小控制流，第 2 步将 <code>_$PI</code> 的值赋值给了 <code>_$fT</code>，而 <code>_$PI</code> 的值其实是 <code>window.localStorage.$_YWTU</code>，<code>window.localStorage</code> 里面有很多值，这个东西我们文章最后再讲，其中一些值与浏览器指纹相关，这里先知道他是取值就行了。</p><p><img src="https://cdn.itbob.cn/img/article/054/58.png" alt="58"></p><p>96 号小控制流，第 3 步，进入第 94 号小控制流，最终生成的是一个 8 位数组，这个其实就是前面我们想要的 <code>_$Yb</code> 的值了。</p><p><img src="https://cdn.itbob.cn/img/article/054/59.png" alt="59"></p><p>后面没有什么特别的，中间几步我就省略了，照着扣代码就行了，然后 96 号小控制流，第 4 步，就将 <code>_$EJ</code> 的值赋值给 <code>_$Yb</code> 了。</p><p><img src="https://cdn.itbob.cn/img/article/054/60.png" alt="60"></p><p>到这里先别急着结束，后面还有关键的几步，96 号小控制流，第 5 步，又遇到了和前面类似的写法。</p><p><img src="https://cdn.itbob.cn/img/article/054/61.png" alt="61"></p><p>同样的，先进 <code>_$pu</code> 打断点，再单步跟。</p><p><img src="https://cdn.itbob.cn/img/article/054/62.png" alt="62"></p><p>来到另一个小控制流，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/054/63.png" alt="63"></p><p>10 号小控制流第 1 步，取 <code>window.localStorage.$_cDro</code> 的值，转为 int 类型，赋值给 <code>_$5s</code>，这个 <code>_$5s</code> 后续也会加到 128 位大数组里面。</p><p><img src="https://cdn.itbob.cn/img/article/054/64.png" alt="64"></p><p>10 号小控制流后续还有几步，没啥用可以省略，最后一步返回 96 号小控制流。</p><p><img src="https://cdn.itbob.cn/img/article/054/65.png" alt="65"></p><p>然后 96 号小控制流后续也没啥了，返回 657 号控制流。</p><p><img src="https://cdn.itbob.cn/img/article/054/66.png" alt="66"></p><p>此时我们已经拿到  <code>_$Yb</code> 了，777 号控制流就先不管了，后续还有些代码先不管不用扣，等用到的时候再说，返回 279 号控制流，接着前面的步骤，来到第 17 步，变量 <code>_$5s</code> 经过 264 号控制流后，生成了一个值并添加到 128 位大数组里面，而 <code>_$5s</code> 的值正是前面我们跟 <code>_$Yb</code> 时，通过 777 号控制流拿到的，实际上也就是取 <code>window.localStorage.$_cDro</code> 的值，转为了 int 类型。</p><p><img src="https://cdn.itbob.cn/img/article/054/67.png" alt="67"></p><p>279 号控制流，第 18、19、20 步，往 128 位数组里面添加了两个定值、一个 8 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/68.png" alt="68"></p><p><img src="https://cdn.itbob.cn/img/article/054/69.png" alt="69"></p><p><img src="https://cdn.itbob.cn/img/article/054/70.png" alt="70"></p><p>279 号控制流，第 21 步，往 128 位数组里面添加了一个 <code>undefined</code> 占位，后续会有操作将其填充值。</p><p><img src="https://cdn.itbob.cn/img/article/054/71.png" alt="71"></p><p><img src="https://cdn.itbob.cn/img/article/054/72.png" alt="72"></p><p>279 号控制流，第 22 步，进入 58 号控制流，58 号控制流与 <code>window.localStorage.$_fb</code> 的值有关，如果有这个值，就会生成 20 位数组，如果没有就是 undefined。58 号控制流就只有一步，返回一个变量，本文中是 <code>_$0g</code>。</p><p><img src="https://cdn.itbob.cn/img/article/054/73.png" alt="73"></p><p><img src="https://cdn.itbob.cn/img/article/054/74.png" alt="74"></p><p>这个 <code>_$0g</code> 是咋来的呢？同样的直接搜索，下断点，发现是通过 112 号控制流得来的，往前跟栈，同样是先经过了 777 号控制流，和之前的情况类似，中间的过程就不看了，直接看这个 112 号控制流。</p><p><img src="https://cdn.itbob.cn/img/article/054/75.png" alt="75"></p><p>本文中，112 号控制流传的参是 <code>_$bd[279]</code> 即 <code>$_fb</code>，112 号控制流第 1 步，进入 247 号控制流。</p><p><img src="https://cdn.itbob.cn/img/article/054/76.png" alt="76"></p><p>247 号控制流就 3 步，先将 <code>window.localStorage</code> 赋值给一个变量，然后取其中 <code>$_fb</code> 的值再返回。</p><p><img src="https://cdn.itbob.cn/img/article/054/77.png" alt="77"></p><p><img src="https://cdn.itbob.cn/img/article/054/78.png" alt="78"></p><p><img src="https://cdn.itbob.cn/img/article/054/79.png" alt="79"></p><p>112 号控制流第 2、3 步，一个 <code>try-catch</code> 语句，取 <code>window.localStorage.$_fb</code> 计算得到 25 位数组，然后取前 20 位并返回，这就是前面我们需要的 <code>_$0g</code> 的值了。</p><p><img src="https://cdn.itbob.cn/img/article/054/80.png" alt="80"></p><p><img src="https://cdn.itbob.cn/img/article/054/81.png" alt="81"></p><p>279 号控制流，第 23 步，将前面 <code>window.localStorage.$_fb</code> 计算得到的 20 位数组添加到 128 位大数组里面，注意这一步如果没有 <code>window.localStorage.$_fb</code> 值的话，是不会添加的。</p><p><img src="https://cdn.itbob.cn/img/article/054/82.png" alt="82"></p><p>279 号控制流，第 24 步，对一个变量进行位运算，然后取 <code>window.localStorage.$_f0</code> 进行运算，如果 <code>$_f0</code> 为空的话是不会往 128 位大数组里添加值的。</p><p><img src="https://cdn.itbob.cn/img/article/054/83.png" alt="83"></p><p><img src="https://cdn.itbob.cn/img/article/054/84.png" alt="84"></p><p><img src="https://cdn.itbob.cn/img/article/054/85.png" alt="85"></p><p>279 号控制流，第 25 步，对一个变量进行位运算，然后取 <code>window.localStorage.$_fh0</code> 进行运算，如果 <code>$_fh0</code> 为空的话是不会往 128 位大数组里添加值的。</p><p><img src="https://cdn.itbob.cn/img/article/054/86.png" alt="86"></p><p><img src="https://cdn.itbob.cn/img/article/054/87.png" alt="87"></p><p><img src="https://cdn.itbob.cn/img/article/054/88.png" alt="88"></p><p>279 号控制流，第 26 步，对一个变量进行位运算，然后取 <code>window.localStorage.$_f1</code> 进行运算，如果 <code>$_f1</code> 为空的话是不会往 128 位大数组里添加值的。</p><p><img src="https://cdn.itbob.cn/img/article/054/89.png" alt="89"></p><p><img src="https://cdn.itbob.cn/img/article/054/90.png" alt="90"></p><p><img src="https://cdn.itbob.cn/img/article/054/91.png" alt="91"></p><p>279 号控制流，第 27 步，进入 611 号控制流，611 号控制流主要是检测 <code>window.navigator.connection.type</code>，即 <code>NetworkInformation</code> 网络相关信息，里面判断了 <code>type</code> 是不是 <code>bluetooth</code>、<code>cellular</code>、<code>ethernet</code>、<code>wifi</code>、<code>wimax</code>，正常的话应该返回 0。</p><p><img src="https://cdn.itbob.cn/img/article/054/92.png" alt="92"></p><p><img src="https://cdn.itbob.cn/img/article/054/93.png" alt="93"></p><p><img src="https://cdn.itbob.cn/img/article/054/94.png" alt="94"></p><p>279 号控制流，接下来几步都是类似的，这里就直接统称第 28 步了，首先对一个变量进行位运算，然后分别取 <code>window.localStorage.$_fr</code>、 <code>window.localStorage.$_fpn1</code> 、 <code>window.localStorage.$_vvCI</code>、 <code>window.localStorage.$_JQnh</code> 进行运算，同样如果这些变量为空的话，也是不会往 128 位大数组里添加值的。</p><p><img src="https://cdn.itbob.cn/img/article/054/96.png" alt="96"></p><p><img src="https://cdn.itbob.cn/img/article/054/97.png" alt="97"></p><p><img src="https://cdn.itbob.cn/img/article/054/98.png" alt="98"></p><p><img src="https://cdn.itbob.cn/img/article/054/99.png" alt="99"></p><p>279 号控制流，第 29 步，往 128 位大数组里添加了一个定值 4，本文中该变量名是 <code>_$kW</code>。</p><p><img src="https://cdn.itbob.cn/img/article/054/100.png" alt="100"></p><p><code>_$kW</code> 这个变量是咋来的，和前面的套路类似，直接搜索下断，同样是经过开头的 777 号控制流得来的，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/054/101.png" alt="101"></p><p>继续 279 号控制流，中间有一些变量位运算之类的就省略了，第 30、31 步，取了一个 <code>https:443</code> 的长度进行计算，先后往 128 位大数组里添加了一个定值和一个 9 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/102.png" alt="102"></p><p><img src="https://cdn.itbob.cn/img/article/054/103.png" alt="103"></p><p>279 号控制流，接下来几步都是在取值，都差不多，就统称为第 32 步了。</p><p><img src="https://cdn.itbob.cn/img/article/054/104.png" alt="104"></p><p><img src="https://cdn.itbob.cn/img/article/054/105.png" alt="105"></p><p><img src="https://cdn.itbob.cn/img/article/054/106.png" alt="106"></p><p><img src="https://cdn.itbob.cn/img/article/054/107.png" alt="107"></p><p><img src="https://cdn.itbob.cn/img/article/054/108.png" alt="108"></p><p><img src="https://cdn.itbob.cn/img/article/054/109.png" alt="109"></p><p>279 号控制流，第 33 步，之前 128 位大数组第 12 位是个 <code>undefined</code>，这里就将第 12 位填充上了一个 4 位数组，其中有个变量 <code>_$8L</code>，前面我们跟步骤的时候就有一个变量一直在做位运算，此处的 <code>_$8L</code> 就是这么来的。</p><p><img src="https://cdn.itbob.cn/img/article/054/110.png" alt="110"></p><p>279 号控制流，最后两步，原来的 128 位大数组，只取有值的前 21 位，一共有多少位与 <code>window.localStorage</code> 的某些值有关，有值的话就长一些，没有就短一些，然后再将数组的每个元素合并成最终的一个大数组并返回，279 号控制流就结束了。</p><p><img src="https://cdn.itbob.cn/img/article/054/111.png" alt="111"></p><p><img src="https://cdn.itbob.cn/img/article/054/112.png" alt="112"></p><p>返回到文章开头的逻辑，279 号控制流结束，返回到 742 号控制流，第 2 步，定义了一个变量并生成了一个 32 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/113.png" alt="113"></p><p><img src="https://cdn.itbob.cn/img/article/054/114.png" alt="114"></p><p>742 号控制流，第 3 步，取 <code>$_ts</code> 里面的某个值并赋值给一个变量。</p><p><img src="https://cdn.itbob.cn/img/article/054/115.png" alt="115"></p><p>742 号控制流，第 4 步，将前面 279 号控制流得到的大数组与上一步 <code>$_ts</code> 里面的某个值进行合并，合并后计算得到一个值。</p><p><img src="https://cdn.itbob.cn/img/article/054/116.png" alt="116"></p><p>742 号控制流，第 4 步，将上一步得到的值进一步计算得到一个 4 位数组，再将其和大数组合并。</p><p><img src="https://cdn.itbob.cn/img/article/054/117.png" alt="117"></p><p>742 号控制流，接下来几步是对时间戳进行各种操作，这里统称为第 5 步。</p><p><img src="https://cdn.itbob.cn/img/article/054/118.png" alt="118"></p><p><img src="https://cdn.itbob.cn/img/article/054/119.png" alt="119"></p><p><img src="https://cdn.itbob.cn/img/article/054/120.png" alt="120"></p><p><img src="https://cdn.itbob.cn/img/article/054/121.png" alt="121"></p><p>742 号控制流，第 6 步，将上一步得到的 4 个时间戳进行计算，得到一个 16 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/122.png" alt="122"></p><p>742 号控制流，第 7 步，将上一步得到的 16 位数组进行异或运算。</p><p><img src="https://cdn.itbob.cn/img/article/054/123.png" alt="123"></p><p>742 号控制流，第 8 步，将上一步的 16 位数组进行计算，得到一个字符串。</p><p><img src="https://cdn.itbob.cn/img/article/054/124.png" alt="124"></p><p>742 号控制流，第 9 步，正式生成 cookie 值，其中 <code>_$bd[274]</code> 定值，一般视为版本号，将上一步得到的字符串、之前得到的大数组和一个 32 位数组进行计算、组合，得到最终结果。</p><p><img src="https://cdn.itbob.cn/img/article/054/125.png" alt="125"></p><p>742 号控制流结束，返回 772 号控制流，利用了一个方法，组装 cookie，然后赋值给 <code>document.cookie</code>，整个流程就结束了。</p><p><img src="https://cdn.itbob.cn/img/article/054/126.png" alt="126"></p><p><img src="https://cdn.itbob.cn/img/article/054/127.png" alt="127"></p><p><img src="https://cdn.itbob.cn/img/article/054/128.png" alt="128"></p><p>代码中用到的 <code>$_ts</code> 的值需要我们自己去匹配出来，动态替换，这些步骤和 4 代是类似的，本文就不再重复叙述，可以参考 4 代的那篇逆向文章进行处理即可。</p><p><img src="https://cdn.itbob.cn/img/article/054/129.png" alt="129"></p><h2><span id="hou-zhui-sheng-cheng">后缀生成</span></h2><p>本例中，请求头中有个 sign 参数，Query String Parameters 有两个后缀参数，这两个后缀和 4 代类似，都是瑞数生成的。</p><p><img src="https://cdn.itbob.cn/img/article/054/130.png" alt="130"></p><p><img src="https://cdn.itbob.cn/img/article/054/131.png" alt="131"></p><p>和 4 代的处理方法一样，我们下一个 XHR 断点，先让网页加载完毕，然后打开开发者工具，过掉无限 debugger 后，点击搜索就会断下，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/054/132.png" alt="132"></p><p>往上跟栈到 <code>hasTokenGet</code>，是一个 sojson 旗下的 jsjiami v6 混淆，不值一提，重点是 <code>jsonMD5ToStr</code> 方法，先对传进去的参数做了一些编码处理，最后返回的是 <code>hex_md5</code>，和在线 MD5 加密的结果是一样的，说明是标准的 MD5。</p><p><img src="https://cdn.itbob.cn/img/article/054/133.png" alt="133"></p><p><img src="https://cdn.itbob.cn/img/article/054/134.png" alt="134"></p><p>重点来看瑞数的两个后缀生成方式，和 4 代一样，<code>XMLHttpRequest.send</code> 和 <code>XMLHttpRequest.open</code> 被重写了，如下图所示，在 <code>XMLHttpRequest.open</code> 下个断点，也就是图中的 <code>_$RQ</code> 方法，<code>arguments[1]</code> 就是原始 URL，经过图中的 <code>_$tB</code> 方法处理后就能拿到后缀。</p><p><img src="https://cdn.itbob.cn/img/article/054/135.png" alt="135"></p><p>跟进图中的 <code>_$tB</code> 方法，<code>_$tB</code> 方法里嵌套了一些其他方法，走一遍逻辑，到图中的 <code>_$5j</code> 方法里，前面的一部分都是在对传入的 URL 做处理。</p><p><img src="https://cdn.itbob.cn/img/article/054/136.png" alt="136"></p><p>接下来是生成了一个 16 位数组：</p><p><img src="https://cdn.itbob.cn/img/article/054/137.png" alt="137"></p><p>然后这个 16 位数组经过一个方法后就生成了第一个后缀，如下图所示，本文中这个方法是 <code>_$ZO</code>。</p><p><img src="https://cdn.itbob.cn/img/article/054/138.png" alt="138"></p><p>跟进 <code>_$ZO</code> 方法，主要有以下 5 步：</p><p>第 1 步：生成了一个 32 位数组；</p><p>第 2 步：将之前的 16 位数组以及两个变量拼接生成一个 50 位的数组；</p><p>第 3 步：进入 744 控制流，这里你会发现和之前我们跟 cookie 时的 742 号控制流是一样的，重复走了一遍，所以这里就不再跟了；</p><p>第 4 步：将生成的第一个后缀值进行处理，得到一个两位的字符串，这个字符串在获取第二个后缀的时候会用到；</p><p>第 5 步：将第一个后缀名称和值进行拼接并返回，此时，第一个后缀 <code>hKHnQfLv</code> 就生成了。</p><p><img src="https://cdn.itbob.cn/img/article/054/139.png" alt="139"></p><p>接着前面的 <code>_$5j</code> 方法，图中的 <code>_$5j</code> 这一步，就是获取第二个后缀 <code>8X7Yi61c</code> 的值：</p><p><img src="https://cdn.itbob.cn/img/article/054/140.png" alt="140"></p><p>主要是看一下图中的 <code>_$UM</code> 方法，先将前面生成的两位的字符串与 URL 参数进行拼接，然后会经过一个 <code>_$Nr</code> 方法就能得到第二个后缀的值了。</p><p><img src="https://cdn.itbob.cn/img/article/054/141.png" alt="141"></p><p>再来看一下 <code>_$Nr</code> 方法，先生成一个类似 53924 的值，然后一个 try 语句，注意这里有个方法，图中的 <code>_$Js</code> 方法，里面用到了 <code>$_ts</code> 里面的某个值，后面又生成了一个由数字组成的字符串，再次经过组合、计算后得到最终的值。</p><p><img src="https://cdn.itbob.cn/img/article/054/142.png" alt="142"></p><p><img src="https://cdn.itbob.cn/img/article/054/143.png" alt="143"></p><p>回到前面的 <code>_$UM</code> 方法，前缀 <code>8X7Yi61c</code> 与值组合，自此，两个后缀都拿到了：</p><p><img src="https://cdn.itbob.cn/img/article/054/144.png" alt="144"></p><h2><span id="zhi-wen-sheng-cheng">指纹生成</span></h2><p>我们前面已经分析了，在往 128 位数组里添加值的时候，会有取 <code>window.localStorage</code> 里面的某些值进行计算的步骤，这些值就是取浏览器 canvas 等指纹生成的，指纹随机就能并发，通常访问单独的一个 html 页面是不校验指纹的，生成的短 cookie 就能通过，但是一些查询数据接口会校验指纹，通过触发 load 事件来向 cookie 里添加指纹，使得 cookie 长度变长，怎么查找指纹在哪里生成的，这里推荐直接看视频资料，已经讲得很清楚了，篇幅太长，本文就不再赘述了，资料链接：<a href="https://mp.weixin.qq.com/s/DEUc1K8WaO_Cq1a2r0Ge5g">https://mp.weixin.qq.com/s/DEUc1K8WaO_Cq1a2r0Ge5g</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/javascript_reverse.png&quot; alt=&quot;javascript_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>人均瑞数系列，瑞数 4 代 JS 逆向分析</title>
    <link href="https://www.itbob.cn/article/053/"/>
    <id>https://www.itbob.cn/article/053/</id>
    <published>2022-07-01T04:00:00.000Z</published>
    <updated>2022-11-02T15:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/javascript_reverse.png" alt="javascript_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#qian-yan">前言</a></li><li><a href="#rui-shu-te-zheng-yi-ji-bu-tong-ban-ben-de-qu-bie">瑞数特征以及不同版本的区别</a></li><li><a href="#cookie-ru-kou-ding-wei">Cookie 入口定位</a></li><li><a href="#wen-jian-jie-gou-yu-luo-ji">文件结构与逻辑</a></li><li><a href="#vm-dai-ma-yi-ji-ts-bian-liang-huo-qu">VM 代码以及 $_ts 变量获取</a></li><li><a href="#kou-dai-ma">扣代码</a><ul><li><a href="#jia-cookie-sheng-cheng-luo-ji">假 Cookie 生成逻辑</a></li><li><a href="#zhen-cookie-sheng-cheng-luo-ji">真 Cookie 生成逻辑</a><ul><li><a href="#qu-jia-cookie">取假 Cookie</a></li><li><a href="#zi-dong-hua-gong-ju-jian-ce">自动化工具检测</a></li><li><a href="#20-wei-he-xin-shu-zu">20 位核心数组</a></li><li><a href="#qi-ta-yong-dao-ts-zhi-de-di-fang">其他用到 $_ts 值的地方</a></li></ul></li><li><a href="#zhu-yi-shi-xiang">注意事项</a></li><li><a href="#hou-zhui-mmewmd-sheng-cheng-luo-ji">后缀 MmEwMD 生成逻辑</a></li></ul></li><li><a href="#shan-yong-watch-gen-zong-gong-neng">善用 Watch 跟踪功能</a></li><li><a href="#jie-guo-yan-zheng">结果验证</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="qian-yan">前言</span></h2><p><img src="https://cdn.itbob.cn/img/article/053/01.png" alt="01"></p><p>瑞数动态安全 Botgate（机器人防火墙）以“动态安全”技术为核心，通过动态封装、动态验证、动态混淆、动态令牌等技术对服务器网页底层代码持续动态变换，增加服务器行为的“不可预测性”，实现了从用户端到服务器端的全方位“主动防护”，为各类 Web、HTML5 提供强大的安全保护。</p><p>瑞数 Botgate 多用于政企、金融、运营商行业，曾一度被视为反爬天花板，随着近年来逆向大佬越来越多，相关的逆向文章也层出不穷，真正到了人均瑞数的时代了，这里也感谢诸如 Nanda、懒神等逆向大佬，揭开了瑞数神秘的面纱，总结的经验让后来人少走了不少弯路。</p><p>过瑞数的方法基本上有以下几种：自动化工具（要隐藏特征值）、RPC 远程调用、JS 逆向（硬扣代码和补环境），本文介绍的是 JS 逆向硬扣代码，尽可能多的介绍各种细节。</p><h2><span id="rui-shu-te-zheng-yi-ji-bu-tong-ban-ben-de-qu-bie">瑞数特征以及不同版本的区别</span></h2><p>对于绝大多数使用了瑞数的网站来说，有以下几点特征（可能有特殊版本不一样，先仅看主流的）：</p><p>1、打开开发者工具（F12）会依次出现两个典型的无限 debugger：</p><p><img src="https://cdn.itbob.cn/img/article/053/02.png" alt="02"></p><p><img src="https://cdn.itbob.cn/img/article/053/03.png" alt="03"></p><p>2、瑞数的 JS 混淆代码中，变量、方法名大多类似于 <code>_$xx</code>，有众多的 <code>if-else</code> 控制流，新版瑞数还可能会有 jsvmp 以及众多三目表达式的情况：</p><p><img src="https://cdn.itbob.cn/img/article/053/04.png" alt="04"></p><p>3、看请求，会有典型的三次请求，首次请求响应码是 202（瑞数3、4代）或者 412（瑞数5代），接着单独请求一个 JS 文件，然后再重新请求页面，后续的其他 XHR 请求中，都带有一个后缀，这个后缀的值是由 JS 生成的，每次都会变化，后缀的值第一个数字为瑞数的版本，比如 <code>MmEwMD=4xxxxx</code> 就是4代瑞数，<code>bX3Xf9nD=5xxxxx</code> 就是5代瑞数：</p><p><img src="https://cdn.itbob.cn/img/article/053/05.png" alt="05"></p><p><img src="https://cdn.itbob.cn/img/article/053/06.png" alt="06"></p><p><img src="https://cdn.itbob.cn/img/article/053/07.png" alt="07"></p><p><img src="https://cdn.itbob.cn/img/article/053/08.png" alt="08"></p><p>4、看 Cookie，瑞数 3、4 代有以 T 和 S 结尾的两个 Cookie，其中以 S 开头的 Cookie 是第一次的 201 那个请求返回的，以 T 开头的 Cookie 是由 JS 生成的，动态变化的，T 和 S 前面一般会跟 80 或 443 的数字，Cookie 值第一个数字为瑞数的版本（为什么可以通过第一个数字来判断版本？难道相同版本第一个数字不会变吗？这些问题我们在分析 JS 的时候可以找到答案），比如：</p><ul><li><code>FSSBBIl1UgzbN7N80T=37Na97B.nWX3....</code>：数字 80 是 http 协议的默认端口号，对应 http 请求，其值第一位为 3，表示 3 代瑞数；</li><li><code>FSSBBIl1UgzbN7N443T=4a.tr1kEXk.....</code>：数字 443 是 https 协议的默认端口号，对应 https 请求，其值第一位为 4，表示 4 代瑞数。</li></ul><p><img src="https://cdn.itbob.cn/img/article/053/09.png" alt="09"></p><p>瑞数 5 代也有以 T 和 S 结尾的两个 Cookie，但有些特殊的 5 代瑞数也有以 O 和 P 结尾的，同样的，以 O 开头的是第一次的 412 那个请求返回的，以 P 开头的是由 JS 生成的，Cookie 值第一个数字同样为瑞数的版本，和 3、4 代不同的是，5 代没有加端口号了，比如：</p><ul><li><code>vsKWUwn3HsfIO=57C6DwDUXS.....</code>：以 O 结尾，其值第一位为 5，表示 5 代瑞数；</li><li><code>WvY7XhIMu0fGT=53.9fybty......</code>：以 T 结尾，其值第一位为 5，表示 5 代瑞数。</li></ul><p><img src="https://cdn.itbob.cn/img/article/053/10.png" alt="10"></p><p><img src="https://cdn.itbob.cn/img/article/053/11.png" alt="11"></p><p>5、看入口，瑞数有个流程是在虚拟机 VM 中加载 1w+ 行的代码，加载此代码的入口，不同版本也不一样（这个入口具体在哪里？怎么定位？在后续逆向分析中再详细介绍），示例如下：</p><ul><li>3 代：<code>_$aW = _$c6[_$l6()](_$wc, _$mo);</code>，<code>_$c6</code> 实际上是 <code>eval</code>，<code>_$l6()</code> 实际上是 <code>call</code>；</li></ul><p><img src="https://cdn.itbob.cn/img/article/053/12.png" alt="12"></p><ul><li>4 代：<code>ret = _$DG.call(_$6a, _$YK);</code>，<code>_$DG</code> 实际上是 <code>eval</code>，有关键字 <code>ret</code>，<code>call</code> 是明文；</li></ul><p><img src="https://cdn.itbob.cn/img/article/053/13.png" alt="13"></p><ul><li>5 代：5 代种类比较多了，最初和 4 代的类似，比如 <code>ret = _$Yg.call(_$kc, _$mH);</code>，有关键字 ret，call 是明文，也有没有 ret 关键字的版本，比如 <code>_$ap = _$j5.call(_$_T, _$gp);</code>，也有像 3 代那样全部混淆了的，比如：<code>_$x8 = _$mP[_$nU[15]](_$z3, _$Ec);</code>，<code>_$mP</code> 实际上是 <code>eval</code>，<code>_$nU[15]</code> 实际上是 <code>call</code>，混淆的 <code>call</code> 与 3 代的区别就是 5 代是在一个数组里取值得到的；</li></ul><p><img src="https://cdn.itbob.cn/img/article/053/14.png" alt="14"></p><p><img src="https://cdn.itbob.cn/img/article/053/15.png" alt="15"></p><p><img src="https://cdn.itbob.cn/img/article/053/16.png" alt="16"></p><p>当然要想精准区分不同版本，得各个条件结合起来看，最主要的还是得看看内部的实现逻辑，以及页面的代码结构，比如 4 代有一个生成假 Cookie 的步骤，而 5 代没有，有的特殊版本虽然看起来是 5 代，但是加了 jsvmp 和三目表达式，和传统的 5 代又有区别，偶尔愚人节啥的突然来个新版本，也会不一样，各版本在分析一遍之后，就很容易区分了。</p><h2><span id="cookie-ru-kou-ding-wei">Cookie 入口定位</span></h2><p>本文案例中瑞数 4 代网站为：<code>aHR0cDovL3d3dy5mYW5nZGkuY29tLmNuL25ld19ob3VzZS9uZXdfaG91c2VfZGV0YWlsLmh0bWw=</code></p><p>首先过掉无限 debugger（过不过其实无所谓，后面的分析其实这个基本上没影响），直接右键 <code>Never pause here</code> 永不在此处断下即可：</p><p><img src="https://cdn.itbob.cn/img/article/053/17.png" alt="17"></p><p>定位 Cookie，首选 Hook 来的最快，通过 Fiddler 等抓包工具、油猴脚本、浏览器插件等方式注入以下 Hook 代码：</p><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 严谨模式 检查所有错误</span><span class="hljs-meta">    &#x27;use strict&#x27;</span>;    <span class="hljs-comment">// document 为要hook的对象 这里是hook的cookie</span>    <span class="hljs-keyword">var</span> cookieTemp = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">document</span>, <span class="hljs-string">&#x27;cookie&#x27;</span>, &#123;        <span class="hljs-comment">// hook set方法也就是赋值的方法 </span>        <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;                <span class="hljs-comment">// 这样就可以快速给下面这个代码行下断点</span>                <span class="hljs-comment">// 从而快速定位设置cookie的代码</span>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hook捕获到cookie设置-&gt;&#x27;</span>, val);                <span class="hljs-keyword">debugger</span>;                cookieTemp = val;                <span class="hljs-keyword">return</span> val;        &#125;,        <span class="hljs-comment">// hook get 方法也就是取值的方法 </span>        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;            <span class="hljs-keyword">return</span> cookieTemp;        &#125;    &#125;);&#125;)();</code></pre><p>Hook 发现会有生成两次 Cookie 的情况，断下之后往上跟栈，可以看到组装 Cookie 的代码，类似如下结构：</p><p><img src="https://cdn.itbob.cn/img/article/053/18.png" alt="18"></p><p>仔细观察这两次 Cookie 生成的地方，分别往上跟栈，你就会发现两个 Cookie 分别是经过了两个不同方法得到的，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/053/19.png" alt="19"></p><p><img src="https://cdn.itbob.cn/img/article/053/20.png" alt="20"></p><p>这里的代码存在于 VM 虚拟机中，且是 IIFE 自执行代码，我们还得往前跟栈看看这些 VM 代码是从哪里加载出来的，跟栈来到首页（202页面）带有 call 的位置：</p><p><img src="https://cdn.itbob.cn/img/article/053/21.png" alt="21"></p><p>我们在文章开头介绍的这个位置就是这么分析得来的，这个位置通常在分析瑞数的时候作为入口，图中 <code>_$te</code> 实际上是 eval 方法，传入的第一个参数 <code>_$fY</code> 是 Window 对象，第二个对象 <code>_$F8</code> 是我们前面看到的 VM 虚拟机中的 IIFE 自执行代码。</p><p>在知道了瑞数大致的入口之后，我们也可以使用事件监听中的 Script 断点，一直下一个断点（F8）就可以走到 202 页面，然后搜索 call 关键字就能快速定位到入口，Script 断点中的两个选项，第一个表示运行 JS 脚本的第一条语句时断下，第二个表示 JS 因为内容安全政策而被屏蔽时断下，一般选择第一个就可以了，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/053/22.png" alt="22"></p><h2><span id="wen-jian-jie-gou-yu-luo-ji">文件结构与逻辑</span></h2><p>想要后续分析 Cookie 的生成，我们不得不要观察一下 202 页面的代码，meta 标签有个 content 内容，引用了一个类似于 <code>c.FxJzG50F.dfe1675.js</code> 的 JS 文件，接着跟一个自执行的 JS，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/053/23.png" alt="23"></p><p>第1部分 meta 标签的 content 内容，每次都是变化的，第2部分引用的这个外部 JS 在不同页面也有所差别，但是同一个网站同一个页面 JS 里的内容一般是固定不会变的，第3部分自执行代码每次变化的只是变量名，整体逻辑不变，后续我们在扣代码的时候，也会用到这里的部分方法。自执行代码里同样也是有很多 <code>if-else</code> 控制流，开头的那个数组，比如上图中的 <code>_$Dk</code> 就是用来控制后续的控制流的。</p><p>引用的 <code>c.FxJzG50F.dfe1675.js</code> 直接打开看是乱码的，而自执行 JS 的主要作用是将这 JS 乱码还原成 VM 里的 1w+ 行的正常代码，并且定义了一个全局变量 <code>window.$_ts</code> 并赋了许多值，这个变量在后续 VM 中作用非常大，meta 标签的 content 内容同样也会在 VM 里用到。</p><p>由于很多值、变量都是动态变化的，肯定不利于我们的分析，所以我们需要固定一套代码到本地，打断点、跟栈都会更加方便，随便保存一份 202 页面的代码，以及该页面对应的外链 JS 文件，如 <code>c.FxJzG50F.dfe1675.js</code> 到本地，使用浏览器自带的 overrides 重写功能、或者浏览器插件 ReRes、或者抓包工具的响应替换功能（如 Fiddler 的 AutoResponder）进行替换。</p><p><img src="https://cdn.itbob.cn/img/article/053/24.png" alt="24"></p><p>VM 里面的代码是生成 Cookie 的主要代码，包含众多的 <code>if-else</code> 控制流，无疑增加了我们分析代码的成本，这里就可以使用 AST 技术做一下反混淆，比如 Nanda 就将 <code>if-else</code> 控制流转换成了 <code>switch-case</code> 的，同一个控制流下的代码放在了同一个 <code>case</code> 下，然后在 <code>call</code> 入口那个地方，将 VM 代码做一下本地替换，具体可以参考 Nanda 的文章：<a href="https://mp.weixin.qq.com/s/r3FXjvT5Mm9Ikg_bDEadcw">《某数4代逻辑分析》</a>，感兴趣的可以试试，不了解 AST 的可以看看以前的文章<a href="https://mp.weixin.qq.com/s/fIbPuNMs5FRADJE5MOZXgA">《逆向进阶，利用 AST 技术还原 JavaScript 混淆代码》</a>，后续有时间再写写 AST 还原瑞数代码的实战，本文咱们选择硬刚！</p><p><img src="https://cdn.itbob.cn/img/article/053/25.jpg" alt="25"></p><h2><span id="vm-dai-ma-yi-ji-ts-bian-liang-huo-qu">VM 代码以及 $_ts 变量获取</span></h2><p>前面我们了解了 VM 代码和 <code>$_ts</code> 的重要性，所以我们第一步是要想办法拿到他们，至于在什么时候有用到，文章后续再说，复制外链 JS，即  <code>c.FxJzG50F.dfe1675.js</code> 的代码和 202 页面的自执行代码到文件，本地直接运行即可，需要轻度补一下环境，缺啥补啥，大致补一下 window、location、document 就行了，补的具体内容可以直接在浏览器控制台使用 <code>copy()</code> 命令复制过来，然后 VM 代码我们就可以直接 Hook eval 的方式得到，大致的补环境代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> eval_js = <span class="hljs-string">&quot;&quot;</span><span class="hljs-built_in">window</span> = &#123;    <span class="hljs-attr">$_ts</span>:&#123;&#125;,    <span class="hljs-attr">eval</span>:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;        eval_js = data    &#125;&#125;location = &#123;    <span class="hljs-string">&quot;ancestorOrigins&quot;</span>: &#123;&#125;,    <span class="hljs-string">&quot;href&quot;</span>: <span class="hljs-string">&quot;http://www.脱敏处理.com.cn/new_house/new_house_detail.html&quot;</span>,    <span class="hljs-string">&quot;origin&quot;</span>: <span class="hljs-string">&quot;http://www.脱敏处理.com.cn&quot;</span>,    <span class="hljs-string">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;http:&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.com.cn&quot;</span>,    <span class="hljs-string">&quot;hostname&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.com.cn&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,    <span class="hljs-string">&quot;pathname&quot;</span>: <span class="hljs-string">&quot;/new_house/new_house_detail.html&quot;</span>,    <span class="hljs-string">&quot;search&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,    <span class="hljs-string">&quot;hash&quot;</span>: <span class="hljs-string">&quot;&quot;</span>&#125;<span class="hljs-built_in">document</span> = &#123;    <span class="hljs-string">&quot;scripts&quot;</span>: [<span class="hljs-string">&quot;script&quot;</span>, <span class="hljs-string">&quot;script&quot;</span>]&#125;</code></pre><p><img src="https://cdn.itbob.cn/img/article/053/25.png" alt="25"></p><p>观察 <code>$_ts</code> 的 key 和 value，和浏览器中得到的是一样的：</p><p><img src="https://cdn.itbob.cn/img/article/053/26.png" alt="26"></p><p>注意事项：<code>c.FxJzG50F.dfe1675.js</code> 外链 JS 如果你直接下载下来用编辑器打开可能会被自动编码，和原始数据有出入，导致运行报错，这里建议直接在浏览器在线访问这个文件，手动复制过来，或者在抓包软件里将响应内容复制过来，观察以下两种情况，第一种情况就可能会导致运行出错，第二种是正常的：</p><p><img src="https://cdn.itbob.cn/img/article/053/27.png" alt="27"></p><h2><span id="kou-dai-ma">扣代码</span></h2><p>前面说了这么多，现在终于可以进入主题了，那就是扣代码，找个好椅子，准备把屁股坐穿，此时你的键盘只有 F11 有用，不断单步调试，只需要亿点点细节，就完事儿了！</p><p>扣代码步骤太多，不可能每一步都截图写出来，只写一下比较重要的，如有遗漏的地方，那也没办法，首先先在我们替换的 202 页面里，自执行代码开始的地方手动加个 debugger，一进入页面就断下，方便后续的分析：</p><p><img src="https://cdn.itbob.cn/img/article/053/28.png" alt="28"></p><p>通过前面我们的分析，已经知道了入口在 call 的地方，快速搜索并下断点：</p><p><img src="https://cdn.itbob.cn/img/article/053/29.png" alt="29"></p><p>通过前面我们的分析，我们也知道了有两次生成 Cookie 的地方，快速搜索 <code>(5)</code>，搜索结果第二个即为入口：</p><p><img src="https://cdn.itbob.cn/img/article/053/30.png" alt="30"></p><h3><span id="jia-cookie-sheng-cheng-luo-ji">假 Cookie 生成逻辑</span></h3><p>首先单步跟假 Cookie，虽然是假的，但是后续生成真 Cookie 中会用到，在跟的时候你会走到这个逻辑里面：</p><p><img src="https://cdn.itbob.cn/img/article/053/31.png" alt="31"></p><p>有一步会调用 <code>_$8e()</code> 方法，而 <code>_$8e = _$Q9</code>，<code>_$Q9</code> 又嵌套在 <code>_$d0</code> 里的，搜索一下哪里调用了 <code>_$d0</code>，发现是代码开头：</p><p><img src="https://cdn.itbob.cn/img/article/053/32.png" alt="32"></p><p>那么传入的参数 <code>_$Wn</code> 是啥呢？单步跟入，是一个方法，作用就是取 202 页面的 content 内容，那么我们在本地就直接删掉这个 <code>_$Wn</code> 方法，直接传入 content 的值即可，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/053/33.png" alt="33"></p><p>另外，我们发现，代码有非常多的在数组里面按索引取值的情况，比如上图中的 <code>_$PV[68]</code> 的值，实际上就是字符串 content，很显然我们要把这个数组的来源找到，直接搜索 <code>_$PV = </code>，可以找到疑似定义和赋值的地方：</p><p><img src="https://cdn.itbob.cn/img/article/053/34.png" alt="34"></p><p><img src="https://cdn.itbob.cn/img/article/053/35.png" alt="35"></p><p>所以我们得看看这个 <code>_$iL</code> 方法，传入了一个非常长的字符串，打断点进去看看，果然生成了 <code>_$PV</code>，是一个 725 位的数组：</p><p><img src="https://cdn.itbob.cn/img/article/053/36.png" alt="36"></p><p>接下来在扣代码的过程中，你会经常遇到一个变量，在本文中是 <code>_$sX</code>：</p><p><img src="https://cdn.itbob.cn/img/article/053/37.png" alt="37"></p><p>有没有很熟悉？这个值就是我们前面拿到的 <code>$_ts</code> 变量，在开头就可以看到是将 <code>window.$_ts</code> 赋值给了 <code>_$sX</code>：</p><p><img src="https://cdn.itbob.cn/img/article/053/38.png" alt="38"></p><p>继续走，会走到以下逻辑中：</p><p><img src="https://cdn.itbob.cn/img/article/053/39.png" alt="39"></p><p>这里会遇到六个数组，他们都已经有值了，所以我们得找到他们是咋来的，任意搜索其中一个数组名称，会找到定义和赋值的地方：</p><p><img src="https://cdn.itbob.cn/img/article/053/40.png" alt="40"></p><p><img src="https://cdn.itbob.cn/img/article/053/41.png" alt="41"></p><p>赋值明显是调用了 <code>_$rv</code> 方法，再搜 <code>_$rv</code> 方法，发现是开头就调用了：</p><p><img src="https://cdn.itbob.cn/img/article/053/42.png" alt="42"></p><p>后续没有什么特别的，一直单步，最后有个 <code>join('')</code> 操作，就生成了假 Cookie：</p><p><img src="https://cdn.itbob.cn/img/article/053/43.png" alt="43"></p><p>接下来是生成 Cookie 的名字 <code>FSSBBIl1UgzbN7N80T</code>，然后将 Cookie 赋值给 <code>document.cookie</code>，然后又向 <code>localStorage</code> 里面的 <code>$_ck</code> 赋了个值，<code>localStorage</code> 的内容可以直接复制下来，没有太大影响。</p><p><img src="https://cdn.itbob.cn/img/article/053/44.png" alt="44"></p><h3><span id="zhen-cookie-sheng-cheng-luo-ji">真 Cookie 生成逻辑</span></h3><p>单步跟真 Cookie，在本文中也就是 <code>_$ZN(768, 1);</code>，可以看到开始进入了无穷无尽的 <code>if-else</code> 控制流：</p><p><img src="https://cdn.itbob.cn/img/article/053/45.png" alt="45"></p><p>这里本地应该怎样处理呢？我的做法是以 <code>_$Hn</code> 和其值命名函数，<code>function _$Hn768()&#123;&#125;</code> 就表示所有走 768 号控制流的方法，继续跟，生成真 Cookie 的方法基本上在 747 号控制流，后续我们主要以 747 号控制流的各个步骤来看，747 号控制流扣出来的代码大致如下：</p><p><img src="https://cdn.itbob.cn/img/article/053/46.png" alt="46"></p><h4><span id="qu-jia-cookie">取假 Cookie</span></h4><p>单步跟 747 号控制流，会有个进入第 709 号控制流的步骤，会取先前生成的假 Cookie，经过一系列操作之后返回一个数组：</p><p><img src="https://cdn.itbob.cn/img/article/053/47.png" alt="47"></p><p><img src="https://cdn.itbob.cn/img/article/053/48.png" alt="48"></p><p>至此我们在本地同步扣的代码，如果正常的话，返回的数组也应该是一样的（后续的数据就不一样了，有一些时间戳之类的参数参与运算）：</p><p><img src="https://cdn.itbob.cn/img/article/053/49.png" alt="49"></p><h4><span id="zi-dong-hua-gong-ju-jian-ce">自动化工具检测</span></h4><p>继续跟 747 号控制流，会进入 268 号控制流，接着进入 154 号控制流，这里面会针对自动化工具做一些检测，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/053/50.png" alt="50"></p><p><img src="https://cdn.itbob.cn/img/article/053/51.png" alt="51"></p><p>这里定义了一个变量 <code>_$iL</code>，检测不通过就是1，后续又把这个变量赋值给了 <code>_$aW</code>，所以我们本地保持一致，也为 false 即可（其实我们不用自动化工具的话，这一段检测就不用管直接返回 false 就行）：</p><p><img src="https://cdn.itbob.cn/img/article/053/52.png" alt="52"></p><h4><span id="20-wei-he-xin-shu-zu">20 位核心数组</span></h4><p>继续跟 268 号控制流，会进入 668 号控制流，668 号控制流就两个操作，一是生成一个 16 位数组，二是取 <code>$_ts</code> 里面的 4 个变量，加到前面的 16 位后面，组成一个 20 位数组，这 20 位数组的最后 4 位是瑞数核心，其中的映射关系搞错了请求是通不过的，在五代中这部分的处理逻辑会更加复杂。</p><p><img src="https://cdn.itbob.cn/img/article/053/53.png" alt="53"></p><p><img src="https://cdn.itbob.cn/img/article/053/54.png" alt="54"></p><p>这里不是单纯的取 <code>$_ts</code> 里的键值对，你在扣代码的时候，你也许会发现怎么本地到这里取值的时候，取出来的不是数字，而是字符串呢？就像下面这种情况：</p><p><img src="https://cdn.itbob.cn/img/article/053/55.png" alt="55"></p><p>实际上我们最开始得到的 <code>$_ts</code> 值，是经过了二次处理的，我们以第一个 <code>_$sX._$Xb</code> 为例，直接搜索 <code>_$sX._$Xb</code>，可以发现这么一个地方：</p><p><img src="https://cdn.itbob.cn/img/article/053/56.png" alt="56"></p><p>很明显这里给  <code>_$sX._$Xb</code> 重新赋值了一遍，我们可以看到等号右边，先取了一次 <code>_$sX._$Xb</code>，其值为 <code>_$Rm</code>，这和我们初始 <code>$_ts</code> 里面对应的值是一样的，然后我们就得再看看 <code>_$sX[&quot;_$Rm&quot;]</code> 又是何方神圣，直接搜索发现是开头赋值了一个方法，通过调用这个方法来生成新的值：</p><p><img src="https://cdn.itbob.cn/img/article/053/57.png" alt="57"></p><p>另外其他三个值也是同样的套路，赋值的代码分别为：</p><pre><code class="hljs javascript">_$sX._$Xb = _$sX[_$sX._$Xb](_$BH, _$DP);_$sX._$oI = _$sX[_$sX._$oI](_$ZJ, _$DS)_$sX._$EN = _$sX[_$sX._$EN]();_$sX._$D9 = _$sX[_$sX._$D9](_$iL);</code></pre><p>实际上应该是：</p><pre><code class="hljs javascript">_$sX._$Xb = _$sX[<span class="hljs-string">&quot;_$Rm&quot;</span>](_$BH, _$DP);_$sX._$oI = _$sX[<span class="hljs-string">&quot;_$Nw&quot;</span>](_$ZJ, _$DS)_$sX._$EN = _$sX[<span class="hljs-string">&quot;_$Uh&quot;</span>]();_$sX._$D9 = _$sX[<span class="hljs-string">&quot;_$ci&quot;</span>](_$iL);</code></pre><p>进一步来说，实际上是：</p><pre><code class="hljs javascript">_$sX._$Xb = _$1k(_$BH, _$DP);_$sX._$oI = _$jH(_$ZJ, _$DS)_$sX._$EN = _$9M();_$sX._$D9 = _$oL(_$iL);</code></pre><p>静态分析没问题，我们可以先固定下来，但是实际应用当中这些值都是动态的，那我们应该怎么处理呢？先来多看几个对比一下找找规律：</p><p><img src="https://cdn.itbob.cn/img/article/053/58.png" alt="58"></p><p><img src="https://cdn.itbob.cn/img/article/053/59.png" alt="59"></p><p>可以发现每次对应的位次都不一样，但是实际上相同位置的方法点进去都是一样的，也就是说，变的只有方法名和变量名，实现的逻辑是不变的，所以我们只要知道了这四个值分别对应的位置，就能够拿到正确的值，在本地，我们就可以这样做：</p><p>1、先利用正则匹配出这四个值，如：<code>[_$sX._$Xb, _$sX._$oI, _$sX._$EN, _$sX._$D9]</code>；</p><p><img src="https://cdn.itbob.cn/img/article/053/60.png" alt="60"></p><p>2、再匹配出 VM 代码开头的 20 个赋值的语句，如：<code>_$sX._$RH = _$wI; _$sX._$i5 = _$n5;</code> 等；</p><p><img src="https://cdn.itbob.cn/img/article/053/61.png" alt="61"></p><p>3、然后通过 <code>$_ts</code> 取这四个值对应的值，相当于：<code>_$sX._$Xb = _$ts._$Xb = _$Rm</code>；然后再找这四个值所定义的方法在 20 个赋值语句中的位置，相当于：查找 <code>_$sX._$Rm = _$1k; </code> 在 20 个赋值语句中的位置为 7（索引从 0 开始）</p><p><img src="https://cdn.itbob.cn/img/article/053/62.png" alt="62"></p><p>4、我们知道了这四个方法在 20 个赋值语句中的位置，那么我们直接匹配本地对应位置的名称，进行动态替换即可，当然前提是咱们本地已经扣了一套代码出来了：</p><p><img src="https://cdn.itbob.cn/img/article/053/63.png" alt="63"></p><p><img src="https://cdn.itbob.cn/img/article/053/64.png" alt="64"></p><p>经过这样处理后，就能够保证这四个值的准确性了。</p><h4><span id="qi-ta-yong-dao-ts-zhi-de-di-fang">其他用到 $_ts 值的地方</span></h4><p>除了上面说的 20 位数组里用到了 4 个 <code>$_ts</code> 的值以外，还有其他地方有 7 个值也用到了，直接搜索就能定位，这 7 个值相对较简单，每次都是固定取 <code>$_ts</code> 里面的第 2、3、4、15、16、17、19 位的值，同样的，找到对应位置，进行动态替换即可：</p><p><img src="https://cdn.itbob.cn/img/article/053/65.png" alt="65"></p><h3><span id="zhu-yi-shi-xiang">注意事项</span></h3><p>特别注意 VM 代码开头，会直接调用执行一些方法，某些变量的值就是通过这些方法生成的，当你一步一步跟的时候发现某些参数不对，或者没有，那么就得注意开头这些方法了，可能一开始就已经生成了。</p><p><img src="https://cdn.itbob.cn/img/article/053/66.png" alt="66"></p><h3><span id="hou-zhui-mmewmd-sheng-cheng-luo-ji">后缀 MmEwMD 生成逻辑</span></h3><p>后续的其他 XHR 请求中，都带有一个后缀，这个后缀的值同样是由 JS 生成的，每次都会变化，当然不同网站，后缀名不一定都是一样的，本例中是 <code>MmEwMD</code>，先下一个 XHR 断点，当 XHR 请求中包含了 <code>MmEwMD=</code> 时就断下，然后刷新网页：</p><p><img src="https://cdn.itbob.cn/img/article/053/67.png" alt="67"></p><p>可以看到后传入 <code>l.open()</code> 的 URL 还是正常的，断下后到 <code>l.send()</code> 就带有后缀了，再看 <code>l.open()</code> 其实就是 <code>xhr.open()</code>，明显和正常的有区别，同样这个方法也在 VM 代码里，应该是重写了方法，可以和正常的做对比：</p><p><img src="https://cdn.itbob.cn/img/article/053/68.png" alt="68"></p><p>跟到 VM 代码里去看看，经过了 <code>_$sd(arguments[1])</code> 方法就变成了带有后缀的完整链接了：</p><p><img src="https://cdn.itbob.cn/img/article/053/69.png" alt="69"></p><p>跟进 <code>_$sd</code> 方法，前面都是对 url 做一些处理，后面有个进入第 779 号控制流的流程，实际上就是原来我们生成 Cookie 的步骤，跟一下就行了。</p><p><img src="https://cdn.itbob.cn/img/article/053/70.png" alt="70"></p><h2><span id="shan-yong-watch-gen-zong-gong-neng">善用 Watch 跟踪功能</span></h2><p><img src="https://cdn.itbob.cn/img/article/053/71.png" alt="71"></p><p>开发者工具的 Watch 功能能够持续跟踪某个变量的值，对于这种控制流很多的情况，设置相应的变量跟踪，能够让你知道你现在处于哪个控制流中，以及生成的数组的变化，不至于跟着跟着不知道到哪一步了。</p><h2><span id="jie-guo-yan-zheng">结果验证</span></h2><p>如果整个流程没问题，代码也扣得正确，携带正确的 Cookie 和正确的后缀，就能成功访问：</p><p><img src="https://cdn.itbob.cn/img/article/053/72.png" alt="72"></p><p><img src="https://cdn.itbob.cn/img/article/053/73.png" alt="73"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/javascript_reverse.png&quot; alt=&quot;javascript_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>AST 脱混淆实战，某 ICP 备案号查询接口 jsjiami v6 分析</title>
    <link href="https://www.itbob.cn/article/052/"/>
    <id>https://www.itbob.cn/article/052/</id>
    <published>2022-05-25T06:01:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/ast.png" alt="ast"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#di-san-fang-gong-ju">第三方工具</a></li><li><a href="#zhua-bao-fen-xi">抓包分析</a></li><li><a href="#jia-mi-ding-wei">加密定位</a></li><li><a href="#ast-tuo-hun-yao">AST 脱混淆</a><ul><li><a href="#wen-jian-jie-gou">文件结构</a></li><li><a href="#jie-mi-han-shu-huan-yuan">解密函数还原</a></li><li><a href="#da-dui-xiang-huan-yuan">大对象还原</a><ul><li><a href="#zi-fu-chuan-huan-yuan">字符串还原</a></li><li><a href="#er-xiang-shi-ji-suan-ti-huan">二项式计算替换</a></li><li><a href="#fang-fa-diao-yong-huan-yuan">方法调用还原</a></li></ul></li><li><a href="#switch-case-fan-kong-zhi-liu-ping-tan-hua">switch-case 反控制流平坦化</a></li><li><a href="#qi-ta-xi-jie-huan-yuan">其他细节还原</a></li></ul></li><li><a href="#wan-zheng-dai-ma">完整代码</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：站 Z 之家网站 ICP 备案号查询</li><li>主页：<code>aHR0cDovL2ljcC5jaGluYXouY29tLw==</code></li><li>接口：<code>aHR0cDovL2ljcC5jaGluYXouY29tL2hvbWUvR2V0UGVyaW1pdEJ5SG9zdA==</code></li><li>逆向参数：<code>hostToken</code>、<code>permitToken</code></li></ul><p>本次主要是 AST 解混淆实战，本例中的 JS 混淆方式是 sojson 旗下的 jsjiami v6 版本，感兴趣的可以去官网体验一下：<a href="https://www.jsjiami.com/">https://www.jsjiami.com/</a> ，如果你还不了解 AST，可以先看看上期的文章（非常详细）：<a href="https://www.itbob.cn/article/051/">《逆向进阶，利用 AST 技术还原 JavaScript 混淆代码》</a>，本文部分 AST 还原代码直接使用了上期文章中的代码，所以细节方面不再赘述，有疑问的地方可以参考参考上期文章。</p><h2><span id="di-san-fang-gong-ju">第三方工具</span></h2><p>逆向领域大佬云集，市面上已经有很多大佬写好的解混淆工具了，除了我们自己手动去写 AST 解析代码以外，有时候直接使用工具会更加方便，当然并没有十全十美的工具，不过大部分情况下都能成功解混淆的，以下工具值得去体验一下：</p><ul><li>蔡老板一键还原 OB 混淆：<a href="https://github.com/Tsaiboss/decodeObfuscator">https://github.com/Tsaiboss/decodeObfuscator</a></li><li>哲哥 AST 混淆还原框架：<a href="https://github.com/sml2h3/ast_tools">https://github.com/sml2h3/ast_tools</a></li><li>V 神 Chrome 插件，内置 AST 混淆还原：<a href="https://github.com/cilame/v_jstools">https://github.com/cilame/v_jstools</a></li><li>jsjiami v6 专用解密工具：<a href="https://github.com/NXY666/JsjiamiV6-Decryptor">https://github.com/NXY666/JsjiamiV6-Decryptor</a></li></ul><h2><span id="zhua-bao-fen-xi">抓包分析</span></h2><p>进入主题，首先抓包看看，来到 ICP 备案查询页面，查询结果中，其他信息都可以直接在相应的 html 源码中找到，只有这个备案号是通过接口传过来的，对应的请求和相关加密参数如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/052/01.png" alt="01"></p><p><img src="https://cdn.itbob.cn/img/article/052/02.png" alt="02"></p><h2><span id="jia-mi-ding-wei">加密定位</span></h2><p>直接搜索关键字 <code>hostToken</code> 或者 <code>permitToken</code> 即可定位：</p><p><img src="https://cdn.itbob.cn/img/article/052/03.png" alt="03"></p><p><img src="https://cdn.itbob.cn/img/article/052/04.png" alt="04"></p><p>关键代码：</p><pre><code class="hljs javascript"><span class="hljs-string">&#x27;data&#x27;</span>: &#123;    <span class="hljs-string">&#x27;kw&#x27;</span>: kw,    <span class="hljs-string">&#x27;hostToken&#x27;</span>: _0x791532[<span class="hljs-string">&#x27;IIPmq&#x27;</span>](generateHostKey, kw),    <span class="hljs-string">&#x27;permitToken&#x27;</span>: _0x791532[_0x404f(<span class="hljs-string">&#x27;‫1df&#x27;</span>, <span class="hljs-string">&#x27;7Gn4&#x27;</span>)](generateWordKey, kw)&#125;</code></pre><p>这里的混淆可以手动跟一下，还原后如下：</p><pre><code class="hljs javascript"><span class="hljs-string">&#x27;data&#x27;</span>: &#123;    <span class="hljs-string">&#x27;kw&#x27;</span>: kw,    <span class="hljs-string">&#x27;hostToken&#x27;</span>: generateHostKey(kw),    <span class="hljs-string">&#x27;permitToken&#x27;</span>: generateWordKey(kw)&#125;</code></pre><p><code>kw</code> 是查询的域名，有用的就是 <code>generateHostKey()</code> 和 <code>generateWordKey()</code> 两个方法了，跟进去看，代码经过了 jsjiami v6 混淆：</p><p><img src="https://cdn.itbob.cn/img/article/052/05.png" alt="05"></p><p><img src="https://cdn.itbob.cn/img/article/052/06.png" alt="06"></p><p><img src="https://cdn.itbob.cn/img/article/052/07.png" alt="07"></p><h2><span id="ast-tuo-hun-yao">AST 脱混淆</span></h2><p>jsjiami 混淆的特征其实和 OB 混淆是类似的：</p><ol><li>一般由一个大数组或者含有大数组的函数、一个数组位移操作的自执行函数、一个解密函数和加密后的函数四部分组成；</li><li>函数名和变量名通常以 _0x 或者 0x 开头，后接 1~6 位数字或字母组合；</li><li>数组位移操作的自执行函数里，有明显的 push、shift 关键字。</li></ol><p>本例中，<code>generateHostKey()</code> 方法在 <code>commo.js</code> 里，<code>generateWordKey()</code> 方法在 <code>generatetoken.js</code> 里，结构如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/052/08.png" alt="08"></p><p>观察 <code>generatetoken.js</code> 文件，可以发现这里面也有 <code>commo.js</code> 里面的 <code>generateHostKey()</code> 和 <code>getRandom()</code> 方法，从方法名来看貌似是重复了，实际上混淆还原后方法是一样的，所以这里我们只需要还原 <code>generatetoken.js</code> 就可以了。</p><h3><span id="wen-jian-jie-gou">文件结构</span></h3><ul><li>混淆 JS 文件：<code>generatetoken.js</code></li><li>AST 还原代码：<code>generatetokenAst.js</code></li><li>还原后的代码：<code>generatetokenNew.js</code></li></ul><h3><span id="jie-mi-han-shu-huan-yuan">解密函数还原</span></h3><p>在原来混淆后的 JS 里，解密函数是 <code>_0x530e</code>，首先观察整个 JS，调用了很多次解密函数，类似于：<code>_0x530e('1', '7XEq')</code>。</p><p>注意这里代码里面有一些特殊字符，类似于 <code>RLE</code>、<code>RLO</code> 之类的，如果在 VSCode 打开是一些 <code>U+202B</code>、<code>U+202E</code> 的字符，实际上这是 RTLO (Right-to-Left Override) 字符，<code>U+202B</code> 和 <code>U+202E</code> 的意思分别是根据内存顺序从左至右和从右至左显示字符，感兴趣的可以网上搜索了解一下。这里并不影响我们进行还原操作。但是如果直接复制过来的话就会导致前后文显示的顺序不对，所以本文中为了方便描述，粘贴的部分代码就手动去掉了这些字符。</p><p><img src="https://cdn.itbob.cn/img/article/052/09.png" alt="09"></p><p><img src="https://cdn.itbob.cn/img/article/052/10.png" alt="10"></p><p>所以第一步我们要还原一下解密函数，把所有 <code>_0x530e</code> 调用的地方直接替换成实际值，首先需要将大数组、自执行函数、加密函数和解密函数分割开，将代码放到 <a href="http://astexplorer.net">astexplorer.net</a> 看一下，也就是将 body 的前四部分和后面剩余部分分割开来，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/052/11.png" alt="11"></p><p>分割代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<span class="hljs-keyword">const</span> parse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>).parse;<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)<span class="hljs-comment">// 导入混淆代码并解析为 AST</span><span class="hljs-keyword">const</span> oldCode = fs.readFileSync(<span class="hljs-string">&quot;generatetoken.js&quot;</span>, &#123;<span class="hljs-attr">encoding</span>: <span class="hljs-string">&quot;utf-8&quot;</span>&#125;);<span class="hljs-keyword">const</span> astCode = parse(oldCode);<span class="hljs-comment">// 获取整个 AST 节点的长度</span><span class="hljs-keyword">let</span> astCodeLength = astCode.program.body.length<span class="hljs-comment">// 获取解密函数的名字 也就是 _0x530e</span><span class="hljs-keyword">let</span> decryptFunctionName = astCode.program.body[<span class="hljs-number">3</span>].id.name<span class="hljs-comment">// 分割加密函数和解密函数，即 body 的前四部分和后面剩余部分</span><span class="hljs-keyword">let</span> decryptFunction = astCode.program.body.slice(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>)<span class="hljs-keyword">let</span> encryptFunction = astCode.program.body.slice(<span class="hljs-number">4</span>, astCodeLength)<span class="hljs-comment">// 获取加密函数和解密函数的方法多种多样，比如可以挨个取值并转换成 JS 代码</span><span class="hljs-comment">// 这样做就不需要将解密函数赋值给整个 AST 节点了</span><span class="hljs-comment">// let decryptFunction = &quot;&quot;;</span><span class="hljs-comment">// for(let i=0; i&lt;4; i++)&#123;</span><span class="hljs-comment">//     decryptFunction += generate(astCode.program.body[i], &#123;compact: true&#125;).code</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// eval(decryptFunction);</span></code></pre><p>在上面的获取加密函数和解密函数的代码中，方法不是唯一的，多种多样，比如直接循环取 body 并转换成 JS 代码，比如直接人工把大数组、自执行函数和解密函数三部分，拿出来放到一个新文件里，然后导出解密方法，后续直接调用也可以。</p><p>在本例中，拿到解密函数后，需要将其赋值给整个 AST 节点，然后再将整个 AST 节点转换成 JavaScript 代码，这里注意有可能会检测代码是否格式化，所以建议转换要加一个 <code>compact</code> 参数，避免格式化，转换完成后 <code>eval</code> 执行一下，让数组位移操作完成，然后我们就可以直接调用解密函数，即 <code>_0x530e()</code>。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 将解密函数赋值给整个 AST 节点</span>astCode.program.body = decryptFunction<span class="hljs-comment">// 将 AST 节点转换成 JS 代码，并 eval 执行一下</span>decryptFunction = generate(astCode, &#123;<span class="hljs-attr">compact</span>: <span class="hljs-literal">true</span>&#125;).code<span class="hljs-built_in">eval</span>(decryptFunction);<span class="hljs-comment">// 测试一下，直接调用 _0x530e 函数可以正确拿到结果</span><span class="hljs-comment">// 输出 split</span><span class="hljs-comment">// console.log(_0x530e(&#x27;‮b&#x27;, &#x27;Zp9G&#x27;))</span></code></pre><p>现在我们能直接调用解密函数 <code>_0x530e()</code> 了，接下来要做的就是怎么把混淆代码中所有调用 <code>_0x530e()</code> 的地方替换成真实值，在此之前，我们要把加密函数（<code>generateKey()</code>、<code>generateHostKey()</code>、<code>generateWordKey()</code> 和 <code>getRandom()</code>）赋值给整个 AST 节点，此时整个节点就没有大数组、自执行函数和解密函数了，解密函数 <code>_0x530e()</code> 已经被写入内存，所以后面不影响我们调用。</p><p>老样子，还是先在 <a href="http://astexplorer.net">astexplorer.net</a> 看一下调用 <code>_0x530e()</code> 的地方，以 <code>_0x530e('b', 'Zp9G')</code> 为例，其真实值应该是 <code>split</code>，对比一下替换前后的结构，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/052/12.png" alt="12"></p><p><img src="https://cdn.itbob.cn/img/article/052/13.png" alt="13"></p><p>可以看到节点由原来的 <code>CallExpression</code> 变成了 <code>StringLiteral</code>，所以我们可以遍历 <code>CallExpression</code>，如果函数名为解密函数名，那就通过 <code>path.toString()</code> 方法获取节点源码，也就类似 <code>_0x530e('b', 'Zp9G')</code> 的源码，然后 <code>eval</code> 执行一下获取其真实值，再使用 <code>types.stringLiteral()</code> 构建 <code>StringLiteral</code> 节点，最后通过 <code>path.replaceInline()</code> 方法替换节点，遍历代码如下：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 将加密函数赋值给整个 AST 节点，此时整个节点就没有大数组、自执行函数和解密函数了</span>astCode.program.body = encryptFunction<span class="hljs-comment">// 调用解密函数，直接计算出类似以下方法的值并替换</span><span class="hljs-comment">// 混淆代码：_0x530e(&#x27;‮b&#x27;, &#x27;Zp9G&#x27;)</span><span class="hljs-comment">// 还原后：split</span><span class="hljs-keyword">const</span> visitor1 = &#123;    <span class="hljs-function"><span class="hljs-title">CallExpression</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">if</span> (path.node.callee.name === decryptFunctionName &amp;&amp; path.node.arguments.length === <span class="hljs-number">2</span>)&#123;            path.replaceInline(types.stringLiteral(<span class="hljs-built_in">eval</span>(path.toString())))        &#125;    &#125;&#125;<span class="hljs-comment">// 遍历节点</span>traverse(astCode, visitor1)<span class="hljs-comment">// 将 AST 节点转换成 JS 代码并写入到新文件里</span><span class="hljs-keyword">const</span> result = generate(astCode, &#123;<span class="hljs-attr">concise</span>:<span class="hljs-literal">true</span>&#125;).codefs.writeFile(<span class="hljs-string">&quot;./generatetokenNew.js&quot;</span>, result, (<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(err)&#125;))</code></pre><p>自此，第一步的解密函数还原就完成了，可以看一下还原前后的对比，如下图所示浅蓝色标记的地方，所有调用 <code>_0x530e()</code> 的地方都被还原了：</p><p><img src="https://cdn.itbob.cn/img/article/052/14.png" alt="14"></p><h3><span id="da-dui-xiang-huan-yuan">大对象还原</span></h3><p>初步还原后我们的代码里就只剩下以下四个方法：</p><ul><li><code>generateKey()</code></li><li><code>generateHostKey()</code></li><li><code>generateWordKey()</code></li><li><code>getRandom()</code></li></ul><p>再观察代码，发现每个方法一开始都有个大的对象，他们分别是：</p><ul><li><code>_0x3b79c6</code></li><li><code>_0x278b2d</code></li><li><code>_0x4115c4</code></li><li><code>_0xd8ec33</code></li></ul><p>后续的代码也在不断调用这个对象的方法，比如 <code>_0x3b79c6[&quot;esdtg&quot;](_0x2e5848[&quot;length&quot;], 0x4)</code> 实际上就是 <code>_0x2e5848[&quot;length&quot;] != 0x4</code>，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/052/15.png" alt="15"></p><p>首先我们将这四个大的对象单独提取出来，还是保持原来的键值对样式，提取完成后删除这两个节点，遍历代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> functionName = &#123;    <span class="hljs-string">&quot;_0x3b79c6&quot;</span>: &#123;&#125;,    <span class="hljs-string">&quot;_0x278b2d&quot;</span>: &#123;&#125;,    <span class="hljs-string">&quot;_0x4115c4&quot;</span>: &#123;&#125;,    <span class="hljs-string">&quot;_0xd8ec33&quot;</span>: &#123;&#125;&#125;<span class="hljs-comment">// 单独提取出四个大对象</span><span class="hljs-keyword">const</span> visitor2 = &#123;    <span class="hljs-function"><span class="hljs-title">VariableDeclarator</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> functionName)&#123;            <span class="hljs-keyword">if</span> (path.node &amp;&amp; path.node.id.name == key) &#123;                <span class="hljs-keyword">const</span> properties = path.node.init.properties                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;properties.length; i++)&#123;                    functionName[key][properties[i].key.value] = properties[i].value                &#125;                <span class="hljs-comment">// 写入对象后就可以删除该节点了</span>                path.remove()            &#125;        &#125;    &#125;&#125;</code></pre><p>这里要注意，大的对象里面，有 <code>+</code>、<code>-</code>、<code>==</code> 之类的二项式计算，也有直接为字符串的，还有变成函数调用的，如下所示：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> _0x3b79c6 = &#123;    <span class="hljs-string">&#x27;MuRlB&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_0x3ca134, _0x50ee94</span>) </span>&#123;        <span class="hljs-keyword">return</span> _0x3ca134 + _0x50ee94;    &#125;,     <span class="hljs-string">&#x27;Ucwyj&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_0x32bfa3, _0x3b191b</span>) </span>&#123;        <span class="hljs-keyword">return</span> _0x32bfa3(_0x3b191b);    &#125;,     <span class="hljs-string">&#x27;YrYQW&#x27;</span>: <span class="hljs-string">&#x27;#IpValue&#x27;</span>&#125;</code></pre><p>针对不同的情况有不同的处理方法，同时还要注意传参和 return 返回的参数位置，不要还原后把 <code>a - b</code> 搞成 <code>b - a</code> 了，当然在本例中传入和返回的顺序是一样的，就不需要考虑这个问题。</p><h4><span id="zi-fu-chuan-huan-yuan">字符串还原</span></h4><p>首先来看字符串，有以下几种情况：</p><ul><li>以 <code>_0x3b79c6['YrYQW']</code> 为例，实际上其值为字符串 <code>'#IpValue'</code>，观察其结构，是一个 <code>MemberExpression</code>，在一个列表里；</li><li>以 <code>_0x278b2d['pjbyX']</code> 为例，实际上其值为字符串 <code>'3|2|1|4|5|0|6'</code>，观察其结构，是一个 <code>MemberExpression</code>，在一个字典里；</li><li>以 <code>_0x278b2d['CnTaO']</code> 为例，虽然也是一个 <code>MemberExpression</code>，也在一个字典里。但实际上是二项式计算，所以要排除在外。</li></ul><p><img src="https://cdn.itbob.cn/img/article/052/16.png" alt="16"></p><p><img src="https://cdn.itbob.cn/img/article/052/17.png" alt="17"></p><p><img src="https://cdn.itbob.cn/img/article/052/18.png" alt="18"></p><p>所以我们在写遍历代码时，同时要注意这三种情况，满足条件后直接取原来大对象对应的节点进行替换即可，遍历代码如下所示：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 函数替换，字符串替换：将类似 _0x3b79c6[&#x27;YrYQW&#x27;] 变成 &#x27;#IpValue&#x27;</span><span class="hljs-keyword">const</span> visitor3 = &#123;    <span class="hljs-function"><span class="hljs-title">MemberExpression</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> functionName)&#123;            <span class="hljs-keyword">if</span> (path.node.object &amp;&amp; path.node.object.name == key &amp;&amp; path.inList ) &#123;                path.replaceInline(functionName[key][path.node.property.value])            &#125;            <span class="hljs-keyword">if</span> (path.node.object &amp;&amp; path.node.object.name == key &amp;&amp; path.parent.property &amp;&amp; path.parent.property.value == <span class="hljs-string">&quot;split&quot;</span>) &#123;                path.replaceInline(functionName[key][path.node.property.value])            &#125;        &#125;    &#125;&#125;</code></pre><h4><span id="er-xiang-shi-ji-suan-ti-huan">二项式计算替换</span></h4><p>再来看看二项式计算的情况，以 <code>_0x278b2d['CnTaO'](_0x691267[&quot;length&quot;], 0x1)</code> 为例，实际上是做减法运算，即 <code>_0x691267[&quot;length&quot;] - 0x1</code>，看一下替换前后对比：</p><p><img src="https://cdn.itbob.cn/img/article/052/19.png" alt="19"></p><p><img src="https://cdn.itbob.cn/img/article/052/20.png" alt="20"></p><p>对于这种情况，我们可以直接提取两个参数，然后提取大对象里对应方法的操作符，然后将参数和操作符直接连接起来组成新的节点（<code>binaryExpression</code>）并替换即可，遍历代码如下：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 函数替换，二项式计算：将类似 _0x278b2d[&#x27;CnTaO&#x27;](_0x691267[&quot;length&quot;], 0x1) 变成 _0x691267[&quot;length&quot;] - 0x1</span><span class="hljs-keyword">const</span> visitor4 = &#123;    <span class="hljs-function"><span class="hljs-title">CallExpression</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> functionName) &#123;            <span class="hljs-keyword">if</span> (path.node.callee &amp;&amp; path.node.callee.object &amp;&amp; path.node.callee.object.name == key) &#123;                <span class="hljs-keyword">let</span> func = functionName[key][path.node.callee.property.value]                <span class="hljs-keyword">if</span> (func.body.body[<span class="hljs-number">0</span>].argument.type == <span class="hljs-string">&quot;BinaryExpression&quot;</span>) &#123;                    <span class="hljs-keyword">let</span> operator = func.body.body[<span class="hljs-number">0</span>].argument.operator                    <span class="hljs-keyword">let</span> left = path.node.arguments[<span class="hljs-number">0</span>]                    <span class="hljs-keyword">let</span> right = path.node.arguments[<span class="hljs-number">1</span>]                    path.replaceInline(types.binaryExpression(operator, left, right))                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h4><span id="fang-fa-diao-yong-huan-yuan">方法调用还原</span></h4><p>以 <code>_0x4115c4[&quot;PJbSm&quot;](getRandom, 0x64, 0x3e7)</code> 为例，实际上是 <code>getRandom(0x64, 0x3e7)</code>，看一下替换前后对比：</p><p><img src="https://cdn.itbob.cn/img/article/052/21.png" alt="21"></p><p><img src="https://cdn.itbob.cn/img/article/052/22.png" alt="22"></p><p>对于这种情况，传入的第一个参数为方法名称，后面的都是参数，那么可以直接取第一个元素为方法名称，使用 <code>slice(1)</code> 方法取后面所有的参数（因为后面的参数个数是不一定的），然后构造新的节点（<code>callExpression</code>）并替换即可，这部分遍历代码可以和前面二项式的替换相结合，代码如下：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 函数替换，二项式计算：将类似 _0x278b2d[&#x27;CnTaO&#x27;](_0x691267[&quot;length&quot;], 0x1) 变成 _0x691267[&quot;length&quot;] - 0x1</span><span class="hljs-comment">// 函数替换，方法调用：将类似 _0x4115c4[&quot;PJbSm&quot;](getRandom, 0x64, 0x3e7) 变成 getRandom(0x64, 0x3e7)</span><span class="hljs-keyword">const</span> visitor4 = &#123;    <span class="hljs-function"><span class="hljs-title">CallExpression</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> functionName) &#123;            <span class="hljs-keyword">if</span> (path.node.callee &amp;&amp; path.node.callee.object &amp;&amp; path.node.callee.object.name == key) &#123;                <span class="hljs-keyword">let</span> func = functionName[key][path.node.callee.property.value]                <span class="hljs-keyword">if</span> (func.body.body[<span class="hljs-number">0</span>].argument.type == <span class="hljs-string">&quot;BinaryExpression&quot;</span>) &#123;                    <span class="hljs-keyword">let</span> operator = func.body.body[<span class="hljs-number">0</span>].argument.operator                    <span class="hljs-keyword">let</span> left = path.node.arguments[<span class="hljs-number">0</span>]                    <span class="hljs-keyword">let</span> right = path.node.arguments[<span class="hljs-number">1</span>]                    path.replaceInline(types.binaryExpression(operator, left, right))                &#125;                <span class="hljs-keyword">if</span> (func.body.body[<span class="hljs-number">0</span>].argument.type == <span class="hljs-string">&quot;CallExpression&quot;</span>) &#123;                    <span class="hljs-keyword">let</span> identifier = path.node.arguments[<span class="hljs-number">0</span>]                    <span class="hljs-keyword">let</span> <span class="hljs-built_in">arguments</span> = path.node.arguments.slice(<span class="hljs-number">1</span>)                    path.replaceInline(types.callExpression(identifier, <span class="hljs-built_in">arguments</span>))                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>自此，第二步的大对象还原就完成了，可以看一下还原前后的对比，如下图所示浅蓝色标记的地方，所有调用四个大对象（<code>_0x3b79c6</code>、<code>_0x278b2d</code>、<code>_0x4115c4</code>、<code>_0xd8ec33</code>）的地方都被还原了：</p><p><img src="https://cdn.itbob.cn/img/article/052/23.png" alt="23"></p><h3><span id="switch-case-fan-kong-zhi-liu-ping-tan-hua">switch-case 反控制流平坦化</span></h3><p>经过前面几步的还原之后，我们发现 <code>generateHostKey()</code>、<code>generateWordKey()</code>、<code>getRandom()</code> 方法里都有一个 <code>switch-case</code> 的控制流，关于反控制流平坦化的讲解在我上期文章有很详细的介绍，不理解的可以看看上期文章，此处也不再赘述了，直接贴代码了：</p><pre><code class="hljs javascript"><span class="hljs-comment">// switch-case 反控制流平坦化</span><span class="hljs-keyword">const</span> visitor5 = &#123;    <span class="hljs-function"><span class="hljs-title">WhileStatement</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-comment">// switch 节点</span>        <span class="hljs-keyword">let</span> switchNode = path.node.body.body[<span class="hljs-number">0</span>];        <span class="hljs-comment">// switch 语句内的控制流数组名，本例中是 _0x28073a、_0x2efb35、_0x187fb8</span>        <span class="hljs-keyword">let</span> arrayName = switchNode.discriminant.object.name;        <span class="hljs-comment">// 获取控制流数组绑定的节点</span>        <span class="hljs-keyword">let</span> bindingArray = path.scope.getBinding(arrayName);        <span class="hljs-comment">// 获取节点整个表达式的参数、分割方法、分隔符</span>        <span class="hljs-keyword">let</span> init = bindingArray.path.node.init;        <span class="hljs-keyword">let</span> object = init.callee.object.value;        <span class="hljs-keyword">let</span> property = init.callee.property.value;        <span class="hljs-keyword">let</span> argument = init.arguments[<span class="hljs-number">0</span>].value;        <span class="hljs-comment">// 模拟执行 &#x27;3|2|1|4|5|0|6&#x27;[&#x27;split&#x27;](&#x27;|&#x27;) 语句</span>        <span class="hljs-keyword">let</span> array = object[property](argument)        <span class="hljs-comment">// 也可以直接取参数进行分割，方法不通用，比如分隔符换成 , 就不行了</span>        <span class="hljs-comment">// let array = init.callee.object.value.split(&#x27;|&#x27;);</span>        <span class="hljs-comment">// switch 语句内的控制流自增变量名，本例中是 _0x38c69e、_0x396880、_0x3b3dc7</span>        <span class="hljs-keyword">let</span> autoIncrementName = switchNode.discriminant.property.argument.name;        <span class="hljs-comment">// 获取控制流自增变量名绑定的节点</span>        <span class="hljs-keyword">let</span> bindingAutoIncrement = path.scope.getBinding(autoIncrementName);        <span class="hljs-comment">// 可选择的操作：删除控制流数组绑定的节点、自增变量名绑定的节点</span>        bindingArray.path.remove();        bindingAutoIncrement.path.remove();        <span class="hljs-comment">// 储存正确顺序的控制流语句</span>        <span class="hljs-keyword">let</span> replace = [];        <span class="hljs-comment">// 遍历控制流数组，按正确顺序取 case 内容</span>        array.forEach(<span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;                <span class="hljs-keyword">let</span> consequent = switchNode.cases[index].consequent;                <span class="hljs-comment">// 如果最后一个节点是 continue 语句，则删除 ContinueStatement 节点</span>                <span class="hljs-keyword">if</span> (types.isContinueStatement(consequent[consequent.length - <span class="hljs-number">1</span>])) &#123;                    consequent.pop();                &#125;                <span class="hljs-comment">// concat 方法拼接多个数组，即正确顺序的 case 内容</span>                replace = replace.concat(consequent);            &#125;        );        <span class="hljs-comment">// 替换整个 while 节点，两种方法都可以</span>        path.replaceWithMultiple(replace);        <span class="hljs-comment">// path.replaceInline(replace);</span>    &#125;&#125;</code></pre><h3><span id="qi-ta-xi-jie-huan-yuan">其他细节还原</span></h3><p>到这里其实大部分混淆都已经还原了，已经很容易分析其逻辑了，还剩下一些细节，我们也还原一下，主要有以下细节：</p><ul><li>十六进制、Unicode 编码等，转正常字符；</li><li>对象属性还原，比如 <code>_0x3cbc20['length']</code> 转换成 <code>_0x3cbc20.length</code>；</li><li>表达式还原，比如 <code>!![]</code> 直接计算成 true；</li><li>删除未引用的变量，比如 <code>_0xodD= &quot;jsjiami.com.v6&quot;;</code>；</li><li>删除冗余逻辑代码，只保留 if 为 true 的。</li></ul><p>这些还原代码在我上期文章有详细讲过，结合代码，在 <a href="http://astexplorer.net">astexplorer.net</a> 对照其结构看，也能理解，同样也不赘述了，直接贴代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor5 = &#123;    <span class="hljs-comment">// 十六进制、Unicode 编码等，转正常字符</span>    <span class="hljs-string">&quot;StringLiteral|NumericLiteral&quot;</span>(path)&#123;        <span class="hljs-keyword">delete</span> path.node.extra;    &#125;,    <span class="hljs-comment">// _0x3cbc20[&quot;length&quot;] 转换成 _0x3cbc20.length</span>    <span class="hljs-function"><span class="hljs-title">MemberExpression</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">if</span> (path.node.property.type == <span class="hljs-string">&quot;StringLiteral&quot;</span>) &#123;            path.node.computed = <span class="hljs-literal">false</span>            path.node.property = types.identifier(path.node.property.value)        &#125;    &#125;,    <span class="hljs-comment">// 表达式还原，!![] 直接计算成 true</span>    <span class="hljs-string">&quot;BinaryExpression|UnaryExpression&quot;</span>(path) &#123;        <span class="hljs-keyword">let</span> &#123;confident, value&#125; = path.evaluate()        <span class="hljs-keyword">if</span> (confident)&#123;            path.replaceInline(types.valueToNode(value))        &#125;    &#125;,    <span class="hljs-comment">// 删除未引用的变量，比如 _0xodD = &quot;jsjiami.com.v6&quot;;</span>    <span class="hljs-function"><span class="hljs-title">AssignmentExpression</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">let</span> binding = path.scope.getBinding(path.node.left.name);        <span class="hljs-keyword">if</span> (!binding) &#123;            path.remove();        &#125;    &#125;&#125;<span class="hljs-comment">// 删除冗余逻辑代码，只保留 if 为 true 的</span><span class="hljs-keyword">const</span> visitor6 = &#123;    <span class="hljs-function"><span class="hljs-title">IfStatement</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">if</span>(path.node.test.type == <span class="hljs-string">&quot;BooleanLiteral&quot;</span>) &#123;            <span class="hljs-keyword">if</span>(path.node.test.value) &#123;                path.replaceInline(path.node.consequent.body)            &#125; <span class="hljs-keyword">else</span> &#123;                path.replaceInline(path.node.alternate.body)            &#125;        &#125;    &#125;&#125;</code></pre><p>自此 jajiami v6 混淆就还原完毕了，还原前后对比一下，代码量缩短了很多，逻辑也更加清楚了，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/052/24.png" alt="24"></p><p>最后结合 Python 代码，携带生成的 <code>hostToken</code> 和 <code>permitToken</code>，成功拿到备案号：</p><p><img src="https://cdn.itbob.cn/img/article/052/25.png" alt="25"></p><h2><span id="wan-zheng-dai-ma">完整代码</span></h2><p>原混淆代码 <code>generatetoken.js</code>、AST 脱混淆代码 <code>generatetokenAst.js</code>、还原后的代码 <code>generatetokenNew.js</code>，以及 Python 测试代码均在 GitHub，均有详细注释，欢迎 Star。所有内容仅供学习交流，严禁用于商业用途、非法用途，否则由此产生的一切后果均与作者无关，在仓库中下载的文件学习完毕之后请于 24 小时内删除！</p><p>代码地址：<a href="https://github.com/TRHX/Python3-Spider-Practice">https://github.com/TRHX/Python3-Spider-Practice</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/ast.png&quot; alt=&quot;ast&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>逆向进阶，利用 AST 技术还原 JavaScript 混淆代码</title>
    <link href="https://www.itbob.cn/article/051/"/>
    <id>https://www.itbob.cn/article/051/</id>
    <published>2022-04-25T09:00:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/ast.png" alt="ast"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#shi-me-shi-ast">什么是 AST</a></li><li><a href="#ast-zai-bian-yi-zhong-de-wei-zhi">AST 在编译中的位置</a><ul><li><a href="#ci-fa-fen-xi">词法分析</a></li><li><a href="#yu-fa-fen-xi">语法分析</a></li><li><a href="#dai-ma-sheng-cheng">代码生成</a></li></ul></li><li><a href="#babel-jian-jie">Babel 简介</a><ul><li><a href="#babel-core">@babel/core</a></li><li><a href="#babel-parser">@babel/parser</a></li><li><a href="#babel-generator">@babel/generator</a></li><li><a href="#babel-traverse">@babel/traverse</a></li><li><a href="#babel-types">@babel/types</a></li></ul></li><li><a href="#chang-jian-hun-yao-huan-yuan">常见混淆还原</a><ul><li><a href="#zi-fu-chuan-huan-yuan">字符串还原</a></li><li><a href="#biao-da-shi-huan-yuan">表达式还原</a></li><li><a href="#shan-chu-wei-shi-yong-bian-liang">删除未使用变量</a></li><li><a href="#shan-chu-rong-yu-luo-ji-dai-ma">删除冗余逻辑代码</a></li><li><a href="#switch-case-fan-kong-zhi-liu-ping-tan-hua">switch-case 反控制流平坦化</a></li></ul></li><li><a href="#can-kao-zi-liao">参考资料</a></li><li><a href="#end">END</a></li></ul><!-- tocstop --><hr><h2><span id="shi-me-shi-ast">什么是 AST</span></h2><p>AST（Abstract Syntax Tree），中文抽象语法树，简称语法树（Syntax Tree），是源代码的抽象语法结构的树状表现形式，树上的每个节点都表示源代码中的一种结构。语法树不是某一种编程语言独有的，JavaScript、Python、Java、Golang 等几乎所有编程语言都有语法树。</p><p>小时候我们得到一个玩具，总喜欢把玩具拆解成一个一个小零件，然后按照我们自己的想法，把零件重新组装起来，一个新玩具就诞生了。而 JavaScript 就像一台精妙运作的机器，通过 AST 解析，我们也可以像童年时拆解玩具一样，深入了解 JavaScript 这台机器的各个零部件，然后重新按照我们自己的意愿来组装。</p><p>AST 的用途很广，IDE 的语法高亮、代码检查、格式化、压缩、转译等，都需要先将代码转化成 AST 再进行后续的操作，ES5 和 ES6 语法差异，为了向后兼容，在实际应用中需要进行语法的转换，也会用到 AST。AST 并不是为了逆向而生，但做逆向学会了 AST，在解混淆时可以如鱼得水。</p><p>AST 有一个在线解析网站：<a href="https://astexplorer.net/">https://astexplorer.net/</a> ，顶部可以选择语言、编译器、是否开启转化等，如下图所示，区域①是源代码，区域②是对应的 AST 语法树，区域③是转换代码，可以对语法树进行各种操作，区域④是转换后生成的新代码。图中原来的 Unicode 字符经过操作之后就变成了正常字符。</p><p>语法树没有单一的格式，选择不同的语言、不同的编译器，得到的结果也是不一样的，在 JavaScript 中，编译器有 Acorn、Espree、Esprima、Recast、Uglify-JS 等，使用最多的是 Babel，后续的学习也是以 Babel 为例。</p><p><img src="https://cdn.itbob.cn/img/article/051/01.png" alt="01"></p><h2><span id="ast-zai-bian-yi-zhong-de-wei-zhi">AST 在编译中的位置</span></h2><p>在编译原理中，编译器转换代码通常要经过三个步骤：词法分析（Lexical Analysis）、语法分析（Syntax Analysis）、代码生成（Code Generation），下图生动展示了这一过程：</p><p><img src="https://cdn.itbob.cn/img/article/051/02.png" alt="02"></p><h3><span id="ci-fa-fen-xi">词法分析</span></h3><p>词法分析阶段是编译过程的第一个阶段，这个阶段的任务是从左到右一个字符一个字符地读入源程序，然后根据构词规则识别单词，生成 token 符号流，比如 <code>isPanda('🐼')</code>，会被拆分成 <code>isPanda</code>，<code>(</code>，<code>'🐼'</code>，<code>)</code> 四部分，每部分都有不同的含义，可以将词法分析过程想象为不同类型标记的列表或数组。</p><p><img src="https://cdn.itbob.cn/img/article/051/03.gif" alt="03"></p><h3><span id="yu-fa-fen-xi">语法分析</span></h3><p>语法分析是编译过程的一个逻辑阶段，语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，比如“程序”，“语句”，“表达式”等，前面的例子中，<code>isPanda('🐼')</code> 就会被分析为一条表达语句 <code>ExpressionStatement</code>，<code>isPanda()</code> 就会被分析成一个函数表达式 <code>CallExpression</code>，<code>🐼</code> 就会被分析成一个变量 <code>Literal</code> 等，众多语法之间的依赖、嵌套关系，就构成了一个树状结构，即 AST 语法树。</p><p><img src="https://cdn.itbob.cn/img/article/051/04.gif" alt="04"></p><h3><span id="dai-ma-sheng-cheng">代码生成</span></h3><p>代码生成是最后一步，将 AST 语法树转换成可执行代码即可，在转换之前，我们可以直接操作语法树，进行增删改查等操作，例如，我们可以确定变量的声明位置、更改变量的值、删除某些节点等，我们将语句 <code>isPanda('🐼')</code> 修改为一个布尔类型的 <code>Literal</code>：<code>true</code>，语法树就有如下变化：</p><p><img src="https://cdn.itbob.cn/img/article/051/05.gif" alt="05"></p><h2><span id="babel-jian-jie">Babel 简介</span></h2><p>Babel 是一个 JavaScript 编译器，也可以说是一个解析库，Babel 中文网：<a href="https://www.babeljs.cn/">https://www.babeljs.cn/</a> ，Babel 英文官网：<a href="https://babeljs.io/">https://babeljs.io/</a> ，Babel 内置了很多分析 JavaScript 代码的方法，我们可以利用 Babel 将 JavaScript 代码转换成 AST 语法树，然后增删改查等操作之后，再转换成 JavaScript 代码。</p><p>Babel 包含的各种功能包、API、各方法可选参数等，都非常多，本文不一一列举，在实际使用过程中，应当多查询官方文档，或者参考文末给出的一些学习资料。Babel 的安装和其他 Node 包一样，需要哪个安装哪个即可，比如 <code>npm install @babel/core @babel/parser @babel/traverse @babel/generator</code></p><p>在做逆向解混淆中，主要用到了 Babel 的以下几个功能包，本文也仅介绍以下几个功能包：</p><ol><li><code>@babel/core</code>：Babel 编译器本身，提供了 babel 的编译 API；</li><li><code>@babel/parser</code>：将 JavaScript 代码解析成 AST 语法树；</li><li><code>@babel/traverse</code>：遍历、修改 AST 语法树的各个节点；</li><li><code>@babel/generator</code>：将 AST 还原成 JavaScript 代码；</li><li><code>@babel/types</code>：判断、验证节点的类型、构建新 AST 节点等。</li></ol><p><img src="https://cdn.itbob.cn/img/article/051/06.png" alt="06"></p><h3><span id="babel-core">@babel/core</span></h3><p>Babel 编译器本身，被拆分成了三个模块：<code>@babel/parser</code>、<code>@babel/traverse</code>、<code>@babel/generator</code>，比如以下方法的导入效果都是一样的：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>).parse;<span class="hljs-keyword">const</span> parse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/core&quot;</span>).parse;<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/core&quot;</span>).traverse</code></pre><h3><span id="babel-parser">@babel/parser</span></h3><p><code>@babel/parser</code> 可以将 JavaScript 代码解析成 AST 语法树，其中主要提供了两个方法：</p><ul><li><code>parser.parse(code, [&#123;options&#125;])</code>：解析一段 JavaScript 代码；</li><li><code>parser.parseExpression(code, [&#123;options&#125;])</code>：考虑到了性能问题，解析单个 JavaScript 表达式。</li></ul><p>部分可选参数 <code>options</code>：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>allowImportExportEverywhere</code></td><td>默认 <code>import</code> 和 <code>export</code> 声明语句只能出现在程序的最顶层，设置为 <code>true</code> 则在任何地方都可以声明</td></tr><tr><td><code>allowReturnOutsideFunction</code></td><td>默认如果在顶层中使用 <code>return</code> 语句会引起错误，设置为 <code>true</code> 就不会报错</td></tr><tr><td><code>sourceType</code></td><td>默认为 <code>script</code>，当代码中含有 <code>import</code> 、<code>export</code> 等关键字时会报错，需要指定为 <code>module</code></td></tr><tr><td><code>errorRecovery</code></td><td>默认如果 babel 发现一些不正常的代码就会抛出错误，设置为 <code>true</code> 则会在保存解析错误的同时继续解析代码，错误的记录将被保存在最终生成的 AST 的 errors 属性中，当然如果遇到严重的错误，依然会终止解析</td></tr></tbody></table><p>举个例子看得比较清楚：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> code = <span class="hljs-string">&quot;const a = 1;&quot;</span>;<span class="hljs-keyword">const</span> ast = parser.parse(code, &#123;<span class="hljs-attr">sourceType</span>: <span class="hljs-string">&quot;module&quot;</span>&#125;)<span class="hljs-built_in">console</span>.log(ast)</code></pre><p><code>&#123;sourceType: &quot;module&quot;&#125;</code> 演示了如何添加可选参数，输出的就是 AST 语法树，这和在线网站 <a href="https://astexplorer.net/">https://astexplorer.net/</a> 解析出来的语法树是一样的：</p><p><img src="https://cdn.itbob.cn/img/article/051/07.png" alt="07"></p><h3><span id="babel-generator">@babel/generator</span></h3><p><code>@babel/generator</code> 可以将 AST 还原成 JavaScript 代码，提供了一个 <code>generate</code> 方法：<code>generate(ast, [&#123;options&#125;], code)</code>。</p><p>部分可选参数 <code>options</code>：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>auxiliaryCommentBefore</code></td><td>在输出文件内容的头部添加注释块文字</td></tr><tr><td><code>auxiliaryCommentAfter</code></td><td>在输出文件内容的末尾添加注释块文字</td></tr><tr><td><code>comments</code></td><td>输出内容是否包含注释</td></tr><tr><td><code>compact</code></td><td>输出内容是否不添加空格，避免格式化</td></tr><tr><td><code>concise</code></td><td>输出内容是否减少空格使其更紧凑一些</td></tr><tr><td><code>minified</code></td><td>是否压缩输出代码</td></tr><tr><td><code>retainLines</code></td><td>尝试在输出代码中使用与源代码中相同的行号</td></tr></tbody></table><p>接着前面的例子，原代码是 <code>const a = 1;</code>，现在我们把 <code>a</code> 变量修改为 <code>b</code>，值 <code>1</code> 修改为 <code>2</code>，然后将 AST 还原生成新的 JS 代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> code = <span class="hljs-string">&quot;const a = 1;&quot;</span>;<span class="hljs-keyword">const</span> ast = parser.parse(code, &#123;<span class="hljs-attr">sourceType</span>: <span class="hljs-string">&quot;module&quot;</span>&#125;)ast.program.body[<span class="hljs-number">0</span>].declarations[<span class="hljs-number">0</span>].id.name = <span class="hljs-string">&quot;b&quot;</span>ast.program.body[<span class="hljs-number">0</span>].declarations[<span class="hljs-number">0</span>].init.value = <span class="hljs-number">2</span><span class="hljs-keyword">const</span> result = generate(ast, &#123;<span class="hljs-attr">minified</span>: <span class="hljs-literal">true</span>&#125;)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>最终输出的是 <code>const b=2;</code>，变量名和值都成功更改了，由于加了压缩处理，等号左右两边的空格也没了。</p><p>代码里 <code>&#123;minified: true&#125;</code> 演示了如何添加可选参数，这里表示压缩输出代码，<code>generate</code> 得到的 <code>result</code> 得到的是一个对象，其中的 <code>code</code> 属性才是最终的 JS 代码。</p><p>代码里 <code>ast.program.body[0].declarations[0].id.name</code> 是 a 在 AST 中的位置，<code>ast.program.body[0].declarations[0].init.value</code> 是 1 在 AST 中的位置，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/051/08.png" alt="08"></p><h3><span id="babel-traverse">@babel/traverse</span></h3><p>当代码多了，我们不可能像前面那样挨个定位并修改，对于相同类型的节点，我们可以直接遍历所有节点来进行修改，这里就用到了 <code>@babel/traverse</code>，它通常和 <code>visitor</code> 一起使用，<code>visitor</code> 是一个对象，这个名字是可以随意取的，<code>visitor</code> 里可以定义一些方法来过滤节点，这里还是用一个例子来演示：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> code = <span class="hljs-string">`</span><span class="hljs-string">const a = 1500;</span><span class="hljs-string">const b = 60;</span><span class="hljs-string">const c = &quot;hi&quot;;</span><span class="hljs-string">const d = 787;</span><span class="hljs-string">const e = &quot;1244&quot;;</span><span class="hljs-string">`</span><span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">NumericLiteral</span>(<span class="hljs-params">path</span>)</span>&#123;        path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>    &#125;,    <span class="hljs-function"><span class="hljs-title">StringLiteral</span>(<span class="hljs-params">path</span>)</span>&#123;        path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>这里的原始代码定义了 abcde 五个变量，其值有数字也有字符串，我们在 AST 中可以看到对应的类型为 <code>NumericLiteral</code> 和 <code>StringLiteral</code>：</p><p><img src="https://cdn.itbob.cn/img/article/051/09.png" alt="09"></p><p>然后我们声明了一个 <code>visitor</code> 对象，然后定义对应类型的处理方法，<code>traverse</code> 接收两个参数，第一个是 AST 对象，第二个是 <code>visitor</code>，当 <code>traverse</code> 遍历所有节点，遇到节点类型为 <code>NumericLiteral</code> 和 <code>StringLiteral</code> 时，就会调用 <code>visitor</code> 中对应的处理方法，<code>visitor</code> 中的方法会接收一个当前节点的 <code>path</code> 对象，该对象的类型是 <code>NodePath</code>，该对象有非常多的属性，以下介绍几种最常用的：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>toString()</code></td><td>当前路径的源码</td></tr><tr><td><code>node</code></td><td>当前路径的节点</td></tr><tr><td><code>parent</code></td><td>当前路径的父级节点</td></tr><tr><td><code>parentPath</code></td><td>当前路径的父级路径</td></tr><tr><td><code>type</code></td><td>当前路径的类型</td></tr></tbody></table><p>PS：<code>path</code> 对象除了有很多属性以外，还有很多方法，比如替换节点、删除节点、插入节点、寻找父级节点、获取同级节点、添加注释、判断节点类型等，可在需要时查询相关文档或查看源码，后续介绍 <code>@babel/types</code> 部分将会举部分例子来演示，以后的实战文章中也会有相关实例，篇幅有限本文不再细说。</p><p>因此在上面的代码中，<code>path.node.value</code> 就拿到了变量的值，然后我们就可以进一步对其进行修改了。以上代码运行后，所有数字都会加上100后再乘以2，所有字符串都会被替换成 <code>I Love JavaScript!</code>，结果如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">3200</span>;<span class="hljs-keyword">const</span> b = <span class="hljs-number">320</span>;<span class="hljs-keyword">const</span> c = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>;<span class="hljs-keyword">const</span> d = <span class="hljs-number">1774</span>;<span class="hljs-keyword">const</span> e = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>;</code></pre><p>如果多个类型的节点，处理的方式都一样，那么还可以使用 <code>|</code> 将所有节点连接成字符串，将同一个方法应用到所有节点：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-string">&quot;NumericLiteral|StringLiteral&quot;</span>(path) &#123;        path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>    &#125;&#125;</code></pre><p><code>visitor</code> 对象有多种写法，以下几种写法的效果都是一样的：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">NumericLiteral</span>(<span class="hljs-params">path</span>)</span>&#123;        path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>    &#125;,    <span class="hljs-function"><span class="hljs-title">StringLiteral</span>(<span class="hljs-params">path</span>)</span>&#123;        path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>    &#125;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-attr">NumericLiteral</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>)</span>&#123;        path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>    &#125;,    <span class="hljs-attr">StringLiteral</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>)</span>&#123;        path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>    &#125;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-attr">NumericLiteral</span>: &#123;        <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span> &#123;            path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>        &#125;    &#125;,    <span class="hljs-attr">StringLiteral</span>: &#123;        <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span> &#123;            path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>        &#125;    &#125;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">if</span> (path.node.type === <span class="hljs-string">&quot;NumericLiteral&quot;</span>) &#123;            path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>        &#125;        <span class="hljs-keyword">if</span> (path.node.type === <span class="hljs-string">&quot;StringLiteral&quot;</span>) &#123;            path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>        &#125;    &#125;&#125;</code></pre><p>以上几种写法中有用到了 <code>enter</code> 方法，在节点的遍历过程中，进入节点（enter）与退出（exit）节点都会访问一次节点，<code>traverse</code> 默认在进入节点时进行节点的处理，如果要在退出节点时处理，那么在 <code>visitor</code> 中就必须声明 <code>exit</code> 方法。</p><h3><span id="babel-types">@babel/types</span></h3><p><code>@babel/types</code> 主要用于构建新的 AST 节点，前面的示例代码为 <code>const a = 1;</code>，如果想要增加内容，比如变成 <code>const a = 1; const b = a * 5 + 1;</code>，就可以通过 <code>@babel/types</code> 来实现。</p><p>首先观察一下 AST 语法树，原语句只有一个 <code>VariableDeclaration</code> 节点，现在增加了一个：</p><p><img src="https://cdn.itbob.cn/img/article/051/10.png" alt="10"></p><p>那么我们的思路就是在遍历节点时，遍历到 <code>VariableDeclaration</code> 节点，就在其后面增加一个 <code>VariableDeclaration</code> 节点，生成  <code>VariableDeclaration</code> 节点，可以使用 <code>types.variableDeclaration()</code> 方法，在 types 中各种方法名称和我们在 AST 中看到的是一样的，只不过首字母是小写的，所以我们不需要知道所有方法的情况下，也能大致推断其方法名，只知道这个方法还不行，还得知道传入的参数是什么，可以查文档，不过这里推荐直接看源码，非常清晰明了，以 Pycharm 为例，按住 Ctrl 键，再点击方法名，就进到源码里了：</p><p><img src="https://cdn.itbob.cn/img/article/051/11.png" alt="11"></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">variableDeclaration</span>(<span class="hljs-params">kind: <span class="hljs-string">&quot;var&quot;</span> | <span class="hljs-string">&quot;let&quot;</span> | <span class="hljs-string">&quot;const&quot;</span>, declarations: <span class="hljs-built_in">Array</span>&lt;BabelNodeVariableDeclarator&gt;</span>)</span></code></pre><p>可以看到需要 <code>kind</code> 和 <code>declarations</code> 两个参数，其中 <code>declarations</code> 是 <code>VariableDeclarator</code> 类型的节点组成的列表，所以我们可以先写出以下 <code>visitor</code> 部分的代码，其中 <code>path.insertAfter()</code> 是在该节点之后插入新节点的意思：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">let</span> declaration = types.variableDeclaration(<span class="hljs-string">&quot;const&quot;</span>, [declarator])        path.insertAfter(declaration)    &#125;&#125;</code></pre><p>接下来我们还需要进一步定义 <code>declarator</code>，也就是 <code>VariableDeclarator</code> 类型的节点，查询其源码如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">variableDeclarator</span>(<span class="hljs-params">id: BabelNodeLVal, init?: BabelNodeExpression</span>)</span></code></pre><p>观察 AST，id 为 <code>Identifier</code> 对象，init 为 <code>BinaryExpression</code> 对象，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/051/12.png" alt="12"></p><p>先来处理 id，可以使用 <code>types.identifier()</code> 方法来生成，其源码为 <code>function identifier(name: string)</code>，name 在这里就是 b 了，此时 <code>visitor</code> 代码就可以这么写：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">let</span> declarator = types.variableDeclarator(types.identifier(<span class="hljs-string">&quot;b&quot;</span>), init)        <span class="hljs-keyword">let</span> declaration = types.variableDeclaration(<span class="hljs-string">&quot;const&quot;</span>, [declarator])        path.insertAfter(declaration)    &#125;&#125;</code></pre><p>然后再来看 init 该如何定义，首先仍然是看 AST 结构：</p><p><img src="https://cdn.itbob.cn/img/article/051/13.png" alt="13"></p><p>init 为 <code>BinaryExpression</code> 对象，left 左边是 <code>BinaryExpression</code>，right 右边是 <code>NumericLiteral</code>，可以用 <code>types.binaryExpression()</code> 方法来生成 init，其源码如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binaryExpression</span>(<span class="hljs-params"></span></span><span class="hljs-params"><span class="hljs-function">    operator: <span class="hljs-string">&quot;+&quot;</span> | <span class="hljs-string">&quot;-&quot;</span> | <span class="hljs-string">&quot;/&quot;</span> | <span class="hljs-string">&quot;%&quot;</span> | <span class="hljs-string">&quot;*&quot;</span> | <span class="hljs-string">&quot;**&quot;</span> | <span class="hljs-string">&quot;&amp;&quot;</span> | <span class="hljs-string">&quot;|&quot;</span> | <span class="hljs-string">&quot;&gt;&gt;&quot;</span> | <span class="hljs-string">&quot;&gt;&gt;&gt;&quot;</span> | <span class="hljs-string">&quot;&lt;&lt;&quot;</span> | <span class="hljs-string">&quot;^&quot;</span> | <span class="hljs-string">&quot;==&quot;</span> | <span class="hljs-string">&quot;===&quot;</span> | <span class="hljs-string">&quot;!=&quot;</span> | <span class="hljs-string">&quot;!==&quot;</span> | <span class="hljs-string">&quot;in&quot;</span> | <span class="hljs-string">&quot;instanceof&quot;</span> | <span class="hljs-string">&quot;&gt;&quot;</span> | <span class="hljs-string">&quot;&lt;&quot;</span> | <span class="hljs-string">&quot;&gt;=&quot;</span> | <span class="hljs-string">&quot;&lt;=&quot;</span>,</span></span><span class="hljs-params"><span class="hljs-function">    left: BabelNodeExpression | BabelNodePrivateName, </span></span><span class="hljs-params"><span class="hljs-function">    right: BabelNodeExpression</span></span><span class="hljs-params"><span class="hljs-function"></span>)</span></code></pre><p>此时 <code>visitor</code> 代码就可以这么写：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">let</span> init = types.binaryExpression(<span class="hljs-string">&quot;+&quot;</span>, left, right)        <span class="hljs-keyword">let</span> declarator = types.variableDeclarator(types.identifier(<span class="hljs-string">&quot;b&quot;</span>), init)        <span class="hljs-keyword">let</span> declaration = types.variableDeclaration(<span class="hljs-string">&quot;const&quot;</span>, [declarator])        path.insertAfter(declaration)    &#125;&#125;</code></pre><p>然后继续构造 left 和 right，和前面的方法一样，观察 AST 语法树，查询对应方法应该传入的参数，层层嵌套，直到把所有的节点都构造完毕，最终的 <code>visitor</code> 代码应该是这样的：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">let</span> left = types.binaryExpression(<span class="hljs-string">&quot;*&quot;</span>, types.identifier(<span class="hljs-string">&quot;a&quot;</span>), types.numericLiteral(<span class="hljs-number">5</span>))        <span class="hljs-keyword">let</span> right = types.numericLiteral(<span class="hljs-number">1</span>)        <span class="hljs-keyword">let</span> init = types.binaryExpression(<span class="hljs-string">&quot;+&quot;</span>, left, right)        <span class="hljs-keyword">let</span> declarator = types.variableDeclarator(types.identifier(<span class="hljs-string">&quot;b&quot;</span>), init)        <span class="hljs-keyword">let</span> declaration = types.variableDeclaration(<span class="hljs-string">&quot;const&quot;</span>, [declarator])        path.insertAfter(declaration)        path.stop()    &#125;&#125;</code></pre><p>注意：<code>path.insertAfter()</code> 插入节点语句后面加了一句 <code>path.stop()</code>，表示插入完成后立即停止遍历当前节点和后续的子节点，添加的新节点也是 <code>VariableDeclaration</code>，如果不加停止语句的话，就会无限循环插入下去。</p><p>插入新节点后，再转换成 JavaScript 代码，就可以看到多了一行新代码，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/051/14.png" alt="14"></p><h2><span id="chang-jian-hun-yao-huan-yuan">常见混淆还原</span></h2><p>了解了 AST 和 babel 后，就可以对 JavaScript 混淆代码进行还原了，以下是部分样例，带你进一步熟悉 babel 的各种操作。</p><h3><span id="zi-fu-chuan-huan-yuan">字符串还原</span></h3><p>文章开头的图中举了个例子，正常字符被换成了 Unicode 编码：</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>[<span class="hljs-string">&#x27;\u006c\u006f\u0067&#x27;</span>](<span class="hljs-string">&#x27;\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u006f\u0072\u006c\u0064\u0021&#x27;</span>)</code></pre><p>观察 AST 结构：</p><p><img src="https://cdn.itbob.cn/img/article/051/15.png" alt="15"></p><p>我们发现 Unicode 编码对应的是 <code>raw</code>，而 <code>rawValue</code> 和 <code>value</code> 都是正常的，所以我们可以将 <code>raw</code> 替换成 <code>rawValue</code> 或 <code>value</code> 即可，需要注意的是引号的问题，本来是 <code>console[&quot;log&quot;]</code>，你还原后变成了 <code>console[log]</code>，自然会报错的，除了替换值以外，这里直接删除 extra 节点，或者删除 raw 值也是可以的，所以以下几种写法都可以还原代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> code = <span class="hljs-string">`console[&#x27;\u006c\u006f\u0067&#x27;](&#x27;\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u006f\u0072\u006c\u0064\u0021&#x27;)`</span><span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">StringLiteral</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-comment">// 以下方法均可</span>        <span class="hljs-comment">// path.node.extra.raw = path.node.rawValue</span>        <span class="hljs-comment">// path.node.extra.raw = &#x27;&quot;&#x27; + path.node.value + &#x27;&quot;&#x27;</span>        <span class="hljs-comment">// delete path.node.extra</span>        <span class="hljs-keyword">delete</span> path.node.extra.raw    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>还原结果：</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>[<span class="hljs-string">&quot;log&quot;</span>](<span class="hljs-string">&quot;Hello world!&quot;</span>);</code></pre><h3><span id="biao-da-shi-huan-yuan">表达式还原</span></h3><p>之前写过 <a href="https://itrhx.blog.csdn.net/article/details/122057377">JSFuck 混淆的还原</a>，其中有介绍 <code>![]</code> 可表示 false，<code>!![]</code> 或者 <code>!+[]</code> 可表示 true，在一些混淆代码中，经常有这些操作，把简单的表达式复杂化，往往需要执行一下语句，才能得到真正的结果，示例代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = !![]+!![]+!![];<span class="hljs-keyword">const</span> b = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">12.34</span> * <span class="hljs-number">2.12</span>)<span class="hljs-keyword">const</span> c = <span class="hljs-number">10</span> &gt;&gt; <span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">1</span><span class="hljs-keyword">const</span> d = <span class="hljs-built_in">String</span>(<span class="hljs-number">21.3</span> + <span class="hljs-number">14</span> * <span class="hljs-number">1.32</span>)<span class="hljs-keyword">const</span> e = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;1.893&quot;</span> + <span class="hljs-string">&quot;45.9088&quot;</span>)<span class="hljs-keyword">const</span> f = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;23.2334&quot;</span> + <span class="hljs-string">&quot;21.89112&quot;</span>)<span class="hljs-keyword">const</span> g = <span class="hljs-number">20</span> &lt; <span class="hljs-number">18</span> ? <span class="hljs-string">&#x27;未成年&#x27;</span> : <span class="hljs-string">&#x27;成年&#x27;</span></code></pre><p>想要执行语句，我们需要了解 <code>path.evaluate()</code> 方法，该方法会对 path 对象进行执行操作，自动计算出结果，返回一个对象，其中的 <code>confident</code> 属性表示置信度，<code>value</code> 表示计算结果，使用 <code>types.valueToNode()</code> 方法创建节点，使用 <code>path.replaceInline()</code> 方法将节点替换成计算结果生成的新节点，替换方法有一下几种：</p><ul><li><code>replaceWith</code>：用一个节点替换另一个节点；</li><li><code>replaceWithMultiple</code>：用多个节点替换另一个节点；</li><li><code>replaceWithSourceString</code>：将传入的源码字符串解析成对应 Node 后再替换，性能较差，不建议使用；</li><li><code>replaceInline</code>：用一个或多个节点替换另一个节点，相当于同时有了前两个函数的功能。</li></ul><p>对应的 AST 处理代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)<span class="hljs-keyword">const</span> code = <span class="hljs-string">`</span><span class="hljs-string">const a = !![]+!![]+!![];</span><span class="hljs-string">const b = Math.floor(12.34 * 2.12)</span><span class="hljs-string">const c = 10 &gt;&gt; 3 &lt;&lt; 1</span><span class="hljs-string">const d = String(21.3 + 14 * 1.32)</span><span class="hljs-string">const e = parseInt(&quot;1.893&quot; + &quot;45.9088&quot;)</span><span class="hljs-string">const f = parseFloat(&quot;23.2334&quot; + &quot;21.89112&quot;)</span><span class="hljs-string">const g = 20 &lt; 18 ? &#x27;未成年&#x27; : &#x27;成年&#x27;</span><span class="hljs-string">`</span><span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-string">&quot;BinaryExpression|CallExpression|ConditionalExpression&quot;</span>(path) &#123;        <span class="hljs-keyword">const</span> &#123;confident, value&#125; = path.evaluate()        <span class="hljs-keyword">if</span> (confident)&#123;            path.replaceInline(types.valueToNode(value))        &#125;    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>最终结果：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">3</span>;<span class="hljs-keyword">const</span> b = <span class="hljs-number">26</span>;<span class="hljs-keyword">const</span> c = <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> d = <span class="hljs-string">&quot;39.78&quot;</span>;<span class="hljs-keyword">const</span> e = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;1.89345.9088&quot;</span>);<span class="hljs-keyword">const</span> f = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;23.233421.89112&quot;</span>);<span class="hljs-keyword">const</span> g = <span class="hljs-string">&quot;\u6210\u5E74&quot;</span>;</code></pre><h3><span id="shan-chu-wei-shi-yong-bian-liang">删除未使用变量</span></h3><p>有时候代码里会有一些并没有使用到的多余变量，删除这些多余变量有助于更加高效的分析代码，示例代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> b = a * <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> c = <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> d = b + <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> e = <span class="hljs-number">3</span>;<span class="hljs-built_in">console</span>.log(d)</code></pre><p>删除多余变量，首先要了解 <code>NodePath</code> 中的 <code>scope</code>，<code>scope</code> 的作用主要是查找标识符的作用域、获取并修改标识符的所有引用等，删除未使用变量主要用到了 <code>scope.getBinding()</code> 方法，传入的值是当前节点能够引用到的标识符名称，返回的关键属性有以下几个：</p><ul><li><code>identifier</code>：标识符的 Node 对象；</li><li><code>path</code>：标识符的 NodePath 对象；</li><li><code>constant</code>：标识符是否为常量；</li><li><code>referenced</code>：标识符是否被引用；</li><li><code> references</code>：标识符被引用的次数；</li><li><code>constantViolations</code>：如果标识符被修改，则会存放所有修改该标识符节点的 Path 对象；</li><li><code>referencePaths</code>：如果标识符被引用，则会存放所有引用该标识符节点的 Path 对象。</li></ul><p>所以我们可以通过 <code>constantViolations</code>、<code>referenced</code>、<code>references</code>、<code>referencePaths</code> 多个参数来判断变量是否可以被删除，AST 处理代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> code = <span class="hljs-string">`</span><span class="hljs-string">const a = 1;</span><span class="hljs-string">const b = a * 2;</span><span class="hljs-string">const c = 2;</span><span class="hljs-string">const d = b + 1;</span><span class="hljs-string">const e = 3;</span><span class="hljs-string">console.log(d)</span><span class="hljs-string">`</span><span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">VariableDeclarator</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">const</span> binding = path.scope.getBinding(path.node.id.name);        <span class="hljs-comment">// 如标识符被修改过，则不能进行删除动作。</span>        <span class="hljs-keyword">if</span> (!binding || binding.constantViolations.length &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 未被引用</span>        <span class="hljs-keyword">if</span> (!binding.referenced) &#123;            path.remove();        &#125;        <span class="hljs-comment">// 被引用次数为0</span>        <span class="hljs-comment">// if (binding.references === 0) &#123;</span>        <span class="hljs-comment">//     path.remove();</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// 长度为0，变量没有被引用过</span>        <span class="hljs-comment">// if (binding.referencePaths.length === 0) &#123;</span>        <span class="hljs-comment">//     path.remove();</span>        <span class="hljs-comment">// &#125;</span>    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>处理后的代码（未使用的 b、c、e 变量已被删除）：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> b = a * <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> d = b + <span class="hljs-number">1</span>;<span class="hljs-built_in">console</span>.log(d);</code></pre><h3><span id="shan-chu-rong-yu-luo-ji-dai-ma">删除冗余逻辑代码</span></h3><p>有时候为了增加逆向难度，会有很多嵌套的 if-else 语句，大量判断为假的冗余逻辑代码，同样可以利用 AST 将其删除掉，只留下判断为真的，示例代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> example = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> a;    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;        a = <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) &#123;            a = <span class="hljs-number">2</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;            a = <span class="hljs-number">3</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> a;&#125;;</code></pre><p>观察 AST，判断条件对应的是 <code>test</code> 节点，if 对应的是 <code>consequent</code> 节点，else 对应的是 <code>alternate</code> 节点，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/051/16.png" alt="16"></p><p>AST 处理思路以及代码：</p><ol><li>筛选出 <code>BooleanLiteral</code> 和 <code>NumericLiteral</code> 节点，取其对应的值，即 <code>path.node.test.value</code>；</li><li>判断 <code>value</code> 值为真，则将节点替换成 <code>consequent</code> 节点下的内容，即 <code>path.node.consequent.body</code>；</li><li>判断 <code>value</code> 值为假，则替换成 <code>alternate</code> 节点下的内容，即 <code>path.node.alternate.body</code>；</li><li>有的 if 语句可能没有写 else，也就没有 <code>alternate</code>，所以这种情况下判断 <code>value</code> 值为假，则直接移除该节点，即 <code>path.remove()</code></li></ol><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/types&#x27;</span>);<span class="hljs-keyword">const</span> code = <span class="hljs-string">`</span><span class="hljs-string">const example = function () &#123;</span><span class="hljs-string">    let a;</span><span class="hljs-string">    if (false) &#123;</span><span class="hljs-string">        a = 1;</span><span class="hljs-string">    &#125; else &#123;</span><span class="hljs-string">        if (1) &#123;</span><span class="hljs-string">            a = 2;</span><span class="hljs-string">        &#125;</span><span class="hljs-string">        else &#123;</span><span class="hljs-string">            a = 3;</span><span class="hljs-string">        &#125;</span><span class="hljs-string">    &#125;</span><span class="hljs-string">    return a;</span><span class="hljs-string">&#125;;</span><span class="hljs-string">`</span><span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">if</span> (types.isBooleanLiteral(path.node.test) || types.isNumericLiteral(path.node.test)) &#123;            <span class="hljs-keyword">if</span> (path.node.test.value) &#123;                path.replaceInline(path.node.consequent.body);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (path.node.alternate) &#123;                    path.replaceInline(path.node.alternate.body);                &#125; <span class="hljs-keyword">else</span> &#123;                    path.remove()                &#125;            &#125;        &#125;    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>处理结果：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> example = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> a;  a = <span class="hljs-number">2</span>;  <span class="hljs-keyword">return</span> a;&#125;;</code></pre><h3><span id="switch-case-fan-kong-zhi-liu-ping-tan-hua">switch-case 反控制流平坦化</span></h3><p>控制流平坦化是混淆当中最常见的，通过 <code>if-else</code> 或者 <code>while-switch-case</code> 语句分解步骤，示例代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> _0x34e16a = <span class="hljs-string">&#x27;3,4,0,5,1,2&#x27;</span>[<span class="hljs-string">&#x27;split&#x27;</span>](<span class="hljs-string">&#x27;,&#x27;</span>);<span class="hljs-keyword">let</span> _0x2eff02 = <span class="hljs-number">0x0</span>;<span class="hljs-keyword">while</span> (!![]) &#123;    <span class="hljs-keyword">switch</span> (_0x34e16a[_0x2eff02++]) &#123;        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;0&#x27;</span>:            <span class="hljs-keyword">let</span> _0x38cb15 = _0x4588f1 + _0x470e97;            <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;1&#x27;</span>:            <span class="hljs-keyword">let</span> _0x1e0e5e = _0x37b9f3[_0x50cee0(<span class="hljs-number">0x2e0</span>, <span class="hljs-number">0x2e8</span>, <span class="hljs-number">0x2e1</span>, <span class="hljs-number">0x2e4</span>)];            <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;2&#x27;</span>:            <span class="hljs-keyword">let</span> _0x35d732 = [_0x388d4b(-<span class="hljs-number">0x134</span>, -<span class="hljs-number">0x134</span>, -<span class="hljs-number">0x139</span>, -<span class="hljs-number">0x138</span>)](_0x38cb15 &gt;&gt; _0x4588f1);            <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;3&#x27;</span>:            <span class="hljs-keyword">let</span> _0x4588f1 = <span class="hljs-number">0x1</span>;            <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;4&#x27;</span>:            <span class="hljs-keyword">let</span> _0x470e97 = <span class="hljs-number">0x2</span>;            <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;5&#x27;</span>:            <span class="hljs-keyword">let</span> _0x37b9f3 = <span class="hljs-number">0x5</span> || _0x38cb15;            <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">break</span>;&#125;</code></pre><p>AST 还原思路：</p><ol><li>获取控制流原始数组，将 <code>'3,4,0,5,1,2'['split'](',')</code> 之类的语句转化成 <code>['3','4','0','5','1','2']</code> 之类的数组，得到该数组之后，也可以选择把 split 语句对应的节点删除掉，因为最终代码里这条语句就没用了；</li><li>遍历第一步得到的控制流数组，依次取出每个值所对应的 case 节点；</li><li>定义一个数组，储存每个 case 节点 <code>consequent</code> 数组里面的内容，并删除 <code>continue</code> 语句对应的节点；</li><li>遍历完成后，将第三步的数组替换掉整个 while 节点，也就是 <code>WhileStatement</code>。</li></ol><p>不同思路，写法多样，对于如何获取控制流数组，可以有以下思路：</p><ol><li>获取到 <code>While</code> 语句节点，然后使用 <code>path.getAllPrevSiblings()</code> 方法获取其前面的所有兄弟节点，遍历每个兄弟节点，找到与 <code>switch()</code> 里面数组的变量名相同的节点，然后再取节点的值进行后续处理；</li><li>直接取 <code>switch()</code> 里面数组的变量名，然后使用 <code>scope.getBinding()</code> 方法获取到它绑定的节点，然后再取这个节点的值进行后续处理。</li></ol><p>所以 AST 处理代码就有两种写法，方法一：（code.js 即为前面的示例代码，为了方便操作，这里使用 fs 从文件中读取代码）</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<span class="hljs-keyword">const</span> code = fs.readFileSync(<span class="hljs-string">&quot;code.js&quot;</span>, &#123;<span class="hljs-attr">encoding</span>: <span class="hljs-string">&quot;utf-8&quot;</span>&#125;);<span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">WhileStatement</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-comment">// switch 节点</span>        <span class="hljs-keyword">let</span> switchNode = path.node.body.body[<span class="hljs-number">0</span>];        <span class="hljs-comment">// switch 语句内的控制流数组名，本例中是 _0x34e16a</span>        <span class="hljs-keyword">let</span> arrayName = switchNode.discriminant.object.name;        <span class="hljs-comment">// 获得所有 while 前面的兄弟节点，本例中获取到的是声明两个变量的节点，即 const _0x34e16a 和 let _0x2eff02</span>        <span class="hljs-keyword">let</span> prevSiblings = path.getAllPrevSiblings();        <span class="hljs-comment">// 定义缓存控制流数组</span>        <span class="hljs-keyword">let</span> array = []        <span class="hljs-comment">// forEach 方法遍历所有节点</span>        prevSiblings.forEach(<span class="hljs-function"><span class="hljs-params">pervNode</span> =&gt;</span> &#123;            <span class="hljs-keyword">let</span> &#123;id, init&#125; = pervNode.node.declarations[<span class="hljs-number">0</span>];            <span class="hljs-comment">// 如果节点 id.name 与 switch 语句内的控制流数组名相同</span>            <span class="hljs-keyword">if</span> (arrayName === id.name) &#123;                <span class="hljs-comment">// 获取节点整个表达式的参数、分割方法、分隔符</span>                <span class="hljs-keyword">let</span> object = init.callee.object.value;                <span class="hljs-keyword">let</span> property = init.callee.property.value;                <span class="hljs-keyword">let</span> argument = init.arguments[<span class="hljs-number">0</span>].value;                <span class="hljs-comment">// 模拟执行 &#x27;3,4,0,5,1,2&#x27;[&#x27;split&#x27;](&#x27;,&#x27;) 语句</span>                array = object[property](argument)                <span class="hljs-comment">// 也可以直接取参数进行分割，方法不通用，比如分隔符换成 | 就不行了</span>                <span class="hljs-comment">// array = init.callee.object.value.split(&#x27;,&#x27;);</span>            &#125;            <span class="hljs-comment">// 前面的兄弟节点就可以删除了</span>            pervNode.remove();        &#125;);        <span class="hljs-comment">// 储存正确顺序的控制流语句</span>        <span class="hljs-keyword">let</span> replace = [];        <span class="hljs-comment">// 遍历控制流数组，按正确顺序取 case 内容</span>        array.forEach(<span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;                <span class="hljs-keyword">let</span> consequent = switchNode.cases[index].consequent;                <span class="hljs-comment">// 如果最后一个节点是 continue 语句，则删除 ContinueStatement 节点</span>                <span class="hljs-keyword">if</span> (types.isContinueStatement(consequent[consequent.length - <span class="hljs-number">1</span>])) &#123;                    consequent.pop();                &#125;                <span class="hljs-comment">// concat 方法拼接多个数组，即正确顺序的 case 内容</span>                replace = replace.concat(consequent);            &#125;        );        <span class="hljs-comment">// 替换整个 while 节点，两种方法都可以</span>        path.replaceWithMultiple(replace);        <span class="hljs-comment">// path.replaceInline(replace);</span>    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>方法二：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<span class="hljs-keyword">const</span> code = fs.readFileSync(<span class="hljs-string">&quot;code.js&quot;</span>, &#123;<span class="hljs-attr">encoding</span>: <span class="hljs-string">&quot;utf-8&quot;</span>&#125;);<span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">WhileStatement</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-comment">// switch 节点</span>        <span class="hljs-keyword">let</span> switchNode = path.node.body.body[<span class="hljs-number">0</span>];        <span class="hljs-comment">// switch 语句内的控制流数组名，本例中是 _0x34e16a</span>        <span class="hljs-keyword">let</span> arrayName = switchNode.discriminant.object.name;        <span class="hljs-comment">// 获取控制流数组绑定的节点</span>        <span class="hljs-keyword">let</span> bindingArray = path.scope.getBinding(arrayName);        <span class="hljs-comment">// 获取节点整个表达式的参数、分割方法、分隔符</span>        <span class="hljs-keyword">let</span> init = bindingArray.path.node.init;        <span class="hljs-keyword">let</span> object = init.callee.object.value;        <span class="hljs-keyword">let</span> property = init.callee.property.value;        <span class="hljs-keyword">let</span> argument = init.arguments[<span class="hljs-number">0</span>].value;        <span class="hljs-comment">// 模拟执行 &#x27;3,4,0,5,1,2&#x27;[&#x27;split&#x27;](&#x27;,&#x27;) 语句</span>        <span class="hljs-keyword">let</span> array = object[property](argument)        <span class="hljs-comment">// 也可以直接取参数进行分割，方法不通用，比如分隔符换成 | 就不行了</span>        <span class="hljs-comment">// let array = init.callee.object.value.split(&#x27;,&#x27;);</span>        <span class="hljs-comment">// switch 语句内的控制流自增变量名，本例中是 _0x2eff02</span>        <span class="hljs-keyword">let</span> autoIncrementName = switchNode.discriminant.property.argument.name;        <span class="hljs-comment">// 获取控制流自增变量名绑定的节点</span>        <span class="hljs-keyword">let</span> bindingAutoIncrement = path.scope.getBinding(autoIncrementName);        <span class="hljs-comment">// 可选择的操作：删除控制流数组绑定的节点、自增变量名绑定的节点</span>        bindingArray.path.remove();        bindingAutoIncrement.path.remove();        <span class="hljs-comment">// 储存正确顺序的控制流语句</span>        <span class="hljs-keyword">let</span> replace = [];        <span class="hljs-comment">// 遍历控制流数组，按正确顺序取 case 内容</span>        array.forEach(<span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;                <span class="hljs-keyword">let</span> consequent = switchNode.cases[index].consequent;                <span class="hljs-comment">// 如果最后一个节点是 continue 语句，则删除 ContinueStatement 节点</span>                <span class="hljs-keyword">if</span> (types.isContinueStatement(consequent[consequent.length - <span class="hljs-number">1</span>])) &#123;                    consequent.pop();                &#125;                <span class="hljs-comment">// concat 方法拼接多个数组，即正确顺序的 case 内容</span>                replace = replace.concat(consequent);            &#125;        );        <span class="hljs-comment">// 替换整个 while 节点，两种方法都可以</span>        path.replaceWithMultiple(replace);        <span class="hljs-comment">// path.replaceInline(replace);</span>    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>以上代码运行后，原来的 <code>switch-case</code> 控制流就被还原了，变成了按顺序一行一行的代码，更加简洁明了：</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> _0x4588f1 = <span class="hljs-number">0x1</span>;<span class="hljs-keyword">let</span> _0x470e97 = <span class="hljs-number">0x2</span>;<span class="hljs-keyword">let</span> _0x38cb15 = _0x4588f1 + _0x470e97;<span class="hljs-keyword">let</span> _0x37b9f3 = <span class="hljs-number">0x5</span> || _0x38cb15;<span class="hljs-keyword">let</span> _0x1e0e5e = _0x37b9f3[_0x50cee0(<span class="hljs-number">0x2e0</span>, <span class="hljs-number">0x2e8</span>, <span class="hljs-number">0x2e1</span>, <span class="hljs-number">0x2e4</span>)];<span class="hljs-keyword">let</span> _0x35d732 = [_0x388d4b(-<span class="hljs-number">0x134</span>, -<span class="hljs-number">0x134</span>, -<span class="hljs-number">0x139</span>, -<span class="hljs-number">0x138</span>)](_0x38cb15 &gt;&gt; _0x4588f1);</code></pre><h2><span id="can-kao-zi-liao">参考资料</span></h2><p>本文有参考以下资料，也是比较推荐的在线学习资料：</p><ul><li>Youtube 视频，Babel 入门：<a href="https://www.youtube.com/watch?v=UeVq_U5obnE">https://www.youtube.com/watch?v=UeVq_U5obnE</a></li><li>官方手册 Babel Handbook：<a href="https://github.com/jamiebuilds/babel-handbook">https://github.com/jamiebuilds/babel-handbook</a></li><li>非官方 Babel API 中文文档：<a href="https://evilrecluse.top/Babel-traverse-api-doc/">https://evilrecluse.top/Babel-traverse-api-doc/</a></li></ul><h2><span id="end">END</span></h2><p>Babel 编译器国内的资料其实不是很多，多看源码、同时在线对照可视化的 AST 语法树，耐心一点儿一层一层分析即可，本文中的案例也只是最基本操作，实际遇到一些混淆还得视情况进行修改，比如需要加一些类型判断来限制等，后续会用实战来带领大家进一步熟悉解混淆当中的其他操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/ast.png&quot; alt=&quot;ast&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
