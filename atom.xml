<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BOB&#39;S BLOG</title>
  
  <subtitle>一入 IT 深似海 从此学习无绝期</subtitle>
  <link href="https://www.itbob.cn/atom.xml" rel="self"/>
  
  <link href="https://www.itbob.cn/"/>
  <updated>2023-01-16T12:42:00.000Z</updated>
  <id>https://www.itbob.cn/</id>
  
  <author>
    <name>BOB</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>极验业务安全，深知 V2 业务风控逆向分析</title>
    <link href="https://www.itbob.cn/article/062/"/>
    <id>https://www.itbob.cn/article/062/</id>
    <published>2023-01-16T12:42:00.000Z</published>
    <updated>2023-01-16T12:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><blockquote><p><strong>极验全家桶，交流请咨询微信：IT-BOB</strong><br><strong>极验全家桶，交流请咨询微信：IT-BOB</strong><br><strong>极验全家桶，交流请咨询微信：IT-BOB</strong></p></blockquote><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#shen-zhi-jian-jie">深知简介</a></li><li><a href="#zhua-bao-fen-xi">抓包分析</a></li><li><a href="#ni-xiang-fen-xi">逆向分析</a><ul><li><a href="#huo-qu-h-zhi">获取 h 值</a></li><li><a href="#huo-qu-e-zhi">获取 e 值</a></li><li><a href="#huo-qu-l-zhi">获取 l 值</a></li><li><a href="#jin-yi-bu-chu-li-l">进一步处理 l</a></li></ul></li><li><a href="#jie-guo-yan-zheng">结果验证</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><p><img src="https://cdn.itbob.cn/img/article/062/01.gif" alt="01"></p><ul><li>目标：某验深知 V2 业务风控逆向分析</li><li>主页：<code>aHR0cHM6Ly93d3cuZ2VldGVzdC5jb20vZGVtby9kay12Mi5odG1s</code></li></ul><h2><span id="shen-zhi-jian-jie">深知简介</span></h2><p>某验深知通过无感采集客户端数据，对用户的环境、标识、行为操作等进行智能化分析，结合业务场景有效识别有潜在风险的用户。整个识别过程不干扰用户，不打断业务既有流程。完整通讯流程如下：</p><p><img src="https://cdn.itbob.cn/img/article/062/02.jpg" alt="02"></p><h2><span id="zhua-bao-fen-xi">抓包分析</span></h2><p>访问首页，会引入一个 <code>v2.sense.js</code>，后面接了个 <code>id</code>，需要将其提取出来，后续有用到，当然一般情况下，同一个业务这个 <code>id</code> 应该是一样的，直接复制下来写死也行。</p><p><img src="https://cdn.itbob.cn/img/article/062/03.png" alt="03"></p><p>接着有个 <code>gettype</code> 的请求，这里主要返回一些资源路径，其中有个 <code>gct.xxx.js</code>，这个 JS 名称每隔一段时间就会变化，这个 JS 会生成一个键值对，例如 <code>&#123;'xnbw': '1158444372'&#125;</code>，JS 变化，这个键值对也会变化，这个键值对参与了后面加密参数的生成，在某验系列产品中都有这个东西，少量测试将其固定发现也可以通过验证，盲猜大量请求或者某些校验严格的网站可能有影响，建议还是动态去请求这个 JS 来获取最新的键值对，这个后文具体再说。</p><p><img src="https://cdn.itbob.cn/img/article/062/04.png" alt="04"></p><p>然后是 <code>judge</code> 的请求，这个请求页面一加载就完成了，不需要手动点击请求，其中 <code>Query String Parameters</code> 里有个 <code>app_id</code> 就是我们前面提到的 <code>id</code>，<code>Request Payload</code> 就是一串超长的字符串，这个也是我们需要逆向的参数。该请求如果验证成功，会返回一个 <code>session_id</code>。</p><p><img src="https://cdn.itbob.cn/img/article/062/05.png" alt="05"></p><p><img src="https://cdn.itbob.cn/img/article/062/06.png" alt="06"></p><p>然后就是业务接口了，本例中业务接口是 <code>verify-dk-v2</code>，也就是一个登录接口，带上前面 <code>judge</code> 接口返回的 <code>session_id</code> 即可请求成功。</p><p><img src="https://cdn.itbob.cn/img/article/062/07.png" alt="07"></p><p><img src="https://cdn.itbob.cn/img/article/062/08.png" alt="08"></p><h2><span id="ni-xiang-fen-xi">逆向分析</span></h2><p>由于我们逆向的参数 <code>Request Payload</code> 没有键名导致不能直接搜索关键字，所以只能跟栈或者下个 XHR 断点，跟栈可以在 <code>sense.2.3.0.js</code> 第 6144 行找到一个 <code>e + h[AUJ_(1173)]</code>，这个就是正确的 <code>Request Payload</code> 值。</p><p><img src="https://cdn.itbob.cn/img/article/062/09.png" alt="09"></p><p>上图中其实核心代码就四行，后文也是围绕这四行代码来分析的：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> h = o[AUJ_(<span class="hljs-number">1156</span>)]()  , e = CoUE[ymDv(<span class="hljs-number">24</span>)](NFeB)  , l = EbF_[ymDv(<span class="hljs-number">409</span>)](e, h[ymDv(<span class="hljs-number">1194</span>)])  , e = DWYi[ymDv(<span class="hljs-number">1137</span>)](l)</code></pre><h3><span id="huo-qu-h-zhi">获取 h 值</span></h3><p>先来看 h 的值，由一个方法生成一个对象，对象里面分别是 <code>aeskey</code> 和 <code>rsa</code>，每次也都是随机变化的。</p><p><img src="https://cdn.itbob.cn/img/article/062/10.png" alt="10"></p><p>继续跟到这个方法里，重点在于 e 和 t 的值，最后返回的就是 <code>&#123;aeskey: e, rsa: t&#125;</code>。</p><p><img src="https://cdn.itbob.cn/img/article/062/11.png" alt="11"></p><p>先看这个 e 的值，也就是 <code>RwyT()</code> 方法，搞过某验其他产品的就知道这里是 16 位随机值。</p><p><img src="https://cdn.itbob.cn/img/article/062/12.png" alt="12"></p><p>然后 t 的值，和某验其他系列产品一样，用到了 RSA 加密算法，这里图中 <code>BPqG()</code> 就是 RSA 算法，t 的值就是 RSA 加密后的结果，扣的时候注意找到算法开头的地方，将整个 <code>BPqG()</code> 方法扣下来即可。</p><p><img src="https://cdn.itbob.cn/img/article/062/13.png" alt="13"></p><p><img src="https://cdn.itbob.cn/img/article/062/14.png" alt="14"></p><h3><span id="huo-qu-e-zhi">获取 e 值</span></h3><p>接下来是 e 的值，<code>e = CoUE[ymDv(24)](NFeB)</code>，很明显是将 <code>NFeB</code> 的值进行了处理，<code>NFeB</code> 是个对象，里面有一些 <code>data</code>、<code>id</code> 等信息，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/062/15.png" alt="15"></p><p>所以我们得先找一下 <code>NFeB</code> 这个值是怎么来的，直接搜索发现只有四个地方，在第 6109 行就是定义的地方，挨个看，首先有个 s 参数，将 id 传入到一个函数进行处理，函数没啥特别的，直接扣就行，通常经过处理后，s 的值为空，即 <code>s=&quot;&quot;</code>。</p><p><img src="https://cdn.itbob.cn/img/article/062/16.png" alt="16"></p><p>再来看有个 u 值，由一个方法生成了一大串包含很多感叹号的字符串，本案例实际测试中，直接将这个值置空也行，可能其他校验严格或者大批量请求的情况下，说不定也会校验的，所以我们最好也跟进去找一下生成逻辑。</p><p><img src="https://cdn.itbob.cn/img/article/062/17.png" alt="17"></p><p>跟进这个方法，里面是一些浏览器环境的值，比如屏幕高宽、canvas、ua、浏览器插件、时间、时区、语言等等，基本上都能写死，后续会将这些值以 <code>!!</code> 相连接最终生成 u 的值。</p><p><img src="https://cdn.itbob.cn/img/article/062/18.png" alt="18"></p><p>然后继续看，接下来是 c 值，是一个对象，值为 <code>&#123;&quot;key&quot;:0,&quot;value&quot;:[]&#125;</code>，我这里直接写死了。</p><p><img src="https://cdn.itbob.cn/img/article/062/19.png" alt="19"></p><p>再往下就是 <code>NFeB</code> 了：</p><p><img src="https://cdn.itbob.cn/img/article/062/20.png" alt="20"></p><p>Unicode 转换一下，简单解一下混淆，就长下面这样：</p><pre><code class="hljs javascript">NFeB = &#123;    <span class="hljs-string">&quot;id&quot;</span>: a[<span class="hljs-string">&quot;id&quot;</span>],    <span class="hljs-string">&quot;page_id&quot;</span>: a[<span class="hljs-string">&quot;page_id&quot;</span>],    <span class="hljs-string">&quot;lang&quot;</span>: a[<span class="hljs-string">&quot;lang&quot;</span>] || AUJ_(<span class="hljs-number">31</span>),    <span class="hljs-string">&quot;data&quot;</span>: &#123;        <span class="hljs-string">&quot;insights&quot;</span>: u || <span class="hljs-literal">null</span>,        <span class="hljs-string">&quot;track_key&quot;</span>: c[<span class="hljs-string">&quot;value&quot;</span>] ? c[<span class="hljs-string">&quot;key&quot;</span>] : <span class="hljs-literal">null</span>,        <span class="hljs-string">&quot;track&quot;</span>: c[<span class="hljs-string">&quot;value&quot;</span>] || <span class="hljs-literal">null</span>,        <span class="hljs-string">&quot;ep&quot;</span>: o[<span class="hljs-string">&quot;KZrg&quot;</span>](i),        <span class="hljs-string">&quot;eco&quot;</span>: <span class="hljs-built_in">window</span>[<span class="hljs-string">&quot;GEERANDOMTOKEN&quot;</span>] || <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-string">&quot;ww3&quot;</span>: <span class="hljs-string">&quot;&quot;</span>    &#125;&#125;;</code></pre><p><code>id</code> 不用说，<code>page_id</code> 就是个时间戳，<code>lang</code> 中文就是 <code>zh-cn</code>，<code>insights</code> 是前面得到的 <code>u</code> 值，<code>track_key</code>、<code>track</code> 取 <code>c</code> 的键和值，<code>ep</code> 将 <code>i</code> 传入了一个函数进行处理，<code>i</code> 是固定的字符串 <code>client</code>，这个 <code>KZrg</code> 方法可以跟进去看看，里面其实有很多都是定值，唯一需要注意的是 <code>t[&quot;tm&quot;]</code> 这个值，和某验其他系列一样，是 <code>window.performance.timing</code> 的值，自己获取一下时间戳随机加减伪造一下就行了。</p><p><img src="https://cdn.itbob.cn/img/article/062/21.png" alt="21"></p><p>然后就是 <code>eco</code> 的值，取的 <code>window.GEERANDOMTOKEN</code>，打印一下 window，除了有这个 token 以外，还可以看到 <code>localStore</code>、<code>session</code> 里面也有这个值。</p><p><img src="https://cdn.itbob.cn/img/article/062/22.png" alt="22"></p><p><img src="https://cdn.itbob.cn/img/article/062/23.png" alt="23"></p><p>由于某验的 JS 都是混淆后的，不太好定位这个值生成的地方，所以拿出我们的 Hook 大法，先清除一下缓存，不然的话是 Hook 不到值的，Hook 代码如下：</p><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> token = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">window</span>, <span class="hljs-string">&#x27;GEERANDOMTOKEN&#x27;</span>, &#123;        <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;GEERANDOMTOKEN-&gt;&#x27;</span>, val);            <span class="hljs-keyword">debugger</span>;            token = val;            <span class="hljs-keyword">return</span> val;        &#125;,        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;            <span class="hljs-keyword">return</span> token;        &#125;    &#125;);&#125;)();</code></pre><p><img src="https://cdn.itbob.cn/img/article/062/24.png" alt="24"></p><p>断下后往前跟栈，<code>window[o] = t</code>，<code>o</code> 就是 <code>GEERANDOMTOKEN</code>，<code>t</code> 就是我们想要的值。</p><p><img src="https://cdn.itbob.cn/img/article/062/25.png" alt="25"></p><p>往上就可以找到 <code>t</code> 的生成方法，核心就是生成一个 32 位的随机字符串，然后加上时间戳，再进行 MD5 加密得到最终值，生成位置以及实现的代码如下：</p><p><img src="https://cdn.itbob.cn/img/article/062/26.png" alt="26"></p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> MD5 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;md5&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getToken</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">var</span> t = MD5(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> t = [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;G&quot;</span>,<span class="hljs-string">&quot;H&quot;</span>,<span class="hljs-string">&quot;I&quot;</span>,<span class="hljs-string">&quot;J&quot;</span>,<span class="hljs-string">&quot;K&quot;</span>,<span class="hljs-string">&quot;L&quot;</span>,<span class="hljs-string">&quot;M&quot;</span>,<span class="hljs-string">&quot;N&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;P&quot;</span>,<span class="hljs-string">&quot;Q&quot;</span>,<span class="hljs-string">&quot;R&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;T&quot;</span>,<span class="hljs-string">&quot;U&quot;</span>,<span class="hljs-string">&quot;V&quot;</span>,<span class="hljs-string">&quot;W&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;Y&quot;</span>,<span class="hljs-string">&quot;Z&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>,<span class="hljs-string">&quot;g&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;i&quot;</span>,<span class="hljs-string">&quot;j&quot;</span>,<span class="hljs-string">&quot;k&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;m&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;q&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,<span class="hljs-string">&quot;s&quot;</span>,<span class="hljs-string">&quot;t&quot;</span>,<span class="hljs-string">&quot;u&quot;</span>,<span class="hljs-string">&quot;v&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>,<span class="hljs-string">&quot;z&quot;</span>], n = <span class="hljs-string">&quot;&quot;</span>, r = <span class="hljs-number">0</span>; r &lt; e; r++)            n += t[<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">61</span> * <span class="hljs-built_in">Math</span>.random(), <span class="hljs-number">10</span>)];        <span class="hljs-keyword">return</span> n;    &#125;(<span class="hljs-number">32</span>) + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime());    <span class="hljs-keyword">return</span> t;&#125;</code></pre><p>当你把以上这些参数都搞完了，你可能认为都齐了，其实不然，后面接着还有一句 <code>Yvwp(NFeB, r)</code>，将 r 的值增加到了 <code>NFeB</code> 里，这个 r 的值类似于 <code>&#123;olbo: &quot;1588069361&quot;&#125;</code>，这个键值对都是每隔一段时间会变的，这个在某验系列其他文章里也提过。</p><p><img src="https://cdn.itbob.cn/img/article/062/27.png" alt="27"></p><p>进一步分析，这个 r 是传进来的，所以往上跟栈，有个 <code>r[psPG(1183)]()</code> 方法就生成了这个对象：</p><p><img src="https://cdn.itbob.cn/img/article/062/28.png" alt="28"></p><p>继续跟到这个方法里去，首先定义了 e 这个对象，然后赋值 <code>e = &#123;ep: &quot;test data&quot;, lang: &quot;zh&quot;&#125;</code>，然后经过 <code>window[tYlM(1126)]()</code> 方法处理后，e 里面就新增了 <code>&#123;olbo: &quot;1588069361&quot;&#125;</code>，后续将 ep 和 lang 两个值删除后返回。</p><p><img src="https://cdn.itbob.cn/img/article/062/29.png" alt="29"></p><p>所以我们继续跟进 <code>window[tYlM(1126)]()</code> 方法，会跳转到 gct.xxxx.js 里，这个 JS 就是我们开头讲过的，他的名称会每隔一段时间变化，内容也会变，所以导致生成的键值对也会变化，继续跟，有个 <code>t[e] = xxx</code> 的语句，其中 e 和等号右边的值，就是我们需要的键值对。</p><p><img src="https://cdn.itbob.cn/img/article/062/30.png" alt="30"></p><p>这个键值对在我们本地也可以动态获取，只需要请求正确的 JS 文件，将要调用的方法全局导出就行了，以下给一个我的处理方法示例（注意里面请求 url 已经脱敏处理，所以不可直接运行，自行抓包补上）：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> json<span class="hljs-keyword">import</span> execjs<span class="hljs-keyword">import</span> requests<span class="hljs-keyword">from</span> loguru <span class="hljs-keyword">import</span> loggerheaders = &#123;    <span class="hljs-string">&quot;user-agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36&quot;</span>,&#125;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_gct</span>():</span>    url = <span class="hljs-string">&quot;https://dkapi.脱敏处理.com/deepknow/v2/gettype&quot;</span>    params = &#123;        <span class="hljs-string">&quot;callback&quot;</span>: <span class="hljs-string">&quot;脱敏处理_&quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(time.time() * <span class="hljs-number">1000</span>))    &#125;    response = requests.get(url, headers=headers, params=params).text    response = json.loads(re.findall(<span class="hljs-string">r&quot;geetest_\d+\((.*?)\)&quot;</span>, response)[<span class="hljs-number">0</span>])    <span class="hljs-comment"># gettype 接口返回的 gct.xxx.js 的地址</span>    gct_path = <span class="hljs-string">&quot;https://static.脱敏处理.com&quot;</span> + response[<span class="hljs-string">&quot;gct_path&quot;</span>]    logger.info(<span class="hljs-string">&quot;gct_path: %s&quot;</span> % gct_path)    gct_js = requests.get(gct_path, headers=headers).text    <span class="hljs-comment"># 正则匹配需要调用的方法名称</span>    function_name = re.findall(<span class="hljs-string">r&quot;\)\)\&#123;return (.*?)\(&quot;</span>, gct_js)[<span class="hljs-number">0</span>]    <span class="hljs-comment"># 查找需要插入全局导出代码的位置</span>    break_position = gct_js.find(<span class="hljs-string">&quot;return function(t)&#123;&quot;</span>)    <span class="hljs-comment"># window.gct 全局导出方法</span>    gct_js_new = gct_js[:break_position] + <span class="hljs-string">&quot;window.gct=&quot;</span> + function_name + <span class="hljs-string">&quot;;&quot;</span> + gct_js[break_position:]    <span class="hljs-comment"># 添加自定义方法调用 window.gct 获取键值对</span>    gct_js_new = <span class="hljs-string">&quot;window = global;&quot;</span> + gct_js_new + <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    function getGct()&#123;</span><span class="hljs-string">        var e = &#123;&quot;lang&quot;: &quot;zh&quot;, &quot;ep&quot;: &quot;test data&quot;&#125;;</span><span class="hljs-string">        window.gct(e);</span><span class="hljs-string">        delete e[&quot;lang&quot;];</span><span class="hljs-string">        delete e[&quot;ep&quot;];</span><span class="hljs-string">        return e;</span><span class="hljs-string">    &#125;&quot;&quot;&quot;</span>    gct = execjs.<span class="hljs-built_in">compile</span>(gct_js_new).call(<span class="hljs-string">&quot;getGct&quot;</span>)    logger.info(<span class="hljs-string">&quot;gct: %s&quot;</span> % gct)    <span class="hljs-keyword">return</span> gct</code></pre><p>到这里我们 <code>NFeB</code> 就生成完毕了，回到 <code>e</code> 的值，这里其实就是把 <code>NFeB</code> 转成字符串，直接 <code>JSON.stringify()</code> 即可。</p><p><img src="https://cdn.itbob.cn/img/article/062/31.png" alt="31"></p><h3><span id="huo-qu-l-zhi">获取 l 值</span></h3><p>l 的值比较简单，就是将前面生成的 <code>h[&quot;aeskey&quot;]</code> 作为 key，<code>e</code> 作为待加密字符串，经过 AES 加密后即可得到 l 的值。</p><p><img src="https://cdn.itbob.cn/img/article/062/32.png" alt="32"></p><p>本地复现如下（有些变量名称不一样无影响，我是直接复用的某验其他产品的方法）：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;crypto-js&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aesEncrypt</span>(<span class="hljs-params">e, i</span>) </span>&#123;    <span class="hljs-keyword">var</span> key = CryptoJS.enc.Utf8.parse(i),    iv = CryptoJS.enc.Utf8.parse(<span class="hljs-string">&quot;0000000000000000&quot;</span>),    srcs = CryptoJS.enc.Utf8.parse(e),    encrypted = CryptoJS.AES.encrypt(srcs, key, &#123;        <span class="hljs-attr">iv</span>: iv,        <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,        <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7    &#125;);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> r = encrypted, o = r.ciphertext.words, i = r.ciphertext.sigBytes, s = [], a = <span class="hljs-number">0</span>; a &lt; i; a++) &#123;        <span class="hljs-keyword">var</span> c = o[a &gt;&gt;&gt; <span class="hljs-number">2</span>] &gt;&gt;&gt; <span class="hljs-number">24</span> - a % <span class="hljs-number">4</span> * <span class="hljs-number">8</span> &amp; <span class="hljs-number">255</span>;        s.push(c);    &#125;    <span class="hljs-keyword">return</span> s;&#125;</code></pre><h3><span id="jin-yi-bu-chu-li-l">进一步处理 l</span></h3><p>最后一步 <code>e = DWYi[ymDv(1137)](l)</code>，将 l 的值经过了 <code>tc_t</code> 这个方法进行处理，就会得到最终 <code>Request Payload</code> 的一部分。</p><p><img src="https://cdn.itbob.cn/img/article/062/33.png" alt="33"></p><p>跟进这个 <code>tc_t</code> 方法，又是熟悉的 <code>return e[&quot;res&quot;] + e[&quot;end&quot;]</code>，同样和某验其他产品一样的。</p><p><img src="https://cdn.itbob.cn/img/article/062/34.png" alt="34"></p><p>跟到处理 e 的这个方法里，最后返回的是 <code>&#123;&quot;res&quot;: a, &quot;end&quot;: s&#125;</code>，没啥特别的，直接扣即可，这里注意和某验其他产品里的方法有些小区别，里面有些常量的值是不一样的，最开始我直接复用了其他产品的方法，发现结果是错的。</p><p><img src="https://cdn.itbob.cn/img/article/062/35.png" alt="35"></p><p>自此整个流程分析完毕，最终 <code>e + h[AUJ_(1173)]</code> 的值与 <code>Request Payload</code> 的值一致。</p><p><img src="https://cdn.itbob.cn/img/article/062/36.png" alt="36"></p><p><img src="https://cdn.itbob.cn/img/article/062/37.png" alt="37"></p><h2><span id="jie-guo-yan-zheng">结果验证</span></h2><p><img src="https://cdn.itbob.cn/img/article/062/38.png" alt="38"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;极验全家桶，交流请咨询微信：IT-BOB&lt;/st</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>极验行为验证，四代滑块验证码逆向分析</title>
    <link href="https://www.itbob.cn/article/061/"/>
    <id>https://www.itbob.cn/article/061/</id>
    <published>2022-12-25T12:00:00.000Z</published>
    <updated>2022-12-25T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><blockquote><p><strong>极验全家桶，交流请咨询微信：IT-BOB</strong><br><strong>极验全家桶，交流请咨询微信：IT-BOB</strong><br><strong>极验全家桶，交流请咨询微信：IT-BOB</strong></p></blockquote><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#tong-xun-liu-cheng">通讯流程</a></li><li><a href="#yan-zheng-ma-liu-cheng-fen-xi">验证码流程分析</a></li><li><a href="#ni-xiang-fen-xi">逆向分析</a><ul><li><a href="#captcha-id-can-shu">captcha_id 参数</a></li><li><a href="#challenge-can-shu">challenge 参数</a></li><li><a href="#w-can-shu">w 参数</a></li></ul></li><li><a href="#jie-guo-yan-zheng">结果验证</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：某验四代滑块验证码，w 参数逆向</li><li>主页：<code>aHR0cHM6Ly9ndDQuZ2VldGVzdC5jb20v</code></li><li>加密算法：RSA、AES</li></ul><h2><span id="tong-xun-liu-cheng">通讯流程</span></h2><p><img src="https://cdn.itbob.cn/img/article/061/01.png" alt="01"></p><h2><span id="yan-zheng-ma-liu-cheng-fen-xi">验证码流程分析</span></h2><p>进入网页后，打开开发者人员工具进行抓包，点击滑动拼图验证，此时还未点击按钮开始验证，抓到了一个名为 <code>load?captcha_id=xxx</code> 的包，<code>Query String Parameters</code> 包含了一些参数：</p><p><img src="https://cdn.itbob.cn/img/article/061/02.png" alt="02"></p><ul><li><code>captcha_id</code>：验证码 id，固定值，由 <code>adaptive-captcha-demo.js</code> 文件生成，后文分析；</li><li><code>challenge</code>：动态变化，由 <code>gtc4.js</code> 文件生成，后文分析；</li><li><code>client_type</code>：表示 web 端；</li><li><code>risk_type</code>：验证码类型，例如滑块为 slide，无感为 ai；</li><li><code>lang</code>：语言；</li><li><code>callback</code>：geetest_ + 时间戳，主要作用是防止缓存。</li></ul><p>响应预览中返回的关键内容如下，相较于三代，底图未做混淆：</p><p><img src="https://cdn.itbob.cn/img/article/061/03.png" alt="03"></p><ul><li><code>bg</code>：背景图片地址；</li><li><code>captcha_type</code>：验证码类型；</li><li><code>gct_path</code>：gct4 文件路径；</li><li><code>lot_number</code>：后续生成 pow_msg、w 的关键参数；</li><li><code>payload</code>：后续 verify 请求接口需要的参数；</li><li><code>datetime</code>：ISO 8601扩展格式的日期，后续生成 pow_msg 的关键参数；</li><li><code>process_token</code>：后续 verify 请求接口需要的参数；</li><li><code>slice</code>：滑块图片地址。</li></ul><p>点击按钮开始验证，弹出滑块验证码，滑动滑块，抓包到 <code>verify?captcha_id=xxx</code>，<code>Query String Parameters</code> 同样包含了一些参数：</p><p><img src="https://cdn.itbob.cn/img/article/061/04.png" alt="04"></p><ul><li><code>captcha_id</code>：与 load 接口请求头中的 captcha_id 一致；</li><li><code>client_type</code>：表示 web 端；</li><li><code>lot_number</code>：load 接口返回的；</li><li><code>risk_type</code>：与 load 接口中的一致，表示验证码类型；</li><li><code>payload</code>：load 接口返回的；</li><li><code>process_token</code>：load 接口返回的；</li><li><code>w</code>：加密参数，由轨迹、滑动时间、滑动距离、userresponse、device_id、pow_msg 等参数加密得到；</li><li><code>callback</code>：geetest_ + 时间戳，主要作用是防止缓存。</li></ul><p>响应预览中返回的内容如下，result 值为 fail 即校验失败，success 为校验通过，通过后携带 seccode 下的参数进行后续业务请求：</p><p><img src="https://cdn.itbob.cn/img/article/061/05.png" alt="05"></p><h2><span id="ni-xiang-fen-xi">逆向分析</span></h2><h3><span id="captcha-id-can-shu">captcha_id 参数</span></h3><p>全局搜索 <code>captcha_id</code>，跟进到 gt4.js 文件中：</p><p><img src="https://cdn.itbob.cn/img/article/061/06.png" alt="06"></p><p>进去后在第 307 行打上断点，刷新页面即会断住，此时 <code>captcha_id</code> 参数的值已经生成，同时 challenge 参数定义在下一行：</p><p><img src="https://cdn.itbob.cn/img/article/061/07.png" alt="07"></p><p>向上跟栈到 value，即 <code>adaptive-captcha-demo.js</code> 文件中，会发现其是个固定值，实际上这个值是每个网站不一样，是管理员在极验后台申请得到的：</p><p><img src="https://cdn.itbob.cn/img/article/061/08.png" alt="08"></p><h3><span id="challenge-can-shu">challenge 参数</span></h3><p>前面提到，<code>challenge</code> 参数定义在 <code>captcha_id</code> 参数的下一行，在 gt4.js 文件的第 309 行打下断点：</p><p><img src="https://cdn.itbob.cn/img/article/061/09.png" alt="09"></p><p>可以看到，challenge 参数的值由 <code>uuid</code> 函数生成，扣出即可。</p><h3><span id="w-can-shu">w 参数</span></h3><p>从 <code>verify?captcha_id=xxx</code> 接口的堆栈处跟栈进去：</p><p><img src="https://cdn.itbob.cn/img/article/061/10.png" alt="10"></p><p>打下断点滑动滑块断住后，向上跟栈到 s 处，如果做过某验三代滑块的话，第 6249 行有个很熟悉的东西，<code>&quot;\u0077&quot;: r</code>，<code>&quot;\u0077&quot;</code> 即字母 w 的 Unicode 值，r 即 w 参数的值：</p><p><img src="https://cdn.itbob.cn/img/article/061/11.png" alt="11"></p><p>r 参数定义在第 6237 行，e 也是跟三代类似的参数，r 是将 i 参数和转为字符串的 e 参数加密得到的：</p><p><img src="https://cdn.itbob.cn/img/article/061/12.png" alt="12"></p><p>向上跟栈，找到 e 参数中各部分定义生成的位置，跟到 <code>$_BHIH</code> 中，_ 中先生成了四个键值对：</p><p><img src="https://cdn.itbob.cn/img/article/061/13.png" alt="13"></p><p><code>passtime</code> 和 <code>track</code> 是熟悉的滑动时间和轨迹，<code>setLeft</code> 为识别出来的缺口距离，<code>userresponse</code> 定义在 19593 行， a 为 <code>setLeft</code> 参数的值，<code>t[$_GDFCG(1909)]</code> 为定值 1.0059466666666665：</p><pre><code class="hljs JavaScript">a / t[$_GDFCG(<span class="hljs-number">1909</span>)] + <span class="hljs-number">2</span></code></pre><p>接着跟到 <code>$_BCFj</code> 中，e 定义在第 6201 行，下面几行定义了 e 中的 <code>device_id</code>、<code>lot_number</code>、<code>pow_msg</code>、<code>pow_sign</code>：</p><p><img src="https://cdn.itbob.cn/img/article/061/14.png" alt="14"></p><p><code>device_id</code> 同一个网站是固定值，<code>lot_number</code> 是 load 响应返回的，控制台打印一下 <code>pow_msg</code>、<code>pow_sign</code> 的结果：</p><p><img src="https://cdn.itbob.cn/img/article/061/15.png" alt="15"></p><p><code>pow_msg</code> 很明显是由几部分组成的，<code>pow_sign</code> 经过加密，向上跟栈到 init 中，分别定义在第 5837 行和第 5838 行，为 d 字典的键，根据键名取值：</p><p><img src="https://cdn.itbob.cn/img/article/061/16.png" alt="16"></p><p>d 定义在第 5835 行，这部分还原一下就很明显了：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> c = t[<span class="hljs-string">&quot;toDataURL&quot;</span>]()[<span class="hljs-string">&quot;replace&quot;</span>](<span class="hljs-string">&quot;data:image/png;base64,&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)    , _ = <span class="hljs-keyword">new</span> w[<span class="hljs-string">&quot;default&quot;</span>][<span class="hljs-string">&quot;MD5&quot;</span>]()[<span class="hljs-string">&quot;hex&quot;</span>](c);a[<span class="hljs-string">&quot;options&quot;</span>][<span class="hljs-string">&quot;deviceId&quot;</span>] = _;<span class="hljs-keyword">var</span> h = a[<span class="hljs-string">&quot;options&quot;</span>]    , l = h[<span class="hljs-string">&quot;powDetail&quot;</span>]    , p = h[<span class="hljs-string">&quot;lotNumber&quot;</span>]    , f = h[<span class="hljs-string">&quot;captchaId&quot;</span>]    , d = v[<span class="hljs-string">&quot;default&quot;</span>](p, f, l[<span class="hljs-string">&quot;hashfunc&quot;</span>], l[<span class="hljs-string">&quot;version&quot;</span>], l[<span class="hljs-string">&quot;bits&quot;</span>], l[<span class="hljs-string">&quot;datetime&quot;</span>], <span class="hljs-string">&quot;&quot;</span>)</code></pre><p>跟进到 <code>v[&quot;default&quot;]</code> 中，函数定义在第 6945 行，于 6978 行打下断点：</p><p><img src="https://cdn.itbob.cn/img/article/061/17.png" alt="17"></p><p><code>pow_msg</code> 由 <code>_ + h</code> 得到，<code>_</code> 定义在第 6960 行：</p><pre><code class="hljs JavaScript">_ = i + <span class="hljs-string">&quot;|&quot;</span> + r + <span class="hljs-string">&quot;|&quot;</span> + n + <span class="hljs-string">&quot;|&quot;</span> + s + <span class="hljs-string">&quot;|&quot;</span> + t + <span class="hljs-string">&quot;|&quot;</span> + e + <span class="hljs-string">&quot;|&quot;</span> + o + <span class="hljs-string">&quot;|&quot;</span>;</code></pre><ul><li>i：<code>l[&quot;version&quot;]</code></li><li>r：<code>l[&quot;bits&quot;]</code></li><li>n：<code>l[&quot;hashfunc&quot;]</code></li><li>s：<code>l[&quot;datetime&quot;]</code></li><li>t：<code>f, h[&quot;captchaId&quot;]</code></li><li>e：<code>p, h[&quot;lotNumber&quot;]</code></li><li>o：<code>&quot;&quot;</code></li></ul><p>h 定义在第 6269 行，跟进去是 16 位随机数字符串，<code>pow_sign</code> 为 p，就是 <code>pow_msg</code> 经过 MD5 加密得到的：</p><p><img src="https://cdn.itbob.cn/img/article/061/18.png" alt="18"></p><p>至此这四个也分析完了，还差以下这部分：</p><p><img src="https://cdn.itbob.cn/img/article/061/19.png" alt="19"></p><p>em 等定值就不分析了，注意 <code>kqg5：&quot;1557244628&quot;</code>，这个参数值和三代滑块中一样，每隔几个小时会改变，向上跟栈到 <code>$_BCFj</code> 中，在第 6207 行打下断点，此时 e 中这个值还未生成：</p><p><img src="https://cdn.itbob.cn/img/article/061/20.png" alt="20"></p><p>下一行打下断点，下步断点，即执行完 <code>n[$_CBHIE(791)](e);</code> 后，这个参数值就生成了，证明是 <code>n[$_CBHIE(791)]</code> 方法生成的，跟进去：</p><p><img src="https://cdn.itbob.cn/img/article/061/21.png" alt="21"></p><p>跳转到第 5766 行，在第 5779 行打下断点，此时的 n 中还未生成此参数：</p><p><img src="https://cdn.itbob.cn/img/article/061/22.png" alt="22"></p><p>执行了 <code>_gct(n)</code> 后即生成：</p><p><img src="https://cdn.itbob.cn/img/article/061/23.png" alt="23"></p><p>可见其生成位置在 <code>_gct</code> 方法中，跟进去后到 gct4.js 文件，和三代大差不差：</p><p><img src="https://cdn.itbob.cn/img/article/061/24.png" alt="24"></p><p>可以将值导出，至此 e 就分析完了，接着回到第 6238 行，跟进到加密函数 <code>d[$_CBHHO(84)]</code> 中，定义在第 11669 行，<code>d[$_DIEHS(177)](c) + u</code> 即 r 参数的值，c 为一个大数组，u 明显也经过加密了，所以 r 参数的值就是数组 c 加密后再加上 u 得到的：</p><p><img src="https://cdn.itbob.cn/img/article/061/25.png" alt="25"></p><p>先跟进到 u，其定义在第 11705 行，解混淆后如下：</p><pre><code class="hljs JavaScript">u = <span class="hljs-keyword">new</span> l[<span class="hljs-string">&quot;default&quot;</span>]()[<span class="hljs-string">&quot;encrypt&quot;</span>](i);</code></pre><p>所以 u 是 i 经过加密后得到的，i 定义在第 11702 行：</p><pre><code class="hljs JavaScript">i = (<span class="hljs-number">0</span>,d[$_DIEIq(<span class="hljs-number">103</span>)])()</code></pre><p>跟进到 <code>d[$_DIEIq(103)]</code> 中，定义在第 852 行，又是熟悉的 16 位随机数：</p><p><img src="https://cdn.itbob.cn/img/article/061/26.png" alt="26"></p><p>i 是随机数，跟进到加密函数 <code>l[($_DIEHS(84))]</code> 中，在第 12725 行，于 12741 行打下断点，可以看到这里就是个 RSA 加密，扣代码或者直接引库即可：</p><p><img src="https://cdn.itbob.cn/img/article/061/27.png" alt="27"></p><p>回到 c 参数，c 参数的值为一个大数组，其定义在第 11705 行，解混淆后内容如下：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> c = s[a][<span class="hljs-string">&quot;symmetrical&quot;</span>][<span class="hljs-string">&quot;encrypt&quot;</span>](e, i);</code></pre><p>e 之前分析完了，i 为随机数，两个参数已经分析完了，跟进到加密方法中，在第 12174 行，于 12186 行打下断点，控制台打印一下混淆部分内容，很熟悉的东西，这里就是 AES 加密，iv 为初始向量，加密模式为 CBC：</p><p><img src="https://cdn.itbob.cn/img/article/061/28.png" alt="28"></p><p>c 参数最后又被 <code>d[$_DIEHS(177)]</code> 函数加密，跟进后，定义在第 547 行，直接扣下来改改即可：</p><p><img src="https://cdn.itbob.cn/img/article/061/29.png" alt="29"></p><h2><span id="jie-guo-yan-zheng">结果验证</span></h2><p><img src="https://cdn.itbob.cn/img/article/061/30.png" alt="30"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;极验全家桶，交流请咨询微信：IT-BOB&lt;/st</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>极验行为验证，三代滑块验证码逆向分析</title>
    <link href="https://www.itbob.cn/article/060/"/>
    <id>https://www.itbob.cn/article/060/</id>
    <published>2022-12-20T12:00:00.000Z</published>
    <updated>2022-12-20T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><blockquote><p><strong>极验全家桶，交流请咨询微信：IT-BOB</strong><br><strong>极验全家桶，交流请咨询微信：IT-BOB</strong><br><strong>极验全家桶，交流请咨询微信：IT-BOB</strong></p></blockquote><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#tong-xun-liu-cheng">通讯流程</a></li><li><a href="#zhua-bao-fen-xi">抓包分析</a></li><li><a href="#ni-xiang-fen-xi">逆向分析</a><ul><li><a href="#w-can-shu">w 参数</a><ul><li><a href="#u-can-shu">u 参数</a></li><li><a href="#l-can-shu">l 参数</a></li></ul></li><li><a href="#di-tu-huan-yuan">底图还原</a></li><li><a href="#cuo-wu-jie-guo">错误结果</a></li><li><a href="#jie-guo-yan-zheng">结果验证</a></li></ul></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：某验三代滑块验证码，底图还原及 w 参数逆向</li><li>验证码 demo 列表：<code>aHR0cHM6Ly93d3cuZ2VldGVzdC5jb20vZGVtby8=</code></li><li>滑块验证码：<code>aHR0cHM6Ly93d3cuZ2VldGVzdC5jb20vZGVtby9zbGlkZS1mbG9hdC5odG1s</code></li><li>加密算法：RSA、AES、MD5</li></ul><h2><span id="tong-xun-liu-cheng">通讯流程</span></h2><p>接口相关：</p><p><img src="https://cdn.itbob.cn/img/article/060/01.png" alt="01"></p><p>完整流程：</p><p><img src="https://cdn.itbob.cn/img/article/060/02.jpg" alt="02"></p><h2><span id="zhua-bao-fen-xi">抓包分析</span></h2><p>进入网页后，打开开发者人员工具进行抓包</p><p>1.未点击按钮进行验证之前，Network 中抓包到了以下信息：</p><p><img src="https://cdn.itbob.cn/img/article/060/03.png" alt="03"></p><p><code>register-slide?t=xxx</code>：注册滑块请求，响应预览中返回的信息中重要的是 gt 和 challenge，gt 是固定值，不同网页对应不同的 gt 值，类似于特征码，challenge 的值每次刷新页面都会变化，gt 参数会通过 url string 的形式传递给 gettype.php：</p><p><img src="https://cdn.itbob.cn/img/article/060/04.png" alt="04"></p><p><code>gettype.php?gt=xxx&amp;callback=xxx</code>：获取验证码，HTTP 请求中不同的请求方式和设置不同的 Content-Type 时，参数传递的方式会不一样，一般为 Query String Parameters、Form Data、Request Payload，这里是 Query String Parameters，在 GET 请求时，参数会以 url string 的形式进行传递，即 ? 后的字符串则为其请求参数，并以 &amp; 作为分隔符，这里传递了 gt 参数的值以及 callback，callback 为 geetest_ + 时间戳：</p><p><img src="https://cdn.itbob.cn/img/article/060/05.png" alt="05"></p><p>响应预览中返回了一些 js 文件及对应的版本号：</p><p><img src="https://cdn.itbob.cn/img/article/060/06.png" alt="06"></p><p>第一个<code> get.php?xxx</code>，url 中传递了一些参数，关键部分如下：</p><ul><li><code>gt</code>：register-slide 响应返回的 gt 值；</li><li><code>challenge</code>：register-slide 响应返回的 challenge 值；</li><li><code>w</code>：对轨迹、滑动时间等进行加密后的参数，该网站第一个 w 值可以直接置空；</li><li><code>callback</code>：geetest_ + 时间戳。</li></ul><p><img src="https://cdn.itbob.cn/img/article/060/07.png" alt="07"></p><p>响应内容如下，这里没什么需要注意的，feedback 就是某验的帮助中心：</p><p><img src="https://cdn.itbob.cn/img/article/060/08.png" alt="08"></p><p>2.点击按钮进行验证之后，Network 中抓包到了以下信息：</p><p><img src="https://cdn.itbob.cn/img/article/060/09.png" alt="09"></p><p>第一个 <code>ajax.php?xxx</code>，url 中传递了一些参数，关键部分如下：</p><ul><li><code>gt</code>：register-slide 响应返回的 gt 值；</li><li><code>challenge</code>：register-slide 响应返回的 challenge 值；</li><li><code>w</code>：对轨迹、滑动时间等进行加密后的参数，该网站第二个 w 值也可以直接置空；</li><li><code>callback</code>：geetest_ + 时间戳。</li></ul><p><img src="https://cdn.itbob.cn/img/article/060/10.png" alt="10"></p><p>响应返回验证码模式，滑块验证码为 slide，点选验证码为 click：</p><p><img src="https://cdn.itbob.cn/img/article/060/11.png" alt="11"></p><p>第二个 <code>get.php?xxx</code>，url 中传递了一些参数，关键部分如下：</p><ul><li><code>gt</code>：register-slide 响应返回的 gt 值；</li><li><code>challenge</code>：register-slide 响应返回的 challenge 值；</li><li><code>callback</code>：geetest_ + 时间戳。</li></ul><p><img src="https://cdn.itbob.cn/img/article/060/12.png" alt="12"></p><p>这个响应返回了很多关键内容：</p><ul><li><code>bg</code>：被打乱的带缺口背景图，需要还原，<code>372fe236d.webp</code></li></ul><p><img src="https://cdn.itbob.cn/img/article/060/13.png" alt="13"></p><ul><li><code>fullbg</code>：被打乱的完整背景图，需要还原，<code>7bfaaa72b.webp</code></li></ul><p><img src="https://cdn.itbob.cn/img/article/060/14.png" alt="14"></p><ul><li><code>slice</code>：滑块图片，不需要还原，<code>372fe236d.png</code></li></ul><p><img src="https://cdn.itbob.cn/img/article/060/15.png" alt="15"></p><ul><li><code>c</code>：关键参数，与后面 aa 参数的值有关，固定值；</li><li><code>s</code>：关键参数，与后面 aa 参数的值有关。</li></ul><p><img src="https://cdn.itbob.cn/img/article/060/16.png" alt="16"></p><p>第二个 <code>ajax.php?xxx</code>，url 中传递了一些参数，关键部分如下：</p><ul><li><code>gt</code>：register-slide 响应返回的 gt 值；</li><li><code>challenge</code>：register-slide 响应返回的 challenge 值 + 两位字符串，注意多了两位，是第二个 get.php?xxx 返回值中得到的；</li><li><code>w</code>：对轨迹、滑动时间等进行加密后的参数，需要通过逆向得到；</li><li><code>callback</code>：geetest_ + 时间戳。</li></ul><p><img src="https://cdn.itbob.cn/img/article/060/17.png" alt="17"></p><p>滑动滑块验证通过即会返回以下内容：</p><p><img src="https://cdn.itbob.cn/img/article/060/18.png" alt="18"></p><p>失败则会返回：</p><p><img src="https://cdn.itbob.cn/img/article/060/19.png" alt="19"></p><h2><span id="ni-xiang-fen-xi">逆向分析</span></h2><h3><span id="w-can-shu">w 参数</span></h3><p>跟到 w 参数的值方法很多，以下讲两种：</p><p>1.很简便，w 参数在 js 文件中有特征码，点击按钮进行验证之后，ctrl + shift + f 全局搜索 <code>&quot;\u0077&quot;</code>，因为 <code>\u0077</code> 就是 w 的 Unicode 编码，然后点击进入 slide.7.8.9.js 文件中，7.8.9 为当前版本，注意没点击验证的话是不会有这个 js 文件的：</p><p><img src="https://cdn.itbob.cn/img/article/060/20.png" alt="20"></p><p>进入后点击左下角 <code>&#123;&#125;</code> 大括号，格式化文件，再 ctrl + f  局部搜索 <code>&quot;\u0077&quot;</code>，只有一个结果，在第 6086 行，在第 6088 行打下断点，滑动滑块即会断住，h + u 即为 w 参数的值：</p><p><img src="https://cdn.itbob.cn/img/article/060/21.png" alt="21"></p><p>2.通过 Initiator 跟栈，跟进到 <code>$_CId</code> 中：</p><p><img src="https://cdn.itbob.cn/img/article/060/22.png" alt="22"></p><p>进去同样格式化后，会跳转到第 4583 行，在该行打下断点：</p><p><img src="https://cdn.itbob.cn/img/article/060/23.png" alt="23"></p><p>向上跟栈到 <code>$_CCBv</code> 中同样会找到刚刚的位置：</p><p><img src="https://cdn.itbob.cn/img/article/060/24.png" alt="24"></p><p>由以上分析可知，w 参数是 h 和 u 相加得到的，所以找到定义的位置，看看是怎么构造生成的，u 参数定义在第 6077 行，h 参数定义在第 6079 行，内容如下：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> u = r[$_CAIAt(<span class="hljs-number">754</span>)](), l = V[$_CAIAt(<span class="hljs-number">353</span>)](gt[$_CAIAt(<span class="hljs-number">218</span>)](o), r[$_CAIAt(<span class="hljs-number">756</span>)]()), h = m[$_CAIAt(<span class="hljs-number">782</span>)](l)</code></pre><p>可以看到，h 参数是传入了 l 参数后经过 <code>m[$_CAIAt(782)]</code> 方法处理后得到的，所以依次往下分析，现在看看 u 参数是怎么生成的：</p><h4><span id="u-can-shu">u 参数</span></h4><p>u 参数通过 <code>r[$_CAIAt(754)]</code> 方法生成，选中后跟进到方法定义位置：</p><p><img src="https://cdn.itbob.cn/img/article/060/25.png" alt="25"></p><p>会跳转到第 6218 行，在 6227 行 return 处打下断点，重新拖动滑块，即会断住：</p><p><img src="https://cdn.itbob.cn/img/article/060/26.png" alt="26"></p><p>e 为 u 参数的值，其定义在第 6266 行：</p><pre><code class="hljs JavaScript">e = <span class="hljs-keyword">new</span> U()[$_CBGAZ(<span class="hljs-number">353</span>)](<span class="hljs-built_in">this</span>[$_CBGAZ(<span class="hljs-number">756</span>)](!<span class="hljs-number">0</span>));</code></pre><p>在控制台中打印输出一下各部分内容：</p><p><img src="https://cdn.itbob.cn/img/article/060/27.png" alt="27"></p><pre><code class="hljs JavaScript">e = <span class="hljs-keyword">new</span> U()[<span class="hljs-string">&quot;encrypt&quot;</span>](<span class="hljs-built_in">this</span>[<span class="hljs-string">&quot;$_CCEc&quot;</span>](!<span class="hljs-number">0</span>));</code></pre><p>从打印出来的结果可以看出，e 参数的值可能是将 16 位的随机字符串加密后得到的，跟进到 <code>this[$_CBGAZ(756)]</code> 中验证一下：</p><p><img src="https://cdn.itbob.cn/img/article/060/28.png" alt="28"></p><p>跳转到第 6208 行，在第 6214 行 return 处打下断点：</p><p><img src="https://cdn.itbob.cn/img/article/060/29.png" alt="29"></p><p><code>Ot</code> 即 16 为字符串，<code>Ot = rt()</code>，跟进到 <code>rt</code> 函数中，在第 4213 行，于第 4219 行打下断点后会发现，16 位字符串是由四个 <code>t()</code> 方法的结果相加得到的：</p><p><img src="https://cdn.itbob.cn/img/article/060/30.png" alt="30"></p><p>跟进到 <code>t()</code> 方法的定义位置，在第 4203 行，第 4208 行即为随机字符串算法：</p><p><img src="https://cdn.itbob.cn/img/article/060/31.png" alt="31"></p><p>还原混淆后内容如下，<code>Math.random()</code> 是随机选取大于等于 0.0 且小于 1.0 的伪随机 double 值，<code>toString(16)</code> 为十六进制字符串：</p><pre><code class="hljs javascript">(<span class="hljs-number">65536</span> * (<span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>[<span class="hljs-string">&quot;random&quot;</span>]()) | <span class="hljs-number">0</span>)[<span class="hljs-string">&quot;toString&quot;</span>](<span class="hljs-number">16</span>)[<span class="hljs-string">&quot;substring&quot;</span>](<span class="hljs-number">1</span>)</code></pre><p>JavaScript 复现：</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">random</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> random_str = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-number">4</span>; index++) &#123;        random_str += (<span class="hljs-number">65536</span> * (<span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>[<span class="hljs-string">&quot;random&quot;</span>]()) | <span class="hljs-number">0</span>)[<span class="hljs-string">&quot;toString&quot;</span>](<span class="hljs-number">16</span>)[<span class="hljs-string">&quot;substring&quot;</span>](<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> random_str;&#125;</code></pre><p><code>this[&quot;$_CCEc&quot;]</code> 分析完了，那 <code>new U()[&quot;encrypt&quot;]</code> 是什么呢，选中 <code>new U()</code> 后，从原型链中可以看到 <code>setPublic</code>，根据经验很有可能就是 RSA 加密设置公钥，加解密相关算法可以查看往期文章 <a href="https://www.itbob.cn/article/045/">CTF&amp;爬虫：掌握这些特征，一秒识别密文加密方式</a>：</p><p><img src="https://cdn.itbob.cn/img/article/060/32.png" alt="32"></p><p>跟进去查看一下：</p><p><img src="https://cdn.itbob.cn/img/article/060/33.png" alt="33"></p><p>跳转到第 2908 行，在第 2922 行断住后，<code>$_BACAs(332)</code> 的值为 <code>&quot;Invalid RSA public key&quot;</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/34.png" alt="34"></p><p>第 2908 行，ut 函数传入了两个值，t 为公钥值，e 为公钥模数，都是固定值：</p><ul><li><code>t</code>：<code>&quot;00C1E3934D1614465B33053E7F48EE4EC87B14B95EF88947713D25EECBFF7E74C7977D02DC1D9451F79DD5D1C10C29ACB6A9B4D6FB7D0A0279B6719E1772565F09AF627715919221AEF91899CAE08C0D686D748B20A3603BE2318CA6BC2B59706592A9219D0BF05C9F65023A21D2330807252AE0066D59CEEFA5F2748EA80BAB81&quot;</code></li><li><code>e</code>：<code>&quot;10001&quot;</code></li></ul><p>这里可以直接引库复现，也可以选择将算法部分扣下来，局部搜索 <code>var U = function</code>，在第 2043 行，将整个自执行函数扣下来，这里随机数后期写成固定值，后面也有随机数，不然会造成传参不匹配：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> U = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 此处过长，省略</span>&#125;();<span class="hljs-comment">// 随机数, 一组四个数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">t</span>(<span class="hljs-params"></span>) </span>&#123;    random_str = (<span class="hljs-number">65536</span> * (<span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>[<span class="hljs-string">&quot;random&quot;</span>]()) | <span class="hljs-number">0</span>)[<span class="hljs-string">&quot;toString&quot;</span>](<span class="hljs-number">16</span>)[<span class="hljs-string">&quot;substring&quot;</span>](<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> random_str;&#125;<span class="hljs-comment">// 随机数, 四个数一组, 四组</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRandomStr</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> t() + t() + t() + t();&#125;<span class="hljs-comment">// u 值</span><span class="hljs-keyword">var</span> u = <span class="hljs-keyword">new</span> U()[<span class="hljs-string">&#x27;encrypt&#x27;</span>](getRandomStr());<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;u 参数的值为:&#x27;</span>, u);</code></pre><p>运行后报错提示，<code>QBLnx is not defined</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/35.png" alt="35"></p><p>其定义在第 136 行，是个函数对象，补上即可：</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">QBLnx</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</code></pre><p>运行后报错提示，<code>$_IBAe is not a function</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/36.png" alt="36"></p><p>搜索后可知，其定义在第 128 行：</p><p><img src="https://cdn.itbob.cn/img/article/060/37.png" alt="37"></p><p>跟进过去将该部分扣下来：</p><pre><code class="hljs JavaScript">QBLnx.$_CM = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> QBLnx.$_Ak.$_DBGGT === <span class="hljs-string">&#x27;function&#x27;</span> ? QBLnx.$_Ak.$_DBGGT.apply(QBLnx.$_Ak, <span class="hljs-built_in">arguments</span>) : QBLnx.$_Ak.$_DBGGT;&#125;;</code></pre><p>接着报错提示，<code>Cannot read property '$_DBGGT' of undefined</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/38.png" alt="38"></p><p>定义在第 7 行，直接将 <code>QBLnx.$_Ak</code> 整个扣下来即可，然后会报错提示，window 和 ht 未定义，ht 为 navigator：</p><p><img src="https://cdn.itbob.cn/img/article/060/39.png" alt="39"></p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">window</span> = &#123;    <span class="hljs-string">&quot;navigator&quot;</span>: &#123;        <span class="hljs-string">&quot;appName&quot;</span>: <span class="hljs-string">&quot;Netscape&quot;</span>,    &#125;,&#125;ht = <span class="hljs-built_in">window</span>[<span class="hljs-string">&quot;navigator&quot;</span>];</code></pre><p>又报错提示，<code>QBLnx.$_Db is not a function</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/40.png" alt="40"></p><p>其定义在第 132 行，扣下来补上：</p><pre><code class="hljs JavaScript">QBLnx.$_Db = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> QBLnx.$_BP.$_DBHGJ === <span class="hljs-string">&#x27;function&#x27;</span> ? QBLnx.$_BP.$_DBHGJ.apply(QBLnx.$_BP, <span class="hljs-built_in">arguments</span>) : QBLnx.$_BP.$_DBHGJ;&#125;;</code></pre><p>报错提示，<code>Cannot read property '$_DBHGJ' of undefined</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/41.png" alt="41"></p><p>通过搜索，其定义在第 68 行，将 <code>QBLnx.$_BP</code> 整个扣下来即可，至此，u 参数成功复现：</p><p><img src="https://cdn.itbob.cn/img/article/060/42.png" alt="42"></p><h4><span id="l-can-shu">l 参数</span></h4><p>u 参数解决后，接着需要分析 l 参数，内容如下：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 混淆</span>l = V[$_CAIAt(<span class="hljs-number">353</span>)](gt[$_CAIAt(<span class="hljs-number">218</span>)](o), r[$_CAIAt(<span class="hljs-number">756</span>)]());<span class="hljs-comment">// 未混淆</span>l = V[<span class="hljs-string">&quot;encrypt&quot;</span>](gt[<span class="hljs-string">&quot;stringify&quot;</span>](o), r[<span class="hljs-string">&quot;$_CCEc&quot;</span>]());</code></pre><p>可以知道，l 参数的结果是将 <code>gt[&quot;stringify&quot;](o)</code> 和 <code>r[&quot;$_CCEc&quot;]()</code> 加密后得到的，先来分析 <code>r[&quot;$_CCEc&quot;]()</code> ，选中后跟进进去，跳转到了熟悉的第 6208 行，就是之前的 16 位随机字符串：</p><p><img src="https://cdn.itbob.cn/img/article/060/43.png" alt="43"></p><p>将这里写成跟之前一样的固定值， <code>gt[&quot;stringify&quot;](o)</code> 返回的是 JSON 格式的数据，由 o 参数生成：</p><p><img src="https://cdn.itbob.cn/img/article/060/44.png" alt="44"></p><p>对比分析以下 o 参数中，哪些是定值，哪些是动态变化的，可以看到箭头所指的值都不一样了：</p><p><img src="https://cdn.itbob.cn/img/article/060/45.png" alt="45"></p><ul><li><code>userresponse</code>：滑动距离 + challenge 的值；</li><li><code>passtime</code>：滑块滑动时间；</li><li><code>imgload</code>：图片加载时间；</li><li><code>aa</code>：轨迹加密；</li><li><code>ep-tm</code>：<code>window[&quot;performance&quot;][&quot;timing&quot;]</code> 相关；</li><li><code>mocq</code>：每天 key、value 会变，后文分析；</li><li><code>rp</code>：gt + 32 位 challenge + passtime，再经过 MD5 加密。</li></ul><p>接下来对关键值进行分析，先来分析下 <code>userresponse</code>，o 定义在第 6012 行：</p><p><img src="https://cdn.itbob.cn/img/article/060/46.png" alt="46"></p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> o = &#123;    <span class="hljs-string">&quot;lang&quot;</span>: i[$_CAIAt(<span class="hljs-number">116</span>)] || $_CAHJd(<span class="hljs-number">103</span>),    <span class="hljs-string">&quot;userresponse&quot;</span>: H(t, i[$_CAHJd(<span class="hljs-number">182</span>)]),    <span class="hljs-string">&quot;passtime&quot;</span>: n,    <span class="hljs-string">&quot;imgload&quot;</span>: r[$_CAIAt(<span class="hljs-number">750</span>)],    <span class="hljs-string">&quot;aa&quot;</span>: e,    <span class="hljs-string">&quot;ep&quot;</span>: r[$_CAHJd(<span class="hljs-number">714</span>)]()&#125;;</code></pre><p><code>userresponse</code> 定义在第 6014 行，需要分析 <code>H(t, i[$_CAHJd(182)])</code>，控制台打印一下：</p><p><img src="https://cdn.itbob.cn/img/article/060/47.png" alt="47"></p><p>t 为滑动滑块的距离，需要注意的是 <code>i[$_CAHJd(182)]</code> 为第二个 <code>ajax.php?xxx</code> 传递的 <code>challenge</code>，比注册请求时的 <code>challenge</code> 长两位，再将 H 参数扣下来即可，其定义在第 704 行，报错提示，<code>$_CJFA is not defined</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/48.png" alt="48"></p><p>定义在第 159 行：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> $_CJEl = QBLnx.$_CM, $_CJDa = [<span class="hljs-string">&#x27;$_CJHo&#x27;</span>].concat($_CJEl), $_CJFA = $_CJDa[<span class="hljs-number">1</span>];</code></pre><p>至此，<code>userresponse</code> 成功复现，接下来看 <code>passtime</code>，<code>n</code> 值此时已经生成了，为 1010，向上跟栈到 <code>$_CGlj</code> 中：</p><p><img src="https://cdn.itbob.cn/img/article/060/49.png" alt="49"></p><p><code>n[$_DAAAV(871)]</code> 为 <code>passtime</code> 值，定义在第 8164 行，为滑动结束时间 - 开始时间：</p><p><img src="https://cdn.itbob.cn/img/article/060/50.png" alt="50"></p><p>接下来分析下 <code>aa</code> 参数，其定义在第 6017 行，值由参数 <code>e</code> 传递，同样向上跟栈到 <code>$_CGlj</code> 中，为第 8168 行的 l 值，l 定义在第 8167 行，三个参数加密后得到：</p><p><img src="https://cdn.itbob.cn/img/article/060/51.png" alt="51"></p><ul><li><code>n[$_DAAAV(913)][$_CJJJb(1066)]()</code> ：轨迹加密后的结果；</li><li><code>n[$_DAAAV(69)][$_CJJJb(1097)]</code> ：c 值，在第二个 <code>get.php?xxx</code> 返回的响应中得到；</li><li><code>n[$_DAAAV(69)][$_CJJJb(319)]</code> ：s 值，在第二个 <code>get.php?xxx</code> 返回的响应中得到。</li></ul><p><img src="https://cdn.itbob.cn/img/article/060/52.png" alt="52"></p><p>接下来跟进到 <code>n[$_DAAAV(913)][$_CJJJb(1066)]</code> 中，分析下轨迹是如何加密的，在第 4065 行，于第 4133 行打下断点，第 4108 行的 <code>this[$_BEHAL(343)]</code> 即为轨迹值，关于轨迹算法后面会专门出一期文章：</p><p><img src="https://cdn.itbob.cn/img/article/060/53.png" alt="53"></p><p>将整个算法部分抠出来，先将轨迹值固定，写成参数传递进去，不然会报错提示，<code>Cannot read property 'length' of undefined</code>，因为轨迹值是别的算法生成的，不传值即为空，运行程序，会报错提示，<code>ct is not defined</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/54.png" alt="54"></p><p>ct 定义在第 4223 行，扣下来，报错提示，<code>(intermediate value)[$_BEHAL(...)] is not a function</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/55.png" alt="55"></p><p>定义在第 4326 行，补上以下内容，即可复现：</p><pre><code class="hljs JavaScript">ct[<span class="hljs-string">&quot;prototype&quot;</span>] = &#123;<span class="hljs-string">&quot;\u0024\u005f\u0043\u0041\u0051&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t</span>) </span>&#123;        <span class="hljs-keyword">var</span> $_BFFJi = QBLnx.$_CM            , $_BFFIX = [<span class="hljs-string">&#x27;$_BFGCq&#x27;</span>].concat($_BFFJi)            , $_BFGAT = $_BFFIX[<span class="hljs-number">1</span>];        $_BFFIX.shift();        <span class="hljs-keyword">var</span> $_BFGBV = $_BFFIX[<span class="hljs-number">0</span>];        <span class="hljs-keyword">var</span> e = <span class="hljs-built_in">this</span>[$_BFFJi(<span class="hljs-number">461</span>)];        <span class="hljs-keyword">if</span> (e[$_BFGAT(<span class="hljs-number">419</span>)])            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ct(e[$_BFFJi(<span class="hljs-number">419</span>)](t));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = [], r = <span class="hljs-number">0</span>, i = e[$_BFGAT(<span class="hljs-number">125</span>)]; r &lt; i; r += <span class="hljs-number">1</span>)            n[r] = t(e[r], r, <span class="hljs-built_in">this</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ct(n);    &#125;,&#125;;</code></pre><p>结果对比一致：</p><p><img src="https://cdn.itbob.cn/img/article/060/56.png" alt="56"></p><p>后面三个参数的值都分析完了，回到第 8167 行 l 处，跟进到 <code>n[$_DAAAV(913)][$_DAAAV(1059)]</code> 中，在第 4135 行，扣下来即可：</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAA</span>(<span class="hljs-params">t, e, n</span>) </span>&#123;    <span class="hljs-keyword">var</span> $_BEIJl = QBLnx.$_CM      , $_BEIIt = [<span class="hljs-string">&#x27;$_BEJC_&#x27;</span>].concat($_BEIJl)      , $_BEJAy = $_BEIIt[<span class="hljs-number">1</span>];    $_BEIIt.shift();    <span class="hljs-keyword">var</span> $_BEJBr = $_BEIIt[<span class="hljs-number">0</span>];    <span class="hljs-keyword">if</span> (!e || !n)        <span class="hljs-keyword">return</span> t;    <span class="hljs-keyword">var</span> r, i = <span class="hljs-number">0</span>, o = t, s = e[<span class="hljs-number">0</span>], a = e[<span class="hljs-number">2</span>], _ = e[<span class="hljs-number">4</span>];    <span class="hljs-keyword">while</span> (r = n[$_BEIJl(<span class="hljs-number">229</span>)](i, <span class="hljs-number">2</span>)) &#123;        i += <span class="hljs-number">2</span>;        <span class="hljs-keyword">var</span> c = <span class="hljs-built_in">parseInt</span>(r, <span class="hljs-number">16</span>)          , u = <span class="hljs-built_in">String</span>[$_BEJAy(<span class="hljs-number">237</span>)](c)          , l = (s * c * c + a * c + _) % t[$_BEJAy(<span class="hljs-number">125</span>)];        o = o[$_BEJAy(<span class="hljs-number">229</span>)](<span class="hljs-number">0</span>, l) + u + o[$_BEJAy(<span class="hljs-number">229</span>)](l);    &#125;    <span class="hljs-keyword">return</span> o;&#125;;</code></pre><p>将 c 和 s 写为固定值，对比结果一致：</p><p><img src="https://cdn.itbob.cn/img/article/060/57.png" alt="57"></p><p>aa 参数分析完成，接下来分析 rp 参数，定义在第 6076 行：</p><p><img src="https://cdn.itbob.cn/img/article/060/58.png" alt="58"></p><pre><code class="hljs JavaScript"><span class="hljs-comment">// 混淆</span>o[$_CAIAt(<span class="hljs-number">791</span>)] = X(i[$_CAIAt(<span class="hljs-number">104</span>)] + i[$_CAIAt(<span class="hljs-number">182</span>)][$_CAHJd(<span class="hljs-number">139</span>)](<span class="hljs-number">0</span>, <span class="hljs-number">32</span>) + o[$_CAHJd(<span class="hljs-number">704</span>)]);<span class="hljs-comment">// 未混淆</span>o[<span class="hljs-string">&quot;rp&quot;</span>] = X(i[<span class="hljs-string">&quot;gt&quot;</span>] + i[<span class="hljs-string">&quot;challenge&quot;</span>][<span class="hljs-string">&quot;slice&quot;</span>](<span class="hljs-number">0</span>, <span class="hljs-number">32</span>) + o[<span class="hljs-string">&quot;passtime&quot;</span>]);</code></pre><p>后面三个参数都很明显了，跟进到 X 函数中，在第 1876 行，扣下来即可，对比结果一致：</p><p><img src="https://cdn.itbob.cn/img/article/060/59.png" alt="59"></p><p>这里是 MD5 加密，也可以直接通过引库复现：</p><p><img src="https://cdn.itbob.cn/img/article/060/60.png" alt="60"></p><p>ep 定义在第 6018 行，跟进到 <code>r[$_CAHJd(714)]</code> 中，tm 参数定义在第 6239 行：</p><p><img src="https://cdn.itbob.cn/img/article/060/61.png" alt="61"></p><p>跟进 <code>new bt()[$_CBGEC(760)]</code> 中，在第 5268 行打下断点，tm 结果如下：</p><p><img src="https://cdn.itbob.cn/img/article/060/62.png" alt="62"></p><p>o 中这个键值对内容每天都会变化：</p><p><img src="https://cdn.itbob.cn/img/article/060/63.png" alt="63"></p><p>在第 6021 行打下断点，此时的 o 中还没有生成以上键值对：</p><p><img src="https://cdn.itbob.cn/img/article/060/64.png" alt="64"></p><p>接着往下找，第 6026 行 <code>a = window[$_CAHJd(744)](s)</code> 执行之后 s 中生成了以上的键值对，所以跟进到 <code>window[$_CAHJd(744)]</code> 中，会跳转到 <code>gct.xxxxxxxx.js</code> 文件中，这个文件的路径可以从 get.php 接口获取到：</p><p><img src="https://cdn.itbob.cn/img/article/060/65.png" alt="65"></p><p>在该文件的第 1253 行打下断点，可以看到此时的 t 中已经生成了 <code>h9s9: &quot;1803797734&quot;</code> ：</p><p><img src="https://cdn.itbob.cn/img/article/060/66.png" alt="66"></p><p>跟进到 <code>StJC</code> 方法中，其定义在第 1202 行，在第 1208 行打下断点，键值对在此处生成，可以通过全局导出调用：</p><p><img src="https://cdn.itbob.cn/img/article/060/67.png" alt="67"></p><p>至此，参数 o 复现完毕，回到第 6078 行，分析完 <code>V[$_CAIAt(353)]</code> l 即完成，跟进，定义在第 3218 行，在第 3230 行打下断点，这里为 AES 加密，初始向量 iv 值为 <code>&quot;0000000000000000&quot;</code>：</p><p><img src="https://cdn.itbob.cn/img/article/060/68.png" alt="68"></p><p>直接引库复现：</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aesV</span>(<span class="hljs-params">o_text, random_str</span>) </span>&#123;    <span class="hljs-keyword">var</span> key = CryptoJS.enc.Utf8.parse(random_str);    <span class="hljs-keyword">var</span> iv = CryptoJS.enc.Utf8.parse(<span class="hljs-string">&quot;0000000000000000&quot;</span>);    <span class="hljs-keyword">var</span> srcs = CryptoJS.enc.Utf8.parse(o_text);    <span class="hljs-keyword">var</span> encrypted = CryptoJS.AES.encrypt(srcs, key, &#123;        <span class="hljs-attr">iv</span>: iv,        <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,        <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7    &#125;);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> r = encrypted, o = r.ciphertext.words, i = r.ciphertext.sigBytes, s = [], a = <span class="hljs-number">0</span>; a &lt; i; a++) &#123;        <span class="hljs-keyword">var</span> c = o[a &gt;&gt;&gt; <span class="hljs-number">2</span>] &gt;&gt;&gt; <span class="hljs-number">24</span> - a % <span class="hljs-number">4</span> * <span class="hljs-number">8</span> &amp; <span class="hljs-number">255</span>;        s.push(c);    &#125;    <span class="hljs-keyword">return</span> s;&#125;;</code></pre><p>对比结果一致：</p><p><img src="https://cdn.itbob.cn/img/article/060/69.png" alt="69"></p><p>l 参数分析完毕，终于只剩下一个 h 了，<code>m[$_CAIAt(782)](l)</code> 即将 l 加密后得到的，跟进 <code>m[$_CAIAt(782)]</code>，定义在第 1568 行，在第 1575 行打下断点，为 e 中两个 value 值相加：</p><p><img src="https://cdn.itbob.cn/img/article/060/70.png" alt="70"></p><p>e 定义在第 1574 行，t 为传入的 l 参数，跟进到 <code>this[$_GFJn(264)]</code> 中，在第 1523 行，复现如下：</p><p><img src="https://cdn.itbob.cn/img/article/060/71.png" alt="71"></p><p>校验结果一致：</p><p><img src="https://cdn.itbob.cn/img/article/060/72.png" alt="72"></p><p>w 参数至此终于全部复现完成！</p><h3><span id="di-tu-huan-yuan">底图还原</span></h3><p>前文说过，拿到的完整背景图以及带缺口背景图都是被打乱了的，这里需要还原才能计算滑动距离以及轨迹等，极验的底图是通过 Canvas 绘制出来的，直接打下事件断点：</p><p><img src="https://cdn.itbob.cn/img/article/060/73.png" alt="73"></p><p>点击按钮进行验证即会断住，格式化后跳转到第 295 行，</p><p><img src="https://cdn.itbob.cn/img/article/060/74.png" alt="74"></p><p>简单解一波混淆，会清晰一些：</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">$_BEG</span>(<span class="hljs-params">t, e</span>) </span>&#123;    <span class="hljs-keyword">var</span> $_DAHHo = QBLnx.$_Db()[<span class="hljs-number">12</span>][<span class="hljs-number">19</span>];    <span class="hljs-keyword">for</span> (; $_DAHHo !== QBLnx.$_Db()[<span class="hljs-number">15</span>][<span class="hljs-number">16</span>];) &#123;        <span class="hljs-keyword">switch</span> ($_DAHHo) &#123;            <span class="hljs-keyword">case</span> QBLnx.$_Db()[<span class="hljs-number">15</span>][<span class="hljs-number">19</span>]:                t = t[<span class="hljs-string">&quot;$_CGz&quot;</span>],                e = e[<span class="hljs-string">&quot;$_CGz&quot;</span>];                <span class="hljs-keyword">var</span> n = t[<span class="hljs-string">&quot;width&quot;</span>]                    , r = t[<span class="hljs-string">&quot;height&quot;</span>]                    , i = h[<span class="hljs-string">&quot;createElement&quot;</span>](<span class="hljs-string">&quot;canvas&quot;</span>);                i[<span class="hljs-string">&quot;width&quot;</span>] = n,                i[<span class="hljs-string">&quot;height&quot;</span>] = r;                $_DAHHo = QBLnx.$_Db()[<span class="hljs-number">3</span>][<span class="hljs-number">18</span>];                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> QBLnx.$_Db()[<span class="hljs-number">0</span>][<span class="hljs-number">18</span>]:                <span class="hljs-keyword">var</span> o = i[<span class="hljs-string">&quot;getContext&quot;</span>](<span class="hljs-string">&quot;2d&quot;</span>);                o[<span class="hljs-string">&quot;drawImage&quot;</span>](t, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);                <span class="hljs-keyword">var</span> s = e[<span class="hljs-string">&quot;getContext&quot;</span>](<span class="hljs-string">&quot;2d&quot;</span>);                $_DAHHo = QBLnx.$_Db()[<span class="hljs-number">0</span>][<span class="hljs-number">17</span>];                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> QBLnx.$_Db()[<span class="hljs-number">12</span>][<span class="hljs-number">17</span>]:                e[<span class="hljs-string">&quot;height&quot;</span>] = <span class="hljs-number">160</span>,                e[<span class="hljs-string">&quot;width&quot;</span>] = <span class="hljs-number">260</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> a = r / <span class="hljs-number">2</span>, _ = <span class="hljs-number">0</span>; _ &lt; <span class="hljs-number">52</span>; _ += <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">var</span> c = Ut[_] % <span class="hljs-number">26</span> * <span class="hljs-number">12</span> + <span class="hljs-number">1</span>                        , u = <span class="hljs-number">25</span> &lt; Ut[_] ? a : <span class="hljs-number">0</span>                        , l = o[<span class="hljs-string">&quot;getImageData&quot;</span>](c, u, <span class="hljs-number">10</span>, a);                    s[<span class="hljs-string">&quot;putImageData&quot;</span>](l, _ % <span class="hljs-number">26</span> * <span class="hljs-number">10</span>, <span class="hljs-number">25</span> &lt; _ ? a : <span class="hljs-number">0</span>);                &#125;                $_DAHHo = QBLnx.$_Db()[<span class="hljs-number">15</span>][<span class="hljs-number">16</span>];                <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;</code></pre><p>控制流平坦化混淆，可以通过 AST 技术解混淆，AST 相关可以看往期文章：<a href="https://www.itbob.cn/article/051/">逆向进阶，利用 AST 技术还原 JavaScript 混淆代码</a>，这里就不对此进行讲解了，这里就是 Canvas 绘图的过程，关键乱序算法部分在 <code>QBLnx.$_Db()[12][17]</code> 中：</p><pre><code class="hljs JavaScript">e[<span class="hljs-string">&quot;height&quot;</span>] = <span class="hljs-number">160</span>,e[<span class="hljs-string">&quot;width&quot;</span>] = <span class="hljs-number">260</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> a = r / <span class="hljs-number">2</span>, _ = <span class="hljs-number">0</span>; _ &lt; <span class="hljs-number">52</span>; _ += <span class="hljs-number">1</span>) &#123;    <span class="hljs-keyword">var</span> c = Ut[_] % <span class="hljs-number">26</span> * <span class="hljs-number">12</span> + <span class="hljs-number">1</span>        , u = <span class="hljs-number">25</span> &lt; Ut[_] ? a : <span class="hljs-number">0</span>        , l = o[<span class="hljs-string">&quot;getImageData&quot;</span>](c, u, <span class="hljs-number">10</span>, a);    s[<span class="hljs-string">&quot;putImageData&quot;</span>](l, _ % <span class="hljs-number">26</span> * <span class="hljs-number">10</span>, <span class="hljs-number">25</span> &lt; _ ? a : <span class="hljs-number">0</span>);&#125;</code></pre><p>原图比例为 312 x 160，宽为 320，长为 160：</p><p><img src="https://cdn.itbob.cn/img/article/060/75.png" alt="75"></p><p><code>e[&quot;height&quot;] = 160</code>、<code>e[&quot;width&quot;] = 260</code> 指还原后的图片比例为 260 x 160，a 的值为 r / 2 即 80，就是将整张图片分为了上下两等分，再将图片纵向切割为了 26 等份，Ut 数组的长度为 52，<code>Ut[_]</code> 即依次取数组中的元素，<code>Ut</code> 数组即为图片还原的顺序，是固定的，<code>25 &lt; Ut[_] ? a : 0 </code> 判断图片是上半部分还是下半部分，<code>_ % 26 * 10</code> 表示每个小块取 10 px 像素，正确图片的顺序为：</p><p><img src="https://cdn.itbob.cn/img/article/060/76.png" alt="76"></p><pre><code class="hljs JavaScript">[<span class="hljs-number">39</span>,<span class="hljs-number">38</span>,<span class="hljs-number">48</span>,<span class="hljs-number">49</span>,<span class="hljs-number">41</span>,<span class="hljs-number">40</span>,<span class="hljs-number">46</span>,<span class="hljs-number">47</span>,<span class="hljs-number">35</span>,<span class="hljs-number">34</span>,<span class="hljs-number">50</span>,<span class="hljs-number">51</span>,<span class="hljs-number">33</span>,<span class="hljs-number">32</span>,<span class="hljs-number">28</span>,<span class="hljs-number">29</span>,<span class="hljs-number">27</span>,<span class="hljs-number">26</span>,<span class="hljs-number">36</span>,<span class="hljs-number">37</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">44</span>,<span class="hljs-number">45</span>,<span class="hljs-number">43</span>,<span class="hljs-number">42</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">23</span>,<span class="hljs-number">22</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">21</span>,<span class="hljs-number">20</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">25</span>,<span class="hljs-number">24</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">10</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">19</span>,<span class="hljs-number">18</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>]</code></pre><p>示例：</p><p><img src="https://cdn.itbob.cn/img/article/060/77.png" alt="77"></p><p>Python 复现：</p><pre><code class="hljs JavaScript">def restore_picture():    img_list = [<span class="hljs-string">&quot;./乱序缺口背景图.png&quot;</span>, <span class="hljs-string">&quot;./乱序背景图.png&quot;</span>]    <span class="hljs-keyword">for</span> index, img <span class="hljs-keyword">in</span> enumerate(img_list):        image = Image.open(img)        s = Image.new(<span class="hljs-string">&quot;RGBA&quot;</span>, (<span class="hljs-number">260</span>, <span class="hljs-number">160</span>))        ut = [<span class="hljs-number">39</span>, <span class="hljs-number">38</span>, <span class="hljs-number">48</span>, <span class="hljs-number">49</span>, <span class="hljs-number">41</span>, <span class="hljs-number">40</span>, <span class="hljs-number">46</span>, <span class="hljs-number">47</span>, <span class="hljs-number">35</span>, <span class="hljs-number">34</span>, <span class="hljs-number">50</span>, <span class="hljs-number">51</span>, <span class="hljs-number">33</span>, <span class="hljs-number">32</span>, <span class="hljs-number">28</span>, <span class="hljs-number">29</span>, <span class="hljs-number">27</span>, <span class="hljs-number">26</span>, <span class="hljs-number">36</span>, <span class="hljs-number">37</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>, <span class="hljs-number">43</span>,<span class="hljs-number">42</span>,<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">23</span>, <span class="hljs-number">22</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">21</span>, <span class="hljs-number">20</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">25</span>, <span class="hljs-number">24</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">19</span>, <span class="hljs-number">18</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>]        height_half = <span class="hljs-number">80</span>        <span class="hljs-keyword">for</span> inx <span class="hljs-keyword">in</span> range(<span class="hljs-number">52</span>):            c = ut[inx] % <span class="hljs-number">26</span> * <span class="hljs-number">12</span> + <span class="hljs-number">1</span>            u = height_half <span class="hljs-keyword">if</span> ut[inx] &gt; <span class="hljs-number">25</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>            l_ = image.crop(box=(c, u, c + <span class="hljs-number">10</span>, u + <span class="hljs-number">80</span>))            s.paste(l_, box=(inx % <span class="hljs-number">26</span> * <span class="hljs-number">10</span>, <span class="hljs-number">80</span> <span class="hljs-keyword">if</span> inx &gt; <span class="hljs-number">25</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>))        <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span>:            s.save(<span class="hljs-string">&quot;./缺口背景图片.png&quot;</span>)        <span class="hljs-attr">else</span>:            s.save(<span class="hljs-string">&quot;./背景图片.png&quot;</span>)</code></pre><p>还原后如下：</p><p><img src="https://cdn.itbob.cn/img/article/060/78.png" alt="78"></p><h3><span id="cuo-wu-jie-guo">错误结果</span></h3><pre><code class="hljs JavaScript"><span class="hljs-comment">// challenge 不对</span>geetest_xxxxxxxxxxxxx(&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;illegal challenge&quot;</span>, <span class="hljs-string">&quot;user_error&quot;</span>: <span class="hljs-string">&quot;\u7f51\u7edc\u4e0d\u7ed9\u529b&quot;</span>, <span class="hljs-string">&quot;error_code&quot;</span>: <span class="hljs-string">&quot;error_23&quot;</span>&#125;)<span class="hljs-comment">// w 不对</span>geetest_xxxxxxxxxxxxx(&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;param decrypt error&quot;</span>, <span class="hljs-string">&quot;user_error&quot;</span>: <span class="hljs-string">&quot;\u7f51\u7edc\u4e0d\u7ed9\u529b&quot;</span>, <span class="hljs-string">&quot;error_code&quot;</span>: <span class="hljs-string">&quot;error_03&quot;</span>&#125;)<span class="hljs-comment">// 无轨迹</span>geetest_xxxxxxxxxxxxx(&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;not proof&quot;</span>, <span class="hljs-string">&quot;user_error&quot;</span>: <span class="hljs-string">&quot;\u7f51\u7edc\u4e0d\u7ed9\u529b&quot;</span>, <span class="hljs-string">&quot;error_code&quot;</span>: <span class="hljs-string">&quot;error_21&quot;</span>&#125;)<span class="hljs-comment">// 轨迹、缺口距离、参数问题</span>geetest_xxxxxxxxxxxxx(&#123;<span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;fail&quot;</span>&#125;)geetest_xxxxxxxxxxxxx(&#123;<span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;forbidden&quot;</span>&#125;)</code></pre><h3><span id="jie-guo-yan-zheng">结果验证</span></h3><p>100 次大概 95% 的成功率：</p><p><img src="https://cdn.itbob.cn/img/article/060/79.jpg" alt="79"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;极验全家桶，交流请咨询微信：IT-BOB&lt;/st</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>极验行为验证，二代滑块验证码逆向分析</title>
    <link href="https://www.itbob.cn/article/059/"/>
    <id>https://www.itbob.cn/article/059/</id>
    <published>2022-12-18T12:00:00.000Z</published>
    <updated>2022-12-18T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><blockquote><p><strong>极验全家桶，交流请咨询微信：IT-BOB</strong><br><strong>极验全家桶，交流请咨询微信：IT-BOB</strong><br><strong>极验全家桶，交流请咨询微信：IT-BOB</strong></p></blockquote><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#zhua-bao-qing-kuang">抓包情况</a></li><li><a href="#ni-xiang-fen-xi">逆向分析</a><ul><li><a href="#huo-qu-h7z-zhi">获取 H7z 值</a></li><li><a href="#huo-qu-r7z-zhi">获取 r7z 值</a><ul><li><a href="#huo-qu-userresponse-zhi">获取 userresponse 值</a></li><li><a href="#huo-qu-passtime-zhi">获取 passtime  值</a></li><li><a href="#huo-qu-imgload-zhi">获取 imgload 值</a></li><li><a href="#huo-qu-aa-zhi">获取 aa 值</a></li><li><a href="#huo-qu-ep-zhi">获取 ep 值</a></li><li><a href="#huo-qu-rp-zhi">获取 rp 值</a></li></ul></li><li><a href="#huo-qu-w-zhi">获取 w 值</a></li></ul></li><li><a href="#jie-guo-yan-zheng">结果验证</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：某验二代滑块验证码逆向分析</li><li>主页：<code>aHR0cDovL3d3dy5qc2dzai5nb3YuY246NTg4ODgvbWluaS9uZXR3ZWIvU01MaWJyYXJ5LmpzcA==</code></li><li>说明：大多数逻辑其实和三四代都一样，相同的就简写了，有疑惑的地方可以看以前的文章</li><li><a href="https://www.itbob.cn/article/060/">某验行为验证，三代滑块验证码逆向分析</a></li><li><a href="https://www.itbob.cn/article/061/">某验行为验证，四代滑块验证码逆向分析</a></li></ul><h2><span id="zhua-bao-qing-kuang">抓包情况</span></h2><p>主页点击搜索就会跳出二代的验证码，<code>netWebServlet.json</code> 的请求，会返回 <code>challenge</code> 和 <code>gt</code>。</p><p><img src="https://cdn.itbob.cn/img/article/059/01.png" alt="01"></p><p>有个 <code>get.php</code> 的请求，返回了一个新的 <code>challenge</code>，这个请求之后的操作，都要用这个新的 <code>challenge</code>，不然是验证不成功的，其他的还有验证码背景图片、乱序图片地址、<code>c</code>、<code>s</code> 等值，之前写过三代的文章，都是类似的，这里就不一一分析了。</p><p><img src="https://cdn.itbob.cn/img/article/059/02.png" alt="02"></p><p>然后是 <code>ajax.php</code> 验证是否通过，通过之后返回一个 <code>validate</code>，请求里同样是需要我们逆向的 <code>w</code> 参数：</p><p><img src="https://cdn.itbob.cn/img/article/059/03.png" alt="03"></p><p><img src="https://cdn.itbob.cn/img/article/059/04.png" alt="04"></p><p>然后同样还是 <code>netWebServlet.json</code> 接口，带上 <code>get.php</code> 请求返回的 <code>challenge</code> 以及 <code>ajax.php</code> 返回的 <code>validate</code>，请求拿到一个 <code>name</code> 的字段。</p><p><img src="https://cdn.itbob.cn/img/article/059/05.png" alt="05"></p><p><img src="https://cdn.itbob.cn/img/article/059/06.png" alt="06"></p><p>后续的搜索数据，带上这个 <code>name</code> 就行了：</p><p><img src="https://cdn.itbob.cn/img/article/059/07.png" alt="07"></p><h2><span id="ni-xiang-fen-xi">逆向分析</span></h2><p>搞过三、四代的都知道我们可以直接搜索 <code>w</code> 的 Unicode 值 <code>\u0077</code> 即可定位，但是二代则不是 Unicode，而是16进制的编码，搜索 <code>\x77</code> 即可定位，当然按照正常流程，跟栈也能很容易找到加密的位置。</p><p><img src="https://cdn.itbob.cn/img/article/059/08.png" alt="08"></p><h3><span id="huo-qu-h7z-zhi">获取 H7z 值</span></h3><p>从上图中可以知道 <code>w</code> 的值为 <code>r7z + H7z</code>，先看 <code>H7z</code>。</p><p><img src="https://cdn.itbob.cn/img/article/059/09.png" alt="09"></p><p>跟进这个方法，来到一大串控制流，这里还是推荐用 AST 还原一下，后续可能有一些循环啥的，硬跟的话容易出错，当然直接全部扣一把梭也是可以的，<code>H7z</code> 的核心其实就是 RSA 加密随机字符串，三代四代都有，这里就不细讲了。</p><p><img src="https://cdn.itbob.cn/img/article/059/10.png" alt="10"></p><h3><span id="huo-qu-r7z-zhi">获取 r7z 值</span></h3><p>然后就是 <code>r7z</code>，主要由以下两句代码生成：</p><p><img src="https://cdn.itbob.cn/img/article/059/11.png" alt="11"></p><pre><code class="hljs javascript">q7z = n0B[M9r.R8z(<span class="hljs-number">699</span>)](h7B[M9r.C8z(<span class="hljs-number">105</span>)](Y7z), V7z[M9r.R8z(<span class="hljs-number">818</span>)]())r7z = p7B[M9r.R8z(<span class="hljs-number">260</span>)](q7z)</code></pre><p>可以看到其中有个变量 <code>Y7z</code> 参与了计算，先来看看他是怎么来的，直接搜索即可定位，可以发现同样是16进制的编码，由五个值组成：<code>userresponse</code>、<code>passtime</code>、<code>imgload</code>、<code>aa</code>、<code>ep</code></p><p><img src="https://cdn.itbob.cn/img/article/059/12.png" alt="12"></p><h4><span id="huo-qu-userresponse-zhi">获取 userresponse 值</span></h4><p>挨个分析，首先是 <code>userresponse</code>，将滑动距离和 <code>challenge</code> 的值传入一个方法，得到一个 9 位字符串：</p><p><img src="https://cdn.itbob.cn/img/article/059/13.png" alt="13"></p><p>上图中 <code>g7z</code> 就是滑动距离，搜索可以看到定义的地方，尺子量一下对比一下，和滑动的距离是一致的：</p><p><img src="https://cdn.itbob.cn/img/article/059/14.png" alt="14"></p><p><img src="https://cdn.itbob.cn/img/article/059/15.png" alt="15"></p><p>然后再来看看那个方法，跟进去之后也是一大串 <code>switch-case</code> 控制流：</p><p><img src="https://cdn.itbob.cn/img/article/059/16.png" alt="16"></p><p>还原一下代码如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUserResponse</span>(<span class="hljs-params">L0z, o0z</span>) </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j0z = o0z.slice(<span class="hljs-number">32</span>), c0z = [], X0z = <span class="hljs-number">0</span>; X0z &lt; j0z.length; X0z++)&#123;        <span class="hljs-keyword">var</span> K0z = j0z.charCodeAt(X0z);        c0z[X0z] = K0z &gt; <span class="hljs-number">57</span> ? K0z - <span class="hljs-number">87</span> : K0z - <span class="hljs-number">48</span>;    &#125;    j0z = <span class="hljs-number">36</span> * c0z[<span class="hljs-number">0</span>] + c0z[<span class="hljs-number">1</span>];    <span class="hljs-keyword">var</span> k0z = <span class="hljs-built_in">Math</span>.round(L0z) + j0z;    o0z = o0z.slice(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>);    <span class="hljs-keyword">var</span> n0z, f0z = [[], [], [], [], []], Q0z = &#123;&#125;, N0z = <span class="hljs-number">0</span>;    X0z = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i0z = o0z.length; i0z &gt; X0z; X0z++)&#123;        n0z = o0z.charAt(X0z), Q0z[n0z] || (Q0z[n0z] = <span class="hljs-number">1</span>, f0z[N0z].push(n0z), N0z++, N0z = <span class="hljs-number">5</span> == N0z ? <span class="hljs-number">0</span> : N0z);    &#125;    <span class="hljs-keyword">var</span> y0z, v0z = k0z, B0z = <span class="hljs-number">4</span>, x0z = <span class="hljs-string">&quot;&quot;</span>, I0z = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>];    <span class="hljs-keyword">while</span> ( v0z &gt; <span class="hljs-number">0</span>) &#123;        v0z - I0z[B0z] &gt;= <span class="hljs-number">0</span> ? (y0z = <span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">Math</span>.random() * f0z[B0z].length, <span class="hljs-number">10</span>),        x0z += f0z[B0z][y0z], v0z -= I0z[B0z]) : (f0z.splice(B0z, <span class="hljs-number">1</span>),        I0z.splice(B0z, <span class="hljs-number">1</span>), B0z -= <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> x0z;&#125;</code></pre><h4><span id="huo-qu-passtime-zhi">获取 passtime  值</span></h4><p><code>passtime</code>  不用考虑是怎么通过函数获取的，含义就是滑动完成所花费的时间，直接取轨迹的最后一个值即可，这个也和三四代是一样的，获取语句为：<code>var passtime = track[track.length - 1][2]</code>，如下图所示，轨迹的最后一个值时间为 871，<code>passtime</code> 的值同样也为 871。</p><p><img src="https://cdn.itbob.cn/img/article/059/17.png" alt="17"></p><p><img src="https://cdn.itbob.cn/img/article/059/18.png" alt="18"></p><h4><span id="huo-qu-imgload-zhi">获取 imgload 值</span></h4><p><code>imgload</code> 也没啥特别的，从字面意思猜测应该是图片加载耗时，实测直接写死即可，或者整个随机值就行。</p><h4><span id="huo-qu-aa-zhi">获取 aa 值</span></h4><p><code>aa</code> 的值就是 <code>F7z</code>，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/059/19.png" alt="19"></p><p>搜索 <code>F7z</code>，定位到下图所示的地方，向一个方法中传入了一个时间戳：</p><p><img src="https://cdn.itbob.cn/img/article/059/20.png" alt="20"></p><p>跟进去同样是 <code>switch-case</code> 控制流，需要注意的是下图中 <code>c7B[M9r.R8z(781)](M9r.R8z(764), K1z)</code> 的值其实就是轨迹。</p><p><img src="https://cdn.itbob.cn/img/article/059/21.png" alt="21"></p><p>这段控制流还原一下就变成这样了：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getF7z</span>(<span class="hljs-params">track</span>)</span>&#123;    <span class="hljs-keyword">var</span> o5r = <span class="hljs-number">6</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> N1z, X1z = s6z(track), f1z = [], B1z = [], o1z = [], t1z = <span class="hljs-number">0</span>, j1z = X1z.length; t1z &lt; j1z; t1z++)&#123;        <span class="hljs-keyword">if</span> (o5r * (o5r + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span> + <span class="hljs-number">8</span>) &#123;            N1z = u6z(X1z[t1z]),            N1z ? B1z.push(N1z) : (f1z.push(O6z(X1z[t1z][<span class="hljs-number">0</span>])),            B1z.push(O6z(X1z[t1z][<span class="hljs-number">1</span>]))),            o1z.push(O6z(X1z[t1z][<span class="hljs-number">2</span>]));            o5r = o5r &gt;= <span class="hljs-number">17705</span> ? o5r / <span class="hljs-number">3</span> : o5r * <span class="hljs-number">3</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> f1z.join(<span class="hljs-string">&quot;&quot;</span>) + <span class="hljs-string">&quot;!!&quot;</span> + B1z.join(<span class="hljs-string">&quot;&quot;</span>) + <span class="hljs-string">&quot;!!&quot;</span> + o1z.join(<span class="hljs-string">&quot;&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s6z</span>(<span class="hljs-params">F6z</span>)</span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> Y6z, g6z, a6z, E6z = [], D6z = <span class="hljs-number">0</span>, P6z = [], J6z = <span class="hljs-number">0</span>, l6z = F6z.length - <span class="hljs-number">1</span>; J6z &lt; l6z; J6z++) &#123;        Y6z = <span class="hljs-built_in">Math</span>.round(F6z[J6z + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - F6z[J6z][<span class="hljs-number">0</span>]),        g6z = <span class="hljs-built_in">Math</span>.round(F6z[J6z + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - F6z[J6z][<span class="hljs-number">1</span>]),        a6z = <span class="hljs-built_in">Math</span>.round(F6z[J6z + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - F6z[J6z][<span class="hljs-number">2</span>]),        P6z.push([Y6z, g6z, a6z]),        <span class="hljs-number">0</span> == Y6z &amp;&amp; <span class="hljs-number">0</span> == g6z &amp;&amp; <span class="hljs-number">0</span> == a6z || (<span class="hljs-number">0</span> == Y6z &amp;&amp; <span class="hljs-number">0</span> == g6z ? D6z += a6z : (E6z.push([Y6z, g6z, a6z + D6z]), D6z = <span class="hljs-number">0</span>));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> !== D6z &amp;&amp; E6z.push([Y6z, g6z, D6z]), E6z;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">O6z</span>(<span class="hljs-params">r6z</span>)</span>&#123;    <span class="hljs-keyword">var</span> d6z = <span class="hljs-string">&quot;()*,-./0123456789:?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqr&quot;</span>      , m6z = d6z.length      , Z6z = <span class="hljs-string">&quot;&quot;</span>      , H6z = <span class="hljs-built_in">Math</span>.abs(r6z)      , W6z = <span class="hljs-built_in">parseInt</span>(H6z / m6z);    W6z &gt;= m6z &amp;&amp; (W6z = m6z - <span class="hljs-number">1</span>), W6z &amp;&amp; (Z6z = d6z.charAt(W6z)), H6z %= m6z;    <span class="hljs-keyword">var</span> q6z = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">return</span> r6z &lt; <span class="hljs-number">0</span> &amp;&amp; (q6z += <span class="hljs-string">&quot;!&quot;</span>), Z6z &amp;&amp; (q6z += <span class="hljs-string">&quot;$&quot;</span>), q6z + Z6z + d6z.charAt(H6z);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">u6z</span>(<span class="hljs-params">R6z</span>)</span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> z6z = [[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]], h6z = <span class="hljs-number">0</span>, C6z = z6z.length; h6z &lt; C6z; h6z++)&#123;        <span class="hljs-keyword">if</span> (R6z[<span class="hljs-number">0</span>] == z6z[h6z][<span class="hljs-number">0</span>] &amp;&amp; R6z[<span class="hljs-number">1</span>] == z6z[h6z][<span class="hljs-number">1</span>])&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;stuvwxyz~&quot;</span>[h6z]        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>以上只是 <code>F7z</code> 第一次生成的地方，后面还有二次处理，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/059/22.png" alt="22"></p><p>同样跟进去，三个传入的参数分别是第一次生成的 <code>F7z</code>、<code>get.php</code> 请求返回的 <code>c</code> 和 <code>s</code> 参数。</p><p><img src="https://cdn.itbob.cn/img/article/059/23.png" alt="23"></p><p>同样是一段控制流，还原后如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getF7z2</span>(<span class="hljs-params">Q1z, v1z, T1z</span>)</span>&#123;    <span class="hljs-keyword">var</span> i1z, x1z = <span class="hljs-number">0</span>, c1z = Q1z, y1z = v1z[<span class="hljs-number">0</span>], k1z = v1z[<span class="hljs-number">2</span>], L1z = v1z[<span class="hljs-number">4</span>];    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">if</span> (i1z = T1z.substr(x1z, <span class="hljs-number">2</span>))&#123;            x1z += <span class="hljs-number">2</span>;            <span class="hljs-keyword">var</span> n1z = <span class="hljs-built_in">parseInt</span>(i1z, <span class="hljs-number">16</span>)              , M1z = <span class="hljs-built_in">String</span>.fromCharCode(n1z)              , I1z = (y1z * n1z * n1z + k1z * n1z + L1z) % Q1z.length;            c1z = c1z.substr(<span class="hljs-number">0</span>, I1z) + M1z + c1z.substr(I1z);        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> c1z        &#125;    &#125;    <span class="hljs-keyword">return</span> Q1z&#125;</code></pre><p>至此 <code>aa</code> 参数分析完毕！</p><h4><span id="huo-qu-ep-zhi">获取 ep 值</span></h4><p><code>ep</code> 的值就是一个版本号，此处是 <code>&#123;'v': '6.0.9'&#125;</code>，写死即可。</p><p><img src="https://cdn.itbob.cn/img/article/059/24.png" alt="24"></p><h4><span id="huo-qu-rp-zhi">获取 rp 值</span></h4><p>自此 <code>Y7z</code> 的第一步生成就分析完毕了，注意接下来还有一步，向 <code>Y7z</code> 里新增了一个 <code>rp</code> 参数：</p><p><img src="https://cdn.itbob.cn/img/article/059/25.png" alt="25"></p><p>这个值的组成看起来很长，实际上是将 gt、challenge 前 32 位以及 passtime 相加经过 MD5 加密后得到的。</p><pre><code class="hljs javascript">Y7z[<span class="hljs-string">&quot;rp&quot;</span>] = md5(gt + challenge.slice(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>) + passtime)</code></pre><p><img src="https://cdn.itbob.cn/img/article/059/26.png" alt="26"></p><p>上图中 <code>I0B</code> 就是 MD5 方法，跟进去其实是可以看到很多 MD5 特征的，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/059/27.png" alt="27"></p><p>自此 <code>Y7z</code> 的值就搞定了，然后接着前面的看，也就是 <code>q7z</code> 的值，同样和三四代一样的，<code>encrypt</code> 是 AES 加密，<code>Y7z</code> 经过 <code>JSON.stringify()</code> 处理为字符串作为待加密对象，后面是 16 为随机字符串作为 AES 的 Key，注意这里的随机字符串应该和获取 <code>H7z</code> 值时的随机字符串一致，不然是验证不成功的。</p><p><img src="https://cdn.itbob.cn/img/article/059/28.png" alt="28"></p><p>然后下一步就是获取 <code>r7z</code> 的值，将上一步得到的 <code>q7z</code> 经过一个方法进行处理，跟进方法，又是和三四代一样的，熟悉的 <code>res + end</code>，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/059/29.png" alt="29"></p><p>直接扣代码，或者直接使用三代的代码即可：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">$_GJF</span>(<span class="hljs-params">e</span>) </span>&#123;    <span class="hljs-keyword">var</span> t = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789()&quot;</span>;    <span class="hljs-keyword">return</span> e &lt; <span class="hljs-number">0</span> || e &gt;= t[<span class="hljs-string">&quot;length&quot;</span>] ? <span class="hljs-string">&quot;.&quot;</span> : t[<span class="hljs-string">&quot;charAt&quot;</span>](e);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">$_HBO</span>(<span class="hljs-params">e, t</span>) </span>&#123;    <span class="hljs-keyword">return</span> e &gt;&gt; t &amp; <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">$_HCX</span>(<span class="hljs-params">e, o</span>) </span>&#123;    <span class="hljs-keyword">var</span> i = <span class="hljs-built_in">this</span>;    o || (o = i);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> t = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, t</span>) </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>, r = <span class="hljs-number">24</span> - <span class="hljs-number">1</span>; <span class="hljs-number">0</span> &lt;= r; r -= <span class="hljs-number">1</span>)            <span class="hljs-number">1</span> === $_HBO(t, r) &amp;&amp; (n = (n &lt;&lt; <span class="hljs-number">1</span>) + $_HBO(e, r));        <span class="hljs-keyword">return</span> n;    &#125;, n = <span class="hljs-string">&quot;&quot;</span>, r = <span class="hljs-string">&quot;&quot;</span>, s = e.length, a = <span class="hljs-number">0</span>; a &lt; s; a += <span class="hljs-number">3</span>) &#123;        <span class="hljs-keyword">var</span> c;        <span class="hljs-keyword">if</span> (a + <span class="hljs-number">2</span> &lt; s)            c = (e[a] &lt;&lt; <span class="hljs-number">16</span>) + (e[a + <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>) + e[a + <span class="hljs-number">2</span>],            n += $_GJF(t(c, <span class="hljs-number">7274496</span>)) + $_GJF(t(c, <span class="hljs-number">9483264</span>)) + $_GJF(t(c, <span class="hljs-number">19220</span>)) + $_GJF(t(c, <span class="hljs-number">235</span>));        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">var</span> _ = s % <span class="hljs-number">3</span>;            <span class="hljs-number">2</span> == _ ? (c = (e[a] &lt;&lt; <span class="hljs-number">16</span>) + (e[a + <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>),            n += $_GJF(t(c, <span class="hljs-number">7274496</span>)) + $_GJF(t(c, <span class="hljs-number">9483264</span>)) + $_GJF(t(c, <span class="hljs-number">19220</span>)),            r = <span class="hljs-string">&quot;.&quot;</span>) : <span class="hljs-number">1</span> == _ &amp;&amp; (c = e[a] &lt;&lt; <span class="hljs-number">16</span>,            n += $_GJF(t(c, <span class="hljs-number">7274496</span>)) + $_GJF(t(c, <span class="hljs-number">9483264</span>)),            r = <span class="hljs-string">&quot;.&quot;</span> + <span class="hljs-string">&quot;.&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> &#123;        <span class="hljs-string">&quot;res&quot;</span>: n,        <span class="hljs-string">&quot;end&quot;</span>: r    &#125;;&#125;</code></pre><h3><span id="huo-qu-w-zhi">获取 w 值</span></h3><p>自此 <code>w</code> 的就已经出来了，<code>r7z + H7z</code> 即为 <code>w</code> 的值。</p><p><img src="https://cdn.itbob.cn/img/article/059/30.png" alt="30"></p><h2><span id="jie-guo-yan-zheng">结果验证</span></h2><p>测试过掉验证码抓取数据成功：</p><p><img src="https://cdn.itbob.cn/img/article/059/31.png" alt="31"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;极验全家桶，交流请咨询微信：IT-BOB&lt;/st</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>云片行为验证，滑动验证码、点选验证码逆向分析</title>
    <link href="https://www.itbob.cn/article/058/"/>
    <id>https://www.itbob.cn/article/058/</id>
    <published>2022-11-26T08:51:00.000Z</published>
    <updated>2022-11-26T08:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#zhua-bao-fen-xi">抓包分析</a></li><li><a href="#ni-xiang-fen-xi">逆向分析</a><ul><li><a href="#tu-pian-jie-kou">图片接口</a></li><li><a href="#yan-zheng-jie-kou">验证接口</a></li></ul></li><li><a href="#jie-guo-yan-zheng">结果验证</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：某片的滑动验证码和点选验证码逆向</li><li>主页：<code>aHR0cHM6Ly93d3cueXVucGlhbi5jb20vcHJvZHVjdC9jYXB0Y2hh</code></li></ul><p><img src="https://cdn.itbob.cn/img/article/058/01.png" alt="01"></p><h2><span id="zhua-bao-fen-xi">抓包分析</span></h2><p>验证码图片获取接口，GET 请求，包含四个参数：<code>cb</code>、<code>i</code>、<code>k</code>、<code>captchaId</code>，有时候可能也会有 <code>token</code> 参数，那是因为不是第一次加载图片，比如刷新图片，会将之前接口的 <code>token</code> 值带上。</p><p><img src="https://cdn.itbob.cn/img/article/058/02.png" alt="02"></p><p>接口返回，如果是滑动验证码，则 <code>bg</code> 是背景图，<code>front</code> 是滑块图，还有个 <code>token</code> 值后续会用到。</p><p><img src="https://cdn.itbob.cn/img/article/058/03.png" alt="03"></p><p>如果是点选验证码，则 <code>captchaImage</code> 是底图，<code>wordsImage</code> 是需要点击的文字，同样的有个 <code>token</code> 值后续会用到。</p><p><img src="https://cdn.itbob.cn/img/article/058/04.png" alt="04"></p><p>验证接口，包含五个参数：<code>cb</code>、<code>i</code>、<code>k</code>、<code>token</code>、<code>captchaId</code>，其中 <code>token</code> 就是获取验证码接口返回的。</p><p><img src="https://cdn.itbob.cn/img/article/058/05.png" alt="05"></p><p><img src="https://cdn.itbob.cn/img/article/058/06.png" alt="06"></p><h2><span id="ni-xiang-fen-xi">逆向分析</span></h2><h3><span id="tu-pian-jie-kou">图片接口</span></h3><p>先来看看获取验证码图片的接口，全局搜索关键字 <code>captchaId</code> 即可定位到 key 为 <code>jsonpRequest</code> 的地方，下图中的 <code>t</code> 就是完整的接口 URL 了：</p><p><img src="https://cdn.itbob.cn/img/article/058/07.png" alt="07"></p><p>往上挨个找，先看看 <code>captchaId</code>，其实就是 <code>this.APP_ID</code>，多次刷新你会发现，对于滑块来讲，是定值 <code>974cd565f11545b6a5006d10dc324281</code>，对于点选来讲，是定值 <code>e1e7be036f9242c7aed023438af66f46</code>，这两个值在一个 JS 里是写死的，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/058/08.png" alt="08"></p><p><img src="https://cdn.itbob.cn/img/article/058/09.png" alt="09"></p><p>再往上看，<code>HOSTS</code> 啥的是定值就不用说了，<code>cb</code> 就是 <code>r</code>，<code>i</code> 就是 <code>a.i</code>，<code>k</code> 就是 <code>a.k</code>，通过 <code>concat()</code> 方法连接起来，所以只需要搞定 <code>r</code> 和 <code>a</code> 的值就行了，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/058/10.png" alt="10"></p><p><code>a</code> 的值是通过 <code>encrypt(e)</code> 得到的，<code>e</code> 里面有 <code>fp</code>、<code>address</code>、<code>yp_riddler_id</code> 等值，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/058/11.png" alt="11"></p><p>先看看这个 <code>encrypt</code> 方法，最终返回的是 <code>i</code> 和 <code>k</code>，瞧瞧这熟悉的 <code>iv</code>、<code>parse</code>，一看就是 AES、DES 之类的，试一下就知道了，或者跟进 <code>lt.a.encrypt()</code> 看看他的源码，对比一下标准算法里的源码，就可以发现是 AES，<code>k</code> 就很明显了，RSA 加密，公钥啥的一搜就有。</p><p><img src="https://cdn.itbob.cn/img/article/058/12.png" alt="12"></p><p>然后往上有个 <code>yp_riddler_id</code>，貌似是从 cookie 中拿的，直接搜索这个关键字，可以找到其设置值的地方，就是一个 UUID，其中有个 <code>window.performance.now()</code> 方法，其作用是返回一个当前页面执行的时间的时间戳，用来精确计算程序执行时间，在 node 实现方法如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> perf = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;perf_hooks&#x27;</span>);performance = perf.performance.now()<span class="hljs-built_in">console</span>.log(performance);</code></pre><p><img src="https://cdn.itbob.cn/img/article/058/13.png" alt="13"></p><p><img src="https://cdn.itbob.cn/img/article/058/14.png" alt="14"></p><p>然后再往上有个 <code>e.fp = this.fingerprint</code>，这里用到的应该是一个指纹库：<a href="https://github.com/fingerprintjs/fingerprintjs">https://github.com/fingerprintjs/fingerprintjs</a> ，感兴趣的可以了解一下，同一个浏览器得到的指纹是一样的，这里固定即可。</p><p><img src="https://cdn.itbob.cn/img/article/058/15.png" alt="15"></p><p>然后就是 <code>r</code> 的值，<code>preAdd</code> 方法，直接扣就行了</p><p><img src="https://cdn.itbob.cn/img/article/058/16.png" alt="16"></p><p><img src="https://cdn.itbob.cn/img/article/058/17.png" alt="17"></p><p>然后这个 <code>e</code> 的值，再传到 <code>jsonpRequest</code> 之前就已经有一些值了，所以我们还得往前跟栈看看：</p><p><img src="https://cdn.itbob.cn/img/article/058/18.png" alt="18"></p><p>来到 <code>getCaptcha</code> 这里，没啥特别的，扣就完事儿了，其中有个 <code>browserInfo</code> 是浏览器的一些东西，copy 下来就行了。</p><p><img src="https://cdn.itbob.cn/img/article/058/19.png" alt="19"></p><h3><span id="yan-zheng-jie-kou">验证接口</span></h3><p>验证接口最后也是走的 <code>jsonpRequest</code>，和前面的获取图片接口类似，不同之处就是传入的 <code>e</code> 里面包含的值不一样，先来看看滑块：</p><p><img src="https://cdn.itbob.cn/img/article/058/20.png" alt="20"></p><p>包含 <code>distanceX</code> 和 <code>points</code>，很明显 <code>points</code> 就是轨迹了，再往前跟看看，如下图所示，我们只需要 <code>i</code> 和 <code>r</code> 参数就行了，参数是一些图片高宽，固定就行，<code>offsetX</code> 是滑动的距离。</p><p><img src="https://cdn.itbob.cn/img/article/058/21.png" alt="21"></p><p>主要看看这个轨迹 <code>i = this.reducePoints()</code>，跟进 <code>reducePoints()</code> 方法里，<code>this.position</code> 是轨迹信息，这个方法对轨迹做了一些处理再返回的，直接把逻辑扣下来即可。</p><p><img src="https://cdn.itbob.cn/img/article/058/22.png" alt="22"></p><p>滑块就到这儿了，再来看看点选验证，同样的还是 <code>jsonpRequest</code>，传入的 <code>e</code> 包含了三个点的坐标。</p><p><img src="https://cdn.itbob.cn/img/article/058/23.png" alt="23"></p><p>同样往上跟栈，这里的 <code>this.position</code> 才是真实坐标，后面每个坐标分别对 x 和 y 与图片的宽和高进行相除，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/058/24.png" alt="24"></p><h2><span id="jie-guo-yan-zheng">结果验证</span></h2><p><img src="https://cdn.itbob.cn/img/article/058/25.png" alt="25"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>安某客滑动验证码逆向分析</title>
    <link href="https://www.itbob.cn/article/057/"/>
    <id>https://www.itbob.cn/article/057/</id>
    <published>2022-11-08T09:35:00.000Z</published>
    <updated>2022-11-26T08:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/captcha_reverse.png" alt="captcha_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#zhua-bao-fen-xi">抓包分析</a></li><li><a href="#dinfo-sheng-cheng">dInfo 生成</a></li><li><a href="#getinfotp-jie-mi">getInfoTp 解密</a></li><li><a href="#data-sheng-cheng">data 生成</a></li><li><a href="#gui-ji-chu-li">轨迹处理</a></li><li><a href="#jie-guo-yan-zheng">结果验证</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：安某客滑动验证码逆向分析</li><li>主页：<code>aHR0cHM6Ly93d3cuYW5qdWtlLmNvbS9jYXB0Y2hhLXZlcmlmeS8/Y2FsbGJhY2s9c2hpZWxkJmZyb209YW50aXNwYW0=</code></li></ul><p><img src="https://cdn.itbob.cn/img/article/057/01.png" alt="01"></p><h2><span id="zhua-bao-fen-xi">抓包分析</span></h2><p>首页请求，有个初始化函数，其中有个 <code>sessionId</code> 后续会用到。</p><p><img src="https://cdn.itbob.cn/img/article/057/02.png" alt="02"></p><p>然后有个 <code>getInfoTp</code> 的请求，<code>Form Data</code> 里有个 <code>dInfo</code> 是加密参数，返回值里 <code>info</code> 也是加密的，包含了图片信息，返回值 <code>responseId</code> 在后续的请求也会用到。</p><p><img src="https://cdn.itbob.cn/img/article/057/03.png" alt="03"></p><p>滑动之后，有个 <code>checkInfoTp</code> 请求，<code>Form Data</code> 里有个 <code>data</code> 是加密参数，包含了轨迹信息，返回值 <code>message</code> 可以看到是否校验成功。</p><p><img src="https://cdn.itbob.cn/img/article/057/04.png" alt="04"></p><p>整体流程就是：请求首页获取 <code>sessionId</code>，请求 <code>getInfoTp</code> 获取图片信息和 <code>responseId</code>，请求 <code>checkInfoTp</code> 校验是否成功，中间涉及到 <code>dInfo</code> 和 <code>data</code> 两个加密参数，以及 <code>getInfoTp</code> 返回得到的 <code>info</code> 的解密。</p><h2><span id="dinfo-sheng-cheng">dInfo 生成</span></h2><p>先来看 <code>getInfoTp</code> 请求的 <code>dInfo</code> 参数，直接搜索可定位，刷新断下，大致就可以看出是 AES 加密，传入了 <code>sessionId</code> 和一个 <code>_taN()</code> 函数的返回值：</p><p><img src="https://cdn.itbob.cn/img/article/057/05.png" alt="05"></p><p><code>_taN()</code> 函数是一些 URL，UA 之类的信息，可以写死：</p><p><img src="https://cdn.itbob.cn/img/article/057/06.png" alt="06"></p><p>往里跟就可以看到 AES 算法了：</p><p><img src="https://cdn.itbob.cn/img/article/057/07.png" alt="07"></p><p>这里简简单单扣一下，JavaScript 代码如下：</p><pre><code class="hljs javascript"><span class="hljs-comment">/* ==================================</span><span class="hljs-comment"># @Time    : 2021-12-14</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: ajk.js</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ================================== */</span><span class="hljs-keyword">var</span> CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto-js&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AESEncrypt</span>(<span class="hljs-params">_cRV, _2undefinedp</span>) </span>&#123;    _2undefinedp = _2undefinedp.split(<span class="hljs-string">&quot;&quot;</span>).reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_PUi, _JrX, _JP9</span>) </span>&#123;        <span class="hljs-keyword">return</span> _JP9 % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? _PUi + <span class="hljs-string">&quot;&quot;</span> : _PUi + _JrX;    &#125;, <span class="hljs-string">&quot;&quot;</span>);    _2undefinedp = CryptoJS.enc.Utf8.parse(_2undefinedp);    _cRV = <span class="hljs-string">&quot;string&quot;</span> == <span class="hljs-keyword">typeof</span> _cRV ? _cRV : <span class="hljs-built_in">JSON</span>.stringify(_cRV);    _cRV = CryptoJS.AES.encrypt(_cRV, _2undefinedp, &#123;        <span class="hljs-attr">iv</span>: _2undefinedp,        <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,        <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7    &#125;);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">encodeURIComponent</span>(_cRV.toString())&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">u</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> &#123;        <span class="hljs-string">&quot;sdkv&quot;</span>: <span class="hljs-string">&quot;3.0.1&quot;</span>,        <span class="hljs-string">&quot;busurl&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com/captcha-verify/?callback=shield&amp;from=antispam&quot;</span>,        <span class="hljs-string">&quot;useragent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36&quot;</span>,        <span class="hljs-string">&quot;clienttype&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDInfo</span>(<span class="hljs-params">sessionId</span>)</span>&#123;    <span class="hljs-keyword">return</span> AESEncrypt(u(), sessionId)&#125;<span class="hljs-comment">// 测试样例</span><span class="hljs-keyword">var</span> sessionId = <span class="hljs-string">&quot;a8b339ec0c26459598786fee1cce8dc2&quot;</span><span class="hljs-built_in">console</span>.log(getDInfo(sessionId))</code></pre><p>这段逻辑也可以用 Python 来实现，关键代码如下（脱敏处理，不能直接运行）：</p><pre><code class="hljs python"><span class="hljs-comment"># ==================================</span><span class="hljs-comment"># --*-- coding: utf-8 --*--</span><span class="hljs-comment"># @Time    : 2021-12-14</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: ajk.py</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ==================================</span><span class="hljs-keyword">import</span> json<span class="hljs-keyword">import</span> base64<span class="hljs-keyword">import</span> requests<span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<span class="hljs-keyword">from</span> loguru <span class="hljs-keyword">import</span> logger<span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> quote_plus<span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<span class="hljs-keyword">from</span> Crypto.Util.Padding <span class="hljs-keyword">import</span> pad, unpad<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AESAlgorithm</span>:</span><span class="hljs-meta">    @staticmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encrypt</span>(<span class="hljs-params">aes_key_iv, text</span>):</span>        <span class="hljs-string">&quot;&quot;&quot; 对明文进行加密 &quot;&quot;&quot;</span>        cipher = AES.new(key=<span class="hljs-built_in">bytes</span>(aes_key_iv, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>), mode=AES.MODE_CBC, iv=<span class="hljs-built_in">bytes</span>(aes_key_iv, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>))        result = base64.b64encode(cipher.encrypt(pad(text.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), <span class="hljs-number">16</span>))).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)        result = quote_plus(result)        <span class="hljs-keyword">return</span> result<span class="hljs-meta">    @staticmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decrypt</span>(<span class="hljs-params">aes_key_iv, text</span>):</span>        <span class="hljs-string">&quot;&quot;&quot; 对密文进行解密 &quot;&quot;&quot;</span>        cipher = AES.new(key=<span class="hljs-built_in">bytes</span>(aes_key_iv, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>), mode=AES.MODE_CBC, iv=<span class="hljs-built_in">bytes</span>(aes_key_iv, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>))        result = unpad(cipher.decrypt(base64.b64decode(text)), <span class="hljs-number">16</span>).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)        <span class="hljs-keyword">return</span> result<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AJKSlide</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, index_url, user_agent</span>):</span>        self.aes = AESAlgorithm()        self.index_url = index_url        self.user_agent = user_agent        self.headers = &#123;<span class="hljs-string">&quot;user-agent&quot;</span>: self.user_agent&#125;    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_session_id</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot; 获取 sessionId &quot;&quot;&quot;</span>        response = requests.get(url=self.index_url, headers=self.headers).text        session_id = etree.HTML(response).xpath(<span class="hljs-string">&quot;//input[@name=&#x27;sessionId&#x27;]/@value&quot;</span>)[<span class="hljs-number">0</span>]        logger.info(<span class="hljs-string">f&quot;sessionId ==&gt; <span class="hljs-subst">&#123;session_id&#125;</span>&quot;</span>)        <span class="hljs-keyword">return</span> session_id<span class="hljs-meta">    @staticmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_aes_key_iv</span>(<span class="hljs-params">session_id</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;设置 AES key 和 iv&quot;&quot;&quot;</span>        aes_key_iv = <span class="hljs-string">&#x27;&#x27;</span>        <span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(session_id):            <span class="hljs-keyword">if</span> index % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:                aes_key_iv += value        logger.info(<span class="hljs-string">f&quot;处理 sessionId 获取 aes key iv ==&gt; <span class="hljs-subst">&#123;aes_key_iv&#125;</span>&quot;</span>)        <span class="hljs-keyword">return</span> aes_key_iv    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_d_info</span>(<span class="hljs-params">self, aes_key_iv</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;获取 dInfo&quot;&quot;&quot;</span>        sdk_info = &#123;            <span class="hljs-string">&quot;sdkv&quot;</span>: <span class="hljs-string">&quot;3.0.1&quot;</span>,            <span class="hljs-string">&quot;busurl&quot;</span>: self.index_url,            <span class="hljs-string">&quot;useragent&quot;</span>: self.user_agent,            <span class="hljs-string">&quot;clienttype&quot;</span>: <span class="hljs-number">1</span>        &#125;        d_info = self.aes.encrypt(aes_key_iv, json.dumps(sdk_info))        logger.info(<span class="hljs-string">f&#x27;dInfo ==&gt; <span class="hljs-subst">&#123;d_info&#125;</span>&#x27;</span>)        <span class="hljs-keyword">return</span> d_info    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, session_id=<span class="hljs-literal">None</span></span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> session_id:            session_id = self.get_session_id()        aes_key_iv = self.get_aes_key_iv(session_id)        self.get_d_info(aes_key_iv)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    UA = <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&quot;</span>    index_url_ = <span class="hljs-string">&quot;https://www.脱敏处理.com/captcha-verify/?callback=shield&amp;from=antispam&quot;</span>    ajk_slide = AJKSlide(index_url_, UA)    ajk_slide.run()</code></pre><h2><span id="getinfotp-jie-mi">getInfoTp 解密</span></h2><p><code>getInfoTp</code> 这个接口返回的 <code>info</code> 的值是加密的，前面我们已经知道用到了 AES 加密算法，这里可以直接猜测也是用的的 AES 来解密的，找到 <code>AESDecrypt</code> 这个方法，下个断点，刷新发现断下之后传入了两个参数，第一个正是 <code>info</code> 的内容，第二个则是 <code>sessionId</code>。</p><p><img src="https://cdn.itbob.cn/img/article/057/08.png" alt="08"></p><p><img src="https://cdn.itbob.cn/img/article/057/09.png" alt="09"></p><p>解密结果可以看到滑块的图片地址等信息：</p><p><img src="https://cdn.itbob.cn/img/article/057/10.png" alt="10"></p><h2><span id="data-sheng-cheng">data 生成</span></h2><p>接下来就是 <code>checkInfoTp</code> 提交验证了，要搞清楚提交的 <code>data</code> 是什么东西，同样搜索打断点，如下图所示 <code>_5DD</code> 就是 <code>data</code> 值，传过来的。</p><p><img src="https://cdn.itbob.cn/img/article/057/11.png" alt="11"></p><p>往上跟栈，可以看到 <code>_Ug0</code> 里面有个 <code>track</code> 参数，这明显就是轨迹了，同样最后的结果经过了 AES 加密。</p><p><img src="https://cdn.itbob.cn/img/article/057/12.png" alt="12"></p><p>再往上跟，可以看到 <code>_Ug0</code> 由三个参数组成，<code>x</code> 是水平滑动的距离，<code>track</code> 是轨迹，<code>p</code> 是定值。</p><p><img src="https://cdn.itbob.cn/img/article/057/13.png" alt="13"></p><h2><span id="gui-ji-chu-li">轨迹处理</span></h2><p>轨迹生成前，得先识别缺口得到要滑动的距离，方式有很多，比如 <code>OpenCV</code>、开源的 <code>ddddocr</code>，或者直接打码平台都行，这里唯一要注意的一点就是图片是有缩放的，原始尺寸 <code>480 × 270 px</code> 渲染后的尺寸 <code>280 × 158 px</code>，比例大概是 <code>1:0.5833333333333333</code>，可以先将图片进行缩放后再识别，也可以先识别距离后再将距离进行缩放。</p><p><img src="https://cdn.itbob.cn/img/article/057/14.png" alt="14"></p><p>轨迹的处理，该站点校验并不太严格，所以可以自己写一下，关于滑块的轨迹处理，主要有缩放法、本地轨迹库、根据一些函数来生成轨迹，如缓动函数、贝塞尔曲线等，以后再单独写一篇文章来介绍，本例中可以使用缩放法，先采集一条正常的，手动滑出来的轨迹，然后根据识别出的实际距离和样本轨迹中的距离相比，得到一个比值，然后将样本中的 x 值和时间值都做一个对应的缩放，生成新的轨迹，主要代码如下：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_track</span>(<span class="hljs-params">distance</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;生成轨迹，样本距离为 126&quot;&quot;&quot;</span>    ratio = distance / <span class="hljs-number">126</span>    new_track = <span class="hljs-string">&quot;&quot;</span>    base_track = <span class="hljs-string">&quot;29,11,0|29,11,11|29,11,26|33,11,56|34,11,66|36,11,67|39,11,76|41,11,83|43,11,86|46,11,92|49,11,98|50,11,102|52,11,106|53,11,111|55,11,116|57,11,118|59,11,123|60,11,126|62,11,132|64,12,134|65,12,138|66,12,142|68,12,148|69,12,151|70,13,155|71,13,158|72,13,164|74,13,166|75,13,170|76,14,174|77,14,180|79,14,182|81,14,186|82,14,196|84,14,198|86,14,207|87,15,212|89,15,219|90,15,223|92,15,230|93,15,234|94,15,239|95,15,243|98,15,246|100,15,250|102,15,260|105,15,262|106,15,266|108,15,270|109,16,276|111,16,278|113,16,283|115,16,286|117,16,291|118,16,294|119,16,298|121,16,302|123,16,309|124,16,311|125,16,315|126,16,319|129,16,324|130,16,327|131,16,331|132,16,334|132,16,388|132,16,522|133,16,566|134,16,574|135,16,575|136,16,594|137,16,620|138,16,625|139,16,652|140,16,657|141,17,676|141,18,680|142,18,684|143,18,688|144,18,716|145,18,724|146,18,796|147,19,828|148,19,860|149,19,888|149,19,890|150,19,916|151,20,932|152,20,936|152,20,1021|153,20,1150|154,20,1152|155,20,1236|155,20,1388|155,20,1522|155,20,1717|&quot;</span>    base_track = base_track.split(<span class="hljs-string">&quot;|&quot;</span>)[:-<span class="hljs-number">1</span>]    <span class="hljs-keyword">for</span> track <span class="hljs-keyword">in</span> base_track:        t = track.split(<span class="hljs-string">&quot;,&quot;</span>)        new_track += <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(<span class="hljs-built_in">int</span>(t[<span class="hljs-number">0</span>]) * ratio)) + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-built_in">str</span>(t[<span class="hljs-number">1</span>]) + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(<span class="hljs-built_in">int</span>(t[<span class="hljs-number">2</span>]) * ratio)) + <span class="hljs-string">&quot;|&quot;</span>        logger.info(<span class="hljs-string">f&quot;new_track ==&gt; <span class="hljs-subst">&#123;new_track&#125;</span>&quot;</span>)        <span class="hljs-keyword">return</span> new_track</code></pre><h2><span id="jie-guo-yan-zheng">结果验证</span></h2><p>整个过程比较简单，验证成功。</p><p><img src="https://cdn.itbob.cn/img/article/057/15.png" alt="15"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/captcha_reverse.png&quot; alt=&quot;captcha_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="验证码逆向实战" scheme="https://www.itbob.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>抖音短视频 X-Bogus 逆向分析，JSVMP 纯算法还原</title>
    <link href="https://www.itbob.cn/article/056/"/>
    <id>https://www.itbob.cn/article/056/</id>
    <published>2022-10-16T11:00:00.000Z</published>
    <updated>2022-11-02T16:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/javascript_reverse.png" alt="javascript_reverse"></p><blockquote><p><strong>X-Bogus 参数，纯算法成品，交流请咨询微信：IT-BOB</strong><br><strong>X-Bogus 参数，纯算法成品，交流请咨询微信：IT-BOB</strong><br><strong>X-Bogus 参数，纯算法成品，交流请咨询微信：IT-BOB</strong></p></blockquote><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#shi-me-shi-jsvmp">什么是 JSVMP？</a></li><li><a href="#jsvmp-you-na-xie-xue-xi-zi-liao">JSVMP 有哪些学习资料？</a></li><li><a href="#jsvmp-ni-xiang-fang-fa-you-na-xie">JSVMP 逆向方法有哪些？</a></li><li><a href="#zhua-bao-qing-kuang">抓包情况</a></li><li><a href="#ni-xiang-fen-xi">逆向分析</a></li><li><a href="#cha-zhuang-fen-xi">插桩分析</a></li><li><a href="#28-ge-zi-fu-sheng-cheng-luo-ji">28个字符生成逻辑</a></li><li><a href="#luan-ma-zi-fu-chuan-sheng-cheng-luo-ji">乱码字符串生成逻辑</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：某音短视频网页端用户信息接口 X-Bogus 参数</li><li>接口：<code>aHR0cHM6Ly93d3cuZG91eWluLmNvbS9hd2VtZS92MS93ZWIvdXNlci9wcm9maWxlL290aGVyLw==</code></li></ul><h2><span id="shi-me-shi-jsvmp">什么是 JSVMP？</span></h2><p>JSVMP 全称 Virtual Machine based code Protection for JavaScript，即 JS 代码虚拟化保护方案。</p><p>JSVMP 的概念最早应该是由西北大学2015级硕士研究生匡开圆，在其2018年的学位论文中提出的，论文标题为：《基于 WebAssembly 的 JavaScript 代码虚拟化保护方法研究与实现》，同年还申请了国家专利，专利名称：《一种基于前端字节码技术的 JavaScript 虚拟化保护方法》，网上可以直接搜到，也可<a href="https://pan.baidu.com/s/1KJWJOgB8JeQx11p6ZJZBUg?pwd=6666">点击此链接</a>（密码6666），免费获取原版高清无水印的论文和专利。本文就简单介绍一下 JSVMP，想要详细了解，当然还是建议去读一下这篇论文。</p><p><img src="https://cdn.itbob.cn/img/article/056/01.png" alt="01"></p><p>JSVMP 的核心是在 JavaScript 代码保护过程中引入代码虚拟化思想，实现源代码的虚拟化过程，将目标代码转换成自定义的字节码，这些字节码只有特殊的解释器才能识别，隐藏目标代码的关键逻辑。在匡开圆的论文中，利用 WebAssembly 技术实现了特殊的虚拟解释器，通过编译隐藏解释器的执行逻辑。JSVMP 的保护流程如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/02.png" alt="02"></p><p>一个完整的 JSVMP 保护系统，大致的架构应该是这样子的：服务器端读取 JavaScript 代码 —&gt; 词法分析 —&gt; 语法分析 —&gt; 生成AST语法树 —&gt; 生成私有指令 —&gt; 生成对应私有解释器，将私有指令加密与私有解释器发送给浏览器，然后一边解释，一边执行。</p><p><img src="https://cdn.itbob.cn/img/article/056/03.png" alt="03"></p><h2><span id="jsvmp-you-na-xie-xue-xi-zi-liao">JSVMP 有哪些学习资料？</span></h2><p>除了匡开圆的论文以外，还有以下文章也值得学习：</p><ul><li><a href="https://mp.weixin.qq.com/s/YDx5Dr-HDfAm-sAqeWW0qg">H5应用加固防破解-js虚拟机保护方案浅谈</a></li><li><a href="https://blog.csdn.net/w2sft/article/details/120843310">JS加密？用虚拟机opcode保护JS源码</a></li><li><a href="https://bbs.pediy.com/thread-261414.htm">给&quot;某音&quot;的js虚拟机写一个编译器</a></li></ul><h2><span id="jsvmp-ni-xiang-fang-fa-you-na-xie">JSVMP 逆向方法有哪些？</span></h2><p>就目前来讲，JSVMP 的逆向方法有三种（自动化不算）：RPC 远程调用，补环境，日志断点还原算法，其中日志断点也称为插桩，找到关键位置，输出关键参数的日志信息，从结果往上倒推生成逻辑，以达到算法还原的目的，RPC 技术以前写过文章，补环境的方式以后有时间再写，本文主要介绍如何使用插桩来还原算法。</p><h2><span id="zhua-bao-qing-kuang">抓包情况</span></h2><p>随便来到某个博主主页，抓包后搜索可发现一个接口，返回的是 JSON 数据，里面包含了博主某音号，认证信息、签名，关注、粉丝、获赞等，请求 <code>Query String Parameters</code> 里包含了一个 <code>X-Bogus</code> 参数，每次请求会改变，此外还有 <code>sec_user_id</code> 是博主主页 URL 后面那一串，<code>webid</code> 直接请求主页返回内容里就有，<code>msToken</code> 与 cookie 有关，清除 cookie 访问，就没这个参数了，实测该接口不验证 <code>webid</code> 和 <code>msToken</code>，直接置空即可。</p><p><img src="https://cdn.itbob.cn/img/article/056/04.png" alt="04"></p><p><img src="https://cdn.itbob.cn/img/article/056/05.png" alt="05"></p><h2><span id="ni-xiang-fen-xi">逆向分析</span></h2><p>这条请求是 XHR 请求，所以直接下个 XHR 断点，当 URL 中包含 <code>X-Bogus</code> 参数时就断下：</p><p><img src="https://cdn.itbob.cn/img/article/056/06.png" alt="06"></p><p><img src="https://cdn.itbob.cn/img/article/056/07.png" alt="07"></p><p>往前跟栈，来到一个叫 webmssdk.js 的 JS 文件，这里就是生成参数的主要 JS 逻辑了，也就是 JSVMP，整体上做了一个混淆，这里可以使用 AST 来解混淆，以前同样也写过 AST 的文章，这里还原混淆不是重点，咱们直接使用 V 佬的插件 <a href="https://github.com/cilame/v_jstools">v_jstools</a> 来还原：</p><p><img src="https://cdn.itbob.cn/img/article/056/08.png" alt="08"></p><p>还原后使用浏览器的 Overrides 替换功能将 webmssdk.js 替换掉，往上跟栈，如下图所示，到 W 这里就已经生成了 <code>X-Bogus</code> 了，<code>this.openArgs[1]</code> 就是携带了 <code>X-Bogus</code> 的完整 URL，仔细观察这段代码，有很多三元表达式，当 M 的值为 15 时，就会走到这段逻辑，U 的值生成之后，有一个 <code>S[C] = U</code> 的操作。</p><p><img src="https://cdn.itbob.cn/img/article/056/09.png" alt="09"></p><p>再往上看代码，S 是一个数组，单步调试的话会发现代码会一直走这个 <code>if-else</code> 的逻辑，几乎每一步都有 S 数组的参与，不断往里面增删改查值，for 循环里面的 I 值，决定着后续 if 语句的走向，这里也就是插桩的关键所在，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/10.png" alt="10"></p><h2><span id="cha-zhuang-fen-xi">插桩分析</span></h2><p>大的 for 循环和 if-else 逻辑有两个地方，为了保证最后的日志更加详细完整，在这两个地方都下个日志断点（右键 <code>Add logpoint</code>），断点内容为：</p><pre><code class="hljs text">&quot;位置 1&quot;, &quot;索引I&quot;, I, &quot;索引A&quot;, A, &quot;值S: &quot;, JSON.stringify(S, function(key, value) &#123;if (value == window) &#123;return undefined&#125; return value&#125;)&quot;位置 2&quot;, &quot;索引I&quot;, I, &quot;索引A&quot;, A, &quot;值S: &quot;, JSON.stringify(S, function(key, value) &#123;if (value == window) &#123;return undefined&#125; return value&#125;)</code></pre><p><img src="https://cdn.itbob.cn/img/article/056/11.png" alt="11"></p><p>插桩输出 S 的时候为什么要写这么长一串呢？首先 <code>JSON.stringify()</code> 方法的作用是将 JavaScript 值转换为 JSON 字符串，基础语法是 <code>JSON.stringify(value[, replacer [, space]])</code>，如果不将其转换成 JSON，那么 S 的值，输出可能是这样的：<code>[empty, Array(26), 1, Array(0)]</code>，你看不到 Array 数组里面具体的值，该方法有个可选参数 replacer，如果 replacer 为函数，则 <code>JSON.stringify</code> 将调用该函数，并传入每个成员的键和值，在函数中可以对成员进行处理，最后返回处理后的值，如果此函数返回 undefined，则排除该成员，举个例子：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj1 = &#123;<span class="hljs-attr">key1</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-attr">key2</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeValue</span>(<span class="hljs-params">key, value</span>) </span>&#123;    <span class="hljs-keyword">if</span> (value == <span class="hljs-string">&#x27;value2&#x27;</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ITBOB&#x27;</span>    &#125; <span class="hljs-keyword">return</span> value&#125;<span class="hljs-keyword">var</span> obj2 = <span class="hljs-built_in">JSON</span>.stringify(obj1, changeValue)<span class="hljs-built_in">console</span>.log(obj2)<span class="hljs-comment">// 输出：&#123;&quot;key1&quot;:&quot;value1&quot;,&quot;key2&quot;:&quot;ITBOB&quot;&#125;</span></code></pre><p>上面的代码中 <code>JSON.stringify</code> 传入了一个函数，当 <code>value</code> 为 <code>value2</code> 的时候就将其替换成字符串 <code>ITBOB</code>，接下来我们演示一下当 <code>value</code> 为 <code>window</code> 时，会发生什么：</p><p><img src="https://cdn.itbob.cn/img/article/056/12.png" alt="12"></p><p>根据报错我们可以看到这里由于循环引用导致异常，要知道在插桩的时候，如果插桩内容有报错，就会导致不能正常输出日志，这样就会缺失一部分日志，这种情况我们就可以加个函数处理一下，让 value 为 window 的时候，JSON 处理的时候函数返回 undefined，排除该成员，其他成员正常输出，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/13.png" alt="13"></p><p>以上就是日志断点为什么要这样写的原因，下好日志断点后，注意前面我们下的 XHR 断点不要取消，然后刷新网页，控制台就开始打印日志了，因为有很多 XHR 请求都包含了 X-Bogus，如果你 XHR 断点取消了，日志就会一直打印直到卡死。日志输出完毕后，大约有8千多条，搜索就能看到最后一条日志 X-Bogus 已经生成了：</p><p><img src="https://cdn.itbob.cn/img/article/056/14.png" alt="14"></p><h2><span id="28-ge-zi-fu-sheng-cheng-luo-ji">28个字符生成逻辑</span></h2><p>直接在打印的日志页面右键 <code>save as..</code>，将日志导出到本地进行分析。<code>X-Bogus</code> 由28个字符组成，现在要做的就是看 <code>DFSzswVOAATANH89SMHZqF9WX7n6</code> 这28个字符是怎么来的，在日志里搜索这个字符串，找到第一次出现的地方，观察一下可以发现，他是逐个字符依次生成的，如下图红框所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/15.png" alt="15"></p><p>在上图中，第8511行，X-Bogus 字符串的下一个元素是 null，到了第8512行，就生成数字6了，那么在这两步之间就是数字6的生成逻辑，这个时候我们看第8511行的日志断点是 <code>位置 2 索引I 16 索引A 738</code>，那么我们回到原网页，在位置2，下一个条件断点（右键 <code>Add conditional breakpoint</code>），当 <code>I == 16 &amp;&amp; A == 738 &amp;&amp; S[7] &amp;&amp; S[7] == 21</code> 时就断下。之所以要加 <code>S[7]</code> 是因为 <code>索引I 16 索引A 738</code> 的位置有很多，在日志里搜一下大概有40多个，多加个限制条件就可以缩小范围，当然有可能加了多个条件仍然有多个位置都满足，这就需要你细心观察了，通过断点断下的时候看看控制台前面输出的日志来判断是不是我们想要的位置。这也是一个小细节，一定要找准位置，千万别搞混了。（提示一下，像我这样下断点的话，一般情况下会断下两次，第二次是满足要求的）</p><p>（注意：本文描述的日志的多少行、断点的具体位置、变量的具体值，可能会有所变化，以你的实际情况为准，但思路是一样的）</p><p><img src="https://cdn.itbob.cn/img/article/056/16.png" alt="16"></p><p>刷新网页，断下之后开始单步跟，来到下图所示的地方：</p><p><img src="https://cdn.itbob.cn/img/article/056/17.png" alt="17"></p><p>到这里之后，就不要下一步了，再下一步有可能整个语句就执行完毕了，其中的细节你看不到，所以这里我们在控制台挨个输入看看：</p><p><img src="https://cdn.itbob.cn/img/article/056/18.png" alt="18"></p><p>可以看到实际上的逻辑就是返回指定位置的字符，y 的值就是 <code>S[5]</code>，m 的值就是 <code>S[4]</code>，经过多次调试发现 m 的值是固定的，M 就是 <code>charAt()</code> 方法，我们再看看我们本地的日志，<code>S[5]</code> 的值为 <code>[20]</code>，<code>charAt()</code> 取值出来就是6，逻辑完全正确。</p><p><img src="https://cdn.itbob.cn/img/article/056/19.png" alt="19"></p><p>现在我们还需要知道这个20是怎么来的，继续往上看，找到20第一次出现的地方，在第8510行，那么我们就要使其在上一步断下，也就是第8509行，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/20.png" alt="20"></p><p>第8509行的索引信息为 <code>位置 2 索引I 47 索引A 730</code>，同样的下条件断点观察怎么生成的：</p><p><img src="https://cdn.itbob.cn/img/article/056/21.png" alt="21"></p><p><img src="https://cdn.itbob.cn/img/article/056/22.png" alt="22"></p><p>可以看到逻辑是 <code>S[5] &amp; S[6]</code>，再看我们本地 <code>S[5] = 5647508</code>、<code>S[6] = 63 </code>，<code>5647508 &amp; 63 = 20</code>，逻辑正确，20就是这么来的。接下来又开始找 <code>5647508</code> 和 <code>63</code> 是怎么生成的，同样在生成的上一步，也就是8508行下个条件断点，这行的索引为 <code>位置 2 索引I 72 索引A 726</code>。</p><p><img src="https://cdn.itbob.cn/img/article/056/23.png" alt="23"></p><p><img src="https://cdn.itbob.cn/img/article/056/24.png" alt="24"></p><p><img src="https://cdn.itbob.cn/img/article/056/25.png" alt="25"></p><p>可以看到 63 是直接 <code>q[A]</code> 生成的，q 是一个大数组，A 就是索引为 726，q 这个大数组怎么来的先不用管，而 <code>5647508</code> 这个大数字，搜索一下，发现有很多，咱们也先放着，到这里咱们可以总结一下最后一个字符的生成步骤如下：</p><pre><code class="hljs text">short_str = &quot;Dkdpgh4ZKsQB80/Mfvw36XI1R25-WUAlEi7NLboqYTOPuzmFjJnryx9HVGcaStCe=&quot;q[726] = 635647508 &amp; 63 = 20short_str.charAt(20) = &#x27;6&#x27;</code></pre><p>然后接日志着往上看，看倒数第二个字母是怎么来的，方法也和前面演示的一样，不断往前下条件断点，这里就不再逐步演示了，当你找完四个数字后，就可以开始看 <code>5647508</code> 这个大数字怎么来的了，搜索这个数字，同样的找到第一次出现的地方，在其前一步下条件断点，步骤捋出来会发现有一个乱码字符串经过 <code>charCodeAt()</code> 操作，再加上一些位运算得到的，乱码字符串类似下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/26.png" alt="26"></p><p>至于这个乱码字符串怎么来的，我们后面再讲，到这里先总结一下，首先我们的 <code>X-Bogus = DFSz swVO AATA NH89 SMHZ qF9W X7n6</code>，将其看成每四个为一组，之所以这么分组，是因为你经过分析后会发现，每一组的每一个字符生成流程都是一样的，这里以最后两组为例，流程大致如下：</p><pre><code class="hljs in">short_str = &quot;Dkdpgh4ZKsQB80/Mfvw36XI1R25-WUAlEi7NLboqYTOPuzmFjJnryx9HVGcaStCe=&quot;X-Bogus = DFSz swVO AATA NH89 SMHZ qF9W X7n6============== 第6组【qF9W】==============&quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;.charCodeAt(15) = 158q[342] = 16158 &lt;&lt; 16 = 10354688&quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;.charCodeAt(16) = 253q[408] = 8253 &lt;&lt; 8 = 6476810354688 | 64768 = 10419456&quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;.charCodeAt(17) = 156156 | 10419456 = 10419612q[520] = 1651507210419612 &amp; 16515072 = 10223616q[532] = 1810223616 &gt;&gt; 18 = 39short_str.charAt(39) = &#x27;q&#x27;q[590]= 25804810419612 &amp; 258048 = 192512q[602] = 12192512 &gt;&gt; 12 = 47short_str.charAt(47) = &#x27;F&#x27;q[660] = 403210419612 &amp; 4032 = 3456q[668] = 63456 &gt;&gt; 6 = 54short_str.charAt(54) = &#x27;9&#x27;q[726] = 6310419612 &amp; 63 = 28short_str.charAt(28) = &#x27;W&#x27;============== 第7组【X7n6】==============&quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;.charCodeAt(18) = 86q[342] = 1686 &lt;&lt; 16 = 5636096&quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;.charCodeAt(19) = 44q[408] = 844 &lt;&lt; 8 = 112645636096 | 11264 = 5647360&quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;.charCodeAt(20) = 148148 | 5647360 = 5647508q[520] = 165150725647508 &amp; 16515072 = 5505024q[532] = 185505024 &gt;&gt; 18 = 21short_str.charAt(21) = &#x27;X&#x27;q[590] = 2580485647508 &amp; 258048 = 139264q[602] = 12139264 &gt;&gt; 12 = 34short_str.charAt(34) = &#x27;7&#x27;q[660] = 40325647508 &amp; 4032 = 3200q[668] = 63200 &gt;&gt; 6 = 50short_str.charAt(50) = &#x27;n&#x27;q[726] = 635647508 &amp; 63 = 20short_str.charAt(20) = &#x27;6&#x27;</code></pre><p>将流程对比一下就可以发现，每个步骤 q 里面的取值都是一样的，这个可以直接写死，不同之处就在于最开始的 <code>charCodeAt()</code> 操作，也就是返回乱码字符串指定位置字符的 Unicode 编码，第7组依次是 18、19、20，第6组依次是15、16、17，以此类推，第1组刚好是0、1、2，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/056/27.png" alt="27"></p><p>每一组的逻辑都是一样的，我们就可以写个通用方法，依次生成七组字符串，最后拼接成完整的 <code>X-Bogus</code>，代码如下：（乱码字符串的生成后文会讲）</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getXBogus</span>(<span class="hljs-params">originalString</span>)</span>&#123;    <span class="hljs-comment">// 生成乱码字符串</span>    <span class="hljs-keyword">var</span> garbledString = getGarbledString(originalString);    <span class="hljs-keyword">var</span> XBogus = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-comment">// 依次生成七组字符串</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">20</span>; i += <span class="hljs-number">3</span>) &#123;        <span class="hljs-keyword">var</span> charCodeAtNum0 = garbledString.charCodeAt(i);        <span class="hljs-keyword">var</span> charCodeAtNum1 = garbledString.charCodeAt(i + <span class="hljs-number">1</span>);        <span class="hljs-keyword">var</span> charCodeAtNum2 = garbledString.charCodeAt(i + <span class="hljs-number">2</span>);        <span class="hljs-keyword">var</span> baseNum = charCodeAtNum2 | charCodeAtNum1 &lt;&lt; <span class="hljs-number">8</span> | charCodeAtNum0 &lt;&lt; <span class="hljs-number">16</span>;        <span class="hljs-comment">// 依次生成四个字符</span>        <span class="hljs-keyword">var</span> str1 = short_str[(baseNum &amp; <span class="hljs-number">16515072</span>) &gt;&gt; <span class="hljs-number">18</span>];        <span class="hljs-keyword">var</span> str2 = short_str[(baseNum &amp; <span class="hljs-number">258048</span>) &gt;&gt; <span class="hljs-number">12</span>];        <span class="hljs-keyword">var</span> str3 = short_str[(baseNum &amp; <span class="hljs-number">4032</span>) &gt;&gt; <span class="hljs-number">6</span>];        <span class="hljs-keyword">var</span> str4 = short_str[baseNum &amp; <span class="hljs-number">63</span>];        XBogus += str1 + str2 + str3 + str4;    &#125;    <span class="hljs-keyword">return</span> XBogus;&#125;</code></pre><h2><span id="luan-ma-zi-fu-chuan-sheng-cheng-luo-ji">乱码字符串生成逻辑</span></h2><p>在进行下一步之前，我们要注意两点：</p><ul><li><p>文章演示有些变量前后不对应，因为每次插桩的值都是会变的，看流程就行了，流程是正确的；</p></li><li><p>我们日志输出是经过 <code>JSON.stringify</code> 处理了的，有些步骤是向某个函数传入乱码字符串进行处理，你会发现处理后的结果和日志不一致，这是正常的。</p></li></ul><p>乱码字符串的生成相对来说稍微复杂一点，但思路仍然一样，这里就不一一截图展示了，直接用日志描述一下关键步骤，注意以下日志是正向的步骤，就不逆着推了，建议自己先逆着把流程走一走，再来看这个步骤就看得懂了。</p><p><strong>Step1</strong>：首先对 URL 后面的参数，也就是 <code>Query String Parameters</code> 进行两次 MD5、两次转 <code>Uint8Array</code> 处理，最后得到的 <code>Uint8Array</code> 对象在后面的步骤中用得到，步骤如下：</p><pre><code class="hljs text">位置 1 索引I 4  索引A 134：将 URL 后面的参数进行 MD5 加密得到字符串位置 1 索引I 16 索引A 460：将上一步的字符串转换为 Uint8Array 对象位置 1 索引I 4  索引A 134：将上一步的 Uint8Array 对象进行 MD5 加密，得到字符串位置 1 索引I 29 索引A 472：将上一步的字符串转换为 Uint8Array 对象</code></pre><p>上述步骤中，我们将最终得到的结果命名为 <code>uint8Array</code>，关键代码实现如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> md5 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;md5&quot;</span>);<span class="hljs-comment">// 字符串转换为 Uint8Array 对象，缺失的变量自行补齐</span>_0x5960a2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> c = a.length &gt;&gt; <span class="hljs-number">1</span>, e = c &lt;&lt; <span class="hljs-number">1</span>, b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(c), d = <span class="hljs-number">0</span>, f = <span class="hljs-number">0</span>; f &lt; e; ) &#123;        b[d++] = _0x511f86[a.charCodeAt(f++)] &lt;&lt; <span class="hljs-number">4</span> | _0x511f86[a.charCodeAt(f++)];    &#125;    <span class="hljs-keyword">return</span> b;&#125;<span class="hljs-comment">// originalString: URL 后面的原始参数</span><span class="hljs-keyword">var</span> uint8Array = _0x5960a2(md5(_0x5960a2(md5(originalString))));</code></pre><p><strong>Step2</strong>：生成两个大数，一个是时间戳，我们称之为 <code>fixedString1</code>，另一个调用某个方法生成，我们称之为 <code>fixedString2</code>。</p><pre><code class="hljs text">fixedString1位置 1 索引I 43 索引A 806：1663385262240 / 1000 = 1663385262.24fixedString2位置 1 索引I 16 索引A 834：M.apply(null, []) = 536919696</code></pre><p>上述步骤中，M 对应以下方法，缺失的方法自行补齐（其中 <code>_0x229792</code> 是创建 <code>canvas</code>）：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x2996f8</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> _0x4b3b53 || (_0xb55f3e.perf ? -<span class="hljs-number">1</span> : (_0x4b3b53 = _0x229792(<span class="hljs-number">3735928559</span>), _0x4b3b53));    &#125; <span class="hljs-keyword">catch</span> (a) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p><strong>Step3</strong>：先后生成两个数组，我们称之为 <code>array1</code>、<code>array2</code>，<code>array2</code> 就是由 <code>array1</code> 的元素位置变换后得来的，严格来讲，<code>array1</code> 不是一个完整的数组，而是一个个数字，这一点可以在日志中体现出来，为了方便我们就直接将其视为一个数组，两个数组都有19个元素，步骤如下：</p><pre><code class="hljs text">array1[0] 至 array1[3] 为定值array1[4]位置 1 索引I 25 索引A 946：uint8Array[14]array1[5]位置 1 索引I 25 索引A 970：uint8Array[15]array1[6] 至 array1[7] 与 post 提交的 form data 有关array1[8] 至 array1[9] 与 ua 有关，与 Step1 类似array1[10]位置 1 索引I 52 索引A 1090：fixedString1 &gt;&gt; 24 = 99位置 1 索引I 47 索引A 1098：99 &amp; 255 = 99array1[11]位置 1 索引I 52 索引A 1122：fixedString1 &gt;&gt; 16 = 25417位置 1 索引I 47 索引A 1130：25417 &amp; 255 = 73array1[12]位置 1 索引I 52 索引A 1154：fixedString1 &gt;&gt; 8 = 6506755位置 1 索引I 47 索引A 1162：6506755 &amp; 255 = 3array1[13]位置 1 索引I 52 索引A 1186：fixedString1 &gt;&gt; 0 = 241位置 1 索引I 47 索引A 1194：241 &amp; 255 = 241array1[14]位置 1 索引I 52 索引A 1218：fixedString2 &gt;&gt; 24 = 32位置 1 索引I 47 索引A 1226：32 &amp; 255 = 32array1[15]位置 1 索引I 52 索引A 1250：fixedString2 &gt;&gt; 16 = 8192位置 1 索引I 47 索引A 1258：8192 &amp; 255 = 0array1[16]位置 1 索引I 52 索引A 1282：fixedString2 &gt;&gt; 8 = 2097342位置 1 索引I 47 索引A 1290：2097342 &amp; 255 = 190array1[17]位置 1 索引I 52 索引A 1314：fixedString2 &gt;&gt; 0 = 536919696位置 1 索引I 47 索引A 1322：536919696 &amp; 255 = 144array1[18]位置 1 索引I 27 索引A 1352：array1.reduce(function(a, b) &#123; return a ^ b; &#125;); = 100array1 完整值如下位置 1 索引I 27 索引A 1538：64,1.00390625,1,8,9,185,69,63,74,125,99,73,3,241,32,0,190,144,100array2 由 array1 元素交换位置而来：array2 = [array1[0], array1[2], array1[4], array1[6], array1[8], array1[10], array1[12], array1[14], array1[16], array1[18], array1[1], array1[3], array1[5], array1[7], array1[9], array1[11], array1[13], array1[15], array1[17]]array2 完整值如下array2 = [64,1,9,69,74,99,3,32,190,100,1.00390625,8,185,63,125,73,241,0,144]</code></pre><p><strong>Step4</strong>：将 Step3 得到的 array2 经过转换得到乱码字符串，步骤如下：</p><pre><code class="hljs text">位置 1 索引I 16 索引A 1706：_0x2f2740.apply(null, array2) = &quot;@\u0000\u0001\u000eíxE?\u0016c%&gt;® \u0000¾ó&quot;位置 1 索引I 16 索引A 1760：_0x46fa4c.apply(null, [&quot;ÿ&quot;, &quot;@\u0000\u0001\u000e\t¹E?J&#125;cI\u0003ñ \u0000¾d&quot;]) = &quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;位置 1 索引I 16 索引A 1812：_0x2b6720.apply(null, [2, 255, &quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;]) = &quot;\u0002ÿ-%.*yê^s6ðýÇýV,&quot;</code></pre><p>其中用到的函数：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x2f2740</span>(<span class="hljs-params">a, c, e, b, d, f, t, n, o, i, r, _, x, u, s, l, v, h, g</span>) </span>&#123;    <span class="hljs-keyword">let</span> w = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">19</span>);    <span class="hljs-keyword">return</span> w[<span class="hljs-number">0</span>] = a,    w[<span class="hljs-number">1</span>] = r,    w[<span class="hljs-number">2</span>] = c,    w[<span class="hljs-number">3</span>] = _,    w[<span class="hljs-number">4</span>] = e,    w[<span class="hljs-number">5</span>] = x,    w[<span class="hljs-number">6</span>] = b,    w[<span class="hljs-number">7</span>] = u,    w[<span class="hljs-number">8</span>] = d,    w[<span class="hljs-number">9</span>] = s,    w[<span class="hljs-number">10</span>] = f,    w[<span class="hljs-number">11</span>] = l,    w[<span class="hljs-number">12</span>] = t,    w[<span class="hljs-number">13</span>] = v,    w[<span class="hljs-number">14</span>] = n,    w[<span class="hljs-number">15</span>] = h,    w[<span class="hljs-number">16</span>] = o,    w[<span class="hljs-number">17</span>] = g,    w[<span class="hljs-number">18</span>] = i,    <span class="hljs-built_in">String</span>.fromCharCode.apply(<span class="hljs-literal">null</span>, w);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x46fa4c</span>(<span class="hljs-params">a, c</span>) </span>&#123;    <span class="hljs-keyword">let</span> e, b = [], d = <span class="hljs-number">0</span>, f = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">256</span>; a++) &#123;        b[a] = a;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c = <span class="hljs-number">0</span>; c &lt; <span class="hljs-number">256</span>; c++) &#123;        d = (d + b[c] + a.charCodeAt(c % a.length)) % <span class="hljs-number">256</span>,        e = b[c],        b[c] = b[d],        b[d] = e;    &#125;    <span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>;    d = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>; a &lt; c.length; a++) &#123;        t = (t + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>,        d = (d + b[t]) % <span class="hljs-number">256</span>,        e = b[t],        b[t] = b[d],        b[d] = e,        f += <span class="hljs-built_in">String</span>.fromCharCode(c.charCodeAt(a) ^ b[(b[t] + b[d]) % <span class="hljs-number">256</span>]);    &#125;    <span class="hljs-keyword">return</span> f;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x583250</span>(<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode(a);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x2b6720</span>(<span class="hljs-params">a, c, e</span>) </span>&#123;    <span class="hljs-keyword">return</span> _0x583250(a) + _0x583250(c) + e;&#125;</code></pre><p>自此，整个流程就走完了。可以用 JavaScript 来实现整个算法，用 Python 也可以，完善代码后随便请求一个博主主页，简单解析几个数据，输出正常：</p><p><img src="https://cdn.itbob.cn/img/article/056/28.png" alt="28"></p><p><img src="https://cdn.itbob.cn/img/article/056/29.png" alt="29"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/javascript_reverse.png&quot; alt=&quot;javascript_reverse&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;X-Bogus 参数，纯算法成品，交</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>APP 逆向，Frida 初体验，root 检测与加密字符串定位</title>
    <link href="https://www.itbob.cn/article/055/"/>
    <id>https://www.itbob.cn/article/055/</id>
    <published>2022-09-12T10:00:00.000Z</published>
    <updated>2022-11-02T16:46:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/app_reverse.png" alt="app_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#an-zhuang-adb">安装 ADB</a></li><li><a href="#an-zhuang-frida">安装 Frida</a></li><li><a href="#ni-xiang-fen-xi">逆向分析</a><ul><li><a href="#jie-he-python-shi-yong">结合 Python 使用</a></li><li><a href="#frida-ming-ling">frida 命令</a></li></ul></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>设备：Google Pixel4，Android 10，已 root</li><li>APP：UnCrackable-Level1.apk（来源：<a href="https://github.com/OWASP/owasp-mastg/tree/master/Crackmes">https://github.com/OWASP/owasp-mastg/tree/master/Crackmes</a> ）</li><li>APP 检测了 root，如果手机 root 了，会强制退出 APP，过了 root 检测后，还需要输入一个字符串进行校验。</li></ul><h2><span id="an-zhuang-adb">安装 ADB</span></h2><p>adb（Android Debug Bridge）即安卓调试桥，安装后可以在电脑上与手机进行交互，Android Studio 等工具里面会自带 adb，有时候我们并不想下载这么大的工具，所以这里介绍一下 Android SDK Platform-Tools，它是 Android SDK 的一个组件，它包括与 Android 平台交互的工具，主要是 adb 和 fastboot，官方下载地址：<a href="https://developer.android.com/studio/releases/platform-tools">https://developer.android.com/studio/releases/platform-tools</a> ，下载完成后将该目录添加到环境变量，USB 连接手机，手机上设置允许 USB 调试，使用命令 <code>adb version</code> 可查看版本信息，<code>adb devices</code> 可以查看当前连接的设备，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/055/01.png" alt="01"></p><h2><span id="an-zhuang-frida">安装 Frida</span></h2><p>Frida 是一款基于 Python + JavaScript 的 Hook 与调试框架，首先电脑端使用命令 <code>pip install frida-tools</code> 安装 frida 模块（此命令默认会安装最新版的 frida 和 frida-tools，如），然后下载 frida-server，下载地址：<a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a></p><p>frida-server 要根据你电脑端安装的 frida 版本和手机的 CPU 架构来选择对应的，使用命令 <code>frida --version</code> 可以查看 frida 版本，使用命令 <code>adb shell</code> 进入手机，输入 <code>getprop ro.product.cpu.abi</code> 查看 CPU 架构，如下图所示，我这里 frida 是 15.2.2 版本，手机 CPU 为 arm64，所以我下载的是 <code>frida-server-15.2.2-android-arm64.xz</code>。</p><p>某些 Android 低版本使用高版本 frida 可能有问题，遇到问题可尝试降低 frida 版本来解决。</p><p><img src="https://cdn.itbob.cn/img/article/055/02.png" alt="02"></p><p><img src="https://cdn.itbob.cn/img/article/055/03.png" alt="03"></p><p>将下载好的 frida-server 使用 <code>adb push</code> 命令传到手机的 <code>/data/local/tmp/</code> 目录下，并给予 777 读、写、执行的权限，然后直接运行 frida-server，正常不会有任何输出，当然也可以使用 &amp; 等方式让其在后台运行。</p><p><img src="https://cdn.itbob.cn/img/article/055/04.png" alt="04"></p><p>然后另开一个 cmd 使用命令 <code>frida-ps -U </code> 可查看手机进程，有输出则正常。</p><p><img src="https://cdn.itbob.cn/img/article/055/05.png" alt="05"></p><h2><span id="ni-xiang-fen-xi">逆向分析</span></h2><p>使用 <code>adb install</code> 命令安装 UnCrackable-Level1.apk，打开该 APP，会检测到 root，出现 <code>Root detected!</code> 的提示，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/055/06.png" alt="06"></p><p>使用 JEB、JADX、GDA 等工具反编译 apk，直接搜索关键字 <code>Root detected!</code> 即可定位到检测的地方：</p><p><img src="https://cdn.itbob.cn/img/article/055/07.png" alt="07"></p><p>可以看到图中有三个检测方法 <code>c.a()</code>、<code>c.b()</code>、<code>c.c()</code>，其中一个返回为真，则弹出 <code>Root detected!</code>，然后前面还有一个 <code>onClick</code> 方法，如果点击 OK 按钮，则触发 <code>System.exit(0);</code>，即退出 APP，先点进三个检测方法看看：</p><p><code>a()</code> 方法通过检测 Android 系统环境变量中是否有 su 文件来判断是否被 root；</p><p><code>b()</code> 方法通过检测 <code>Build.TAGS</code> 中是否包含字符串 <code>test-keys</code> 来判断是否被 root；</p><p><code>c()</code> 方法通过检测指定路径下是否包含指定的文件来判断是否被 root。</p><p><img src="https://cdn.itbob.cn/img/article/055/08.png" alt="08"></p><p>所以我们这里就有多种过掉检测的方法：</p><p>方法一：Hook 三个检测方法，让它们都返回 false，不再执行后续的 a 方法，就不会退出 APP 了：</p><pre><code class="hljs javascript">Java.perform(    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook begin&quot;</span>)        <span class="hljs-keyword">var</span> vantagePoint = Java.use(<span class="hljs-string">&quot;sg.vantagepoint.a.c&quot;</span>)        vantagePoint.a.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook vantagepoint.a.c.a&quot;</span>)            <span class="hljs-built_in">this</span>.a();            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        vantagePoint.b.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook vantagepoint.a.c.b&quot;</span>)            <span class="hljs-built_in">this</span>.b();            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        vantagePoint.c.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook vantagepoint.a.c.c&quot;</span>)            <span class="hljs-built_in">this</span>.c();            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;)</code></pre><p>方法二：Hook <code>a()</code> 方法，置空，什么都不做，不弹出对话框，也不退出 APP：</p><pre><code class="hljs javascript">Java.perform(    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook begin&quot;</span>)        <span class="hljs-keyword">var</span> mainActivity = Java.use(<span class="hljs-string">&quot;sg.vantagepoint.uncrackable1.MainActivity&quot;</span>);        mainActivity.a.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook mainActivity.a&quot;</span>)        &#125;    &#125;)</code></pre><p>方法三：Hook <code>onClick()</code> 方法，点击 OK 后不让其退出 APP，注意这里是内部类的 Hook 写法：</p><pre><code class="hljs javascript">Java.perform(    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook begin&quot;</span>)        <span class="hljs-keyword">var</span> mainActivity$<span class="hljs-number">1</span> = Java.use(<span class="hljs-string">&quot;sg.vantagepoint.uncrackable1.MainActivity$1&quot;</span>);        mainActivity$<span class="hljs-number">1.</span>onClick.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook mainActivity$1.onClick&quot;</span>)        &#125;    &#125;)</code></pre><p>方法四：Hook <code>System.exit()</code> 方法，点击 OK 后不让其退出 APP：</p><pre><code class="hljs javascript">Java.perform(    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook begin&quot;</span>)        <span class="hljs-keyword">var</span> javaSystem = Java.use(<span class="hljs-string">&quot;java.lang.System&quot;</span>);        javaSystem.exit.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook system.exit&quot;</span>)        &#125;    &#125;)</code></pre><p>root 检测过掉之后，APP 还要输入一个字符串，输入错误会提示 <code>That's not it. Try again.</code>，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/055/09.png" alt="09"></p><p>分析 Java 代码，有一个 <code>if-else</code> 判断，obj 为输入的字符串，<code>a.a(obj)</code> 判断为真，就表示输入正确。</p><p><img src="https://cdn.itbob.cn/img/article/055/10.png" alt="10"></p><p>跟到 <code>a.a()</code> 方法，可以看到 <code>bArr</code> 是内置的字符串，通过 <code>equals()</code> 方法比较输入的 <code>str</code> 是否和 <code>bArr</code> 相等：</p><p><img src="https://cdn.itbob.cn/img/article/055/11.png" alt="11"></p><p><code>bArr</code> 的值，主要经过 <code>sg.vantagepoint.a.a.a()</code> 方法处理后得到，继续跟进去可以发现是 AES 加密算法：</p><p><img src="https://cdn.itbob.cn/img/article/055/12.png" alt="12"></p><p>这里就可以直接 Hook <code>sg.vantagepoint.a.a.a()</code>，直接拿到加密后的值，也就是我们要的正确字符串，由于这里返回的是 ASCII 码，所以我们还需要在 JavaScript 代码中使用 <code>String.fromCharCode()</code> 将其转换成正常字符，Hook 代码如下：</p><pre><code class="hljs javascript">Java.perform(    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">var</span> cryptoAES = Java.use(<span class="hljs-string">&quot;sg.vantagepoint.a.a&quot;</span>);        cryptoAES.a.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bArr, bArr2</span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook cryptoAES&quot;</span>)            <span class="hljs-keyword">var</span> secret = <span class="hljs-string">&quot;&quot;</span>;            <span class="hljs-keyword">var</span> decryptValue = <span class="hljs-built_in">this</span>.a(bArr, bArr2);            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] DecryptValue:&quot;</span>, decryptValue)            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i &lt; decryptValue.length; i++)&#123;              secret += <span class="hljs-built_in">String</span>.fromCharCode(decryptValue[i]);            &#125;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Secret:&quot;</span>, secret)            <span class="hljs-keyword">return</span> decryptValue;        &#125;    &#125;)</code></pre><p>运行 Hook 脚本有两种方式，一是结合 Python 使用，二是直接通过 frida 命令使用脚本，注入 Hook 代码也有个时机问题，有时候需要在 APP 启动就开始 Hook，有时候可以等 APP 启动加载完毕了再 Hook，本例中，过 root 检测的时候，如果采用第一、二种方法，即 Hook 三个检测方法或者 a 方法，那就需要在 APP 启动的时候就 Hook，如果采用第三、四种方法，即 Hook  <code>onClick()</code> 或者 <code>System.exit()</code> 方法，那么等 APP 启动了再 Hook 也可以。</p><h3><span id="jie-he-python-shi-yong">结合 Python 使用</span></h3><p>首先来看一下结合 Python 怎么使用，JavaScript 代码如下（frida-hook.js）：</p><pre><code class="hljs javascript"><span class="hljs-comment">/* ==================================</span><span class="hljs-comment"># @Time    : 2022-08-29</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: frida-hook.js</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ================================== */</span>Java.perform(    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook begin&quot;</span>)        <span class="hljs-comment">// 方法一：Hook 三个检测方法，让它们都返回 false，不再执行后续的 a 方法，就不会退出 APP 了</span>        <span class="hljs-comment">// var vantagePoint = Java.use(&quot;sg.vantagepoint.a.c&quot;)</span>        <span class="hljs-comment">// vantagePoint.a.implementation = function()&#123;</span>        <span class="hljs-comment">//     console.log(&quot;[*] Hook vantagepoint.a.c.a&quot;)</span>        <span class="hljs-comment">//     this.a();</span>        <span class="hljs-comment">//     return false;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// vantagePoint.b.implementation = function()&#123;</span>        <span class="hljs-comment">//     console.log(&quot;[*] Hook vantagepoint.a.c.b&quot;)</span>        <span class="hljs-comment">//     this.b();</span>        <span class="hljs-comment">//     return false;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// vantagePoint.c.implementation = function()&#123;</span>        <span class="hljs-comment">//     console.log(&quot;[*] Hook vantagepoint.a.c.c&quot;)</span>        <span class="hljs-comment">//     this.c();</span>        <span class="hljs-comment">//     return false;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// 方法二：Hook a() 方法，置空，什么都不做，不弹出对话框，也不退出 APP</span>        <span class="hljs-comment">// var mainActivity = Java.use(&quot;sg.vantagepoint.uncrackable1.MainActivity&quot;);</span>        <span class="hljs-comment">// mainActivity.a.implementation = function()&#123;</span>        <span class="hljs-comment">//    console.log(&quot;[*] Hook mainActivity.a&quot;)</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// 方法三：Hook onClick() 方法，点击 OK 后不让其退出 APP</span>        <span class="hljs-comment">// var mainActivity$1 = Java.use(&quot;sg.vantagepoint.uncrackable1.MainActivity$1&quot;);</span>        <span class="hljs-comment">// mainActivity$1.onClick.implementation = function()&#123;</span>        <span class="hljs-comment">//     console.log(&quot;[*] Hook mainActivity$1.onClick&quot;)</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// 方法四：Hook System.exit 方法，点击 OK 后不让其退出 APP</span>        <span class="hljs-keyword">var</span> javaSystem = Java.use(<span class="hljs-string">&quot;java.lang.System&quot;</span>);        javaSystem.exit.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook system.exit&quot;</span>)        &#125;        <span class="hljs-keyword">var</span> cryptoAES = Java.use(<span class="hljs-string">&quot;sg.vantagepoint.a.a&quot;</span>);        cryptoAES.a.implementation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bArr, bArr2</span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Hook cryptoAES&quot;</span>)            <span class="hljs-keyword">var</span> secret = <span class="hljs-string">&quot;&quot;</span>;            <span class="hljs-keyword">var</span> decryptValue = <span class="hljs-built_in">this</span>.a(bArr, bArr2);            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] DecryptValue:&quot;</span>, decryptValue)            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i &lt; decryptValue.length; i++)&#123;              secret += <span class="hljs-built_in">String</span>.fromCharCode(decryptValue[i]);            &#125;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[*] Secret:&quot;</span>, secret)            <span class="hljs-keyword">return</span> decryptValue;        &#125;    &#125;)</code></pre><p>Python 代码如下（<a href="http://frida-hook.py">frida-hook.py</a>）：</p><pre><code class="hljs python"><span class="hljs-comment"># ==================================</span><span class="hljs-comment"># --*-- coding: utf-8 --*--</span><span class="hljs-comment"># @Time    : 2022-08-29</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: frida-hook.py</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ==================================</span><span class="hljs-keyword">import</span> sys<span class="hljs-keyword">import</span> frida<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_message</span>(<span class="hljs-params">message, data</span>):</span>    <span class="hljs-keyword">if</span> message[<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;send&#x27;</span>:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[*] &#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(message[<span class="hljs-string">&#x27;payload&#x27;</span>]))    <span class="hljs-keyword">else</span>:        <span class="hljs-built_in">print</span>(message)<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./frida-hook.js&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> fp:    hook_string = fp.read()<span class="hljs-comment"># 方式一：attach 模式，已经启动的 APP</span>process = frida.get_usb_device(-<span class="hljs-number">1</span>).attach(<span class="hljs-string">&quot;Uncrackable1&quot;</span>)script = process.create_script(hook_string)script.on(<span class="hljs-string">&quot;message&quot;</span>, on_message)script.load()sys.stdin.read()<span class="hljs-comment"># 方式二，spawn 模式，重启 APP</span><span class="hljs-comment"># device = frida.get_usb_device(-1)</span><span class="hljs-comment"># pid = device.spawn([&quot;owasp.mstg.uncrackable1&quot;])</span><span class="hljs-comment"># process = device.attach(pid)</span><span class="hljs-comment"># script = process.create_script(hook_string)</span><span class="hljs-comment"># script.on(&quot;message&quot;, on_message)</span><span class="hljs-comment"># script.load()</span><span class="hljs-comment"># device.resume(pid)</span><span class="hljs-comment"># sys.stdin.read()</span></code></pre><p>Python 代码中，attach 模式 Hook 已经存在的进程，spawn 模式会重启 APP，启动一个新的进程并挂起，在启动的同时注入 frida 代码，适用于在进程启动前的一些 Hook，attach 模式传入的是 APP 名称，spawn 模式传入的是 APP 包名，查看 APP 名称和包名的方法有很多，这里介绍两个 frida 命令，<code>frida-ps -Uai</code>：列出安装的程序，<code>frida-ps -Ua</code>：列出正在运行中的程序，如下图所示，本例中 <code>Uncrackable1</code> 就是 APP 名称，<code>owasp.mstg.uncrackable1</code> 就是包名：</p><p><img src="https://cdn.itbob.cn/img/article/055/13.png" alt="13"></p><p>运行 Python 代码，注意手机端也要启动 frida-server，过掉 root 检测后，先随便输入字符串，点击 VERIFY 就会 Hook 到正确的字符串为 <code>I want to believe</code>，再次输入正确的字符串，即可验证成功。</p><p><img src="https://cdn.itbob.cn/img/article/055/14.png" alt="14"></p><h3><span id="frida-ming-ling">frida 命令</span></h3><p>不使用 Python，也可以直接使用 frida 命令来实现，和前面 Python  一样也有两种模式，同样的一个是 APP 名一个是包名：</p><p><code>frida -U Uncrackable1 -l .\frida-hook.js</code>：attach 模式，APP 启动后注入 frida 代码；</p><p><code>frida -U -f owasp.mstg.uncrackable1 -l .\frida-hook.js --no-pause</code>：spawn 模式，重启 APP，启动的同时注入 frida 代码。</p><p><img src="https://cdn.itbob.cn/img/article/055/15.png" alt="15"></p><p>至此，我们完美绕过了 root 检测，并成功找到了正确的字符串。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/app_reverse.png&quot; alt=&quot;app_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;!-</summary>
      
    
    
    
    <category term="APP 逆向实战" scheme="https://www.itbob.cn/categories/APP-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="APP 逆向实战" scheme="https://www.itbob.cn/tags/APP-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>国内 Web 防护天花板，瑞数 5 代 JS 逆向分析</title>
    <link href="https://www.itbob.cn/article/054/"/>
    <id>https://www.itbob.cn/article/054/</id>
    <published>2022-09-01T05:00:00.000Z</published>
    <updated>2022-11-02T15:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/javascript_reverse.png" alt="javascript_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#qian-yan">前言</a></li><li><a href="#cookie-ru-kou-ding-wei">Cookie 入口定位</a></li><li><a href="#vm-dai-ma-yi-ji-ts-bian-liang-huo-qu">VM 代码以及 $_ts 变量获取</a></li><li><a href="#shan-yong-watch-gen-zong-gong-neng">善用 Watch 跟踪功能</a></li><li><a href="#gen-zhan-fen-xi">跟栈分析</a></li><li><a href="#hou-zhui-sheng-cheng">后缀生成</a></li><li><a href="#zhi-wen-sheng-cheng">指纹生成</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="qian-yan">前言</span></h2><p><img src="https://cdn.itbob.cn/img/article/054/01.png" alt="01"></p><p>瑞数动态安全 Botgate（机器人防火墙）以“动态安全”技术为核心，通过动态封装、动态验证、动态混淆、动态令牌等技术对服务器网页底层代码持续动态变换，增加服务器行为的“不可预测性”，实现了从用户端到服务器端的全方位“主动防护”，为各类 Web、HTML5 提供强大的安全保护。</p><p>在往期的文章<a href="https://www.itbob.cn/article/053/">《国内 Web 防护天花板，瑞数 4 代 JS 逆向分析》</a>中，详细介绍了瑞数的特征、如何区分不同版本、瑞数的代码结构以及各自的作用，本文就不再赘述了，不了解的同志可以先去看看之前的文章。</p><h2><span id="cookie-ru-kou-ding-wei">Cookie 入口定位</span></h2><p>本文案例中瑞数 5 代网站为：<code>aHR0cHM6Ly93d3cubm1wYS5nb3YuY24vZGF0YXNlYXJjaC9ob21lLWluZGV4Lmh0bWw=</code></p><p>定位 Cookie，首选 Hook 来的最快，通过 Fiddler 插件、油猴脚本、浏览器插件等方式注入以下 Hook 代码：</p><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 严谨模式 检查所有错误</span><span class="hljs-meta">    &#x27;use strict&#x27;</span>;    <span class="hljs-comment">// document 为要hook的对象 这里是hook的cookie</span>    <span class="hljs-keyword">var</span> cookieTemp = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">document</span>, <span class="hljs-string">&#x27;cookie&#x27;</span>, &#123;        <span class="hljs-comment">// hook set方法也就是赋值的方法 </span>        <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;                <span class="hljs-comment">// 这样就可以快速给下面这个代码行下断点</span>                <span class="hljs-comment">// 从而快速定位设置cookie的代码</span>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hook捕获到cookie设置-&gt;&#x27;</span>, val);                <span class="hljs-keyword">debugger</span>;                cookieTemp = val;                <span class="hljs-keyword">return</span> val;        &#125;,        <span class="hljs-comment">// hook get 方法也就是取值的方法 </span>        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;            <span class="hljs-keyword">return</span> cookieTemp;        &#125;    &#125;);&#125;)();</code></pre><p>断下之后往上跟栈，可以看到组装 Cookie 后赋值给 <code>document.cookie</code> 的代码，类似如下结构：</p><p><img src="https://cdn.itbob.cn/img/article/054/02.png" alt="02"></p><p>继续往上跟栈，和4代瑞数类似，<code>(772, 1)</code> 的位置是入口，4代有一次生成假 cookie 的过程，5代就没有了，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/054/03.png" alt="03"></p><p>再往前跟栈，来到首页代码，这里就是我们熟悉的 call 位置了，图中 <code>_$ug</code> 实际上是 eval 方法，传入的第一个参数 <code>_$Cs</code> 是 Window 对象，第二个对象 <code>_$Dm</code> 是我们前面看到的 VM 虚拟机中的 IIFE 自执行代码。</p><p><img src="https://cdn.itbob.cn/img/article/054/04.png" alt="04"></p><h2><span id="vm-dai-ma-yi-ji-ts-bian-liang-huo-qu">VM 代码以及 $_ts 变量获取</span></h2><p>获取 VM 代码和 <code>$_ts</code> 变量是第一步，和4代类似，复制外链 JS（例如 <code>fjtvkgf7LVI2.a670748.js</code>）的代码和 412 页面的自执行代码到文件，本地直接运行即可，需要轻度补一下环境，缺啥补啥，大致补一下 window、location、document 就行了，补的具体内容可以直接在浏览器控制台使用 <code>copy()</code> 命令复制过来，然后 VM 代码我们就可以直接 Hook eval 的方式得到，这里 <code>$_ts</code> 变量的获取和4代有点儿区别，4代我们的做法是运行完代码后直接取 <code>window.$_ts</code> 就行了，5代运行完代码后会有一个清空 <code>$_ts</code> 的操作，可以自己跟栈看一下逻辑，要么把清空的逻辑删了，要么定义一个全局变量，然后直接在 call 的地方将 <code>$_ts</code> 的值导出来：</p><p><img src="https://cdn.itbob.cn/img/article/054/05.png" alt="05"></p><p>大致的补环境代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> eval_js = <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">var</span> rs_ts = <span class="hljs-string">&quot;&quot;</span><span class="hljs-built_in">window</span> = &#123;    <span class="hljs-attr">$_ts</span>: &#123;&#125;,    <span class="hljs-attr">eval</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;        eval_js = data    &#125;&#125;location = &#123;    <span class="hljs-string">&quot;ancestorOrigins&quot;</span>: &#123;&#125;,    <span class="hljs-string">&quot;href&quot;</span>: <span class="hljs-string">&quot;https://脱敏处理/datasearch/home-index.html&quot;</span>,    <span class="hljs-string">&quot;origin&quot;</span>: <span class="hljs-string">&quot;https://脱敏处理&quot;</span>,    <span class="hljs-string">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;https:&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.cn&quot;</span>,    <span class="hljs-string">&quot;hostname&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.cn&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,    <span class="hljs-string">&quot;pathname&quot;</span>: <span class="hljs-string">&quot;/datasearch/home-index.html&quot;</span>,    <span class="hljs-string">&quot;search&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,    <span class="hljs-string">&quot;hash&quot;</span>: <span class="hljs-string">&quot;&quot;</span>&#125;<span class="hljs-built_in">document</span> = &#123;    <span class="hljs-string">&quot;scripts&quot;</span>: [<span class="hljs-string">&quot;script&quot;</span>, <span class="hljs-string">&quot;script&quot;</span>]&#125;</code></pre><p>获取 VM 代码以及 <code>$_ts</code> 变量：</p><p><img src="https://cdn.itbob.cn/img/article/054/06.png" alt="06"></p><h2><span id="shan-yong-watch-gen-zong-gong-neng">善用 Watch 跟踪功能</span></h2><p>在跟栈分析之前，有必要了解一下浏览器开发者工具的 Watch 功能，它能够持续跟踪某个变量的值，对于瑞数这种控制流很多的情况，设置相应的变量跟踪，能够让你知道你现在处于哪个控制流中，以及生成的数组的变化，不至于跟着跟着不知道到哪一步了。如下图所示，<code>_$S8</code> 表示目前正处于第 279 号大控制流，<code>_$5x</code> 表示大控制流下的哪个分支，<code>_$mz</code> 表示 128 位大数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/07.png" alt="07"></p><h2><span id="gen-zhan-fen-xi">跟栈分析</span></h2><p>老样子，本地替换一套 412 页面的代码，固定下来，然后开始跟栈分析。直接从 <code>(772, 1)</code> 开始跟（文中说的第多少号控制流、第几步均为作者自己的叫法，第多少步并不代表实际上的步骤，仅表示关键步骤）：</p><p><img src="https://cdn.itbob.cn/img/article/054/08.png" alt="08"></p><p>单步进来，<code>_$qh</code> 是传进来的参数 1，即将进入 742 号控制流：</p><p><img src="https://cdn.itbob.cn/img/article/054/09.png" alt="09"></p><p>进入 742 号控制流，第 1 步通过一个方法获取了一个时间戳，进入这个方法内部，对时间戳进行了差值计算，会发现有两个变量 <code>_$tb</code> 和 <code>_$t1</code> 已经生成了值：</p><p><img src="https://cdn.itbob.cn/img/article/054/10.png" alt="10"></p><p><img src="https://cdn.itbob.cn/img/article/054/11.png" alt="11"></p><p>这两个值也是时间戳，怎么来的？直接搜索这两个变量，搜索结果有几个全部打上断点，刷新断下后往前跟栈，会发现是最开始走了一遍 703 号控制流：</p><p><img src="https://cdn.itbob.cn/img/article/054/12.png" alt="12"></p><p>先单步跟一遍 703 号控制流，703 号控制流第 1 步是进入 699 号控制流，返回一个数组，没有特别的，直接扣代码即可：</p><p><img src="https://cdn.itbob.cn/img/article/054/13.png" alt="13"></p><p>703 号控制流第 2、3 步分别取数组的值：</p><p><img src="https://cdn.itbob.cn/img/article/054/14.png" alt="14"></p><p><img src="https://cdn.itbob.cn/img/article/054/15.png" alt="15"></p><p>703 号控制流第 4、5、6 步生成两个时间戳并赋值给前面提到的 <code>_$tb</code>、<code>_$t1</code> 变量，涉及到的方法也没有什么特别的，缺啥搜啥补啥即可：</p><p><img src="https://cdn.itbob.cn/img/article/054/16.png" alt="16"></p><p><img src="https://cdn.itbob.cn/img/article/054/17.png" alt="17"></p><p><img src="https://cdn.itbob.cn/img/article/054/18.png" alt="18"></p><p>703 号控制流第 7 步，这里修改了 <code>$_ts</code> 的某个值（VM 代码中，<code>$_ts</code> 被赋值给了另一个变量，下图中是 <code>_$iw</code>），<code>_$iw._$uq</code> 原本的值是 <code>_$ou</code>，修改后的值是 181，这个值也是后面关键 4 位数组中的其中一个，具体逻辑后面再讲。</p><p><img src="https://cdn.itbob.cn/img/article/054/19.png" alt="19"></p><p>703 号控制流结束，我们继续前面的  742 号控制流，742 号控制流第 2 步，将前面生成的时间戳赋值给另一个变量。</p><p><img src="https://cdn.itbob.cn/img/article/054/20.png" alt="20"></p><p>742 号控制流第 3 步，进入 279 号控制流，279 号控制流是生成 128 位数组的关键。</p><p><img src="https://cdn.itbob.cn/img/article/054/21.png" alt="21"></p><p>进入 279 号控制流，第 1 步定义了一个变量：</p><p><img src="https://cdn.itbob.cn/img/article/054/22.png" alt="22"></p><p>279 号控制流，第 2 步，进入 157 号控制流，157 号控制流主要是做自动化检测</p><p><img src="https://cdn.itbob.cn/img/article/054/23.png" alt="23"></p><p><img src="https://cdn.itbob.cn/img/article/054/24.png" alt="24"></p><p>279 号控制流，第 3、4、5 步，做了一些运算，一些全局变量的值会改变，后续的数组里会用到。</p><p><img src="https://cdn.itbob.cn/img/article/054/25.png" alt="25"></p><p><img src="https://cdn.itbob.cn/img/article/054/26.png" alt="26"></p><p><img src="https://cdn.itbob.cn/img/article/054/27.png" alt="27"></p><p>279 号控制流，第 6 步，初始化了一个 128 位的空数组，后续的操作都是为了往这个数组里面填充值。</p><p><img src="https://cdn.itbob.cn/img/article/054/28.png" alt="28"></p><p>279 号控制流，第 7 步，进入 695 号控制流，生成一个 20 位的数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/29.png" alt="29"></p><p>进入 695 号控制流看一下，第 1 步，取 <code>$_ts</code> 的一个值，生成 16 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/30.png" alt="30"></p><p>695 号控制流，第 2 步，取 <code>$_ts</code> 里的四个值，与前面的 16 位数组一起组成 20 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/31.png" alt="31"></p><p>这里注意这四个值怎么来的，以第二个值 <code>_$iw._$KI</code> 为例，搜索发现有一条语句 <code>_$iw._$KI = _$iw[_$iw._$KI](_$bl, _$n2);</code>，首先等号右边取 <code>_$iw._$KI</code> 的值为 <code>_$Mo</code>，然后 <code>_$iw[&quot;_$Mo&quot;]</code> 实际上就是 <code>_$iw._$Mo</code>，前面的定义 <code>_$iw._$Mo = _$1D</code>，<code>_$1D</code> 是个方法，所以原语句相当于 <code>_$iw._$KI = _$1D(_$bl, _$n2)</code>，其他三个值的来源也是类似的。</p><p><img src="https://cdn.itbob.cn/img/article/054/32.png" alt="32"></p><p>695 号控制流结束，回到 279 号控制流，第 8 步，将前面的时间戳转换成了一个 8 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/33.png" alt="33"></p><p>279 号控制流，第 9 步，往 128 位数组里面添加了一个值。</p><p><img src="https://cdn.itbob.cn/img/article/054/34.png" alt="34"></p><p><code>_$ae</code> 这个值怎么来的？搜索下断点并跟栈，发现是开头走了第 178 号控制流得来的，跟着走一遍即可。</p><p><img src="https://cdn.itbob.cn/img/article/054/35.png" alt="35"></p><p><img src="https://cdn.itbob.cn/img/article/054/36.png" alt="36"></p><p>279 号控制流，第 10 步，又往 128 位数组里面添加了一个值，这个值是开始 279 号控制流传过来的。</p><p><img src="https://cdn.itbob.cn/img/article/054/37.png" alt="37"></p><p><img src="https://cdn.itbob.cn/img/article/054/38.png" alt="38"></p><p>279 号控制流，第 11、12、13、14 步，时间戳相关计算，然后生成两个 2 位数组。注意这里面的两个变量，<code>_$ll</code> 和 <code>_$ed</code>，在刷新 cookie、生成后缀的时候可能是有值的，仅访问主页没有值不影响。</p><p><img src="https://cdn.itbob.cn/img/article/054/39.png" alt="39"></p><p><img src="https://cdn.itbob.cn/img/article/054/40.png" alt="40"></p><p><img src="https://cdn.itbob.cn/img/article/054/41.png" alt="41"></p><p><img src="https://cdn.itbob.cn/img/article/054/42.png" alt="42"></p><p>279 号控制流，第 15 步，往 128 位数组里面添加了一个 4 位数组 <code>_$bl</code>，搜索也可以找到是通过 723 号控制流得来的。</p><p><img src="https://cdn.itbob.cn/img/article/054/43.png" alt="43"></p><p><img src="https://cdn.itbob.cn/img/article/054/44.png" alt="44"></p><p>这里的 723 号控制流，实际上是取了 <code>$_ts</code> 某个值进行运算，生成 16 位数组，然后截取前 4 位数组返回的。</p><p><img src="https://cdn.itbob.cn/img/article/054/45.png" alt="45"></p><p><img src="https://cdn.itbob.cn/img/article/054/46.png" alt="46"></p><p>279 号控制流，第 16 步，往 128 位数组里面添加了一个 8 位数组 <code>_$Yb</code>。</p><p><img src="https://cdn.itbob.cn/img/article/054/47.png" alt="47"></p><p>8 位数组 <code>_$Yb</code> 同样搜索打断点，可以在一个赋值语句断下：</p><p><img src="https://cdn.itbob.cn/img/article/054/48.png" alt="48"></p><p>可以看到 <code>_$EJ</code> 的值就是 <code>_$Yb</code>，往前跟栈，会发现先后经过了 657 号、10 号、777 号控制流，其中 777 号控制流是入口：</p><p><img src="https://cdn.itbob.cn/img/article/054/49.png" alt="49"></p><p><img src="https://cdn.itbob.cn/img/article/054/50.png" alt="50"></p><p><img src="https://cdn.itbob.cn/img/article/054/51.png" alt="51"></p><p>如果单步跟 777 号控制流，你会发现步骤较多，中间有些语句不好处理，且容易跟丢，所以我们这里就直接关注 657 号控制流就行了，777 号控制流直接到 10 号控制流，再到 657 号控制流，中间的一些过程暂时不管，跟到缺什么的时候再说（后续有很多取值赋值等操作都是在 777 号控制流里实现的，可以注意一下），这段逻辑在本地表现的代码如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/054/52.png" alt="52"></p><p>这里直接单步跟一下 657 号控制流，第 1、2 步 new 了一个方法。</p><p><img src="https://cdn.itbob.cn/img/article/054/53.png" alt="53"></p><p><img src="https://cdn.itbob.cn/img/article/054/54.png" alt="54"></p><p>这里就要注意了，容易跟丢，先进入 <code>_$bH</code> 方法打上断点，然后下一个断点就走到里面了，接着在单步调试，会进到另一个小的控制流里面，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/054/55.png" alt="55"></p><p><img src="https://cdn.itbob.cn/img/article/054/56.png" alt="56"></p><p>开始单步跟第 96 号小控制流，第 1 步定义了一个变量。</p><p><img src="https://cdn.itbob.cn/img/article/054/57.png" alt="57"></p><p>96 号小控制流，第 2 步将 <code>_$PI</code> 的值赋值给了 <code>_$fT</code>，而 <code>_$PI</code> 的值其实是 <code>window.localStorage.$_YWTU</code>，<code>window.localStorage</code> 里面有很多值，这个东西我们文章最后再讲，其中一些值与浏览器指纹相关，这里先知道他是取值就行了。</p><p><img src="https://cdn.itbob.cn/img/article/054/58.png" alt="58"></p><p>96 号小控制流，第 3 步，进入第 94 号小控制流，最终生成的是一个 8 位数组，这个其实就是前面我们想要的 <code>_$Yb</code> 的值了。</p><p><img src="https://cdn.itbob.cn/img/article/054/59.png" alt="59"></p><p>后面没有什么特别的，中间几步我就省略了，照着扣代码就行了，然后 96 号小控制流，第 4 步，就将 <code>_$EJ</code> 的值赋值给 <code>_$Yb</code> 了。</p><p><img src="https://cdn.itbob.cn/img/article/054/60.png" alt="60"></p><p>到这里先别急着结束，后面还有关键的几步，96 号小控制流，第 5 步，又遇到了和前面类似的写法。</p><p><img src="https://cdn.itbob.cn/img/article/054/61.png" alt="61"></p><p>同样的，先进 <code>_$pu</code> 打断点，再单步跟。</p><p><img src="https://cdn.itbob.cn/img/article/054/62.png" alt="62"></p><p>来到另一个小控制流，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/054/63.png" alt="63"></p><p>10 号小控制流第 1 步，取 <code>window.localStorage.$_cDro</code> 的值，转为 int 类型，赋值给 <code>_$5s</code>，这个 <code>_$5s</code> 后续也会加到 128 位大数组里面。</p><p><img src="https://cdn.itbob.cn/img/article/054/64.png" alt="64"></p><p>10 号小控制流后续还有几步，没啥用可以省略，最后一步返回 96 号小控制流。</p><p><img src="https://cdn.itbob.cn/img/article/054/65.png" alt="65"></p><p>然后 96 号小控制流后续也没啥了，返回 657 号控制流。</p><p><img src="https://cdn.itbob.cn/img/article/054/66.png" alt="66"></p><p>此时我们已经拿到  <code>_$Yb</code> 了，777 号控制流就先不管了，后续还有些代码先不管不用扣，等用到的时候再说，返回 279 号控制流，接着前面的步骤，来到第 17 步，变量 <code>_$5s</code> 经过 264 号控制流后，生成了一个值并添加到 128 位大数组里面，而 <code>_$5s</code> 的值正是前面我们跟 <code>_$Yb</code> 时，通过 777 号控制流拿到的，实际上也就是取 <code>window.localStorage.$_cDro</code> 的值，转为了 int 类型。</p><p><img src="https://cdn.itbob.cn/img/article/054/67.png" alt="67"></p><p>279 号控制流，第 18、19、20 步，往 128 位数组里面添加了两个定值、一个 8 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/68.png" alt="68"></p><p><img src="https://cdn.itbob.cn/img/article/054/69.png" alt="69"></p><p><img src="https://cdn.itbob.cn/img/article/054/70.png" alt="70"></p><p>279 号控制流，第 21 步，往 128 位数组里面添加了一个 <code>undefined</code> 占位，后续会有操作将其填充值。</p><p><img src="https://cdn.itbob.cn/img/article/054/71.png" alt="71"></p><p><img src="https://cdn.itbob.cn/img/article/054/72.png" alt="72"></p><p>279 号控制流，第 22 步，进入 58 号控制流，58 号控制流与 <code>window.localStorage.$_fb</code> 的值有关，如果有这个值，就会生成 20 位数组，如果没有就是 undefined。58 号控制流就只有一步，返回一个变量，本文中是 <code>_$0g</code>。</p><p><img src="https://cdn.itbob.cn/img/article/054/73.png" alt="73"></p><p><img src="https://cdn.itbob.cn/img/article/054/74.png" alt="74"></p><p>这个 <code>_$0g</code> 是咋来的呢？同样的直接搜索，下断点，发现是通过 112 号控制流得来的，往前跟栈，同样是先经过了 777 号控制流，和之前的情况类似，中间的过程就不看了，直接看这个 112 号控制流。</p><p><img src="https://cdn.itbob.cn/img/article/054/75.png" alt="75"></p><p>本文中，112 号控制流传的参是 <code>_$bd[279]</code> 即 <code>$_fb</code>，112 号控制流第 1 步，进入 247 号控制流。</p><p><img src="https://cdn.itbob.cn/img/article/054/76.png" alt="76"></p><p>247 号控制流就 3 步，先将 <code>window.localStorage</code> 赋值给一个变量，然后取其中 <code>$_fb</code> 的值再返回。</p><p><img src="https://cdn.itbob.cn/img/article/054/77.png" alt="77"></p><p><img src="https://cdn.itbob.cn/img/article/054/78.png" alt="78"></p><p><img src="https://cdn.itbob.cn/img/article/054/79.png" alt="79"></p><p>112 号控制流第 2、3 步，一个 <code>try-catch</code> 语句，取 <code>window.localStorage.$_fb</code> 计算得到 25 位数组，然后取前 20 位并返回，这就是前面我们需要的 <code>_$0g</code> 的值了。</p><p><img src="https://cdn.itbob.cn/img/article/054/80.png" alt="80"></p><p><img src="https://cdn.itbob.cn/img/article/054/81.png" alt="81"></p><p>279 号控制流，第 23 步，将前面 <code>window.localStorage.$_fb</code> 计算得到的 20 位数组添加到 128 位大数组里面，注意这一步如果没有 <code>window.localStorage.$_fb</code> 值的话，是不会添加的。</p><p><img src="https://cdn.itbob.cn/img/article/054/82.png" alt="82"></p><p>279 号控制流，第 24 步，对一个变量进行位运算，然后取 <code>window.localStorage.$_f0</code> 进行运算，如果 <code>$_f0</code> 为空的话是不会往 128 位大数组里添加值的。</p><p><img src="https://cdn.itbob.cn/img/article/054/83.png" alt="83"></p><p><img src="https://cdn.itbob.cn/img/article/054/84.png" alt="84"></p><p><img src="https://cdn.itbob.cn/img/article/054/85.png" alt="85"></p><p>279 号控制流，第 25 步，对一个变量进行位运算，然后取 <code>window.localStorage.$_fh0</code> 进行运算，如果 <code>$_fh0</code> 为空的话是不会往 128 位大数组里添加值的。</p><p><img src="https://cdn.itbob.cn/img/article/054/86.png" alt="86"></p><p><img src="https://cdn.itbob.cn/img/article/054/87.png" alt="87"></p><p><img src="https://cdn.itbob.cn/img/article/054/88.png" alt="88"></p><p>279 号控制流，第 26 步，对一个变量进行位运算，然后取 <code>window.localStorage.$_f1</code> 进行运算，如果 <code>$_f1</code> 为空的话是不会往 128 位大数组里添加值的。</p><p><img src="https://cdn.itbob.cn/img/article/054/89.png" alt="89"></p><p><img src="https://cdn.itbob.cn/img/article/054/90.png" alt="90"></p><p><img src="https://cdn.itbob.cn/img/article/054/91.png" alt="91"></p><p>279 号控制流，第 27 步，进入 611 号控制流，611 号控制流主要是检测 <code>window.navigator.connection.type</code>，即 <code>NetworkInformation</code> 网络相关信息，里面判断了 <code>type</code> 是不是 <code>bluetooth</code>、<code>cellular</code>、<code>ethernet</code>、<code>wifi</code>、<code>wimax</code>，正常的话应该返回 0。</p><p><img src="https://cdn.itbob.cn/img/article/054/92.png" alt="92"></p><p><img src="https://cdn.itbob.cn/img/article/054/93.png" alt="93"></p><p><img src="https://cdn.itbob.cn/img/article/054/94.png" alt="94"></p><p>279 号控制流，接下来几步都是类似的，这里就直接统称第 28 步了，首先对一个变量进行位运算，然后分别取 <code>window.localStorage.$_fr</code>、 <code>window.localStorage.$_fpn1</code> 、 <code>window.localStorage.$_vvCI</code>、 <code>window.localStorage.$_JQnh</code> 进行运算，同样如果这些变量为空的话，也是不会往 128 位大数组里添加值的。</p><p><img src="https://cdn.itbob.cn/img/article/054/96.png" alt="96"></p><p><img src="https://cdn.itbob.cn/img/article/054/97.png" alt="97"></p><p><img src="https://cdn.itbob.cn/img/article/054/98.png" alt="98"></p><p><img src="https://cdn.itbob.cn/img/article/054/99.png" alt="99"></p><p>279 号控制流，第 29 步，往 128 位大数组里添加了一个定值 4，本文中该变量名是 <code>_$kW</code>。</p><p><img src="https://cdn.itbob.cn/img/article/054/100.png" alt="100"></p><p><code>_$kW</code> 这个变量是咋来的，和前面的套路类似，直接搜索下断，同样是经过开头的 777 号控制流得来的，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/054/101.png" alt="101"></p><p>继续 279 号控制流，中间有一些变量位运算之类的就省略了，第 30、31 步，取了一个 <code>https:443</code> 的长度进行计算，先后往 128 位大数组里添加了一个定值和一个 9 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/102.png" alt="102"></p><p><img src="https://cdn.itbob.cn/img/article/054/103.png" alt="103"></p><p>279 号控制流，接下来几步都是在取值，都差不多，就统称为第 32 步了。</p><p><img src="https://cdn.itbob.cn/img/article/054/104.png" alt="104"></p><p><img src="https://cdn.itbob.cn/img/article/054/105.png" alt="105"></p><p><img src="https://cdn.itbob.cn/img/article/054/106.png" alt="106"></p><p><img src="https://cdn.itbob.cn/img/article/054/107.png" alt="107"></p><p><img src="https://cdn.itbob.cn/img/article/054/108.png" alt="108"></p><p><img src="https://cdn.itbob.cn/img/article/054/109.png" alt="109"></p><p>279 号控制流，第 33 步，之前 128 位大数组第 12 位是个 <code>undefined</code>，这里就将第 12 位填充上了一个 4 位数组，其中有个变量 <code>_$8L</code>，前面我们跟步骤的时候就有一个变量一直在做位运算，此处的 <code>_$8L</code> 就是这么来的。</p><p><img src="https://cdn.itbob.cn/img/article/054/110.png" alt="110"></p><p>279 号控制流，最后两步，原来的 128 位大数组，只取有值的前 21 位，一共有多少位与 <code>window.localStorage</code> 的某些值有关，有值的话就长一些，没有就短一些，然后再将数组的每个元素合并成最终的一个大数组并返回，279 号控制流就结束了。</p><p><img src="https://cdn.itbob.cn/img/article/054/111.png" alt="111"></p><p><img src="https://cdn.itbob.cn/img/article/054/112.png" alt="112"></p><p>返回到文章开头的逻辑，279 号控制流结束，返回到 742 号控制流，第 2 步，定义了一个变量并生成了一个 32 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/113.png" alt="113"></p><p><img src="https://cdn.itbob.cn/img/article/054/114.png" alt="114"></p><p>742 号控制流，第 3 步，取 <code>$_ts</code> 里面的某个值并赋值给一个变量。</p><p><img src="https://cdn.itbob.cn/img/article/054/115.png" alt="115"></p><p>742 号控制流，第 4 步，将前面 279 号控制流得到的大数组与上一步 <code>$_ts</code> 里面的某个值进行合并，合并后计算得到一个值。</p><p><img src="https://cdn.itbob.cn/img/article/054/116.png" alt="116"></p><p>742 号控制流，第 4 步，将上一步得到的值进一步计算得到一个 4 位数组，再将其和大数组合并。</p><p><img src="https://cdn.itbob.cn/img/article/054/117.png" alt="117"></p><p>742 号控制流，接下来几步是对时间戳进行各种操作，这里统称为第 5 步。</p><p><img src="https://cdn.itbob.cn/img/article/054/118.png" alt="118"></p><p><img src="https://cdn.itbob.cn/img/article/054/119.png" alt="119"></p><p><img src="https://cdn.itbob.cn/img/article/054/120.png" alt="120"></p><p><img src="https://cdn.itbob.cn/img/article/054/121.png" alt="121"></p><p>742 号控制流，第 6 步，将上一步得到的 4 个时间戳进行计算，得到一个 16 位数组。</p><p><img src="https://cdn.itbob.cn/img/article/054/122.png" alt="122"></p><p>742 号控制流，第 7 步，将上一步得到的 16 位数组进行异或运算。</p><p><img src="https://cdn.itbob.cn/img/article/054/123.png" alt="123"></p><p>742 号控制流，第 8 步，将上一步的 16 位数组进行计算，得到一个字符串。</p><p><img src="https://cdn.itbob.cn/img/article/054/124.png" alt="124"></p><p>742 号控制流，第 9 步，正式生成 cookie 值，其中 <code>_$bd[274]</code> 定值，一般视为版本号，将上一步得到的字符串、之前得到的大数组和一个 32 位数组进行计算、组合，得到最终结果。</p><p><img src="https://cdn.itbob.cn/img/article/054/125.png" alt="125"></p><p>742 号控制流结束，返回 772 号控制流，利用了一个方法，组装 cookie，然后赋值给 <code>document.cookie</code>，整个流程就结束了。</p><p><img src="https://cdn.itbob.cn/img/article/054/126.png" alt="126"></p><p><img src="https://cdn.itbob.cn/img/article/054/127.png" alt="127"></p><p><img src="https://cdn.itbob.cn/img/article/054/128.png" alt="128"></p><p>代码中用到的 <code>$_ts</code> 的值需要我们自己去匹配出来，动态替换，这些步骤和 4 代是类似的，本文就不再重复叙述，可以参考 4 代的那篇逆向文章进行处理即可。</p><p><img src="https://cdn.itbob.cn/img/article/054/129.png" alt="129"></p><h2><span id="hou-zhui-sheng-cheng">后缀生成</span></h2><p>本例中，请求头中有个 sign 参数，Query String Parameters 有两个后缀参数，这两个后缀和 4 代类似，都是瑞数生成的。</p><p><img src="https://cdn.itbob.cn/img/article/054/130.png" alt="130"></p><p><img src="https://cdn.itbob.cn/img/article/054/131.png" alt="131"></p><p>和 4 代的处理方法一样，我们下一个 XHR 断点，先让网页加载完毕，然后打开开发者工具，过掉无限 debugger 后，点击搜索就会断下，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/054/132.png" alt="132"></p><p>往上跟栈到 <code>hasTokenGet</code>，是一个 sojson 旗下的 jsjiami v6 混淆，不值一提，重点是 <code>jsonMD5ToStr</code> 方法，先对传进去的参数做了一些编码处理，最后返回的是 <code>hex_md5</code>，和在线 MD5 加密的结果是一样的，说明是标准的 MD5。</p><p><img src="https://cdn.itbob.cn/img/article/054/133.png" alt="133"></p><p><img src="https://cdn.itbob.cn/img/article/054/134.png" alt="134"></p><p>重点来看瑞数的两个后缀生成方式，和 4 代一样，<code>XMLHttpRequest.send</code> 和 <code>XMLHttpRequest.open</code> 被重写了，如下图所示，在 <code>XMLHttpRequest.open</code> 下个断点，也就是图中的 <code>_$RQ</code> 方法，<code>arguments[1]</code> 就是原始 URL，经过图中的 <code>_$tB</code> 方法处理后就能拿到后缀。</p><p><img src="https://cdn.itbob.cn/img/article/054/135.png" alt="135"></p><p>跟进图中的 <code>_$tB</code> 方法，<code>_$tB</code> 方法里嵌套了一些其他方法，走一遍逻辑，到图中的 <code>_$5j</code> 方法里，前面的一部分都是在对传入的 URL 做处理。</p><p><img src="https://cdn.itbob.cn/img/article/054/136.png" alt="136"></p><p>接下来是生成了一个 16 位数组：</p><p><img src="https://cdn.itbob.cn/img/article/054/137.png" alt="137"></p><p>然后这个 16 位数组经过一个方法后就生成了第一个后缀，如下图所示，本文中这个方法是 <code>_$ZO</code>。</p><p><img src="https://cdn.itbob.cn/img/article/054/138.png" alt="138"></p><p>跟进 <code>_$ZO</code> 方法，主要有以下 5 步：</p><p>第 1 步：生成了一个 32 位数组；</p><p>第 2 步：将之前的 16 位数组以及两个变量拼接生成一个 50 位的数组；</p><p>第 3 步：进入 744 控制流，这里你会发现和之前我们跟 cookie 时的 742 号控制流是一样的，重复走了一遍，所以这里就不再跟了；</p><p>第 4 步：将生成的第一个后缀值进行处理，得到一个两位的字符串，这个字符串在获取第二个后缀的时候会用到；</p><p>第 5 步：将第一个后缀名称和值进行拼接并返回，此时，第一个后缀 <code>hKHnQfLv</code> 就生成了。</p><p><img src="https://cdn.itbob.cn/img/article/054/139.png" alt="139"></p><p>接着前面的 <code>_$5j</code> 方法，图中的 <code>_$5j</code> 这一步，就是获取第二个后缀 <code>8X7Yi61c</code> 的值：</p><p><img src="https://cdn.itbob.cn/img/article/054/140.png" alt="140"></p><p>主要是看一下图中的 <code>_$UM</code> 方法，先将前面生成的两位的字符串与 URL 参数进行拼接，然后会经过一个 <code>_$Nr</code> 方法就能得到第二个后缀的值了。</p><p><img src="https://cdn.itbob.cn/img/article/054/141.png" alt="141"></p><p>再来看一下 <code>_$Nr</code> 方法，先生成一个类似 53924 的值，然后一个 try 语句，注意这里有个方法，图中的 <code>_$Js</code> 方法，里面用到了 <code>$_ts</code> 里面的某个值，后面又生成了一个由数字组成的字符串，再次经过组合、计算后得到最终的值。</p><p><img src="https://cdn.itbob.cn/img/article/054/142.png" alt="142"></p><p><img src="https://cdn.itbob.cn/img/article/054/143.png" alt="143"></p><p>回到前面的 <code>_$UM</code> 方法，前缀 <code>8X7Yi61c</code> 与值组合，自此，两个后缀都拿到了：</p><p><img src="https://cdn.itbob.cn/img/article/054/144.png" alt="144"></p><h2><span id="zhi-wen-sheng-cheng">指纹生成</span></h2><p>我们前面已经分析了，在往 128 位数组里添加值的时候，会有取 <code>window.localStorage</code> 里面的某些值进行计算的步骤，这些值就是取浏览器 canvas 等指纹生成的，指纹随机就能并发，通常访问单独的一个 html 页面是不校验指纹的，生成的短 cookie 就能通过，但是一些查询数据接口会校验指纹，通过触发 load 事件来向 cookie 里添加指纹，使得 cookie 长度变长，怎么查找指纹在哪里生成的，这里推荐直接看视频资料，已经讲得很清楚了，篇幅太长，本文就不再赘述了，资料链接：<a href="https://mp.weixin.qq.com/s/DEUc1K8WaO_Cq1a2r0Ge5g">https://mp.weixin.qq.com/s/DEUc1K8WaO_Cq1a2r0Ge5g</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/javascript_reverse.png&quot; alt=&quot;javascript_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>国内 Web 防护天花板，瑞数 4 代 JS 逆向分析</title>
    <link href="https://www.itbob.cn/article/053/"/>
    <id>https://www.itbob.cn/article/053/</id>
    <published>2022-07-01T04:00:00.000Z</published>
    <updated>2022-11-02T15:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/javascript_reverse.png" alt="javascript_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#qian-yan">前言</a></li><li><a href="#rui-shu-te-zheng-yi-ji-bu-tong-ban-ben-de-qu-bie">瑞数特征以及不同版本的区别</a></li><li><a href="#cookie-ru-kou-ding-wei">Cookie 入口定位</a></li><li><a href="#wen-jian-jie-gou-yu-luo-ji">文件结构与逻辑</a></li><li><a href="#vm-dai-ma-yi-ji-ts-bian-liang-huo-qu">VM 代码以及 $_ts 变量获取</a></li><li><a href="#kou-dai-ma">扣代码</a><ul><li><a href="#jia-cookie-sheng-cheng-luo-ji">假 Cookie 生成逻辑</a></li><li><a href="#zhen-cookie-sheng-cheng-luo-ji">真 Cookie 生成逻辑</a><ul><li><a href="#qu-jia-cookie">取假 Cookie</a></li><li><a href="#zi-dong-hua-gong-ju-jian-ce">自动化工具检测</a></li><li><a href="#20-wei-he-xin-shu-zu">20 位核心数组</a></li><li><a href="#qi-ta-yong-dao-ts-zhi-de-di-fang">其他用到 $_ts 值的地方</a></li></ul></li><li><a href="#zhu-yi-shi-xiang">注意事项</a></li><li><a href="#hou-zhui-mmewmd-sheng-cheng-luo-ji">后缀 MmEwMD 生成逻辑</a></li></ul></li><li><a href="#shan-yong-watch-gen-zong-gong-neng">善用 Watch 跟踪功能</a></li><li><a href="#jie-guo-yan-zheng">结果验证</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="qian-yan">前言</span></h2><p><img src="https://cdn.itbob.cn/img/article/053/01.png" alt="01"></p><p>瑞数动态安全 Botgate（机器人防火墙）以“动态安全”技术为核心，通过动态封装、动态验证、动态混淆、动态令牌等技术对服务器网页底层代码持续动态变换，增加服务器行为的“不可预测性”，实现了从用户端到服务器端的全方位“主动防护”，为各类 Web、HTML5 提供强大的安全保护。</p><p>瑞数 Botgate 多用于政企、金融、运营商行业，曾一度被视为反爬天花板，随着近年来逆向大佬越来越多，相关的逆向文章也层出不穷，真正到了人均瑞数的时代了，这里也感谢诸如 Nanda、懒神等逆向大佬，揭开了瑞数神秘的面纱，总结的经验让后来人少走了不少弯路。</p><p>过瑞数的方法基本上有以下几种：自动化工具（要隐藏特征值）、RPC 远程调用、JS 逆向（硬扣代码和补环境），本文介绍的是 JS 逆向硬扣代码，尽可能多的介绍各种细节。</p><h2><span id="rui-shu-te-zheng-yi-ji-bu-tong-ban-ben-de-qu-bie">瑞数特征以及不同版本的区别</span></h2><p>对于绝大多数使用了瑞数的网站来说，有以下几点特征（可能有特殊版本不一样，先仅看主流的）：</p><p>1、打开开发者工具（F12）会依次出现两个典型的无限 debugger：</p><p><img src="https://cdn.itbob.cn/img/article/053/02.png" alt="02"></p><p><img src="https://cdn.itbob.cn/img/article/053/03.png" alt="03"></p><p>2、瑞数的 JS 混淆代码中，变量、方法名大多类似于 <code>_$xx</code>，有众多的 <code>if-else</code> 控制流，新版瑞数还可能会有 jsvmp 以及众多三目表达式的情况：</p><p><img src="https://cdn.itbob.cn/img/article/053/04.png" alt="04"></p><p>3、看请求，会有典型的三次请求，首次请求响应码是 202（瑞数3、4代）或者 412（瑞数5代），接着单独请求一个 JS 文件，然后再重新请求页面，后续的其他 XHR 请求中，都带有一个后缀，这个后缀的值是由 JS 生成的，每次都会变化，后缀的值第一个数字为瑞数的版本，比如 <code>MmEwMD=4xxxxx</code> 就是4代瑞数，<code>bX3Xf9nD=5xxxxx</code> 就是5代瑞数：</p><p><img src="https://cdn.itbob.cn/img/article/053/05.png" alt="05"></p><p><img src="https://cdn.itbob.cn/img/article/053/06.png" alt="06"></p><p><img src="https://cdn.itbob.cn/img/article/053/07.png" alt="07"></p><p><img src="https://cdn.itbob.cn/img/article/053/08.png" alt="08"></p><p>4、看 Cookie，瑞数 3、4 代有以 T 和 S 结尾的两个 Cookie，其中以 S 开头的 Cookie 是第一次的 201 那个请求返回的，以 T 开头的 Cookie 是由 JS 生成的，动态变化的，T 和 S 前面一般会跟 80 或 443 的数字，Cookie 值第一个数字为瑞数的版本（为什么可以通过第一个数字来判断版本？难道相同版本第一个数字不会变吗？这些问题我们在分析 JS 的时候可以找到答案），比如：</p><ul><li><code>FSSBBIl1UgzbN7N80T=37Na97B.nWX3....</code>：数字 80 是 http 协议的默认端口号，对应 http 请求，其值第一位为 3，表示 3 代瑞数；</li><li><code>FSSBBIl1UgzbN7N443T=4a.tr1kEXk.....</code>：数字 443 是 https 协议的默认端口号，对应 https 请求，其值第一位为 4，表示 4 代瑞数。</li></ul><p><img src="https://cdn.itbob.cn/img/article/053/09.png" alt="09"></p><p>瑞数 5 代也有以 T 和 S 结尾的两个 Cookie，但有些特殊的 5 代瑞数也有以 O 和 P 结尾的，同样的，以 O 开头的是第一次的 412 那个请求返回的，以 P 开头的是由 JS 生成的，Cookie 值第一个数字同样为瑞数的版本，和 3、4 代不同的是，5 代没有加端口号了，比如：</p><ul><li><code>vsKWUwn3HsfIO=57C6DwDUXS.....</code>：以 O 结尾，其值第一位为 5，表示 5 代瑞数；</li><li><code>WvY7XhIMu0fGT=53.9fybty......</code>：以 T 结尾，其值第一位为 5，表示 5 代瑞数。</li></ul><p><img src="https://cdn.itbob.cn/img/article/053/10.png" alt="10"></p><p><img src="https://cdn.itbob.cn/img/article/053/11.png" alt="11"></p><p>5、看入口，瑞数有个流程是在虚拟机 VM 中加载 1w+ 行的代码，加载此代码的入口，不同版本也不一样（这个入口具体在哪里？怎么定位？在后续逆向分析中再详细介绍），示例如下：</p><ul><li>3 代：<code>_$aW = _$c6[_$l6()](_$wc, _$mo);</code>，<code>_$c6</code> 实际上是 <code>eval</code>，<code>_$l6()</code> 实际上是 <code>call</code>；</li></ul><p><img src="https://cdn.itbob.cn/img/article/053/12.png" alt="12"></p><ul><li>4 代：<code>ret = _$DG.call(_$6a, _$YK);</code>，<code>_$DG</code> 实际上是 <code>eval</code>，有关键字 <code>ret</code>，<code>call</code> 是明文；</li></ul><p><img src="https://cdn.itbob.cn/img/article/053/13.png" alt="13"></p><ul><li>5 代：5 代种类比较多了，最初和 4 代的类似，比如 <code>ret = _$Yg.call(_$kc, _$mH);</code>，有关键字 ret，call 是明文，也有没有 ret 关键字的版本，比如 <code>_$ap = _$j5.call(_$_T, _$gp);</code>，也有像 3 代那样全部混淆了的，比如：<code>_$x8 = _$mP[_$nU[15]](_$z3, _$Ec);</code>，<code>_$mP</code> 实际上是 <code>eval</code>，<code>_$nU[15]</code> 实际上是 <code>call</code>，混淆的 <code>call</code> 与 3 代的区别就是 5 代是在一个数组里取值得到的；</li></ul><p><img src="https://cdn.itbob.cn/img/article/053/14.png" alt="14"></p><p><img src="https://cdn.itbob.cn/img/article/053/15.png" alt="15"></p><p><img src="https://cdn.itbob.cn/img/article/053/16.png" alt="16"></p><p>当然要想精准区分不同版本，得各个条件结合起来看，最主要的还是得看看内部的实现逻辑，以及页面的代码结构，比如 4 代有一个生成假 Cookie 的步骤，而 5 代没有，有的特殊版本虽然看起来是 5 代，但是加了 jsvmp 和三目表达式，和传统的 5 代又有区别，偶尔愚人节啥的突然来个新版本，也会不一样，各版本在分析一遍之后，就很容易区分了。</p><h2><span id="cookie-ru-kou-ding-wei">Cookie 入口定位</span></h2><p>本文案例中瑞数 4 代网站为：<code>aHR0cDovL3d3dy5mYW5nZGkuY29tLmNuL25ld19ob3VzZS9uZXdfaG91c2VfZGV0YWlsLmh0bWw=</code></p><p>首先过掉无限 debugger（过不过其实无所谓，后面的分析其实这个基本上没影响），直接右键 <code>Never pause here</code> 永不在此处断下即可：</p><p><img src="https://cdn.itbob.cn/img/article/053/17.png" alt="17"></p><p>定位 Cookie，首选 Hook 来的最快，通过 Fiddler 等抓包工具、油猴脚本、浏览器插件等方式注入以下 Hook 代码：</p><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 严谨模式 检查所有错误</span><span class="hljs-meta">    &#x27;use strict&#x27;</span>;    <span class="hljs-comment">// document 为要hook的对象 这里是hook的cookie</span>    <span class="hljs-keyword">var</span> cookieTemp = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">document</span>, <span class="hljs-string">&#x27;cookie&#x27;</span>, &#123;        <span class="hljs-comment">// hook set方法也就是赋值的方法 </span>        <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;                <span class="hljs-comment">// 这样就可以快速给下面这个代码行下断点</span>                <span class="hljs-comment">// 从而快速定位设置cookie的代码</span>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hook捕获到cookie设置-&gt;&#x27;</span>, val);                <span class="hljs-keyword">debugger</span>;                cookieTemp = val;                <span class="hljs-keyword">return</span> val;        &#125;,        <span class="hljs-comment">// hook get 方法也就是取值的方法 </span>        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;            <span class="hljs-keyword">return</span> cookieTemp;        &#125;    &#125;);&#125;)();</code></pre><p>Hook 发现会有生成两次 Cookie 的情况，断下之后往上跟栈，可以看到组装 Cookie 的代码，类似如下结构：</p><p><img src="https://cdn.itbob.cn/img/article/053/18.png" alt="18"></p><p>仔细观察这两次 Cookie 生成的地方，分别往上跟栈，你就会发现两个 Cookie 分别是经过了两个不同方法得到的，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/053/19.png" alt="19"></p><p><img src="https://cdn.itbob.cn/img/article/053/20.png" alt="20"></p><p>这里的代码存在于 VM 虚拟机中，且是 IIFE 自执行代码，我们还得往前跟栈看看这些 VM 代码是从哪里加载出来的，跟栈来到首页（202页面）带有 call 的位置：</p><p><img src="https://cdn.itbob.cn/img/article/053/21.png" alt="21"></p><p>我们在文章开头介绍的这个位置就是这么分析得来的，这个位置通常在分析瑞数的时候作为入口，图中 <code>_$te</code> 实际上是 eval 方法，传入的第一个参数 <code>_$fY</code> 是 Window 对象，第二个对象 <code>_$F8</code> 是我们前面看到的 VM 虚拟机中的 IIFE 自执行代码。</p><p>在知道了瑞数大致的入口之后，我们也可以使用事件监听中的 Script 断点，一直下一个断点（F8）就可以走到 202 页面，然后搜索 call 关键字就能快速定位到入口，Script 断点中的两个选项，第一个表示运行 JS 脚本的第一条语句时断下，第二个表示 JS 因为内容安全政策而被屏蔽时断下，一般选择第一个就可以了，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/053/22.png" alt="22"></p><h2><span id="wen-jian-jie-gou-yu-luo-ji">文件结构与逻辑</span></h2><p>想要后续分析 Cookie 的生成，我们不得不要观察一下 202 页面的代码，meta 标签有个 content 内容，引用了一个类似于 <code>c.FxJzG50F.dfe1675.js</code> 的 JS 文件，接着跟一个自执行的 JS，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/053/23.png" alt="23"></p><p>第1部分 meta 标签的 content 内容，每次都是变化的，第2部分引用的这个外部 JS 在不同页面也有所差别，但是同一个网站同一个页面 JS 里的内容一般是固定不会变的，第3部分自执行代码每次变化的只是变量名，整体逻辑不变，后续我们在扣代码的时候，也会用到这里的部分方法。自执行代码里同样也是有很多 <code>if-else</code> 控制流，开头的那个数组，比如上图中的 <code>_$Dk</code> 就是用来控制后续的控制流的。</p><p>引用的 <code>c.FxJzG50F.dfe1675.js</code> 直接打开看是乱码的，而自执行 JS 的主要作用是将这 JS 乱码还原成 VM 里的 1w+ 行的正常代码，并且定义了一个全局变量 <code>window.$_ts</code> 并赋了许多值，这个变量在后续 VM 中作用非常大，meta 标签的 content 内容同样也会在 VM 里用到。</p><p>由于很多值、变量都是动态变化的，肯定不利于我们的分析，所以我们需要固定一套代码到本地，打断点、跟栈都会更加方便，随便保存一份 202 页面的代码，以及该页面对应的外链 JS 文件，如 <code>c.FxJzG50F.dfe1675.js</code> 到本地，使用浏览器自带的 overrides 重写功能、或者浏览器插件 ReRes、或者抓包工具的响应替换功能（如 Fiddler 的 AutoResponder）进行替换。</p><p><img src="https://cdn.itbob.cn/img/article/053/24.png" alt="24"></p><p>VM 里面的代码是生成 Cookie 的主要代码，包含众多的 <code>if-else</code> 控制流，无疑增加了我们分析代码的成本，这里就可以使用 AST 技术做一下反混淆，比如 Nanda 就将 <code>if-else</code> 控制流转换成了 <code>switch-case</code> 的，同一个控制流下的代码放在了同一个 <code>case</code> 下，然后在 <code>call</code> 入口那个地方，将 VM 代码做一下本地替换，具体可以参考 Nanda 的文章：<a href="https://mp.weixin.qq.com/s/r3FXjvT5Mm9Ikg_bDEadcw">《某数4代逻辑分析》</a>，感兴趣的可以试试，不了解 AST 的可以看看以前的文章<a href="https://mp.weixin.qq.com/s/fIbPuNMs5FRADJE5MOZXgA">《逆向进阶，利用 AST 技术还原 JavaScript 混淆代码》</a>，后续有时间再写写 AST 还原瑞数代码的实战，本文咱们选择硬刚！</p><p><img src="https://cdn.itbob.cn/img/article/053/25.jpg" alt="25"></p><h2><span id="vm-dai-ma-yi-ji-ts-bian-liang-huo-qu">VM 代码以及 $_ts 变量获取</span></h2><p>前面我们了解了 VM 代码和 <code>$_ts</code> 的重要性，所以我们第一步是要想办法拿到他们，至于在什么时候有用到，文章后续再说，复制外链 JS，即  <code>c.FxJzG50F.dfe1675.js</code> 的代码和 202 页面的自执行代码到文件，本地直接运行即可，需要轻度补一下环境，缺啥补啥，大致补一下 window、location、document 就行了，补的具体内容可以直接在浏览器控制台使用 <code>copy()</code> 命令复制过来，然后 VM 代码我们就可以直接 Hook eval 的方式得到，大致的补环境代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> eval_js = <span class="hljs-string">&quot;&quot;</span><span class="hljs-built_in">window</span> = &#123;    <span class="hljs-attr">$_ts</span>:&#123;&#125;,    <span class="hljs-attr">eval</span>:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;        eval_js = data    &#125;&#125;location = &#123;    <span class="hljs-string">&quot;ancestorOrigins&quot;</span>: &#123;&#125;,    <span class="hljs-string">&quot;href&quot;</span>: <span class="hljs-string">&quot;http://www.脱敏处理.com.cn/new_house/new_house_detail.html&quot;</span>,    <span class="hljs-string">&quot;origin&quot;</span>: <span class="hljs-string">&quot;http://www.脱敏处理.com.cn&quot;</span>,    <span class="hljs-string">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;http:&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.com.cn&quot;</span>,    <span class="hljs-string">&quot;hostname&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.com.cn&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,    <span class="hljs-string">&quot;pathname&quot;</span>: <span class="hljs-string">&quot;/new_house/new_house_detail.html&quot;</span>,    <span class="hljs-string">&quot;search&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,    <span class="hljs-string">&quot;hash&quot;</span>: <span class="hljs-string">&quot;&quot;</span>&#125;<span class="hljs-built_in">document</span> = &#123;    <span class="hljs-string">&quot;scripts&quot;</span>: [<span class="hljs-string">&quot;script&quot;</span>, <span class="hljs-string">&quot;script&quot;</span>]&#125;</code></pre><p><img src="https://cdn.itbob.cn/img/article/053/25.png" alt="25"></p><p>观察 <code>$_ts</code> 的 key 和 value，和浏览器中得到的是一样的：</p><p><img src="https://cdn.itbob.cn/img/article/053/26.png" alt="26"></p><p>注意事项：<code>c.FxJzG50F.dfe1675.js</code> 外链 JS 如果你直接下载下来用编辑器打开可能会被自动编码，和原始数据有出入，导致运行报错，这里建议直接在浏览器在线访问这个文件，手动复制过来，或者在抓包软件里将响应内容复制过来，观察以下两种情况，第一种情况就可能会导致运行出错，第二种是正常的：</p><p><img src="https://cdn.itbob.cn/img/article/053/27.png" alt="27"></p><h2><span id="kou-dai-ma">扣代码</span></h2><p>前面说了这么多，现在终于可以进入主题了，那就是扣代码，找个好椅子，准备把屁股坐穿，此时你的键盘只有 F11 有用，不断单步调试，只需要亿点点细节，就完事儿了！</p><p>扣代码步骤太多，不可能每一步都截图写出来，只写一下比较重要的，如有遗漏的地方，那也没办法，首先先在我们替换的 202 页面里，自执行代码开始的地方手动加个 debugger，一进入页面就断下，方便后续的分析：</p><p><img src="https://cdn.itbob.cn/img/article/053/28.png" alt="28"></p><p>通过前面我们的分析，已经知道了入口在 call 的地方，快速搜索并下断点：</p><p><img src="https://cdn.itbob.cn/img/article/053/29.png" alt="29"></p><p>通过前面我们的分析，我们也知道了有两次生成 Cookie 的地方，快速搜索 <code>(5)</code>，搜索结果第二个即为入口：</p><p><img src="https://cdn.itbob.cn/img/article/053/30.png" alt="30"></p><h3><span id="jia-cookie-sheng-cheng-luo-ji">假 Cookie 生成逻辑</span></h3><p>首先单步跟假 Cookie，虽然是假的，但是后续生成真 Cookie 中会用到，在跟的时候你会走到这个逻辑里面：</p><p><img src="https://cdn.itbob.cn/img/article/053/31.png" alt="31"></p><p>有一步会调用 <code>_$8e()</code> 方法，而 <code>_$8e = _$Q9</code>，<code>_$Q9</code> 又嵌套在 <code>_$d0</code> 里的，搜索一下哪里调用了 <code>_$d0</code>，发现是代码开头：</p><p><img src="https://cdn.itbob.cn/img/article/053/32.png" alt="32"></p><p>那么传入的参数 <code>_$Wn</code> 是啥呢？单步跟入，是一个方法，作用就是取 202 页面的 content 内容，那么我们在本地就直接删掉这个 <code>_$Wn</code> 方法，直接传入 content 的值即可，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/053/33.png" alt="33"></p><p>另外，我们发现，代码有非常多的在数组里面按索引取值的情况，比如上图中的 <code>_$PV[68]</code> 的值，实际上就是字符串 content，很显然我们要把这个数组的来源找到，直接搜索 <code>_$PV = </code>，可以找到疑似定义和赋值的地方：</p><p><img src="https://cdn.itbob.cn/img/article/053/34.png" alt="34"></p><p><img src="https://cdn.itbob.cn/img/article/053/35.png" alt="35"></p><p>所以我们得看看这个 <code>_$iL</code> 方法，传入了一个非常长的字符串，打断点进去看看，果然生成了 <code>_$PV</code>，是一个 725 位的数组：</p><p><img src="https://cdn.itbob.cn/img/article/053/36.png" alt="36"></p><p>接下来在扣代码的过程中，你会经常遇到一个变量，在本文中是 <code>_$sX</code>：</p><p><img src="https://cdn.itbob.cn/img/article/053/37.png" alt="37"></p><p>有没有很熟悉？这个值就是我们前面拿到的 <code>$_ts</code> 变量，在开头就可以看到是将 <code>window.$_ts</code> 赋值给了 <code>_$sX</code>：</p><p><img src="https://cdn.itbob.cn/img/article/053/38.png" alt="38"></p><p>继续走，会走到以下逻辑中：</p><p><img src="https://cdn.itbob.cn/img/article/053/39.png" alt="39"></p><p>这里会遇到六个数组，他们都已经有值了，所以我们得找到他们是咋来的，任意搜索其中一个数组名称，会找到定义和赋值的地方：</p><p><img src="https://cdn.itbob.cn/img/article/053/40.png" alt="40"></p><p><img src="https://cdn.itbob.cn/img/article/053/41.png" alt="41"></p><p>赋值明显是调用了 <code>_$rv</code> 方法，再搜 <code>_$rv</code> 方法，发现是开头就调用了：</p><p><img src="https://cdn.itbob.cn/img/article/053/42.png" alt="42"></p><p>后续没有什么特别的，一直单步，最后有个 <code>join('')</code> 操作，就生成了假 Cookie：</p><p><img src="https://cdn.itbob.cn/img/article/053/43.png" alt="43"></p><p>接下来是生成 Cookie 的名字 <code>FSSBBIl1UgzbN7N80T</code>，然后将 Cookie 赋值给 <code>document.cookie</code>，然后又向 <code>localStorage</code> 里面的 <code>$_ck</code> 赋了个值，<code>localStorage</code> 的内容可以直接复制下来，没有太大影响。</p><p><img src="https://cdn.itbob.cn/img/article/053/44.png" alt="44"></p><h3><span id="zhen-cookie-sheng-cheng-luo-ji">真 Cookie 生成逻辑</span></h3><p>单步跟真 Cookie，在本文中也就是 <code>_$ZN(768, 1);</code>，可以看到开始进入了无穷无尽的 <code>if-else</code> 控制流：</p><p><img src="https://cdn.itbob.cn/img/article/053/45.png" alt="45"></p><p>这里本地应该怎样处理呢？我的做法是以 <code>_$Hn</code> 和其值命名函数，<code>function _$Hn768()&#123;&#125;</code> 就表示所有走 768 号控制流的方法，继续跟，生成真 Cookie 的方法基本上在 747 号控制流，后续我们主要以 747 号控制流的各个步骤来看，747 号控制流扣出来的代码大致如下：</p><p><img src="https://cdn.itbob.cn/img/article/053/46.png" alt="46"></p><h4><span id="qu-jia-cookie">取假 Cookie</span></h4><p>单步跟 747 号控制流，会有个进入第 709 号控制流的步骤，会取先前生成的假 Cookie，经过一系列操作之后返回一个数组：</p><p><img src="https://cdn.itbob.cn/img/article/053/47.png" alt="47"></p><p><img src="https://cdn.itbob.cn/img/article/053/48.png" alt="48"></p><p>至此我们在本地同步扣的代码，如果正常的话，返回的数组也应该是一样的（后续的数据就不一样了，有一些时间戳之类的参数参与运算）：</p><p><img src="https://cdn.itbob.cn/img/article/053/49.png" alt="49"></p><h4><span id="zi-dong-hua-gong-ju-jian-ce">自动化工具检测</span></h4><p>继续跟 747 号控制流，会进入 268 号控制流，接着进入 154 号控制流，这里面会针对自动化工具做一些检测，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/053/50.png" alt="50"></p><p><img src="https://cdn.itbob.cn/img/article/053/51.png" alt="51"></p><p>这里定义了一个变量 <code>_$iL</code>，检测不通过就是1，后续又把这个变量赋值给了 <code>_$aW</code>，所以我们本地保持一致，也为 false 即可（其实我们不用自动化工具的话，这一段检测就不用管直接返回 false 就行）：</p><p><img src="https://cdn.itbob.cn/img/article/053/52.png" alt="52"></p><h4><span id="20-wei-he-xin-shu-zu">20 位核心数组</span></h4><p>继续跟 268 号控制流，会进入 668 号控制流，668 号控制流就两个操作，一是生成一个 16 位数组，二是取 <code>$_ts</code> 里面的 4 个变量，加到前面的 16 位后面，组成一个 20 位数组，这 20 位数组的最后 4 位是瑞数核心，其中的映射关系搞错了请求是通不过的，在五代中这部分的处理逻辑会更加复杂。</p><p><img src="https://cdn.itbob.cn/img/article/053/53.png" alt="53"></p><p><img src="https://cdn.itbob.cn/img/article/053/54.png" alt="54"></p><p>这里不是单纯的取 <code>$_ts</code> 里的键值对，你在扣代码的时候，你也许会发现怎么本地到这里取值的时候，取出来的不是数字，而是字符串呢？就像下面这种情况：</p><p><img src="https://cdn.itbob.cn/img/article/053/55.png" alt="55"></p><p>实际上我们最开始得到的 <code>$_ts</code> 值，是经过了二次处理的，我们以第一个 <code>_$sX._$Xb</code> 为例，直接搜索 <code>_$sX._$Xb</code>，可以发现这么一个地方：</p><p><img src="https://cdn.itbob.cn/img/article/053/56.png" alt="56"></p><p>很明显这里给  <code>_$sX._$Xb</code> 重新赋值了一遍，我们可以看到等号右边，先取了一次 <code>_$sX._$Xb</code>，其值为 <code>_$Rm</code>，这和我们初始 <code>$_ts</code> 里面对应的值是一样的，然后我们就得再看看 <code>_$sX[&quot;_$Rm&quot;]</code> 又是何方神圣，直接搜索发现是开头赋值了一个方法，通过调用这个方法来生成新的值：</p><p><img src="https://cdn.itbob.cn/img/article/053/57.png" alt="57"></p><p>另外其他三个值也是同样的套路，赋值的代码分别为：</p><pre><code class="hljs javascript">_$sX._$Xb = _$sX[_$sX._$Xb](_$BH, _$DP);_$sX._$oI = _$sX[_$sX._$oI](_$ZJ, _$DS)_$sX._$EN = _$sX[_$sX._$EN]();_$sX._$D9 = _$sX[_$sX._$D9](_$iL);</code></pre><p>实际上应该是：</p><pre><code class="hljs javascript">_$sX._$Xb = _$sX[<span class="hljs-string">&quot;_$Rm&quot;</span>](_$BH, _$DP);_$sX._$oI = _$sX[<span class="hljs-string">&quot;_$Nw&quot;</span>](_$ZJ, _$DS)_$sX._$EN = _$sX[<span class="hljs-string">&quot;_$Uh&quot;</span>]();_$sX._$D9 = _$sX[<span class="hljs-string">&quot;_$ci&quot;</span>](_$iL);</code></pre><p>进一步来说，实际上是：</p><pre><code class="hljs javascript">_$sX._$Xb = _$1k(_$BH, _$DP);_$sX._$oI = _$jH(_$ZJ, _$DS)_$sX._$EN = _$9M();_$sX._$D9 = _$oL(_$iL);</code></pre><p>静态分析没问题，我们可以先固定下来，但是实际应用当中这些值都是动态的，那我们应该怎么处理呢？先来多看几个对比一下找找规律：</p><p><img src="https://cdn.itbob.cn/img/article/053/58.png" alt="58"></p><p><img src="https://cdn.itbob.cn/img/article/053/59.png" alt="59"></p><p>可以发现每次对应的位次都不一样，但是实际上相同位置的方法点进去都是一样的，也就是说，变的只有方法名和变量名，实现的逻辑是不变的，所以我们只要知道了这四个值分别对应的位置，就能够拿到正确的值，在本地，我们就可以这样做：</p><p>1、先利用正则匹配出这四个值，如：<code>[_$sX._$Xb, _$sX._$oI, _$sX._$EN, _$sX._$D9]</code>；</p><p><img src="https://cdn.itbob.cn/img/article/053/60.png" alt="60"></p><p>2、再匹配出 VM 代码开头的 20 个赋值的语句，如：<code>_$sX._$RH = _$wI; _$sX._$i5 = _$n5;</code> 等；</p><p><img src="https://cdn.itbob.cn/img/article/053/61.png" alt="61"></p><p>3、然后通过 <code>$_ts</code> 取这四个值对应的值，相当于：<code>_$sX._$Xb = _$ts._$Xb = _$Rm</code>；然后再找这四个值所定义的方法在 20 个赋值语句中的位置，相当于：查找 <code>_$sX._$Rm = _$1k; </code> 在 20 个赋值语句中的位置为 7（索引从 0 开始）</p><p><img src="https://cdn.itbob.cn/img/article/053/62.png" alt="62"></p><p>4、我们知道了这四个方法在 20 个赋值语句中的位置，那么我们直接匹配本地对应位置的名称，进行动态替换即可，当然前提是咱们本地已经扣了一套代码出来了：</p><p><img src="https://cdn.itbob.cn/img/article/053/63.png" alt="63"></p><p><img src="https://cdn.itbob.cn/img/article/053/64.png" alt="64"></p><p>经过这样处理后，就能够保证这四个值的准确性了。</p><h4><span id="qi-ta-yong-dao-ts-zhi-de-di-fang">其他用到 $_ts 值的地方</span></h4><p>除了上面说的 20 位数组里用到了 4 个 <code>$_ts</code> 的值以外，还有其他地方有 7 个值也用到了，直接搜索就能定位，这 7 个值相对较简单，每次都是固定取 <code>$_ts</code> 里面的第 2、3、4、15、16、17、19 位的值，同样的，找到对应位置，进行动态替换即可：</p><p><img src="https://cdn.itbob.cn/img/article/053/65.png" alt="65"></p><h3><span id="zhu-yi-shi-xiang">注意事项</span></h3><p>特别注意 VM 代码开头，会直接调用执行一些方法，某些变量的值就是通过这些方法生成的，当你一步一步跟的时候发现某些参数不对，或者没有，那么就得注意开头这些方法了，可能一开始就已经生成了。</p><p><img src="https://cdn.itbob.cn/img/article/053/66.png" alt="66"></p><h3><span id="hou-zhui-mmewmd-sheng-cheng-luo-ji">后缀 MmEwMD 生成逻辑</span></h3><p>后续的其他 XHR 请求中，都带有一个后缀，这个后缀的值同样是由 JS 生成的，每次都会变化，当然不同网站，后缀名不一定都是一样的，本例中是 <code>MmEwMD</code>，先下一个 XHR 断点，当 XHR 请求中包含了 <code>MmEwMD=</code> 时就断下，然后刷新网页：</p><p><img src="https://cdn.itbob.cn/img/article/053/67.png" alt="67"></p><p>可以看到后传入 <code>l.open()</code> 的 URL 还是正常的，断下后到 <code>l.send()</code> 就带有后缀了，再看 <code>l.open()</code> 其实就是 <code>xhr.open()</code>，明显和正常的有区别，同样这个方法也在 VM 代码里，应该是重写了方法，可以和正常的做对比：</p><p><img src="https://cdn.itbob.cn/img/article/053/68.png" alt="68"></p><p>跟到 VM 代码里去看看，经过了 <code>_$sd(arguments[1])</code> 方法就变成了带有后缀的完整链接了：</p><p><img src="https://cdn.itbob.cn/img/article/053/69.png" alt="69"></p><p>跟进 <code>_$sd</code> 方法，前面都是对 url 做一些处理，后面有个进入第 779 号控制流的流程，实际上就是原来我们生成 Cookie 的步骤，跟一下就行了。</p><p><img src="https://cdn.itbob.cn/img/article/053/70.png" alt="70"></p><h2><span id="shan-yong-watch-gen-zong-gong-neng">善用 Watch 跟踪功能</span></h2><p><img src="https://cdn.itbob.cn/img/article/053/71.png" alt="71"></p><p>开发者工具的 Watch 功能能够持续跟踪某个变量的值，对于这种控制流很多的情况，设置相应的变量跟踪，能够让你知道你现在处于哪个控制流中，以及生成的数组的变化，不至于跟着跟着不知道到哪一步了。</p><h2><span id="jie-guo-yan-zheng">结果验证</span></h2><p>如果整个流程没问题，代码也扣得正确，携带正确的 Cookie 和正确的后缀，就能成功访问：</p><p><img src="https://cdn.itbob.cn/img/article/053/72.png" alt="72"></p><p><img src="https://cdn.itbob.cn/img/article/053/73.png" alt="73"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/javascript_reverse.png&quot; alt=&quot;javascript_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>AST 脱混淆实战，某 ICP 备案号查询接口 jsjiami v6 分析</title>
    <link href="https://www.itbob.cn/article/052/"/>
    <id>https://www.itbob.cn/article/052/</id>
    <published>2022-05-25T06:01:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/ast.png" alt="ast"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#di-san-fang-gong-ju">第三方工具</a></li><li><a href="#zhua-bao-fen-xi">抓包分析</a></li><li><a href="#jia-mi-ding-wei">加密定位</a></li><li><a href="#ast-tuo-hun-yao">AST 脱混淆</a><ul><li><a href="#wen-jian-jie-gou">文件结构</a></li><li><a href="#jie-mi-han-shu-huan-yuan">解密函数还原</a></li><li><a href="#da-dui-xiang-huan-yuan">大对象还原</a><ul><li><a href="#zi-fu-chuan-huan-yuan">字符串还原</a></li><li><a href="#er-xiang-shi-ji-suan-ti-huan">二项式计算替换</a></li><li><a href="#fang-fa-diao-yong-huan-yuan">方法调用还原</a></li></ul></li><li><a href="#switch-case-fan-kong-zhi-liu-ping-tan-hua">switch-case 反控制流平坦化</a></li><li><a href="#qi-ta-xi-jie-huan-yuan">其他细节还原</a></li></ul></li><li><a href="#wan-zheng-dai-ma">完整代码</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：站 Z 之家网站 ICP 备案号查询</li><li>主页：<code>aHR0cDovL2ljcC5jaGluYXouY29tLw==</code></li><li>接口：<code>aHR0cDovL2ljcC5jaGluYXouY29tL2hvbWUvR2V0UGVyaW1pdEJ5SG9zdA==</code></li><li>逆向参数：<code>hostToken</code>、<code>permitToken</code></li></ul><p>本次主要是 AST 解混淆实战，本例中的 JS 混淆方式是 sojson 旗下的 jsjiami v6 版本，感兴趣的可以去官网体验一下：<a href="https://www.jsjiami.com/">https://www.jsjiami.com/</a> ，如果你还不了解 AST，可以先看看上期的文章（非常详细）：<a href="https://www.itbob.cn/article/051/">《逆向进阶，利用 AST 技术还原 JavaScript 混淆代码》</a>，本文部分 AST 还原代码直接使用了上期文章中的代码，所以细节方面不再赘述，有疑问的地方可以参考参考上期文章。</p><h2><span id="di-san-fang-gong-ju">第三方工具</span></h2><p>逆向领域大佬云集，市面上已经有很多大佬写好的解混淆工具了，除了我们自己手动去写 AST 解析代码以外，有时候直接使用工具会更加方便，当然并没有十全十美的工具，不过大部分情况下都能成功解混淆的，以下工具值得去体验一下：</p><ul><li>蔡老板一键还原 OB 混淆：<a href="https://github.com/Tsaiboss/decodeObfuscator">https://github.com/Tsaiboss/decodeObfuscator</a></li><li>哲哥 AST 混淆还原框架：<a href="https://github.com/sml2h3/ast_tools">https://github.com/sml2h3/ast_tools</a></li><li>V 神 Chrome 插件，内置 AST 混淆还原：<a href="https://github.com/cilame/v_jstools">https://github.com/cilame/v_jstools</a></li><li>jsjiami v6 专用解密工具：<a href="https://github.com/NXY666/JsjiamiV6-Decryptor">https://github.com/NXY666/JsjiamiV6-Decryptor</a></li></ul><h2><span id="zhua-bao-fen-xi">抓包分析</span></h2><p>进入主题，首先抓包看看，来到 ICP 备案查询页面，查询结果中，其他信息都可以直接在相应的 html 源码中找到，只有这个备案号是通过接口传过来的，对应的请求和相关加密参数如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/052/01.png" alt="01"></p><p><img src="https://cdn.itbob.cn/img/article/052/02.png" alt="02"></p><h2><span id="jia-mi-ding-wei">加密定位</span></h2><p>直接搜索关键字 <code>hostToken</code> 或者 <code>permitToken</code> 即可定位：</p><p><img src="https://cdn.itbob.cn/img/article/052/03.png" alt="03"></p><p><img src="https://cdn.itbob.cn/img/article/052/04.png" alt="04"></p><p>关键代码：</p><pre><code class="hljs javascript"><span class="hljs-string">&#x27;data&#x27;</span>: &#123;    <span class="hljs-string">&#x27;kw&#x27;</span>: kw,    <span class="hljs-string">&#x27;hostToken&#x27;</span>: _0x791532[<span class="hljs-string">&#x27;IIPmq&#x27;</span>](generateHostKey, kw),    <span class="hljs-string">&#x27;permitToken&#x27;</span>: _0x791532[_0x404f(<span class="hljs-string">&#x27;‫1df&#x27;</span>, <span class="hljs-string">&#x27;7Gn4&#x27;</span>)](generateWordKey, kw)&#125;</code></pre><p>这里的混淆可以手动跟一下，还原后如下：</p><pre><code class="hljs javascript"><span class="hljs-string">&#x27;data&#x27;</span>: &#123;    <span class="hljs-string">&#x27;kw&#x27;</span>: kw,    <span class="hljs-string">&#x27;hostToken&#x27;</span>: generateHostKey(kw),    <span class="hljs-string">&#x27;permitToken&#x27;</span>: generateWordKey(kw)&#125;</code></pre><p><code>kw</code> 是查询的域名，有用的就是 <code>generateHostKey()</code> 和 <code>generateWordKey()</code> 两个方法了，跟进去看，代码经过了 jsjiami v6 混淆：</p><p><img src="https://cdn.itbob.cn/img/article/052/05.png" alt="05"></p><p><img src="https://cdn.itbob.cn/img/article/052/06.png" alt="06"></p><p><img src="https://cdn.itbob.cn/img/article/052/07.png" alt="07"></p><h2><span id="ast-tuo-hun-yao">AST 脱混淆</span></h2><p>jsjiami 混淆的特征其实和 OB 混淆是类似的：</p><ol><li>一般由一个大数组或者含有大数组的函数、一个数组位移操作的自执行函数、一个解密函数和加密后的函数四部分组成；</li><li>函数名和变量名通常以 _0x 或者 0x 开头，后接 1~6 位数字或字母组合；</li><li>数组位移操作的自执行函数里，有明显的 push、shift 关键字。</li></ol><p>本例中，<code>generateHostKey()</code> 方法在 <code>commo.js</code> 里，<code>generateWordKey()</code> 方法在 <code>generatetoken.js</code> 里，结构如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/052/08.png" alt="08"></p><p>观察 <code>generatetoken.js</code> 文件，可以发现这里面也有 <code>commo.js</code> 里面的 <code>generateHostKey()</code> 和 <code>getRandom()</code> 方法，从方法名来看貌似是重复了，实际上混淆还原后方法是一样的，所以这里我们只需要还原 <code>generatetoken.js</code> 就可以了。</p><h3><span id="wen-jian-jie-gou">文件结构</span></h3><ul><li>混淆 JS 文件：<code>generatetoken.js</code></li><li>AST 还原代码：<code>generatetokenAst.js</code></li><li>还原后的代码：<code>generatetokenNew.js</code></li></ul><h3><span id="jie-mi-han-shu-huan-yuan">解密函数还原</span></h3><p>在原来混淆后的 JS 里，解密函数是 <code>_0x530e</code>，首先观察整个 JS，调用了很多次解密函数，类似于：<code>_0x530e('1', '7XEq')</code>。</p><p>注意这里代码里面有一些特殊字符，类似于 <code>RLE</code>、<code>RLO</code> 之类的，如果在 VSCode 打开是一些 <code>U+202B</code>、<code>U+202E</code> 的字符，实际上这是 RTLO (Right-to-Left Override) 字符，<code>U+202B</code> 和 <code>U+202E</code> 的意思分别是根据内存顺序从左至右和从右至左显示字符，感兴趣的可以网上搜索了解一下。这里并不影响我们进行还原操作。但是如果直接复制过来的话就会导致前后文显示的顺序不对，所以本文中为了方便描述，粘贴的部分代码就手动去掉了这些字符。</p><p><img src="https://cdn.itbob.cn/img/article/052/09.png" alt="09"></p><p><img src="https://cdn.itbob.cn/img/article/052/10.png" alt="10"></p><p>所以第一步我们要还原一下解密函数，把所有 <code>_0x530e</code> 调用的地方直接替换成实际值，首先需要将大数组、自执行函数、加密函数和解密函数分割开，将代码放到 <a href="http://astexplorer.net">astexplorer.net</a> 看一下，也就是将 body 的前四部分和后面剩余部分分割开来，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/052/11.png" alt="11"></p><p>分割代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<span class="hljs-keyword">const</span> parse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>).parse;<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)<span class="hljs-comment">// 导入混淆代码并解析为 AST</span><span class="hljs-keyword">const</span> oldCode = fs.readFileSync(<span class="hljs-string">&quot;generatetoken.js&quot;</span>, &#123;<span class="hljs-attr">encoding</span>: <span class="hljs-string">&quot;utf-8&quot;</span>&#125;);<span class="hljs-keyword">const</span> astCode = parse(oldCode);<span class="hljs-comment">// 获取整个 AST 节点的长度</span><span class="hljs-keyword">let</span> astCodeLength = astCode.program.body.length<span class="hljs-comment">// 获取解密函数的名字 也就是 _0x530e</span><span class="hljs-keyword">let</span> decryptFunctionName = astCode.program.body[<span class="hljs-number">3</span>].id.name<span class="hljs-comment">// 分割加密函数和解密函数，即 body 的前四部分和后面剩余部分</span><span class="hljs-keyword">let</span> decryptFunction = astCode.program.body.slice(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>)<span class="hljs-keyword">let</span> encryptFunction = astCode.program.body.slice(<span class="hljs-number">4</span>, astCodeLength)<span class="hljs-comment">// 获取加密函数和解密函数的方法多种多样，比如可以挨个取值并转换成 JS 代码</span><span class="hljs-comment">// 这样做就不需要将解密函数赋值给整个 AST 节点了</span><span class="hljs-comment">// let decryptFunction = &quot;&quot;;</span><span class="hljs-comment">// for(let i=0; i&lt;4; i++)&#123;</span><span class="hljs-comment">//     decryptFunction += generate(astCode.program.body[i], &#123;compact: true&#125;).code</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// eval(decryptFunction);</span></code></pre><p>在上面的获取加密函数和解密函数的代码中，方法不是唯一的，多种多样，比如直接循环取 body 并转换成 JS 代码，比如直接人工把大数组、自执行函数和解密函数三部分，拿出来放到一个新文件里，然后导出解密方法，后续直接调用也可以。</p><p>在本例中，拿到解密函数后，需要将其赋值给整个 AST 节点，然后再将整个 AST 节点转换成 JavaScript 代码，这里注意有可能会检测代码是否格式化，所以建议转换要加一个 <code>compact</code> 参数，避免格式化，转换完成后 <code>eval</code> 执行一下，让数组位移操作完成，然后我们就可以直接调用解密函数，即 <code>_0x530e()</code>。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 将解密函数赋值给整个 AST 节点</span>astCode.program.body = decryptFunction<span class="hljs-comment">// 将 AST 节点转换成 JS 代码，并 eval 执行一下</span>decryptFunction = generate(astCode, &#123;<span class="hljs-attr">compact</span>: <span class="hljs-literal">true</span>&#125;).code<span class="hljs-built_in">eval</span>(decryptFunction);<span class="hljs-comment">// 测试一下，直接调用 _0x530e 函数可以正确拿到结果</span><span class="hljs-comment">// 输出 split</span><span class="hljs-comment">// console.log(_0x530e(&#x27;‮b&#x27;, &#x27;Zp9G&#x27;))</span></code></pre><p>现在我们能直接调用解密函数 <code>_0x530e()</code> 了，接下来要做的就是怎么把混淆代码中所有调用 <code>_0x530e()</code> 的地方替换成真实值，在此之前，我们要把加密函数（<code>generateKey()</code>、<code>generateHostKey()</code>、<code>generateWordKey()</code> 和 <code>getRandom()</code>）赋值给整个 AST 节点，此时整个节点就没有大数组、自执行函数和解密函数了，解密函数 <code>_0x530e()</code> 已经被写入内存，所以后面不影响我们调用。</p><p>老样子，还是先在 <a href="http://astexplorer.net">astexplorer.net</a> 看一下调用 <code>_0x530e()</code> 的地方，以 <code>_0x530e('b', 'Zp9G')</code> 为例，其真实值应该是 <code>split</code>，对比一下替换前后的结构，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/052/12.png" alt="12"></p><p><img src="https://cdn.itbob.cn/img/article/052/13.png" alt="13"></p><p>可以看到节点由原来的 <code>CallExpression</code> 变成了 <code>StringLiteral</code>，所以我们可以遍历 <code>CallExpression</code>，如果函数名为解密函数名，那就通过 <code>path.toString()</code> 方法获取节点源码，也就类似 <code>_0x530e('b', 'Zp9G')</code> 的源码，然后 <code>eval</code> 执行一下获取其真实值，再使用 <code>types.stringLiteral()</code> 构建 <code>StringLiteral</code> 节点，最后通过 <code>path.replaceInline()</code> 方法替换节点，遍历代码如下：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 将加密函数赋值给整个 AST 节点，此时整个节点就没有大数组、自执行函数和解密函数了</span>astCode.program.body = encryptFunction<span class="hljs-comment">// 调用解密函数，直接计算出类似以下方法的值并替换</span><span class="hljs-comment">// 混淆代码：_0x530e(&#x27;‮b&#x27;, &#x27;Zp9G&#x27;)</span><span class="hljs-comment">// 还原后：split</span><span class="hljs-keyword">const</span> visitor1 = &#123;    <span class="hljs-function"><span class="hljs-title">CallExpression</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">if</span> (path.node.callee.name === decryptFunctionName &amp;&amp; path.node.arguments.length === <span class="hljs-number">2</span>)&#123;            path.replaceInline(types.stringLiteral(<span class="hljs-built_in">eval</span>(path.toString())))        &#125;    &#125;&#125;<span class="hljs-comment">// 遍历节点</span>traverse(astCode, visitor1)<span class="hljs-comment">// 将 AST 节点转换成 JS 代码并写入到新文件里</span><span class="hljs-keyword">const</span> result = generate(astCode, &#123;<span class="hljs-attr">concise</span>:<span class="hljs-literal">true</span>&#125;).codefs.writeFile(<span class="hljs-string">&quot;./generatetokenNew.js&quot;</span>, result, (<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(err)&#125;))</code></pre><p>自此，第一步的解密函数还原就完成了，可以看一下还原前后的对比，如下图所示浅蓝色标记的地方，所有调用 <code>_0x530e()</code> 的地方都被还原了：</p><p><img src="https://cdn.itbob.cn/img/article/052/14.png" alt="14"></p><h3><span id="da-dui-xiang-huan-yuan">大对象还原</span></h3><p>初步还原后我们的代码里就只剩下以下四个方法：</p><ul><li><code>generateKey()</code></li><li><code>generateHostKey()</code></li><li><code>generateWordKey()</code></li><li><code>getRandom()</code></li></ul><p>再观察代码，发现每个方法一开始都有个大的对象，他们分别是：</p><ul><li><code>_0x3b79c6</code></li><li><code>_0x278b2d</code></li><li><code>_0x4115c4</code></li><li><code>_0xd8ec33</code></li></ul><p>后续的代码也在不断调用这个对象的方法，比如 <code>_0x3b79c6[&quot;esdtg&quot;](_0x2e5848[&quot;length&quot;], 0x4)</code> 实际上就是 <code>_0x2e5848[&quot;length&quot;] != 0x4</code>，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/052/15.png" alt="15"></p><p>首先我们将这四个大的对象单独提取出来，还是保持原来的键值对样式，提取完成后删除这两个节点，遍历代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> functionName = &#123;    <span class="hljs-string">&quot;_0x3b79c6&quot;</span>: &#123;&#125;,    <span class="hljs-string">&quot;_0x278b2d&quot;</span>: &#123;&#125;,    <span class="hljs-string">&quot;_0x4115c4&quot;</span>: &#123;&#125;,    <span class="hljs-string">&quot;_0xd8ec33&quot;</span>: &#123;&#125;&#125;<span class="hljs-comment">// 单独提取出四个大对象</span><span class="hljs-keyword">const</span> visitor2 = &#123;    <span class="hljs-function"><span class="hljs-title">VariableDeclarator</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> functionName)&#123;            <span class="hljs-keyword">if</span> (path.node &amp;&amp; path.node.id.name == key) &#123;                <span class="hljs-keyword">const</span> properties = path.node.init.properties                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;properties.length; i++)&#123;                    functionName[key][properties[i].key.value] = properties[i].value                &#125;                <span class="hljs-comment">// 写入对象后就可以删除该节点了</span>                path.remove()            &#125;        &#125;    &#125;&#125;</code></pre><p>这里要注意，大的对象里面，有 <code>+</code>、<code>-</code>、<code>==</code> 之类的二项式计算，也有直接为字符串的，还有变成函数调用的，如下所示：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> _0x3b79c6 = &#123;    <span class="hljs-string">&#x27;MuRlB&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_0x3ca134, _0x50ee94</span>) </span>&#123;        <span class="hljs-keyword">return</span> _0x3ca134 + _0x50ee94;    &#125;,     <span class="hljs-string">&#x27;Ucwyj&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_0x32bfa3, _0x3b191b</span>) </span>&#123;        <span class="hljs-keyword">return</span> _0x32bfa3(_0x3b191b);    &#125;,     <span class="hljs-string">&#x27;YrYQW&#x27;</span>: <span class="hljs-string">&#x27;#IpValue&#x27;</span>&#125;</code></pre><p>针对不同的情况有不同的处理方法，同时还要注意传参和 return 返回的参数位置，不要还原后把 <code>a - b</code> 搞成 <code>b - a</code> 了，当然在本例中传入和返回的顺序是一样的，就不需要考虑这个问题。</p><h4><span id="zi-fu-chuan-huan-yuan">字符串还原</span></h4><p>首先来看字符串，有以下几种情况：</p><ul><li>以 <code>_0x3b79c6['YrYQW']</code> 为例，实际上其值为字符串 <code>'#IpValue'</code>，观察其结构，是一个 <code>MemberExpression</code>，在一个列表里；</li><li>以 <code>_0x278b2d['pjbyX']</code> 为例，实际上其值为字符串 <code>'3|2|1|4|5|0|6'</code>，观察其结构，是一个 <code>MemberExpression</code>，在一个字典里；</li><li>以 <code>_0x278b2d['CnTaO']</code> 为例，虽然也是一个 <code>MemberExpression</code>，也在一个字典里。但实际上是二项式计算，所以要排除在外。</li></ul><p><img src="https://cdn.itbob.cn/img/article/052/16.png" alt="16"></p><p><img src="https://cdn.itbob.cn/img/article/052/17.png" alt="17"></p><p><img src="https://cdn.itbob.cn/img/article/052/18.png" alt="18"></p><p>所以我们在写遍历代码时，同时要注意这三种情况，满足条件后直接取原来大对象对应的节点进行替换即可，遍历代码如下所示：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 函数替换，字符串替换：将类似 _0x3b79c6[&#x27;YrYQW&#x27;] 变成 &#x27;#IpValue&#x27;</span><span class="hljs-keyword">const</span> visitor3 = &#123;    <span class="hljs-function"><span class="hljs-title">MemberExpression</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> functionName)&#123;            <span class="hljs-keyword">if</span> (path.node.object &amp;&amp; path.node.object.name == key &amp;&amp; path.inList ) &#123;                path.replaceInline(functionName[key][path.node.property.value])            &#125;            <span class="hljs-keyword">if</span> (path.node.object &amp;&amp; path.node.object.name == key &amp;&amp; path.parent.property &amp;&amp; path.parent.property.value == <span class="hljs-string">&quot;split&quot;</span>) &#123;                path.replaceInline(functionName[key][path.node.property.value])            &#125;        &#125;    &#125;&#125;</code></pre><h4><span id="er-xiang-shi-ji-suan-ti-huan">二项式计算替换</span></h4><p>再来看看二项式计算的情况，以 <code>_0x278b2d['CnTaO'](_0x691267[&quot;length&quot;], 0x1)</code> 为例，实际上是做减法运算，即 <code>_0x691267[&quot;length&quot;] - 0x1</code>，看一下替换前后对比：</p><p><img src="https://cdn.itbob.cn/img/article/052/19.png" alt="19"></p><p><img src="https://cdn.itbob.cn/img/article/052/20.png" alt="20"></p><p>对于这种情况，我们可以直接提取两个参数，然后提取大对象里对应方法的操作符，然后将参数和操作符直接连接起来组成新的节点（<code>binaryExpression</code>）并替换即可，遍历代码如下：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 函数替换，二项式计算：将类似 _0x278b2d[&#x27;CnTaO&#x27;](_0x691267[&quot;length&quot;], 0x1) 变成 _0x691267[&quot;length&quot;] - 0x1</span><span class="hljs-keyword">const</span> visitor4 = &#123;    <span class="hljs-function"><span class="hljs-title">CallExpression</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> functionName) &#123;            <span class="hljs-keyword">if</span> (path.node.callee &amp;&amp; path.node.callee.object &amp;&amp; path.node.callee.object.name == key) &#123;                <span class="hljs-keyword">let</span> func = functionName[key][path.node.callee.property.value]                <span class="hljs-keyword">if</span> (func.body.body[<span class="hljs-number">0</span>].argument.type == <span class="hljs-string">&quot;BinaryExpression&quot;</span>) &#123;                    <span class="hljs-keyword">let</span> operator = func.body.body[<span class="hljs-number">0</span>].argument.operator                    <span class="hljs-keyword">let</span> left = path.node.arguments[<span class="hljs-number">0</span>]                    <span class="hljs-keyword">let</span> right = path.node.arguments[<span class="hljs-number">1</span>]                    path.replaceInline(types.binaryExpression(operator, left, right))                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h4><span id="fang-fa-diao-yong-huan-yuan">方法调用还原</span></h4><p>以 <code>_0x4115c4[&quot;PJbSm&quot;](getRandom, 0x64, 0x3e7)</code> 为例，实际上是 <code>getRandom(0x64, 0x3e7)</code>，看一下替换前后对比：</p><p><img src="https://cdn.itbob.cn/img/article/052/21.png" alt="21"></p><p><img src="https://cdn.itbob.cn/img/article/052/22.png" alt="22"></p><p>对于这种情况，传入的第一个参数为方法名称，后面的都是参数，那么可以直接取第一个元素为方法名称，使用 <code>slice(1)</code> 方法取后面所有的参数（因为后面的参数个数是不一定的），然后构造新的节点（<code>callExpression</code>）并替换即可，这部分遍历代码可以和前面二项式的替换相结合，代码如下：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 函数替换，二项式计算：将类似 _0x278b2d[&#x27;CnTaO&#x27;](_0x691267[&quot;length&quot;], 0x1) 变成 _0x691267[&quot;length&quot;] - 0x1</span><span class="hljs-comment">// 函数替换，方法调用：将类似 _0x4115c4[&quot;PJbSm&quot;](getRandom, 0x64, 0x3e7) 变成 getRandom(0x64, 0x3e7)</span><span class="hljs-keyword">const</span> visitor4 = &#123;    <span class="hljs-function"><span class="hljs-title">CallExpression</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> functionName) &#123;            <span class="hljs-keyword">if</span> (path.node.callee &amp;&amp; path.node.callee.object &amp;&amp; path.node.callee.object.name == key) &#123;                <span class="hljs-keyword">let</span> func = functionName[key][path.node.callee.property.value]                <span class="hljs-keyword">if</span> (func.body.body[<span class="hljs-number">0</span>].argument.type == <span class="hljs-string">&quot;BinaryExpression&quot;</span>) &#123;                    <span class="hljs-keyword">let</span> operator = func.body.body[<span class="hljs-number">0</span>].argument.operator                    <span class="hljs-keyword">let</span> left = path.node.arguments[<span class="hljs-number">0</span>]                    <span class="hljs-keyword">let</span> right = path.node.arguments[<span class="hljs-number">1</span>]                    path.replaceInline(types.binaryExpression(operator, left, right))                &#125;                <span class="hljs-keyword">if</span> (func.body.body[<span class="hljs-number">0</span>].argument.type == <span class="hljs-string">&quot;CallExpression&quot;</span>) &#123;                    <span class="hljs-keyword">let</span> identifier = path.node.arguments[<span class="hljs-number">0</span>]                    <span class="hljs-keyword">let</span> <span class="hljs-built_in">arguments</span> = path.node.arguments.slice(<span class="hljs-number">1</span>)                    path.replaceInline(types.callExpression(identifier, <span class="hljs-built_in">arguments</span>))                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>自此，第二步的大对象还原就完成了，可以看一下还原前后的对比，如下图所示浅蓝色标记的地方，所有调用四个大对象（<code>_0x3b79c6</code>、<code>_0x278b2d</code>、<code>_0x4115c4</code>、<code>_0xd8ec33</code>）的地方都被还原了：</p><p><img src="https://cdn.itbob.cn/img/article/052/23.png" alt="23"></p><h3><span id="switch-case-fan-kong-zhi-liu-ping-tan-hua">switch-case 反控制流平坦化</span></h3><p>经过前面几步的还原之后，我们发现 <code>generateHostKey()</code>、<code>generateWordKey()</code>、<code>getRandom()</code> 方法里都有一个 <code>switch-case</code> 的控制流，关于反控制流平坦化的讲解在我上期文章有很详细的介绍，不理解的可以看看上期文章，此处也不再赘述了，直接贴代码了：</p><pre><code class="hljs javascript"><span class="hljs-comment">// switch-case 反控制流平坦化</span><span class="hljs-keyword">const</span> visitor5 = &#123;    <span class="hljs-function"><span class="hljs-title">WhileStatement</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-comment">// switch 节点</span>        <span class="hljs-keyword">let</span> switchNode = path.node.body.body[<span class="hljs-number">0</span>];        <span class="hljs-comment">// switch 语句内的控制流数组名，本例中是 _0x28073a、_0x2efb35、_0x187fb8</span>        <span class="hljs-keyword">let</span> arrayName = switchNode.discriminant.object.name;        <span class="hljs-comment">// 获取控制流数组绑定的节点</span>        <span class="hljs-keyword">let</span> bindingArray = path.scope.getBinding(arrayName);        <span class="hljs-comment">// 获取节点整个表达式的参数、分割方法、分隔符</span>        <span class="hljs-keyword">let</span> init = bindingArray.path.node.init;        <span class="hljs-keyword">let</span> object = init.callee.object.value;        <span class="hljs-keyword">let</span> property = init.callee.property.value;        <span class="hljs-keyword">let</span> argument = init.arguments[<span class="hljs-number">0</span>].value;        <span class="hljs-comment">// 模拟执行 &#x27;3|2|1|4|5|0|6&#x27;[&#x27;split&#x27;](&#x27;|&#x27;) 语句</span>        <span class="hljs-keyword">let</span> array = object[property](argument)        <span class="hljs-comment">// 也可以直接取参数进行分割，方法不通用，比如分隔符换成 , 就不行了</span>        <span class="hljs-comment">// let array = init.callee.object.value.split(&#x27;|&#x27;);</span>        <span class="hljs-comment">// switch 语句内的控制流自增变量名，本例中是 _0x38c69e、_0x396880、_0x3b3dc7</span>        <span class="hljs-keyword">let</span> autoIncrementName = switchNode.discriminant.property.argument.name;        <span class="hljs-comment">// 获取控制流自增变量名绑定的节点</span>        <span class="hljs-keyword">let</span> bindingAutoIncrement = path.scope.getBinding(autoIncrementName);        <span class="hljs-comment">// 可选择的操作：删除控制流数组绑定的节点、自增变量名绑定的节点</span>        bindingArray.path.remove();        bindingAutoIncrement.path.remove();        <span class="hljs-comment">// 储存正确顺序的控制流语句</span>        <span class="hljs-keyword">let</span> replace = [];        <span class="hljs-comment">// 遍历控制流数组，按正确顺序取 case 内容</span>        array.forEach(<span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;                <span class="hljs-keyword">let</span> consequent = switchNode.cases[index].consequent;                <span class="hljs-comment">// 如果最后一个节点是 continue 语句，则删除 ContinueStatement 节点</span>                <span class="hljs-keyword">if</span> (types.isContinueStatement(consequent[consequent.length - <span class="hljs-number">1</span>])) &#123;                    consequent.pop();                &#125;                <span class="hljs-comment">// concat 方法拼接多个数组，即正确顺序的 case 内容</span>                replace = replace.concat(consequent);            &#125;        );        <span class="hljs-comment">// 替换整个 while 节点，两种方法都可以</span>        path.replaceWithMultiple(replace);        <span class="hljs-comment">// path.replaceInline(replace);</span>    &#125;&#125;</code></pre><h3><span id="qi-ta-xi-jie-huan-yuan">其他细节还原</span></h3><p>到这里其实大部分混淆都已经还原了，已经很容易分析其逻辑了，还剩下一些细节，我们也还原一下，主要有以下细节：</p><ul><li>十六进制、Unicode 编码等，转正常字符；</li><li>对象属性还原，比如 <code>_0x3cbc20['length']</code> 转换成 <code>_0x3cbc20.length</code>；</li><li>表达式还原，比如 <code>!![]</code> 直接计算成 true；</li><li>删除未引用的变量，比如 <code>_0xodD= &quot;jsjiami.com.v6&quot;;</code>；</li><li>删除冗余逻辑代码，只保留 if 为 true 的。</li></ul><p>这些还原代码在我上期文章有详细讲过，结合代码，在 <a href="http://astexplorer.net">astexplorer.net</a> 对照其结构看，也能理解，同样也不赘述了，直接贴代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor5 = &#123;    <span class="hljs-comment">// 十六进制、Unicode 编码等，转正常字符</span>    <span class="hljs-string">&quot;StringLiteral|NumericLiteral&quot;</span>(path)&#123;        <span class="hljs-keyword">delete</span> path.node.extra;    &#125;,    <span class="hljs-comment">// _0x3cbc20[&quot;length&quot;] 转换成 _0x3cbc20.length</span>    <span class="hljs-function"><span class="hljs-title">MemberExpression</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">if</span> (path.node.property.type == <span class="hljs-string">&quot;StringLiteral&quot;</span>) &#123;            path.node.computed = <span class="hljs-literal">false</span>            path.node.property = types.identifier(path.node.property.value)        &#125;    &#125;,    <span class="hljs-comment">// 表达式还原，!![] 直接计算成 true</span>    <span class="hljs-string">&quot;BinaryExpression|UnaryExpression&quot;</span>(path) &#123;        <span class="hljs-keyword">let</span> &#123;confident, value&#125; = path.evaluate()        <span class="hljs-keyword">if</span> (confident)&#123;            path.replaceInline(types.valueToNode(value))        &#125;    &#125;,    <span class="hljs-comment">// 删除未引用的变量，比如 _0xodD = &quot;jsjiami.com.v6&quot;;</span>    <span class="hljs-function"><span class="hljs-title">AssignmentExpression</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">let</span> binding = path.scope.getBinding(path.node.left.name);        <span class="hljs-keyword">if</span> (!binding) &#123;            path.remove();        &#125;    &#125;&#125;<span class="hljs-comment">// 删除冗余逻辑代码，只保留 if 为 true 的</span><span class="hljs-keyword">const</span> visitor6 = &#123;    <span class="hljs-function"><span class="hljs-title">IfStatement</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">if</span>(path.node.test.type == <span class="hljs-string">&quot;BooleanLiteral&quot;</span>) &#123;            <span class="hljs-keyword">if</span>(path.node.test.value) &#123;                path.replaceInline(path.node.consequent.body)            &#125; <span class="hljs-keyword">else</span> &#123;                path.replaceInline(path.node.alternate.body)            &#125;        &#125;    &#125;&#125;</code></pre><p>自此 jajiami v6 混淆就还原完毕了，还原前后对比一下，代码量缩短了很多，逻辑也更加清楚了，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/052/24.png" alt="24"></p><p>最后结合 Python 代码，携带生成的 <code>hostToken</code> 和 <code>permitToken</code>，成功拿到备案号：</p><p><img src="https://cdn.itbob.cn/img/article/052/25.png" alt="25"></p><h2><span id="wan-zheng-dai-ma">完整代码</span></h2><p>原混淆代码 <code>generatetoken.js</code>、AST 脱混淆代码 <code>generatetokenAst.js</code>、还原后的代码 <code>generatetokenNew.js</code>，以及 Python 测试代码均在 GitHub，均有详细注释，欢迎 Star。所有内容仅供学习交流，严禁用于商业用途、非法用途，否则由此产生的一切后果均与作者无关，在仓库中下载的文件学习完毕之后请于 24 小时内删除！</p><p>代码地址：<a href="https://github.com/TRHX/Python3-Spider-Practice">https://github.com/TRHX/Python3-Spider-Practice</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/ast.png&quot; alt=&quot;ast&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>逆向进阶，利用 AST 技术还原 JavaScript 混淆代码</title>
    <link href="https://www.itbob.cn/article/051/"/>
    <id>https://www.itbob.cn/article/051/</id>
    <published>2022-04-25T09:00:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/ast.png" alt="ast"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#shi-me-shi-ast">什么是 AST</a></li><li><a href="#ast-zai-bian-yi-zhong-de-wei-zhi">AST 在编译中的位置</a><ul><li><a href="#ci-fa-fen-xi">词法分析</a></li><li><a href="#yu-fa-fen-xi">语法分析</a></li><li><a href="#dai-ma-sheng-cheng">代码生成</a></li></ul></li><li><a href="#babel-jian-jie">Babel 简介</a><ul><li><a href="#babel-core">@babel/core</a></li><li><a href="#babel-parser">@babel/parser</a></li><li><a href="#babel-generator">@babel/generator</a></li><li><a href="#babel-traverse">@babel/traverse</a></li><li><a href="#babel-types">@babel/types</a></li></ul></li><li><a href="#chang-jian-hun-yao-huan-yuan">常见混淆还原</a><ul><li><a href="#zi-fu-chuan-huan-yuan">字符串还原</a></li><li><a href="#biao-da-shi-huan-yuan">表达式还原</a></li><li><a href="#shan-chu-wei-shi-yong-bian-liang">删除未使用变量</a></li><li><a href="#shan-chu-rong-yu-luo-ji-dai-ma">删除冗余逻辑代码</a></li><li><a href="#switch-case-fan-kong-zhi-liu-ping-tan-hua">switch-case 反控制流平坦化</a></li></ul></li><li><a href="#can-kao-zi-liao">参考资料</a></li><li><a href="#end">END</a></li></ul><!-- tocstop --><hr><h2><span id="shi-me-shi-ast">什么是 AST</span></h2><p>AST（Abstract Syntax Tree），中文抽象语法树，简称语法树（Syntax Tree），是源代码的抽象语法结构的树状表现形式，树上的每个节点都表示源代码中的一种结构。语法树不是某一种编程语言独有的，JavaScript、Python、Java、Golang 等几乎所有编程语言都有语法树。</p><p>小时候我们得到一个玩具，总喜欢把玩具拆解成一个一个小零件，然后按照我们自己的想法，把零件重新组装起来，一个新玩具就诞生了。而 JavaScript 就像一台精妙运作的机器，通过 AST 解析，我们也可以像童年时拆解玩具一样，深入了解 JavaScript 这台机器的各个零部件，然后重新按照我们自己的意愿来组装。</p><p>AST 的用途很广，IDE 的语法高亮、代码检查、格式化、压缩、转译等，都需要先将代码转化成 AST 再进行后续的操作，ES5 和 ES6 语法差异，为了向后兼容，在实际应用中需要进行语法的转换，也会用到 AST。AST 并不是为了逆向而生，但做逆向学会了 AST，在解混淆时可以如鱼得水。</p><p>AST 有一个在线解析网站：<a href="https://astexplorer.net/">https://astexplorer.net/</a> ，顶部可以选择语言、编译器、是否开启转化等，如下图所示，区域①是源代码，区域②是对应的 AST 语法树，区域③是转换代码，可以对语法树进行各种操作，区域④是转换后生成的新代码。图中原来的 Unicode 字符经过操作之后就变成了正常字符。</p><p>语法树没有单一的格式，选择不同的语言、不同的编译器，得到的结果也是不一样的，在 JavaScript 中，编译器有 Acorn、Espree、Esprima、Recast、Uglify-JS 等，使用最多的是 Babel，后续的学习也是以 Babel 为例。</p><p><img src="https://cdn.itbob.cn/img/article/051/01.png" alt="01"></p><h2><span id="ast-zai-bian-yi-zhong-de-wei-zhi">AST 在编译中的位置</span></h2><p>在编译原理中，编译器转换代码通常要经过三个步骤：词法分析（Lexical Analysis）、语法分析（Syntax Analysis）、代码生成（Code Generation），下图生动展示了这一过程：</p><p><img src="https://cdn.itbob.cn/img/article/051/02.png" alt="02"></p><h3><span id="ci-fa-fen-xi">词法分析</span></h3><p>词法分析阶段是编译过程的第一个阶段，这个阶段的任务是从左到右一个字符一个字符地读入源程序，然后根据构词规则识别单词，生成 token 符号流，比如 <code>isPanda('🐼')</code>，会被拆分成 <code>isPanda</code>，<code>(</code>，<code>'🐼'</code>，<code>)</code> 四部分，每部分都有不同的含义，可以将词法分析过程想象为不同类型标记的列表或数组。</p><p><img src="https://cdn.itbob.cn/img/article/051/03.gif" alt="03"></p><h3><span id="yu-fa-fen-xi">语法分析</span></h3><p>语法分析是编译过程的一个逻辑阶段，语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，比如“程序”，“语句”，“表达式”等，前面的例子中，<code>isPanda('🐼')</code> 就会被分析为一条表达语句 <code>ExpressionStatement</code>，<code>isPanda()</code> 就会被分析成一个函数表达式 <code>CallExpression</code>，<code>🐼</code> 就会被分析成一个变量 <code>Literal</code> 等，众多语法之间的依赖、嵌套关系，就构成了一个树状结构，即 AST 语法树。</p><p><img src="https://cdn.itbob.cn/img/article/051/04.gif" alt="04"></p><h3><span id="dai-ma-sheng-cheng">代码生成</span></h3><p>代码生成是最后一步，将 AST 语法树转换成可执行代码即可，在转换之前，我们可以直接操作语法树，进行增删改查等操作，例如，我们可以确定变量的声明位置、更改变量的值、删除某些节点等，我们将语句 <code>isPanda('🐼')</code> 修改为一个布尔类型的 <code>Literal</code>：<code>true</code>，语法树就有如下变化：</p><p><img src="https://cdn.itbob.cn/img/article/051/05.gif" alt="05"></p><h2><span id="babel-jian-jie">Babel 简介</span></h2><p>Babel 是一个 JavaScript 编译器，也可以说是一个解析库，Babel 中文网：<a href="https://www.babeljs.cn/">https://www.babeljs.cn/</a> ，Babel 英文官网：<a href="https://babeljs.io/">https://babeljs.io/</a> ，Babel 内置了很多分析 JavaScript 代码的方法，我们可以利用 Babel 将 JavaScript 代码转换成 AST 语法树，然后增删改查等操作之后，再转换成 JavaScript 代码。</p><p>Babel 包含的各种功能包、API、各方法可选参数等，都非常多，本文不一一列举，在实际使用过程中，应当多查询官方文档，或者参考文末给出的一些学习资料。Babel 的安装和其他 Node 包一样，需要哪个安装哪个即可，比如 <code>npm install @babel/core @babel/parser @babel/traverse @babel/generator</code></p><p>在做逆向解混淆中，主要用到了 Babel 的以下几个功能包，本文也仅介绍以下几个功能包：</p><ol><li><code>@babel/core</code>：Babel 编译器本身，提供了 babel 的编译 API；</li><li><code>@babel/parser</code>：将 JavaScript 代码解析成 AST 语法树；</li><li><code>@babel/traverse</code>：遍历、修改 AST 语法树的各个节点；</li><li><code>@babel/generator</code>：将 AST 还原成 JavaScript 代码；</li><li><code>@babel/types</code>：判断、验证节点的类型、构建新 AST 节点等。</li></ol><p><img src="https://cdn.itbob.cn/img/article/051/06.png" alt="06"></p><h3><span id="babel-core">@babel/core</span></h3><p>Babel 编译器本身，被拆分成了三个模块：<code>@babel/parser</code>、<code>@babel/traverse</code>、<code>@babel/generator</code>，比如以下方法的导入效果都是一样的：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>).parse;<span class="hljs-keyword">const</span> parse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/core&quot;</span>).parse;<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/core&quot;</span>).traverse</code></pre><h3><span id="babel-parser">@babel/parser</span></h3><p><code>@babel/parser</code> 可以将 JavaScript 代码解析成 AST 语法树，其中主要提供了两个方法：</p><ul><li><code>parser.parse(code, [&#123;options&#125;])</code>：解析一段 JavaScript 代码；</li><li><code>parser.parseExpression(code, [&#123;options&#125;])</code>：考虑到了性能问题，解析单个 JavaScript 表达式。</li></ul><p>部分可选参数 <code>options</code>：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>allowImportExportEverywhere</code></td><td>默认 <code>import</code> 和 <code>export</code> 声明语句只能出现在程序的最顶层，设置为 <code>true</code> 则在任何地方都可以声明</td></tr><tr><td><code>allowReturnOutsideFunction</code></td><td>默认如果在顶层中使用 <code>return</code> 语句会引起错误，设置为 <code>true</code> 就不会报错</td></tr><tr><td><code>sourceType</code></td><td>默认为 <code>script</code>，当代码中含有 <code>import</code> 、<code>export</code> 等关键字时会报错，需要指定为 <code>module</code></td></tr><tr><td><code>errorRecovery</code></td><td>默认如果 babel 发现一些不正常的代码就会抛出错误，设置为 <code>true</code> 则会在保存解析错误的同时继续解析代码，错误的记录将被保存在最终生成的 AST 的 errors 属性中，当然如果遇到严重的错误，依然会终止解析</td></tr></tbody></table><p>举个例子看得比较清楚：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> code = <span class="hljs-string">&quot;const a = 1;&quot;</span>;<span class="hljs-keyword">const</span> ast = parser.parse(code, &#123;<span class="hljs-attr">sourceType</span>: <span class="hljs-string">&quot;module&quot;</span>&#125;)<span class="hljs-built_in">console</span>.log(ast)</code></pre><p><code>&#123;sourceType: &quot;module&quot;&#125;</code> 演示了如何添加可选参数，输出的就是 AST 语法树，这和在线网站 <a href="https://astexplorer.net/">https://astexplorer.net/</a> 解析出来的语法树是一样的：</p><p><img src="https://cdn.itbob.cn/img/article/051/07.png" alt="07"></p><h3><span id="babel-generator">@babel/generator</span></h3><p><code>@babel/generator</code> 可以将 AST 还原成 JavaScript 代码，提供了一个 <code>generate</code> 方法：<code>generate(ast, [&#123;options&#125;], code)</code>。</p><p>部分可选参数 <code>options</code>：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>auxiliaryCommentBefore</code></td><td>在输出文件内容的头部添加注释块文字</td></tr><tr><td><code>auxiliaryCommentAfter</code></td><td>在输出文件内容的末尾添加注释块文字</td></tr><tr><td><code>comments</code></td><td>输出内容是否包含注释</td></tr><tr><td><code>compact</code></td><td>输出内容是否不添加空格，避免格式化</td></tr><tr><td><code>concise</code></td><td>输出内容是否减少空格使其更紧凑一些</td></tr><tr><td><code>minified</code></td><td>是否压缩输出代码</td></tr><tr><td><code>retainLines</code></td><td>尝试在输出代码中使用与源代码中相同的行号</td></tr></tbody></table><p>接着前面的例子，原代码是 <code>const a = 1;</code>，现在我们把 <code>a</code> 变量修改为 <code>b</code>，值 <code>1</code> 修改为 <code>2</code>，然后将 AST 还原生成新的 JS 代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> code = <span class="hljs-string">&quot;const a = 1;&quot;</span>;<span class="hljs-keyword">const</span> ast = parser.parse(code, &#123;<span class="hljs-attr">sourceType</span>: <span class="hljs-string">&quot;module&quot;</span>&#125;)ast.program.body[<span class="hljs-number">0</span>].declarations[<span class="hljs-number">0</span>].id.name = <span class="hljs-string">&quot;b&quot;</span>ast.program.body[<span class="hljs-number">0</span>].declarations[<span class="hljs-number">0</span>].init.value = <span class="hljs-number">2</span><span class="hljs-keyword">const</span> result = generate(ast, &#123;<span class="hljs-attr">minified</span>: <span class="hljs-literal">true</span>&#125;)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>最终输出的是 <code>const b=2;</code>，变量名和值都成功更改了，由于加了压缩处理，等号左右两边的空格也没了。</p><p>代码里 <code>&#123;minified: true&#125;</code> 演示了如何添加可选参数，这里表示压缩输出代码，<code>generate</code> 得到的 <code>result</code> 得到的是一个对象，其中的 <code>code</code> 属性才是最终的 JS 代码。</p><p>代码里 <code>ast.program.body[0].declarations[0].id.name</code> 是 a 在 AST 中的位置，<code>ast.program.body[0].declarations[0].init.value</code> 是 1 在 AST 中的位置，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/051/08.png" alt="08"></p><h3><span id="babel-traverse">@babel/traverse</span></h3><p>当代码多了，我们不可能像前面那样挨个定位并修改，对于相同类型的节点，我们可以直接遍历所有节点来进行修改，这里就用到了 <code>@babel/traverse</code>，它通常和 <code>visitor</code> 一起使用，<code>visitor</code> 是一个对象，这个名字是可以随意取的，<code>visitor</code> 里可以定义一些方法来过滤节点，这里还是用一个例子来演示：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> code = <span class="hljs-string">`</span><span class="hljs-string">const a = 1500;</span><span class="hljs-string">const b = 60;</span><span class="hljs-string">const c = &quot;hi&quot;;</span><span class="hljs-string">const d = 787;</span><span class="hljs-string">const e = &quot;1244&quot;;</span><span class="hljs-string">`</span><span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">NumericLiteral</span>(<span class="hljs-params">path</span>)</span>&#123;        path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>    &#125;,    <span class="hljs-function"><span class="hljs-title">StringLiteral</span>(<span class="hljs-params">path</span>)</span>&#123;        path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>这里的原始代码定义了 abcde 五个变量，其值有数字也有字符串，我们在 AST 中可以看到对应的类型为 <code>NumericLiteral</code> 和 <code>StringLiteral</code>：</p><p><img src="https://cdn.itbob.cn/img/article/051/09.png" alt="09"></p><p>然后我们声明了一个 <code>visitor</code> 对象，然后定义对应类型的处理方法，<code>traverse</code> 接收两个参数，第一个是 AST 对象，第二个是 <code>visitor</code>，当 <code>traverse</code> 遍历所有节点，遇到节点类型为 <code>NumericLiteral</code> 和 <code>StringLiteral</code> 时，就会调用 <code>visitor</code> 中对应的处理方法，<code>visitor</code> 中的方法会接收一个当前节点的 <code>path</code> 对象，该对象的类型是 <code>NodePath</code>，该对象有非常多的属性，以下介绍几种最常用的：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>toString()</code></td><td>当前路径的源码</td></tr><tr><td><code>node</code></td><td>当前路径的节点</td></tr><tr><td><code>parent</code></td><td>当前路径的父级节点</td></tr><tr><td><code>parentPath</code></td><td>当前路径的父级路径</td></tr><tr><td><code>type</code></td><td>当前路径的类型</td></tr></tbody></table><p>PS：<code>path</code> 对象除了有很多属性以外，还有很多方法，比如替换节点、删除节点、插入节点、寻找父级节点、获取同级节点、添加注释、判断节点类型等，可在需要时查询相关文档或查看源码，后续介绍 <code>@babel/types</code> 部分将会举部分例子来演示，以后的实战文章中也会有相关实例，篇幅有限本文不再细说。</p><p>因此在上面的代码中，<code>path.node.value</code> 就拿到了变量的值，然后我们就可以进一步对其进行修改了。以上代码运行后，所有数字都会加上100后再乘以2，所有字符串都会被替换成 <code>I Love JavaScript!</code>，结果如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">3200</span>;<span class="hljs-keyword">const</span> b = <span class="hljs-number">320</span>;<span class="hljs-keyword">const</span> c = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>;<span class="hljs-keyword">const</span> d = <span class="hljs-number">1774</span>;<span class="hljs-keyword">const</span> e = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>;</code></pre><p>如果多个类型的节点，处理的方式都一样，那么还可以使用 <code>|</code> 将所有节点连接成字符串，将同一个方法应用到所有节点：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-string">&quot;NumericLiteral|StringLiteral&quot;</span>(path) &#123;        path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>    &#125;&#125;</code></pre><p><code>visitor</code> 对象有多种写法，以下几种写法的效果都是一样的：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">NumericLiteral</span>(<span class="hljs-params">path</span>)</span>&#123;        path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>    &#125;,    <span class="hljs-function"><span class="hljs-title">StringLiteral</span>(<span class="hljs-params">path</span>)</span>&#123;        path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>    &#125;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-attr">NumericLiteral</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>)</span>&#123;        path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>    &#125;,    <span class="hljs-attr">StringLiteral</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>)</span>&#123;        path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>    &#125;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-attr">NumericLiteral</span>: &#123;        <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span> &#123;            path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>        &#125;    &#125;,    <span class="hljs-attr">StringLiteral</span>: &#123;        <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span> &#123;            path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>        &#125;    &#125;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">if</span> (path.node.type === <span class="hljs-string">&quot;NumericLiteral&quot;</span>) &#123;            path.node.value = (path.node.value + <span class="hljs-number">100</span>) * <span class="hljs-number">2</span>        &#125;        <span class="hljs-keyword">if</span> (path.node.type === <span class="hljs-string">&quot;StringLiteral&quot;</span>) &#123;            path.node.value = <span class="hljs-string">&quot;I Love JavaScript!&quot;</span>        &#125;    &#125;&#125;</code></pre><p>以上几种写法中有用到了 <code>enter</code> 方法，在节点的遍历过程中，进入节点（enter）与退出（exit）节点都会访问一次节点，<code>traverse</code> 默认在进入节点时进行节点的处理，如果要在退出节点时处理，那么在 <code>visitor</code> 中就必须声明 <code>exit</code> 方法。</p><h3><span id="babel-types">@babel/types</span></h3><p><code>@babel/types</code> 主要用于构建新的 AST 节点，前面的示例代码为 <code>const a = 1;</code>，如果想要增加内容，比如变成 <code>const a = 1; const b = a * 5 + 1;</code>，就可以通过 <code>@babel/types</code> 来实现。</p><p>首先观察一下 AST 语法树，原语句只有一个 <code>VariableDeclaration</code> 节点，现在增加了一个：</p><p><img src="https://cdn.itbob.cn/img/article/051/10.png" alt="10"></p><p>那么我们的思路就是在遍历节点时，遍历到 <code>VariableDeclaration</code> 节点，就在其后面增加一个 <code>VariableDeclaration</code> 节点，生成  <code>VariableDeclaration</code> 节点，可以使用 <code>types.variableDeclaration()</code> 方法，在 types 中各种方法名称和我们在 AST 中看到的是一样的，只不过首字母是小写的，所以我们不需要知道所有方法的情况下，也能大致推断其方法名，只知道这个方法还不行，还得知道传入的参数是什么，可以查文档，不过这里推荐直接看源码，非常清晰明了，以 Pycharm 为例，按住 Ctrl 键，再点击方法名，就进到源码里了：</p><p><img src="https://cdn.itbob.cn/img/article/051/11.png" alt="11"></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">variableDeclaration</span>(<span class="hljs-params">kind: <span class="hljs-string">&quot;var&quot;</span> | <span class="hljs-string">&quot;let&quot;</span> | <span class="hljs-string">&quot;const&quot;</span>, declarations: <span class="hljs-built_in">Array</span>&lt;BabelNodeVariableDeclarator&gt;</span>)</span></code></pre><p>可以看到需要 <code>kind</code> 和 <code>declarations</code> 两个参数，其中 <code>declarations</code> 是 <code>VariableDeclarator</code> 类型的节点组成的列表，所以我们可以先写出以下 <code>visitor</code> 部分的代码，其中 <code>path.insertAfter()</code> 是在该节点之后插入新节点的意思：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">let</span> declaration = types.variableDeclaration(<span class="hljs-string">&quot;const&quot;</span>, [declarator])        path.insertAfter(declaration)    &#125;&#125;</code></pre><p>接下来我们还需要进一步定义 <code>declarator</code>，也就是 <code>VariableDeclarator</code> 类型的节点，查询其源码如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">variableDeclarator</span>(<span class="hljs-params">id: BabelNodeLVal, init?: BabelNodeExpression</span>)</span></code></pre><p>观察 AST，id 为 <code>Identifier</code> 对象，init 为 <code>BinaryExpression</code> 对象，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/051/12.png" alt="12"></p><p>先来处理 id，可以使用 <code>types.identifier()</code> 方法来生成，其源码为 <code>function identifier(name: string)</code>，name 在这里就是 b 了，此时 <code>visitor</code> 代码就可以这么写：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">let</span> declarator = types.variableDeclarator(types.identifier(<span class="hljs-string">&quot;b&quot;</span>), init)        <span class="hljs-keyword">let</span> declaration = types.variableDeclaration(<span class="hljs-string">&quot;const&quot;</span>, [declarator])        path.insertAfter(declaration)    &#125;&#125;</code></pre><p>然后再来看 init 该如何定义，首先仍然是看 AST 结构：</p><p><img src="https://cdn.itbob.cn/img/article/051/13.png" alt="13"></p><p>init 为 <code>BinaryExpression</code> 对象，left 左边是 <code>BinaryExpression</code>，right 右边是 <code>NumericLiteral</code>，可以用 <code>types.binaryExpression()</code> 方法来生成 init，其源码如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binaryExpression</span>(<span class="hljs-params"></span></span><span class="hljs-params"><span class="hljs-function">    operator: <span class="hljs-string">&quot;+&quot;</span> | <span class="hljs-string">&quot;-&quot;</span> | <span class="hljs-string">&quot;/&quot;</span> | <span class="hljs-string">&quot;%&quot;</span> | <span class="hljs-string">&quot;*&quot;</span> | <span class="hljs-string">&quot;**&quot;</span> | <span class="hljs-string">&quot;&amp;&quot;</span> | <span class="hljs-string">&quot;|&quot;</span> | <span class="hljs-string">&quot;&gt;&gt;&quot;</span> | <span class="hljs-string">&quot;&gt;&gt;&gt;&quot;</span> | <span class="hljs-string">&quot;&lt;&lt;&quot;</span> | <span class="hljs-string">&quot;^&quot;</span> | <span class="hljs-string">&quot;==&quot;</span> | <span class="hljs-string">&quot;===&quot;</span> | <span class="hljs-string">&quot;!=&quot;</span> | <span class="hljs-string">&quot;!==&quot;</span> | <span class="hljs-string">&quot;in&quot;</span> | <span class="hljs-string">&quot;instanceof&quot;</span> | <span class="hljs-string">&quot;&gt;&quot;</span> | <span class="hljs-string">&quot;&lt;&quot;</span> | <span class="hljs-string">&quot;&gt;=&quot;</span> | <span class="hljs-string">&quot;&lt;=&quot;</span>,</span></span><span class="hljs-params"><span class="hljs-function">    left: BabelNodeExpression | BabelNodePrivateName, </span></span><span class="hljs-params"><span class="hljs-function">    right: BabelNodeExpression</span></span><span class="hljs-params"><span class="hljs-function"></span>)</span></code></pre><p>此时 <code>visitor</code> 代码就可以这么写：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">let</span> init = types.binaryExpression(<span class="hljs-string">&quot;+&quot;</span>, left, right)        <span class="hljs-keyword">let</span> declarator = types.variableDeclarator(types.identifier(<span class="hljs-string">&quot;b&quot;</span>), init)        <span class="hljs-keyword">let</span> declaration = types.variableDeclaration(<span class="hljs-string">&quot;const&quot;</span>, [declarator])        path.insertAfter(declaration)    &#125;&#125;</code></pre><p>然后继续构造 left 和 right，和前面的方法一样，观察 AST 语法树，查询对应方法应该传入的参数，层层嵌套，直到把所有的节点都构造完毕，最终的 <code>visitor</code> 代码应该是这样的：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">let</span> left = types.binaryExpression(<span class="hljs-string">&quot;*&quot;</span>, types.identifier(<span class="hljs-string">&quot;a&quot;</span>), types.numericLiteral(<span class="hljs-number">5</span>))        <span class="hljs-keyword">let</span> right = types.numericLiteral(<span class="hljs-number">1</span>)        <span class="hljs-keyword">let</span> init = types.binaryExpression(<span class="hljs-string">&quot;+&quot;</span>, left, right)        <span class="hljs-keyword">let</span> declarator = types.variableDeclarator(types.identifier(<span class="hljs-string">&quot;b&quot;</span>), init)        <span class="hljs-keyword">let</span> declaration = types.variableDeclaration(<span class="hljs-string">&quot;const&quot;</span>, [declarator])        path.insertAfter(declaration)        path.stop()    &#125;&#125;</code></pre><p>注意：<code>path.insertAfter()</code> 插入节点语句后面加了一句 <code>path.stop()</code>，表示插入完成后立即停止遍历当前节点和后续的子节点，添加的新节点也是 <code>VariableDeclaration</code>，如果不加停止语句的话，就会无限循环插入下去。</p><p>插入新节点后，再转换成 JavaScript 代码，就可以看到多了一行新代码，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/051/14.png" alt="14"></p><h2><span id="chang-jian-hun-yao-huan-yuan">常见混淆还原</span></h2><p>了解了 AST 和 babel 后，就可以对 JavaScript 混淆代码进行还原了，以下是部分样例，带你进一步熟悉 babel 的各种操作。</p><h3><span id="zi-fu-chuan-huan-yuan">字符串还原</span></h3><p>文章开头的图中举了个例子，正常字符被换成了 Unicode 编码：</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>[<span class="hljs-string">&#x27;\u006c\u006f\u0067&#x27;</span>](<span class="hljs-string">&#x27;\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u006f\u0072\u006c\u0064\u0021&#x27;</span>)</code></pre><p>观察 AST 结构：</p><p><img src="https://cdn.itbob.cn/img/article/051/15.png" alt="15"></p><p>我们发现 Unicode 编码对应的是 <code>raw</code>，而 <code>rawValue</code> 和 <code>value</code> 都是正常的，所以我们可以将 <code>raw</code> 替换成 <code>rawValue</code> 或 <code>value</code> 即可，需要注意的是引号的问题，本来是 <code>console[&quot;log&quot;]</code>，你还原后变成了 <code>console[log]</code>，自然会报错的，除了替换值以外，这里直接删除 extra 节点，或者删除 raw 值也是可以的，所以以下几种写法都可以还原代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> code = <span class="hljs-string">`console[&#x27;\u006c\u006f\u0067&#x27;](&#x27;\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u006f\u0072\u006c\u0064\u0021&#x27;)`</span><span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">StringLiteral</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-comment">// 以下方法均可</span>        <span class="hljs-comment">// path.node.extra.raw = path.node.rawValue</span>        <span class="hljs-comment">// path.node.extra.raw = &#x27;&quot;&#x27; + path.node.value + &#x27;&quot;&#x27;</span>        <span class="hljs-comment">// delete path.node.extra</span>        <span class="hljs-keyword">delete</span> path.node.extra.raw    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>还原结果：</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>[<span class="hljs-string">&quot;log&quot;</span>](<span class="hljs-string">&quot;Hello world!&quot;</span>);</code></pre><h3><span id="biao-da-shi-huan-yuan">表达式还原</span></h3><p>之前写过 <a href="https://itrhx.blog.csdn.net/article/details/122057377">JSFuck 混淆的还原</a>，其中有介绍 <code>![]</code> 可表示 false，<code>!![]</code> 或者 <code>!+[]</code> 可表示 true，在一些混淆代码中，经常有这些操作，把简单的表达式复杂化，往往需要执行一下语句，才能得到真正的结果，示例代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = !![]+!![]+!![];<span class="hljs-keyword">const</span> b = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">12.34</span> * <span class="hljs-number">2.12</span>)<span class="hljs-keyword">const</span> c = <span class="hljs-number">10</span> &gt;&gt; <span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">1</span><span class="hljs-keyword">const</span> d = <span class="hljs-built_in">String</span>(<span class="hljs-number">21.3</span> + <span class="hljs-number">14</span> * <span class="hljs-number">1.32</span>)<span class="hljs-keyword">const</span> e = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;1.893&quot;</span> + <span class="hljs-string">&quot;45.9088&quot;</span>)<span class="hljs-keyword">const</span> f = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;23.2334&quot;</span> + <span class="hljs-string">&quot;21.89112&quot;</span>)<span class="hljs-keyword">const</span> g = <span class="hljs-number">20</span> &lt; <span class="hljs-number">18</span> ? <span class="hljs-string">&#x27;未成年&#x27;</span> : <span class="hljs-string">&#x27;成年&#x27;</span></code></pre><p>想要执行语句，我们需要了解 <code>path.evaluate()</code> 方法，该方法会对 path 对象进行执行操作，自动计算出结果，返回一个对象，其中的 <code>confident</code> 属性表示置信度，<code>value</code> 表示计算结果，使用 <code>types.valueToNode()</code> 方法创建节点，使用 <code>path.replaceInline()</code> 方法将节点替换成计算结果生成的新节点，替换方法有一下几种：</p><ul><li><code>replaceWith</code>：用一个节点替换另一个节点；</li><li><code>replaceWithMultiple</code>：用多个节点替换另一个节点；</li><li><code>replaceWithSourceString</code>：将传入的源码字符串解析成对应 Node 后再替换，性能较差，不建议使用；</li><li><code>replaceInline</code>：用一个或多个节点替换另一个节点，相当于同时有了前两个函数的功能。</li></ul><p>对应的 AST 处理代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)<span class="hljs-keyword">const</span> code = <span class="hljs-string">`</span><span class="hljs-string">const a = !![]+!![]+!![];</span><span class="hljs-string">const b = Math.floor(12.34 * 2.12)</span><span class="hljs-string">const c = 10 &gt;&gt; 3 &lt;&lt; 1</span><span class="hljs-string">const d = String(21.3 + 14 * 1.32)</span><span class="hljs-string">const e = parseInt(&quot;1.893&quot; + &quot;45.9088&quot;)</span><span class="hljs-string">const f = parseFloat(&quot;23.2334&quot; + &quot;21.89112&quot;)</span><span class="hljs-string">const g = 20 &lt; 18 ? &#x27;未成年&#x27; : &#x27;成年&#x27;</span><span class="hljs-string">`</span><span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-string">&quot;BinaryExpression|CallExpression|ConditionalExpression&quot;</span>(path) &#123;        <span class="hljs-keyword">const</span> &#123;confident, value&#125; = path.evaluate()        <span class="hljs-keyword">if</span> (confident)&#123;            path.replaceInline(types.valueToNode(value))        &#125;    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>最终结果：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">3</span>;<span class="hljs-keyword">const</span> b = <span class="hljs-number">26</span>;<span class="hljs-keyword">const</span> c = <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> d = <span class="hljs-string">&quot;39.78&quot;</span>;<span class="hljs-keyword">const</span> e = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;1.89345.9088&quot;</span>);<span class="hljs-keyword">const</span> f = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;23.233421.89112&quot;</span>);<span class="hljs-keyword">const</span> g = <span class="hljs-string">&quot;\u6210\u5E74&quot;</span>;</code></pre><h3><span id="shan-chu-wei-shi-yong-bian-liang">删除未使用变量</span></h3><p>有时候代码里会有一些并没有使用到的多余变量，删除这些多余变量有助于更加高效的分析代码，示例代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> b = a * <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> c = <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> d = b + <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> e = <span class="hljs-number">3</span>;<span class="hljs-built_in">console</span>.log(d)</code></pre><p>删除多余变量，首先要了解 <code>NodePath</code> 中的 <code>scope</code>，<code>scope</code> 的作用主要是查找标识符的作用域、获取并修改标识符的所有引用等，删除未使用变量主要用到了 <code>scope.getBinding()</code> 方法，传入的值是当前节点能够引用到的标识符名称，返回的关键属性有以下几个：</p><ul><li><code>identifier</code>：标识符的 Node 对象；</li><li><code>path</code>：标识符的 NodePath 对象；</li><li><code>constant</code>：标识符是否为常量；</li><li><code>referenced</code>：标识符是否被引用；</li><li><code> references</code>：标识符被引用的次数；</li><li><code>constantViolations</code>：如果标识符被修改，则会存放所有修改该标识符节点的 Path 对象；</li><li><code>referencePaths</code>：如果标识符被引用，则会存放所有引用该标识符节点的 Path 对象。</li></ul><p>所以我们可以通过 <code>constantViolations</code>、<code>referenced</code>、<code>references</code>、<code>referencePaths</code> 多个参数来判断变量是否可以被删除，AST 处理代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> code = <span class="hljs-string">`</span><span class="hljs-string">const a = 1;</span><span class="hljs-string">const b = a * 2;</span><span class="hljs-string">const c = 2;</span><span class="hljs-string">const d = b + 1;</span><span class="hljs-string">const e = 3;</span><span class="hljs-string">console.log(d)</span><span class="hljs-string">`</span><span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">VariableDeclarator</span>(<span class="hljs-params">path</span>)</span>&#123;        <span class="hljs-keyword">const</span> binding = path.scope.getBinding(path.node.id.name);        <span class="hljs-comment">// 如标识符被修改过，则不能进行删除动作。</span>        <span class="hljs-keyword">if</span> (!binding || binding.constantViolations.length &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 未被引用</span>        <span class="hljs-keyword">if</span> (!binding.referenced) &#123;            path.remove();        &#125;        <span class="hljs-comment">// 被引用次数为0</span>        <span class="hljs-comment">// if (binding.references === 0) &#123;</span>        <span class="hljs-comment">//     path.remove();</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// 长度为0，变量没有被引用过</span>        <span class="hljs-comment">// if (binding.referencePaths.length === 0) &#123;</span>        <span class="hljs-comment">//     path.remove();</span>        <span class="hljs-comment">// &#125;</span>    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>处理后的代码（未使用的 b、c、e 变量已被删除）：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> b = a * <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> d = b + <span class="hljs-number">1</span>;<span class="hljs-built_in">console</span>.log(d);</code></pre><h3><span id="shan-chu-rong-yu-luo-ji-dai-ma">删除冗余逻辑代码</span></h3><p>有时候为了增加逆向难度，会有很多嵌套的 if-else 语句，大量判断为假的冗余逻辑代码，同样可以利用 AST 将其删除掉，只留下判断为真的，示例代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> example = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> a;    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;        a = <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) &#123;            a = <span class="hljs-number">2</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;            a = <span class="hljs-number">3</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> a;&#125;;</code></pre><p>观察 AST，判断条件对应的是 <code>test</code> 节点，if 对应的是 <code>consequent</code> 节点，else 对应的是 <code>alternate</code> 节点，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/051/16.png" alt="16"></p><p>AST 处理思路以及代码：</p><ol><li>筛选出 <code>BooleanLiteral</code> 和 <code>NumericLiteral</code> 节点，取其对应的值，即 <code>path.node.test.value</code>；</li><li>判断 <code>value</code> 值为真，则将节点替换成 <code>consequent</code> 节点下的内容，即 <code>path.node.consequent.body</code>；</li><li>判断 <code>value</code> 值为假，则替换成 <code>alternate</code> 节点下的内容，即 <code>path.node.alternate.body</code>；</li><li>有的 if 语句可能没有写 else，也就没有 <code>alternate</code>，所以这种情况下判断 <code>value</code> 值为假，则直接移除该节点，即 <code>path.remove()</code></li></ol><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/types&#x27;</span>);<span class="hljs-keyword">const</span> code = <span class="hljs-string">`</span><span class="hljs-string">const example = function () &#123;</span><span class="hljs-string">    let a;</span><span class="hljs-string">    if (false) &#123;</span><span class="hljs-string">        a = 1;</span><span class="hljs-string">    &#125; else &#123;</span><span class="hljs-string">        if (1) &#123;</span><span class="hljs-string">            a = 2;</span><span class="hljs-string">        &#125;</span><span class="hljs-string">        else &#123;</span><span class="hljs-string">            a = 3;</span><span class="hljs-string">        &#125;</span><span class="hljs-string">    &#125;</span><span class="hljs-string">    return a;</span><span class="hljs-string">&#125;;</span><span class="hljs-string">`</span><span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-keyword">if</span> (types.isBooleanLiteral(path.node.test) || types.isNumericLiteral(path.node.test)) &#123;            <span class="hljs-keyword">if</span> (path.node.test.value) &#123;                path.replaceInline(path.node.consequent.body);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (path.node.alternate) &#123;                    path.replaceInline(path.node.alternate.body);                &#125; <span class="hljs-keyword">else</span> &#123;                    path.remove()                &#125;            &#125;        &#125;    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>处理结果：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> example = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> a;  a = <span class="hljs-number">2</span>;  <span class="hljs-keyword">return</span> a;&#125;;</code></pre><h3><span id="switch-case-fan-kong-zhi-liu-ping-tan-hua">switch-case 反控制流平坦化</span></h3><p>控制流平坦化是混淆当中最常见的，通过 <code>if-else</code> 或者 <code>while-switch-case</code> 语句分解步骤，示例代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> _0x34e16a = <span class="hljs-string">&#x27;3,4,0,5,1,2&#x27;</span>[<span class="hljs-string">&#x27;split&#x27;</span>](<span class="hljs-string">&#x27;,&#x27;</span>);<span class="hljs-keyword">let</span> _0x2eff02 = <span class="hljs-number">0x0</span>;<span class="hljs-keyword">while</span> (!![]) &#123;    <span class="hljs-keyword">switch</span> (_0x34e16a[_0x2eff02++]) &#123;        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;0&#x27;</span>:            <span class="hljs-keyword">let</span> _0x38cb15 = _0x4588f1 + _0x470e97;            <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;1&#x27;</span>:            <span class="hljs-keyword">let</span> _0x1e0e5e = _0x37b9f3[_0x50cee0(<span class="hljs-number">0x2e0</span>, <span class="hljs-number">0x2e8</span>, <span class="hljs-number">0x2e1</span>, <span class="hljs-number">0x2e4</span>)];            <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;2&#x27;</span>:            <span class="hljs-keyword">let</span> _0x35d732 = [_0x388d4b(-<span class="hljs-number">0x134</span>, -<span class="hljs-number">0x134</span>, -<span class="hljs-number">0x139</span>, -<span class="hljs-number">0x138</span>)](_0x38cb15 &gt;&gt; _0x4588f1);            <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;3&#x27;</span>:            <span class="hljs-keyword">let</span> _0x4588f1 = <span class="hljs-number">0x1</span>;            <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;4&#x27;</span>:            <span class="hljs-keyword">let</span> _0x470e97 = <span class="hljs-number">0x2</span>;            <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;5&#x27;</span>:            <span class="hljs-keyword">let</span> _0x37b9f3 = <span class="hljs-number">0x5</span> || _0x38cb15;            <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">break</span>;&#125;</code></pre><p>AST 还原思路：</p><ol><li>获取控制流原始数组，将 <code>'3,4,0,5,1,2'['split'](',')</code> 之类的语句转化成 <code>['3','4','0','5','1','2']</code> 之类的数组，得到该数组之后，也可以选择把 split 语句对应的节点删除掉，因为最终代码里这条语句就没用了；</li><li>遍历第一步得到的控制流数组，依次取出每个值所对应的 case 节点；</li><li>定义一个数组，储存每个 case 节点 <code>consequent</code> 数组里面的内容，并删除 <code>continue</code> 语句对应的节点；</li><li>遍历完成后，将第三步的数组替换掉整个 while 节点，也就是 <code>WhileStatement</code>。</li></ol><p>不同思路，写法多样，对于如何获取控制流数组，可以有以下思路：</p><ol><li>获取到 <code>While</code> 语句节点，然后使用 <code>path.getAllPrevSiblings()</code> 方法获取其前面的所有兄弟节点，遍历每个兄弟节点，找到与 <code>switch()</code> 里面数组的变量名相同的节点，然后再取节点的值进行后续处理；</li><li>直接取 <code>switch()</code> 里面数组的变量名，然后使用 <code>scope.getBinding()</code> 方法获取到它绑定的节点，然后再取这个节点的值进行后续处理。</li></ol><p>所以 AST 处理代码就有两种写法，方法一：（code.js 即为前面的示例代码，为了方便操作，这里使用 fs 从文件中读取代码）</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<span class="hljs-keyword">const</span> code = fs.readFileSync(<span class="hljs-string">&quot;code.js&quot;</span>, &#123;<span class="hljs-attr">encoding</span>: <span class="hljs-string">&quot;utf-8&quot;</span>&#125;);<span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">WhileStatement</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-comment">// switch 节点</span>        <span class="hljs-keyword">let</span> switchNode = path.node.body.body[<span class="hljs-number">0</span>];        <span class="hljs-comment">// switch 语句内的控制流数组名，本例中是 _0x34e16a</span>        <span class="hljs-keyword">let</span> arrayName = switchNode.discriminant.object.name;        <span class="hljs-comment">// 获得所有 while 前面的兄弟节点，本例中获取到的是声明两个变量的节点，即 const _0x34e16a 和 let _0x2eff02</span>        <span class="hljs-keyword">let</span> prevSiblings = path.getAllPrevSiblings();        <span class="hljs-comment">// 定义缓存控制流数组</span>        <span class="hljs-keyword">let</span> array = []        <span class="hljs-comment">// forEach 方法遍历所有节点</span>        prevSiblings.forEach(<span class="hljs-function"><span class="hljs-params">pervNode</span> =&gt;</span> &#123;            <span class="hljs-keyword">let</span> &#123;id, init&#125; = pervNode.node.declarations[<span class="hljs-number">0</span>];            <span class="hljs-comment">// 如果节点 id.name 与 switch 语句内的控制流数组名相同</span>            <span class="hljs-keyword">if</span> (arrayName === id.name) &#123;                <span class="hljs-comment">// 获取节点整个表达式的参数、分割方法、分隔符</span>                <span class="hljs-keyword">let</span> object = init.callee.object.value;                <span class="hljs-keyword">let</span> property = init.callee.property.value;                <span class="hljs-keyword">let</span> argument = init.arguments[<span class="hljs-number">0</span>].value;                <span class="hljs-comment">// 模拟执行 &#x27;3,4,0,5,1,2&#x27;[&#x27;split&#x27;](&#x27;,&#x27;) 语句</span>                array = object[property](argument)                <span class="hljs-comment">// 也可以直接取参数进行分割，方法不通用，比如分隔符换成 | 就不行了</span>                <span class="hljs-comment">// array = init.callee.object.value.split(&#x27;,&#x27;);</span>            &#125;            <span class="hljs-comment">// 前面的兄弟节点就可以删除了</span>            pervNode.remove();        &#125;);        <span class="hljs-comment">// 储存正确顺序的控制流语句</span>        <span class="hljs-keyword">let</span> replace = [];        <span class="hljs-comment">// 遍历控制流数组，按正确顺序取 case 内容</span>        array.forEach(<span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;                <span class="hljs-keyword">let</span> consequent = switchNode.cases[index].consequent;                <span class="hljs-comment">// 如果最后一个节点是 continue 语句，则删除 ContinueStatement 节点</span>                <span class="hljs-keyword">if</span> (types.isContinueStatement(consequent[consequent.length - <span class="hljs-number">1</span>])) &#123;                    consequent.pop();                &#125;                <span class="hljs-comment">// concat 方法拼接多个数组，即正确顺序的 case 内容</span>                replace = replace.concat(consequent);            &#125;        );        <span class="hljs-comment">// 替换整个 while 节点，两种方法都可以</span>        path.replaceWithMultiple(replace);        <span class="hljs-comment">// path.replaceInline(replace);</span>    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>方法二：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<span class="hljs-keyword">const</span> generate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<span class="hljs-keyword">const</span> code = fs.readFileSync(<span class="hljs-string">&quot;code.js&quot;</span>, &#123;<span class="hljs-attr">encoding</span>: <span class="hljs-string">&quot;utf-8&quot;</span>&#125;);<span class="hljs-keyword">const</span> ast = parser.parse(code)<span class="hljs-keyword">const</span> visitor = &#123;    <span class="hljs-function"><span class="hljs-title">WhileStatement</span>(<span class="hljs-params">path</span>)</span> &#123;        <span class="hljs-comment">// switch 节点</span>        <span class="hljs-keyword">let</span> switchNode = path.node.body.body[<span class="hljs-number">0</span>];        <span class="hljs-comment">// switch 语句内的控制流数组名，本例中是 _0x34e16a</span>        <span class="hljs-keyword">let</span> arrayName = switchNode.discriminant.object.name;        <span class="hljs-comment">// 获取控制流数组绑定的节点</span>        <span class="hljs-keyword">let</span> bindingArray = path.scope.getBinding(arrayName);        <span class="hljs-comment">// 获取节点整个表达式的参数、分割方法、分隔符</span>        <span class="hljs-keyword">let</span> init = bindingArray.path.node.init;        <span class="hljs-keyword">let</span> object = init.callee.object.value;        <span class="hljs-keyword">let</span> property = init.callee.property.value;        <span class="hljs-keyword">let</span> argument = init.arguments[<span class="hljs-number">0</span>].value;        <span class="hljs-comment">// 模拟执行 &#x27;3,4,0,5,1,2&#x27;[&#x27;split&#x27;](&#x27;,&#x27;) 语句</span>        <span class="hljs-keyword">let</span> array = object[property](argument)        <span class="hljs-comment">// 也可以直接取参数进行分割，方法不通用，比如分隔符换成 | 就不行了</span>        <span class="hljs-comment">// let array = init.callee.object.value.split(&#x27;,&#x27;);</span>        <span class="hljs-comment">// switch 语句内的控制流自增变量名，本例中是 _0x2eff02</span>        <span class="hljs-keyword">let</span> autoIncrementName = switchNode.discriminant.property.argument.name;        <span class="hljs-comment">// 获取控制流自增变量名绑定的节点</span>        <span class="hljs-keyword">let</span> bindingAutoIncrement = path.scope.getBinding(autoIncrementName);        <span class="hljs-comment">// 可选择的操作：删除控制流数组绑定的节点、自增变量名绑定的节点</span>        bindingArray.path.remove();        bindingAutoIncrement.path.remove();        <span class="hljs-comment">// 储存正确顺序的控制流语句</span>        <span class="hljs-keyword">let</span> replace = [];        <span class="hljs-comment">// 遍历控制流数组，按正确顺序取 case 内容</span>        array.forEach(<span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;                <span class="hljs-keyword">let</span> consequent = switchNode.cases[index].consequent;                <span class="hljs-comment">// 如果最后一个节点是 continue 语句，则删除 ContinueStatement 节点</span>                <span class="hljs-keyword">if</span> (types.isContinueStatement(consequent[consequent.length - <span class="hljs-number">1</span>])) &#123;                    consequent.pop();                &#125;                <span class="hljs-comment">// concat 方法拼接多个数组，即正确顺序的 case 内容</span>                replace = replace.concat(consequent);            &#125;        );        <span class="hljs-comment">// 替换整个 while 节点，两种方法都可以</span>        path.replaceWithMultiple(replace);        <span class="hljs-comment">// path.replaceInline(replace);</span>    &#125;&#125;traverse(ast, visitor)<span class="hljs-keyword">const</span> result = generate(ast)<span class="hljs-built_in">console</span>.log(result.code)</code></pre><p>以上代码运行后，原来的 <code>switch-case</code> 控制流就被还原了，变成了按顺序一行一行的代码，更加简洁明了：</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> _0x4588f1 = <span class="hljs-number">0x1</span>;<span class="hljs-keyword">let</span> _0x470e97 = <span class="hljs-number">0x2</span>;<span class="hljs-keyword">let</span> _0x38cb15 = _0x4588f1 + _0x470e97;<span class="hljs-keyword">let</span> _0x37b9f3 = <span class="hljs-number">0x5</span> || _0x38cb15;<span class="hljs-keyword">let</span> _0x1e0e5e = _0x37b9f3[_0x50cee0(<span class="hljs-number">0x2e0</span>, <span class="hljs-number">0x2e8</span>, <span class="hljs-number">0x2e1</span>, <span class="hljs-number">0x2e4</span>)];<span class="hljs-keyword">let</span> _0x35d732 = [_0x388d4b(-<span class="hljs-number">0x134</span>, -<span class="hljs-number">0x134</span>, -<span class="hljs-number">0x139</span>, -<span class="hljs-number">0x138</span>)](_0x38cb15 &gt;&gt; _0x4588f1);</code></pre><h2><span id="can-kao-zi-liao">参考资料</span></h2><p>本文有参考以下资料，也是比较推荐的在线学习资料：</p><ul><li>Youtube 视频，Babel 入门：<a href="https://www.youtube.com/watch?v=UeVq_U5obnE">https://www.youtube.com/watch?v=UeVq_U5obnE</a></li><li>官方手册 Babel Handbook：<a href="https://github.com/jamiebuilds/babel-handbook">https://github.com/jamiebuilds/babel-handbook</a></li><li>非官方 Babel API 中文文档：<a href="https://evilrecluse.top/Babel-traverse-api-doc/">https://evilrecluse.top/Babel-traverse-api-doc/</a></li></ul><h2><span id="end">END</span></h2><p>Babel 编译器国内的资料其实不是很多，多看源码、同时在线对照可视化的 AST 语法树，耐心一点儿一层一层分析即可，本文中的案例也只是最基本操作，实际遇到一些混淆还得视情况进行修改，比如需要加一些类型判断来限制等，后续会用实战来带领大家进一步熟悉解混淆当中的其他操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/ast.png&quot; alt=&quot;ast&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>网洛者反爬练习平台第七题：JSVMPZL 初体验</title>
    <link href="https://www.itbob.cn/article/050/"/>
    <id>https://www.itbob.cn/article/050/</id>
    <published>2022-04-06T05:39:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/javascript_reverse.png" alt="javascript_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#ni-xiang-guo-cheng">逆向过程</a><ul><li><a href="#hook-guan-jian-fang-fa">Hook 关键方法</a></li><li><a href="#ri-zhi-duan-dian-cha-zhuang-diao-shi">日志断点 / 插桩调试</a></li></ul></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：网洛者反反爬虫练习平台第七题：JSVMPZL 初体验</li><li>链接：<a href="http://spider.wangluozhe.com/challenge/7">http://spider.wangluozhe.com/challenge/7</a></li><li>简介：平台注册需要邀请码，站长在群里，可后台回复交流群加群获取，或者直接加网站底部站长QQ获取。要求采集100页的全部数字，并计算所有数据加和。主要难点在于 vvv 大佬开发的 JS 混淆框架：jsvmpzl</li></ul><p><img src="https://cdn.itbob.cn/img/article/050/01.png" alt="01"></p><h2><span id="ni-xiang-guo-cheng">逆向过程</span></h2><p>直接搜索，或者跟栈，可以轻松找到加密入口，打开 F12 有两个反调试，一是无限 debugger，右键 Never pause here 即可，二是定时器，控制台输入 <code>for (let i = 1; i &lt; 99999; i++) window.clearInterval(i);</code> 过掉即可。</p><p><img src="https://cdn.itbob.cn/img/article/050/02.png" alt="02"></p><p>跟进 <code>y__()</code>，就可以看到 jsvmpzl 混淆的代码了，如果有做过猿人学平台的题，会发现此混淆和猿人学第 18 题（ <a href="https://match.yuanrenxue.com/match/18">https://match.yuanrenxue.com/match/18</a> ）是一样的，在 <code>y__()</code> 第一行下个断点，观察 <code>__v_()</code> 第一个参数 <code>_</code>，<code>_[2][0]</code> 你会发现有关 MD5 算法的一些特征，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/050/03.png" alt="03"></p><p>那么我们直接大胆猜测一下，是不是就是某个数据经过 MD5 之后就是 <code>_signature</code> 了呢？再继续调试一下，注意 <code>arguments</code> 的变化：</p><p><img src="https://cdn.itbob.cn/img/article/050/04.png" alt="04"></p><p>很明显这个 <code>window.byted_acrawler(window.sign())</code> 应该就是生成 <code>_signature</code> 的语句，这个方法和某字节系的 <code>_signature</code> 生成的方法名称是一样的，直接在控制台输出一下可以拿到值，其中 <code>window.sign()</code> 是取的时间戳：</p><p><img src="https://cdn.itbob.cn/img/article/050/05.png" alt="05"></p><p>我们前面猜测是 MD5，直接验证一下，发现并不是的，即便是同一个时间戳，经过 <code>window.byted_acrawler()</code> 后得到的值每次也都不一样：</p><p><img src="https://cdn.itbob.cn/img/article/050/06.png" alt="06"></p><h3><span id="hook-guan-jian-fang-fa">Hook 关键方法</span></h3><p>经过前面的分析，既然标准的 MD5 不行，那有没有可能是魔改的 MD5 呢？首先找个 JavaScript 标准的 MD5 代码看一下，比如：<a href="http://pajhome.org.uk/crypt/md5/md5.html">http://pajhome.org.uk/crypt/md5/md5.html</a></p><p><img src="https://cdn.itbob.cn/img/article/050/07.png" alt="07"></p><p>可以注意到，源码里面有很多 <code>md5_ff</code>、<code>md5_gg</code>、<code>md5_hh</code>、<code>md5_ii</code> 的方法，最后一个值都是固定的，那么有没有可能此题就是在标准 MD5 的基础上修改了一些默认值呢？所以我们可以直接 Hook 这些关键方法，在控制台输出传入的值，来一一对比一下，看看默认值是否是一样的，为了方便观察，我们还可以为输出语句加上颜色，Hook 代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> oldFF = _[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;md5_ff&#x27;</span>];<span class="hljs-keyword">let</span> oldGG = _[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;md5_gg&#x27;</span>];<span class="hljs-keyword">let</span> oldHH = _[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;md5_hh&#x27;</span>];<span class="hljs-keyword">let</span> oldII = _[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;md5_ii&#x27;</span>];<span class="hljs-keyword">let</span> color_white_red = <span class="hljs-string">&quot;color: white; background: red;&quot;</span><span class="hljs-keyword">let</span> color_white_grey = <span class="hljs-string">&quot;color: white; background: grey;&quot;</span><span class="hljs-keyword">let</span> color_white_darkcyan = <span class="hljs-string">&quot;color: white; background: darkcyan;&quot;</span><span class="hljs-keyword">let</span> color_white_green = <span class="hljs-string">&quot;color: white; background: green;&quot;</span><span class="hljs-keyword">let</span> color_white_orange = <span class="hljs-string">&quot;color: white; background: orange;&quot;</span>_[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;md5_ff&#x27;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d, e, f, g</span>) </span>&#123;    <span class="hljs-keyword">debugger</span>;    <span class="hljs-keyword">let</span> result = oldFF(a, b, c, d, e, f, g);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;%c Function: %c md5_ff %c Result: %c %s %c Params: %c %s, %s, %s, %s, %s, %s, %s &quot;</span>, color_white_red, color_white_grey, color_white_red, color_white_grey, result, color_white_red, color_white_grey, a, b, c, d, e, f, g)    <span class="hljs-keyword">return</span> result;&#125;;_[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;md5_gg&#x27;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d, e, f, g</span>) </span>&#123;    <span class="hljs-keyword">debugger</span>;    <span class="hljs-keyword">let</span> result = oldGG(a, b, c, d, e, f, g);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;%c Function: %c md5_gg %c Result: %c %s %c Params: %c %s, %s, %s, %s, %s, %s, %s &quot;</span>, color_white_red, color_white_darkcyan, color_white_red, color_white_darkcyan, result, color_white_red, color_white_darkcyan, a, b, c, d, e, f, g)    <span class="hljs-keyword">return</span> result;&#125;;_[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;md5_hh&#x27;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d, e, f, g</span>) </span>&#123;    <span class="hljs-keyword">debugger</span>;    <span class="hljs-keyword">let</span> result = oldHH(a, b, c, d, e, f, g);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;%c Function: %c md5_hh %c Result: %c %s %c Params: %c %s, %s, %s, %s, %s, %s, %s &quot;</span>, color_white_red, color_white_green, color_white_red, color_white_green, result, color_white_red, color_white_green, a, b, c, d, e, f, g)    <span class="hljs-keyword">return</span> result;&#125;;_[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;md5_ii&#x27;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d, e, f, g</span>) </span>&#123;    <span class="hljs-keyword">debugger</span>;    <span class="hljs-keyword">let</span> result = oldII(a, b, c, d, e, f, g);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;%c Function: %c md5_ii %c Result: %c %s %c Params: %c %s, %s, %s, %s, %s, %s, %s &quot;</span>, color_white_red, color_white_orange, color_white_red, color_white_orange, result, color_white_red, color_white_orange, a, b, c, d, e, f, g)    <span class="hljs-keyword">return</span> result;&#125;;</code></pre><p>Hook 代码写得比较死板，熟悉 JS 的大佬可自己优化一下，注意注入代码的时机，清除定时器后，断点运行到 <code>y__()</code> 方法后再注入，然后取消断点，一直下一步，就可以在控制台看到输出的参数了，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/050/08.png" alt="08"></p><p><img src="https://cdn.itbob.cn/img/article/050/09.png" alt="09"></p><p>与默认参数进行对比，可以发现 <code>md5_hh()</code> 里有两个默认参数被修改了：</p><p><img src="https://cdn.itbob.cn/img/article/050/10.png" alt="10"></p><p>默认的 <code>-722521979</code> 改成了 <code>-722521939</code>、<code>76029189</code> 改成了 <code>76029185</code>，本地代码修改一下即可：</p><pre><code class="hljs javascript"><span class="hljs-comment">/* ==================================</span><span class="hljs-comment"># @Time    : 2021-12-23</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: challenge_7.js</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ================================== */</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message</span><span class="hljs-comment"> * Digest Algorithm, as defined in RFC 1321.</span><span class="hljs-comment"> * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009</span><span class="hljs-comment"> * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet</span><span class="hljs-comment"> * Distributed under the BSD License</span><span class="hljs-comment"> * See http://pajhome.org.uk/crypt/md5 for more info.</span><span class="hljs-comment"> */</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * Configurable variables. You may need to tweak these to be compatible with</span><span class="hljs-comment"> * the server-side, but the defaults work in most cases.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> hexcase = <span class="hljs-number">0</span>;   <span class="hljs-comment">/* hex output format. 0 - lowercase; 1 - uppercase        */</span><span class="hljs-keyword">var</span> b64pad  = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-comment">/* base-64 pad character. &quot;=&quot; for strict RFC compliance   */</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * These are the functions you&#x27;ll usually want to call</span><span class="hljs-comment"> * They take string arguments and return either hex or base-64 encoded strings</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hex_md5</span>(<span class="hljs-params">s</span>)    </span>&#123; <span class="hljs-keyword">return</span> rstr2hex(rstr_md5(str2rstr_utf8(s))); &#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b64_md5</span>(<span class="hljs-params">s</span>)    </span>&#123; <span class="hljs-keyword">return</span> rstr2b64(rstr_md5(str2rstr_utf8(s))); &#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">any_md5</span>(<span class="hljs-params">s, e</span>) </span>&#123; <span class="hljs-keyword">return</span> rstr2any(rstr_md5(str2rstr_utf8(s)), e); &#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hex_hmac_md5</span>(<span class="hljs-params">k, d</span>)</span><span class="hljs-function">  </span>&#123; <span class="hljs-keyword">return</span> rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); &#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b64_hmac_md5</span>(<span class="hljs-params">k, d</span>)</span><span class="hljs-function">  </span>&#123; <span class="hljs-keyword">return</span> rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); &#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">any_hmac_md5</span>(<span class="hljs-params">k, d, e</span>)</span><span class="hljs-function">  </span>&#123; <span class="hljs-keyword">return</span> rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); &#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Perform a simple self-test to see if the VM is working</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">md5_vm_test</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> hex_md5(<span class="hljs-string">&quot;abc&quot;</span>).toLowerCase() == <span class="hljs-string">&quot;900150983cd24fb0d6963f7d28e17f72&quot;</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Calculate the MD5 of a raw string</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rstr_md5</span>(<span class="hljs-params">s</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> binl2rstr(binl_md5(rstr2binl(s), s.length * <span class="hljs-number">8</span>));&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Calculate the HMAC-MD5, of a key and some data (raw strings)</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rstr_hmac_md5</span>(<span class="hljs-params">key, data</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">var</span> bkey = rstr2binl(key);  <span class="hljs-keyword">if</span>(bkey.length &gt; <span class="hljs-number">16</span>) bkey = binl_md5(bkey, key.length * <span class="hljs-number">8</span>);  <span class="hljs-keyword">var</span> ipad = <span class="hljs-built_in">Array</span>(<span class="hljs-number">16</span>), opad = <span class="hljs-built_in">Array</span>(<span class="hljs-number">16</span>);  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++)  &#123;    ipad[i] = bkey[i] ^ <span class="hljs-number">0x36363636</span>;    opad[i] = bkey[i] ^ <span class="hljs-number">0x5C5C5C5C</span>;  &#125;  <span class="hljs-keyword">var</span> hash = binl_md5(ipad.concat(rstr2binl(data)), <span class="hljs-number">512</span> + data.length * <span class="hljs-number">8</span>);  <span class="hljs-keyword">return</span> binl2rstr(binl_md5(opad.concat(hash), <span class="hljs-number">512</span> + <span class="hljs-number">128</span>));&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Convert a raw string to a hex string</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rstr2hex</span>(<span class="hljs-params">input</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">try</span> &#123; hexcase &#125; <span class="hljs-keyword">catch</span>(e) &#123; hexcase=<span class="hljs-number">0</span>; &#125;  <span class="hljs-keyword">var</span> hex_tab = hexcase ? <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span> : <span class="hljs-string">&quot;0123456789abcdef&quot;</span>;  <span class="hljs-keyword">var</span> output = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">var</span> x;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; input.length; i++)  &#123;    x = input.charCodeAt(i);    output += hex_tab.charAt((x &gt;&gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0F</span>)           +  hex_tab.charAt( x        &amp; <span class="hljs-number">0x0F</span>);  &#125;  <span class="hljs-keyword">return</span> output;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Convert a raw string to a base-64 string</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rstr2b64</span>(<span class="hljs-params">input</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">try</span> &#123; b64pad &#125; <span class="hljs-keyword">catch</span>(e) &#123; b64pad=<span class="hljs-string">&#x27;&#x27;</span>; &#125;  <span class="hljs-keyword">var</span> tab = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;  <span class="hljs-keyword">var</span> output = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">var</span> len = input.length;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i += <span class="hljs-number">3</span>)  &#123;    <span class="hljs-keyword">var</span> triplet = (input.charCodeAt(i) &lt;&lt; <span class="hljs-number">16</span>)                | (i + <span class="hljs-number">1</span> &lt; len ? input.charCodeAt(i+<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">8</span> : <span class="hljs-number">0</span>)                | (i + <span class="hljs-number">2</span> &lt; len ? input.charCodeAt(i+<span class="hljs-number">2</span>)      : <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)    &#123;      <span class="hljs-keyword">if</span>(i * <span class="hljs-number">8</span> + j * <span class="hljs-number">6</span> &gt; input.length * <span class="hljs-number">8</span>) output += b64pad;      <span class="hljs-keyword">else</span> output += tab.charAt((triplet &gt;&gt;&gt; <span class="hljs-number">6</span>*(<span class="hljs-number">3</span>-j)) &amp; <span class="hljs-number">0x3F</span>);    &#125;  &#125;  <span class="hljs-keyword">return</span> output;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Convert a raw string to an arbitrary string encoding</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rstr2any</span>(<span class="hljs-params">input, encoding</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">var</span> divisor = encoding.length;  <span class="hljs-keyword">var</span> i, j, q, x, quotient;  <span class="hljs-comment">/* Convert to an array of 16-bit big-endian values, forming the dividend */</span>  <span class="hljs-keyword">var</span> dividend = <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">Math</span>.ceil(input.length / <span class="hljs-number">2</span>));  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; dividend.length; i++)  &#123;    dividend[i] = (input.charCodeAt(i * <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">8</span>) | input.charCodeAt(i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);  &#125;  <span class="hljs-comment">/*</span><span class="hljs-comment">   * Repeatedly perform a long division. The binary array forms the dividend,</span><span class="hljs-comment">   * the length of the encoding is the divisor. Once computed, the quotient</span><span class="hljs-comment">   * forms the dividend for the next step. All remainders are stored for later</span><span class="hljs-comment">   * use.</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">var</span> full_length = <span class="hljs-built_in">Math</span>.ceil(input.length * <span class="hljs-number">8</span> /                                    (<span class="hljs-built_in">Math</span>.log(encoding.length) / <span class="hljs-built_in">Math</span>.log(<span class="hljs-number">2</span>)));  <span class="hljs-keyword">var</span> remainders = <span class="hljs-built_in">Array</span>(full_length);  <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; full_length; j++)  &#123;    quotient = <span class="hljs-built_in">Array</span>();    x = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; dividend.length; i++)    &#123;      x = (x &lt;&lt; <span class="hljs-number">16</span>) + dividend[i];      q = <span class="hljs-built_in">Math</span>.floor(x / divisor);      x -= q * divisor;      <span class="hljs-keyword">if</span>(quotient.length &gt; <span class="hljs-number">0</span> || q &gt; <span class="hljs-number">0</span>)        quotient[quotient.length] = q;    &#125;    remainders[j] = x;    dividend = quotient;  &#125;  <span class="hljs-comment">/* Convert the remainders to the output string */</span>  <span class="hljs-keyword">var</span> output = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">for</span>(i = remainders.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)    output += encoding.charAt(remainders[i]);  <span class="hljs-keyword">return</span> output;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Encode a string as utf-8.</span><span class="hljs-comment"> * For efficiency, this assumes the input is valid utf-16.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">str2rstr_utf8</span>(<span class="hljs-params">input</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">var</span> output = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>;  <span class="hljs-keyword">var</span> x, y;  <span class="hljs-keyword">while</span>(++i &lt; input.length)  &#123;    <span class="hljs-comment">/* Decode utf-16 surrogate pairs */</span>    x = input.charCodeAt(i);    y = i + <span class="hljs-number">1</span> &lt; input.length ? input.charCodeAt(i + <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(<span class="hljs-number">0xD800</span> &lt;= x &amp;&amp; x &lt;= <span class="hljs-number">0xDBFF</span> &amp;&amp; <span class="hljs-number">0xDC00</span> &lt;= y &amp;&amp; y &lt;= <span class="hljs-number">0xDFFF</span>)    &#123;      x = <span class="hljs-number">0x10000</span> + ((x &amp; <span class="hljs-number">0x03FF</span>) &lt;&lt; <span class="hljs-number">10</span>) + (y &amp; <span class="hljs-number">0x03FF</span>);      i++;    &#125;    <span class="hljs-comment">/* Encode output as utf-8 */</span>    <span class="hljs-keyword">if</span>(x &lt;= <span class="hljs-number">0x7F</span>)      output += <span class="hljs-built_in">String</span>.fromCharCode(x);    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt;= <span class="hljs-number">0x7FF</span>)      output += <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0xC0</span> | ((x &gt;&gt;&gt; <span class="hljs-number">6</span> ) &amp; <span class="hljs-number">0x1F</span>),                                    <span class="hljs-number">0x80</span> | ( x         &amp; <span class="hljs-number">0x3F</span>));    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt;= <span class="hljs-number">0xFFFF</span>)      output += <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0xE0</span> | ((x &gt;&gt;&gt; <span class="hljs-number">12</span>) &amp; <span class="hljs-number">0x0F</span>),                                    <span class="hljs-number">0x80</span> | ((x &gt;&gt;&gt; <span class="hljs-number">6</span> ) &amp; <span class="hljs-number">0x3F</span>),                                    <span class="hljs-number">0x80</span> | ( x         &amp; <span class="hljs-number">0x3F</span>));    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt;= <span class="hljs-number">0x1FFFFF</span>)      output += <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0xF0</span> | ((x &gt;&gt;&gt; <span class="hljs-number">18</span>) &amp; <span class="hljs-number">0x07</span>),                                    <span class="hljs-number">0x80</span> | ((x &gt;&gt;&gt; <span class="hljs-number">12</span>) &amp; <span class="hljs-number">0x3F</span>),                                    <span class="hljs-number">0x80</span> | ((x &gt;&gt;&gt; <span class="hljs-number">6</span> ) &amp; <span class="hljs-number">0x3F</span>),                                    <span class="hljs-number">0x80</span> | ( x         &amp; <span class="hljs-number">0x3F</span>));  &#125;  <span class="hljs-keyword">return</span> output;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Encode a string as utf-16</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">str2rstr_utf16le</span>(<span class="hljs-params">input</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">var</span> output = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; input.length; i++)    output += <span class="hljs-built_in">String</span>.fromCharCode( input.charCodeAt(i)        &amp; <span class="hljs-number">0xFF</span>,                                  (input.charCodeAt(i) &gt;&gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>);  <span class="hljs-keyword">return</span> output;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">str2rstr_utf16be</span>(<span class="hljs-params">input</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">var</span> output = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; input.length; i++)    output += <span class="hljs-built_in">String</span>.fromCharCode((input.charCodeAt(i) &gt;&gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>,                                   input.charCodeAt(i)        &amp; <span class="hljs-number">0xFF</span>);  <span class="hljs-keyword">return</span> output;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Convert a raw string to an array of little-endian words</span><span class="hljs-comment"> * Characters &gt;255 have their high-byte silently ignored.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rstr2binl</span>(<span class="hljs-params">input</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">var</span> output = <span class="hljs-built_in">Array</span>(input.length &gt;&gt; <span class="hljs-number">2</span>);  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; output.length; i++)    output[i] = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; input.length * <span class="hljs-number">8</span>; i += <span class="hljs-number">8</span>)    output[i&gt;&gt;<span class="hljs-number">5</span>] |= (input.charCodeAt(i / <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>) &lt;&lt; (i%<span class="hljs-number">32</span>);  <span class="hljs-keyword">return</span> output;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Convert an array of little-endian words to a string</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binl2rstr</span>(<span class="hljs-params">input</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">var</span> output = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; input.length * <span class="hljs-number">32</span>; i += <span class="hljs-number">8</span>)    output += <span class="hljs-built_in">String</span>.fromCharCode((input[i&gt;&gt;<span class="hljs-number">5</span>] &gt;&gt;&gt; (i % <span class="hljs-number">32</span>)) &amp; <span class="hljs-number">0xFF</span>);  <span class="hljs-keyword">return</span> output;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Calculate the MD5 of an array of little-endian words, and a bit length.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binl_md5</span>(<span class="hljs-params">x, len</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-comment">/* append padding */</span>  x[len &gt;&gt; <span class="hljs-number">5</span>] |= <span class="hljs-number">0x80</span> &lt;&lt; ((len) % <span class="hljs-number">32</span>);  x[(((len + <span class="hljs-number">64</span>) &gt;&gt;&gt; <span class="hljs-number">9</span>) &lt;&lt; <span class="hljs-number">4</span>) + <span class="hljs-number">14</span>] = len;  <span class="hljs-keyword">var</span> a =  <span class="hljs-number">1732584193</span>;  <span class="hljs-keyword">var</span> b = -<span class="hljs-number">271733879</span>;  <span class="hljs-keyword">var</span> c = -<span class="hljs-number">1732584194</span>;  <span class="hljs-keyword">var</span> d =  <span class="hljs-number">271733878</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; x.length; i += <span class="hljs-number">16</span>)  &#123;    <span class="hljs-keyword">var</span> olda = a;    <span class="hljs-keyword">var</span> oldb = b;    <span class="hljs-keyword">var</span> oldc = c;    <span class="hljs-keyword">var</span> oldd = d;    a = md5_ff(a, b, c, d, x[i+ <span class="hljs-number">0</span>], <span class="hljs-number">7</span> , -<span class="hljs-number">680876936</span>);    d = md5_ff(d, a, b, c, x[i+ <span class="hljs-number">1</span>], <span class="hljs-number">12</span>, -<span class="hljs-number">389564586</span>);    c = md5_ff(c, d, a, b, x[i+ <span class="hljs-number">2</span>], <span class="hljs-number">17</span>,  <span class="hljs-number">606105819</span>);    b = md5_ff(b, c, d, a, x[i+ <span class="hljs-number">3</span>], <span class="hljs-number">22</span>, -<span class="hljs-number">1044525330</span>);    a = md5_ff(a, b, c, d, x[i+ <span class="hljs-number">4</span>], <span class="hljs-number">7</span> , -<span class="hljs-number">176418897</span>);    d = md5_ff(d, a, b, c, x[i+ <span class="hljs-number">5</span>], <span class="hljs-number">12</span>,  <span class="hljs-number">1200080426</span>);    c = md5_ff(c, d, a, b, x[i+ <span class="hljs-number">6</span>], <span class="hljs-number">17</span>, -<span class="hljs-number">1473231341</span>);    b = md5_ff(b, c, d, a, x[i+ <span class="hljs-number">7</span>], <span class="hljs-number">22</span>, -<span class="hljs-number">45705983</span>);    a = md5_ff(a, b, c, d, x[i+ <span class="hljs-number">8</span>], <span class="hljs-number">7</span> ,  <span class="hljs-number">1770035416</span>);    d = md5_ff(d, a, b, c, x[i+ <span class="hljs-number">9</span>], <span class="hljs-number">12</span>, -<span class="hljs-number">1958414417</span>);    c = md5_ff(c, d, a, b, x[i+<span class="hljs-number">10</span>], <span class="hljs-number">17</span>, -<span class="hljs-number">42063</span>);    b = md5_ff(b, c, d, a, x[i+<span class="hljs-number">11</span>], <span class="hljs-number">22</span>, -<span class="hljs-number">1990404162</span>);    a = md5_ff(a, b, c, d, x[i+<span class="hljs-number">12</span>], <span class="hljs-number">7</span> ,  <span class="hljs-number">1804603682</span>);    d = md5_ff(d, a, b, c, x[i+<span class="hljs-number">13</span>], <span class="hljs-number">12</span>, -<span class="hljs-number">40341101</span>);    c = md5_ff(c, d, a, b, x[i+<span class="hljs-number">14</span>], <span class="hljs-number">17</span>, -<span class="hljs-number">1502002290</span>);    b = md5_ff(b, c, d, a, x[i+<span class="hljs-number">15</span>], <span class="hljs-number">22</span>,  <span class="hljs-number">1236535329</span>);    a = md5_gg(a, b, c, d, x[i+ <span class="hljs-number">1</span>], <span class="hljs-number">5</span> , -<span class="hljs-number">165796510</span>);    d = md5_gg(d, a, b, c, x[i+ <span class="hljs-number">6</span>], <span class="hljs-number">9</span> , -<span class="hljs-number">1069501632</span>);    c = md5_gg(c, d, a, b, x[i+<span class="hljs-number">11</span>], <span class="hljs-number">14</span>,  <span class="hljs-number">643717713</span>);    b = md5_gg(b, c, d, a, x[i+ <span class="hljs-number">0</span>], <span class="hljs-number">20</span>, -<span class="hljs-number">373897302</span>);    a = md5_gg(a, b, c, d, x[i+ <span class="hljs-number">5</span>], <span class="hljs-number">5</span> , -<span class="hljs-number">701558691</span>);    d = md5_gg(d, a, b, c, x[i+<span class="hljs-number">10</span>], <span class="hljs-number">9</span> ,  <span class="hljs-number">38016083</span>);    c = md5_gg(c, d, a, b, x[i+<span class="hljs-number">15</span>], <span class="hljs-number">14</span>, -<span class="hljs-number">660478335</span>);    b = md5_gg(b, c, d, a, x[i+ <span class="hljs-number">4</span>], <span class="hljs-number">20</span>, -<span class="hljs-number">405537848</span>);    a = md5_gg(a, b, c, d, x[i+ <span class="hljs-number">9</span>], <span class="hljs-number">5</span> ,  <span class="hljs-number">568446438</span>);    d = md5_gg(d, a, b, c, x[i+<span class="hljs-number">14</span>], <span class="hljs-number">9</span> , -<span class="hljs-number">1019803690</span>);    c = md5_gg(c, d, a, b, x[i+ <span class="hljs-number">3</span>], <span class="hljs-number">14</span>, -<span class="hljs-number">187363961</span>);    b = md5_gg(b, c, d, a, x[i+ <span class="hljs-number">8</span>], <span class="hljs-number">20</span>,  <span class="hljs-number">1163531501</span>);    a = md5_gg(a, b, c, d, x[i+<span class="hljs-number">13</span>], <span class="hljs-number">5</span> , -<span class="hljs-number">1444681467</span>);    d = md5_gg(d, a, b, c, x[i+ <span class="hljs-number">2</span>], <span class="hljs-number">9</span> , -<span class="hljs-number">51403784</span>);    c = md5_gg(c, d, a, b, x[i+ <span class="hljs-number">7</span>], <span class="hljs-number">14</span>,  <span class="hljs-number">1735328473</span>);    b = md5_gg(b, c, d, a, x[i+<span class="hljs-number">12</span>], <span class="hljs-number">20</span>, -<span class="hljs-number">1926607734</span>);    a = md5_hh(a, b, c, d, x[i+ <span class="hljs-number">5</span>], <span class="hljs-number">4</span> , -<span class="hljs-number">378558</span>);    d = md5_hh(d, a, b, c, x[i+ <span class="hljs-number">8</span>], <span class="hljs-number">11</span>, -<span class="hljs-number">2022574463</span>);    c = md5_hh(c, d, a, b, x[i+<span class="hljs-number">11</span>], <span class="hljs-number">16</span>,  <span class="hljs-number">1839030562</span>);    b = md5_hh(b, c, d, a, x[i+<span class="hljs-number">14</span>], <span class="hljs-number">23</span>, -<span class="hljs-number">35309556</span>);    a = md5_hh(a, b, c, d, x[i+ <span class="hljs-number">1</span>], <span class="hljs-number">4</span> , -<span class="hljs-number">1530992060</span>);    d = md5_hh(d, a, b, c, x[i+ <span class="hljs-number">4</span>], <span class="hljs-number">11</span>,  <span class="hljs-number">1272893353</span>);    c = md5_hh(c, d, a, b, x[i+ <span class="hljs-number">7</span>], <span class="hljs-number">16</span>, -<span class="hljs-number">155497632</span>);    b = md5_hh(b, c, d, a, x[i+<span class="hljs-number">10</span>], <span class="hljs-number">23</span>, -<span class="hljs-number">1094730640</span>);    a = md5_hh(a, b, c, d, x[i+<span class="hljs-number">13</span>], <span class="hljs-number">4</span> ,  <span class="hljs-number">681279174</span>);    d = md5_hh(d, a, b, c, x[i+ <span class="hljs-number">0</span>], <span class="hljs-number">11</span>, -<span class="hljs-number">358537222</span>);    <span class="hljs-comment">// 注释掉的是默认值</span>    <span class="hljs-comment">// c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);</span>    c = md5_hh(c, d, a, b, x[i+ <span class="hljs-number">3</span>], <span class="hljs-number">16</span>, -<span class="hljs-number">722521939</span>);    <span class="hljs-comment">// b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);</span>    b = md5_hh(b, c, d, a, x[i+ <span class="hljs-number">6</span>], <span class="hljs-number">23</span>,  <span class="hljs-number">76029185</span>);    a = md5_hh(a, b, c, d, x[i+ <span class="hljs-number">9</span>], <span class="hljs-number">4</span> , -<span class="hljs-number">640364487</span>);    d = md5_hh(d, a, b, c, x[i+<span class="hljs-number">12</span>], <span class="hljs-number">11</span>, -<span class="hljs-number">421815835</span>);    c = md5_hh(c, d, a, b, x[i+<span class="hljs-number">15</span>], <span class="hljs-number">16</span>,  <span class="hljs-number">530742520</span>);    b = md5_hh(b, c, d, a, x[i+ <span class="hljs-number">2</span>], <span class="hljs-number">23</span>, -<span class="hljs-number">995338651</span>);    a = md5_ii(a, b, c, d, x[i+ <span class="hljs-number">0</span>], <span class="hljs-number">6</span> , -<span class="hljs-number">198630844</span>);    d = md5_ii(d, a, b, c, x[i+ <span class="hljs-number">7</span>], <span class="hljs-number">10</span>,  <span class="hljs-number">1126891415</span>);    c = md5_ii(c, d, a, b, x[i+<span class="hljs-number">14</span>], <span class="hljs-number">15</span>, -<span class="hljs-number">1416354905</span>);    b = md5_ii(b, c, d, a, x[i+ <span class="hljs-number">5</span>], <span class="hljs-number">21</span>, -<span class="hljs-number">57434055</span>);    a = md5_ii(a, b, c, d, x[i+<span class="hljs-number">12</span>], <span class="hljs-number">6</span> ,  <span class="hljs-number">1700485571</span>);    d = md5_ii(d, a, b, c, x[i+ <span class="hljs-number">3</span>], <span class="hljs-number">10</span>, -<span class="hljs-number">1894986606</span>);    c = md5_ii(c, d, a, b, x[i+<span class="hljs-number">10</span>], <span class="hljs-number">15</span>, -<span class="hljs-number">1051523</span>);    b = md5_ii(b, c, d, a, x[i+ <span class="hljs-number">1</span>], <span class="hljs-number">21</span>, -<span class="hljs-number">2054922799</span>);    a = md5_ii(a, b, c, d, x[i+ <span class="hljs-number">8</span>], <span class="hljs-number">6</span> ,  <span class="hljs-number">1873313359</span>);    d = md5_ii(d, a, b, c, x[i+<span class="hljs-number">15</span>], <span class="hljs-number">10</span>, -<span class="hljs-number">30611744</span>);    c = md5_ii(c, d, a, b, x[i+ <span class="hljs-number">6</span>], <span class="hljs-number">15</span>, -<span class="hljs-number">1560198380</span>);    b = md5_ii(b, c, d, a, x[i+<span class="hljs-number">13</span>], <span class="hljs-number">21</span>,  <span class="hljs-number">1309151649</span>);    a = md5_ii(a, b, c, d, x[i+ <span class="hljs-number">4</span>], <span class="hljs-number">6</span> , -<span class="hljs-number">145523070</span>);    d = md5_ii(d, a, b, c, x[i+<span class="hljs-number">11</span>], <span class="hljs-number">10</span>, -<span class="hljs-number">1120210379</span>);    c = md5_ii(c, d, a, b, x[i+ <span class="hljs-number">2</span>], <span class="hljs-number">15</span>,  <span class="hljs-number">718787259</span>);    b = md5_ii(b, c, d, a, x[i+ <span class="hljs-number">9</span>], <span class="hljs-number">21</span>, -<span class="hljs-number">343485551</span>);    a = safe_add(a, olda);    b = safe_add(b, oldb);    c = safe_add(c, oldc);    d = safe_add(d, oldd);  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>(a, b, c, d);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * These functions implement the four basic operations the algorithm uses.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">md5_cmn</span>(<span class="hljs-params">q, a, b, x, s, t</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">md5_ff</span>(<span class="hljs-params">a, b, c, d, x, s, t</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> md5_cmn((b &amp; c) | ((~b) &amp; d), a, b, x, s, t);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">md5_gg</span>(<span class="hljs-params">a, b, c, d, x, s, t</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> md5_cmn((b &amp; d) | (c &amp; (~d)), a, b, x, s, t);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">md5_hh</span>(<span class="hljs-params">a, b, c, d, x, s, t</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> md5_cmn(b ^ c ^ d, a, b, x, s, t);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">md5_ii</span>(<span class="hljs-params">a, b, c, d, x, s, t</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> md5_cmn(c ^ (b | (~d)), a, b, x, s, t);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Add integers, wrapping at 2^32. This uses 16-bit operations internally</span><span class="hljs-comment"> * to work around bugs in some JS interpreters.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safe_add</span>(<span class="hljs-params">x, y</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">var</span> lsw = (x &amp; <span class="hljs-number">0xFFFF</span>) + (y &amp; <span class="hljs-number">0xFFFF</span>);  <span class="hljs-keyword">var</span> msw = (x &gt;&gt; <span class="hljs-number">16</span>) + (y &gt;&gt; <span class="hljs-number">16</span>) + (lsw &gt;&gt; <span class="hljs-number">16</span>);  <span class="hljs-keyword">return</span> (msw &lt;&lt; <span class="hljs-number">16</span>) | (lsw &amp; <span class="hljs-number">0xFFFF</span>);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Bitwise rotate a 32-bit number to the left.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bit_rol</span>(<span class="hljs-params">num, cnt</span>)</span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (<span class="hljs-number">32</span> - cnt));&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSignature</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> hex_md5(<span class="hljs-built_in">Date</span>.parse(<span class="hljs-built_in">Date</span>()).toString())&#125;<span class="hljs-built_in">console</span>.log(getSignature())</code></pre><p>Python 调用代码：</p><pre><code class="hljs python"><span class="hljs-comment"># ==================================</span><span class="hljs-comment"># --*-- coding: utf-8 --*--</span><span class="hljs-comment"># @Time    : 2021-12-23</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: challenge_7.py</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ==================================</span><span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> execjs<span class="hljs-keyword">import</span> requestschallenge_api = <span class="hljs-string">&quot;http://spider.wangluozhe.com/challenge/api/7&quot;</span>headers = &#123;    <span class="hljs-string">&quot;Cookie&quot;</span>: <span class="hljs-string">&quot;Cookie 替换成你的&quot;</span>,    <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;spider.wangluozhe.com&quot;</span>,    <span class="hljs-string">&quot;Origin&quot;</span>: <span class="hljs-string">&quot;http://spider.wangluozhe.com&quot;</span>,    <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;http://spider.wangluozhe.com/challenge/7&quot;</span>,    <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&quot;</span>,    <span class="hljs-string">&quot;X-Requested-With&quot;</span>: <span class="hljs-string">&quot;XMLHttpRequest&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_signature</span>():</span>    now = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(time.time())) + <span class="hljs-string">&quot;000&quot;</span>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;challenge_7.js&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:        wlz_js = execjs.<span class="hljs-built_in">compile</span>(f.read())    <span class="hljs-comment"># signature = wlz_js.call(&quot;getSignature&quot;)</span>    signature = wlz_js.call(<span class="hljs-string">&quot;hex_md5&quot;</span>, now)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;signature: &quot;</span>, signature)    <span class="hljs-keyword">return</span> signature<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>    result = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>):        data = &#123;            <span class="hljs-string">&quot;page&quot;</span>: page,            <span class="hljs-string">&quot;count&quot;</span>: <span class="hljs-number">10</span>,            <span class="hljs-string">&quot;_signature&quot;</span>: get_signature()        &#125;        response = requests.post(url=challenge_api, headers=headers, data=data).json()        <span class="hljs-built_in">print</span>(response)        <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> response[<span class="hljs-string">&quot;data&quot;</span>]:            result += d[<span class="hljs-string">&quot;value&quot;</span>]    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;结果为: &quot;</span>, result)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    main()</code></pre><p>这里还有一点小细节，如果是 Python 生成时间戳传入 JS 的 <code>hex_md5</code> 方法的话，要保证时间戳的最后三位为0，不然校验通不过，通常的写法是 <code>str(int(time.time() * 1000))</code>，这里要改一下：<code>str(int(time.time())) + &quot;000&quot;</code>，不用 Python 的话，也可以在 JS 里写个方法直接返回 <code>hex_md5(Date.parse(Date()).toString())</code> 也行。</p><p><strong>还有一个问题就是如果你找的 MD5 代码不规范，准确来说是和题目使用的 MD5 代码不太一样的话，有可能本地要改的地方就不止这两处了，所以尽量找一个方法名都一样的JS，能省不少事儿。</strong></p><h3><span id="ri-zhi-duan-dian-cha-zhuang-diao-shi">日志断点 / 插桩调试</span></h3><p>除了 Hook 以外，我们还可以通过插桩调试的方式，将整个生成 <code>_signature</code> 的流程、涉及到的参数、生成的值，都通过日志的形式打印出来，逆向分析其逻辑。PS：插桩，即日志断点，鼠标右键选择 <code>Add logpoint</code> 即可添加一个日志断点，相当于 <code>console.log()</code>，此功能是 Chrome 73 版本新增的。</p><p><img src="https://cdn.itbob.cn/img/article/050/11.png" alt="11"></p><ul><li><strong>Add breakpoint</strong>：添加普通断点；</li><li><strong>Add conditional breakpoint</strong>：添加条件断点，满足条件才断下；</li><li><strong>Add logpoint</strong>：添加日志断点；</li><li><strong>Never pause here</strong>：永不在此处断下；</li><li><strong>Add script to ignore list</strong>：网站的部分 JS，比如 <code>jquery.min.js</code> 之类的库文件，我们单步调试的时候并不想进入到该文件中，那么可以将此类文件右键添加忽略掉。</li></ul><p>关键的日志断点有以下三处：</p><ul><li>第 605 行，<code>arguments</code> 为当前传入函数的参数值；</li><li>第 141 行，<code>___.join(vV_)</code> 为当前调用的方法名称，也会输出方法中的参数名称；</li><li>第 591 行，<code>__V(_, ___(u_), 0, 0, _U__).apply(void 0, y__(v___))</code> 为当前方法执行完毕的结果。</li></ul><p>肯定有人会疑惑，如何知道应该在这三个地方下日志断点呢？答案是只能自己单步、多步调试，找规律、仔细观察，就像交流群里的小小白大佬说的一样，屁股坐烂就行了。当然也不是只有这三个地方能输出对应的信息，有可能其他地方也可以，这就要看你自己调试了。</p><p><img src="https://cdn.itbob.cn/img/article/050/12.png" alt="12"></p><p><img src="https://cdn.itbob.cn/img/article/050/13.png" alt="13"></p><p><img src="https://cdn.itbob.cn/img/article/050/14.png" alt="14"></p><p>除了这三个地方的日志断点以外，建议还可以在第 606 行打个断点，这样每次执行一个方法就断下，本地就可以跟着同步调试，挨个对比传入的参数和得到的结果，不至于一下子输出的东西太多，不方便查找。</p><p>第一步，<code>gnature = window.byted_acrawler(window.sign())</code>：</p><p><img src="https://cdn.itbob.cn/img/article/050/15.png" alt="15"></p><p>下一步，sign 方法，取时间戳：</p><p><img src="https://cdn.itbob.cn/img/article/050/16.png" alt="16"></p><p>下一步，调用 <code>hex_md5()</code> 方法：</p><p><img src="https://cdn.itbob.cn/img/article/050/17.png" alt="17"></p><p>从这里就可以开始本地同步调试了，本地 MD5 下断点调试，可以看到得到的值不一样：</p><p><img src="https://cdn.itbob.cn/img/article/050/18.png" alt="18"></p><p>下一步，调用 <code>str2binl()</code> 方法，和本地得到的值是一样的：</p><p><img src="https://cdn.itbob.cn/img/article/050/19.png" alt="19"></p><p><img src="https://cdn.itbob.cn/img/article/050/20.png" alt="20"></p><p>下一步，调用 <code>core_md5()</code> 方法，得到的值和本地就不一样了，这里大致可以确定此方法内部与标准算法有差别了：</p><p><img src="https://cdn.itbob.cn/img/article/050/21.png" alt="21"></p><p><img src="https://cdn.itbob.cn/img/article/050/22.png" alt="22"></p><p>下一步，调用 <code>md5_ff()</code> 方法，得到的值是一样的：</p><p><img src="https://cdn.itbob.cn/img/article/050/23.png" alt="23"></p><p><img src="https://cdn.itbob.cn/img/article/050/24.png" alt="24"></p><p>以此类推，最终会找到两个不一样的地方，即 <code>md5_hh()</code> 两个默认参数被修改了。</p><p><code>-722521979</code> 被改成了 <code>-722521939</code>：</p><p><img src="https://cdn.itbob.cn/img/article/050/25.png" alt="25"></p><p><img src="https://cdn.itbob.cn/img/article/050/26.png" alt="26"></p><p><code>76029189</code> 被改成了 <code>76029185</code>：</p><p><img src="https://cdn.itbob.cn/img/article/050/27.png" alt="27"></p><p><img src="https://cdn.itbob.cn/img/article/050/28.png" alt="28"></p><p>最终提交结果，验证成功：</p><p><img src="https://cdn.itbob.cn/img/article/050/29.png" alt="29"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/javascript_reverse.png&quot; alt=&quot;javascript_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>拉勾网 traceparent、__lg_stoken__、X-S-HEADER 等参数逆向分析</title>
    <link href="https://www.itbob.cn/article/049/"/>
    <id>https://www.itbob.cn/article/049/</id>
    <published>2022-03-16T04:18:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/javascript_reverse.png" alt="javascript_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#zhua-bao-fen-xi">抓包分析</a></li><li><a href="#cookies-can-shu">Cookies 参数</a><ul><li><a href="#user-trace-token">user_trace_token</a></li><li><a href="#x-http-token">X_HTTP_TOKEN</a></li><li><a href="#lg-stoken">__lg_stoken__</a></li></ul></li><li><a href="#qing-qiu-tou-can-shu">请求头参数</a><ul><li><a href="#x-anit-forge-code-x-anit-forge-token">x-anit-forge-code / x-anit-forge-token</a></li><li><a href="#traceparent">traceparent</a></li><li><a href="#x-k-header-x-ss-req-header">X-K-HEADER / X-SS-REQ-HEADER</a></li><li><a href="#x-s-header">X-S-HEADER</a></li></ul></li><li><a href="#qing-qiu-fan-hui-shu-ju-jie-mi">请求/返回数据解密</a></li><li><a href="#ni-xiang-xiao-ji-qiao">逆向小技巧</a></li><li><a href="#wan-zheng-dai-ma">完整代码</a></li><li><a href="#chang-jian-wen-ti">常见问题</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><p>本次的目标是拉勾网职位的爬取，涉及到的一些关键参数如下：</p><ul><li>请求头参数：<code>traceparent</code>、<code>X-K-HEADER</code>、<code>X-S-HEADER</code>、<code>X-SS-REQ-HEADER</code>、<code>x-anit-forge-code</code>、<code>x-anit-forge-token</code></li><li>Cookie 值：<code>user_trace_token</code>、<code>X_HTTP_TOKEN</code>、<code>__lg_stoken__</code></li><li>POST 请求数据加密，返回的加密职位信息解密，AES 算法</li></ul><p>参数比较多，但事实上有些参数固定、或者直接不要，也是可以的，比如 Cookie 的三个值，请求头的 <code>X-K-HEADER</code>、<code>X-SS-REQ-HEADER</code> 等可以固定，<code>x-anit-forge-code</code> 和 <code>x-anit-forge-token</code> 可有可无。尽管如此，本文还是把每个参数的来源都分析了，可根据你实际情况灵活处理。</p><p>另外即便是把所有参数都补齐了，拉勾网对于单个 IP 还有频率限制，抓不了几次就要求登录，可自行搭配代理进行抓取，或者复制账号登录后的 cookies 到代码里，可以解除限制，如果是账号登录后访问，请求头多了两个参数，即 <code>x-anit-forge-code</code> 和 <code>x-anit-forge-token</code>，经过测试这两个参数其实不要也行。</p><h2><span id="zhua-bao-fen-xi">抓包分析</span></h2><p>搜索职位，点击翻页，就可以看到一条名为 positionAjax.json 的 Ajax 请求，不难判断这就是返回的职位信息。重点参数已在图中框出来了。</p><p>未登录，正常 IP，正常请求，Header 以及 Cookies：</p><p><img src="https://cdn.itbob.cn/img/article/049/01.png" alt="01"></p><p><img src="https://cdn.itbob.cn/img/article/049/02.png" alt="02"></p><p>异常 IP，登录账号后再请求，Header 以及 Cookies：</p><p><img src="https://cdn.itbob.cn/img/article/049/03.png" alt="03"></p><p><img src="https://cdn.itbob.cn/img/article/049/04.png" alt="04"></p><p>请求数据和返回数据都经过了加密：</p><p><img src="https://cdn.itbob.cn/img/article/049/05.png" alt="05"></p><h2><span id="cookies-can-shu">Cookies 参数</span></h2><p>先看 cookies 里的关键参数，主要是 <code>user_trace_token</code>、<code>X_HTTP_TOKEN</code> 和 <code>__lg_stoken__</code>。</p><h3><span id="user-trace-token">user_trace_token</span></h3><p>通过接口返回的，直接搜索就可以找到，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/049/06.png" alt="06"></p><p><img src="https://cdn.itbob.cn/img/article/049/07.png" alt="07"></p><p>请求参数，time 是时间戳，a 值随便，没有都可以，不影响，其他值都是定值，获取的关键代码如下：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user_trace_token</span>() -&gt; <span class="hljs-built_in">str</span>:</span>    <span class="hljs-comment"># 获取 cookie 中的 user_trace_token</span>    json_url = <span class="hljs-string">&quot;https://a.脱敏处理.com/json&quot;</span>    headers = &#123;        <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;a.脱敏处理.com&quot;</span>,        <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com/&quot;</span>,        <span class="hljs-string">&quot;User-Agent&quot;</span>: UA    &#125;    params = &#123;        <span class="hljs-string">&quot;lt&quot;</span>: <span class="hljs-string">&quot;trackshow&quot;</span>,        <span class="hljs-string">&quot;t&quot;</span>: <span class="hljs-string">&quot;ad&quot;</span>,        <span class="hljs-string">&quot;v&quot;</span>: <span class="hljs-number">0</span>,        <span class="hljs-string">&quot;dl&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com/&quot;</span>,        <span class="hljs-string">&quot;dr&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com&quot;</span>,        <span class="hljs-string">&quot;time&quot;</span>: <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(time.time() * <span class="hljs-number">1000</span>))    &#125;    response = requests.get(url=json_url, headers=headers, params=params)    user_trace_token = response.cookies.get_dict()[<span class="hljs-string">&quot;user_trace_token&quot;</span>]    <span class="hljs-keyword">return</span> user_trace_token</code></pre><h3><span id="x-http-token">X_HTTP_TOKEN</span></h3><p>直接搜索没有值，直接上 Hook 大法，小白朋友不清楚的话可以看以前的文章，都有详细教程，这里不再细说。</p><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-meta">    &#x27;use strict&#x27;</span>;    <span class="hljs-keyword">var</span> cookieTemp = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">document</span>, <span class="hljs-string">&#x27;cookie&#x27;</span>, &#123;        <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hook捕获到cookie设置-&gt;&#x27;</span>, val);            <span class="hljs-keyword">if</span> (val.indexOf(<span class="hljs-string">&#x27;X_HTTP_TOKEN&#x27;</span>) != -<span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">debugger</span>;            &#125;            cookieTemp = val;            <span class="hljs-keyword">return</span> val;        &#125;,        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">return</span> cookieTemp;        &#125;    &#125;);&#125;)();</code></pre><p><img src="https://cdn.itbob.cn/img/article/049/08.png" alt="08"></p><p>往上跟栈调试，是一个小小的 OB 混淆，<code>_0x32e0d2</code> 就是最后的 <code>X_HTTP_TOKEN</code> 值了，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/049/09.png" alt="09"></p><p>直接梭哈，才300多行，不必扣了，全部 copy 下来，本地运行，发现会报错 document 未定义，定位到代码位置，下断点调试一下，发现是正则匹配 cookie 中的 <code>user_trace_token</code> 的值，那么我们直接定义一下即可：<code>var document = &#123;&quot;cookie&quot;: cookie&#125;</code>，cookie 值把 <code>user_trace_token</code> 传过来即可。</p><p><img src="https://cdn.itbob.cn/img/article/049/10.png" alt="10"></p><p>补全 document 后，再次运行，又会报错 window 未定义，再次定位到源码，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/049/11.png" alt="11"></p><p>分析一下，取了 window XMLHttpRequest 对象，向 wafcheck.json 这个接口发送了一个 Ajax GET 请求，然后取了 Response Header 的 Date 值赋值给 <code>_0x309ac8</code>，注意这个 Date 值比正常时间晚了8个小时，然而取 Date 值并没有什么用，因为后面又 new 了一个新 Date 标准时间，赋值给了 <code>_0x150c4d</code>，<code>new Date(_0x309ac8[_0x3551('0x2d')](/-/g, '/'))</code> 语句虽然用到了前面的旧 Date，然而实际上是 <code>replace()</code> 替换方法，与旧的 Date 并没有什么关系，然后调用 <code>Date.parse()</code> 方法将新 Date 转换成时间戳赋值给 <code>_0x4e6d5d</code>，所以不需要这么复杂，直接本地把 <code>_0x89ea429</code> 方法修改一下就行了：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 原方法</span><span class="hljs-comment">// function _0x89ea42() &#123;</span><span class="hljs-comment">//     var _0x372cc0 = null;</span><span class="hljs-comment">//     if (window[_0x3551(&#x27;0x26&#x27;)]) &#123;</span><span class="hljs-comment">//         _0x372cc0 = new window[(_0x3551(&#x27;0x26&#x27;))]();</span><span class="hljs-comment">//     &#125; else &#123;</span><span class="hljs-comment">//         _0x372cc0 = new ActiveObject(_0x3551(&#x27;0x27&#x27;));</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">//     _0x372cc0[_0x3551(&#x27;0x28&#x27;)](_0x3551(&#x27;0x29&#x27;), _0x3551(&#x27;0x2a&#x27;), ![]);</span><span class="hljs-comment">//     _0x372cc0[_0x3551(&#x27;0x2b&#x27;)](null);</span><span class="hljs-comment">//     var _0x309ac8 = _0x372cc0[_0x3551(&#x27;0x2c&#x27;)](&#x27;Date&#x27;);</span><span class="hljs-comment">//     var _0x150c4d = new Date(_0x309ac8[_0x3551(&#x27;0x2d&#x27;)](/-/g, &#x27;/&#x27;));</span><span class="hljs-comment">//     var _0x4e6d5d = Date[_0x3551(&#x27;0x2e&#x27;)](_0x150c4d);</span><span class="hljs-comment">//     return _0x4e6d5d / 0x3e8;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// 本地改写</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x89ea42</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> _0x150c4d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();    <span class="hljs-keyword">var</span> _0x4e6d5d = <span class="hljs-built_in">Date</span>.parse(_0x150c4d);    <span class="hljs-keyword">return</span> _0x4e6d5d / <span class="hljs-number">0x3e8</span>;&#125;</code></pre><p>本地测试 OK：</p><p><img src="https://cdn.itbob.cn/img/article/049/12.png" alt="12"></p><h3><span id="lg-stoken">__lg_stoken__</span></h3><p><code>__lg_stoken__</code> 这个参数是在点击搜索后才开始生成的，直接搜索同样没值，Hook 一下，往上跟栈，很容易找到生成位置：</p><p><img src="https://cdn.itbob.cn/img/article/049/13.png" alt="13"></p><p><img src="https://cdn.itbob.cn/img/article/049/14.png" alt="14"></p><p>可以看到 d 就是 <code>__lg_stoken__</code> 的值，<code>d = (new g()).a()</code>、<code>g = window.gt</code>，<code>window.gt</code> 实际上是调用了 <code>_0x11db59</code></p><p>跟进混淆的 JS 看一下，就会发现末尾的这段代码是关键，这里用到了 prototype 原型对象，我们直接 <code>window.gt.prototype.a()</code> 或者 <code>(new window.gt).a()</code> 就能获取到 <code>__lg_stoken__</code>，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/049/15.png" alt="15"></p><p>到这里也许你想下断点去调试一下，看看能不能扣个逻辑出来，但是你会发现刷新之后断不下，因为这个混淆 JS 文件是一直在变化的，之前的断点就不管用了，然后你就可能会想到直接替换掉这个 JS，让文件名固定下来，就可以断点调试了，如果你这样操作的话，重新刷新会发现一直在加载中，打开控制台会发现报错了，造成这样的原因就在于这个混淆 JS 不仅文件名会改变，他的内容也会改变，当然，内容也不仅仅是改变了变量名那么简单，有些值也是动态变化的，比如：</p><p><img src="https://cdn.itbob.cn/img/article/049/16.png" alt="16"></p><p>这里我们先不管那么多，直接把所有的混淆代码 copy 下来，先在本地调试一下，看看能不能跑通，调试过程中，先后会提示 <code>window is not defined</code>、<code>Cannot read properties of undefined (reading 'hostname')</code>，定位到代码，有个取 <code>window.location.hostname</code> 的操作，本地定义一下就行了：</p><p><img src="https://cdn.itbob.cn/img/article/049/17.png" alt="17"></p><p>再次调试又会报错 <code> Cannot read properties of undefined (reading 'substr')</code>，<code>substr()</code> 方法可在字符串中抽取从指定下标开始的、指定数目的字符，是字符串对象 stringObject 具有的方法，我们定位到代码，发现是 <code>window.location.search</code> 对象调用了 <code>substr()</code> 方法，所以同样的，我们本地也要补齐。</p><p><img src="https://cdn.itbob.cn/img/article/049/18.png" alt="18"></p><p>本地补齐参数后，运行结果与网页一致：</p><p><img src="https://cdn.itbob.cn/img/article/049/19.png" alt="19"></p><p>执行结果没问题了，那么还有一个问题，<code>window.location.search</code> 的值就是待加密参数了，是咋来的呢？我们直接搜索，就可以看到是一个接口302跳转的地址，用的时候直接取就行了，这个接口是你搜索内容组成的，搜索不同参数，这个跳转地址也是不一样的：</p><p><img src="https://cdn.itbob.cn/img/article/049/20.png" alt="20"></p><p>调试成功后，我们随便换一个搜索关键词，将得到的302跳转地址拿到这个 JS 中，加密一下，发现会报错，这说明混淆 JS 传入的参数和 JS 内容应该是相对应的，这里的做法是直接请求拿到这个 JS 文件内容，然后把要补的 window 和获取 <code>__lg_stoken__</code> 的方法加进去，然后直接执行就行了。</p><p>获取 <code>__lg_stoken__</code>  的关键代码如下（<code>original_data</code> 为原始搜索数据）：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_lg_stoken</span>(<span class="hljs-params">original_data: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">str</span>:</span>    <span class="hljs-comment"># 获取 cookie 中的 __lg_stoken__</span>    token_url = <span class="hljs-string">&quot;https://www.脱敏处理.com/wn/jobs&quot;</span>    token_headers = &#123;        <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.com&quot;</span>,        <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com/&quot;</span>,        <span class="hljs-string">&quot;User-Agent&quot;</span>: UA    &#125;    params = &#123;        <span class="hljs-string">&quot;kd&quot;</span>: original_data[<span class="hljs-string">&quot;kd&quot;</span>],        <span class="hljs-string">&quot;city&quot;</span>: original_data[<span class="hljs-string">&quot;city&quot;</span>]    &#125;    token_response = requests.get(url=token_url, params=params, headers=token_headers, cookies=global_cookies, allow_redirects=<span class="hljs-literal">False</span>)    <span class="hljs-keyword">if</span> token_response.status_code != <span class="hljs-number">302</span>:        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;获取跳转链接异常！检查 global_cookies 是否已包含 __lg_stoken__！&quot;</span>)    <span class="hljs-comment"># 获取 302 跳转的地址</span>    security_check_url = token_response.headers[<span class="hljs-string">&quot;Location&quot;</span>]    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;login&quot;</span> <span class="hljs-keyword">in</span> security_check_url:        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;IP 被关进小黑屋啦！需要登录！请补全登录后的 Cookie，或者自行添加代理！&quot;</span>)    parse_result = parse.urlparse(security_check_url)    <span class="hljs-comment"># url 的参数为待加密对象</span>    security_check_params = parse_result.query    <span class="hljs-comment"># 取 name 参数，为混淆 js 的文件名</span>    security_check_js_name = parse.parse_qs(security_check_params)[<span class="hljs-string">&quot;name&quot;</span>][<span class="hljs-number">0</span>]    <span class="hljs-comment"># 发送请求，获取混淆的 js</span>    js_url = <span class="hljs-string">&quot;https://www.脱敏处理.com/common-sec/dist/&quot;</span> + security_check_js_name + <span class="hljs-string">&quot;.js&quot;</span>    js_headers = &#123;        <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.com&quot;</span>,        <span class="hljs-string">&quot;Referer&quot;</span>: security_check_url,        <span class="hljs-string">&quot;User-Agent&quot;</span>: UA    &#125;    js_response = requests.get(url=js_url, headers=js_headers, cookies=global_cookies).text    <span class="hljs-comment"># 补全 js，添加 window 参数和一个方法，用于获取 __lg_stoken__ 的值</span>    lg_js = <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    window = &#123;</span><span class="hljs-string">        &quot;location&quot;: &#123;</span><span class="hljs-string">            &quot;hostname&quot;: &quot;www.脱敏处理.com&quot;,</span><span class="hljs-string">            &quot;search&quot;: &#x27;?%s&#x27;</span><span class="hljs-string">        &#125;</span><span class="hljs-string">    &#125;</span><span class="hljs-string">    function getLgStoken()&#123;</span><span class="hljs-string">        return window.gt.prototype.a()</span><span class="hljs-string">    &#125;</span><span class="hljs-string">    &quot;&quot;&quot;</span> % security_check_params + js_response    lg_stoken = execjs.<span class="hljs-built_in">compile</span>(lg_js).call(<span class="hljs-string">&quot;getLgStoken&quot;</span>)    <span class="hljs-keyword">return</span> lg_stoken</code></pre><h2><span id="qing-qiu-tou-can-shu">请求头参数</span></h2><p>请求头参数比较多，有 <code>traceparent</code>、<code>X-K-HEADER</code>、<code>X-S-HEADER</code>、<code>X-SS-REQ-HEADER</code>、<code>x-anit-forge-code</code>、<code>x-anit-forge-token</code>，其中最后两个 <code>x-anit</code> 开头的参数是登录后才有的，实际测试中，即便是登录了，不加这两个好像也行。不过还是分析一下吧。</p><h3><span id="x-anit-forge-code-x-anit-forge-token">x-anit-forge-code / x-anit-forge-token</span></h3><p>这两个值是首次点击搜索生成的，第一次访问搜索接口，返回的 HTML 里面夹杂了一个 JSON 文件，里面的 <code>submitCode</code> 和 <code>submitToken</code> 就是 <code>x-anit-forge-code</code> 和 <code>x-anit-forge-token</code> 的值，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/049/21.png" alt="21"></p><p>请求这个接口要注意带上登录后的 cookies，有用的只有四个值，正确的 cookies 类似于：</p><pre><code class="hljs python">cookies = &#123;    <span class="hljs-string">&quot;login&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>,    <span class="hljs-string">&quot;gate_login_token&quot;</span>: <span class="hljs-string">&quot;54a31e93aa904a6bb9731bxxxxxxxxxxxxxx&quot;</span>,    <span class="hljs-string">&quot;_putrc&quot;</span>: <span class="hljs-string">&quot;9550E53D830BE8xxxxxxxxxxxxxx&quot;</span>,    <span class="hljs-string">&quot;JSESSIONID&quot;</span>: <span class="hljs-string">&quot;ABAAAECABIEACCA79BFxxxxxxxxxxxxxx&quot;</span>&#125;</code></pre><p>注意，JSESSIONID 即便不登录也会有，但是登录时应该会携带这个值，进行一个激活操作，如果你请求获取到的 submitCode、submitToken 为空，那么就有可能 JSESSIONID 是无效的，以上所有值都必须登录后复制过来！</p><p>获取 <code> x-anit-forge-code</code>、<code>x-anit-forge-token</code>  的关键代码如下（<code>original_data</code> 为原始搜索数据）：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_x_anit</span>(<span class="hljs-params">original_data: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-literal">None</span>:</span>    <span class="hljs-comment"># 更新 x-anit-forge-code 和 x-anit-forge-token</span>    url = <span class="hljs-string">&quot;https://www.脱敏处理.com/wn/jobs&quot;</span>    headers = &#123;        <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.com&quot;</span>,        <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com/&quot;</span>,        <span class="hljs-string">&quot;User-Agent&quot;</span>: UA    &#125;    params = &#123;        <span class="hljs-string">&quot;kd&quot;</span>: original_data[<span class="hljs-string">&quot;kd&quot;</span>],        <span class="hljs-string">&quot;city&quot;</span>: original_data[<span class="hljs-string">&quot;city&quot;</span>]    &#125;    response = requests.get(url=url, params=params, headers=headers, cookies=global_cookies)    tree = etree.HTML(response.text)    next_data_json = json.loads(tree.xpath(<span class="hljs-string">&quot;//script[@id=&#x27;__NEXT_DATA__&#x27;]/text()&quot;</span>)[<span class="hljs-number">0</span>])    submit_code = next_data_json[<span class="hljs-string">&quot;props&quot;</span>][<span class="hljs-string">&quot;tokenData&quot;</span>][<span class="hljs-string">&quot;submitCode&quot;</span>]    submit_token = next_data_json[<span class="hljs-string">&quot;props&quot;</span>][<span class="hljs-string">&quot;tokenData&quot;</span>][<span class="hljs-string">&quot;submitToken&quot;</span>]    <span class="hljs-comment"># 注意 JSESSIONID 必须是登录验证后的！</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> submit_code <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> submit_token:        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;submitCode &amp; submitToken 为空，请检查 JSESSIONID 是否正确！&quot;</span>)    <span class="hljs-keyword">global</span> x_anit    x_anit[<span class="hljs-string">&quot;x-anit-forge-code&quot;</span>] = submit_code    x_anit[<span class="hljs-string">&quot;x-anit-forge-token&quot;</span>] = submit_token</code></pre><h3><span id="traceparent">traceparent</span></h3><p>同样的 Hook 大法，跟栈：</p><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> org = <span class="hljs-built_in">window</span>.XMLHttpRequest.prototype.setRequestHeader;    <span class="hljs-built_in">window</span>.XMLHttpRequest.prototype.setRequestHeader = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key, value</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hook 捕获到 %s 设置 -&gt; %s&#x27;</span>, key, value);        <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&#x27;traceparent&#x27;</span>) &#123;            <span class="hljs-keyword">debugger</span>;        &#125;        <span class="hljs-keyword">return</span> org.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);    &#125;;&#125;)();</code></pre><p><img src="https://cdn.itbob.cn/img/article/049/22.png" alt="22"></p><p><img src="https://cdn.itbob.cn/img/article/049/23.png" alt="23"></p><p>观察上面的代码，三元表达式，<code>t.sampled</code> 为 <code>true</code>，所以 <code>e</code> 值为 <code>01</code>，<code>n</code> 值为 <code>t.id</code>，重点在于 <code>t.traceId</code> 和 <code>t.id</code> 了，跟栈发现很难调，直接搜索关键字，可找到生成的位置：</p><p><img src="https://cdn.itbob.cn/img/article/049/24.png" alt="24"></p><p><img src="https://cdn.itbob.cn/img/article/049/25.png" alt="25"></p><p>把 <code>E()</code> 方法扣出来就行了，改写一下即可：</p><pre><code class="hljs javascript">getRandomValues = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;get-random-values&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">E</span>(<span class="hljs-params">t</span>) </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> b = [], w = <span class="hljs-number">0</span>; w &lt; <span class="hljs-number">256</span>; ++w)            b[w] = (w + <span class="hljs-number">256</span>).toString(<span class="hljs-number">16</span>).substr(<span class="hljs-number">1</span>);    <span class="hljs-keyword">var</span> T = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">16</span>);    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t</span>) </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e = [], n = <span class="hljs-number">0</span>; n &lt; t.length; n++)            e.push(b[t[n]]);        <span class="hljs-keyword">return</span> e.join(<span class="hljs-string">&quot;&quot;</span>)    &#125;(getRandomValues(T)).substr(<span class="hljs-number">0</span>, t)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTraceparent</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;00-&quot;</span> + E() + <span class="hljs-string">&quot;-&quot;</span> + E(<span class="hljs-number">16</span>) + <span class="hljs-string">&quot;-&quot;</span> + <span class="hljs-string">&quot;01&quot;</span>&#125;<span class="hljs-comment">// 测试输出</span><span class="hljs-comment">// console.log(getTraceparent())</span></code></pre><h3><span id="x-k-header-x-ss-req-header">X-K-HEADER / X-SS-REQ-HEADER</span></h3><p><code>X-K-HEADER</code> 和 <code>X-SS-REQ-HEADER</code> 数据是一样的，只不过后者是键值对形式，先直接全局搜索关键字，发现都是从本地拿这两个值，清除 cookie 就为空了，那么直接搜索值，发现是 agreement 这个接口返回的，<code>secretKeyValue</code> 值就是我们要的，有可能浏览器抓包直接搜索的话搜索不到，使用抓包工具，比如 Fiddler 就能搜到了，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/049/26.png" alt="26"></p><p>这个接口是 post 请求，请求带了一个 json 数据，<code>secretKeyDecode</code>，直接搜索关键字，就一个值，定位跟栈：</p><p><img src="https://cdn.itbob.cn/img/article/049/27.png" alt="27"></p><p><code>zt()</code> 是从本地缓存中取，<code>At()</code> 是重新生成：</p><p><img src="https://cdn.itbob.cn/img/article/049/28.png" alt="28"></p><p>这里就非常明显了，t 是32位随机字符串，赋值为 <code>aesKey</code>，后面紧接着一个 RSA 加密了 <code>aesKey</code>，赋值为 <code>rsaEncryptData</code>，而 <code>rsaEncryptData</code> 就是前面 agreement 接口请求的 <code>secretKeyValue</code> 值。</p><p>这里先说一下，最终搜索职位请求的 data 和返回数据都是 AES 加密解密，会用到这个 <code>aesKey</code>，请求头的另一个参数 <code>X-S-HEADER</code> 也会用到，如果这个 key 没有经过 RSA 加密并通过 agreement 接口验证的话，是无效的，可以理解为 agreement 接口既是为了获取 <code>X-K-HEADER</code> 和 <code>X-SS-REQ-HEADER</code>，也是为了激活这个 <code>aesKey</code>。</p><p>这部分的 JS 代码和 Python 代码大致如下：</p><pre><code class="hljs javascript">JSEncrypt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;jsencrypt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAesKeyAndRsaEncryptData</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> aesKey = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t</span>) </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;</span>, r = <span class="hljs-string">&quot;&quot;</span>, n = <span class="hljs-number">0</span>; n &lt; t; n++) &#123;            <span class="hljs-keyword">var</span> i = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * e.length);            r += e.substring(i, i + <span class="hljs-number">1</span>)        &#125;        <span class="hljs-keyword">return</span> r    &#125;(<span class="hljs-number">32</span>);    <span class="hljs-keyword">var</span> e = <span class="hljs-keyword">new</span> JSEncrypt();    e.setPublicKey(<span class="hljs-string">&quot;-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnbJqzIXk6qGotX5nD521Vk/24APi2qx6C+2allfix8iAfUGqx0MK3GufsQcAt/o7NO8W+qw4HPE+RBR6m7+3JVlKAF5LwYkiUJN1dh4sTj03XQ0jsnd3BYVqL/gi8iC4YXJ3aU5VUsB6skROancZJAeq95p7ehXXAJfCbLwcK+yFFeRKLvhrjZOMDvh1TsMB4exfg+h2kNUI94zu8MK3UA7v1ANjfgopaE+cpvoulg446oKOkmigmc35lv8hh34upbMmehUqB51kqk9J7p8VMI3jTDBcMC21xq5XF7oM8gmqjNsYxrT9EVK7cezYPq7trqLX1fyWgtBtJZG7WMftKwIDAQAB-----END PUBLIC KEY-----&quot;</span>);    <span class="hljs-keyword">var</span> rsaEncryptData = e.encrypt(aesKey);    <span class="hljs-keyword">return</span> &#123;        <span class="hljs-string">&quot;aesKey&quot;</span>: aesKey,        <span class="hljs-string">&quot;rsaEncryptData&quot;</span>: rsaEncryptData    &#125;&#125;<span class="hljs-comment">// 测试输出</span><span class="hljs-comment">// console.log(getAesKeyAndRsaEncryptData())</span></code></pre><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_aes_key</span>() -&gt; <span class="hljs-literal">None</span>:</span>    <span class="hljs-comment"># 通过JS获取 AES Key，并通过接口激活，接口激活后会返回一个 secretKeyValue，后续请求头会用到</span>    <span class="hljs-keyword">global</span> aes_key, secret_key_value    url = <span class="hljs-string">&quot;https://gate.脱敏处理.com/system/agreement&quot;</span>    headers = &#123;        <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>,        <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;gate.脱敏处理.com&quot;</span>,        <span class="hljs-string">&quot;Origin&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com&quot;</span>,        <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com/&quot;</span>,        <span class="hljs-string">&quot;User-Agent&quot;</span>: UA    &#125;    encrypt_data = lagou_js.call(<span class="hljs-string">&quot;getAesKeyAndRsaEncryptData&quot;</span>)    aes_key = encrypt_data[<span class="hljs-string">&quot;aesKey&quot;</span>]    rsa_encrypt_data = encrypt_data[<span class="hljs-string">&quot;rsaEncryptData&quot;</span>]    data = &#123;<span class="hljs-string">&quot;secretKeyDecode&quot;</span>: rsa_encrypt_data&#125;    response = requests.post(url=url, headers=headers, json=data).json()    secret_key_value = response[<span class="hljs-string">&quot;content&quot;</span>][<span class="hljs-string">&quot;secretKeyValue&quot;</span>]</code></pre><h3><span id="x-s-header">X-S-HEADER</span></h3><p><code>X-S-HEADER</code> 你每次翻页都会改变，直接搜索关键字可定位：</p><p><img src="https://cdn.itbob.cn/img/article/049/29.png" alt="29"></p><p><img src="https://cdn.itbob.cn/img/article/049/30.png" alt="30"></p><p>中间有一个 SHA256 加密，最后返回的 <code>Rt(JSON.stringify(&#123;originHeader: JSON.stringify(e), code: t&#125;))</code> 就是 <code>X-S-HEADER</code> 的值了，<code>Rt()</code> 是一个 AES 加密，比较关键的，<code>Vt(r)</code> 是一个 URL，比如你搜索职位就是 positionAjax.json，搜索公司就是 companyAjax.json，可根据实际情况定制，然后 <code>Lt(t)</code> 就是搜索信息，字符串形式，包含了城市、页码、关键词等。</p><p>获取 <code>X-S-HEADER</code> 的 JS 代码大致如下：</p><pre><code class="hljs javascript">CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto-js&#x27;</span>)jt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">aesKey, originalData, u</span>) </span>&#123;    <span class="hljs-keyword">var</span> e = &#123;<span class="hljs-attr">deviceType</span>: <span class="hljs-number">1</span>&#125;      , t = <span class="hljs-string">&quot;&quot;</span>.concat(<span class="hljs-built_in">JSON</span>.stringify(e)).concat(u).concat(<span class="hljs-built_in">JSON</span>.stringify(originalData))      , t = (t = t, <span class="hljs-literal">null</span> === (t = CryptoJS.SHA256(t).toString()) || <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> === t ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : t.toUpperCase());    <span class="hljs-keyword">return</span> Rt(<span class="hljs-built_in">JSON</span>.stringify(&#123;        <span class="hljs-attr">originHeader</span>: <span class="hljs-built_in">JSON</span>.stringify(e),        <span class="hljs-attr">code</span>: t    &#125;), aesKey)&#125;Rt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t, aesKey</span>) </span>&#123;    <span class="hljs-keyword">var</span> Ot = CryptoJS.enc.Utf8.parse(<span class="hljs-string">&quot;c558Gq0YQK2QUlMc&quot;</span>),        Dt = CryptoJS.enc.Utf8.parse(aesKey),        t = CryptoJS.enc.Utf8.parse(t);    t = CryptoJS.AES.encrypt(t, Dt, &#123;        <span class="hljs-attr">iv</span>: Ot,        <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,        <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7    &#125;);    <span class="hljs-keyword">return</span> t.toString()&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getXSHeader</span>(<span class="hljs-params">aesKey, originalData, u</span>)</span>&#123;    <span class="hljs-keyword">return</span> jt(aesKey, originalData, u)&#125;<span class="hljs-comment">// 测试样例</span><span class="hljs-comment">// var url = &quot;https://www.脱敏处理.com/jobs/v2/positionAjax.json&quot;</span><span class="hljs-comment">// var aesKey = &quot;dgHY1qVeo/Z0yDaF5WV/EEXxYiwbr5Jt&quot;</span><span class="hljs-comment">// var originalData = &#123;&quot;first&quot;: &quot;true&quot;, &quot;needAddtionalResult&quot;: &quot;false&quot;, &quot;city&quot;: &quot;全国&quot;, &quot;pn&quot;: &quot;2&quot;, &quot;kd&quot;: &quot;Java&quot;&#125;</span><span class="hljs-comment">// console.log(getXSHeader(aesKey, originalData, url))</span></code></pre><h2><span id="qing-qiu-fan-hui-shu-ju-jie-mi">请求/返回数据解密</span></h2><p>前面抓包我们已经发现 positionAjax.json 是 POST 请求，Form Data 中的数据是加密的，返回的 data 也是加密的，我们分析请求头参数的时候，就涉及到 AES 加密解密，所以我们直接搜索 <code>AES.encrypt</code>、<code>AES.decrypt</code>，下断点调试：</p><p><img src="https://cdn.itbob.cn/img/article/049/31.png" alt="31"></p><p><img src="https://cdn.itbob.cn/img/article/049/32.png" alt="32"></p><p>非常明显了，这部分的 JS 代码大致如下：</p><pre><code class="hljs javascript">CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto-js&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRequestData</span>(<span class="hljs-params">aesKey, originalData</span>)</span>&#123;    <span class="hljs-keyword">return</span> Rt(<span class="hljs-built_in">JSON</span>.stringify(originalData), aesKey)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getResponseData</span>(<span class="hljs-params">encryptData, aesKey</span>)</span>&#123;    <span class="hljs-keyword">return</span> It(encryptData, aesKey)&#125;Rt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t, aesKey</span>) </span>&#123;    <span class="hljs-keyword">var</span> Ot = CryptoJS.enc.Utf8.parse(<span class="hljs-string">&quot;c558Gq0YQK2QUlMc&quot;</span>),        Dt = CryptoJS.enc.Utf8.parse(aesKey),        t = CryptoJS.enc.Utf8.parse(t);    t = CryptoJS.AES.encrypt(t, Dt, &#123;        <span class="hljs-attr">iv</span>: Ot,        <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,        <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7    &#125;);    <span class="hljs-keyword">return</span> t.toString()&#125;;It = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t, aesKey</span>) </span>&#123;    <span class="hljs-keyword">var</span> Ot = CryptoJS.enc.Utf8.parse(<span class="hljs-string">&quot;c558Gq0YQK2QUlMc&quot;</span>),    Dt = CryptoJS.enc.Utf8.parse(aesKey);    t = CryptoJS.AES.decrypt(t, Dt, &#123;        <span class="hljs-attr">iv</span>: Ot,        <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,        <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7    &#125;).toString(CryptoJS.enc.Utf8);    <span class="hljs-keyword">try</span> &#123;        t = <span class="hljs-built_in">JSON</span>.parse(t)    &#125; <span class="hljs-keyword">catch</span> (t) &#123;&#125;    <span class="hljs-keyword">return</span> t&#125;<span class="hljs-comment">// 测试样例，注意，encryptedData 数据太多，省略了，直接运行解密是会报错的</span><span class="hljs-comment">// var aesKey = &quot;dgHY1qVeo/Z0yDaF5WV/EEXxYiwbr5Jt&quot;</span><span class="hljs-comment">// var encryptedData = &quot;r4MqbduYxu3Z9sFL75xDhelMTCYPHLluKaurYgzEXlEQ1Rg......&quot;</span><span class="hljs-comment">// var originalData = &#123;&quot;first&quot;: &quot;true&quot;, &quot;needAddtionalResult&quot;: &quot;false&quot;, &quot;city&quot;: &quot;全国&quot;, &quot;pn&quot;: &quot;2&quot;, &quot;kd&quot;: &quot;Java&quot;&#125;</span><span class="hljs-comment">// console.log(getRequestData(aesKey, originalData))</span><span class="hljs-comment">// console.log(getResponseData(encryptedData, aesKey))</span></code></pre><p>大致的 Python 代码如下：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_header_params</span>(<span class="hljs-params">original_data: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">dict</span>:</span>    <span class="hljs-comment"># 后续请求数据所需的请求头参数</span>    <span class="hljs-comment"># 职位搜索 URL，如果是搜索公司，那就是 https://www.脱敏处理.com/jobs/companyAjax.json，根据实际情况更改</span>    u = <span class="hljs-string">&quot;https://www.脱敏处理.com/jobs/v2/positionAjax.json&quot;</span>    <span class="hljs-keyword">return</span> &#123;        <span class="hljs-string">&quot;traceparent&quot;</span>: lagou_js.call(<span class="hljs-string">&quot;getTraceparent&quot;</span>),        <span class="hljs-string">&quot;X-K-HEADER&quot;</span>: secret_key_value,        <span class="hljs-string">&quot;X-S-HEADER&quot;</span>: lagou_js.call(<span class="hljs-string">&quot;getXSHeader&quot;</span>, aes_key, original_data, u),        <span class="hljs-string">&quot;X-SS-REQ-HEADER&quot;</span>: json.dumps(&#123;<span class="hljs-string">&quot;secret&quot;</span>: secret_key_value&#125;)    &#125;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_encrypted_data</span>(<span class="hljs-params">original_data: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">str</span>:</span>    <span class="hljs-comment"># AES 加密原始数据</span>    encrypted_data = lagou_js.call(<span class="hljs-string">&quot;getRequestData&quot;</span>, aes_key, original_data)    <span class="hljs-keyword">return</span> encrypted_data<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_data</span>(<span class="hljs-params">original_data: <span class="hljs-built_in">dict</span>, encrypted_data: <span class="hljs-built_in">str</span>, header_params: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">dict</span>:</span>    <span class="hljs-comment"># 携带加密后的请求数据和完整请求头，拿到密文，AES 解密得到明文职位信息</span>    url = <span class="hljs-string">&quot;https://www.脱敏处理.com/jobs/v2/positionAjax.json&quot;</span>    referer = parse.urljoin(<span class="hljs-string">&quot;https://www.脱敏处理.com/wn/jobs?&quot;</span>, parse.urlencode(original_data))    headers = &#123;        <span class="hljs-comment"># &quot;content-type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,</span>        <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;www.脱敏处理.com&quot;</span>,        <span class="hljs-string">&quot;Origin&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com&quot;</span>,        <span class="hljs-string">&quot;Referer&quot;</span>: referer,        <span class="hljs-string">&quot;traceparent&quot;</span>: header_params[<span class="hljs-string">&quot;traceparent&quot;</span>],        <span class="hljs-string">&quot;User-Agent&quot;</span>: UA,        <span class="hljs-string">&quot;X-K-HEADER&quot;</span>: header_params[<span class="hljs-string">&quot;X-K-HEADER&quot;</span>],        <span class="hljs-string">&quot;X-S-HEADER&quot;</span>: header_params[<span class="hljs-string">&quot;X-S-HEADER&quot;</span>],        <span class="hljs-string">&quot;X-SS-REQ-HEADER&quot;</span>: header_params[<span class="hljs-string">&quot;X-SS-REQ-HEADER&quot;</span>],    &#125;    <span class="hljs-comment"># 添加 x-anit-forge-code 和 x-anit-forge-token</span>    headers.update(x_anit)    data = &#123;<span class="hljs-string">&quot;data&quot;</span>: encrypted_data&#125;    response = requests.post(url=url, headers=headers, cookies=global_cookies, data=data).json()    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;status&quot;</span> <span class="hljs-keyword">in</span> response:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> response[<span class="hljs-string">&quot;status&quot;</span>] <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;操作太频繁&quot;</span> <span class="hljs-keyword">in</span> response[<span class="hljs-string">&quot;msg&quot;</span>]:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;获取数据失败！msg：%s！可以尝试补全登录后的 Cookies，或者添加代理！&quot;</span> % response[<span class="hljs-string">&quot;msg&quot;</span>])        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;获取数据异常！请检查数据是否完整！&quot;</span>)    <span class="hljs-keyword">else</span>:        response_data = response[<span class="hljs-string">&quot;data&quot;</span>]        decrypted_data = lagou_js.call(<span class="hljs-string">&quot;getResponseData&quot;</span>, response_data, aes_key)        <span class="hljs-keyword">return</span> decrypted_data</code></pre><p>最终整合所有代码，成功拿到数据：</p><p><img src="https://cdn.itbob.cn/img/article/049/33.png" alt="33"></p><h2><span id="ni-xiang-xiao-ji-qiao">逆向小技巧</span></h2><p>浏览器开发者工具 Application - Storage 选项，可以一键清除所有 Cookies，也可以自定义存储配额：</p><p><img src="https://cdn.itbob.cn/img/article/049/34.png" alt="34"></p><p>Storage - Cookies 可以查看每个站点的所有 Cookies，HttpOnly 打勾的表示是服务器返回的，选中一条 Cookie，右键可以直接定位到哪个请求带了这个 Cookie，也可以直接编辑值，还可以删除单个 Cookie，当你登录了账号，但又需要清除某个 Cookie，且不想重新登录时，这个功能或许有用。</p><p><img src="https://cdn.itbob.cn/img/article/049/35.png" alt="35"></p><h2><span id="wan-zheng-dai-ma">完整代码</span></h2><p>文中给出了部分关键代码，不能直接运行，部分细节可能没提及到，完整代码已放 GitHub，均有详细注释，欢迎 Star。所有内容仅供学习交流，严禁用于商业用途、非法用途，否则由此产生的一切后果均与作者无关，在仓库中下载的文件学习完毕之后请于 24 小时内删除！</p><p>仓库地址：<a href="https://github.com/TRHX/Python3-Spider-Practice">https://github.com/TRHX/Python3-Spider-Practice</a></p><h2><span id="chang-jian-wen-ti">常见问题</span></h2><ul><li><p>JS 代码里引用了三个库，npm install 安装一下即可，如果安装了还提示找不到库，那就是路径问题，推荐在当前目录下执行命令安装，或者在 Python 代码里指定完整路径，具体方法可自行百度。</p></li><li><p>jsencrypt 这个库，本地运行可能会报错 <code>window is not defined</code>，在 <code>\node_modules\jsencrypt\bin\jsencrypt.js</code> 源码中加入 <code>var window = global;</code> 即可，这是实现 RSA 加密的库，当然还有很多其他实现方法或者库，都可以。</p></li><li><p>execjs 执行 JS 的时候，可能会报编码错误 <code>&quot;gbk&quot; can't decode byte...</code>，有两种解决方法，一是找到官方源码 <a href="http://subprocess.py">subprocess.py</a>，搜索 <code>encoding=None</code> 改成 <code>encoding='utf-8'</code>，二是直接在 Python 代码里面加入以下代码即可：</p></li></ul><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partialsubprocess.Popen = partial(subprocess.Popen, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/javascript_reverse.png&quot; alt=&quot;javascript_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Python 中如何解决 asyncio 文件描述符最大数量限制问题</title>
    <link href="https://www.itbob.cn/article/048/"/>
    <id>https://www.itbob.cn/article/048/</id>
    <published>2022-02-23T02:18:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#wen-ti-fu-xian">问题复现</a></li><li><a href="#wen-ti-fen-xi">问题分析</a><ul><li><a href="#shi-jian-xun-huan-eventloop">事件循环 EventLoop</a></li><li><a href="#i-o-duo-lu-fu-yong">I/O 多路复用</a></li><li><a href="#select-de-que-dian">select 的缺点</a></li></ul></li><li><a href="#jie-jue-fang-fa">解决方法</a><ul><li><a href="#1-geng-huan-shi-jian-xun-huan-xuan-ze-qi">1.更换事件循环选择器</a></li><li><a href="#2-xian-zhi-bing-fa-liang">2.限制并发量</a></li><li><a href="#3-xiu-gai-zui-da-wen-jian-miao-shu-fu-xian-zhi">3.修改最大文件描述符限制</a><ul><li><a href="#windows">Windows</a></li><li><a href="#linux">Linux</a></li></ul></li></ul></li><li><a href="#zong-jie">总结</a><ul><li><a href="#windows-1">Windows</a></li><li><a href="#linux-1">Linux</a></li></ul></li></ul><!-- tocstop --><hr><h2><span id="wen-ti-fu-xian">问题复现</span></h2><p>Windows 平台下，Python 版本 3.5，使用异步框架 asyncio，有时候会出现 <code>ValueError: too many file descriptors in select()</code> 的报错信息，今天我们就来聊一下为什么会出现这种问题，以及问题的一些解决方法。</p><p>写一个小 dome 复现这个问题（环境：Windows 64 位、Python 3.7）：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> aiohttp<span class="hljs-keyword">import</span> asyncionum = <span class="hljs-number">0</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">url</span>):</span>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> response:            <span class="hljs-keyword">global</span> num            num += <span class="hljs-number">1</span>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s ——&gt; %s&#x27;</span> % (<span class="hljs-built_in">str</span>(num), response.status))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tasks</span>():</span>    url = <span class="hljs-string">&#x27;https://www.baidu.com/s?ie=UTF-8&amp;wd=%s&#x27;</span>    task = [main(url % i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>)]    <span class="hljs-keyword">return</span> taskloop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks()))</code></pre><p>在打印 500 次左右后就会出现以下报错：</p><p><img src="https://cdn.itbob.cn/img/article/048/01.png" alt="01.png"></p><h2><span id="wen-ti-fen-xi">问题分析</span></h2><p>好像这个报错和 select 有关，那什么是 select 呢？要怎么解决呢？别急，我们首先来了解一下 asyncio 中的事件循环，即 EventLoop。</p><h3><span id="shi-jian-xun-huan-eventloop">事件循环 EventLoop</span></h3><p>事件循环是 asyncio 的核心，异步任务的运行、任务完成之后的回调、网络 I/O 操作、子进程的运行，都是通过事件循环完成的，通俗来讲，事件循环所做的就是等待事件发生，然后再将每个事件与我们已明确与所述事件类型匹配的函数进行匹配。下图很好的展示了协程、事件循环之间的相互作用：</p><p><img src="https://cdn.itbob.cn/img/article/048/02.png" alt="02.png"></p><p>在 asyncio 中，主要提供了两种不同事件循环的实现方法：</p><ul><li><p><strong>SelectorEventLoop</strong>：基于 selectors 模块的事件循环，selectors 又是建立在底层的 I/O 复用模块 select 之上的，selectors 提供了高度封装和高效的 I/O 复用，也就是说 SelectorEventLoop 在底层就是使用了 select I/O 多路复用的机制。</p></li><li><p><strong>ProactorEventLoop</strong>：使用 IOCP 专为 Windows 构建的事件循环，IOCP 全称 I/O Completion Port，即 I/O 完成端口。它是支持多个同时发生的异步 I/O 操作的应用程序编程接口，它充分利用内核对象的调度，只使用少量的几个线程来处理和客户端的所有通信，消除了无谓的线程上下文切换，是 Windows 下性能最好的 I/O 模型，有关 IOCP 的详细介绍可参考<a href="https://docs.microsoft.com/en-ca/windows/win32/fileio/i-o-completion-ports">微软文档</a>。</p></li></ul><p>那么这两种方法有什么区别呢？在 asyncio 中什么时候用什么方法呢？</p><p>我们不妨看一下 asyncio 的源码，在 Python 3.7 中，无论在 Windows 还是 Linux 中都可以看到其默认的设置是 SelectorEventLoop：</p><p><img src="https://cdn.itbob.cn/img/article/048/03.png" alt="03.png"></p><p>我们也可以分别在 Windows 平台和 Linux 平台打印一下 EventLoop 对象（Python 3.7），可以看到默认都是 SelectorEventLoop：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncioloop = asyncio.get_event_loop()<span class="hljs-built_in">print</span>(loop)</code></pre><p>Windows：</p><p><img src="https://cdn.itbob.cn/img/article/048/04.png" alt="04.png"></p><p>Linux：</p><p><img src="https://cdn.itbob.cn/img/article/048/05.png" alt="05.png"></p><p>事实上，在 Python 3.7 以及之前的版本中，   所有平台默认使用的都是 SelectorEventLoop，在 Python 3.8 以及以后的版本中，Unix 平台默认使用的是 SelectorEventLoop，Windows 平台默认使用的是 ProactorEventLoop，这个差异可以在官方文档中看到。</p><ul><li>Python 3.7 文档：<a href="https://docs.python.org/3.7/library/asyncio-eventloop.html#event-loop-implementations">https://docs.python.org/3.7/library/asyncio-eventloop.html#event-loop-implementations</a></li><li>Python 3.8 文档：<a href="https://docs.python.org/3.8/library/asyncio-eventloop.html#event-loop-implementations">https://docs.python.org/3.8/library/asyncio-eventloop.html#event-loop-implementations</a></li></ul><p><img src="https://cdn.itbob.cn/img/article/048/06.png" alt="06.png"></p><p>说了这么多，这和 <code>ValueError: too many file descriptors in select()</code> 的报错问题有什么关系呢？select 到底是什么东西呢？</p><h3><span id="i-o-duo-lu-fu-yong">I/O 多路复用</span></h3><p>要了解 select，我们还要了解一下什么是 I/O 多路复用（I/O multiplexing），服务器端编程经常需要构造高性能的 I/O 模型，常见的 I/O 模型有同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用等；当需要同时处理多个客户端接入请求时，可以利用多线程或者 I/O 多路复用技术进行处理，I/O 多路复用技术就是为了解决进程或线程阻塞到某个 I/O 系统调用而出现的技术，使进程不阻塞于某个特定的 I/O 系统调用。</p><p><strong>select，poll，epoll 等都是 I/O 多路复用的一种机制</strong>，其中后两个在 Linux 中可用，Windows 仅支持 select，I/O 多路复用通过这种机制，可以监视多个描述符，一旦某个描述符就绪，一般是读就绪或者写就绪，就是在这个文件描述符进行读写操作之前，能够通知程序进行相应的读写操作。</p><h3><span id="select-de-que-dian">select 的缺点</span></h3><p>I/O 多路复用这个概念被提出来以后， select 是第一个实现这个概念的，select 被实现以后，很快就暴露出了很多问题，其中一个缺点就是 <strong>select 在 Windows 中限制了文件描述符数量为 512 个，在 Linux 中限制为 1024 个</strong>，那么在前面的 dome 中，使用的是 Python 3.5，这个版本的 asyncio 默认使用了 SelectorEventLoop，底层调用的是 select，受 select 缺点的影响，并发量过高，就出现了 <code>ValueError: too many file descriptors in select()</code> 的报错信息。</p><h2><span id="jie-jue-fang-fa">解决方法</span></h2><h3><span id="1-geng-huan-shi-jian-xun-huan-xuan-ze-qi">1.更换事件循环选择器</span></h3><p>如果你使用的是 Python 3.7 及以下的版本，那么在 Windows 平台，可以使用 ProactorEventLoop。在 Linux 平台可以使用 PollSelector。</p><p><strong>注意</strong>：如果你使用了 ProactorEventLoop，那么你将无法使用代理！这是 asyncio 的 bug，早在 2020 年 1 月就有人提过 <a href="https://github.com/aio-libs/aiohttp/issues/4536">issue</a>，目前仍然可以看到类似的 issue，官方貌似也还没办法解决，所以，如果您必须要使用代理，则可以参考后面的解决办法。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> selectors<span class="hljs-keyword">import</span> asyncio<span class="hljs-keyword">import</span> sys<span class="hljs-keyword">if</span> sys.platform == <span class="hljs-string">&#x27;win32&#x27;</span>:    loop = asyncio.ProactorEventLoop()    asyncio.set_event_loop(loop)<span class="hljs-keyword">else</span>:    selector = selectors.PollSelector()    loop = asyncio.SelectorEventLoop(selector)    asyncio.set_event_loop(loop)</code></pre><h3><span id="2-xian-zhi-bing-fa-liang">2.限制并发量</span></h3><p>可以使用方法 <code>asyncio.Semaphore()</code> 来限制并发量，Semaphore 就是信号量的意思，Semaphore 管理一个内部计数器，该计数器在每次调用 <code>acquire()</code> 方法时递减，每次调用 <code>release()</code> 方法时递增，计数器永远不会低于零，当方法 <code>acquire()</code> 发现它为零时，它会阻塞，等待其他线程调用 <code>release()</code> 方法。通过限制并发量的方法来解决报错问题是个不错的选择。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> aiohttp<span class="hljs-keyword">import</span> asyncionum = <span class="hljs-number">0</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">url, semaphore</span>):</span>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> semaphore:        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:            <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> response:                <span class="hljs-keyword">global</span> num                num += <span class="hljs-number">1</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s ——&gt; %s&#x27;</span> % (<span class="hljs-built_in">str</span>(num), response.status))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tasks</span>():</span>    semaphore = asyncio.Semaphore(<span class="hljs-number">300</span>)                         <span class="hljs-comment"># 限制并发量为 300</span>    url = <span class="hljs-string">&#x27;https://www.baidu.com/s?ie=UTF-8&amp;wd=%s&#x27;</span>    task = [main(url % i, semaphore) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>)]    <span class="hljs-comment"># #总共 10000 任务</span>    <span class="hljs-keyword">return</span> taskloop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks()))</code></pre><h3><span id="3-xiu-gai-zui-da-wen-jian-miao-shu-fu-xian-zhi">3.修改最大文件描述符限制</span></h3><h4><span id="windows">Windows</span></h4><p>在 Windows 中，最大文件描述符限制在 C 语言的头文件 Winsock2.h 中使用变量 <code>FD_SETSIZE</code> 进行定义，如果要修改它，可以通过在包含 Winsock2.h 之前将 <code>FD_SETSIZE</code> 定义为另一个值来修改，如果我们使用的编程语言是 Python 的话，是不太好对这个值进行修改的，可以参考微软官方文档：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-select">https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-select</a></p><h4><span id="linux">Linux</span></h4><p>在 Linux 平台，可以使用 <code>ulimit</code> 命令来修改最大文件描述符限制：</p><ul><li><p>查看当前会话最大文件描述符限制（默认1024）：<code>ulimit -n</code></p></li><li><p>临时修改限制，只对当前的会话有效：<code>ulimit -SHn 65536</code></p></li><li><p>永久修改限制，在 <code>/etc/security/limits.conf</code> 文件里新增以下内容：</p>  <pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>hard nofile 65536<span class="hljs-bullet">* </span>soft nofile 65536</code></pre></li></ul><p><code>ulimit</code> 命令参考：</p><pre><code class="hljs diff"><span class="hljs-deletion">-S使用软 (soft) 资源限制</span><span class="hljs-deletion">-H使用硬 (hard) 资源限制</span><span class="hljs-deletion">-a所有当前限制都被报告</span><span class="hljs-deletion">-b套接字缓存尺寸</span><span class="hljs-deletion">-c创建的核文件的最大尺寸</span><span class="hljs-deletion">-d一个进程的数据区的最大尺寸</span><span class="hljs-deletion">-e最高的调度优先级 (nice)</span><span class="hljs-deletion">-f有 shell 及其子进程可以写的最大文件尺寸</span><span class="hljs-deletion">-i最多的可以挂起的信号数</span><span class="hljs-deletion">-k分配给此进程的最大 kqueue 数量</span><span class="hljs-deletion">-l一个进程可以锁定的最大内存尺寸</span><span class="hljs-deletion">-m最大的内存进驻尺寸</span><span class="hljs-deletion">-n最多的打开的文件描述符个数</span><span class="hljs-deletion">-p管道缓冲区尺寸</span><span class="hljs-deletion">-qPOSIX 信息队列的最大字节数</span><span class="hljs-deletion">-r实时调度的最大优先级</span><span class="hljs-deletion">-s最大栈尺寸</span><span class="hljs-deletion">-t最大的CPU时间，以秒为单位</span><span class="hljs-deletion">-u最大用户进程数</span><span class="hljs-deletion">-v虚拟内存尺寸</span><span class="hljs-deletion">-x最大的文件锁数量</span><span class="hljs-deletion">-P最大伪终端数量</span><span class="hljs-deletion">-T最大线程数量</span></code></pre><h2><span id="zong-jie">总结</span></h2><p>asyncio 事件循环选择器，在 Python 3.7 以及之前的版本中，所有平台默认使用的都是 SelectorEventLoop，在 Python 3.8 以及以后的版本中，Unix 平台默认使用的是 SelectorEventLoop，Windows 平台默认使用的是 ProactorEventLoop。</p><p>select 在 Windows 中限制了文件描述符最大数量为 512 个，在 Linux 中限制为 1024 个。</p><p>要解决 <code>ValueError: too many file descriptors in select()</code> 的报错问题，根据您的平台和业务要求选择合理的解决方法：</p><h3><span id="windows">Windows</span></h3><ol><li><p>通过 <code>asyncio.Semaphore()</code> 方法来限制并发量，通常设置在 300-500 比较合理，这是最优的做法；</p></li><li><p>更换 asyncio 的事件循环选择器为 ProactorEventLoop，<strong>注意：这将导致无法使用代理！</strong></p></li></ol><h3><span id="linux">Linux</span></h3><ol><li><p>通过 <code>asyncio.Semaphore()</code> 方法来限制并发量，通常设置在 800-1000 比较合理；</p></li><li><p>通过 <code>ulimit</code> 命令来修改最大文件描述符限制；</p></li><li><p>更换 asyncio 的事件循环选择器为 PollSelector。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#wen-ti-fu-xian&quot;&gt;问题复现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#wen-ti-fen-</summary>
      
    
    
    
    <category term="Python" scheme="https://www.itbob.cn/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.itbob.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>RPC 技术及其框架 Sekiro 在爬虫逆向中的应用，加密数据一把梭</title>
    <link href="https://www.itbob.cn/article/047/"/>
    <id>https://www.itbob.cn/article/047/</id>
    <published>2022-02-21T09:20:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/rpc.png" alt="rpc"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#shi-me-shi-rpc">什么是 RPC</a></li><li><a href="#jsrpc">JSRPC</a></li><li><a href="#sekiro">Sekiro</a></li><li><a href="#you-que-dian">优缺点</a></li></ul><!-- tocstop --><hr><h2><span id="shi-me-shi-rpc">什么是 RPC</span></h2><p><s>RPC，英文 RangPaCong，中文让爬虫，旨在为爬虫开路，秒杀一切，让爬虫畅通无阻！</s></p><p>开个玩笑，实际上 RPC 为远程过程调用，全称 Remote Procedure Call，是一种技术思想而非一种规范或协议。RPC 的诞生事实上离不开分布式的发展，RPC 主要解决了两个问题：</p><ol><li>解决了分布式系统中，服务之间的互相调用问题；</li><li>RPC 使得在远程调用时，像本地调用一样方便，让调用者感知不到远程调用的逻辑。</li></ol><p>RPC 的存在让构建分布式系统更加容易，相比于 HTTP 协议，RPC 采用二进制字节码传输，因此也更加高效、安全。在一个典型 RPC 的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，完整 RPC 架构图如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/047/01.jpg" alt="01"></p><h2><span id="jsrpc">JSRPC</span></h2><p>RPC 技术是非常复杂的，对于我们搞爬虫、逆向的来说，不需要完全了解，只需要知道这项技术如何在逆向中应用就行了。</p><p>RPC 在逆向中，简单来说就是将本地和浏览器，看做是服务端和客户端，二者之间通过 WebSocket 协议进行 RPC 通信，在浏览器中将加密函数暴露出来，在本地直接调用浏览器中对应的加密函数，从而得到加密结果，不必去在意函数具体的执行逻辑，也省去了扣代码、补环境等操作，可以省去大量的逆向调试时间。我们以某团网页端的登录为例来演示 RPC 在逆向中的具体使用方法。（假设你已经有一定逆向基础，了解 WebSocket 协议，纯小白可以先看看以前的文章）</p><ul><li>主页（base64）：<code>aHR0cHM6Ly9wYXNzcG9ydC5tZWl0dWFuLmNvbS9hY2NvdW50L3VuaXRpdmVsb2dpbg==</code></li><li>参数：h5Fingerprint</li></ul><p>首先抓一下包，登录接口有一个超级长的参数 h5Fingerprint，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/047/02.png" alt="02"></p><p>直接搜一下就能找到加密函数：</p><p><img src="https://cdn.itbob.cn/img/article/047/03.png" alt="03"></p><p>其中 <code>utility.getH5fingerprint()</code> 传入的参数 <code>window.location.origin + url</code> 格式化后，参数如下：</p><pre><code class="hljs makefile">url = <span class="hljs-string">&quot;https://passport.脱敏处理.com/account/unitivelogin&quot;</span>params = &#123;    <span class="hljs-string">&quot;risk_partner&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,    <span class="hljs-string">&quot;risk_platform&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>,    <span class="hljs-string">&quot;risk_app&quot;</span>: <span class="hljs-string">&quot;-1&quot;</span>,    <span class="hljs-string">&quot;uuid&quot;</span>: <span class="hljs-string">&quot;96309b5f00ba4143b920.1644805104.1.0.0&quot;</span>,    <span class="hljs-string">&quot;token_id&quot;</span>: <span class="hljs-string">&quot;DNCmLoBpSbBD6leXFdqIxA&quot;</span>,    <span class="hljs-string">&quot;service&quot;</span>: <span class="hljs-string">&quot;www&quot;</span>,    <span class="hljs-string">&quot;continue&quot;</span>: <span class="hljs-string">&quot;https://www.脱敏处理.com/account/settoken?continue=https%3A%2F%2Fwww.脱敏处理.com%2F&quot;</span>&#125;</code></pre><p>uuid 和 token_id 都可以直接搜到，不是本次研究重点，这里不再细说，接下来我们使用 RPC 技术，直接调用浏览器里的 <code>utility.getH5fingerprint()</code> 方法，首先在本地编写服务端代码，使其能够一直输入待加密字符串，接收并打印加密后的字符串：</p><pre><code class="hljs python"><span class="hljs-comment"># ==================================</span><span class="hljs-comment"># --*-- coding: utf-8 --*--</span><span class="hljs-comment"># @Time    : 2022-02-14</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: ws_server.py</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ==================================</span><span class="hljs-keyword">import</span> sys<span class="hljs-keyword">import</span> asyncio<span class="hljs-keyword">import</span> websockets<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">receive_massage</span>(<span class="hljs-params">websocket</span>):</span>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        send_text = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要加密的字符串: &quot;</span>)        <span class="hljs-keyword">if</span> send_text == <span class="hljs-string">&quot;exit&quot;</span>:            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Exit, goodbye!&quot;</span>)            <span class="hljs-keyword">await</span> websocket.send(send_text)            <span class="hljs-keyword">await</span> websocket.close()            sys.exit()        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">await</span> websocket.send(send_text)            response_text = <span class="hljs-keyword">await</span> websocket.recv()            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n加密结果：&quot;</span>, response_text)start_server = websockets.serve(receive_massage, <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">5678</span>)  <span class="hljs-comment"># 自定义端口</span>asyncio.get_event_loop().run_until_complete(start_server)asyncio.get_event_loop().run_forever()</code></pre><p>编写浏览器客户端 JS 代码，收到消息就直接 <code>utility.getH5fingerprint()</code> 得到加密参数并发送给服务端：</p><pre><code class="hljs javascript"><span class="hljs-comment">/* ==================================</span><span class="hljs-comment"># @Time    : 2022-02-14</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: ws_client.js</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ================================== */</span><span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">&quot;ws://127.0.0.1:5678&quot;</span>);  <span class="hljs-comment">// 自定义端口</span>ws.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Received Message: &quot;</span> + evt.data);    <span class="hljs-keyword">if</span> (evt.data == <span class="hljs-string">&quot;exit&quot;</span>) &#123;        ws.close();    &#125; <span class="hljs-keyword">else</span> &#123;        ws.send(utility.getH5fingerprint(evt.data))    &#125;&#125;;</code></pre><p>然后我们需要把客户端代码注入到网页中，这里方法有很多，比如抓包软件 Fiddler 替换响应、浏览器插件 ReRes 替换 JS、浏览器开发者工具 Overrides 重写功能等，也可以通过插件、油猴等注入 Hook 的方式插入，反正方法很多，对这些方法不太了解的朋友可以去看看以前的文章，都有介绍。</p><p>这里我们使用浏览器开发者工具 Overrides 重写功能，将 WebSocket 客户端代码加到加密的这个 JS 文件里并 Ctrl+S 保存，这里将其写成了 IIFE 自执行方式，这样做的原因是防止污染全局变量，不用自执行方式当然也是可以的。</p><p><img src="https://cdn.itbob.cn/img/article/047/04.png" alt="04"></p><p>然后先运行本地服务端代码，网页上先登录一遍，网页上先登录一遍，网页上先登录一遍，重要的步骤说三遍！然后就可以在本地传入待加密字符串，获取 <code>utility.getH5fingerprint()</code> 加密后的结果了：</p><p><img src="https://cdn.itbob.cn/img/article/047/05.png" alt="05"></p><h2><span id="sekiro">Sekiro</span></h2><p>通过前面的示例，可以发现自己写服务端太麻烦了，不易扩展，那这方面有没有现成的轮子呢？答案是有的，这里介绍两个项目：</p><ul><li>JsRPC-hliang：<a href="https://github.com/jxhczhl/JsRpc">https://github.com/jxhczhl/JsRpc</a></li><li>Sekiro：<a href="https://github.com/virjar/sekiro">https://github.com/virjar/sekiro</a></li></ul><p>JsRPC-hliang 是用 go 语言写的，是专门为 JS 逆向做的项目，而 Sekiro 功能更加强大，Sekiro 是由邓维佳大佬，俗称渣总，写的一个基于长链接和代码注入的 Android Private API 暴露框架，可以用在 APP 逆向、APP 数据抓取、Android 群控等场景，同时 Sekiro 也是目前公开方案唯一稳定的 JSRPC 框架，两者在 JS 逆向方面的使用方法其实都差不多，本文主要介绍一下 Sekiro 在 Web JS 逆向中的应用。</p><p>参考 Sekiro 文档，首先在本地编译项目：</p><ul><li><p>Linux &amp; Mac：执行脚本 <code>build_demo_server.sh</code>，之后得到产出发布压缩包：<code>sekiro-service-demo/target/sekiro-release-demo.zip</code></p></li><li><p>Windows：可以直接下载：<a href="https://oss.virjar.com/sekiro/sekiro-demo">https://oss.virjar.com/sekiro/sekiro-demo</a></p></li></ul><p>然后在本地运行（需要有 Java 环境，自行配置）：</p><ul><li>Linux &amp; Mac：<code>bin/sekiro.sh</code></li><li>Windows：<code>bin/sekiro.bat</code></li></ul><p>以 Windows 为例，启动后如下：</p><p><img src="https://cdn.itbob.cn/img/article/047/06.png" alt="06"></p><p>接下来就需要在浏览器里注入代码了，需要将作者提供的 sekiro_web_client.js（下载地址：<a href="https://sekiro.virjar.com/sekiro-doc/assets/sekiro_web_client.js%EF%BC%89">https://sekiro.virjar.com/sekiro-doc/assets/sekiro_web_client.js）</a> 注入到浏览器环境，然后通过 SekiroClient 和 Sekiro 服务器通信，即可直接 RPC 调用浏览器内部方法，官方提供的 SekiroClient 代码样例如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">guid</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">S4</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> (((<span class="hljs-number">1</span>+<span class="hljs-built_in">Math</span>.random())*<span class="hljs-number">0x10000</span>)|<span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>).substring(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> (S4()+S4()+<span class="hljs-string">&quot;-&quot;</span>+S4()+<span class="hljs-string">&quot;-&quot;</span>+S4()+<span class="hljs-string">&quot;-&quot;</span>+S4()+<span class="hljs-string">&quot;-&quot;</span>+S4()+S4()+S4());&#125;<span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> SekiroClient(<span class="hljs-string">&quot;wss://sekiro.virjar.com/business/register?group=ws-group&amp;clientId=&quot;</span>+guid());client.registerAction(<span class="hljs-string">&quot;clientTime&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">request, resolve, reject</span>)</span>&#123;    resolve(<span class="hljs-string">&quot;&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());&#125;)</code></pre><p>wss 链接里，如果是免费版，要将 business 改成 business-demo，解释一下涉及到的名词：</p><ul><li><strong>group</strong>：业务类型（接口组），每个业务一个 group，group 下面可以注册多个终端（SekiroClient），同时 group 可以挂载多个 Action；</li><li><strong>clientId</strong>：指代设备，多个设备使用多个机器提供 API 服务，提供群控能力和负载均衡能力；</li><li><strong>SekiroClient</strong>：服务提供者客户端，主要场景为手机/浏览器等。最终的 Sekiro 调用会转发到 SekiroClient。每个 client 需要有一个惟一的 clientId；</li><li><strong>registerAction</strong>：接口，同一个 group 下面可以有多个接口，分别做不同的功能；</li><li><strong>resolve</strong>：将内容传回给客户端的方法；</li><li><strong>request</strong>：客户端传过来的请求，如果请求里有多个参数，可以以键值对的方式从里面提取参数然后再做处理。</li></ul><p>说了这么多可能也不好理解，直接实战，还是以某团网页端登录为例，我们将 sekiro_web_client.js 与 SekiroClient 通信代码写在一起，然后根据需求，改写一下通信部分代码：</p><ol><li>ws 链接改为：<code>ws://127.0.0.1:5620/business-demo/register?group=rpc-test&amp;clientId=</code>，自定义 <code>group</code> 为 <code>rpc-test</code>；</li><li>注册一个事件 <code>registerAction</code> 为 <code>getH5fingerprint</code>；</li><li><code>resolve</code> 返回的结果为 <code>utility.getH5fingerprint(request[&quot;url&quot;])</code>，即加密并返回客户端传过来的 url 参数。</li></ol><p>完整代码如下（留意末尾 SekiroClient 通信代码部分的写法）：</p><pre><code class="hljs javascript"><span class="hljs-comment">/* ==================================</span><span class="hljs-comment"># @Time    : 2022-02-14</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: sekiro.js</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ================================== */</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-meta">    &#x27;use strict&#x27;</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SekiroClient</span>(<span class="hljs-params">wsURL</span>) </span>&#123;        <span class="hljs-built_in">this</span>.wsURL = wsURL;        <span class="hljs-built_in">this</span>.handlers = &#123;&#125;;        <span class="hljs-built_in">this</span>.socket = &#123;&#125;;        <span class="hljs-comment">// check</span>        <span class="hljs-keyword">if</span> (!wsURL) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;wsURL can not be empty!!&#x27;</span>)        &#125;        <span class="hljs-built_in">this</span>.webSocketFactory = <span class="hljs-built_in">this</span>.resolveWebSocketFactory();        <span class="hljs-built_in">this</span>.connect()    &#125;    SekiroClient.prototype.resolveWebSocketFactory = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;            <span class="hljs-keyword">var</span> theWebSocket = <span class="hljs-built_in">window</span>.WebSocket ? <span class="hljs-built_in">window</span>.WebSocket : <span class="hljs-built_in">window</span>.MozWebSocket;            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">wsURL</span>) </span>&#123;                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WindowWebSocketWrapper</span>(<span class="hljs-params">wsURL</span>) </span>&#123;                    <span class="hljs-built_in">this</span>.mSocket = <span class="hljs-keyword">new</span> theWebSocket(wsURL);                &#125;                WindowWebSocketWrapper.prototype.close = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                    <span class="hljs-built_in">this</span>.mSocket.close();                &#125;;                WindowWebSocketWrapper.prototype.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onMessageFunction</span>) </span>&#123;                    <span class="hljs-built_in">this</span>.mSocket.onmessage = onMessageFunction;                &#125;;                WindowWebSocketWrapper.prototype.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onOpenFunction</span>) </span>&#123;                    <span class="hljs-built_in">this</span>.mSocket.onopen = onOpenFunction;                &#125;;                WindowWebSocketWrapper.prototype.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onCloseFunction</span>) </span>&#123;                    <span class="hljs-built_in">this</span>.mSocket.onclose = onCloseFunction;                &#125;;                WindowWebSocketWrapper.prototype.send = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) </span>&#123;                    <span class="hljs-built_in">this</span>.mSocket.send(message);                &#125;;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WindowWebSocketWrapper(wsURL);            &#125;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> weex === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;            <span class="hljs-comment">// this is weex env : https://weex.apache.org/zh/docs/modules/websockets.html</span>            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;test webSocket for weex&quot;</span>);                <span class="hljs-keyword">var</span> ws = weex.requireModule(<span class="hljs-string">&#x27;webSocket&#x27;</span>);                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;find webSocket for weex:&quot;</span> + ws);                <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">wsURL</span>) </span>&#123;                    <span class="hljs-keyword">try</span> &#123;                        ws.close();                    &#125; <span class="hljs-keyword">catch</span> (e) &#123;                    &#125;                    ws.WebSocket(wsURL, <span class="hljs-string">&#x27;&#x27;</span>);                    <span class="hljs-keyword">return</span> ws;                &#125;            &#125; <span class="hljs-keyword">catch</span> (e) &#123;                <span class="hljs-built_in">console</span>.log(e);                <span class="hljs-comment">//ignore</span>            &#125;        &#125;        <span class="hljs-comment">//TODO support ReactNative</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> WebSocket === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">wsURL</span>) </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> theWebSocket(wsURL);            &#125;        &#125;        <span class="hljs-comment">// weex 和 PC环境的websocket API不完全一致，所以做了抽象兼容</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;the js environment do not support websocket&quot;</span>);    &#125;;    SekiroClient.prototype.connect = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;sekiro: begin of connect to wsURL: &#x27;</span> + <span class="hljs-built_in">this</span>.wsURL);        <span class="hljs-keyword">var</span> _this = <span class="hljs-built_in">this</span>;        <span class="hljs-comment">// 不check close，让</span>        <span class="hljs-comment">// if (this.socket &amp;&amp; this.socket.readyState === 1) &#123;</span>        <span class="hljs-comment">//     this.socket.close();</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-built_in">this</span>.socket = <span class="hljs-built_in">this</span>.webSocketFactory(<span class="hljs-built_in">this</span>.wsURL);        &#125; <span class="hljs-keyword">catch</span> (e) &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;sekiro: create connection failed,reconnect after 2s&quot;</span>);            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                _this.connect()            &#125;, <span class="hljs-number">2000</span>)        &#125;        <span class="hljs-built_in">this</span>.socket.onmessage(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;            _this.handleSekiroRequest(event.data)        &#125;);        <span class="hljs-built_in">this</span>.socket.onopen(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;sekiro: open a sekiro client connection&#x27;</span>)        &#125;);        <span class="hljs-built_in">this</span>.socket.onclose(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;sekiro: disconnected ,reconnection after 2s&#x27;</span>);            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                _this.connect()            &#125;, <span class="hljs-number">2000</span>)        &#125;);    &#125;;    SekiroClient.prototype.handleSekiroRequest = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requestJson</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;receive sekiro request: &quot;</span> + requestJson);        <span class="hljs-keyword">var</span> request = <span class="hljs-built_in">JSON</span>.parse(requestJson);        <span class="hljs-keyword">var</span> seq = request[<span class="hljs-string">&#x27;__sekiro_seq__&#x27;</span>];        <span class="hljs-keyword">if</span> (!request[<span class="hljs-string">&#x27;action&#x27;</span>]) &#123;            <span class="hljs-built_in">this</span>.sendFailed(seq, <span class="hljs-string">&#x27;need request param &#123;action&#125;&#x27;</span>);            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-keyword">var</span> action = request[<span class="hljs-string">&#x27;action&#x27;</span>];        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.handlers[action]) &#123;            <span class="hljs-built_in">this</span>.sendFailed(seq, <span class="hljs-string">&#x27;no action handler: &#x27;</span> + action + <span class="hljs-string">&#x27; defined&#x27;</span>);            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-keyword">var</span> theHandler = <span class="hljs-built_in">this</span>.handlers[action];        <span class="hljs-keyword">var</span> _this = <span class="hljs-built_in">this</span>;        <span class="hljs-keyword">try</span> &#123;            theHandler(request, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    _this.sendSuccess(seq, response)                &#125; <span class="hljs-keyword">catch</span> (e) &#123;                    _this.sendFailed(seq, <span class="hljs-string">&quot;e:&quot;</span> + e);                &#125;            &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">errorMessage</span>) </span>&#123;                _this.sendFailed(seq, errorMessage)            &#125;)        &#125; <span class="hljs-keyword">catch</span> (e) &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;error: &quot;</span> + e);            _this.sendFailed(seq, <span class="hljs-string">&quot;:&quot;</span> + e);        &#125;    &#125;;    SekiroClient.prototype.sendSuccess = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">seq, response</span>) </span>&#123;        <span class="hljs-keyword">var</span> responseJson;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> response == <span class="hljs-string">&#x27;string&#x27;</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                responseJson = <span class="hljs-built_in">JSON</span>.parse(response);            &#125; <span class="hljs-keyword">catch</span> (e) &#123;                responseJson = &#123;&#125;;                responseJson[<span class="hljs-string">&#x27;data&#x27;</span>] = response;            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> response == <span class="hljs-string">&#x27;object&#x27;</span>) &#123;            responseJson = response;        &#125; <span class="hljs-keyword">else</span> &#123;            responseJson = &#123;&#125;;            responseJson[<span class="hljs-string">&#x27;data&#x27;</span>] = response;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(responseJson)) &#123;            responseJson = &#123;                <span class="hljs-attr">data</span>: responseJson,                <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> (responseJson[<span class="hljs-string">&#x27;code&#x27;</span>]) &#123;            responseJson[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (responseJson[<span class="hljs-string">&#x27;status&#x27;</span>]) &#123;            responseJson[<span class="hljs-string">&#x27;status&#x27;</span>] = <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            responseJson[<span class="hljs-string">&#x27;status&#x27;</span>] = <span class="hljs-number">0</span>;        &#125;        responseJson[<span class="hljs-string">&#x27;__sekiro_seq__&#x27;</span>] = seq;        <span class="hljs-keyword">var</span> responseText = <span class="hljs-built_in">JSON</span>.stringify(responseJson);        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;response :&quot;</span> + responseText);        <span class="hljs-built_in">this</span>.socket.send(responseText);    &#125;;    SekiroClient.prototype.sendFailed = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">seq, errorMessage</span>) </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> errorMessage != <span class="hljs-string">&#x27;string&#x27;</span>) &#123;            errorMessage = <span class="hljs-built_in">JSON</span>.stringify(errorMessage);        &#125;        <span class="hljs-keyword">var</span> responseJson = &#123;&#125;;        responseJson[<span class="hljs-string">&#x27;message&#x27;</span>] = errorMessage;        responseJson[<span class="hljs-string">&#x27;status&#x27;</span>] = -<span class="hljs-number">1</span>;        responseJson[<span class="hljs-string">&#x27;__sekiro_seq__&#x27;</span>] = seq;        <span class="hljs-keyword">var</span> responseText = <span class="hljs-built_in">JSON</span>.stringify(responseJson);        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;sekiro: response :&quot;</span> + responseText);        <span class="hljs-built_in">this</span>.socket.send(responseText)    &#125;;    SekiroClient.prototype.registerAction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action, handler</span>) </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> action !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;an action must be string&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> handler !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;a handler must be function&quot;</span>);        &#125;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;sekiro: register action: &quot;</span> + action);        <span class="hljs-built_in">this</span>.handlers[action] = handler;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;    &#125;;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">guid</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">S4</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">return</span> (((<span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>.random()) * <span class="hljs-number">0x10000</span>) | <span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>).substring(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> (S4() + S4() + <span class="hljs-string">&quot;-&quot;</span> + S4() + <span class="hljs-string">&quot;-&quot;</span> + S4() + <span class="hljs-string">&quot;-&quot;</span> + S4() + <span class="hljs-string">&quot;-&quot;</span> + S4() + S4() + S4());    &#125;    <span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> SekiroClient(<span class="hljs-string">&quot;ws://127.0.0.1:5620/business-demo/register?group=rpc-test&amp;clientId=&quot;</span> + guid());    client.registerAction(<span class="hljs-string">&quot;getH5fingerprint&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request, resolve, reject</span>) </span>&#123;        resolve(utility.getH5fingerprint(request[<span class="hljs-string">&quot;url&quot;</span>]));    &#125;)&#125;)();</code></pre><p>与前面的方法一样，使用浏览器开发者工具 Overrides 重写功能，将上面的代码注入到网页 JS 里：</p><p><img src="https://cdn.itbob.cn/img/article/047/07.png" alt="07"></p><p>然后 Sekiro 为我们提供了一些 API：</p><ul><li>查看分组列表：<a href="http://127.0.0.1:5620/business-demo/groupList">http://127.0.0.1:5620/business-demo/groupList</a></li><li>查看队列状态：<a href="http://127.0.0.1:5620/business-demo/clientQueue?group=test">http://127.0.0.1:5620/business-demo/clientQueue?group=test</a></li><li>调用转发：<a href="http://127.0.0.1:5620/business-demo/invoke?group=test&amp;action=test&amp;param=testparm">http://127.0.0.1:5620/business-demo/invoke?group=test&amp;action=test&amp;param=testparm</a></li></ul><p>比如我们现在要调用 <code>utility.getH5fingerprint()</code> 加密方法该怎么办呢？很简单，代码注入到浏览器里后，首先还是要手动登录一遍，手动登录一遍，手动登录一遍，重要的事情说三遍！然后参考上面的调用转发 API 进行改写：</p><ul><li>我们自定义的分组 <code>group</code> 是 <code>rpc-test</code>；</li><li>事件 <code>action</code> 是 <code>getH5fingerprint</code>；</li><li>待加密参数名称为 <code>url</code>， 其值例如为：<code>https://www.baidu.com/</code></li></ul><p>那么我们的调用链接就应该是：<code>http://127.0.0.1:5620/business-demo/invoke?group=rpc-test&amp;action=getH5fingerprint&amp;url=https://www.baidu.com/</code>，直接浏览器打开，返回的字典，data 里面就是加密结果：</p><p><img src="https://cdn.itbob.cn/img/article/047/08.png" alt="08"></p><p>同样的，在本地用 Python 的话，直接 requests 就完事儿了：</p><p><img src="https://cdn.itbob.cn/img/article/047/09.png" alt="09"></p><p>我们前面是把 sekiro_web_client.js 复制下来和通信代码一起注入到浏览器的，这里我们还可以有更加优雅的方法，直接给 document 新创建一个 script，通过链接的形式插入 sekiro_web_client.js，这里需要注意一下几点问题：</p><ol><li>第一个是时机的问题，需要等待 document 这些元素加载完成才能建立 SekiroClient 通信，不然调用 SekiroClient 是会报错的，这里可以用 setTimeout 方法，该方法用于在指定的毫秒数后调用函数或计算表达式，将 SekiroClient 通信代码单独封装成一个函数，比如 <code>function startSekiro()</code>，然后等待 1-2 秒后再执行 SekiroClient 通信代码；</li><li>由于 SekiroClient 通信代码被封装成了函数，此时直接调用 <code>utility.getH5fingerprint</code> 是会提示未定义的，所以我们要先将其导为全局变量，比如 <code>window.getH5fingerprint = utility.getH5fingerprint</code>，后续直接调用 <code>window.getH5fingerprint</code> 即可。</li></ol><p>完整代码如下所示：</p><pre><code class="hljs javascript"><span class="hljs-comment">/* ==================================</span><span class="hljs-comment"># @Time    : 2022-02-14</span><span class="hljs-comment"># @Author  : ITBOB.CN</span><span class="hljs-comment"># @FileName: sekiro.js</span><span class="hljs-comment"># @Software: PyCharm</span><span class="hljs-comment"># ================================== */</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> newElement = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;script&quot;</span>);    newElement.setAttribute(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;text/javascript&quot;</span>);    newElement.setAttribute(<span class="hljs-string">&quot;src&quot;</span>, <span class="hljs-string">&quot;https://sekiro.virjar.com/sekiro-doc/assets/sekiro_web_client.js&quot;</span>);    <span class="hljs-built_in">document</span>.body.appendChild(newElement);    <span class="hljs-built_in">window</span>.getH5fingerprint = utility.getH5fingerprint    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">guid</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">S4</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">return</span> (((<span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>.random()) * <span class="hljs-number">0x10000</span>) | <span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>).substring(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> (S4() + S4() + <span class="hljs-string">&quot;-&quot;</span> + S4() + <span class="hljs-string">&quot;-&quot;</span> + S4() + <span class="hljs-string">&quot;-&quot;</span> + S4() + <span class="hljs-string">&quot;-&quot;</span> + S4() + S4() + S4());    &#125;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startSekiro</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> SekiroClient(<span class="hljs-string">&quot;ws://127.0.0.1:5620/business-demo/register?group=rpc-test&amp;clientId=&quot;</span> + guid());        client.registerAction(<span class="hljs-string">&quot;getH5fingerprint&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request, resolve, reject</span>) </span>&#123;            resolve(<span class="hljs-built_in">window</span>.getH5fingerprint(request[<span class="hljs-string">&quot;url&quot;</span>]));        &#125;)    &#125;    <span class="hljs-built_in">setTimeout</span>(startSekiro, <span class="hljs-number">2000</span>)&#125;)();</code></pre><p><img src="https://cdn.itbob.cn/img/article/047/10.png" alt="10"></p><h2><span id="you-que-dian">优缺点</span></h2><p>目前如果不去逆向 JS 来实现加密参数的话，用得最多的就是自动化工具了，比如 Selenium、Puppeteer 等，很显然这些自动化工具配置繁琐、运行效率极低，而 RPC 技术不需要加载多余的资源，稳定性和效率明显都更高，RPC 不需要考虑浏览器指纹、各种环境，如果风控不严的话，高并发也是能够轻松实现的，相反，由于 RPC 是一直挂载在同一个浏览器上的，所以针对风控较严格的站点，比如检测 UA、IP 与加密参数绑定之类的，那么 PRC 调用太频繁就不太行了，当然也可以研究研究浏览器群控技术，操纵多个不同浏览器可以一定程度上缓解这个问题。总之 RPC 技术还是非常牛的，除了 JS 逆向，可以说是目前比较万能、高效的方法了，一定程度上做到了加密参数一把梭！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/rpc.png&quot; alt=&quot;rpc&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>吾爱破解2022春节解题领红包之番外篇 Web 中级题解</title>
    <link href="https://www.itbob.cn/article/046/"/>
    <id>https://www.itbob.cn/article/046/</id>
    <published>2022-02-17T00:43:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="wen-zhang-mu-lu">文章目录</span></h2><!-- toc --><ul><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#hls-liu-mei-ti-chuan-shu-xie-yi">HLS 流媒体传输协议</a></li><li><a href="#saz-fen-xi">SAZ 分析</a></li><li><a href="#js-ni-xiang">JS 逆向</a></li><li><a href="#ts-jie-mi-he-bing-zhuan-huan">TS 解密合并转换</a></li></ul><!-- tocstop --><hr><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><p>本次逆向的目标来源于吾爱破解 2022 春节解题领红包之番外篇 Web 中级题，吾爱破解每年都会有派送红包活动（送吾爱币），需要大家使出看家逆向本领来分析内容获得口令红包，今年一共有五个题，一个送分题，两个 Windows 题、一个 Android 题和一个 Web 题，本文分析的正是  Web 题，<strong>吾爱有规定活动结束前不要外泄口令、讨论分享分析过程，所以本文在活动结束后才发出来。</strong></p><p>此 Web 题题目是：小 D 最爱看的视频网站最近关站了，关站前他用 Fiddler 和 Web Archive 保存了一位主播的视频，但他发现存下来的文件无法播放。你能帮小 D 找回他的回忆吗？（.saz 与 .wacz 任选其一即可解题）</p><ul><li><p>活动地址：<a href="https://www.52pojie.cn/thread-1582582-1-1.html">https://www.52pojie.cn/thread-1582582-1-1.html</a></p></li><li><p>Web 题地址：<a href="https://www.52pojie.cn/home.php?mod=task&amp;do=view&amp;id=17">https://www.52pojie.cn/home.php?mod=task&amp;do=view&amp;id=17</a></p></li></ul><h2><span id="hls-liu-mei-ti-chuan-shu-xie-yi">HLS 流媒体传输协议</span></h2><p>本题涉及到 HLS 流媒体传输协议，先简单介绍一下，了解的同志可直接跳过。</p><p>HLS 全称 HTTP Live Streaming，即基于 HTTP 的自适应码率流媒体传输协议，是苹果研发的动态码率自适应技术，它包括一个 M3U(8) 的索引文件，若干 TS 视频流文件，如果视频流文件是加密的，那就还会存在一个 key 加密串文件。</p><p>M3U8 文件是 M3U 的一种，只不过文件中存储的文本使用 UTF-8 字符编码，在极少数情况下，M3U8 文件可能会以 M3UP 扩展名保存。M3U8 文件是各种音频和视频播放程序使用的播放列表文件，它包含了媒体文件或媒体文件夹的路径或 URL，以及有关播放列表的相关信息。</p><p>TS 全称为 MPEG2-TS，TS 即 Transport Stream 传输流，又称 MPEG-TS、MTS、TP，这种格式的特点就是从视频流的任一片段开始都是可以独立解码的。</p><p>针对 TS 格式的文件，如果是未加密的，一般的播放器就能够直接播放，也可以使用 FFmpeg 等工具转换为其他格式，FFmpeg 也可以直接处理 M3U8 文件，自动解密合并转换 TS 文件，当然也有其他大佬写好的小工具，拖入 M3U8 文件就直接给你处理好了。</p><p><img src="https://cdn.itbob.cn/img/article/046/01.png" alt="01.png"></p><p>M3U8 文件内容的大致格式示例如下：</p><pre><code class="hljs awk"><span class="hljs-comment">#EXTM3U</span><span class="hljs-comment">#EXT-X-VERSION:3</span><span class="hljs-comment">#EXT-X-MEDIA-SEQUENCE:0</span><span class="hljs-comment">#EXT-X-ALLOW-CACHE:YES</span><span class="hljs-comment">#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://www.example.com/m3u8.key&quot;</span><span class="hljs-comment">#EXT-X-TARGETDURATION:5</span><span class="hljs-comment">#EXTINF:4.200000,</span>https:<span class="hljs-regexp">//</span>www.example.com<span class="hljs-regexp">/hls/</span>live_00000.ts<span class="hljs-comment">#EXTINF:4.166667,</span>https:<span class="hljs-regexp">//</span>www.example.com<span class="hljs-regexp">/hls/</span>live_00001.ts<span class="hljs-comment">#EXTINF:3.600000,</span>https:<span class="hljs-regexp">//</span>www.example.com<span class="hljs-regexp">/hls/</span>live_00002.ts<span class="hljs-comment">#EXTINF:2.516667,</span>https:<span class="hljs-regexp">//</span>www.example.com<span class="hljs-regexp">/hls/</span>live_00003.ts<span class="hljs-comment">#EXTINF:4.166667,</span>https:<span class="hljs-regexp">//</span>www.example.com<span class="hljs-regexp">/hls/</span>live_00004.ts<span class="hljs-comment">#EXTINF:4.166667,</span>https:<span class="hljs-regexp">//</span>www.example.com<span class="hljs-regexp">/hls/</span>live_00005.ts<span class="hljs-comment">#EXTINF:4.166667,</span>https:<span class="hljs-regexp">//</span>www.example.com<span class="hljs-regexp">/hls/</span>live_00006.ts<span class="hljs-comment">#EXTINF:1.716667,</span>https:<span class="hljs-regexp">//</span>www.example.com<span class="hljs-regexp">/hls/</span>live_00007.ts<span class="hljs-comment">#EXT-X-ENDLIST</span></code></pre><p>各标签含义如下：</p><ul><li><code>#EXTM3U</code>：m3u文件头，必须放在第一行，起标示作用；</li><li><code>#EXT-X-VERSION</code>：播放列表文件的兼容版本。若不存在此标记，则默认为协议的第一个版本；</li><li><code>#EXT-X-MEDIA-SEQUENCE</code>： 播放列表中的每个媒体 URI 都有一个唯一的整数序列号。URI 的序列号等于它之前的 URI 的序列号加一；</li><li><code>#EXT-X-ALLOW-CACHE</code>：指示客户端是否可以缓存下载的媒体片段以供以后重播；</li><li><code>#EXT-X-KEY</code>：TS 片段可以被加密，该标签指定加密方式（METHOD）、密钥的 URI 以及偏移量 IV 等信息，没有此标签表示未加密；</li><li><code>#EXT-X-TARGETDURATION</code>：每一份 TS 媒体文件的最大持续时间，以秒为单位；</li><li><code>#EXTINF</code>：每一份媒体文件的详细信息，包括媒体持续时间、媒体 URL 地址等；</li><li><code>#EXT-X-ENDLIST</code>：表示不再将媒体片段添加到播放列表文件中，一般位于文件结尾。</li></ul><p>完整格式、标准标签可参考 HLS 标准协议中，对 Playlist file 的介绍：<a href="https://datatracker.ietf.org/doc/html/draft-pantos-http-live-streaming-08">https://datatracker.ietf.org/doc/html/draft-pantos-http-live-streaming-08</a></p><h2><span id="saz-fen-xi">SAZ 分析</span></h2><p>在 Fiddler 软件中，使用 SAZ 格式用来保存和读取 HTTP/HTTPS 请求信息，打开该文件可以注意到一些重要的请求：script.bundle.js、live.m3u8、drm 以及八个 ts 视频流文件。</p><p>先来看看 m3u8 文件，可以看到是 AES-128 加密，加密的 key 文件地址为 <code>key://live</code>，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/046/02.png" alt="02.png"></p><p>一般情况下，要想解密 ts，必然会去请求 key 的地址，拿到 key 后再解密 ts，很显然此题的 key 地址不是一个合法的 URL 地址，当然此题的抓包记录可能是出题人伪造的，因为这个 Host 是 52tube.mmxxii，也不是一个合法的域名，最主要的是，抓包记录里没有 <code>key://live</code> 这条请求，那么很大概率真实的地址隐藏在 JS 里，从另一个方面来思考，如果这是完整的抓包记录，不管真实的 key 地址是啥，必然会在记录里出现！</p><p>有经验的朋友应该一眼就能看出来 drm 这条请求最有可能是拿 key 的操作了，第一是 drm 这个关键词在 ts 解密里经常会出现，搞得多的朋友应该见过不少，第二 ping 请求返回的 success，通过其名称和返回值来看也不像 key，剩下就只有 drm 了，查看返回值是乱码的，查看 Hex 值，32 位 16 进制数据，而正常的 key 应该是 16 位 16 进制数据，所以你如果直接拿这个数据当作 key 去解密，肯定也是失败的。</p><p>到这里我们应该有如下猜想：drm 返回的数据，经过了 script.bundle.js 二次处理就能得到正确的 key。</p><p><img src="https://cdn.itbob.cn/img/article/046/03.png" alt="03.png"></p><h2><span id="js-ni-xiang">JS 逆向</span></h2><p>我们把抓包记录的 script.bundle.js，右键，save - response - response body，保存到本地。</p><p>格式化之后有 15000+ 行代码，又不能动态调试，从哪里找加密入口呢？可以大胆尝试一下：</p><ul><li>JS 里可能会检测到 m3u8 里存在 key 的 URI 之后，发送 /api/drm/ 这个请求，可以直接搜索 <code>/api/drm/</code> 或者 <code>key://live</code> 定位；</li><li>drm 是一个 post 请求，带有 h 和 id 两个参数，可以直接搜索 <code>post</code>、<code>id</code>、<code>h</code> 定位到大致位置。</li></ul><p><img src="https://cdn.itbob.cn/img/article/046/04.png" alt="04.png"></p><p>通过搜索可以发现如下可疑代码片段：</p><p><img src="https://cdn.itbob.cn/img/article/046/05.png" alt="05.png"></p><p>将关键代码提炼一下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params">t</span>) </span>&#123;    <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Uint8Array</span>(t)].map((<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> t.toString(<span class="hljs-number">16</span>).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>))).join(<span class="hljs-string">&quot;&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params">t, e</span>) </span>&#123;    <span class="hljs-keyword">let</span> r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(t.length);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; t.length; i++) r[i] = t[i] ^ e[i];    <span class="hljs-keyword">return</span> r&#125;<span class="hljs-keyword">let</span> e = <span class="hljs-string">&quot;/api/ping/&quot;</span>,    i = <span class="hljs-string">&quot;/api/drm/&quot;</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">a</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">t</span>.<span class="hljs-title">DefaultConfig</span>.<span class="hljs-title">loader</span> </span>&#123;    <span class="hljs-keyword">let</span> e = <span class="hljs-keyword">await</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">let</span> t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">16</span>);        crypto.getRandomValues(t);        <span class="hljs-keyword">let</span> e = n(t.buffer) + <span class="hljs-built_in">Date</span>.now() + <span class="hljs-built_in">Math</span>.random();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>((<span class="hljs-keyword">await</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t</span>) </span>&#123;            <span class="hljs-keyword">const</span> e = (<span class="hljs-keyword">new</span> TextEncoder).encode(t);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> crypto.subtle.digest(<span class="hljs-string">&quot;SHA-256&quot;</span>, e)        &#125; (e)).slice(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>))    &#125;();    <span class="hljs-keyword">var</span> r = <span class="hljs-keyword">new</span> URLSearchParams;    r.append(<span class="hljs-string">&quot;h&quot;</span>, n(e.buffer)),        r.append(<span class="hljs-string">&quot;id&quot;</span>, t);    <span class="hljs-keyword">var</span> a = &#123;        <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,        <span class="hljs-attr">headers</span>: &#123;            <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>        &#125;,        <span class="hljs-attr">body</span>: r    &#125;;    <span class="hljs-keyword">let</span> o = <span class="hljs-keyword">await</span> fetch(i, a),        l = <span class="hljs-keyword">await</span> o.arrayBuffer();    <span class="hljs-keyword">if</span> (<span class="hljs-number">32</span> !== l.byteLength) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Invalid response&quot;</span>);    <span class="hljs-keyword">let</span> u = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(l.slice(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>)),        c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(l.slice(<span class="hljs-number">16</span>, <span class="hljs-number">32</span>));    <span class="hljs-keyword">return</span> s(s(u, e), c)&#125;</code></pre><p>可以看到事实上在发送 <code>/api/drm/</code> 请求拿到结果后，先后取前后 16 位数据，然后经过了 s 方法的处理，最后返回的 <code>s(s(u, e), c)</code> 应该才是正确的 key，这里的重点在于 e 的值，上面有个方法，取了当前时间+随机值，经过 SHA-256 加密，再取前 16 位。</p><p>这里可以思考一下，这个 e 的值是不固定的，那么最后的 key 应该也是不固定的，同一个 TS 对应有无数个 key，我反正是没见过，不信的话尝试就用那个方法生成 e，你会发现最终的 key 是错误的。</p><p>仔细看一下，发送 post 请求对 h 值赋值的地方：<code>r.append(&quot;h&quot;, n(e.buffer))</code>，n 方法是转 16 进制，那么我们直接将 h 值倒推，从16进制转为10进制，这才是正确的 e 的值！然后 l 的值是 <code>/api/drm/</code> 请求返回的 32 位 16 进制数据转为 10 进制，剩下的就好说了，直接改写一下 JS 代码拿到正确的 key：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params">t, e</span>) </span>&#123;    <span class="hljs-keyword">let</span> r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(t.length);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; t.length; i++)        r[i] = t[i] ^ e[i];    <span class="hljs-keyword">return</span> r&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getKey</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">// /api/drm/ 请求表单的 h 值，16进制数据</span>    <span class="hljs-keyword">const</span> h = [<span class="hljs-string">&quot;7b&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;31&quot;</span>, <span class="hljs-string">&quot;1e&quot;</span>, <span class="hljs-string">&quot;6e&quot;</span>, <span class="hljs-string">&quot;31&quot;</span>, <span class="hljs-string">&quot;0f&quot;</span>, <span class="hljs-string">&quot;0d&quot;</span>, <span class="hljs-string">&quot;f0&quot;</span>, <span class="hljs-string">&quot;68&quot;</span>, <span class="hljs-string">&quot;d9&quot;</span>, <span class="hljs-string">&quot;ed&quot;</span>, <span class="hljs-string">&quot;e1&quot;</span>, <span class="hljs-string">&quot;04&quot;</span>, <span class="hljs-string">&quot;75&quot;</span>, <span class="hljs-string">&quot;a8&quot;</span>];    <span class="hljs-comment">// /api/drm/ 请求返回的32位16进制数据</span>    <span class="hljs-keyword">const</span> drm = [<span class="hljs-string">&quot;08&quot;</span>, <span class="hljs-string">&quot;A5&quot;</span>, <span class="hljs-string">&quot;E6&quot;</span>, <span class="hljs-string">&quot;C2&quot;</span>, <span class="hljs-string">&quot;C2&quot;</span>, <span class="hljs-string">&quot;61&quot;</span>, <span class="hljs-string">&quot;A8&quot;</span>, <span class="hljs-string">&quot;AC&quot;</span>, <span class="hljs-string">&quot;B4&quot;</span>, <span class="hljs-string">&quot;D7&quot;</span>, <span class="hljs-string">&quot;9C&quot;</span>, <span class="hljs-string">&quot;49&quot;</span>, <span class="hljs-string">&quot;AF&quot;</span>, <span class="hljs-string">&quot;16&quot;</span>, <span class="hljs-string">&quot;0A&quot;</span>, <span class="hljs-string">&quot;3A&quot;</span>, <span class="hljs-string">&quot;DA&quot;</span>, <span class="hljs-string">&quot;4E&quot;</span>, <span class="hljs-string">&quot;5C&quot;</span>, <span class="hljs-string">&quot;EA&quot;</span>, <span class="hljs-string">&quot;E1&quot;</span>, <span class="hljs-string">&quot;6F&quot;</span>, <span class="hljs-string">&quot;ED&quot;</span>, <span class="hljs-string">&quot;46&quot;</span>, <span class="hljs-string">&quot;EB&quot;</span>, <span class="hljs-string">&quot;6F&quot;</span>, <span class="hljs-string">&quot;49&quot;</span>, <span class="hljs-string">&quot;8C&quot;</span>, <span class="hljs-string">&quot;9B&quot;</span>, <span class="hljs-string">&quot;63&quot;</span>, <span class="hljs-string">&quot;D5&quot;</span>, <span class="hljs-string">&quot;3B&quot;</span>]    <span class="hljs-comment">// 转换为10进制数据，为 e 和 l 赋值</span>    <span class="hljs-keyword">const</span> e = [];    <span class="hljs-keyword">const</span> l = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;h.length; i++)    &#123;        e.push(<span class="hljs-built_in">parseInt</span>(h[i],<span class="hljs-number">16</span>))    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;drm.length; i++)    &#123;        l.push(<span class="hljs-built_in">parseInt</span>(drm[i],<span class="hljs-number">16</span>))    &#125;    <span class="hljs-keyword">const</span> u = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(l.slice(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>));    <span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(l.slice(<span class="hljs-number">16</span>, <span class="hljs-number">32</span>));    <span class="hljs-keyword">const</span> keyArray = s(s(u, e), c);    <span class="hljs-keyword">const</span> keyHex = <span class="hljs-keyword">new</span> Buffer.from(keyArray).toString(<span class="hljs-string">&#x27;hex&#x27;</span>);    <span class="hljs-keyword">const</span> keyBase64 = <span class="hljs-keyword">new</span> Buffer.from(keyArray).toString(<span class="hljs-string">&#x27;base64&#x27;</span>);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;keyArray: &quot;</span>, keyArray)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;keyHex: &quot;</span>, keyHex)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;keyBase64: &quot;</span>, keyBase64)&#125;getKey()<span class="hljs-comment">// 输出</span><span class="hljs-comment">// keyArray:  Uint8Array(16) [</span><span class="hljs-comment">//   169, 251, 139,  54,  77,</span><span class="hljs-comment">//    63,  74, 231, 175, 208,</span><span class="hljs-comment">//    12,  40, 213, 113, 170,</span><span class="hljs-comment">//   169</span><span class="hljs-comment">// ]</span><span class="hljs-comment">// keyHex:  a9fb8b364d3f4ae7afd00c28d571aaa9</span><span class="hljs-comment">// keyBase64:  qfuLNk0/Suev0Awo1XGqqQ==</span></code></pre><h2><span id="ts-jie-mi-he-bing-zhuan-huan">TS 解密合并转换</span></h2><p>通过 JS 逆向我们拿到了 16进制和 base64 形式的  key，不管什么形式都可以拿来解密，这里介绍两种对 TS 媒体流解密、合并、转换的方法。</p><p>第一种方法是使用 FFmpeg 工具，FFmpeg 是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。官网地址：<a href="https://ffmpeg.org/">https://ffmpeg.org/</a> ，下载编译好的程序，将 bin 目录添加到环境变量即可。</p><p>首先我们要把 m3u8 文件和 ts 媒体流保存到同一个文件夹，由于是虚假的 Host，所以不能直接浏览器访问保存，可以直接在 Fiddler 里，右键，save - response - response body，保存到本地，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/046/06.png" alt="06.png"></p><p>然后就是保存密钥文件，这里要求密钥文件必须是16进制的数据，如果你直接将 key 以字符串形式保存的话，解密也是失败的，编辑 16 进制文件有专门的工具，比如 HxD、010 editor、winhex 等，以 HxD 为例，新建文件，写入我们前面通过 JS 逆向得到的 key 的 16 进制数据，存为 .key 文件，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/046/07.png" alt="07.png"></p><p>然后修改 m3u8 文件里 key 的地址、名称，建议将 key、m3u8、ts 文件都放同一个文件夹，这样 m3u8 文件里就不用添加资源路径了，不容易出错。</p><p><img src="https://cdn.itbob.cn/img/article/046/08.png" alt="08.png"></p><p>然后在当前文件夹，打开命令行输入命令：<code>ffmpeg -allowed_extensions ALL -i live.m3u8 -c copy live.mp4</code>，即可自动解密 ts，并合并转换为 .mp4 格式：</p><p><img src="https://cdn.itbob.cn/img/article/046/09.png" alt="09.png"></p><p><img src="https://cdn.itbob.cn/img/article/046/10.png" alt="10.png"></p><p>第二种方法就是使用大佬写的第三方小工具，这里推荐吾爱大佬逍遥一仙写的 M3U8 批量下载器，下载地址、使用方法见原贴：<a href="https://www.52pojie.cn/thread-1374045-1-1.html">https://www.52pojie.cn/thread-1374045-1-1.html</a></p><p>我们可以直接拖入处理好的 M3U8 文件，自动处理：</p><p><img src="https://cdn.itbob.cn/img/article/046/11.png" alt="11.png"></p><p>也可以选择其他 - 工具 - 合并助手，添加所有 TS 文件，输入 key 后自动处理：</p><p><img src="https://cdn.itbob.cn/img/article/046/12.png" alt="12.png"></p><p>处理完毕后的 mp4 文件默认在软件目录的 output 文件夹里面，解密后是一段动画，往后看会找到 flag：<code>flag&#123;like_sub_52tube&#125;</code> 为正确答案。</p><p><img src="https://cdn.itbob.cn/img/article/046/13.png" alt="13.png"></p><p><img src="https://cdn.itbob.cn/img/article/046/14.png" alt="14.png"></p><p><img src="https://cdn.itbob.cn/img/article/046/15.png" alt="15.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;&lt;/h2&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#ni-xiang-mu-biao&quot;&gt;逆向目标&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#hls-liu-mei-ti</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>CTF&amp;爬虫：掌握这些特征，一秒识别密文加密方式</title>
    <link href="https://www.itbob.cn/article/045/"/>
    <id>https://www.itbob.cn/article/045/</id>
    <published>2022-01-13T09:40:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/encryption_algorithm.png" alt="encryption_algorithm"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#qian-yan">前言</a></li><li><a href="#bian-ma-xi-lie">编码系列</a><ul><li><a href="#base-xi-lie-bian-ma">Base 系列编码</a></li><li><a href="#unicode-bian-ma">Unicode 编码</a></li><li><a href="#escape-bian-ma">Escape 编码</a></li><li><a href="#url-hex-bian-ma">URL / Hex 编码</a></li></ul></li><li><a href="#jia-mi-suan-fa">加密算法</a><ul><li><a href="#md5">MD5</a></li><li><a href="#sha-xi-lie">SHA 系列</a></li><li><a href="#hmac-xi-lie">HMAC 系列</a></li><li><a href="#rsa">RSA</a></li><li><a href="#aes-des-3des-rc4-rabbit-deng">AES、DES、3DES、RC4、Rabbit 等</a></li><li><a href="#sm-xi-lie">SM 系列</a></li></ul></li><li><a href="#hun-yao-xi-lie">混淆系列</a><ul><li><a href="#obfuscator">Obfuscator</a></li><li><a href="#jjencode">JJEncode</a></li><li><a href="#aaencode">AAEncode</a></li><li><a href="#jsfuck">JSFuck</a></li><li><a href="#jother">Jother</a></li><li><a href="#brainfuck">Brainfuck</a></li><li><a href="#ook">Ook!</a></li><li><a href="#trivial-brainfuck-substitution">Trivial brainfuck substitution</a></li></ul></li><li><a href="#qi-ta">其他</a><ul><li><a href="#kai-sa-mi-ma">恺撒密码</a></li><li><a href="#zha-lan-mi-ma">栅栏密码</a></li><li><a href="#zhu-quan-mi-ma">猪圈密码</a></li><li><a href="#mo-si-mi-ma">摩斯密码</a></li><li><a href="#pei-gen-mi-ma">培根密码</a></li><li><a href="#wei-ji-ni-ya-mi-ma">维吉尼亚密码</a></li><li><a href="#yu-fo-lun-shan">与佛论禅</a></li><li><a href="#dang-pu-mi-ma">当铺密码</a></li></ul></li></ul><!-- tocstop --><hr><h2><span id="qian-yan">前言</span></h2><p>爬虫工程师在做加密参数逆向的时候，经常会遇到各种各样的加密算法、编码、混淆，每个算法都有其对应的特征，对于一些较小的网站，往往直接引用这些官方算法，没有进行魔改等其他操作，这种情况下，如果我们能熟悉常见算法的特征，通过密文就能猜测出使用的哪种算法、编码、混淆，将会大大提高工作效率！在 CTF 中通常也会有密码类的题目，掌握一些常见密文特征也是 CTFer 们必备的技能！</p><p>本文将介绍以下编码和加密算法的特征：</p><ul><li>编码：Base 系列、Unicode、Escape、URL、Hex；</li><li>算法：MD5、SHA 系列、HMAC 系列、RSA、AES、DES、3DES、RC4、Rabbit、SM 系列；</li><li>混淆：Obfuscator、JJEncode、AAEncode、JSFuck、Jother、Brainfuck、Ook!、Trivial brainfuck substitution；</li><li>其他：恺撒密码、栅栏密码、猪圈密码、摩斯密码、培根密码、维吉尼亚密码、与佛论禅、当铺密码。</li></ul><p>PS：常见加密算法原理以及在 Python 和 JavaScript 中的实现方法可参见以前的文章：<a href="https://www.itbob.cn/article/039/">爬虫常见加密解密算法总结</a></p><h2><span id="bian-ma-xi-lie">编码系列</span></h2><h3><span id="base-xi-lie-bian-ma">Base 系列编码</span></h3><p>Base64 是我们最常见的编码，除此之外，其实还有 Base16、Base32、Base58、Base85、Base100 等，他们之间最明显的区别就是使用了不同数量的可打印字符对任意字节数据进行编码，比如 Base64 使用了64个可打印字符（A-Z、a-z、0-9、+、/），Base16 使用了16个可打印字符（A-F、0-9），这里主要讲怎么快速识别，其具体原理可自行百度，Base 系列主要特征如下：</p><ul><li>Base16：结尾没有等号，数字要多于字母；</li><li>Base32：字母要多于数字，明文数量超过10个，结尾可能会有很多等号；</li><li>Base58：结尾没有等号，字母要多于数字；</li><li>Base64：一般情况下结尾都会有1个或者2个等号，明文很少的时候可能没有；</li><li>Base85：等号一般出现在字符串中间，含有一些奇怪的字符；</li><li>Base100：密文由 Emoji 表情组成。</li></ul><p>示例：</p><table><thead><tr><th style="text-align:left">编码类型</th><th style="text-align:left">示例一</th><th>示例二</th></tr></thead><tbody><tr><td style="text-align:left">明文</td><td style="text-align:left">01234567890</td><td>administrators</td></tr><tr><td style="text-align:left">Base16</td><td style="text-align:left"><code>3031323334353637383930</code></td><td><code>61646D696E6973747261746F7273</code></td></tr><tr><td style="text-align:left">Base32</td><td style="text-align:left"><code>GAYTEMZUGU3DOOBZGA======</code></td><td><code>MFSG22LONFZXI4TBORXXE4Y=</code></td></tr><tr><td style="text-align:left">Base58</td><td style="text-align:left"><code>cX8j8pvGzppMKVb</code></td><td><code>BNF5dFLUTN5XwM1yLoF</code></td></tr><tr><td style="text-align:left">Base64</td><td style="text-align:left"><code>MDEyMzQ1Njc4OTA=</code></td><td><code>YWRtaW5pc3RyYXRvcnM=</code></td></tr><tr><td style="text-align:left">Base85</td><td style="text-align:left"><code>0JP==1c70M3&amp;rY</code></td><td><code>@:X4hDJ=06Eaa'.EcV</code></td></tr><tr><td style="text-align:left">Base100</td><td style="text-align:left"><code>🐧🐨🐩🐪🐫🐬🐭🐮🐯🐰🐧</code></td><td><code>👘👛👤👠👥👠👪👫👩👘👫👦👩👪</code></td></tr></tbody></table><h3><span id="unicode-bian-ma">Unicode 编码</span></h3><p>Unicode 又称为统一码、万国码、单一码，是一种在计算机上使用的字符编码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。其主要特征如下：</p><ul><li>以 <code>\u</code>、<code>&amp;#</code> 或 <code>&amp;#x</code> 开头，后面是数字加字母组合</li></ul><p>PS：<code>\u</code> 开头和 <code>&amp;#x</code> 开头是一样的，都是16进制 Unicode 字符的不同写法，<code>&amp;#</code> 则是 Unicode 字符10进制的写法，此外，<code>&amp;#</code> 和 <code>&amp;#x</code> 开头的，也称为 HTML 字符实体转换，字符实体是用一个编号写入 HTML 代码中来代替一个字符，在 HTML 中，某些字符是预留的，如果希望正确地显示预留字符，就必须在 HTML 源代码中使用字符实体。</p><table><thead><tr><th>编码类型</th><th>示例一</th><th>示例二</th></tr></thead><tbody><tr><td>明文</td><td>12345</td><td>admin</td></tr><tr><td>Unicode</td><td><code>\u0031\u0032\u0033\u0034\u0035</code></td><td><code>\u0061\u0064\u006d\u0069\u006e</code></td></tr></tbody></table><h3><span id="escape-bian-ma">Escape 编码</span></h3><p>Escape 编码又叫 %u 编码，Escape 编码就是字符对应 UTF-16BE 表示方式前面加 %u，Escape 不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： <code>* @ - _ + . / </code>，其他所有的字符都会被转义序列替换。其主要特征如下：</p><ul><li>以 <code>%u</code> 开头，后面是数字加字母组合</li></ul><table><thead><tr><th>编码类型</th><th>示例一</th><th>示例二</th></tr></thead><tbody><tr><td>明文</td><td>爬虫</td><td>我爱Python</td></tr><tr><td>Escape</td><td><code>%u722C%u866B</code></td><td><code>%u6211%u7231Python</code></td></tr></tbody></table><h3><span id="url-hex-bian-ma">URL / Hex 编码</span></h3><p>URL 和 Hex 编码的结果是一样的，不同的是当你用 URL 编码网址时是不会把 <code>http</code>、<code>https</code> 关键字和 <code>/</code>、<code>?</code>、<code>&amp;</code>、<code>=</code> 等连接符进行编码的，而 Hex 编码则全部转化了，其主要特征如下：</p><ul><li>以 <code>%</code> 开头，后面是数字加字母组合</li></ul><table><thead><tr><th>编码类型</th><th>示例</th></tr></thead><tbody><tr><td>明文</td><td><a href="https://www.kuaidaili.com/">https://www.kuaidaili.com/</a></td></tr><tr><td>Unicode</td><td><code>https://%77%77%77%2E%6B%75%61%69%64%61%69%6C%69%2E%63%6F%6D/</code></td></tr><tr><td>Hex</td><td><code>%68%74%74%70%73%3a%2f%2f%77%77%77%2e%6b%75%61%69%64%61%69%6c%69%2e%63%6f%6d%2f</code></td></tr></tbody></table><h2><span id="jia-mi-suan-fa">加密算法</span></h2><h3><span id="md5">MD5</span></h3><p>MD5 实质是一种消息摘要算法，一个数据的 MD5 值是唯一的，同一个数据不可能计算出多个不同的 MD5 值，但是，不同数据计算出来的 MD5 值是有可能一样的，知道一个 MD5 值，理论上是无法还原出它的原始数据的，MD5 是最容易辨别的，主要特征如下：</p><ul><li>密文一般为 16 位或者 32 位，其中 16 位是取的 32 位第 9~25 位的值；</li><li>组成方式为字母（a-f）和数字（0-9）混合，字母可以全部是大写或者小写。</li></ul><p>除了通过密文特征来判断以外，我们还可以搜索源代码，标准 MD5 的源码里是包含了一些特定的值的，没有这些特定值，就无法实现 MD5：</p><ul><li><code>0123456789ABCDEF</code>、<code>0123456789abcdef</code></li><li><code>1732584193</code>、<code>-271733879</code>、<code>-1732584194</code>、<code>271733878</code></li></ul><p>PS：某些特殊情况下，密文的长度也有可能不止 16 位或者 32 位，有可能是在官方算法上有一些魔改，通常也是在 16 位的基础上，左右填充了一些随机字符串。</p><p>示例：</p><table><thead><tr><th>编码类型</th><th>示例一</th><th>示例二</th></tr></thead><tbody><tr><td>明文</td><td>123456</td><td>admin</td></tr><tr><td>MD5（16位小写）</td><td><code>49ba59abbe56e057</code></td><td><code>7a57a5a743894a0e</code></td></tr><tr><td>MD5（16位大写）</td><td><code>49BA59ABBE56E057</code></td><td><code>7A57A5A743894A0E</code></td></tr><tr><td>MD5（32位小写）</td><td><code>e10adc3949ba59abbe56e057f20f883e</code></td><td><code>21232f297a57a5a743894a0e4a801fc3</code></td></tr><tr><td>MD5（32位大写）</td><td><code>E10ADC3949BA59ABBE56E057F20F883E</code></td><td><code>21232F297A57A5A743894A0E4A801FC3</code></td></tr></tbody></table><h3><span id="sha-xi-lie">SHA 系列</span></h3><p>SHA 是比 MD5 更安全一点的摘要算法，SHA 通常指 SHA 家族算法，分别是 SHA-1、SHA-2、SHA-3，其中 SHA-2 是 SHA-224、SHA-256、SHA-384、SHA-512 的并称，SHA-3 是 SHA3-224、SHA3-256、SHA3-384、SHA3-512、SHAKE128、SHAKE256 的并称，其名字的后缀的数字就代表了结果的大小（bit），注意，SHAKE 算法结果的大小并不是固定的，其他算法特征如下：</p><ul><li>SHA-1：字母（a-f）和数字（0-9）混合，固定位数 40 位；</li><li>SHA-224/SHA3-224：字母（a-f）和数字（0-9）混合，固定位数 56 位；</li><li>SHA-256/SHA3-256：字母（a-f）和数字（0-9）混合，固定位数 64 位；</li><li>SHA-384/SHA3-384：字母（a-f）和数字（0-9）混合，固定位数 96 位；</li><li>SHA-512/SHA3-512：字母（a-f）和数字（0-9）混合，固定位数 128 位。</li></ul><p>示例：</p><table><thead><tr><th>编码类型</th><th>示例</th></tr></thead><tbody><tr><td>明文</td><td>123456</td></tr><tr><td>SHA-1</td><td><code>7c4a8d09ca3762af61e59520943dc26494f8941b</code></td></tr><tr><td>SHA-256</td><td><code>8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92</code></td></tr><tr><td>SHA3-256</td><td><code>c888c9ce9e098d5864d3ded6ebcc140a12142263bace3a23a36f9905f12bd64a</code></td></tr></tbody></table><h3><span id="hmac-xi-lie">HMAC 系列</span></h3><p>HMAC 这种算法就是在 MD5、SHA 两种加密的基础上引入了秘钥，其密文也和 MD5、SHA 类似，密文的长度和使用的 MD5、SHA 算法对应密文的长度是一样的。特征如下：</p><ul><li>HMAC-MD5：字母（a-f）和数字（0-9）混合，位数一般为 32 位；</li><li>HMAC-SHA-1：字母（a-f）和数字（0-9）混合，固定位数 40 位；</li><li>HMAC-SHA-224 / HMAC-SHA3-224：字母（a-f）和数字（0-9）混合，固定位数 56 位；</li><li>HMAC-SHA-256 / HMAC-SHA3-256：字母（a-f）和数字（0-9）混合，固定位数 64 位；</li><li>HMAC-SHA-384 / HMAC-SHA3-384：字母（a-f）和数字（0-9）混合，固定位数 96 位；</li><li>HMAC-SHA-512 / HMAC-SHA3-512：字母（a-f）和数字（0-9）混合，固定位数 128 位。</li></ul><p>HMAC 和 SHA、MD5 的密文都很像，当无法确定是否为 HMAC 时，可以通过其名称搜索到加密方法，如果传入了密钥 key，说明就是 HMAC，当然你也可以直接当做是 SHA 或 MD5 来解，解密失败时就得考虑是否有密钥，是否为 HMAC 了，在 JS 中，通常一个 HMAC 加密方法是这样写的：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HmacSHA1Encrypt</span>(<span class="hljs-params">word, key</span>) </span>&#123;    <span class="hljs-keyword">return</span> CryptoJS.HmacSHA1(word, key).toString();&#125;</code></pre><p>示例（密钥 123456abcde）：</p><table><thead><tr><th>编码类型</th><th>示例</th></tr></thead><tbody><tr><td>明文</td><td>123456</td></tr><tr><td>HMAC-MD5</td><td><code>432bb95bb00005ddce4a1c757488ed95</code></td></tr><tr><td>HMAC-SHA-1</td><td><code>37a04076b7736c44460d330ee0d00014428b175e</code></td></tr><tr><td>HMAC-SHA-256</td><td><code>50cb1345366df11140fb91b43caaf69627e3f5529705ddf6b0d0cae67986e585</code></td></tr><tr><td>HMAC-SHA3-256</td><td><code>b808ed9f66436e89fba527a01d1d6044318fea8599d9f39bfb6bec4843964bf3</code></td></tr></tbody></table><h3><span id="rsa">RSA</span></h3><p>RSA 加密算法是一种非对称加密算法，通过公钥加密结果，必须私钥解密。 同样私钥加密结果，公钥可以解密，应用非常广泛，在网站中通常使用 JSEncrypt 库来实现，其最大的特征就是有一个设置公钥的过程，我们可以通过以下方法来快速初步判断是否为 RSA 算法：</p><ul><li><p>搜索关键词 <code>new JSEncrypt()</code>，<code>JSEncrypt</code> 等，一般会使用 JSEncrypt 库，会有 new 一个实例对象的操作；</p></li><li><p>搜索关键词 <code>setPublicKey</code>、<code>setKey</code>、<code>setPrivateKey</code>、<code>getPublicKey</code> 等，一般实现的代码里都含有设置密钥的过程；</p></li><li><p>RSA 的私钥、公钥、明文、密文长度也有一定对应关系，也可以从这方面初步判断：</p><table><thead><tr><th style="text-align:left">私钥长度（Base64）</th><th style="text-align:left">公钥长度（Base64）</th><th style="text-align:left">明文长度</th><th style="text-align:left">密文长度</th></tr></thead><tbody><tr><td style="text-align:left">428</td><td style="text-align:left">128</td><td style="text-align:left">1~53</td><td style="text-align:left">88</td></tr><tr><td style="text-align:left">812</td><td style="text-align:left">216</td><td style="text-align:left">1~117</td><td style="text-align:left">172</td></tr><tr><td style="text-align:left">1588</td><td style="text-align:left">392</td><td style="text-align:left">1~245</td><td style="text-align:left">344</td></tr></tbody></table></li></ul><h3><span id="aes-des-3des-rc4-rabbit-deng">AES、DES、3DES、RC4、Rabbit 等</span></h3><p>AES、DES、3DES、RC4、Rabbit 等加密算法的密文通常没有固定的长度，他们通常使用 crypto-js 来实现，比如 AES 加解密示例如下：</p><pre><code class="hljs javascript">CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;crypto-js&quot;</span>)<span class="hljs-keyword">var</span> key = CryptoJS.enc.Utf8.parse(<span class="hljs-string">&quot;0123456789abcdef&quot;</span>);<span class="hljs-keyword">var</span> iv = CryptoJS.enc.Utf8.parse(<span class="hljs-string">&quot;0123456789abcdef&quot;</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AESEncrypt</span>(<span class="hljs-params">word</span>) </span>&#123;    <span class="hljs-keyword">var</span> srcs = CryptoJS.enc.Utf8.parse(word);    <span class="hljs-keyword">var</span> encrypted = CryptoJS.AES.encrypt(srcs, key, &#123;        <span class="hljs-attr">iv</span>: iv,        <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,        <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7    &#125;);    <span class="hljs-keyword">return</span> encrypted.toString();&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AESDecrypt</span>(<span class="hljs-params">word</span>) </span>&#123;    <span class="hljs-keyword">var</span> srcs = word;    <span class="hljs-keyword">var</span> decrypt = CryptoJS.AES.decrypt(srcs, key, &#123;        <span class="hljs-attr">iv</span>: iv,        <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,        <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7    &#125;);    <span class="hljs-keyword">return</span> decrypt.toString(CryptoJS.enc.Utf8);&#125;<span class="hljs-built_in">console</span>.log(AESEncrypt(<span class="hljs-string">&quot;ITBOB&quot;</span>))<span class="hljs-built_in">console</span>.log(AESDecrypt(<span class="hljs-string">&quot;r78lMXzImDRcDx9ADakCmg==&quot;</span>))</code></pre><p>在 crypto-js 中，也有一些特定的关键字，我们可以通过搜索这些关键字来快速定位到 crypto-js：</p><ul><li><p><code>CryptoJS</code>、<code>crypto-js</code>、<code>iv</code>、<code>mode</code>、<code>padding</code>、<code>createEncryptor</code>、<code>createDecryptor</code></p></li><li><p><code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=</code>、<code>0xffffffff</code>、<code>0xffff</code></p></li></ul><p>定位到 CryptoJS 后，观察加密方法，比如 AES 就是 <code>CryptoJS.AES.encrypt</code>，DES 就是 <code>CryptoJS.DES.encrypt</code>，3DES 就是 <code>CryptoJS.TripleDES.encrypt</code>，注意他的 iv、mode、padding，拿下来就可以本地复现了。</p><h3><span id="sm-xi-lie">SM 系列</span></h3><p>SM 代表商密，即商业密码，是我国发布的一系列国产加密算法，SM 系列包括：SM1、SM2、SM3 、SM4、SM7、SM9，其中 SM1 和 SM7 的算法不公开，SM 系列算法在我国一些 gov 网站上有应用，有关国产加密算法前期文章有介绍：<a href="https://www.itbob.cn/article/041/">《认识 SM1/SM2/SM3/SM4/SM7/SM9/ZUC 国密算法》</a>，本文不再赘述。</p><p>在 SM 的 JavaScript 代码中一般会存在以下关键字，可以通过搜索关键字定位：</p><ul><li><code>SM2</code>、<code>SM3</code>、<code>SM4</code></li><li><code>FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF</code></li><li><code>FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC</code></li><li><code>28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93</code></li><li><code>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789</code></li><li><code>getPublicKeyFromPrivateKey</code>、<code>doEncrypt</code>、<code>doDecrypt</code>、<code>doSignature</code></li></ul><h2><span id="hun-yao-xi-lie">混淆系列</span></h2><h3><span id="obfuscator">Obfuscator</span></h3><p>Obfuscator 就是混淆的意思，简称 OB 混淆，实战可参考以前的文章：<a href="https://itrhx.blog.csdn.net/article/details/121719631">【JS 逆向百例】W店UA，OB反混淆，抓包替换CORS跨域错误分析</a>，OB 混淆具有以下特征：</p><ul><li>一般由一个大数组或者含有大数组的函数、一个自执行函数、解密函数和加密后的函数四部分组成；</li><li>函数名和变量名通常以 <code>_0x</code> 或者 <code>0x</code> 开头，后接 1~6 位数字或字母组合；</li><li>自执行函数，进行移位操作，有明显的 push、shift 关键字；</li></ul><p>一段正常的代码如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hi</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello World!&quot;</span>);&#125;hi();</code></pre><p>经过 OB 混淆后的结果：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x3f26</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> _0x2dad75 = [<span class="hljs-string">&#x27;5881925kTCKCP&#x27;</span>, <span class="hljs-string">&#x27;Hello\x20World!&#x27;</span>, <span class="hljs-string">&#x27;600mDvfGa&#x27;</span>, <span class="hljs-string">&#x27;699564jYNxbu&#x27;</span>, <span class="hljs-string">&#x27;1083271cEvuvT&#x27;</span>, <span class="hljs-string">&#x27;log&#x27;</span>, <span class="hljs-string">&#x27;18sKjcFY&#x27;</span>, <span class="hljs-string">&#x27;214857eMgFSU&#x27;</span>, <span class="hljs-string">&#x27;77856FUKcuE&#x27;</span>, <span class="hljs-string">&#x27;736425OzpdFI&#x27;</span>, <span class="hljs-string">&#x27;737172JqcGMg&#x27;</span>];    _0x3f26 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> _0x2dad75;    &#125;;    <span class="hljs-keyword">return</span> _0x3f26();&#125;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_0x307c88, _0x4f8223</span>) </span>&#123;    <span class="hljs-keyword">var</span> _0x32807d = _0x1fe9, _0x330c58 = _0x307c88();    <span class="hljs-keyword">while</span> (!![]) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">var</span> _0x5d6354 = <span class="hljs-built_in">parseInt</span>(_0x32807d(<span class="hljs-number">0x6f</span>)) / <span class="hljs-number">0x1</span> + <span class="hljs-built_in">parseInt</span>(_0x32807d(<span class="hljs-number">0x6e</span>)) / <span class="hljs-number">0x2</span> + <span class="hljs-built_in">parseInt</span>(_0x32807d(<span class="hljs-number">0x70</span>)) / <span class="hljs-number">0x3</span> + -<span class="hljs-built_in">parseInt</span>(_0x32807d(<span class="hljs-number">0x69</span>)) / <span class="hljs-number">0x4</span> + <span class="hljs-built_in">parseInt</span>(_0x32807d(<span class="hljs-number">0x71</span>)) / <span class="hljs-number">0x5</span> + <span class="hljs-built_in">parseInt</span>(_0x32807d(<span class="hljs-number">0x6c</span>)) / <span class="hljs-number">0x6</span> * (<span class="hljs-built_in">parseInt</span>(_0x32807d(<span class="hljs-number">0x6a</span>)) / <span class="hljs-number">0x7</span>) + -<span class="hljs-built_in">parseInt</span>(_0x32807d(<span class="hljs-number">0x73</span>)) / <span class="hljs-number">0x8</span> * (<span class="hljs-built_in">parseInt</span>(_0x32807d(<span class="hljs-number">0x6d</span>)) / <span class="hljs-number">0x9</span>);            <span class="hljs-keyword">if</span> (_0x5d6354 === _0x4f8223) <span class="hljs-keyword">break</span>; <span class="hljs-keyword">else</span> _0x330c58[<span class="hljs-string">&#x27;push&#x27;</span>](_0x330c58[<span class="hljs-string">&#x27;shift&#x27;</span>]());        &#125; <span class="hljs-keyword">catch</span> (_0x3f18e4) &#123;            _0x330c58[<span class="hljs-string">&#x27;push&#x27;</span>](_0x330c58[<span class="hljs-string">&#x27;shift&#x27;</span>]());        &#125;    &#125;&#125;(_0x3f26, <span class="hljs-number">0xaa023</span>));<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_0x1fe9</span>(<span class="hljs-params">_0xa907e7, _0x410a46</span>) </span>&#123;    <span class="hljs-keyword">var</span> _0x3f261f = _0x3f26();    <span class="hljs-keyword">return</span> _0x1fe9 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_0x1fe950, _0x5a08da</span>) </span>&#123;        _0x1fe950 = _0x1fe950 - <span class="hljs-number">0x69</span>;        <span class="hljs-keyword">var</span> _0x82a06 = _0x3f261f[_0x1fe950];        <span class="hljs-keyword">return</span> _0x82a06;    &#125;, _0x1fe9(_0xa907e7, _0x410a46);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hi</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> _0x12a222 = _0x1fe9;    <span class="hljs-built_in">console</span>[_0x12a222(<span class="hljs-number">0x6b</span>)](_0x12a222(<span class="hljs-number">0x72</span>));&#125;hi();</code></pre><h3><span id="jjencode">JJEncode</span></h3><p>JJEncode、AAEncode、JSFuck 都是同一个作者，实战可参考以前的文章：<a href="https://itrhx.blog.csdn.net/article/details/121920783">【JS 逆向百例】网洛者反爬练习平台第二题：JJEncode 加密</a>，JJEncode 具有以下特征：</p><ul><li>大量 <code>$</code>、<code>_</code> 符号，大量重复的自定义变量；</li><li>仅由 18 个符号组成：<code>[]()!+,\&quot;$.:;_&#123;&#125;~=</code></li></ul><p>正常的一段 JS 代码：</p><pre><code class="hljs javascript">alert(<span class="hljs-string">&quot;Hello, JavaScript&quot;</span> )</code></pre><p>经过 JJEncode 混淆（自定义变量名为 $）之后的代码：</p><pre><code class="hljs javascript">$=~[];$=&#123;<span class="hljs-attr">___</span>:++$,<span class="hljs-attr">$$$$</span>:(![]+<span class="hljs-string">&quot;&quot;</span>)[$],<span class="hljs-attr">__$</span>:++$,<span class="hljs-attr">$_$_</span>:(![]+<span class="hljs-string">&quot;&quot;</span>)[$],<span class="hljs-attr">_$_</span>:++$,<span class="hljs-attr">$_$$</span>:(&#123;&#125;+<span class="hljs-string">&quot;&quot;</span>)[$],<span class="hljs-attr">$$_$</span>:($[$]+<span class="hljs-string">&quot;&quot;</span>)[$],<span class="hljs-attr">_$$</span>:++$,<span class="hljs-attr">$$$_</span>:(!<span class="hljs-string">&quot;&quot;</span>+<span class="hljs-string">&quot;&quot;</span>)[$],<span class="hljs-attr">$__</span>:++$,<span class="hljs-attr">$_$</span>:++$,<span class="hljs-attr">$$__</span>:(&#123;&#125;+<span class="hljs-string">&quot;&quot;</span>)[$],<span class="hljs-attr">$$_</span>:++$,<span class="hljs-attr">$$$</span>:++$,<span class="hljs-attr">$___</span>:++$,<span class="hljs-attr">$__$</span>:++$&#125;;$.$_=($.$_=$+<span class="hljs-string">&quot;&quot;</span>)[$.$_$]+($._$=$.$_[$.__$])+($.$$=($.$+<span class="hljs-string">&quot;&quot;</span>)[$.__$])+((!$)+<span class="hljs-string">&quot;&quot;</span>)[$._$$]+($.__=$.$_[$.$$_])+($.$=(!<span class="hljs-string">&quot;&quot;</span>+<span class="hljs-string">&quot;&quot;</span>)[$.__$])+($._=(!<span class="hljs-string">&quot;&quot;</span>+<span class="hljs-string">&quot;&quot;</span>)[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$=$.$+(!<span class="hljs-string">&quot;&quot;</span>+<span class="hljs-string">&quot;&quot;</span>)[$._$$]+$.__+$._+$.$+$.$$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$$+<span class="hljs-string">&quot;\&quot;&quot;</span>+$.$_$_+(![]+<span class="hljs-string">&quot;&quot;</span>)[$._$_]+$.$$$_+<span class="hljs-string">&quot;\\&quot;</span>+$.__$+$.$$_+$._$_+$.__+<span class="hljs-string">&quot;(\\\&quot;\\&quot;</span>+$.__$+$.__$+$.___+$.$$$_+(![]+<span class="hljs-string">&quot;&quot;</span>)[$._$_]+(![]+<span class="hljs-string">&quot;&quot;</span>)[$._$_]+$._$+<span class="hljs-string">&quot;,\\&quot;</span>+$.$__+$.___+<span class="hljs-string">&quot;\\&quot;</span>+$.__$+$.__$+$._$_+$.$_$_+<span class="hljs-string">&quot;\\&quot;</span>+$.__$+$.$$_+$.$$_+$.$_$_+<span class="hljs-string">&quot;\\&quot;</span>+$.__$+$._$_+$._$$+$.$$__+<span class="hljs-string">&quot;\\&quot;</span>+$.__$+$.$$_+$._$_+<span class="hljs-string">&quot;\\&quot;</span>+$.__$+$.$_$+$.__$+<span class="hljs-string">&quot;\\&quot;</span>+$.__$+$.$$_+$.___+$.__+<span class="hljs-string">&quot;\\\&quot;\\&quot;</span>+$.$__+$.___+<span class="hljs-string">&quot;)&quot;</span>+<span class="hljs-string">&quot;\&quot;&quot;</span>)())();</code></pre><h3><span id="aaencode">AAEncode</span></h3><p>JJEncode、AAEncode、JSFuck 都是同一个作者，实战可参考以前的文章：<a href="https://itrhx.blog.csdn.net/article/details/121920864">【JS 逆向百例】网洛者反爬练习平台第三题：AAEncode 加密</a>，AAEncode 具有以下特征：</p><ul><li>仅由日式表情符号组成</li></ul><p>正常的一段 JS 代码：</p><pre><code class="hljs javascript">alert(<span class="hljs-string">&quot;Hello, JavaScript&quot;</span>)</code></pre><p>经过 AAEncode 混淆之后的代码：</p><pre><code class="hljs javascript">ﾟωﾟﾉ= <span class="hljs-regexp">/｀ｍ´）ﾉ ~┻━┻   /</span><span class="hljs-regexp">/*´∇｀*/</span> [<span class="hljs-string">&#x27;_&#x27;</span>]; o=(ﾟｰﾟ)  =_=<span class="hljs-number">3</span>; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)=&#123;ﾟΘﾟ: <span class="hljs-string">&#x27;_&#x27;</span> ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ <span class="hljs-string">&#x27;_&#x27;</span>)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>)[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>) [c^_^o];(ﾟДﾟ) [<span class="hljs-string">&#x27;c&#x27;</span>] = ((ﾟДﾟ)+<span class="hljs-string">&#x27;_&#x27;</span>) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [<span class="hljs-string">&#x27;o&#x27;</span>] = ((ﾟДﾟ)+<span class="hljs-string">&#x27;_&#x27;</span>) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [<span class="hljs-string">&#x27;c&#x27;</span>]+(ﾟДﾟ) [<span class="hljs-string">&#x27;o&#x27;</span>]+(ﾟωﾟﾉ +<span class="hljs-string">&#x27;_&#x27;</span>)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>) [ﾟｰﾟ] + ((ﾟДﾟ) +<span class="hljs-string">&#x27;_&#x27;</span>) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>) [ﾟΘﾟ]+((ﾟｰﾟ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [<span class="hljs-string">&#x27;c&#x27;</span>]+((ﾟДﾟ)+<span class="hljs-string">&#x27;_&#x27;</span>) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [<span class="hljs-string">&#x27;o&#x27;</span>]+((ﾟｰﾟ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>) [ﾟΘﾟ];(ﾟДﾟ) [<span class="hljs-string">&#x27;_&#x27;</span>] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+<span class="hljs-string">&#x27;_&#x27;</span>) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==<span class="hljs-number">3</span>) +<span class="hljs-string">&#x27;_&#x27;</span>) [ﾟΘﾟ]+ (ﾟωﾟﾉ +<span class="hljs-string">&#x27;_&#x27;</span>) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=<span class="hljs-string">&#x27;\\&#x27;</span>; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +<span class="hljs-string">&#x27;_&#x27;</span>)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=<span class="hljs-string">&#x27;\&quot;&#x27;</span>;(ﾟДﾟ) [<span class="hljs-string">&#x27;_&#x27;</span>] ( (ﾟДﾟ) [<span class="hljs-string">&#x27;_&#x27;</span>] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (<span class="hljs-string">&#x27;_&#x27;</span>);</code></pre><h3><span id="jsfuck">JSFuck</span></h3><p>JJEncode、AAEncode、JSFuck 都是同一个作者，实战可参考以前的文章：<a href="https://itrhx.blog.csdn.net/article/details/122057377">【JS 逆向百例】网洛者反爬练习平台第四题：JSFuck 加密</a>，JSFuck 具有以下特征：</p><ul><li>仅由 6 个符号组成：<code>[]()!+</code></li></ul><p>正常的一段 JS 代码：</p><pre><code class="hljs javascript">alert(<span class="hljs-number">1</span>)</code></pre><p>经过 JSFuck 混淆之后的代码类似于：</p><pre><code class="hljs javascript">[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(+(!+[]+!+[]+!+[]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]])+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]])()((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[+!+[]+[!+[]+!+[]+!+[]]]+[+!+[]]+([+[]]+![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[!+[]+!+[]+[+[]]])</code></pre><h3><span id="jother">Jother</span></h3><p>Jother 混淆和 JSFuck 有点儿类似，唯一的区别就是密文比 JSFuck 多了 <code>&#123;&#125;</code>，其解密方式和 JSFuck 是一样的，Jother 混淆现在不太常见了，也很难找到在线混淆之类的工具了，原作者有个在线页面也关闭了，不过仍然可以了解一下，Jother 混淆具有以下特征：</p><ul><li>仅由 8 个符号组成：<code>[]()!+&#123;&#125;</code></li></ul><p>正常的一段代码：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">anonymous</span>(<span class="hljs-params"></span></span><span class="hljs-params"><span class="hljs-function"></span>) </span>&#123;<span class="hljs-keyword">return</span> location&#125;</code></pre><p>经过 Jother 混淆之后的代码类似于：</p><pre><code class="hljs javascript">[][(![]+[])[!![]+!![]+!![]]+(&#123;&#125;+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]]+(&#123;&#125;+[])[+!![]]+(&#123;&#125;[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+(&#123;&#125;[[]]+[])[+[]]+(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+(&#123;&#125;+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(&#123;&#125;[[]]+[])[+[]]+(!![]+[])[+!![]]+(&#123;&#125;[[]]+[])[+!![]]+(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+(&#123;&#125;+[])[+!![]]+(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+(&#123;&#125;[[]]+[])[!![]+!![]+!![]+!![]+!![]]+(&#123;&#125;+[])[+!![]]+(&#123;&#125;[[]]+[])[+!![]])()</code></pre><h3><span id="brainfuck">Brainfuck</span></h3><p>Brainfuck 实际上是一种极小化的计算机语言，又称为 BF 语言，该语言以其极简主义着称，仅包含八个简单的命令、一个数据指针和一个指令指针，这种语言在爬虫领域也可以是一种反爬手段，可以视为一种混淆方式，虽然不常见🤔，这里给一个在线体验的网址：<a href="https://copy.sh/brainfuck/text.html">https://copy.sh/brainfuck/text.html</a> ，感兴趣的同志可以深入研究一下，Brainfuck 具有以下特征：</p><ul><li>仅由 <code>&lt;&gt;+-.[]</code> 组成；</li><li>大量的 <code>+-</code> 符号。</li></ul><p>正常的一段代码：</p><pre><code class="hljs javascript">alert(<span class="hljs-string">&quot;Hello, Brainfuck&quot;</span>)</code></pre><p>经过 Brainfuck 混淆之后的代码类似于：</p><pre><code class="hljs javascript">--[-----&gt;+&lt;]&gt;-----.+++++++++++.-------.+++++++++++++.++.+[---&gt;+&lt;]&gt;+.------.++[-&gt;++&lt;]&gt;.-[-&gt;+++++&lt;]&gt;++.+++++++..+++.[-&gt;+++++&lt;]&gt;+.------------.+[-&gt;++&lt;]&gt;.---[-----&gt;+&lt;]&gt;-.+++[-&gt;+++&lt;]&gt;++.++++++++.+++++.--------.-[---&gt;+&lt;]&gt;--.+[-&gt;+++&lt;]&gt;+.++++++++.+[++&gt;---&lt;]&gt;.+++++++.</code></pre><h3><span id="ook">Ook!</span></h3><p>Ook! 和 Brainfuck 的原理都是类似的，只不过符号有差异，同样的，这种语言在爬虫领域也可以是一种反爬手段，可以视为一种混淆方式，虽然不常见🤔，在线体验的网址：<a href="https://www.splitbrain.org/services/ook">https://www.splitbrain.org/services/ook</a> ，Ook! 具有以下特征：</p><ul><li>完整 Ook!：仅由 3 种符号组成 <code>Ook.</code>、<code>Ook?</code>、<code>Ook!</code></li><li>Short Ook!：仅由 3 种符号组成 <code>.!?</code></li></ul><p>正常的一段代码：</p><pre><code class="hljs javascript">alert(<span class="hljs-string">&quot;Hello, Ook!&quot;</span>)</code></pre><p>经过 Ook! 混淆之后的代码类似于：</p><pre><code class="hljs javascript">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook.</code></pre><h3><span id="trivial-brainfuck-substitution">Trivial brainfuck substitution</span></h3><p>Trivial brainfuck substitution 不是一种单一的编程语言，而是一大类编程语言，成员超过 20 个，前面提到的 Brainfuck、Ook! 都是其中的一员，在爬虫领域中，说实话这种稀奇古怪的混淆其实并不常见，但是在一些 CTF 中有可能会出现，作为爬虫工程师也可以了解了解😎，具体可以参考：<a href="https://esolangs.org/wiki/Trivial_brainfuck_substitution">https://esolangs.org/wiki/Trivial_brainfuck_substitution</a></p><h2><span id="qi-ta">其他</span></h2><h3><span id="kai-sa-mi-ma">恺撒密码</span></h3><p>恺撒密码（Caesar cipher）又称为恺撒加密、恺撒变换、变换加密，它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是 3 的时候，所有的字母 A 将被替换成 D，B 变成 E，以此类推。这个加密方法是以罗马共和时期恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。</p><p>根据偏移量的不同，还存在若干特定的恺撒密码名称：偏移量为10：Avocat（A→K）；偏移量为13：ROT13；偏移量为-5：Cassis (K 6)；偏移量为-6：Cassette (K 7)</p><p>示例（偏移量 3）：</p><ul><li><p>明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ</p></li><li><p>密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC</p></li></ul><h3><span id="zha-lan-mi-ma">栅栏密码</span></h3><p>栅栏密码就是把要加密的明文分成 N 个一组，然后把每组的第 1 个字连起来，形成一段无规律的话。栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多，一般不超过 30 个。</p><p>示例：明文为 THE LONGEST DAY MUST HAVE AN END。加密时，把将要传递的信息中的字母交替排成上下两行：</p><p>T E O G S D Y U T A E N N</p><p>H L N E T A M S H V A E D</p><p>将下面一行字母排在上面一行的后边组合成密文：</p><p>TEOGSDYUTAENN HLNETAMSHVAED</p><p>栅栏密码还有一种变种，称为栅栏密码 W 型，它会先把明文类似 W 形状进行排列，然后再按栏目顺序 1-N，取每一栏的所有字符值，组成加密后密文，比如字符串 123456789，采用栏目数为 3 时，明文将采用如下排列：<br>1—5—9<br>-2-4-6-8-<br>–3—7–<br>取每一栏所有字符串，组成加密后密文：159246837</p><h3><span id="zhu-quan-mi-ma">猪圈密码</span></h3><p>猪圈密码也称为朱高密码、共济会暗号、共济会密码或共济会员密码，是一种以格子为基础的简单替代式密码。只能对字母加解密并且符号无法复制，粘贴后会直接显示明文，即使使用符号，也不会影响密码分析，亦可用在其它替代式的方法。曾经是美国内战时盟军使用的密码，目前仅在密码教学、各种竞赛中使用。</p><p><img src="https://cdn.itbob.cn/img/article/045/01.gif" alt="01.gif"></p><h3><span id="mo-si-mi-ma">摩斯密码</span></h3><p>摩斯密码（Morse code），又称为摩尔斯电码、摩斯电码，是一种时通时断的信号代码，这种信号代码通过不同的排列顺序来表达不同的英文字母、数字和标点符号等。</p><p>26个字母的摩斯密码表</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">摩斯码</th><th style="text-align:left">字符</th><th style="text-align:left">摩斯码</th><th>字符</th><th>摩斯码</th><th>字符</th><th>摩斯码</th></tr></thead><tbody><tr><td style="text-align:left">A</td><td style="text-align:left"><code>．━</code></td><td style="text-align:left">B</td><td style="text-align:left"><code>━ ．．．</code></td><td>C</td><td><code>━ ．━ ．</code></td><td>D</td><td><code>━ ．．</code></td></tr><tr><td style="text-align:left">E</td><td style="text-align:left"><code>．</code></td><td style="text-align:left">F</td><td style="text-align:left"><code>．．━ ．</code></td><td>G</td><td><code>━ ━ ．</code></td><td>H</td><td><code>．．．．</code></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left"><code>．．</code></td><td style="text-align:left">J</td><td style="text-align:left"><code>．━ ━ ━</code></td><td>K</td><td><code>━ ．━</code></td><td>L</td><td><code>．━ ．．</code></td></tr><tr><td style="text-align:left">M</td><td style="text-align:left"><code>━ ━</code></td><td style="text-align:left">N</td><td style="text-align:left"><code>━ ．</code></td><td>O</td><td><code>━ ━ ━</code></td><td>P</td><td><code>．━ ━ ．</code></td></tr><tr><td style="text-align:left">Q</td><td style="text-align:left"><code>━ ━ ．━</code></td><td style="text-align:left">R</td><td style="text-align:left"><code>．━ ．</code></td><td>S</td><td><code>．．．</code></td><td>T</td><td><code>━</code></td></tr><tr><td style="text-align:left">U</td><td style="text-align:left"><code>．．━</code></td><td style="text-align:left">V</td><td style="text-align:left"><code>．．．━</code></td><td>W</td><td><code>．━ ━</code></td><td>X</td><td><code>━ ．．━</code></td></tr><tr><td style="text-align:left">Y</td><td style="text-align:left"><code>━ ．━ ━</code></td><td style="text-align:left">Z</td><td style="text-align:left"><code>━ ━ ．．</code></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>10个数字的摩斯密码表</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">摩斯码</th><th style="text-align:left">字符</th><th style="text-align:left">摩斯码</th><th>字符</th><th>摩斯码</th><th>字符</th><th>摩斯码</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left"><code>━ ━ ━ ━ ━</code></td><td style="text-align:left">1</td><td style="text-align:left"><code>．━ ━ ━ ━</code></td><td>2</td><td><code>．．━ ━ ━</code></td><td>3</td><td><code>．．．━ ━</code></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><code>．．．．━</code></td><td style="text-align:left">5</td><td style="text-align:left"><code>．．．．．</code></td><td>6</td><td><code>━ ．．．．</code></td><td>7</td><td><code>━ ━ ．．．</code></td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><code>━ ━ ━ ．．</code></td><td style="text-align:left">9</td><td style="text-align:left"><code>━ ━ ━ ━ ．</code></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>标点符号的摩斯密码表</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">摩斯码</th><th style="text-align:left">字符</th><th style="text-align:left">摩斯码</th><th>字符</th><th>摩斯码</th><th>字符</th><th>摩斯码</th></tr></thead><tbody><tr><td style="text-align:left">.</td><td style="text-align:left"><code>．━ ．━ ．━</code></td><td style="text-align:left">:</td><td style="text-align:left"><code>━ ━ ━ ．．．</code></td><td>,</td><td><code>━ ━ ．．━ ━</code></td><td>;</td><td><code>━ ．━ ．━ ．</code></td></tr><tr><td style="text-align:left">?</td><td style="text-align:left"><code>．．━ ━ ．．</code></td><td style="text-align:left">=</td><td style="text-align:left"><code>━ ．．．━</code></td><td>’</td><td><code>．━ ━ ━ ━ ．</code></td><td>/</td><td><code>━ ．．━ ．</code></td></tr><tr><td style="text-align:left">!</td><td style="text-align:left"><code>━ ．━ ．━ ━</code></td><td style="text-align:left">━</td><td style="text-align:left"><code>━ ．．．．━</code></td><td>_</td><td><code>．．━ ━ ．━</code></td><td>&quot;</td><td><code>．━ ．．━ ．</code></td></tr><tr><td style="text-align:left">(</td><td style="text-align:left"><code>━ ．━ ━ ．</code></td><td style="text-align:left">)</td><td style="text-align:left"><code>━ ．━ ━ ．━</code></td><td>$</td><td><code>．．．━ ．．━</code></td><td>&amp;</td><td><code>． ．．．</code></td></tr><tr><td style="text-align:left">@</td><td style="text-align:left"><code>．━ ━ ．━ ．</code></td><td style="text-align:left"></td><td style="text-align:left"></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3><span id="pei-gen-mi-ma">培根密码</span></h3><p>培根密码，又名倍康尼密码（Bacon’s cipher）是由法兰西斯·培根发明的一种隐写术，它是一种本质上用二进制数设计的，没有用通常的0和1来表示，而是采用a和b，看到一串的a和b，并且五个一组，那么就是培根加密了。</p><p>第一种方式：</p><table><thead><tr><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th></tr></thead><tbody><tr><td>A</td><td>aaaaa</td><td>H</td><td>aabbb</td><td>O</td><td>abbba</td><td>V</td><td>babab</td></tr><tr><td>B</td><td>aaaab</td><td>I</td><td>abaaa</td><td>P</td><td>abbbb</td><td>W</td><td>babba</td></tr><tr><td>C</td><td>aaaba</td><td>J</td><td>abaab</td><td>Q</td><td>baaaa</td><td>X</td><td>babbb</td></tr><tr><td>D</td><td>aaabb</td><td>K</td><td>ababa</td><td>R</td><td>baaab</td><td>Y</td><td>bbaaa</td></tr><tr><td>E</td><td>aabaa</td><td>L</td><td>ababb</td><td>S</td><td>baaba</td><td>Z</td><td>bbaab</td></tr><tr><td>F</td><td>aabab</td><td>M</td><td>abbaa</td><td>T</td><td>baabb</td><td></td><td></td></tr><tr><td>G</td><td>aabba</td><td>N</td><td>abbab</td><td>U</td><td>babaa</td><td></td><td></td></tr></tbody></table><p>第二种方式：</p><table><thead><tr><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th></tr></thead><tbody><tr><td>a</td><td>AAAAA</td><td>h</td><td>AABBB</td><td>p</td><td>ABBBA</td><td>x</td><td>BABAB</td></tr><tr><td>b</td><td>AAAAB</td><td>i-j</td><td>ABAAA</td><td>q</td><td>ABBBB</td><td>y</td><td>BABBA</td></tr><tr><td>c</td><td>AAABA</td><td>k</td><td>ABAAB</td><td>r</td><td>BAAAA</td><td>z</td><td>BABBB</td></tr><tr><td>d</td><td>AAABB</td><td>l</td><td>ABABA</td><td>s</td><td>BAAAB</td><td></td><td></td></tr><tr><td>e</td><td>AABAA</td><td>m</td><td>ABABB</td><td>t</td><td>BAABA</td><td></td><td></td></tr><tr><td>f</td><td>AABAB</td><td>n</td><td>ABBAA</td><td>u-v</td><td>BAABB</td><td></td><td></td></tr><tr><td>g</td><td>AABBA</td><td>o</td><td>ABBAB</td><td>w</td><td>BABAA</td><td></td><td></td></tr></tbody></table><p>示例：</p><ul><li>明文：kuaidaili</li><li>密文：ABABABABAAAAAAAABAAAAAABBAAAAAABAAAABABBABAAA</li></ul><h3><span id="wei-ji-ni-ya-mi-ma">维吉尼亚密码</span></h3><p>维吉尼亚密码是在凯撒密码基础上产生的一种加密方法，它将凯撒密码的全部25种位移排序为一张表，与原字母序列共同组成26行及26列的字母表。另外，维吉尼亚密码必须有一个密钥，这个密钥由字母组成，最少一个，最多可与明文字母数量相等。维吉尼亚密码表如下：</p><p><img src="https://cdn.itbob.cn/img/article/045/02.png" alt="02.png"></p><p>示例：</p><ul><li>明文：I’ve got it.</li><li>密钥：ok</li><li>密文：W’fs qcd wd.</li></ul><p>首先，密钥长度需要与明文长度相同，如果少于明文长度，则重复拼接直到相同。示例的明文长度为8个字母（非字母均被忽略），密钥会被程序补全为 <code>okokokok</code>，然后根据维吉尼亚密码表进行加密：明文第一个字母是 <code>I</code>，密钥第一个字母是 <code>o</code>，在表格中找到 <code>I</code> 列与 <code>o</code> 行相交点，字母 <code>W</code> 就是密文第一个字母，同理，<code>v</code> 列与 <code>k</code> 行交点字母是 <code>F</code>，<code>e</code> 列与 <code>o</code> 行交点字母是 <code>S</code>，以此类推。注意：维吉尼亚密码只对字母进行加密，不区分大小写，若文本中出现非字母字符会原样保留，如果输入多行文本，每行是单独加密的。</p><h3><span id="yu-fo-lun-shan">与佛论禅</span></h3><p>字符串转换后，是一些佛语，在线体验：<a href="https://keyfc.net/bbs/tools/tudoucode.aspx">https://keyfc.net/bbs/tools/tudoucode.aspx</a></p><p>示例：</p><ul><li>明文：爬虫</li><li>密文：佛曰：俱曳栗羅。諳故大多罰顛冥有諳姪帝罰知俱薩心俱智伊</li></ul><h3><span id="dang-pu-mi-ma">当铺密码</span></h3><p>当铺密码在 CTF 比赛题目中出现过。该加密算法是根据当前汉字有多少笔画出头，对应的明文就是数字几。</p><p>示例：</p><ul><li>明文：王夫 井工 夫口 由中人 井中 夫夫 由中大</li><li>密文：67 84 70 123 82 77 125</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/encryption_algorithm.png&quot; alt=&quot;encryption_algorithm&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/s</summary>
      
    
    
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="算法" scheme="https://www.itbob.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="JS 逆向理论" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E7%90%86%E8%AE%BA/"/>
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>某空气质量监测平台无限 debugger 以及数据动态加密分析</title>
    <link href="https://www.itbob.cn/article/044/"/>
    <id>https://www.itbob.cn/article/044/</id>
    <published>2022-01-10T09:30:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/javascript_reverse.png" alt="javascript_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#xie-zai-qian-mian">写在前面</a></li><li><a href="#rao-guo-wu-xian-debugger">绕过无限 debugger</a><ul><li><a href="#fang-fa-yi">方法一</a></li><li><a href="#fang-fa-er">方法二</a></li><li><a href="#fang-fa-san">方法三</a></li></ul></li><li><a href="#zhua-bao-fen-xi">抓包分析</a></li><li><a href="#jia-mi-ru-kou">加密入口</a></li><li><a href="#dong-tai-js">动态 JS</a></li><li><a href="#ben-di-gai-xie">本地改写</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：某空气质量监测平台无限 debugger 以及请求数据、返回数据动态加密、解密</li><li>主页：<code>aHR0cHM6Ly93d3cuYXFpc3R1ZHkuY24v</code></li><li>接口：<code>aHR0cHM6Ly93d3cuYXFpc3R1ZHkuY24vYXBpbmV3L2FxaXN0dWR5YXBpLnBocA==</code></li></ul><h2><span id="xie-zai-qian-mian">写在前面</span></h2><p>这个站点更新频率很高，在我之前也已经有很多博主写了该站点的分析文章，近期有读者问请求数据的加密和返回数据的解密，发现其加解密 JS 变成了动态的，以前的那些文章提到的解决思路不太行了，但整体上来说也不是很难，只不过处理起来比较麻烦一点，还有一些小细节需要注意。</p><p>在网站的“关于系统”里可以看到，这个站貌似是个人开发者在维护，最早在2013年就有了，在友情赞助列表里，可以看到大多数都是一些环境、测绘、公共卫生相关的大学专业、研究院人员，可以猜测到这些数据对于他们的研究是非常有帮助的，再加上反爬更新频繁，可以看出站长饱受爬虫之苦，咱们也不想给站长添加负担，毕竟这种站点咱们应该支持，让他长久维护下去，<strong>所以本期只分析逻辑和少部分代码，就不放完整代码了，如果有相关专业人士确实需要抓取数据做研究的，可以通过邮件联系我。</strong></p><h2><span id="rao-guo-wu-xian-debugger">绕过无限 debugger</span></h2><p>右键 F12，会提示右键被禁用，不要紧，使用快捷键 <code>Ctrl+Shift+i</code> 或者浏览器右上角，更多工具，开发者工具，照样能打开。</p><p><img src="https://cdn.itbob.cn/img/article/044/01.png" alt="01.png"></p><h3><span id="fang-fa-yi">方法一</span></h3><p>打开控制台后会进入第一个无限 debugger，往上跟一个栈，可以看到一个 try-catch 语句，你下断点会发现他会一直走 catch，调用 <code>setTimeout()</code> 方法，该方法用于在指定的毫秒数后调用函数或计算表达式，注意上面，是将 debugger 传递给了构造方法 constructor，所以这里我们有两种方法过掉 debugger，Hook 掉 constructor 或 setTimeout 都可以。</p><p><img src="https://cdn.itbob.cn/img/article/044/02.png" alt="02.png"></p><pre><code class="hljs javascript"><span class="hljs-comment">// 两种 Hook 任选一中</span><span class="hljs-comment">// Hook 构造方法</span><span class="hljs-built_in">Function</span>.prototype.constructor_ = <span class="hljs-built_in">Function</span>.prototype.constructor;<span class="hljs-built_in">Function</span>.prototype.constructor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-keyword">if</span>(a == <span class="hljs-string">&quot;debugger&quot;</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;&#125;;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Function</span>.prototype.constructor_(a);&#125;;<span class="hljs-comment">// Hook setTimeout</span><span class="hljs-keyword">var</span> setTimeout_ = <span class="hljs-built_in">setTimeout</span><span class="hljs-keyword">var</span> <span class="hljs-built_in">setTimeout</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">func, time</span>)</span>&#123;    <span class="hljs-keyword">if</span> (func == txsdefwsw)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;    &#125;    <span class="hljs-keyword">return</span> setTimeout_(func, time)&#125;</code></pre><p>然后就来到了第二个无限 debugger，同样跟栈，发现有个 setInterval 定时器和构造方法 constructor，类似的，我们 Hook 掉 constructor 或 setInterval 都可以。注意：定时器这里还检测了窗口高宽，即便是你过了 constructor 或 setInterval，如果不把开发者工具单独拿出来也是不行的，会不断输出“检测到非法调试”。</p><p><img src="https://cdn.itbob.cn/img/article/044/03.png" alt="03.png"></p><pre><code class="hljs javascript"><span class="hljs-comment">// Hook setInterval</span><span class="hljs-keyword">var</span> setInterval_ = <span class="hljs-built_in">setInterval</span><span class="hljs-built_in">setInterval</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">func, time</span>)</span>&#123;    <span class="hljs-keyword">if</span> (time == <span class="hljs-number">2000</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;    &#125;    <span class="hljs-keyword">return</span> setInterval_(func, time)&#125;</code></pre><p>我们观察到，其实这两个无限 debugger 都可以 Hook 构造方法来过掉，所以直接 Fiddler 注入该 Hook 构造方法的代码即可：</p><p><img src="https://cdn.itbob.cn/img/article/044/04.png" alt="04.png"></p><h3><span id="fang-fa-er">方法二</span></h3><p>在我们遇到第二个无限 debugger 的时候，还可以直接跟栈到一个 city_realtime.php 的页面，里面有两个 eval 语句，执行第一个 eval 里面的语句你就会发现正是前面我们在 VM 虚拟机里面看到的 debugger 代码，所以这里理论上可以直接替换掉这个页面，去掉 eval 语句，就不会有无限 debugger 了，但是先告诉你，现在不行了，因为里面有加载了某个 JS，这个 JS 在后面加密解密中会用到，但是这个 JS 是动态的，每10分钟就会改变，我们后面还要通过此页面来获取动态的 JS，所以是不能替换的！这里只是提一下这个思路！</p><p><img src="https://cdn.itbob.cn/img/article/044/05.png" alt="05.png"></p><p><img src="https://cdn.itbob.cn/img/article/044/06.png" alt="06.png"></p><h3><span id="fang-fa-san">方法三</span></h3><p>当然，这里还有一种最简单的方法，直接右键选择 Never pause here，永不在此处断下即可，同样还需要把开发者工具窗口单独拿出来，不然会一直输出“检测到非法调试”。</p><p><img src="https://cdn.itbob.cn/img/article/044/07.png" alt="07.png"></p><h2><span id="zhua-bao-fen-xi">抓包分析</span></h2><p>我们在实时监控页面，顺便点击查询一个城市，可以看到请求的 Form Data 和返回的数据都是加密的，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/044/08.png" alt="08.png"></p><h2><span id="jia-mi-ru-kou">加密入口</span></h2><p>由于是 XHR，所以我们直接跟栈，很容易找到加密的位置：</p><p><img src="https://cdn.itbob.cn/img/article/044/09.png" alt="09.png"></p><p><img src="https://cdn.itbob.cn/img/article/044/10.png" alt="10.png"></p><p>可以看到传递的 data 键值对：<code>&#123;hXM8NDFHN: p7crXYR&#125;</code>，键在这个 JS 里是写死的，值是通过一个方法 <code>pU14VhqrofroULds()</code> 得到的，这个方法需要传递两个参数，第一个是定值 GETDATA，第二个就是城市名称，我们再跟进看看这个方法是啥：</p><p><img src="https://cdn.itbob.cn/img/article/044/11.png" alt="11.png"></p><p>一些 appId、时间戳、城市等参数，做了一些 MD5、base64 的操作，返回的 param 就是我们要的值了。看起来不难，我们再找找返回的加密数据是如何解密的，我们注意到 ajax 请求有个 success 关键字，我们即便是不懂 JS 逻辑，也可以猜到应该是请求成功后的处理操作吧，如下图所示：传进来的 dzJMI 就是返回的加密的数据，经过 <code>db0HpCYIy97HkHS7RkhUn()</code> 方法后，就解密成功了：</p><p><img src="https://cdn.itbob.cn/img/article/044/12.png" alt="12.png"></p><p>跟进 <code>db0HpCYIy97HkHS7RkhUn()</code> 方法，可以看到是 AES+DES+BASE64 解密，传入的密钥 key 和偏移量 iv 都在头部有定义：</p><p><img src="https://cdn.itbob.cn/img/article/044/13.png" alt="13.png"></p><p><img src="https://cdn.itbob.cn/img/article/044/14.png" alt="14.png"></p><h2><span id="dong-tai-js">动态 JS</span></h2><p>经过以上分析后，我们加密解密的逻辑都搞定了，但是你多调试一下就会发现，这一个加密解密的 JS 是动态变化的，定义的密钥 key 和偏移量 iv 都是隔段时间就会改变的，如果你在这段代码里下断点，停留时间过长，突然发现断点失效无法断下了，那就是 JS 变了，当前代码已经失效了。</p><p>我们随便薅两个不同的 JS 下来（提示：JS 每隔10分钟会变化，后文有详细分析），利用 PyCharm 的文件对比功能（依次选择 View - Compare With）可以总结出以下几个变化的地方（变量名的变化不算）：</p><ol><li>开头的8个参数的值：两个 aes key 和 iv，两个 des key 和 iv；</li></ol><p><img src="https://cdn.itbob.cn/img/article/044/15.png" alt="15.png"></p><ol start="2"><li>生成加密的 param 时，appId 是变化的，最后的加密分为 AES、DES 和没有加密，三种情况（这里是最容易忽略的地方，这里没有注意到，请求可能会提示 appId 无效的情况）：</li></ol><p><img src="https://cdn.itbob.cn/img/article/044/16.png" alt="16.png"></p><ol start="3"><li>最后发送请求时，data 键值对，其中的键也是变化的：</li></ol><p><img src="https://cdn.itbob.cn/img/article/044/17.png" alt="17.png"></p><p>变化的地方我们找到了，那我们怎么获取这个 JS 呢？因为这个 JS 的在 VM 虚拟机里，所以我们还要找到它的源头，是从哪里来的，我们抓包可以看到一个比较特殊的 JS，类似于 encrypt_xxxxxx.js，看这取名就知道不简单，返回的是一段 eval 包裹的代码：</p><p><img src="https://cdn.itbob.cn/img/article/044/18.png" alt="18.png"></p><p>对于 eval 我们已经很熟悉了，直接去掉 eval，让他执行一下，就可以看到正是我们需要的那段 JS：</p><p><img src="https://cdn.itbob.cn/img/article/044/19.png" alt="19.png"></p><p>这里有个小细节，如果你使用控制台，会发现它一直在打印 img 标签，影响我们的输入，这里可以直接跟进去下断点暂时阻止他运行就行了，不需要做其他操作浪费时间：</p><p><img src="https://cdn.itbob.cn/img/article/044/20.png" alt="20.png"></p><p>你以为到这里就差不多搞定了？错了，同样的这个 encrypt_xxxxxx.js 也藏有玄机：</p><ol><li>encrypt_xxxxxx.js 的名称是动态的，后面的 v 值是秒级时间戳，隔600秒，也就是十分钟就会改变，这个 JS 可以在 city_realtime.php 页面找到，还记得我们前面说过的绕过无限 debugger 不能替换此页面吗？我们要通过此页面来获取动态的 JS，所以是不能替换的！</li></ol><p><img src="https://cdn.itbob.cn/img/article/044/21.png" alt="21.png"></p><p><img src="https://cdn.itbob.cn/img/article/044/22.png" alt="22.png"></p><ol start="2"><li>encrypt_xxxxxx.js 返回的 JS，并不是所有的执行一遍 eval 就能得到明文代码了，它是 eval 和 base64 相结合的，第一遍都是 eval，但是后面就说不定了，有可能直接出结果，有可能需要 base64，有可能 base64 两遍，有可能两遍 base64 之后还要再 eval，总之，除了第一遍是 eval 以外，后面是否需要 base64 和 eval，以及需要的次数和先后顺序，都是不确定的！举几个例子：</li></ol><p><img src="https://cdn.itbob.cn/img/article/044/23.png" alt="23.png"></p><p><img src="https://cdn.itbob.cn/img/article/044/24.png" alt="24.png"></p><p><img src="https://cdn.itbob.cn/img/article/044/25.png" alt="25.png"></p><p>这里可能有人会问，你怎么看出来那是 base64 呢？很简单，直接在网站页面的控制台里输入 <code>dswejwehxt</code>，点击去看这个函数，就是 base64：</p><p><img src="https://cdn.itbob.cn/img/article/044/26.png" alt="26.png"></p><p>那么针对 encrypt_xxxxxx.js 内容不确定的情况，我们可以写一个方法，获取到 encrypt_xxxxxx.js 后，需要执行 eval 就执行 eval，需要执行 base64 就执行 base64，直到没有 eval 和 base64 即可，可以分别用字符串 <code>eval(function</code> 和 <code>dswejwehxt(</code> 来判断是否需要 eval 和 base64（当然也有其他方式，比如 <code>()</code> 的个数等），示例代码如下所示：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_decrypted_js</span>(<span class="hljs-params">encrypted_js_url</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    :param encrypted_js_url: encrypt_xxxxxx.js 的地址</span><span class="hljs-string">    :return: 解密后的 JS</span><span class="hljs-string">    &quot;&quot;&quot;</span>    decrypted_js = requests.get(url=encrypted_js_url, headers=headers).text    flag = <span class="hljs-literal">True</span>    <span class="hljs-keyword">while</span> flag:        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;eval(function&quot;</span> <span class="hljs-keyword">in</span> decrypted_js:            <span class="hljs-comment"># 需要执行 eval</span>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;需要执行 eval！&quot;</span>)            replace_js = decrypted_js.replace(<span class="hljs-string">&quot;eval(function&quot;</span>, <span class="hljs-string">&quot;(function&quot;</span>)            decrypted_js = execjs.<span class="hljs-built_in">eval</span>(replace_js)        <span class="hljs-keyword">elif</span> <span class="hljs-string">&quot;dswejwehxt(&quot;</span> <span class="hljs-keyword">in</span> decrypted_js:            <span class="hljs-comment"># 需要 base64 解码</span>            base64_num = decrypted_js.count(<span class="hljs-string">&quot;dswejwehxt(&quot;</span>)            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;需要 %s 次 base64 解码！&quot;</span> % base64_num)            decrypted_js = re.findall(<span class="hljs-string">r&quot;\(&#x27;(.*?)&#x27;\)&quot;</span>, decrypted_js)[<span class="hljs-number">0</span>]            num = <span class="hljs-number">0</span>            <span class="hljs-keyword">while</span> base64_num &gt; num:                decrypted_js = base64.b64decode(decrypted_js).decode()                num += <span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-comment"># 得到明文</span>            flag = <span class="hljs-literal">False</span>    <span class="hljs-comment"># print(decrypted_js)</span>    <span class="hljs-keyword">return</span> decrypted_js</code></pre><h2><span id="ben-di-gai-xie">本地改写</span></h2><p>通过以上函数我们就拿到了动态的 JS 了，那么我们可以直接执行拿回来的 JS 吗？当然是不可以的，你可以自己本地执行一下，可以发现里面的 CryptoJS、Base64、hex_md5 都需要补齐才行，所以到这里我们就有两种做法：</p><ol><li>拿到解密后的动态 JS 后，动态 JS 和我们自己写的 Base64、hex_md5 等方法组成新的 JS 代码，执行新的 JS 代码拿到参数，这里还需要注意因为里面的其他方法名都是动态的，所以你还得想办法匹配到正确的方法名来调用才行，所以这种方法个人感觉还是稍微有点儿麻烦的；</li><li>我们本地自己写一个 JS，拿到解密后的动态 JS 后，把里面的 key、iv、appId、data 键名、param 是否需要 AES 或 DES 加密，这些信息都匹配出来，然后传给我们自己写的 JS，调用我们自己的方法拿到加密结果。</li></ol><p>虽然两种方法都很麻烦，但暂时也想不到更好的解决方法了，有比较好的想法的朋友可以留言说一说。</p><p>以第二种方法为例，我们本地的 JS 示例（main.js）：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> CryptoJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;crypto-js&quot;</span>);<span class="hljs-keyword">var</span> BASE64 = &#123;    <span class="hljs-attr">encrypt</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>&#123;        <span class="hljs-keyword">return</span> CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(text))    &#125;,    <span class="hljs-attr">decrypt</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>&#123;        <span class="hljs-keyword">return</span> CryptoJS.enc.Base64.parse(text).toString(CryptoJS.enc.Utf8)    &#125;&#125;;<span class="hljs-keyword">var</span> DES = &#123;    <span class="hljs-attr">encrypt</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text, key, iv</span>) </span>&#123;        <span class="hljs-keyword">var</span> secretkey = (CryptoJS.MD5(key).toString()).substr(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>);        <span class="hljs-keyword">var</span> secretiv = (CryptoJS.MD5(iv).toString()).substr(<span class="hljs-number">24</span>, <span class="hljs-number">8</span>);        secretkey = CryptoJS.enc.Utf8.parse(secretkey);        secretiv = CryptoJS.enc.Utf8.parse(secretiv);        <span class="hljs-keyword">var</span> result = CryptoJS.DES.encrypt(text, secretkey, &#123;            <span class="hljs-attr">iv</span>: secretiv,            <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,            <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7        &#125;);        <span class="hljs-keyword">return</span> result.toString();    &#125;,    <span class="hljs-attr">decrypt</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text, key, iv</span>) </span>&#123;        <span class="hljs-keyword">var</span> secretkey = (CryptoJS.MD5(key).toString()).substr(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>);        <span class="hljs-keyword">var</span> secretiv = (CryptoJS.MD5(iv).toString()).substr(<span class="hljs-number">24</span>, <span class="hljs-number">8</span>);        secretkey = CryptoJS.enc.Utf8.parse(secretkey);        secretiv = CryptoJS.enc.Utf8.parse(secretiv);        <span class="hljs-keyword">var</span> result = CryptoJS.DES.decrypt(text, secretkey, &#123;            <span class="hljs-attr">iv</span>: secretiv,            <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,            <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7        &#125;);        <span class="hljs-keyword">return</span> result.toString(CryptoJS.enc.Utf8);    &#125;&#125;;<span class="hljs-keyword">var</span> AES = &#123;    <span class="hljs-attr">encrypt</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text, key, iv</span>) </span>&#123;        <span class="hljs-keyword">var</span> secretkey = (CryptoJS.MD5(key).toString()).substr(<span class="hljs-number">16</span>, <span class="hljs-number">16</span>);        <span class="hljs-keyword">var</span> secretiv = (CryptoJS.MD5(iv).toString()).substr(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>);        secretkey = CryptoJS.enc.Utf8.parse(secretkey);        secretiv = CryptoJS.enc.Utf8.parse(secretiv);        <span class="hljs-keyword">var</span> result = CryptoJS.AES.encrypt(text, secretkey, &#123;            <span class="hljs-attr">iv</span>: secretiv,            <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,            <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7        &#125;);        <span class="hljs-keyword">return</span> result.toString();    &#125;,    <span class="hljs-attr">decrypt</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text, key, iv</span>) </span>&#123;        <span class="hljs-keyword">var</span> secretkey = (CryptoJS.MD5(key).toString()).substr(<span class="hljs-number">16</span>, <span class="hljs-number">16</span>);        <span class="hljs-keyword">var</span> secretiv = (CryptoJS.MD5(iv).toString()).substr(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>);        secretkey = CryptoJS.enc.Utf8.parse(secretkey);        secretiv = CryptoJS.enc.Utf8.parse(secretiv);        <span class="hljs-keyword">var</span> result = CryptoJS.AES.decrypt(text, secretkey, &#123;            <span class="hljs-attr">iv</span>: secretiv,            <span class="hljs-attr">mode</span>: CryptoJS.mode.CBC,            <span class="hljs-attr">padding</span>: CryptoJS.pad.Pkcs7        &#125;);        <span class="hljs-keyword">return</span> result.toString(CryptoJS.enc.Utf8);    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDecryptedData</span>(<span class="hljs-params">data, AES_KEY_1, AES_IV_1, DES_KEY_1, DES_IV_1</span>) </span>&#123;    data = AES.decrypt(data, AES_KEY_1, AES_IV_1);    data = DES.decrypt(data, DES_KEY_1, DES_IV_1);    data = BASE64.decrypt(data);    <span class="hljs-keyword">return</span> data;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ObjectSort</span>(<span class="hljs-params">obj</span>) </span>&#123;    <span class="hljs-keyword">var</span> newObject = &#123;&#125;;    <span class="hljs-built_in">Object</span>.keys(obj).sort().map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>&#123;        newObject[key] = obj[key];    &#125;);    <span class="hljs-keyword">return</span> newObject;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRequestParam</span>(<span class="hljs-params">method, obj, appId</span>) </span>&#123;    <span class="hljs-keyword">var</span> clienttype = <span class="hljs-string">&#x27;WEB&#x27;</span>;    <span class="hljs-keyword">var</span> timestamp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()    <span class="hljs-keyword">var</span> param = &#123;        <span class="hljs-attr">appId</span>: appId,        <span class="hljs-attr">method</span>: method,        <span class="hljs-attr">timestamp</span>: timestamp,        <span class="hljs-attr">clienttype</span>: clienttype,        <span class="hljs-attr">object</span>: obj,        <span class="hljs-attr">secret</span>: CryptoJS.MD5(appId + method + timestamp + clienttype + <span class="hljs-built_in">JSON</span>.stringify(ObjectSort(obj))).toString()    &#125;;    param = BASE64.encrypt(<span class="hljs-built_in">JSON</span>.stringify(param));    <span class="hljs-keyword">return</span> param;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRequestAESParam</span>(<span class="hljs-params">requestMethod, requestCity, appId, AES_KEY_2, AES_IV_2</span>)</span>&#123;    <span class="hljs-keyword">var</span> param = getRequestParam(requestMethod, requestCity, appId);    <span class="hljs-keyword">return</span> AES.encrypt(param, AES_KEY_2, AES_IV_2);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRequestDESParam</span>(<span class="hljs-params">requestMethod, requestCity, appId, DES_KEY_2, DES_IV_2</span>)</span>&#123;    <span class="hljs-keyword">var</span> param = getRequestParam(requestMethod, requestCity, appId);    <span class="hljs-keyword">return</span> DES.encrypt(param, DES_KEY_2, DES_IV_2);&#125;</code></pre><p>我们匹配 JS 里面的各项参数的 Python 代码示例（匹配8个 key、iv 值、appId 和 param 的加密方式）：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_key_iv_appid</span>(<span class="hljs-params">decrypted_js</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    :param decrypted_js: 解密后的 encrypt_xxxxxx.js</span><span class="hljs-string">    :return: 请求必须的一些参数</span><span class="hljs-string">    &quot;&quot;&quot;</span>    key_iv = re.findall(<span class="hljs-string">r&#x27;const.*?&quot;(.*?)&quot;;&#x27;</span>, decrypted_js)    app_id = re.findall(<span class="hljs-string">r&quot;var appId.*?&#x27;(.*?)&#x27;;&quot;</span>, decrypted_js)    request_data_name = re.findall(<span class="hljs-string">r&quot;aqistudyapi.php.*?data.*?&#123;(.*?):&quot;</span>, decrypted_js, re.DOTALL)    <span class="hljs-comment"># 判断 param 是 AES 加密还是 DES 加密还是没有加密</span>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;AES.encrypt(param&quot;</span> <span class="hljs-keyword">in</span> decrypted_js:        request_param_encrypt = <span class="hljs-string">&quot;AES&quot;</span>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&quot;DES.encrypt(param&quot;</span> <span class="hljs-keyword">in</span> decrypted_js:        request_param_encrypt = <span class="hljs-string">&quot;DES&quot;</span>    <span class="hljs-keyword">else</span>:        request_param_encrypt = <span class="hljs-string">&quot;NO&quot;</span>    key_iv_appid = &#123;        <span class="hljs-comment"># key 和 iv 的位置和原来 js 里的是一样的</span>        <span class="hljs-string">&quot;aes_key_1&quot;</span>: key_iv[<span class="hljs-number">0</span>],        <span class="hljs-string">&quot;aes_iv_1&quot;</span>: key_iv[<span class="hljs-number">1</span>],        <span class="hljs-string">&quot;aes_key_2&quot;</span>: key_iv[<span class="hljs-number">2</span>],        <span class="hljs-string">&quot;aes_iv_2&quot;</span>: key_iv[<span class="hljs-number">3</span>],        <span class="hljs-string">&quot;des_key_1&quot;</span>: key_iv[<span class="hljs-number">4</span>],        <span class="hljs-string">&quot;des_iv_1&quot;</span>: key_iv[<span class="hljs-number">5</span>],        <span class="hljs-string">&quot;des_key_2&quot;</span>: key_iv[<span class="hljs-number">6</span>],        <span class="hljs-string">&quot;des_iv_2&quot;</span>: key_iv[<span class="hljs-number">7</span>],        <span class="hljs-string">&quot;app_id&quot;</span>: app_id[<span class="hljs-number">0</span>],        <span class="hljs-comment"># 发送请求的 data 的键名</span>        <span class="hljs-string">&quot;request_data_name&quot;</span>: request_data_name[<span class="hljs-number">0</span>].strip(),        <span class="hljs-comment"># 发送请求的 data 值需要哪种加密</span>        <span class="hljs-string">&quot;request_param_encrypt&quot;</span>: request_param_encrypt    &#125;    <span class="hljs-comment"># print(key_iv_appid)</span>    <span class="hljs-keyword">return</span> key_iv_appid</code></pre><p>我们发送请求以及解密返回值的 Python 代码示例（以北京为例）：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_data</span>(<span class="hljs-params">key_iv_appid</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    :param key_iv_appid: get_key_iv_appid() 方法返回的值</span><span class="hljs-string">    &quot;&quot;&quot;</span>    request_method = <span class="hljs-string">&quot;GETDATA&quot;</span>    request_city = &#123;<span class="hljs-string">&quot;city&quot;</span>: <span class="hljs-string">&quot;北京&quot;</span>&#125;    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;main.js&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:        execjs_ = execjs.<span class="hljs-built_in">compile</span>(f.read())    <span class="hljs-comment"># 根据不同加密方式调用不同方法获取请求加密的 param 参数</span>    request_param_encrypt = key_iv_appid[<span class="hljs-string">&quot;request_param_encrypt&quot;</span>]    <span class="hljs-keyword">if</span> request_param_encrypt == <span class="hljs-string">&quot;AES&quot;</span>:        param = execjs_.call(            <span class="hljs-string">&#x27;getRequestAESParam&#x27;</span>, request_method, request_city,            key_iv_appid[<span class="hljs-string">&quot;app_id&quot;</span>], key_iv_appid[<span class="hljs-string">&quot;aes_key_2&quot;</span>], key_iv_appid[<span class="hljs-string">&quot;aes_iv_2&quot;</span>]        )    <span class="hljs-keyword">elif</span> request_param_encrypt == <span class="hljs-string">&quot;DES&quot;</span>:        param = execjs_.call(            <span class="hljs-string">&#x27;getRequestDESParam&#x27;</span>, request_method, request_city,            key_iv_appid[<span class="hljs-string">&quot;app_id&quot;</span>], key_iv_appid[<span class="hljs-string">&quot;des_key_2&quot;</span>], key_iv_appid[<span class="hljs-string">&quot;des_iv_2&quot;</span>]        )    <span class="hljs-keyword">else</span>:        param = execjs_.call(<span class="hljs-string">&#x27;getRequestParam&#x27;</span>, request_method, request_city, key_iv_appid[<span class="hljs-string">&quot;app_id&quot;</span>])    data = &#123;        key_iv_appid[<span class="hljs-string">&quot;request_data_name&quot;</span>]: param    &#125;    response = requests.post(url=aqistudy_api, headers=headers, data=data).text    <span class="hljs-comment"># print(response)</span>    <span class="hljs-comment"># 对获取的加密数据解密</span>    decrypted_data = execjs_.call(        <span class="hljs-string">&#x27;getDecryptedData&#x27;</span>, response,        key_iv_appid[<span class="hljs-string">&quot;aes_key_1&quot;</span>], key_iv_appid[<span class="hljs-string">&quot;aes_iv_1&quot;</span>],        key_iv_appid[<span class="hljs-string">&quot;des_key_1&quot;</span>], key_iv_appid[<span class="hljs-string">&quot;des_iv_1&quot;</span>]    )    <span class="hljs-built_in">print</span>(json.loads(decrypted_data))</code></pre><p>运行结果，成功请求并解密返回值：</p><p><img src="https://cdn.itbob.cn/img/article/044/27.png" alt="27.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/javascript_reverse.png&quot; alt=&quot;javascript_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket 协议爬虫，智慧树扫码登录案例分析</title>
    <link href="https://www.itbob.cn/article/043/"/>
    <id>https://www.itbob.cn/article/043/</id>
    <published>2021-12-07T08:30:00.000Z</published>
    <updated>2022-05-22T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.itbob.cn/img/cover/javascript_reverse.png" alt="javascript_reverse"></p><h2><span id="wen-zhang-mu-lu">文章目录</span></h2><hr><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ni-xiang-mu-biao">逆向目标</a></li><li><a href="#websocket-jian-jie">WebSocket 简介</a></li><li><a href="#zhua-bao-fen-xi">抓包分析</a></li><li><a href="#can-shu-huo-qu">参数获取</a></li><li><a href="#python-shi-xian-websocket-qing-qiu">Python 实现 WebSocket 请求</a></li><li><a href="#shi-xian-sao-ma-deng-lu">实现扫码登录</a></li><li><a href="#wan-zheng-dai-ma">完整代码</a></li></ul><!-- tocstop --><hr><h2><span id="sheng-ming">声明</span></h2><p><strong><font color="red">本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！</font></strong></p><p><strong><font color="red">本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请通过邮件 <a href="mailto:admin@itbob.cn">admin@itbob.cn</a> 联系我立即删除！</font></strong></p><h2><span id="ni-xiang-mu-biao">逆向目标</span></h2><ul><li>目标：智慧树扫码登录，接口使用了 WebSocket 通信协议</li><li>主页：<code>aHR0cHM6Ly9wYXNzcG9ydC56aGlodWlzaHUuY29tL2xvZ2luI3FyQ29kZUxvZ2lu</code></li></ul><h2><span id="websocket-jian-jie">WebSocket 简介</span></h2><p>WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议，WebSocket 使得客户端和服务器之间的数据交换变得更加简单。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><p>WebSocket 协议简称为 WS 或者 WSS（WebSocket Secure），其发送请求的 URL 以 <code>ws://</code> 或者 <code>wss://</code> 开头，WSS 是 WS 的加密版本，类似于 HTTP 与 HTTPS。</p><p>WebSocket 协议的最大特点就是：服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。与 HTTP 的对比如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/043/01.png" alt="01.png"></p><h2><span id="zhua-bao-fen-xi">抓包分析</span></h2><p>来到智慧树的扫码登录页面，抓包选中 WS，用来筛选 WebSocket 请求，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/043/02.png" alt="02.png"></p><p>其中有一些比较特别的参数，是 HTTP/ HTTPS 请求中没有的：</p><ul><li><code>Upgrade: websocket</code>：表明这是 WebSocket 类型请求；</li><li><code>Sec-WebSocket-Version</code>：告诉服务器所使用的 Websocket Draft（协议版本），必须是 13；</li><li><code>Sec-WebSocket-Extensions</code>：协议扩展，某类协议可能支持多个扩展，通过它可以实现协议增强；</li><li><code>Sec-WebSocket-Key</code>：是 WebSocket 客户端发送的一个 base64 编码的密文，是浏览器随机生成的，要求服务端必须返回一个对应加密的 <code>Sec-WebSocket-Accept</code> 应答，否则客户端会抛出 <code>Error during WebSocket handshake</code> 错误，并关闭连接。</li></ul><p>我们先扫码登录一遍，再选择 Messages 选项卡，可以看到有一些数据交互，其中绿色的箭头是客户端发送给服务器的数据，红色箭头是服务器响应返回给客户端的数据，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/043/03.png" alt="03.png"></p><p>我们观察一下整个交互过程，当我们打开二维码页面后，也就是二维码加载出来的同时，WebSocket 连接就建立了，每隔8秒左右，客户端就主动发送一串字符串，服务端也返回相同的字符串，只不过是字典格式，当我们扫码成功时，服务端就返回扫码成功的信息，当我们点击登陆时，客户端又会返回扫码结果，如果成功，就有一个一次性密码 <code>oncePassword</code> 和一个 <code>uuid</code>，这两个参数肯定在后续的请求中会用到的。如果长时间不扫码的话，过段时间就会返回二维码已失效的信息，每隔8秒发送一次消息，正是为了保持连接以及获取二维码状态消息。</p><p>那么到这里就出现了两个问题：</p><ol><li><p>在来回交互发送的那串字符串，是怎么得来的？</p></li><li><p>在 Python 中应该如何实现 WebSocket 请求？</p></li><li><p>如何实现客户端每隔 8 秒发送一次数据的同时，实时接收服务端的信息？（观察请求扫码结果实时返回的，所以不能每隔 8 秒才接收一次）</p></li></ol><h2><span id="can-shu-huo-qu">参数获取</span></h2><p>首先解决第一个问题，客户端发送的那串字符串是怎么来的，这里寻找加密字符串的方式和 HTTP/HTTPS 请求是一样的，在本例中，我们可以直接搜索这个字符串，发现是通过一个接口传过来的，其中 img 就是二维码图片的 base64 值，qrToken 就是客户端发送的那串字符串，如下图所示：</p><p><img src="https://cdn.itbob.cn/img/article/043/04.png" alt="04.png"></p><p>这里需要注意的是，并不是所有的 WebSocket 请求都是如此的简单的，有的客户端发送的数据是 Binary Message（二进制数据）、或者更复杂的加密参数，直接搜索无法获取，针对这种情况，我们也有解决方法：</p><ol><li><p>已知创建 WebSocket 对象的语句为：<code>var Socket = new WebSocket(url, [protocol] );</code>，所以我们可以搜索 <code>new WebSocket</code> 定位到建立请求的位置。</p></li><li><p>已知一个 WebSocket 对象有以下相关事件，我们可以搜索对应事件处理程序代码来定位：</p></li></ol><table><thead><tr><th style="text-align:left">事件</th><th style="text-align:left">事件处理程序</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">open</td><td style="text-align:left">Socket.onopen</td><td style="text-align:left">连接建立时触发</td></tr><tr><td style="text-align:left">message</td><td style="text-align:left">Socket.onmessage</td><td style="text-align:left">客户端接收服务端数据时触发</td></tr><tr><td style="text-align:left">error</td><td style="text-align:left">Socket.onerror</td><td style="text-align:left">通信发生错误时触发</td></tr><tr><td style="text-align:left">close</td><td style="text-align:left">Socket.onclose</td><td style="text-align:left">连接关闭时触发</td></tr></tbody></table><ol start="3"><li>已知一个 WebSocket 对象有以下相关方法，我们可以搜索对应方法来定位：</li></ol><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Socket.send()</td><td style="text-align:left">使用连接发送数据</td></tr><tr><td style="text-align:left">Socket.close()</td><td style="text-align:left">关闭连接</td></tr></tbody></table><h2><span id="python-shi-xian-websocket-qing-qiu">Python 实现 WebSocket 请求</span></h2><p>接着前面说，第二个问题，在 Python 中应该如何实现 WebSocket 请求？Python 库中用于连接 WebSocket 的有很多，比较常用、稳定的有 <a href="https://github.com/websocket-client/websocket-client">websocket-client</a>（非异步）、<a href="https://github.com/aaugustin/websockets">websockets</a>（异步）、<a href="https://github.com/asyncins/aiowebsocket">aiowebsocket</a>（异步）。在本案例中使用 websocket-client，这里还要注意第三个问题，对于客户端来说，要每隔 8 秒发送一次数据，对于服务端，我们需要实时接收服务端的信息，可以观察请求，扫码的结果是实时返回的，如果我们也每隔 8 秒才接收一次数据的话，有可能会丢失数据，而且也会使得整个程序的响应也不及时，效率变低。</p><p>在 websocket-client 官方文档中给我们提供了一个长连接的 demo，它实现了连续发送三次数据，并实时监听服务端返回的数据，其中的 <code>websocket.enableTrace(True)</code> 表示是否显示连接详细信息：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> websocket<span class="hljs-keyword">import</span> _thread<span class="hljs-keyword">import</span> time<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_message</span>(<span class="hljs-params">ws, message</span>):</span>    <span class="hljs-built_in">print</span>(message)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_error</span>(<span class="hljs-params">ws, error</span>):</span>    <span class="hljs-built_in">print</span>(error)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_close</span>(<span class="hljs-params">ws, close_status_code, close_msg</span>):</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;### closed ###&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_open</span>(<span class="hljs-params">ws</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">*args</span>):</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):            time.sleep(<span class="hljs-number">1</span>)            ws.send(<span class="hljs-string">&quot;Hello %d&quot;</span> % i)        time.sleep(<span class="hljs-number">1</span>)        ws.close()        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;thread terminating...&quot;</span>)    _thread.start_new_thread(run, ())<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    websocket.enableTrace(<span class="hljs-literal">True</span>)    ws = websocket.WebSocketApp(        <span class="hljs-string">&quot;ws://echo.websocket.org/&quot;</span>, on_open=on_open,        on_message=on_message, on_error=on_error, on_close=on_close    )    ws.run_forever()</code></pre><p>我们将其适当改造一下，客户端在 run 方法里，依然是每隔 8 秒发送一次 qr_token，实时接收服务端的消息，当“扫码成功”字样出现在消息里时，将得到的 <code>oncePassword</code> 和 <code>uuid</code> 存起来，然后关闭连接，逻辑代码如下所示，后续只要将二维码的获取逻辑接入就行了。（已脱敏处理，不能直接运行）</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> _thread<span class="hljs-keyword">import</span> websocketweb_socket_url = <span class="hljs-string">&quot;wss://appcomm-user.脱敏处理.com/app-commserv-user/websocket?qrToken=%s&quot;</span>qr_token = <span class="hljs-string">&quot;ca6e6cfb70de4f2f915b968aefcad404&quot;</span>once_password = <span class="hljs-string">&quot;&quot;</span>uuid = <span class="hljs-string">&quot;&quot;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss_on_message</span>(<span class="hljs-params">ws, message</span>):</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=============== [message] ===============&quot;</span>)    message = json.loads(message)    <span class="hljs-built_in">print</span>(message)    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;扫码成功&quot;</span> <span class="hljs-keyword">in</span> message[<span class="hljs-string">&quot;msg&quot;</span>]:        <span class="hljs-keyword">global</span> once_password, uuid        once_password = message[<span class="hljs-string">&quot;oncePassword&quot;</span>]        uuid = message[<span class="hljs-string">&quot;uuid&quot;</span>]        ws.close()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss_on_error</span>(<span class="hljs-params">ws, error</span>):</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=============== [error] ===============&quot;</span>)    <span class="hljs-built_in">print</span>(error)    ws.close()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss_on_close</span>(<span class="hljs-params">ws, close_status_code, close_msg</span>):</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=============== [closed] ===============&quot;</span>)    <span class="hljs-built_in">print</span>(close_status_code)    <span class="hljs-built_in">print</span>(close_msg)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss_on_open</span>(<span class="hljs-params">ws</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">*args</span>):</span>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:            ws.send(qr_token)            time.sleep(<span class="hljs-number">8</span>)    _thread.start_new_thread(run, (qr_token,))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss</span>():</span>    <span class="hljs-comment"># websocket.enableTrace(True)  # 是否显示连接详细信息</span>    ws = websocket.WebSocketApp(        web_socket_url % qr_token, on_open=wss_on_open,        on_message=wss_on_message, on_error=wss_on_error,        on_close=wss_on_close    )    ws.run_forever()</code></pre><h2><span id="shi-xian-sao-ma-deng-lu">实现扫码登录</span></h2><p>最重要的 WebSocket 请求部分已经解决了，扫码拿到 <code>oncePassword</code> 和 <code>uuid</code> 后，后续的处理步骤就比较简单了，现在来理一下完整的步骤：</p><ol><li>请求首页，第一次获取 cookie，包含：INGRESSCOOKIE、JSESSIONID、SERVERID、acw_tc；</li><li>请求获取二维码接口，得到二维码的 base64 值和 qrToken；</li><li>建立 WebSocket 连接，扫描二维码，获取一次性密码 oncePassword 和 uuid（好像没什么用）；</li><li>请求一个登录接口，302 重定向，需要携带一次性密码，第二次获取 cookie，包含：CASLOGC、CASTGC，同时更新 SERVERID；</li><li>请求第 4 步 302 重定向地址，第三次获取 cookie，包含：SESSION；</li><li>携带完整 cookie，请求用户信息接口，获取真实用户名等信息。</li></ol><p>实际上 WebSocket 连接结束后，有很多请求，看起来都比较可以，但是经过测试，只有两个重定向比较有用，抓包如下：</p><p><img src="https://cdn.itbob.cn/img/article/043/05.png" alt="05.png"></p><h2><span id="wan-zheng-dai-ma">完整代码</span></h2><p><strong>以下只演示部分关键代码，不能直接运行！</strong> 完整代码仓库地址：<a href="https://github.com/TRHX/Python3-Spider-Practice/">https://github.com/TRHX/Python3-Spider-Practice/</a></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> json<span class="hljs-keyword">import</span> base64<span class="hljs-keyword">import</span> _thread<span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> websocket<span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Imageweb_socket_url = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>get_login_qr_img_url = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>login_url = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>user_info_url = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>headers = &#123;    <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>,    <span class="hljs-string">&quot;Pragma&quot;</span>: <span class="hljs-string">&quot;no-cache&quot;</span>,    <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>,    <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36&quot;</span>&#125;qr_token = <span class="hljs-string">&quot;&quot;</span>once_password = <span class="hljs-string">&quot;&quot;</span>uuid = <span class="hljs-string">&quot;&quot;</span>cookie = &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cookies_first</span>():</span>    response = requests.get(url=login_url, headers=headers)    <span class="hljs-keyword">global</span> cookie    cookie = response.cookies.get_dict()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_login_qr_img</span>():</span>    response = requests.get(url=get_login_qr_img_url, headers=headers, cookies=cookie).json()    qr_img = response[<span class="hljs-string">&quot;img&quot;</span>]    <span class="hljs-keyword">global</span> qr_token    qr_token = response[<span class="hljs-string">&quot;qrToken&quot;</span>]    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;code.png&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:        f.write(base64.b64decode(qr_img))    image = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;code.png&#x27;</span>)    image.show()    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请扫描验证码! &quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss_on_message</span>(<span class="hljs-params">ws, message</span>):</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=============== [message] ===============&quot;</span>)    message = json.loads(message)    <span class="hljs-built_in">print</span>(message)    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;扫码成功&quot;</span> <span class="hljs-keyword">in</span> message[<span class="hljs-string">&quot;msg&quot;</span>]:        <span class="hljs-keyword">global</span> once_password, uuid        once_password = message[<span class="hljs-string">&quot;oncePassword&quot;</span>]        uuid = message[<span class="hljs-string">&quot;uuid&quot;</span>]        ws.close()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss_on_error</span>(<span class="hljs-params">ws, error</span>):</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=============== [error] ===============&quot;</span>)    <span class="hljs-built_in">print</span>(error)    ws.close()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss_on_close</span>(<span class="hljs-params">ws, close_status_code, close_msg</span>):</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=============== [closed] ===============&quot;</span>)    <span class="hljs-built_in">print</span>(close_status_code)    <span class="hljs-built_in">print</span>(close_msg)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss_on_open</span>(<span class="hljs-params">ws</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">*args</span>):</span>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:            ws.send(qr_token)            time.sleep(<span class="hljs-number">8</span>)    _thread.start_new_thread(run, (qr_token,))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wss</span>():</span>    <span class="hljs-comment"># websocket.enableTrace(True)  # 是否显示连接详细信息</span>    ws = websocket.WebSocketApp(        web_socket_url % qr_token, on_open=wss_on_open,        on_message=wss_on_message, on_error=wss_on_error,        on_close=wss_on_close    )    ws.run_forever()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cookie_second</span>():</span>    <span class="hljs-keyword">global</span> cookie    params = &#123;        <span class="hljs-string">&quot;pwd&quot;</span>: once_password,        <span class="hljs-string">&quot;service&quot;</span>: <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>    &#125;    headers[<span class="hljs-string">&quot;Host&quot;</span>] = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>    headers[<span class="hljs-string">&quot;Referer&quot;</span>] = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>    response = requests.get(url=login_url, params=params, headers=headers, cookies=cookie, allow_redirects=<span class="hljs-literal">False</span>)    cookie.update(response.cookies.get_dict())    location = response.headers.get(<span class="hljs-string">&quot;Location&quot;</span>)    <span class="hljs-keyword">return</span> location<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cookie_third</span>(<span class="hljs-params">location</span>):</span>    <span class="hljs-keyword">global</span> cookie    headers[<span class="hljs-string">&quot;Host&quot;</span>] = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>    headers[<span class="hljs-string">&quot;Referer&quot;</span>] = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>    response = requests.get(url=location, headers=headers, cookies=cookie, allow_redirects=<span class="hljs-literal">False</span>)    cookie.update(response.cookies.get_dict())    location = response.headers.get(<span class="hljs-string">&quot;Location&quot;</span>)    <span class="hljs-keyword">return</span> location<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_login_user_info</span>():</span>    headers[<span class="hljs-string">&quot;Host&quot;</span>] = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>    headers[<span class="hljs-string">&quot;Origin&quot;</span>] = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>    headers[<span class="hljs-string">&quot;Referer&quot;</span>] = <span class="hljs-string">&quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;</span>    params = &#123;<span class="hljs-string">&quot;time&quot;</span>: <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(time.time() * <span class="hljs-number">1000</span>))&#125;    response = requests.get(url=user_info_url, headers=headers, cookies=cookie, params=params)    <span class="hljs-built_in">print</span>(response.text)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>    <span class="hljs-comment"># 第一次获取 cookie，包含 INGRESSCOOKIE、JSESSIONID、SERVERID、acw_tc</span>    get_cookies_first()    <span class="hljs-comment"># 获取二维码</span>    get_login_qr_img()    <span class="hljs-comment"># websocket 扫码登录，返回一次性密码</span>    wss()    <span class="hljs-comment"># 第二次获取 cookie，更新 SERVERID、获取 CASLOGC、CASTGC</span>    location1 = get_cookie_second()    <span class="hljs-comment"># 第三次获取 cookie，获取 SESSION</span>    get_cookie_third(location1)    <span class="hljs-comment"># 获取登录用户信息</span>    get_login_user_info()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    main()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.itbob.cn/img/cover/javascript_reverse.png&quot; alt=&quot;javascript_reverse&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;wen-zhang-mu-lu&quot;&gt;文章目录&lt;/span&gt;</summary>
      
    
    
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/categories/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="爬虫" scheme="https://www.itbob.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="JS 逆向实战" scheme="https://www.itbob.cn/tags/JS-%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
</feed>
