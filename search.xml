<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【JS 逆向】AST 脱混淆实战，某 ICP 备案号查询接口 jsjiami v6 分析</title>
      <link href="/article/052/"/>
      <url>/article/052/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><strong>本文章中所有内容仅供学习交流，抓包内容、敏感网址、数据接口均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关，若有侵权，请在公众号联系我立即删除！</strong></p><h2 id="逆向目标"><a href="#逆向目标" class="headerlink" title="逆向目标"></a>逆向目标</h2><ul><li>目标：站 Z 之家网站 ICP 备案号查询</li><li>主页：<code>aHR0cDovL2ljcC5jaGluYXouY29tLw==</code></li><li>接口：<code>aHR0cDovL2ljcC5jaGluYXouY29tL2hvbWUvR2V0UGVyaW1pdEJ5SG9zdA==</code></li><li>逆向参数：<code>hostToken</code>、<code>permitToken</code></li></ul><p>本次主要是 AST 解混淆实战，本例中的 JS 混淆方式是 sojson 旗下的 jsjiami v6 版本，感兴趣的可以去官网体验一下：<a href="https://www.jsjiami.com/">https://www.jsjiami.com/</a> ，如果你还不了解 AST，可以先看看上期的文章（非常详细）：<a href="https://www.itbob.cn/article/051/">《逆向进阶，利用 AST 技术还原 JavaScript 混淆代码》</a>，本文部分 AST 还原代码直接使用了上期文章中的代码，所以细节方面不再赘述，有疑问的地方可以参考参考上期文章。</p><h2 id="第三方工具"><a href="#第三方工具" class="headerlink" title="第三方工具"></a>第三方工具</h2><p>逆向领域大佬云集，市面上已经有很多大佬写好的解混淆工具了，除了我们自己手动去写 AST 解析代码以外，有时候直接使用工具会更加方便，当然并没有十全十美的工具，不过大部分情况下都能成功解混淆的，以下工具值得去体验一下：</p><ul><li>蔡老板一键还原 OB 混淆：<a href="https://github.com/Tsaiboss/decodeObfuscator">https://github.com/Tsaiboss/decodeObfuscator</a></li><li>哲哥 AST 混淆还原框架：<a href="https://github.com/sml2h3/ast_tools">https://github.com/sml2h3/ast_tools</a></li><li>V 神 Chrome 插件，内置 AST 混淆还原：<a href="https://github.com/cilame/v_jstools">https://github.com/cilame/v_jstools</a></li><li>jsjiami v6 专用解密工具：<a href="https://github.com/NXY666/JsjiamiV6-Decryptor">https://github.com/NXY666/JsjiamiV6-Decryptor</a></li></ul><h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p>进入主题，首先抓包看看，来到 ICP 备案查询页面，查询结果中，其他信息都可以直接在相应的 html 源码中找到，只有这个备案号是通过接口传过来的，对应的请求和相关加密参数如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0f138564edc0bd1105d47f5cdfbfade8.png" alt="01"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/410785d65040014c5e2ef0790cd61d5c.png" alt="02"></p><h2 id="加密定位"><a href="#加密定位" class="headerlink" title="加密定位"></a>加密定位</h2><p>直接搜索关键字 <code>hostToken</code> 或者 <code>permitToken</code> 即可定位：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ce5187bac33cd5f5a818cfc2a6a720fb.png" alt="03"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/049d86ab89afba4d32cb21ac9a2fb599.png" alt="04"></p><p>关键代码：</p><pre><code class="javascript">&#39;data&#39;: &#123;    &#39;kw&#39;: kw,    &#39;hostToken&#39;: _0x791532[&#39;IIPmq&#39;](generateHostKey, kw),    &#39;permitToken&#39;: _0x791532[_0x404f(&#39;‫1df&#39;, &#39;7Gn4&#39;)](generateWordKey, kw)&#125;</code></pre><p>这里的混淆可以手动跟一下，还原后如下：</p><pre><code class="javascript">&#39;data&#39;: &#123;    &#39;kw&#39;: kw,    &#39;hostToken&#39;: generateHostKey(kw),    &#39;permitToken&#39;: generateWordKey(kw)&#125;</code></pre><p><code>kw</code> 是查询的域名，有用的就是 <code>generateHostKey()</code> 和 <code>generateWordKey()</code> 两个方法了，跟进去看，代码经过了 jsjiami v6 混淆：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/66713c07ba6880c09c9dbc3604e290df.png" alt="05"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/abcc44976be8d583e2cd948e06c705d9.png" alt="06"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/3332edc2c481e2dbc672ca818c8ad060.png" alt="07"></p><h2 id="AST-脱混淆"><a href="#AST-脱混淆" class="headerlink" title="AST 脱混淆"></a>AST 脱混淆</h2><p>jsjiami 混淆的特征其实和 OB 混淆是类似的：</p><ol><li>一般由一个大数组或者含有大数组的函数、一个数组位移操作的自执行函数、一个解密函数和加密后的函数四部分组成；</li><li>函数名和变量名通常以 _0x 或者 0x 开头，后接 1~6 位数字或字母组合；</li><li>数组位移操作的自执行函数里，有明显的 push、shift 关键字。</li></ol><p>本例中，<code>generateHostKey()</code> 方法在 <code>commo.js</code> 里，<code>generateWordKey()</code> 方法在 <code>generatetoken.js</code> 里，结构如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3d1c1327ff484c80e8e308d16c71cd22.png" alt="08"></p><p>观察 <code>generatetoken.js</code> 文件，可以发现这里面也有 <code>commo.js</code> 里面的 <code>generateHostKey()</code> 和 <code>getRandom()</code> 方法，从方法名来看貌似是重复了，实际上混淆还原后方法是一样的，所以这里我们只需要还原 <code>generatetoken.js</code> 就可以了。</p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><ul><li>混淆 JS 文件：<code>generatetoken.js</code></li><li>AST 还原代码：<code>generatetokenAst.js</code></li><li>还原后的代码：<code>generatetokenNew.js</code></li></ul><h3 id="解密函数还原"><a href="#解密函数还原" class="headerlink" title="解密函数还原"></a>解密函数还原</h3><p>在原来混淆后的 JS 里，解密函数是 <code>_0x530e</code>，首先观察整个 JS，调用了很多次解密函数，类似于：<code>_0x530e(&#39;1&#39;, &#39;7XEq&#39;)</code>。</p><p>注意这里代码里面有一些特殊字符，类似于 <code>RLE</code>、<code>RLO</code> 之类的，如果在 VSCode 打开是一些 <code>U+202B</code>、<code>U+202E</code> 的字符，实际上这是 RTLO (Right-to-Left Override) 字符，<code>U+202B</code> 和 <code>U+202E</code> 的意思分别是根据内存顺序从左至右和从右至左显示字符，感兴趣的可以网上搜索了解一下。这里并不影响我们进行还原操作。但是如果直接复制过来的话就会导致前后文显示的顺序不对，所以本文中为了方便描述，粘贴的部分代码就手动去掉了这些字符。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/160a9bdb547e5cd19a94563f78addccf.png" alt="09"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/6a62938a7cb953b2c02e7e0326ea8d23.png" alt="10"></p><p>所以第一步我们要还原一下解密函数，把所有 <code>_0x530e</code> 调用的地方直接替换成实际值，首先需要将大数组、自执行函数、加密函数和解密函数分割开，将代码放到 astexplorer.net 看一下，也就是将 body 的前四部分和后面剩余部分分割开来，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/588093722962f4d006dcfeefbe90cb7a.png" alt="11"></p><p>分割代码：</p><pre><code class="javascript">const fs = require(&quot;fs&quot;);const parse = require(&quot;@babel/parser&quot;).parse;const generate = require(&quot;@babel/generator&quot;).defaultconst traverse = require(&quot;@babel/traverse&quot;).defaultconst types = require(&quot;@babel/types&quot;)// 导入混淆代码并解析为 ASTconst oldCode = fs.readFileSync(&quot;generatetoken.js&quot;, &#123;encoding: &quot;utf-8&quot;&#125;);const astCode = parse(oldCode);// 获取整个 AST 节点的长度let astCodeLength = astCode.program.body.length// 获取解密函数的名字 也就是 _0x530elet decryptFunctionName = astCode.program.body[3].id.name// 分割加密函数和解密函数，即 body 的前四部分和后面剩余部分let decryptFunction = astCode.program.body.slice(0, 4)let encryptFunction = astCode.program.body.slice(4, astCodeLength)// 获取加密函数和解密函数的方法多种多样，比如可以挨个取值并转换成 JS 代码// 这样做就不需要将解密函数赋值给整个 AST 节点了// let decryptFunction = &quot;&quot;;// for(let i=0; i&lt;4; i++)&#123;//     decryptFunction += generate(astCode.program.body[i], &#123;compact: true&#125;).code// &#125;// eval(decryptFunction);</code></pre><p>在上面的获取加密函数和解密函数的代码中，方法不是唯一的，多种多样，比如直接循环取 body 并转换成 JS 代码，比如直接人工把大数组、自执行函数和解密函数三部分，拿出来放到一个新文件里，然后导出解密方法，后续直接调用也可以。</p><p>在本例中，拿到解密函数后，需要将其赋值给整个 AST 节点，然后再将整个 AST 节点转换成 JavaScript 代码，这里注意有可能会检测代码是否格式化，所以建议转换要加一个 <code>compact</code> 参数，避免格式化，转换完成后 <code>eval</code> 执行一下，让数组位移操作完成，然后我们就可以直接调用解密函数，即 <code>_0x530e()</code>。</p><pre><code class="javascript">// 将解密函数赋值给整个 AST 节点astCode.program.body = decryptFunction// 将 AST 节点转换成 JS 代码，并 eval 执行一下decryptFunction = generate(astCode, &#123;compact: true&#125;).codeeval(decryptFunction);// 测试一下，直接调用 _0x530e 函数可以正确拿到结果// 输出 split// console.log(_0x530e(&#39;‮b&#39;, &#39;Zp9G&#39;))</code></pre><p>现在我们能直接调用解密函数 <code>_0x530e()</code> 了，接下来要做的就是怎么把混淆代码中所有调用 <code>_0x530e()</code> 的地方替换成真实值，在此之前，我们要把加密函数（<code>generateKey()</code>、<code>generateHostKey()</code>、<code>generateWordKey()</code> 和 <code>getRandom()</code>）赋值给整个 AST 节点，此时整个节点就没有大数组、自执行函数和解密函数了，解密函数 <code>_0x530e()</code> 已经被写入内存，所以后面不影响我们调用。</p><p>老样子，还是先在 astexplorer.net 看一下调用 <code>_0x530e()</code> 的地方，以 <code>_0x530e(&#39;b&#39;, &#39;Zp9G&#39;)</code> 为例，其真实值应该是 <code>split</code>，对比一下替换前后的结构，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/97d80ef9b923f117cac6e4060a4998f5.png" alt="12"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/8bf00ab1113c218219f838cd00ab21e9.png" alt="13"></p><p>可以看到节点由原来的 <code>CallExpression</code> 变成了 <code>StringLiteral</code>，所以我们可以遍历 <code>CallExpression</code>，如果函数名为解密函数名，那就通过 <code>path.toString()</code> 方法获取节点源码，也就类似 <code>_0x530e(&#39;b&#39;, &#39;Zp9G&#39;)</code> 的源码，然后 <code>eval</code> 执行一下获取其真实值，再使用 <code>types.stringLiteral()</code> 构建 <code>StringLiteral</code> 节点，最后通过 <code>path.replaceInline()</code> 方法替换节点，遍历代码如下：</p><pre><code class="javascript">// 将加密函数赋值给整个 AST 节点，此时整个节点就没有大数组、自执行函数和解密函数了astCode.program.body = encryptFunction// 调用解密函数，直接计算出类似以下方法的值并替换// 混淆代码：_0x530e(&#39;‮b&#39;, &#39;Zp9G&#39;)// 还原后：splitconst visitor1 = &#123;    CallExpression(path)&#123;        if (path.node.callee.name === decryptFunctionName &amp;&amp; path.node.arguments.length === 2)&#123;            path.replaceInline(types.stringLiteral(eval(path.toString())))        &#125;    &#125;&#125;// 遍历节点traverse(astCode, visitor1)// 将 AST 节点转换成 JS 代码并写入到新文件里const result = generate(astCode, &#123;concise:true&#125;).codefs.writeFile(&quot;./generatetokenNew.js&quot;, result, (err =&gt; &#123;console.log(err)&#125;))</code></pre><p>自此，第一步的解密函数还原就完成了，可以看一下还原前后的对比，如下图所示浅蓝色标记的地方，所有调用 <code>_0x530e()</code> 的地方都被还原了：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/592ed12ad85ea4b424c8b59a99e03bc9.png" alt="14"></p><h3 id="大对象还原"><a href="#大对象还原" class="headerlink" title="大对象还原"></a>大对象还原</h3><p>初步还原后我们的代码里就只剩下以下四个方法：</p><ul><li><code>generateKey()</code></li><li><code>generateHostKey()</code></li><li><code>generateWordKey()</code></li><li> <code>getRandom()</code></li></ul><p>再观察代码，发现每个方法一开始都有个大的对象，他们分别是：</p><ul><li><code>_0x3b79c6</code></li><li><code>_0x278b2d</code></li><li><code>_0x4115c4</code></li><li><code>_0xd8ec33</code></li></ul><p>后续的代码也在不断调用这个对象的方法，比如 <code>_0x3b79c6[&quot;esdtg&quot;](_0x2e5848[&quot;length&quot;], 0x4)</code> 实际上就是 <code>_0x2e5848[&quot;length&quot;] != 0x4</code>，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/dad85b7cf44527da212f026cf6f8fd36.png" alt="15"></p><p>首先我们将这四个大的对象单独提取出来，还是保持原来的键值对样式，提取完成后删除这两个节点，遍历代码如下：</p><pre><code class="javascript">let functionName = &#123;    &quot;_0x3b79c6&quot;: &#123;&#125;,    &quot;_0x278b2d&quot;: &#123;&#125;,    &quot;_0x4115c4&quot;: &#123;&#125;,    &quot;_0xd8ec33&quot;: &#123;&#125;&#125;// 单独提取出四个大对象const visitor2 = &#123;    VariableDeclarator(path)&#123;        for (let key in functionName)&#123;            if (path.node &amp;&amp; path.node.id.name == key) &#123;                const properties = path.node.init.properties                for (let i=0; i&lt;properties.length; i++)&#123;                    functionName[key][properties[i].key.value] = properties[i].value                &#125;                // 写入对象后就可以删除该节点了                path.remove()            &#125;        &#125;    &#125;&#125;</code></pre><p>这里要注意，大的对象里面，有 <code>+</code>、<code>-</code>、<code>==</code> 之类的二项式计算，也有直接为字符串的，还有变成函数调用的，如下所示：</p><pre><code class="JavaScript">var _0x3b79c6 = &#123;    &#39;MuRlB&#39;: function (_0x3ca134, _0x50ee94) &#123;        return _0x3ca134 + _0x50ee94;    &#125;,     &#39;Ucwyj&#39;: function (_0x32bfa3, _0x3b191b) &#123;        return _0x32bfa3(_0x3b191b);    &#125;,     &#39;YrYQW&#39;: &#39;#IpValue&#39;&#125;</code></pre><p>针对不同的情况有不同的处理方法，同时还要注意传参和 return 返回的参数位置，不要还原后把 <code>a - b</code> 搞成 <code>b - a</code> 了，当然在本例中传入和返回的顺序是一样的，就不需要考虑这个问题。</p><h4 id="字符串还原"><a href="#字符串还原" class="headerlink" title="字符串还原"></a>字符串还原</h4><p>首先来看字符串，有以下几种情况：</p><ul><li>以 <code>_0x3b79c6[&#39;YrYQW&#39;]</code> 为例，实际上其值为字符串 <code>&#39;#IpValue&#39;</code>，观察其结构，是一个 <code>MemberExpression</code>，在一个列表里；</li><li>以 <code>_0x278b2d[&#39;pjbyX&#39;]</code> 为例，实际上其值为字符串 <code>&#39;3|2|1|4|5|0|6&#39;</code>，观察其结构，是一个 <code>MemberExpression</code>，在一个字典里；</li><li>以 <code>_0x278b2d[&#39;CnTaO&#39;]</code> 为例，虽然也是一个 <code>MemberExpression</code>，也在一个字典里。但实际上是二项式计算，所以要排除在外。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/c7da2da4b18ea101be336632d3302e9b.png" alt="16"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/bb64748de3614028d49b5445a8f0a4bd.png" alt="17"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/2d864c898a10fe2512de55ae0aae6b4b.png" alt="18"></p><p>所以我们在写遍历代码时，同时要注意这三种情况，满足条件后直接取原来大对象对应的节点进行替换即可，遍历代码如下所示：</p><pre><code class="javascript">// 函数替换，字符串替换：将类似 _0x3b79c6[&#39;YrYQW&#39;] 变成 &#39;#IpValue&#39;const visitor3 = &#123;    MemberExpression(path) &#123;        for (let key in functionName)&#123;            if (path.node.object &amp;&amp; path.node.object.name == key &amp;&amp; path.inList ) &#123;                path.replaceInline(functionName[key][path.node.property.value])            &#125;            if (path.node.object &amp;&amp; path.node.object.name == key &amp;&amp; path.parent.property &amp;&amp; path.parent.property.value == &quot;split&quot;) &#123;                path.replaceInline(functionName[key][path.node.property.value])            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="二项式计算替换"><a href="#二项式计算替换" class="headerlink" title="二项式计算替换"></a>二项式计算替换</h4><p>再来看看二项式计算的情况，以 <code>_0x278b2d[&#39;CnTaO&#39;](_0x691267[&quot;length&quot;], 0x1)</code> 为例，实际上是做减法运算，即 <code>_0x691267[&quot;length&quot;] - 0x1</code>，看一下替换前后对比：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/15473cd5662d90370f1bdd845bd6f42a.png" alt="19"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c2c67cc2f0760f493d99a29281599894.png" alt="20"></p><p>对于这种情况，我们可以直接提取两个参数，然后提取大对象里对应方法的操作符，然后将参数和操作符直接连接起来组成新的节点（<code>binaryExpression</code>）并替换即可，遍历代码如下：</p><pre><code class="javascript">// 函数替换，二项式计算：将类似 _0x278b2d[&#39;CnTaO&#39;](_0x691267[&quot;length&quot;], 0x1) 变成 _0x691267[&quot;length&quot;] - 0x1const visitor4 = &#123;    CallExpression(path)&#123;        for (let key in functionName) &#123;            if (path.node.callee &amp;&amp; path.node.callee.object &amp;&amp; path.node.callee.object.name == key) &#123;                let func = functionName[key][path.node.callee.property.value]                if (func.body.body[0].argument.type == &quot;BinaryExpression&quot;) &#123;                    let operator = func.body.body[0].argument.operator                    let left = path.node.arguments[0]                    let right = path.node.arguments[1]                    path.replaceInline(types.binaryExpression(operator, left, right))                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="方法调用还原"><a href="#方法调用还原" class="headerlink" title="方法调用还原"></a>方法调用还原</h4><p>以 <code>_0x4115c4[&quot;PJbSm&quot;](getRandom, 0x64, 0x3e7)</code> 为例，实际上是 <code>getRandom(0x64, 0x3e7)</code>，看一下替换前后对比：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0214e34c163d988a87ae74c287aa4fb9.png" alt="21"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/618a03ab22a77658de6b3f90232ad8cd.png" alt="22"></p><p>对于这种情况，传入的第一个参数为方法名称，后面的都是参数，那么可以直接取第一个元素为方法名称，使用 <code>slice(1)</code> 方法取后面所有的参数（因为后面的参数个数是不一定的），然后构造新的节点（<code>callExpression</code>）并替换即可，这部分遍历代码可以和前面二项式的替换相结合，代码如下：</p><pre><code class="javascript">// 函数替换，二项式计算：将类似 _0x278b2d[&#39;CnTaO&#39;](_0x691267[&quot;length&quot;], 0x1) 变成 _0x691267[&quot;length&quot;] - 0x1// 函数替换，方法调用：将类似 _0x4115c4[&quot;PJbSm&quot;](getRandom, 0x64, 0x3e7) 变成 getRandom(0x64, 0x3e7)const visitor4 = &#123;    CallExpression(path)&#123;        for (let key in functionName) &#123;            if (path.node.callee &amp;&amp; path.node.callee.object &amp;&amp; path.node.callee.object.name == key) &#123;                let func = functionName[key][path.node.callee.property.value]                if (func.body.body[0].argument.type == &quot;BinaryExpression&quot;) &#123;                    let operator = func.body.body[0].argument.operator                    let left = path.node.arguments[0]                    let right = path.node.arguments[1]                    path.replaceInline(types.binaryExpression(operator, left, right))                &#125;                if (func.body.body[0].argument.type == &quot;CallExpression&quot;) &#123;                    let identifier = path.node.arguments[0]                    let arguments = path.node.arguments.slice(1)                    path.replaceInline(types.callExpression(identifier, arguments))                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>自此，第二步的大对象还原就完成了，可以看一下还原前后的对比，如下图所示浅蓝色标记的地方，所有调用四个大对象（<code>_0x3b79c6</code>、<code>_0x278b2d</code>、<code>_0x4115c4</code>、<code>_0xd8ec33</code>）的地方都被还原了：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7d6b3b0a9c46e31799e0c8d15b3a7b86.png" alt="23"></p><h3 id="switch-case-反控制流平坦化"><a href="#switch-case-反控制流平坦化" class="headerlink" title="switch-case 反控制流平坦化"></a>switch-case 反控制流平坦化</h3><p>经过前面几步的还原之后，我们发现 <code>generateHostKey()</code>、<code>generateWordKey()</code>、<code>getRandom()</code> 方法里都有一个 <code>switch-case</code> 的控制流，关于反控制流平坦化的讲解在我上期文章有很详细的介绍，不理解的可以看看上期文章，此处也不再赘述了，直接贴代码了：</p><pre><code class="javascript">// switch-case 反控制流平坦化const visitor5 = &#123;    WhileStatement(path) &#123;        // switch 节点        let switchNode = path.node.body.body[0];        // switch 语句内的控制流数组名，本例中是 _0x28073a、_0x2efb35、_0x187fb8        let arrayName = switchNode.discriminant.object.name;        // 获取控制流数组绑定的节点        let bindingArray = path.scope.getBinding(arrayName);        // 获取节点整个表达式的参数、分割方法、分隔符        let init = bindingArray.path.node.init;        let object = init.callee.object.value;        let property = init.callee.property.value;        let argument = init.arguments[0].value;        // 模拟执行 &#39;3|2|1|4|5|0|6&#39;[&#39;split&#39;](&#39;|&#39;) 语句        let array = object[property](argument)        // 也可以直接取参数进行分割，方法不通用，比如分隔符换成 , 就不行了        // let array = init.callee.object.value.split(&#39;|&#39;);        // switch 语句内的控制流自增变量名，本例中是 _0x38c69e、_0x396880、_0x3b3dc7        let autoIncrementName = switchNode.discriminant.property.argument.name;        // 获取控制流自增变量名绑定的节点        let bindingAutoIncrement = path.scope.getBinding(autoIncrementName);        // 可选择的操作：删除控制流数组绑定的节点、自增变量名绑定的节点        bindingArray.path.remove();        bindingAutoIncrement.path.remove();        // 储存正确顺序的控制流语句        let replace = [];        // 遍历控制流数组，按正确顺序取 case 内容        array.forEach(index =&gt; &#123;                let consequent = switchNode.cases[index].consequent;                // 如果最后一个节点是 continue 语句，则删除 ContinueStatement 节点                if (types.isContinueStatement(consequent[consequent.length - 1])) &#123;                    consequent.pop();                &#125;                // concat 方法拼接多个数组，即正确顺序的 case 内容                replace = replace.concat(consequent);            &#125;        );        // 替换整个 while 节点，两种方法都可以        path.replaceWithMultiple(replace);        // path.replaceInline(replace);    &#125;&#125;</code></pre><h3 id="其他细节还原"><a href="#其他细节还原" class="headerlink" title="其他细节还原"></a>其他细节还原</h3><p>到这里其实大部分混淆都已经还原了，已经很容易分析其逻辑了，还剩下一些细节，我们也还原一下，主要有以下细节：</p><ul><li>十六进制、Unicode 编码等，转正常字符；</li><li>对象属性还原，比如 <code>_0x3cbc20[&#39;length&#39;]</code> 转换成 <code>_0x3cbc20.length</code>；</li><li>表达式还原，比如 <code>!![]</code> 直接计算成 true；</li><li>删除未引用的变量，比如 <code>_0xodD= &quot;jsjiami.com.v6&quot;;</code>；</li><li>删除冗余逻辑代码，只保留 if 为 true 的。</li></ul><p>这些还原代码在我上期文章有详细讲过，结合代码，在 astexplorer.net 对照其结构看，也能理解，同样也不赘述了，直接贴代码：</p><pre><code class="javascript">const visitor5 = &#123;    // 十六进制、Unicode 编码等，转正常字符    &quot;StringLiteral|NumericLiteral&quot;(path)&#123;        delete path.node.extra;    &#125;,    // _0x3cbc20[&quot;length&quot;] 转换成 _0x3cbc20.length    MemberExpression(path)&#123;        if (path.node.property.type == &quot;StringLiteral&quot;) &#123;            path.node.computed = false            path.node.property = types.identifier(path.node.property.value)        &#125;    &#125;,    // 表达式还原，!![] 直接计算成 true    &quot;BinaryExpression|UnaryExpression&quot;(path) &#123;        let &#123;confident, value&#125; = path.evaluate()        if (confident)&#123;            path.replaceInline(types.valueToNode(value))        &#125;    &#125;,    // 删除未引用的变量，比如 _0xodD = &quot;jsjiami.com.v6&quot;;    AssignmentExpression(path)&#123;        let binding = path.scope.getBinding(path.node.left.name);        if (!binding) &#123;            path.remove();        &#125;    &#125;&#125;// 删除冗余逻辑代码，只保留 if 为 true 的const visitor6 = &#123;    IfStatement(path) &#123;        if(path.node.test.type == &quot;BooleanLiteral&quot;) &#123;            if(path.node.test.value) &#123;                path.replaceInline(path.node.consequent.body)            &#125; else &#123;                path.replaceInline(path.node.alternate.body)            &#125;        &#125;    &#125;&#125;</code></pre><p>自此 jajiami v6 混淆就还原完毕了，还原前后对比一下，代码量缩短了很多，逻辑也更加清楚了，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/52f0ccf4ce30a1c150ddd25e8f189ab0.png" alt="24"></p><p>最后结合 Python 代码，携带生成的 <code>hostToken</code> 和 <code>permitToken</code>，成功拿到备案号：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4b54ca38cc38d9776bdb39c52ed25c93.png" alt="25"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>原混淆代码 <code>generatetoken.js</code>、AST 脱混淆代码 <code>generatetokenAst.js</code>、还原后的代码 <code>generatetokenNew.js</code>，以及 Python 测试代码均在 GitHub，均有详细注释，欢迎 Star。所有内容仅供学习交流，严禁用于商业用途、非法用途，否则由此产生的一切后果均与作者无关，在仓库中下载的文件学习完毕之后请于 24 小时内删除！</p><p>代码地址：<a href="https://github.com/TRHX/Python3-Spider-Practice">https://github.com/TRHX/Python3-Spider-Practice</a></p>]]></content>
      
      
      <categories>
          
          <category> JS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS 逆向 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向进阶，利用 AST 技术还原 JavaScript 混淆代码</title>
      <link href="/article/051/"/>
      <url>/article/051/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-AST"><a href="#什么是-AST" class="headerlink" title="什么是 AST"></a>什么是 AST</h2><p>AST（Abstract Syntax Tree），中文抽象语法树，简称语法树（Syntax Tree），是源代码的抽象语法结构的树状表现形式，树上的每个节点都表示源代码中的一种结构。语法树不是某一种编程语言独有的，JavaScript、Python、Java、Golang 等几乎所有编程语言都有语法树。</p><p>小时候我们得到一个玩具，总喜欢把玩具拆解成一个一个小零件，然后按照我们自己的想法，把零件重新组装起来，一个新玩具就诞生了。而 JavaScript 就像一台精妙运作的机器，通过 AST 解析，我们也可以像童年时拆解玩具一样，深入了解 JavaScript 这台机器的各个零部件，然后重新按照我们自己的意愿来组装。</p><p>AST 的用途很广，IDE 的语法高亮、代码检查、格式化、压缩、转译等，都需要先将代码转化成 AST 再进行后续的操作，ES5 和 ES6 语法差异，为了向后兼容，在实际应用中需要进行语法的转换，也会用到 AST。AST 并不是为了逆向而生，但做逆向学会了 AST，在解混淆时可以如鱼得水。</p><p>AST 有一个在线解析网站：<a href="https://astexplorer.net/">https://astexplorer.net/</a> ，顶部可以选择语言、编译器、是否开启转化等，如下图所示，区域①是源代码，区域②是对应的 AST 语法树，区域③是转换代码，可以对语法树进行各种操作，区域④是转换后生成的新代码。图中原来的 Unicode 字符经过操作之后就变成了正常字符。</p><p>语法树没有单一的格式，选择不同的语言、不同的编译器，得到的结果也是不一样的，在 JavaScript 中，编译器有 Acorn、Espree、Esprima、Recast、Uglify-JS 等，使用最多的是 Babel，后续的学习也是以 Babel 为例。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3e56f2edec502087a2bb0b10ef178b52.png" alt="01"></p><h2 id="AST-在编译中的位置"><a href="#AST-在编译中的位置" class="headerlink" title="AST 在编译中的位置"></a>AST 在编译中的位置</h2><p>在编译原理中，编译器转换代码通常要经过三个步骤：词法分析（Lexical Analysis）、语法分析（Syntax Analysis）、代码生成（Code Generation），下图生动展示了这一过程：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/90fe33b7b362f60e1ee1849bf3c06fc9.png" alt="02"></p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词法分析阶段是编译过程的第一个阶段，这个阶段的任务是从左到右一个字符一个字符地读入源程序，然后根据构词规则识别单词，生成 token 符号流，比如 <code>isPanda(&#39;🐼&#39;)</code>，会被拆分成 <code>isPanda</code>，<code>(</code>，<code>&#39;🐼&#39;</code>，<code>)</code> 四部分，每部分都有不同的含义，可以将词法分析过程想象为不同类型标记的列表或数组。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/de8a6906cf7db9be51ef2eb56cbd1b70.gif#pic_center" alt="03"></p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法分析是编译过程的一个逻辑阶段，语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，比如“程序”，“语句”，“表达式”等，前面的例子中，<code>isPanda(&#39;🐼&#39;)</code> 就会被分析为一条表达语句 <code>ExpressionStatement</code>，<code>isPanda()</code> 就会被分析成一个函数表达式 <code>CallExpression</code>，<code>🐼</code> 就会被分析成一个变量 <code>Literal</code> 等，众多语法之间的依赖、嵌套关系，就构成了一个树状结构，即 AST 语法树。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/45b5484465969681707f32a2dde5370b.gif#pic_center" alt="04"></p><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>代码生成是最后一步，将 AST 语法树转换成可执行代码即可，在转换之前，我们可以直接操作语法树，进行增删改查等操作，例如，我们可以确定变量的声明位置、更改变量的值、删除某些节点等，我们将语句 <code>isPanda(&#39;🐼&#39;)</code> 修改为一个布尔类型的 <code>Literal</code>：<code>true</code>，语法树就有如下变化：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6659a4f8614b61a4d6376aadca326f88.gif#pic_center" alt="05"></p><h2 id="Babel-简介"><a href="#Babel-简介" class="headerlink" title="Babel 简介"></a>Babel 简介</h2><p>Babel 是一个 JavaScript 编译器，也可以说是一个解析库，Babel 中文网：<a href="https://www.babeljs.cn/">https://www.babeljs.cn/</a> ，Babel 英文官网：<a href="https://babeljs.io/">https://babeljs.io/</a> ，Babel 内置了很多分析 JavaScript 代码的方法，我们可以利用 Babel 将 JavaScript 代码转换成 AST 语法树，然后增删改查等操作之后，再转换成 JavaScript 代码。</p><p>Babel 包含的各种功能包、API、各方法可选参数等，都非常多，本文不一一列举，在实际使用过程中，应当多查询官方文档，或者参考文末给出的一些学习资料。Babel 的安装和其他 Node 包一样，需要哪个安装哪个即可，比如 <code>npm install @babel/core @babel/parser @babel/traverse @babel/generator</code></p><p>在做逆向解混淆中，主要用到了 Babel 的以下几个功能包，本文也仅介绍以下几个功能包：</p><ol><li><code>@babel/core</code>：Babel 编译器本身，提供了 babel 的编译 API；</li><li><code>@babel/parser</code>：将 JavaScript 代码解析成 AST 语法树；</li><li><code>@babel/traverse</code>：遍历、修改 AST 语法树的各个节点；</li><li><code>@babel/generator</code>：将 AST 还原成 JavaScript 代码；</li><li><code>@babel/types</code>：判断、验证节点的类型、构建新 AST 节点等。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/f8be61bdf850b955459dd4d476f80822.png" alt="06"></p><h3 id="babel-core"><a href="#babel-core" class="headerlink" title="@babel/core"></a>@babel/core</h3><p>Babel 编译器本身，被拆分成了三个模块：<code>@babel/parser</code>、<code>@babel/traverse</code>、<code>@babel/generator</code>，比如以下方法的导入效果都是一样的：</p><pre><code class="javascript">const parse = require(&quot;@babel/parser&quot;).parse;const parse = require(&quot;@babel/core&quot;).parse;const traverse = require(&quot;@babel/traverse&quot;).defaultconst traverse = require(&quot;@babel/core&quot;).traverse</code></pre><h3 id="babel-parser"><a href="#babel-parser" class="headerlink" title="@babel/parser"></a>@babel/parser</h3><p><code>@babel/parser</code> 可以将 JavaScript 代码解析成 AST 语法树，其中主要提供了两个方法：</p><ul><li><code>parser.parse(code, [&#123;options&#125;])</code>：解析一段 JavaScript 代码；</li><li><code>parser.parseExpression(code, [&#123;options&#125;])</code>：考虑到了性能问题，解析单个 JavaScript 表达式。</li></ul><p>部分可选参数 <code>options</code>：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>allowImportExportEverywhere</code></td><td>默认 <code>import</code> 和 <code>export</code> 声明语句只能出现在程序的最顶层，设置为 <code>true</code> 则在任何地方都可以声明</td></tr><tr><td><code>allowReturnOutsideFunction</code></td><td>默认如果在顶层中使用 <code>return</code> 语句会引起错误，设置为 <code>true</code> 就不会报错</td></tr><tr><td><code>sourceType</code></td><td>默认为 <code>script</code>，当代码中含有 <code>import</code> 、<code>export</code> 等关键字时会报错，需要指定为 <code>module</code></td></tr><tr><td><code>errorRecovery</code></td><td>默认如果 babel 发现一些不正常的代码就会抛出错误，设置为 <code>true</code> 则会在保存解析错误的同时继续解析代码，错误的记录将被保存在最终生成的 AST 的 errors 属性中，当然如果遇到严重的错误，依然会终止解析</td></tr></tbody></table><p>举个例子看得比较清楚：</p><pre><code class="javascript">const parser = require(&quot;@babel/parser&quot;);const code = &quot;const a = 1;&quot;;const ast = parser.parse(code, &#123;sourceType: &quot;module&quot;&#125;)console.log(ast)</code></pre><p><code>&#123;sourceType: &quot;module&quot;&#125;</code> 演示了如何添加可选参数，输出的就是 AST 语法树，这和在线网站 <a href="https://astexplorer.net/">https://astexplorer.net/</a> 解析出来的语法树是一样的：</p><p><img src="https://img-blog.csdnimg.cn/cb7791be87be4a4c8f47add3228e3d58.png" alt="07"></p><h3 id="babel-generator"><a href="#babel-generator" class="headerlink" title="@babel/generator"></a>@babel/generator</h3><p><code>@babel/generator</code> 可以将 AST 还原成 JavaScript 代码，提供了一个 <code>generate</code> 方法：<code>generate(ast, [&#123;options&#125;], code)</code>。</p><p>部分可选参数 <code>options</code>：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>auxiliaryCommentBefore</code></td><td>在输出文件内容的头部添加注释块文字</td></tr><tr><td><code>auxiliaryCommentAfter</code></td><td>在输出文件内容的末尾添加注释块文字</td></tr><tr><td><code>comments</code></td><td>输出内容是否包含注释</td></tr><tr><td><code>compact</code></td><td>输出内容是否不添加空格，避免格式化</td></tr><tr><td><code>concise</code></td><td>输出内容是否减少空格使其更紧凑一些</td></tr><tr><td><code>minified</code></td><td>是否压缩输出代码</td></tr><tr><td><code>retainLines</code></td><td>尝试在输出代码中使用与源代码中相同的行号</td></tr></tbody></table><p>接着前面的例子，原代码是 <code>const a = 1;</code>，现在我们把 <code>a</code> 变量修改为 <code>b</code>，值 <code>1</code> 修改为 <code>2</code>，然后将 AST 还原生成新的 JS 代码：</p><pre><code class="javascript">const parser = require(&quot;@babel/parser&quot;);const generate = require(&quot;@babel/generator&quot;).defaultconst code = &quot;const a = 1;&quot;;const ast = parser.parse(code, &#123;sourceType: &quot;module&quot;&#125;)ast.program.body[0].declarations[0].id.name = &quot;b&quot;ast.program.body[0].declarations[0].init.value = 2const result = generate(ast, &#123;minified: true&#125;)console.log(result.code)</code></pre><p>最终输出的是 <code>const b=2;</code>，变量名和值都成功更改了，由于加了压缩处理，等号左右两边的空格也没了。</p><p>代码里 <code>&#123;minified: true&#125;</code> 演示了如何添加可选参数，这里表示压缩输出代码，<code>generate</code> 得到的 <code>result</code> 得到的是一个对象，其中的 <code>code</code> 属性才是最终的 JS 代码。</p><p>代码里 <code>ast.program.body[0].declarations[0].id.name</code> 是 a 在 AST 中的位置，<code>ast.program.body[0].declarations[0].init.value</code> 是 1 在 AST 中的位置，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0ffbf3d9a54e2de3c779735aeac0e3e4.png" alt="08"></p><h3 id="babel-traverse"><a href="#babel-traverse" class="headerlink" title="@babel/traverse"></a>@babel/traverse</h3><p>当代码多了，我们不可能像前面那样挨个定位并修改，对于相同类型的节点，我们可以直接遍历所有节点来进行修改，这里就用到了 <code>@babel/traverse</code>，它通常和 <code>visitor</code> 一起使用，<code>visitor</code> 是一个对象，这个名字是可以随意取的，<code>visitor</code> 里可以定义一些方法来过滤节点，这里还是用一个例子来演示：</p><pre><code class="javascript">const parser = require(&quot;@babel/parser&quot;);const generate = require(&quot;@babel/generator&quot;).defaultconst traverse = require(&quot;@babel/traverse&quot;).defaultconst code = `const a = 1500;const b = 60;const c = &quot;hi&quot;;const d = 787;const e = &quot;1244&quot;;`const ast = parser.parse(code)const visitor = &#123;    NumericLiteral(path)&#123;        path.node.value = (path.node.value + 100) * 2    &#125;,    StringLiteral(path)&#123;        path.node.value = &quot;I Love JavaScript!&quot;    &#125;&#125;traverse(ast, visitor)const result = generate(ast)console.log(result.code)</code></pre><p>这里的原始代码定义了 abcde 五个变量，其值有数字也有字符串，我们在 AST 中可以看到对应的类型为 <code>NumericLiteral</code> 和 <code>StringLiteral</code>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b0a932b29fef0ad7a6f20dbc88f3ec46.png" alt="09"></p><p>然后我们声明了一个 <code>visitor</code> 对象，然后定义对应类型的处理方法，<code>traverse</code> 接收两个参数，第一个是 AST 对象，第二个是 <code>visitor</code>，当 <code>traverse</code> 遍历所有节点，遇到节点类型为 <code>NumericLiteral</code> 和 <code>StringLiteral</code> 时，就会调用 <code>visitor</code> 中对应的处理方法，<code>visitor</code> 中的方法会接收一个当前节点的 <code>path</code> 对象，该对象的类型是 <code>NodePath</code>，该对象有非常多的属性，以下介绍几种最常用的：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>toString()</code></td><td>当前路径的源码</td></tr><tr><td><code>node</code></td><td>当前路径的节点</td></tr><tr><td><code>parent</code></td><td>当前路径的父级节点</td></tr><tr><td><code>parentPath</code></td><td>当前路径的父级路径</td></tr><tr><td><code>type</code></td><td>当前路径的类型</td></tr></tbody></table><p>PS：<code>path</code> 对象除了有很多属性以外，还有很多方法，比如替换节点、删除节点、插入节点、寻找父级节点、获取同级节点、添加注释、判断节点类型等，可在需要时查询相关文档或查看源码，后续介绍 <code>@babel/types</code> 部分将会举部分例子来演示，以后的实战文章中也会有相关实例，篇幅有限本文不再细说。</p><p>因此在上面的代码中，<code>path.node.value</code> 就拿到了变量的值，然后我们就可以进一步对其进行修改了。以上代码运行后，所有数字都会加上100后再乘以2，所有字符串都会被替换成 <code>I Love JavaScript!</code>，结果如下：</p><pre><code class="javascript">const a = 3200;const b = 320;const c = &quot;I Love JavaScript!&quot;;const d = 1774;const e = &quot;I Love JavaScript!&quot;;</code></pre><p>如果多个类型的节点，处理的方式都一样，那么还可以使用 <code>|</code> 将所有节点连接成字符串，将同一个方法应用到所有节点：</p><pre><code class="javascript">const visitor = &#123;    &quot;NumericLiteral|StringLiteral&quot;(path) &#123;        path.node.value = &quot;I Love JavaScript!&quot;    &#125;&#125;</code></pre><p><code>visitor</code> 对象有多种写法，以下几种写法的效果都是一样的：</p><pre><code class="javascript">const visitor = &#123;    NumericLiteral(path)&#123;        path.node.value = (path.node.value + 100) * 2    &#125;,    StringLiteral(path)&#123;        path.node.value = &quot;I Love JavaScript!&quot;    &#125;&#125;</code></pre><pre><code class="javascript">const visitor = &#123;    NumericLiteral: function (path)&#123;        path.node.value = (path.node.value + 100) * 2    &#125;,    StringLiteral: function (path)&#123;        path.node.value = &quot;I Love JavaScript!&quot;    &#125;&#125;</code></pre><pre><code class="javascript">const visitor = &#123;    NumericLiteral: &#123;        enter(path) &#123;            path.node.value = (path.node.value + 100) * 2        &#125;    &#125;,    StringLiteral: &#123;        enter(path) &#123;            path.node.value = &quot;I Love JavaScript!&quot;        &#125;    &#125;&#125;</code></pre><pre><code class="javascript">const visitor = &#123;    enter(path) &#123;        if (path.node.type === &quot;NumericLiteral&quot;) &#123;            path.node.value = (path.node.value + 100) * 2        &#125;        if (path.node.type === &quot;StringLiteral&quot;) &#123;            path.node.value = &quot;I Love JavaScript!&quot;        &#125;    &#125;&#125;</code></pre><p>以上几种写法中有用到了 <code>enter</code> 方法，在节点的遍历过程中，进入节点（enter）与退出（exit）节点都会访问一次节点，<code>traverse</code> 默认在进入节点时进行节点的处理，如果要在退出节点时处理，那么在 <code>visitor</code> 中就必须声明 <code>exit</code> 方法。</p><h3 id="babel-types"><a href="#babel-types" class="headerlink" title="@babel/types"></a>@babel/types</h3><p><code>@babel/types</code> 主要用于构建新的 AST 节点，前面的示例代码为 <code>const a = 1;</code>，如果想要增加内容，比如变成 <code>const a = 1; const b = a * 5 + 1;</code>，就可以通过 <code>@babel/types</code> 来实现。</p><p>首先观察一下 AST 语法树，原语句只有一个 <code>VariableDeclaration</code> 节点，现在增加了一个：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7319ba7290bf4d5c94d86c3c0d89e288.png" alt="10"></p><p>那么我们的思路就是在遍历节点时，遍历到 <code>VariableDeclaration</code> 节点，就在其后面增加一个 <code>VariableDeclaration</code> 节点，生成  <code>VariableDeclaration</code> 节点，可以使用 <code>types.variableDeclaration()</code> 方法，在 types 中各种方法名称和我们在 AST 中看到的是一样的，只不过首字母是小写的，所以我们不需要知道所有方法的情况下，也能大致推断其方法名，只知道这个方法还不行，还得知道传入的参数是什么，可以查文档，不过这里推荐直接看源码，非常清晰明了，以 Pycharm 为例，按住 Ctrl 键，再点击方法名，就进到源码里了：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/59b5979bae2fa54c199c8040f2442d04.png" alt="11"></p><pre><code class="javascript">function variableDeclaration(kind: &quot;var&quot; | &quot;let&quot; | &quot;const&quot;, declarations: Array&lt;BabelNodeVariableDeclarator&gt;)</code></pre><p>可以看到需要 <code>kind</code> 和 <code>declarations</code> 两个参数，其中 <code>declarations</code> 是 <code>VariableDeclarator</code> 类型的节点组成的列表，所以我们可以先写出以下 <code>visitor</code> 部分的代码，其中 <code>path.insertAfter()</code> 是在该节点之后插入新节点的意思：</p><pre><code class="javascript">const visitor = &#123;    VariableDeclaration(path) &#123;        let declaration = types.variableDeclaration(&quot;const&quot;, [declarator])        path.insertAfter(declaration)    &#125;&#125;</code></pre><p>接下来我们还需要进一步定义 <code>declarator</code>，也就是 <code>VariableDeclarator</code> 类型的节点，查询其源码如下：</p><pre><code class="javascript">function variableDeclarator(id: BabelNodeLVal, init?: BabelNodeExpression)</code></pre><p>观察 AST，id 为 <code>Identifier</code> 对象，init 为 <code>BinaryExpression</code> 对象，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/050533c545ec5244818054a2e2572cc4.png" alt="12"></p><p>先来处理 id，可以使用 <code>types.identifier()</code> 方法来生成，其源码为 <code>function identifier(name: string)</code>，name 在这里就是 b 了，此时 <code>visitor</code> 代码就可以这么写：</p><pre><code class="javascript">const visitor = &#123;    VariableDeclaration(path) &#123;        let declarator = types.variableDeclarator(types.identifier(&quot;b&quot;), init)        let declaration = types.variableDeclaration(&quot;const&quot;, [declarator])        path.insertAfter(declaration)    &#125;&#125;</code></pre><p>然后再来看 init 该如何定义，首先仍然是看 AST 结构：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a927d6abed41d43251e3c3c2a432e46f.png" alt="13"></p><p>init 为 <code>BinaryExpression</code> 对象，left 左边是 <code>BinaryExpression</code>，right 右边是 <code>NumericLiteral</code>，可以用 <code>types.binaryExpression()</code> 方法来生成 init，其源码如下：</p><pre><code class="javascript">function binaryExpression(    operator: &quot;+&quot; | &quot;-&quot; | &quot;/&quot; | &quot;%&quot; | &quot;*&quot; | &quot;**&quot; | &quot;&amp;&quot; | &quot;|&quot; | &quot;&gt;&gt;&quot; | &quot;&gt;&gt;&gt;&quot; | &quot;&lt;&lt;&quot; | &quot;^&quot; | &quot;==&quot; | &quot;===&quot; | &quot;!=&quot; | &quot;!==&quot; | &quot;in&quot; | &quot;instanceof&quot; | &quot;&gt;&quot; | &quot;&lt;&quot; | &quot;&gt;=&quot; | &quot;&lt;=&quot;,    left: BabelNodeExpression | BabelNodePrivateName,     right: BabelNodeExpression)</code></pre><p>此时 <code>visitor</code> 代码就可以这么写：</p><pre><code class="javascript">const visitor = &#123;    VariableDeclaration(path) &#123;        let init = types.binaryExpression(&quot;+&quot;, left, right)        let declarator = types.variableDeclarator(types.identifier(&quot;b&quot;), init)        let declaration = types.variableDeclaration(&quot;const&quot;, [declarator])        path.insertAfter(declaration)    &#125;&#125;</code></pre><p>然后继续构造 left 和 right，和前面的方法一样，观察 AST 语法树，查询对应方法应该传入的参数，层层嵌套，直到把所有的节点都构造完毕，最终的 <code>visitor</code> 代码应该是这样的：</p><pre><code class="javascript">const visitor = &#123;    VariableDeclaration(path) &#123;        let left = types.binaryExpression(&quot;*&quot;, types.identifier(&quot;a&quot;), types.numericLiteral(5))        let right = types.numericLiteral(1)        let init = types.binaryExpression(&quot;+&quot;, left, right)        let declarator = types.variableDeclarator(types.identifier(&quot;b&quot;), init)        let declaration = types.variableDeclaration(&quot;const&quot;, [declarator])        path.insertAfter(declaration)        path.stop()    &#125;&#125;</code></pre><p>注意：<code>path.insertAfter()</code> 插入节点语句后面加了一句 <code>path.stop()</code>，表示插入完成后立即停止遍历当前节点和后续的子节点，添加的新节点也是 <code>VariableDeclaration</code>，如果不加停止语句的话，就会无限循环插入下去。</p><p>插入新节点后，再转换成 JavaScript 代码，就可以看到多了一行新代码，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/79269e1d54071214b2438eed3bf58d15.png" alt="14"></p><h2 id="常见混淆还原"><a href="#常见混淆还原" class="headerlink" title="常见混淆还原"></a>常见混淆还原</h2><p>了解了 AST 和 babel 后，就可以对 JavaScript 混淆代码进行还原了，以下是部分样例，带你进一步熟悉 babel 的各种操作。</p><h3 id="字符串还原"><a href="#字符串还原" class="headerlink" title="字符串还原"></a>字符串还原</h3><p>文章开头的图中举了个例子，正常字符被换成了 Unicode 编码：</p><pre><code class="javascript">console[&#39;\u006c\u006f\u0067&#39;](&#39;\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u006f\u0072\u006c\u0064\u0021&#39;)</code></pre><p>观察 AST 结构：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/59b4fc53c0c3aa2a0873a76a5d88c175.png" alt="15"></p><p>我们发现 Unicode 编码对应的是 <code>raw</code>，而 <code>rawValue</code> 和 <code>value</code> 都是正常的，所以我们可以将 <code>raw</code> 替换成 <code>rawValue</code> 或 <code>value</code> 即可，需要注意的是引号的问题，本来是 <code>console[&quot;log&quot;]</code>，你还原后变成了 <code>console[log]</code>，自然会报错的，除了替换值以外，这里直接删除 extra 节点，或者删除 raw 值也是可以的，所以以下几种写法都可以还原代码：</p><pre><code class="javascript">const parser = require(&quot;@babel/parser&quot;);const generate = require(&quot;@babel/generator&quot;).defaultconst traverse = require(&quot;@babel/traverse&quot;).defaultconst code = `console[&#39;\u006c\u006f\u0067&#39;](&#39;\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u006f\u0072\u006c\u0064\u0021&#39;)`const ast = parser.parse(code)const visitor = &#123;    StringLiteral(path) &#123;        // 以下方法均可        // path.node.extra.raw = path.node.rawValue        // path.node.extra.raw = &#39;&quot;&#39; + path.node.value + &#39;&quot;&#39;        // delete path.node.extra        delete path.node.extra.raw    &#125;&#125;traverse(ast, visitor)const result = generate(ast)console.log(result.code)</code></pre><p>还原结果：</p><pre><code class="javascript">console[&quot;log&quot;](&quot;Hello world!&quot;);</code></pre><h3 id="表达式还原"><a href="#表达式还原" class="headerlink" title="表达式还原"></a>表达式还原</h3><p>之前写过 <a href="https://itrhx.blog.csdn.net/article/details/122057377">JSFuck 混淆的还原</a>，其中有介绍 <code>![]</code> 可表示 false，<code>!![]</code> 或者 <code>!+[]</code> 可表示 true，在一些混淆代码中，经常有这些操作，把简单的表达式复杂化，往往需要执行一下语句，才能得到真正的结果，示例代码如下：</p><pre><code class="javascript">const a = !![]+!![]+!![];const b = Math.floor(12.34 * 2.12)const c = 10 &gt;&gt; 3 &lt;&lt; 1const d = String(21.3 + 14 * 1.32)const e = parseInt(&quot;1.893&quot; + &quot;45.9088&quot;)const f = parseFloat(&quot;23.2334&quot; + &quot;21.89112&quot;)const g = 20 &lt; 18 ? &#39;未成年&#39; : &#39;成年&#39;</code></pre><p>想要执行语句，我们需要了解 <code>path.evaluate()</code> 方法，该方法会对 path 对象进行执行操作，自动计算出结果，返回一个对象，其中的 <code>confident</code> 属性表示置信度，<code>value</code> 表示计算结果，使用 <code>types.valueToNode()</code> 方法创建节点，使用 <code>path.replaceInline()</code> 方法将节点替换成计算结果生成的新节点，替换方法有一下几种：</p><ul><li><code>replaceWith</code>：用一个节点替换另一个节点；</li><li><code>replaceWithMultiple</code>：用多个节点替换另一个节点；</li><li><code>replaceWithSourceString</code>：将传入的源码字符串解析成对应 Node 后再替换，性能较差，不建议使用；</li><li><code>replaceInline</code>：用一个或多个节点替换另一个节点，相当于同时有了前两个函数的功能。</li></ul><p>对应的 AST 处理代码如下：</p><pre><code class="javascript">const parser = require(&quot;@babel/parser&quot;);const generate = require(&quot;@babel/generator&quot;).defaultconst traverse = require(&quot;@babel/traverse&quot;).defaultconst types = require(&quot;@babel/types&quot;)const code = `const a = !![]+!![]+!![];const b = Math.floor(12.34 * 2.12)const c = 10 &gt;&gt; 3 &lt;&lt; 1const d = String(21.3 + 14 * 1.32)const e = parseInt(&quot;1.893&quot; + &quot;45.9088&quot;)const f = parseFloat(&quot;23.2334&quot; + &quot;21.89112&quot;)const g = 20 &lt; 18 ? &#39;未成年&#39; : &#39;成年&#39;`const ast = parser.parse(code)const visitor = &#123;    &quot;BinaryExpression|CallExpression|ConditionalExpression&quot;(path) &#123;        const &#123;confident, value&#125; = path.evaluate()        if (confident)&#123;            path.replaceInline(types.valueToNode(value))        &#125;    &#125;&#125;traverse(ast, visitor)const result = generate(ast)console.log(result.code)</code></pre><p>最终结果：</p><pre><code class="javascript">const a = 3;const b = 26;const c = 2;const d = &quot;39.78&quot;;const e = parseInt(&quot;1.89345.9088&quot;);const f = parseFloat(&quot;23.233421.89112&quot;);const g = &quot;\u6210\u5E74&quot;;</code></pre><h3 id="删除未使用变量"><a href="#删除未使用变量" class="headerlink" title="删除未使用变量"></a>删除未使用变量</h3><p>有时候代码里会有一些并没有使用到的多余变量，删除这些多余变量有助于更加高效的分析代码，示例代码如下：</p><pre><code class="javascript">const a = 1;const b = a * 2;const c = 2;const d = b + 1;const e = 3;console.log(d)</code></pre><p>删除多余变量，首先要了解 <code>NodePath</code> 中的 <code>scope</code>，<code>scope</code> 的作用主要是查找标识符的作用域、获取并修改标识符的所有引用等，删除未使用变量主要用到了 <code>scope.getBinding()</code> 方法，传入的值是当前节点能够引用到的标识符名称，返回的关键属性有以下几个：</p><ul><li><code>identifier</code>：标识符的 Node 对象；</li><li><code>path</code>：标识符的 NodePath 对象；</li><li><code>constant</code>：标识符是否为常量；</li><li><code>referenced</code>：标识符是否被引用；</li><li><code> references</code>：标识符被引用的次数；</li><li><code>constantViolations</code>：如果标识符被修改，则会存放所有修改该标识符节点的 Path 对象；</li><li><code>referencePaths</code>：如果标识符被引用，则会存放所有引用该标识符节点的 Path 对象。</li></ul><p>所以我们可以通过 <code>constantViolations</code>、<code>referenced</code>、<code>references</code>、<code>referencePaths</code> 多个参数来判断变量是否可以被删除，AST 处理代码如下：</p><pre><code class="javascript">const parser = require(&quot;@babel/parser&quot;);const generate = require(&quot;@babel/generator&quot;).defaultconst traverse = require(&quot;@babel/traverse&quot;).defaultconst code = `const a = 1;const b = a * 2;const c = 2;const d = b + 1;const e = 3;console.log(d)`const ast = parser.parse(code)const visitor = &#123;    VariableDeclarator(path)&#123;        const binding = path.scope.getBinding(path.node.id.name);        // 如标识符被修改过，则不能进行删除动作。        if (!binding || binding.constantViolations.length &gt; 0) &#123;            return;        &#125;        // 未被引用        if (!binding.referenced) &#123;            path.remove();        &#125;        // 被引用次数为0        // if (binding.references === 0) &#123;        //     path.remove();        // &#125;        // 长度为0，变量没有被引用过        // if (binding.referencePaths.length === 0) &#123;        //     path.remove();        // &#125;    &#125;&#125;traverse(ast, visitor)const result = generate(ast)console.log(result.code)</code></pre><p>处理后的代码（未使用的 b、c、e 变量已被删除）：</p><pre><code class="javascript">const a = 1;const b = a * 2;const d = b + 1;console.log(d);</code></pre><h3 id="删除冗余逻辑代码"><a href="#删除冗余逻辑代码" class="headerlink" title="删除冗余逻辑代码"></a>删除冗余逻辑代码</h3><p>有时候为了增加逆向难度，会有很多嵌套的 if-else 语句，大量判断为假的冗余逻辑代码，同样可以利用 AST 将其删除掉，只留下判断为真的，示例代码如下：</p><pre><code class="javascript">const example = function () &#123;    let a;    if (false) &#123;        a = 1;    &#125; else &#123;        if (1) &#123;            a = 2;        &#125;        else &#123;            a = 3;        &#125;    &#125;    return a;&#125;;</code></pre><p>观察 AST，判断条件对应的是 <code>test</code> 节点，if 对应的是 <code>consequent</code> 节点，else 对应的是 <code>alternate</code> 节点，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/11bee2b313c5327859074428625a9348.png" alt="16"></p><p>AST 处理思路以及代码：</p><ol><li>筛选出 <code>BooleanLiteral</code> 和 <code>NumericLiteral</code> 节点，取其对应的值，即 <code>path.node.test.value</code>；</li><li>判断 <code>value</code> 值为真，则将节点替换成 <code>consequent</code> 节点下的内容，即 <code>path.node.consequent.body</code>；</li><li>判断 <code>value</code> 值为假，则替换成 <code>alternate</code> 节点下的内容，即 <code>path.node.alternate.body</code>；</li><li>有的 if 语句可能没有写 else，也就没有 <code>alternate</code>，所以这种情况下判断 <code>value</code> 值为假，则直接移除该节点，即 <code>path.remove()</code></li></ol><pre><code class="javascript">const parser = require(&quot;@babel/parser&quot;);const generate = require(&quot;@babel/generator&quot;).defaultconst traverse = require(&quot;@babel/traverse&quot;).defaultconst types = require(&#39;@babel/types&#39;);const code = `const example = function () &#123;    let a;    if (false) &#123;        a = 1;    &#125; else &#123;        if (1) &#123;            a = 2;        &#125;        else &#123;            a = 3;        &#125;    &#125;    return a;&#125;;`const ast = parser.parse(code)const visitor = &#123;    enter(path) &#123;        if (types.isBooleanLiteral(path.node.test) || types.isNumericLiteral(path.node.test)) &#123;            if (path.node.test.value) &#123;                path.replaceInline(path.node.consequent.body);            &#125; else &#123;                if (path.node.alternate) &#123;                    path.replaceInline(path.node.alternate.body);                &#125; else &#123;                    path.remove()                &#125;            &#125;        &#125;    &#125;&#125;traverse(ast, visitor)const result = generate(ast)console.log(result.code)</code></pre><p>处理结果：</p><pre><code class="javascript">const example = function () &#123;  let a;  a = 2;  return a;&#125;;</code></pre><h3 id="switch-case-反控制流平坦化"><a href="#switch-case-反控制流平坦化" class="headerlink" title="switch-case 反控制流平坦化"></a>switch-case 反控制流平坦化</h3><p>控制流平坦化是混淆当中最常见的，通过 <code>if-else</code> 或者 <code>while-switch-case</code> 语句分解步骤，示例代码：</p><pre><code class="javascript">const _0x34e16a = &#39;3,4,0,5,1,2&#39;[&#39;split&#39;](&#39;,&#39;);let _0x2eff02 = 0x0;while (!![]) &#123;    switch (_0x34e16a[_0x2eff02++]) &#123;        case&#39;0&#39;:            let _0x38cb15 = _0x4588f1 + _0x470e97;            continue;        case&#39;1&#39;:            let _0x1e0e5e = _0x37b9f3[_0x50cee0(0x2e0, 0x2e8, 0x2e1, 0x2e4)];            continue;        case&#39;2&#39;:            let _0x35d732 = [_0x388d4b(-0x134, -0x134, -0x139, -0x138)](_0x38cb15 &gt;&gt; _0x4588f1);            continue;        case&#39;3&#39;:            let _0x4588f1 = 0x1;            continue;        case&#39;4&#39;:            let _0x470e97 = 0x2;            continue;        case&#39;5&#39;:            let _0x37b9f3 = 0x5 || _0x38cb15;            continue;    &#125;    break;&#125;</code></pre><p>AST 还原思路：</p><ol><li>获取控制流原始数组，将 <code>&#39;3,4,0,5,1,2&#39;[&#39;split&#39;](&#39;,&#39;)</code> 之类的语句转化成 <code>[&#39;3&#39;,&#39;4&#39;,&#39;0&#39;,&#39;5&#39;,&#39;1&#39;,&#39;2&#39;]</code> 之类的数组，得到该数组之后，也可以选择把 split 语句对应的节点删除掉，因为最终代码里这条语句就没用了；</li><li>遍历第一步得到的控制流数组，依次取出每个值所对应的 case 节点；</li><li>定义一个数组，储存每个 case 节点 <code>consequent</code> 数组里面的内容，并删除 <code>continue</code> 语句对应的节点；</li><li>遍历完成后，将第三步的数组替换掉整个 while 节点，也就是 <code>WhileStatement</code>。</li></ol><p>不同思路，写法多样，对于如何获取控制流数组，可以有以下思路：</p><ol><li>获取到 <code>While</code> 语句节点，然后使用 <code>path.getAllPrevSiblings()</code> 方法获取其前面的所有兄弟节点，遍历每个兄弟节点，找到与 <code>switch()</code> 里面数组的变量名相同的节点，然后再取节点的值进行后续处理；</li><li>直接取 <code>switch()</code> 里面数组的变量名，然后使用 <code>scope.getBinding()</code> 方法获取到它绑定的节点，然后再取这个节点的值进行后续处理。</li></ol><p>所以 AST 处理代码就有两种写法，方法一：（code.js 即为前面的示例代码，为了方便操作，这里使用 fs 从文件中读取代码）</p><pre><code class="javascript">const parser = require(&quot;@babel/parser&quot;);const generate = require(&quot;@babel/generator&quot;).defaultconst traverse = require(&quot;@babel/traverse&quot;).defaultconst types = require(&quot;@babel/types&quot;)const fs = require(&quot;fs&quot;);const code = fs.readFileSync(&quot;code.js&quot;, &#123;encoding: &quot;utf-8&quot;&#125;);const ast = parser.parse(code)const visitor = &#123;    WhileStatement(path) &#123;        // switch 节点        let switchNode = path.node.body.body[0];        // switch 语句内的控制流数组名，本例中是 _0x34e16a        let arrayName = switchNode.discriminant.object.name;        // 获得所有 while 前面的兄弟节点，本例中获取到的是声明两个变量的节点，即 const _0x34e16a 和 let _0x2eff02        let prevSiblings = path.getAllPrevSiblings();        // 定义缓存控制流数组        let array = []        // forEach 方法遍历所有节点        prevSiblings.forEach(pervNode =&gt; &#123;            let &#123;id, init&#125; = pervNode.node.declarations[0];            // 如果节点 id.name 与 switch 语句内的控制流数组名相同            if (arrayName === id.name) &#123;                // 获取节点整个表达式的参数、分割方法、分隔符                let object = init.callee.object.value;                let property = init.callee.property.value;                let argument = init.arguments[0].value;                // 模拟执行 &#39;3,4,0,5,1,2&#39;[&#39;split&#39;](&#39;,&#39;) 语句                array = object[property](argument)                // 也可以直接取参数进行分割，方法不通用，比如分隔符换成 | 就不行了                // array = init.callee.object.value.split(&#39;,&#39;);            &#125;            // 前面的兄弟节点就可以删除了            pervNode.remove();        &#125;);        // 储存正确顺序的控制流语句        let replace = [];        // 遍历控制流数组，按正确顺序取 case 内容        array.forEach(index =&gt; &#123;                let consequent = switchNode.cases[index].consequent;                // 如果最后一个节点是 continue 语句，则删除 ContinueStatement 节点                if (types.isContinueStatement(consequent[consequent.length - 1])) &#123;                    consequent.pop();                &#125;                // concat 方法拼接多个数组，即正确顺序的 case 内容                replace = replace.concat(consequent);            &#125;        );        // 替换整个 while 节点，两种方法都可以        path.replaceWithMultiple(replace);        // path.replaceInline(replace);    &#125;&#125;traverse(ast, visitor)const result = generate(ast)console.log(result.code)</code></pre><p>方法二：</p><pre><code class="javascript">const parser = require(&quot;@babel/parser&quot;);const generate = require(&quot;@babel/generator&quot;).defaultconst traverse = require(&quot;@babel/traverse&quot;).defaultconst types = require(&quot;@babel/types&quot;)const fs = require(&quot;fs&quot;);const code = fs.readFileSync(&quot;code.js&quot;, &#123;encoding: &quot;utf-8&quot;&#125;);const ast = parser.parse(code)const visitor = &#123;    WhileStatement(path) &#123;        // switch 节点        let switchNode = path.node.body.body[0];        // switch 语句内的控制流数组名，本例中是 _0x34e16a        let arrayName = switchNode.discriminant.object.name;        // 获取控制流数组绑定的节点        let bindingArray = path.scope.getBinding(arrayName);        // 获取节点整个表达式的参数、分割方法、分隔符        let init = bindingArray.path.node.init;        let object = init.callee.object.value;        let property = init.callee.property.value;        let argument = init.arguments[0].value;        // 模拟执行 &#39;3,4,0,5,1,2&#39;[&#39;split&#39;](&#39;,&#39;) 语句        let array = object[property](argument)        // 也可以直接取参数进行分割，方法不通用，比如分隔符换成 | 就不行了        // let array = init.callee.object.value.split(&#39;,&#39;);        // switch 语句内的控制流自增变量名，本例中是 _0x2eff02        let autoIncrementName = switchNode.discriminant.property.argument.name;        // 获取控制流自增变量名绑定的节点        let bindingAutoIncrement = path.scope.getBinding(autoIncrementName);        // 可选择的操作：删除控制流数组绑定的节点、自增变量名绑定的节点        bindingArray.path.remove();        bindingAutoIncrement.path.remove();        // 储存正确顺序的控制流语句        let replace = [];        // 遍历控制流数组，按正确顺序取 case 内容        array.forEach(index =&gt; &#123;                let consequent = switchNode.cases[index].consequent;                // 如果最后一个节点是 continue 语句，则删除 ContinueStatement 节点                if (types.isContinueStatement(consequent[consequent.length - 1])) &#123;                    consequent.pop();                &#125;                // concat 方法拼接多个数组，即正确顺序的 case 内容                replace = replace.concat(consequent);            &#125;        );        // 替换整个 while 节点，两种方法都可以        path.replaceWithMultiple(replace);        // path.replaceInline(replace);    &#125;&#125;traverse(ast, visitor)const result = generate(ast)console.log(result.code)</code></pre><p>以上代码运行后，原来的 <code>switch-case</code> 控制流就被还原了，变成了按顺序一行一行的代码，更加简洁明了：</p><pre><code class="javascript">let _0x4588f1 = 0x1;let _0x470e97 = 0x2;let _0x38cb15 = _0x4588f1 + _0x470e97;let _0x37b9f3 = 0x5 || _0x38cb15;let _0x1e0e5e = _0x37b9f3[_0x50cee0(0x2e0, 0x2e8, 0x2e1, 0x2e4)];let _0x35d732 = [_0x388d4b(-0x134, -0x134, -0x139, -0x138)](_0x38cb15 &gt;&gt; _0x4588f1);</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>本文有参考以下资料，也是比较推荐的在线学习资料：</p><ul><li>Youtube 视频，Babel 入门：<a href="https://www.youtube.com/watch?v=UeVq_U5obnE">https://www.youtube.com/watch?v=UeVq_U5obnE</a></li><li>官方手册 Babel Handbook：<a href="https://github.com/jamiebuilds/babel-handbook">https://github.com/jamiebuilds/babel-handbook</a></li><li>非官方 Babel API 中文文档：<a href="https://evilrecluse.top/Babel-traverse-api-doc/">https://evilrecluse.top/Babel-traverse-api-doc/</a></li></ul><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>Babel 编译器国内的资料其实不是很多，多看源码、同时在线对照可视化的 AST 语法树，耐心一点儿一层一层分析即可，本文中的案例也只是最基本操作，实际遇到一些混淆还得视情况进行修改，比如需要加一些类型判断来限制等，后续会用实战来带领大家进一步熟悉解混淆当中的其他操作。</p>]]></content>
      
      
      <categories>
          
          <category> JS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS 逆向 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS 逆向】网洛者反爬练习平台第七题：JSVMPZL 初体验</title>
      <link href="/article/050/"/>
      <url>/article/050/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><strong>本文章中所有内容仅供学习交流，抓包内容、敏感网址、数据接口均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关，若有侵权，请在公众号联系我立即删除！</strong></p><h2 id="逆向目标"><a href="#逆向目标" class="headerlink" title="逆向目标"></a>逆向目标</h2><ul><li>目标：网洛者反反爬虫练习平台第七题：JSVMPZL 初体验</li><li>链接：<a href="http://spider.wangluozhe.com/challenge/7">http://spider.wangluozhe.com/challenge/7</a></li><li>简介：平台注册需要邀请码，站长在群里，可后台回复交流群加群获取，或者直接加网站底部站长QQ获取。要求采集100页的全部数字，并计算所有数据加和。主要难点在于 vvv 大佬开发的 JS 混淆框架：jsvmpzl</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/adc6eb6d3f2480b306a9e27b85cea3b5.png" alt="01"></p><h2 id="逆向过程"><a href="#逆向过程" class="headerlink" title="逆向过程"></a>逆向过程</h2><p>直接搜索，或者跟栈，可以轻松找到加密入口，打开 F12 有两个反调试，一是无限 debugger，右键 Never pause here 即可，二是定时器，控制台输入 <code>for (let i = 1; i &lt; 99999; i++) window.clearInterval(i);</code> 过掉即可。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5b01302e20f7265f8732b19b0150df6f.png" alt="02"></p><p>跟进 <code>y__()</code>，就可以看到 jsvmpzl 混淆的代码了，如果有做过猿人学平台的题，会发现此混淆和猿人学第 18 题（ <a href="https://match.yuanrenxue.com/match/18">https://match.yuanrenxue.com/match/18</a> ）是一样的，在 <code>y__()</code> 第一行下个断点，观察 <code>__v_()</code> 第一个参数 <code>_</code>，<code>_[2][0]</code> 你会发现有关 MD5 算法的一些特征，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3780acd49c90e60e4877f0b2a688e365.png" alt="03"></p><p>那么我们直接大胆猜测一下，是不是就是某个数据经过 MD5 之后就是 <code>_signature</code> 了呢？再继续调试一下，注意 <code>arguments</code> 的变化：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3a613678a973b5d3f77ab95395a75c02.png" alt="04"></p><p>很明显这个 <code>window.byted_acrawler(window.sign())</code> 应该就是生成 <code>_signature</code> 的语句，这个方法和某字节系的 <code>_signature</code> 生成的方法名称是一样的，直接在控制台输出一下可以拿到值，其中 <code>window.sign()</code> 是取的时间戳：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a1f83868ca67a77c46fe6e1eb9acb290.png" alt="05"></p><p>我们前面猜测是 MD5，直接验证一下，发现并不是的，即便是同一个时间戳，经过 <code>window.byted_acrawler()</code> 后得到的值每次也都不一样：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7c30a65c29a26d5357c6fe6ccbb9fd0d.png" alt="06"></p><h3 id="Hook-关键方法"><a href="#Hook-关键方法" class="headerlink" title="Hook 关键方法"></a>Hook 关键方法</h3><p>经过前面的分析，既然标准的 MD5 不行，那有没有可能是魔改的 MD5 呢？首先找个 JavaScript 标准的 MD5 代码看一下，比如：<a href="http://pajhome.org.uk/crypt/md5/md5.html">http://pajhome.org.uk/crypt/md5/md5.html</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/d7aca0b28d6131db38bdf6e1d9e46441.png" alt="07"></p><p>可以注意到，源码里面有很多 <code>md5_ff</code>、<code>md5_gg</code>、<code>md5_hh</code>、<code>md5_ii</code> 的方法，最后一个值都是固定的，那么有没有可能此题就是在标准 MD5 的基础上修改了一些默认值呢？所以我们可以直接 Hook 这些关键方法，在控制台输出传入的值，来一一对比一下，看看默认值是否是一样的，为了方便观察，我们还可以为输出语句加上颜色，Hook 代码如下：</p><pre><code class="javascript">let oldFF = _[2][0][&#39;md5_ff&#39;];let oldGG = _[2][0][&#39;md5_gg&#39;];let oldHH = _[2][0][&#39;md5_hh&#39;];let oldII = _[2][0][&#39;md5_ii&#39;];let color_white_red = &quot;color: white; background: red;&quot;let color_white_grey = &quot;color: white; background: grey;&quot;let color_white_darkcyan = &quot;color: white; background: darkcyan;&quot;let color_white_green = &quot;color: white; background: green;&quot;let color_white_orange = &quot;color: white; background: orange;&quot;_[2][0][&#39;md5_ff&#39;] = function (a, b, c, d, e, f, g) &#123;    debugger;    let result = oldFF(a, b, c, d, e, f, g);    console.log(&quot;%c Function: %c md5_ff %c Result: %c %s %c Params: %c %s, %s, %s, %s, %s, %s, %s &quot;, color_white_red, color_white_grey, color_white_red, color_white_grey, result, color_white_red, color_white_grey, a, b, c, d, e, f, g)    return result;&#125;;_[2][0][&#39;md5_gg&#39;] = function (a, b, c, d, e, f, g) &#123;    debugger;    let result = oldGG(a, b, c, d, e, f, g);    console.log(&quot;%c Function: %c md5_gg %c Result: %c %s %c Params: %c %s, %s, %s, %s, %s, %s, %s &quot;, color_white_red, color_white_darkcyan, color_white_red, color_white_darkcyan, result, color_white_red, color_white_darkcyan, a, b, c, d, e, f, g)    return result;&#125;;_[2][0][&#39;md5_hh&#39;] = function (a, b, c, d, e, f, g) &#123;    debugger;    let result = oldHH(a, b, c, d, e, f, g);    console.log(&quot;%c Function: %c md5_hh %c Result: %c %s %c Params: %c %s, %s, %s, %s, %s, %s, %s &quot;, color_white_red, color_white_green, color_white_red, color_white_green, result, color_white_red, color_white_green, a, b, c, d, e, f, g)    return result;&#125;;_[2][0][&#39;md5_ii&#39;] = function (a, b, c, d, e, f, g) &#123;    debugger;    let result = oldII(a, b, c, d, e, f, g);    console.log(&quot;%c Function: %c md5_ii %c Result: %c %s %c Params: %c %s, %s, %s, %s, %s, %s, %s &quot;, color_white_red, color_white_orange, color_white_red, color_white_orange, result, color_white_red, color_white_orange, a, b, c, d, e, f, g)    return result;&#125;;</code></pre><p>Hook 代码写得比较死板，熟悉 JS 的大佬可自己优化一下，注意注入代码的时机，清除定时器后，断点运行到 <code>y__()</code> 方法后再注入，然后取消断点，一直下一步，就可以在控制台看到输出的参数了，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/dc4426ed825d5f3fe1516910035de8ce.png" alt="08"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/f73a668ccd538dedf6759c122269c9da.png" alt="09"></p><p>与默认参数进行对比，可以发现 <code>md5_hh()</code> 里有两个默认参数被修改了：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e1b033d6086f175337c36b7c1d04e208.png" alt="10"></p><p>默认的 <code>-722521979</code> 改成了 <code>-722521939</code>、<code>76029189</code> 改成了 <code>76029185</code>，本地代码修改一下即可：</p><pre><code class="javascript">/* ==================================# @Time    : 2021-12-23# @Author  : ITBOB# @FileName: challenge_7.js# @Software: PyCharm# ================================== *//* * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message * Digest Algorithm, as defined in RFC 1321. * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet * Distributed under the BSD License * See http://pajhome.org.uk/crypt/md5 for more info. *//* * Configurable variables. You may need to tweak these to be compatible with * the server-side, but the defaults work in most cases. */var hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */var b64pad  = &quot;&quot;;  /* base-64 pad character. &quot;=&quot; for strict RFC compliance   *//* * These are the functions you&#39;ll usually want to call * They take string arguments and return either hex or base-64 encoded strings */function hex_md5(s)    &#123; return rstr2hex(rstr_md5(str2rstr_utf8(s))); &#125;function b64_md5(s)    &#123; return rstr2b64(rstr_md5(str2rstr_utf8(s))); &#125;function any_md5(s, e) &#123; return rstr2any(rstr_md5(str2rstr_utf8(s)), e); &#125;function hex_hmac_md5(k, d)  &#123; return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); &#125;function b64_hmac_md5(k, d)  &#123; return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); &#125;function any_hmac_md5(k, d, e)  &#123; return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); &#125;/* * Perform a simple self-test to see if the VM is working */function md5_vm_test()&#123;  return hex_md5(&quot;abc&quot;).toLowerCase() == &quot;900150983cd24fb0d6963f7d28e17f72&quot;;&#125;/* * Calculate the MD5 of a raw string */function rstr_md5(s)&#123;  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));&#125;/* * Calculate the HMAC-MD5, of a key and some data (raw strings) */function rstr_hmac_md5(key, data)&#123;  var bkey = rstr2binl(key);  if(bkey.length &gt; 16) bkey = binl_md5(bkey, key.length * 8);  var ipad = Array(16), opad = Array(16);  for(var i = 0; i &lt; 16; i++)  &#123;    ipad[i] = bkey[i] ^ 0x36363636;    opad[i] = bkey[i] ^ 0x5C5C5C5C;  &#125;  var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);  return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));&#125;/* * Convert a raw string to a hex string */function rstr2hex(input)&#123;  try &#123; hexcase &#125; catch(e) &#123; hexcase=0; &#125;  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;  var output = &quot;&quot;;  var x;  for(var i = 0; i &lt; input.length; i++)  &#123;    x = input.charCodeAt(i);    output += hex_tab.charAt((x &gt;&gt;&gt; 4) &amp; 0x0F)           +  hex_tab.charAt( x        &amp; 0x0F);  &#125;  return output;&#125;/* * Convert a raw string to a base-64 string */function rstr2b64(input)&#123;  try &#123; b64pad &#125; catch(e) &#123; b64pad=&#39;&#39;; &#125;  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;  var output = &quot;&quot;;  var len = input.length;  for(var i = 0; i &lt; len; i += 3)  &#123;    var triplet = (input.charCodeAt(i) &lt;&lt; 16)                | (i + 1 &lt; len ? input.charCodeAt(i+1) &lt;&lt; 8 : 0)                | (i + 2 &lt; len ? input.charCodeAt(i+2)      : 0);    for(var j = 0; j &lt; 4; j++)    &#123;      if(i * 8 + j * 6 &gt; input.length * 8) output += b64pad;      else output += tab.charAt((triplet &gt;&gt;&gt; 6*(3-j)) &amp; 0x3F);    &#125;  &#125;  return output;&#125;/* * Convert a raw string to an arbitrary string encoding */function rstr2any(input, encoding)&#123;  var divisor = encoding.length;  var i, j, q, x, quotient;  /* Convert to an array of 16-bit big-endian values, forming the dividend */  var dividend = Array(Math.ceil(input.length / 2));  for(i = 0; i &lt; dividend.length; i++)  &#123;    dividend[i] = (input.charCodeAt(i * 2) &lt;&lt; 8) | input.charCodeAt(i * 2 + 1);  &#125;  /*   * Repeatedly perform a long division. The binary array forms the dividend,   * the length of the encoding is the divisor. Once computed, the quotient   * forms the dividend for the next step. All remainders are stored for later   * use.   */  var full_length = Math.ceil(input.length * 8 /                                    (Math.log(encoding.length) / Math.log(2)));  var remainders = Array(full_length);  for(j = 0; j &lt; full_length; j++)  &#123;    quotient = Array();    x = 0;    for(i = 0; i &lt; dividend.length; i++)    &#123;      x = (x &lt;&lt; 16) + dividend[i];      q = Math.floor(x / divisor);      x -= q * divisor;      if(quotient.length &gt; 0 || q &gt; 0)        quotient[quotient.length] = q;    &#125;    remainders[j] = x;    dividend = quotient;  &#125;  /* Convert the remainders to the output string */  var output = &quot;&quot;;  for(i = remainders.length - 1; i &gt;= 0; i--)    output += encoding.charAt(remainders[i]);  return output;&#125;/* * Encode a string as utf-8. * For efficiency, this assumes the input is valid utf-16. */function str2rstr_utf8(input)&#123;  var output = &quot;&quot;;  var i = -1;  var x, y;  while(++i &lt; input.length)  &#123;    /* Decode utf-16 surrogate pairs */    x = input.charCodeAt(i);    y = i + 1 &lt; input.length ? input.charCodeAt(i + 1) : 0;    if(0xD800 &lt;= x &amp;&amp; x &lt;= 0xDBFF &amp;&amp; 0xDC00 &lt;= y &amp;&amp; y &lt;= 0xDFFF)    &#123;      x = 0x10000 + ((x &amp; 0x03FF) &lt;&lt; 10) + (y &amp; 0x03FF);      i++;    &#125;    /* Encode output as utf-8 */    if(x &lt;= 0x7F)      output += String.fromCharCode(x);    else if(x &lt;= 0x7FF)      output += String.fromCharCode(0xC0 | ((x &gt;&gt;&gt; 6 ) &amp; 0x1F),                                    0x80 | ( x         &amp; 0x3F));    else if(x &lt;= 0xFFFF)      output += String.fromCharCode(0xE0 | ((x &gt;&gt;&gt; 12) &amp; 0x0F),                                    0x80 | ((x &gt;&gt;&gt; 6 ) &amp; 0x3F),                                    0x80 | ( x         &amp; 0x3F));    else if(x &lt;= 0x1FFFFF)      output += String.fromCharCode(0xF0 | ((x &gt;&gt;&gt; 18) &amp; 0x07),                                    0x80 | ((x &gt;&gt;&gt; 12) &amp; 0x3F),                                    0x80 | ((x &gt;&gt;&gt; 6 ) &amp; 0x3F),                                    0x80 | ( x         &amp; 0x3F));  &#125;  return output;&#125;/* * Encode a string as utf-16 */function str2rstr_utf16le(input)&#123;  var output = &quot;&quot;;  for(var i = 0; i &lt; input.length; i++)    output += String.fromCharCode( input.charCodeAt(i)        &amp; 0xFF,                                  (input.charCodeAt(i) &gt;&gt;&gt; 8) &amp; 0xFF);  return output;&#125;function str2rstr_utf16be(input)&#123;  var output = &quot;&quot;;  for(var i = 0; i &lt; input.length; i++)    output += String.fromCharCode((input.charCodeAt(i) &gt;&gt;&gt; 8) &amp; 0xFF,                                   input.charCodeAt(i)        &amp; 0xFF);  return output;&#125;/* * Convert a raw string to an array of little-endian words * Characters &gt;255 have their high-byte silently ignored. */function rstr2binl(input)&#123;  var output = Array(input.length &gt;&gt; 2);  for(var i = 0; i &lt; output.length; i++)    output[i] = 0;  for(var i = 0; i &lt; input.length * 8; i += 8)    output[i&gt;&gt;5] |= (input.charCodeAt(i / 8) &amp; 0xFF) &lt;&lt; (i%32);  return output;&#125;/* * Convert an array of little-endian words to a string */function binl2rstr(input)&#123;  var output = &quot;&quot;;  for(var i = 0; i &lt; input.length * 32; i += 8)    output += String.fromCharCode((input[i&gt;&gt;5] &gt;&gt;&gt; (i % 32)) &amp; 0xFF);  return output;&#125;/* * Calculate the MD5 of an array of little-endian words, and a bit length. */function binl_md5(x, len)&#123;  /* append padding */  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; ((len) % 32);  x[(((len + 64) &gt;&gt;&gt; 9) &lt;&lt; 4) + 14] = len;  var a =  1732584193;  var b = -271733879;  var c = -1732584194;  var d =  271733878;  for(var i = 0; i &lt; x.length; i += 16)  &#123;    var olda = a;    var oldb = b;    var oldc = c;    var oldd = d;    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);    // 注释掉的是默认值    // c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521939);    // b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029185);    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);    a = safe_add(a, olda);    b = safe_add(b, oldb);    c = safe_add(c, oldc);    d = safe_add(d, oldd);  &#125;  return Array(a, b, c, d);&#125;/* * These functions implement the four basic operations the algorithm uses. */function md5_cmn(q, a, b, x, s, t)&#123;  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);&#125;function md5_ff(a, b, c, d, x, s, t)&#123;  return md5_cmn((b &amp; c) | ((~b) &amp; d), a, b, x, s, t);&#125;function md5_gg(a, b, c, d, x, s, t)&#123;  return md5_cmn((b &amp; d) | (c &amp; (~d)), a, b, x, s, t);&#125;function md5_hh(a, b, c, d, x, s, t)&#123;  return md5_cmn(b ^ c ^ d, a, b, x, s, t);&#125;function md5_ii(a, b, c, d, x, s, t)&#123;  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);&#125;/* * Add integers, wrapping at 2^32. This uses 16-bit operations internally * to work around bugs in some JS interpreters. */function safe_add(x, y)&#123;  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);&#125;/* * Bitwise rotate a 32-bit number to the left. */function bit_rol(num, cnt)&#123;  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));&#125;function getSignature() &#123;    return hex_md5(Date.parse(Date()).toString())&#125;console.log(getSignature())</code></pre><p>Python 调用代码：</p><pre><code class="python"># ==================================# --*-- coding: utf-8 --*--# @Time    : 2021-12-23# @Author  : ITBOB# @FileName: challenge_7.py# @Software: PyCharm# ==================================import timeimport execjsimport requestschallenge_api = &quot;http://spider.wangluozhe.com/challenge/api/7&quot;headers = &#123;    &quot;Cookie&quot;: &quot;Cookie 替换成你的&quot;,    &quot;Host&quot;: &quot;spider.wangluozhe.com&quot;,    &quot;Origin&quot;: &quot;http://spider.wangluozhe.com&quot;,    &quot;Referer&quot;: &quot;http://spider.wangluozhe.com/challenge/7&quot;,    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&quot;,    &quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;&#125;def get_signature():    now = str(int(time.time())) + &quot;000&quot;    with open(&#39;challenge_7.js&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:        wlz_js = execjs.compile(f.read())    # signature = wlz_js.call(&quot;getSignature&quot;)    signature = wlz_js.call(&quot;hex_md5&quot;, now)    print(&quot;signature: &quot;, signature)    return signaturedef main():    result = 0    for page in range(1, 101):        data = &#123;            &quot;page&quot;: page,            &quot;count&quot;: 10,            &quot;_signature&quot;: get_signature()        &#125;        response = requests.post(url=challenge_api, headers=headers, data=data).json()        print(response)        for d in response[&quot;data&quot;]:            result += d[&quot;value&quot;]    print(&quot;结果为: &quot;, result)if __name__ == &#39;__main__&#39;:    main()</code></pre><p>这里还有一点小细节，如果是 Python 生成时间戳传入 JS 的 <code>hex_md5</code> 方法的话，要保证时间戳的最后三位为0，不然校验通不过，通常的写法是 <code>str(int(time.time() * 1000))</code>，这里要改一下：<code>str(int(time.time())) + &quot;000&quot;</code>，不用 Python 的话，也可以在 JS 里写个方法直接返回 <code>hex_md5(Date.parse(Date()).toString())</code> 也行。</p><p><strong>还有一个问题就是如果你找的 MD5 代码不规范，准确来说是和题目使用的 MD5 代码不太一样的话，有可能本地要改的地方就不止这两处了，所以尽量找一个方法名都一样的JS，能省不少事儿。</strong></p><h3 id="日志断点-插桩调试"><a href="#日志断点-插桩调试" class="headerlink" title="日志断点 / 插桩调试"></a>日志断点 / 插桩调试</h3><p>除了 Hook 以外，我们还可以通过插桩调试的方式，将整个生成 <code>_signature</code> 的流程、涉及到的参数、生成的值，都通过日志的形式打印出来，逆向分析其逻辑。PS：插桩，即日志断点，鼠标右键选择 <code>Add logpoint</code> 即可添加一个日志断点，相当于 <code>console.log()</code>，此功能是 Chrome 73 版本新增的。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/809d43c9561951a392f9a395f2edb284.png" alt="11"></p><ul><li><strong>Add breakpoint</strong>：添加普通断点；</li><li><strong>Add conditional breakpoint</strong>：添加条件断点，满足条件才断下；</li><li><strong>Add logpoint</strong>：添加日志断点；</li><li><strong>Never pause here</strong>：永不在此处断下；</li><li><strong>Add script to ignore list</strong>：网站的部分 JS，比如 <code>jquery.min.js</code> 之类的库文件，我们单步调试的时候并不想进入到该文件中，那么可以将此类文件右键添加忽略掉。</li></ul><p>关键的日志断点有以下三处：</p><ul><li>第 605 行，<code>arguments</code> 为当前传入函数的参数值；</li><li>第 141 行，<code>___.join(vV_)</code> 为当前调用的方法名称，也会输出方法中的参数名称；</li><li>第 591 行，<code>__V(_, ___(u_), 0, 0, _U__).apply(void 0, y__(v___))</code> 为当前方法执行完毕的结果。</li></ul><p>肯定有人会疑惑，如何知道应该在这三个地方下日志断点呢？答案是只能自己单步、多步调试，找规律、仔细观察，就像交流群里的小小白大佬说的一样，屁股坐烂就行了。当然也不是只有这三个地方能输出对应的信息，有可能其他地方也可以，这就要看你自己调试了。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7824eb659f7e79005c7d06e0a4a8226c.png" alt="12"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/88f582a59787275088ccefd6d2b31040.png" alt="13"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/eacf5f0661f1f37a78b10d0077ceeb83.png" alt="14"></p><p>除了这三个地方的日志断点以外，建议还可以在第 606 行打个断点，这样每次执行一个方法就断下，本地就可以跟着同步调试，挨个对比传入的参数和得到的结果，不至于一下子输出的东西太多，不方便查找。</p><p>第一步，<code>gnature = window.byted_acrawler(window.sign())</code>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5b63ed75da5005cd2cfaf7751e2e21cb.png" alt="15"></p><p>下一步，sign 方法，取时间戳：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3a69124e145ec58b96f9d10b2bfc7116.png" alt="16"></p><p>下一步，调用 <code>hex_md5()</code> 方法：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e5c6bef0f6e7cebb0b63523977364143.png" alt="17"></p><p>从这里就可以开始本地同步调试了，本地 MD5 下断点调试，可以看到得到的值不一样：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/79cfa228e9d358ce3285c07b1e7015f7.png" alt="18"></p><p>下一步，调用 <code>str2binl()</code> 方法，和本地得到的值是一样的：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9100052468ccac22aa4a648964be5e9b.png" alt="19"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/ebf4964df2d57ffd62a499ed74d25ed2.png" alt="20"></p><p>下一步，调用 <code>core_md5()</code> 方法，得到的值和本地就不一样了，这里大致可以确定此方法内部与标准算法有差别了：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/907c0c4e27b8e67a6b1e9424ea48faa7.png" alt="21"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/77f401db641df96442715fc7292c3cd9.png" alt="22"></p><p>下一步，调用 <code>md5_ff()</code> 方法，得到的值是一样的：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/196f75611556bbdfcd3dd9abf0d06732.png" alt="23"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/d88f1342eb678ba930b9e70ab6f1d7ef.png" alt="24"></p><p>以此类推，最终会找到两个不一样的地方，即 <code>md5_hh()</code> 两个默认参数被修改了。</p><p><code>-722521979</code> 被改成了 <code>-722521939</code>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6d6b5d79d7028a73134562e50f537f00.png" alt="25"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c60c5a5e389cdcac6ed85fd19c4b0502.png" alt="26"></p><p><code>76029189</code> 被改成了 <code>76029185</code>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f22f81db4216a5dbe49fc821815b851a.png" alt="27"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/0e115ab6c1095593e66c5367390e1170.png" alt="28"></p><p>最终提交结果，验证成功：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/8806ce0bcee1aa373561097d24caa75f.png" alt="29"></p>]]></content>
      
      
      <categories>
          
          <category> JS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS 逆向 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS 逆向】拉勾网爬虫，traceparent、__lg_stoken__、X-S-HEADER 等参数分析</title>
      <link href="/article/049/"/>
      <url>/article/049/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><strong>本文章中所有内容仅供学习交流，抓包内容、敏感网址、数据接口均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关，若有侵权，请在公众号联系我立即删除！</strong></p><h2 id="逆向目标"><a href="#逆向目标" class="headerlink" title="逆向目标"></a>逆向目标</h2><p>本次的目标是拉勾网职位的爬取，涉及到的一些关键参数如下：</p><ul><li>请求头参数：<code>traceparent</code>、<code>X-K-HEADER</code>、<code>X-S-HEADER</code>、<code>X-SS-REQ-HEADER</code>、<code>x-anit-forge-code</code>、<code>x-anit-forge-token</code></li><li>Cookie 值：<code>user_trace_token</code>、<code>X_HTTP_TOKEN</code>、<code>__lg_stoken__</code></li><li>POST 请求数据加密，返回的加密职位信息解密，AES 算法</li></ul><p>参数比较多，但事实上有些参数固定、或者直接不要，也是可以的，比如 Cookie 的三个值，请求头的 <code>X-K-HEADER</code>、<code>X-SS-REQ-HEADER</code> 等可以固定，<code>x-anit-forge-code</code> 和 <code>x-anit-forge-token</code> 可有可无。尽管如此，本文还是把每个参数的来源都分析了，可根据你实际情况灵活处理。</p><p>另外即便是把所有参数都补齐了，拉勾网对于单个 IP 还有频率限制，抓不了几次就要求登录，可自行搭配代理进行抓取，或者复制账号登录后的 cookies 到代码里，可以解除限制，如果是账号登录后访问，请求头多了两个参数，即 <code>x-anit-forge-code</code> 和 <code>x-anit-forge-token</code>，经过测试这两个参数其实不要也行。</p><h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p>搜索职位，点击翻页，就可以看到一条名为 positionAjax.json 的 Ajax 请求，不难判断这就是返回的职位信息。重点参数已在图中框出来了。</p><p>未登录，正常 IP，正常请求，Header 以及 Cookies：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/70cb2fa995ca86f03f2356999f2e76dc.png" alt="01"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/0072eeb2185eb259f92ba86ffaa87216.png" alt="02"></p><p>异常 IP，登录账号后再请求，Header 以及 Cookies：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/24936f2b0de3cfb9830fe000ce73f942.png" alt="03"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/1f7fadc2fceef7508ac9acf308965a69.png" alt="04"></p><p>请求数据和返回数据都经过了加密：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1253e653b4c3ef62aa5b0a6ea43cc60f.png" alt="05"></p><h2 id="Cookies-参数"><a href="#Cookies-参数" class="headerlink" title="Cookies 参数"></a>Cookies 参数</h2><p>先看 cookies 里的关键参数，主要是 <code>user_trace_token</code>、<code>X_HTTP_TOKEN</code> 和 <code>__lg_stoken__</code>。</p><h3 id="user-trace-token"><a href="#user-trace-token" class="headerlink" title="user_trace_token"></a>user_trace_token</h3><p>通过接口返回的，直接搜索就可以找到，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/51b765b8c4bf512393cfc701254bf1a7.png" alt="06"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/cf51c497bb4c3a66b5dd6a4e6d1fa0af.png" alt="07"></p><p>请求参数，time 是时间戳，a 值随便，没有都可以，不影响，其他值都是定值，获取的关键代码如下：</p><pre><code class="python">def get_user_trace_token() -&gt; str:    # 获取 cookie 中的 user_trace_token    json_url = &quot;https://a.脱敏处理.com/json&quot;    headers = &#123;        &quot;Host&quot;: &quot;a.脱敏处理.com&quot;,        &quot;Referer&quot;: &quot;https://www.脱敏处理.com/&quot;,        &quot;User-Agent&quot;: UA    &#125;    params = &#123;        &quot;lt&quot;: &quot;trackshow&quot;,        &quot;t&quot;: &quot;ad&quot;,        &quot;v&quot;: 0,        &quot;dl&quot;: &quot;https://www.脱敏处理.com/&quot;,        &quot;dr&quot;: &quot;https://www.脱敏处理.com&quot;,        &quot;time&quot;: str(int(time.time() * 1000))    &#125;    response = requests.get(url=json_url, headers=headers, params=params)    user_trace_token = response.cookies.get_dict()[&quot;user_trace_token&quot;]    return user_trace_token</code></pre><h3 id="X-HTTP-TOKEN"><a href="#X-HTTP-TOKEN" class="headerlink" title="X_HTTP_TOKEN"></a>X_HTTP_TOKEN</h3><p>直接搜索没有值，直接上 Hook 大法，小白朋友不清楚的话可以看以前的文章，都有详细教程，这里不再细说。</p><pre><code class="javascript">(function () &#123;    &#39;use strict&#39;;    var cookieTemp = &quot;&quot;;    Object.defineProperty(document, &#39;cookie&#39;, &#123;        set: function (val) &#123;            console.log(&#39;Hook捕获到cookie设置-&gt;&#39;, val);            if (val.indexOf(&#39;X_HTTP_TOKEN&#39;) != -1) &#123;                debugger;            &#125;            cookieTemp = val;            return val;        &#125;,        get: function () &#123;            return cookieTemp;        &#125;    &#125;);&#125;)();</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/bbba2e987582027cc7abd508b3574034.png" alt="08"></p><p>往上跟栈调试，是一个小小的 OB 混淆，<code>_0x32e0d2</code> 就是最后的 <code>X_HTTP_TOKEN</code> 值了，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/54d3c9e468fc4a104eceb6d3e888e241.png" alt="09"></p><p>直接梭哈，才300多行，不必扣了，全部 copy 下来，本地运行，发现会报错 document 未定义，定位到代码位置，下断点调试一下，发现是正则匹配 cookie 中的 <code>user_trace_token</code> 的值，那么我们直接定义一下即可：<code>var document = &#123;&quot;cookie&quot;: cookie&#125;</code>，cookie 值把 <code>user_trace_token</code> 传过来即可。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7a1675d3103c4057fc553339712e9f06.png" alt="10"></p><p>补全 document 后，再次运行，又会报错 window 未定义，再次定位到源码，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0b202a0b9bba762648653c7a519277f7.png" alt="11"></p><p>分析一下，取了 window XMLHttpRequest 对象，向 wafcheck.json 这个接口发送了一个 Ajax GET 请求，然后取了 Response Header 的 Date 值赋值给 <code>_0x309ac8</code>，注意这个 Date 值比正常时间晚了8个小时，然而取 Date 值并没有什么用，因为后面又 new 了一个新 Date 标准时间，赋值给了 <code>_0x150c4d</code>，<code>new Date(_0x309ac8[_0x3551(&#39;0x2d&#39;)](/-/g, &#39;/&#39;))</code> 语句虽然用到了前面的旧 Date，然而实际上是 <code>replace()</code> 替换方法，与旧的 Date 并没有什么关系，然后调用 <code>Date.parse()</code> 方法将新 Date 转换成时间戳赋值给 <code>_0x4e6d5d</code>，所以不需要这么复杂，直接本地把 <code>_0x89ea429</code> 方法修改一下就行了：</p><pre><code class="javascript">// 原方法// function _0x89ea42() &#123;//     var _0x372cc0 = null;//     if (window[_0x3551(&#39;0x26&#39;)]) &#123;//         _0x372cc0 = new window[(_0x3551(&#39;0x26&#39;))]();//     &#125; else &#123;//         _0x372cc0 = new ActiveObject(_0x3551(&#39;0x27&#39;));//     &#125;//     _0x372cc0[_0x3551(&#39;0x28&#39;)](_0x3551(&#39;0x29&#39;), _0x3551(&#39;0x2a&#39;), ![]);//     _0x372cc0[_0x3551(&#39;0x2b&#39;)](null);//     var _0x309ac8 = _0x372cc0[_0x3551(&#39;0x2c&#39;)](&#39;Date&#39;);//     var _0x150c4d = new Date(_0x309ac8[_0x3551(&#39;0x2d&#39;)](/-/g, &#39;/&#39;));//     var _0x4e6d5d = Date[_0x3551(&#39;0x2e&#39;)](_0x150c4d);//     return _0x4e6d5d / 0x3e8;// &#125;// 本地改写function _0x89ea42() &#123;    var _0x150c4d = new Date();    var _0x4e6d5d = Date.parse(_0x150c4d);    return _0x4e6d5d / 0x3e8;&#125;</code></pre><p>本地测试 OK：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/281437e650682cc59489955d88dc7bf5.png" alt="12"></p><h3 id="lg-stoken"><a href="#lg-stoken" class="headerlink" title="lg_stoken"></a><strong>lg_stoken</strong></h3><p><code>__lg_stoken__</code> 这个参数是在点击搜索后才开始生成的，直接搜索同样没值，Hook 一下，往上跟栈，很容易找到生成位置：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/da44eff2c8db5bcb772483440154ca4a.png" alt="13"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/95fc8ff9ba9695f869840d786f33b822.png" alt="14"></p><p>可以看到 d 就是 <code>__lg_stoken__</code> 的值，<code>d = (new g()).a()</code>、<code>g = window.gt</code>，<code>window.gt</code> 实际上是调用了 <code>_0x11db59</code></p><p>跟进混淆的 JS 看一下，就会发现末尾的这段代码是关键，这里用到了 prototype 原型对象，我们直接 <code>window.gt.prototype.a()</code> 或者 <code>(new window.gt).a()</code> 就能获取到 <code>__lg_stoken__</code>，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7b16218279b88d708ef41c717ebf03d4.png" alt="15"></p><p>到这里也许你想下断点去调试一下，看看能不能扣个逻辑出来，但是你会发现刷新之后断不下，因为这个混淆 JS 文件是一直在变化的，之前的断点就不管用了，然后你就可能会想到直接替换掉这个 JS，让文件名固定下来，就可以断点调试了，如果你这样操作的话，重新刷新会发现一直在加载中，打开控制台会发现报错了，造成这样的原因就在于这个混淆 JS 不仅文件名会改变，他的内容也会改变，当然，内容也不仅仅是改变了变量名那么简单，有些值也是动态变化的，比如：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/085f1a05ec9ba2419fe631e412e776ff.png" alt="16"></p><p>这里我们先不管那么多，直接把所有的混淆代码 copy 下来，先在本地调试一下，看看能不能跑通，调试过程中，先后会提示 <code>window is not defined</code>、<code>Cannot read properties of undefined (reading &#39;hostname&#39;)</code>，定位到代码，有个取 <code>window.location.hostname</code> 的操作，本地定义一下就行了：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/fdda6cf866ecb09c5f7f059bd91ad056.png" alt="17"></p><p>再次调试又会报错 <code> Cannot read properties of undefined (reading &#39;substr&#39;)</code>，<code>substr()</code> 方法可在字符串中抽取从指定下标开始的、指定数目的字符，是字符串对象 stringObject 具有的方法，我们定位到代码，发现是 <code>window.location.search</code> 对象调用了 <code>substr()</code> 方法，所以同样的，我们本地也要补齐。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e951e3c429fff1e85e127a810d9e259e.png" alt="18"></p><p>本地补齐参数后，运行结果与网页一致：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3ef0c04fbc7678fc2553830a473d4356.png" alt="19"></p><p>执行结果没问题了，那么还有一个问题，<code>window.location.search</code> 的值就是待加密参数了，是咋来的呢？我们直接搜索，就可以看到是一个接口302跳转的地址，用的时候直接取就行了，这个接口是你搜索内容组成的，搜索不同参数，这个跳转地址也是不一样的：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c686be59dceaf2965fd00383cfe68066.png" alt="20"></p><p>调试成功后，我们随便换一个搜索关键词，将得到的302跳转地址拿到这个 JS 中，加密一下，发现会报错，这说明混淆 JS 传入的参数和 JS 内容应该是相对应的，这里的做法是直接请求拿到这个 JS 文件内容，然后把要补的 window 和获取 <code>__lg_stoken__</code> 的方法加进去，然后直接执行就行了。</p><p>获取 <code>__lg_stoken__</code>  的关键代码如下（<code>original_data</code> 为原始搜索数据）：</p><pre><code class="python">def get_lg_stoken(original_data: dict) -&gt; str:    # 获取 cookie 中的 __lg_stoken__    token_url = &quot;https://www.脱敏处理.com/wn/jobs&quot;    token_headers = &#123;        &quot;Host&quot;: &quot;www.脱敏处理.com&quot;,        &quot;Referer&quot;: &quot;https://www.脱敏处理.com/&quot;,        &quot;User-Agent&quot;: UA    &#125;    params = &#123;        &quot;kd&quot;: original_data[&quot;kd&quot;],        &quot;city&quot;: original_data[&quot;city&quot;]    &#125;    token_response = requests.get(url=token_url, params=params, headers=token_headers, cookies=global_cookies, allow_redirects=False)    if token_response.status_code != 302:        raise Exception(&quot;获取跳转链接异常！检查 global_cookies 是否已包含 __lg_stoken__！&quot;)    # 获取 302 跳转的地址    security_check_url = token_response.headers[&quot;Location&quot;]    if &quot;login&quot; in security_check_url:        raise Exception(&quot;IP 被关进小黑屋啦！需要登录！请补全登录后的 Cookie，或者自行添加代理！&quot;)    parse_result = parse.urlparse(security_check_url)    # url 的参数为待加密对象    security_check_params = parse_result.query    # 取 name 参数，为混淆 js 的文件名    security_check_js_name = parse.parse_qs(security_check_params)[&quot;name&quot;][0]    # 发送请求，获取混淆的 js    js_url = &quot;https://www.脱敏处理.com/common-sec/dist/&quot; + security_check_js_name + &quot;.js&quot;    js_headers = &#123;        &quot;Host&quot;: &quot;www.脱敏处理.com&quot;,        &quot;Referer&quot;: security_check_url,        &quot;User-Agent&quot;: UA    &#125;    js_response = requests.get(url=js_url, headers=js_headers, cookies=global_cookies).text    # 补全 js，添加 window 参数和一个方法，用于获取 __lg_stoken__ 的值    lg_js = &quot;&quot;&quot;    window = &#123;        &quot;location&quot;: &#123;            &quot;hostname&quot;: &quot;www.脱敏处理.com&quot;,            &quot;search&quot;: &#39;?%s&#39;        &#125;    &#125;    function getLgStoken()&#123;        return window.gt.prototype.a()    &#125;    &quot;&quot;&quot; % security_check_params + js_response    lg_stoken = execjs.compile(lg_js).call(&quot;getLgStoken&quot;)    return lg_stoken</code></pre><h2 id="请求头参数"><a href="#请求头参数" class="headerlink" title="请求头参数"></a>请求头参数</h2><p>请求头参数比较多，有 <code>traceparent</code>、<code>X-K-HEADER</code>、<code>X-S-HEADER</code>、<code>X-SS-REQ-HEADER</code>、<code>x-anit-forge-code</code>、<code>x-anit-forge-token</code>，其中最后两个 <code>x-anit</code> 开头的参数是登录后才有的，实际测试中，即便是登录了，不加这两个好像也行。不过还是分析一下吧。</p><h3 id="x-anit-forge-code-x-anit-forge-token"><a href="#x-anit-forge-code-x-anit-forge-token" class="headerlink" title="x-anit-forge-code / x-anit-forge-token"></a>x-anit-forge-code / x-anit-forge-token</h3><p>这两个值是首次点击搜索生成的，第一次访问搜索接口，返回的 HTML 里面夹杂了一个 JSON 文件，里面的 <code>submitCode</code> 和 <code>submitToken</code> 就是 <code>x-anit-forge-code</code> 和 <code>x-anit-forge-token</code> 的值，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b058272ab7d86994c7c93e4ef6c521ed.png" alt="21"></p><p>请求这个接口要注意带上登录后的 cookies，有用的只有四个值，正确的 cookies 类似于：</p><pre><code class="python">cookies = &#123;    &quot;login&quot;: &quot;true&quot;,    &quot;gate_login_token&quot;: &quot;54a31e93aa904a6bb9731bxxxxxxxxxxxxxx&quot;,    &quot;_putrc&quot;: &quot;9550E53D830BE8xxxxxxxxxxxxxx&quot;,    &quot;JSESSIONID&quot;: &quot;ABAAAECABIEACCA79BFxxxxxxxxxxxxxx&quot;&#125;</code></pre><p>注意，JSESSIONID 即便不登录也会有，但是登录时应该会携带这个值，进行一个激活操作，如果你请求获取到的 submitCode、submitToken 为空，那么就有可能 JSESSIONID 是无效的，以上所有值都必须登录后复制过来！</p><p>获取 <code> x-anit-forge-code</code>、<code>x-anit-forge-token</code>  的关键代码如下（<code>original_data</code> 为原始搜索数据）：</p><pre><code class="python">def update_x_anit(original_data: dict) -&gt; None:    # 更新 x-anit-forge-code 和 x-anit-forge-token    url = &quot;https://www.脱敏处理.com/wn/jobs&quot;    headers = &#123;        &quot;Host&quot;: &quot;www.脱敏处理.com&quot;,        &quot;Referer&quot;: &quot;https://www.脱敏处理.com/&quot;,        &quot;User-Agent&quot;: UA    &#125;    params = &#123;        &quot;kd&quot;: original_data[&quot;kd&quot;],        &quot;city&quot;: original_data[&quot;city&quot;]    &#125;    response = requests.get(url=url, params=params, headers=headers, cookies=global_cookies)    tree = etree.HTML(response.text)    next_data_json = json.loads(tree.xpath(&quot;//script[@id=&#39;__NEXT_DATA__&#39;]/text()&quot;)[0])    submit_code = next_data_json[&quot;props&quot;][&quot;tokenData&quot;][&quot;submitCode&quot;]    submit_token = next_data_json[&quot;props&quot;][&quot;tokenData&quot;][&quot;submitToken&quot;]    # 注意 JSESSIONID 必须是登录验证后的！    if not submit_code or not submit_token:        raise Exception(&quot;submitCode &amp; submitToken 为空，请检查 JSESSIONID 是否正确！&quot;)    global x_anit    x_anit[&quot;x-anit-forge-code&quot;] = submit_code    x_anit[&quot;x-anit-forge-token&quot;] = submit_token</code></pre><h3 id="traceparent"><a href="#traceparent" class="headerlink" title="traceparent"></a>traceparent</h3><p>同样的 Hook 大法，跟栈：</p><pre><code class="javascript">(function () &#123;    var org = window.XMLHttpRequest.prototype.setRequestHeader;    window.XMLHttpRequest.prototype.setRequestHeader = function (key, value) &#123;        console.log(&#39;Hook 捕获到 %s 设置 -&gt; %s&#39;, key, value);        if (key == &#39;traceparent&#39;) &#123;            debugger;        &#125;        return org.apply(this, arguments);    &#125;;&#125;)();</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/ca4250dc656e4516f61eb4085ca9743e.png" alt="22"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/b38bd3f45b8b107002472e03f13b4ce9.png" alt="23"></p><p>观察上面的代码，三元表达式，<code>t.sampled</code> 为 <code>true</code>，所以 <code>e</code> 值为 <code>01</code>，<code>n</code> 值为 <code>t.id</code>，重点在于 <code>t.traceId</code> 和 <code>t.id</code> 了，跟栈发现很难调，直接搜索关键字，可找到生成的位置：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9aa669c7aac13c6f101f1df1bc01d1df.png" alt="24"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/1c6831862c149d7dec12e01dbf838d86.png" alt="25"></p><p>把 <code>E()</code> 方法扣出来就行了，改写一下即可：</p><pre><code class="javascript">getRandomValues = require(&#39;get-random-values&#39;)function E(t) &#123;    for (var b = [], w = 0; w &lt; 256; ++w)            b[w] = (w + 256).toString(16).substr(1);    var T = new Uint8Array(16);    return function(t) &#123;        for (var e = [], n = 0; n &lt; t.length; n++)            e.push(b[t[n]]);        return e.join(&quot;&quot;)    &#125;(getRandomValues(T)).substr(0, t)&#125;function getTraceparent()&#123;    return &quot;00-&quot; + E() + &quot;-&quot; + E(16) + &quot;-&quot; + &quot;01&quot;&#125;// 测试输出// console.log(getTraceparent())</code></pre><h3 id="X-K-HEADER-X-SS-REQ-HEADER"><a href="#X-K-HEADER-X-SS-REQ-HEADER" class="headerlink" title="X-K-HEADER / X-SS-REQ-HEADER"></a>X-K-HEADER / X-SS-REQ-HEADER</h3><p><code>X-K-HEADER</code> 和 <code>X-SS-REQ-HEADER</code> 数据是一样的，只不过后者是键值对形式，先直接全局搜索关键字，发现都是从本地拿这两个值，清除 cookie 就为空了，那么直接搜索值，发现是 agreement 这个接口返回的，<code>secretKeyValue</code> 值就是我们要的，有可能浏览器抓包直接搜索的话搜索不到，使用抓包工具，比如 Fiddler 就能搜到了，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5b82461455529eac20e1037983745711.png" alt="26"></p><p>这个接口是 post 请求，请求带了一个 json 数据，<code>secretKeyDecode</code>，直接搜索关键字，就一个值，定位跟栈：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/738389717bc00ab5cedf5d7fecc09b82.png" alt="27"></p><p><code>zt()</code> 是从本地缓存中取，<code>At()</code> 是重新生成：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/fa5ccfe57f4391467800a062edbc44e0.png" alt="28"></p><p>这里就非常明显了，t 是32位随机字符串，赋值为 <code>aesKey</code>，后面紧接着一个 RSA 加密了 <code>aesKey</code>，赋值为 <code>rsaEncryptData</code>，而 <code>rsaEncryptData</code> 就是前面 agreement 接口请求的 <code>secretKeyValue</code> 值。</p><p>这里先说一下，最终搜索职位请求的 data 和返回数据都是 AES 加密解密，会用到这个 <code>aesKey</code>，请求头的另一个参数 <code>X-S-HEADER</code> 也会用到，如果这个 key 没有经过 RSA 加密并通过 agreement 接口验证的话，是无效的，可以理解为 agreement 接口既是为了获取 <code>X-K-HEADER</code> 和 <code>X-SS-REQ-HEADER</code>，也是为了激活这个 <code>aesKey</code>。</p><p>这部分的 JS 代码和 Python 代码大致如下：</p><pre><code class="javascript">JSEncrypt = require(&quot;jsencrypt&quot;)function getAesKeyAndRsaEncryptData() &#123;    var aesKey = function (t) &#123;        for (var e = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;, r = &quot;&quot;, n = 0; n &lt; t; n++) &#123;            var i = Math.floor(Math.random() * e.length);            r += e.substring(i, i + 1)        &#125;        return r    &#125;(32);    var e = new JSEncrypt();    e.setPublicKey(&quot;-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnbJqzIXk6qGotX5nD521Vk/24APi2qx6C+2allfix8iAfUGqx0MK3GufsQcAt/o7NO8W+qw4HPE+RBR6m7+3JVlKAF5LwYkiUJN1dh4sTj03XQ0jsnd3BYVqL/gi8iC4YXJ3aU5VUsB6skROancZJAeq95p7ehXXAJfCbLwcK+yFFeRKLvhrjZOMDvh1TsMB4exfg+h2kNUI94zu8MK3UA7v1ANjfgopaE+cpvoulg446oKOkmigmc35lv8hh34upbMmehUqB51kqk9J7p8VMI3jTDBcMC21xq5XF7oM8gmqjNsYxrT9EVK7cezYPq7trqLX1fyWgtBtJZG7WMftKwIDAQAB-----END PUBLIC KEY-----&quot;);    var rsaEncryptData = e.encrypt(aesKey);    return &#123;        &quot;aesKey&quot;: aesKey,        &quot;rsaEncryptData&quot;: rsaEncryptData    &#125;&#125;// 测试输出// console.log(getAesKeyAndRsaEncryptData())</code></pre><pre><code class="python">def update_aes_key() -&gt; None:    # 通过JS获取 AES Key，并通过接口激活，接口激活后会返回一个 secretKeyValue，后续请求头会用到    global aes_key, secret_key_value    url = &quot;https://gate.脱敏处理.com/system/agreement&quot;    headers = &#123;        &quot;Content-Type&quot;: &quot;application/json&quot;,        &quot;Host&quot;: &quot;gate.脱敏处理.com&quot;,        &quot;Origin&quot;: &quot;https://www.脱敏处理.com&quot;,        &quot;Referer&quot;: &quot;https://www.脱敏处理.com/&quot;,        &quot;User-Agent&quot;: UA    &#125;    encrypt_data = lagou_js.call(&quot;getAesKeyAndRsaEncryptData&quot;)    aes_key = encrypt_data[&quot;aesKey&quot;]    rsa_encrypt_data = encrypt_data[&quot;rsaEncryptData&quot;]    data = &#123;&quot;secretKeyDecode&quot;: rsa_encrypt_data&#125;    response = requests.post(url=url, headers=headers, json=data).json()    secret_key_value = response[&quot;content&quot;][&quot;secretKeyValue&quot;]</code></pre><h3 id="X-S-HEADER"><a href="#X-S-HEADER" class="headerlink" title="X-S-HEADER"></a>X-S-HEADER</h3><p><code>X-S-HEADER</code> 你每次翻页都会改变，直接搜索关键字可定位：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3c12d2eec0ae138cdf5b9308c5efd6dd.png" alt="29"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/67936e9e23ab04bbdd242d44b8ec3af1.png" alt="30"></p><p>中间有一个 SHA256 加密，最后返回的 <code>Rt(JSON.stringify(&#123;originHeader: JSON.stringify(e), code: t&#125;))</code> 就是 <code>X-S-HEADER</code> 的值了，<code>Rt()</code> 是一个 AES 加密，比较关键的，<code>Vt(r)</code> 是一个 URL，比如你搜索职位就是 positionAjax.json，搜索公司就是 companyAjax.json，可根据实际情况定制，然后 <code>Lt(t)</code> 就是搜索信息，字符串形式，包含了城市、页码、关键词等。</p><p>获取 <code>X-S-HEADER</code> 的 JS 代码大致如下：</p><pre><code class="javascript">CryptoJS = require(&#39;crypto-js&#39;)jt = function(aesKey, originalData, u) &#123;    var e = &#123;deviceType: 1&#125;      , t = &quot;&quot;.concat(JSON.stringify(e)).concat(u).concat(JSON.stringify(originalData))      , t = (t = t, null === (t = CryptoJS.SHA256(t).toString()) || void 0 === t ? void 0 : t.toUpperCase());    return Rt(JSON.stringify(&#123;        originHeader: JSON.stringify(e),        code: t    &#125;), aesKey)&#125;Rt = function (t, aesKey) &#123;    var Ot = CryptoJS.enc.Utf8.parse(&quot;c558Gq0YQK2QUlMc&quot;),        Dt = CryptoJS.enc.Utf8.parse(aesKey),        t = CryptoJS.enc.Utf8.parse(t);    t = CryptoJS.AES.encrypt(t, Dt, &#123;        iv: Ot,        mode: CryptoJS.mode.CBC,        padding: CryptoJS.pad.Pkcs7    &#125;);    return t.toString()&#125;;function getXSHeader(aesKey, originalData, u)&#123;    return jt(aesKey, originalData, u)&#125;// 测试样例// var url = &quot;https://www.脱敏处理.com/jobs/v2/positionAjax.json&quot;// var aesKey = &quot;dgHY1qVeo/Z0yDaF5WV/EEXxYiwbr5Jt&quot;// var originalData = &#123;&quot;first&quot;: &quot;true&quot;, &quot;needAddtionalResult&quot;: &quot;false&quot;, &quot;city&quot;: &quot;全国&quot;, &quot;pn&quot;: &quot;2&quot;, &quot;kd&quot;: &quot;Java&quot;&#125;// console.log(getXSHeader(aesKey, originalData, url))</code></pre><h2 id="请求-返回数据解密"><a href="#请求-返回数据解密" class="headerlink" title="请求/返回数据解密"></a>请求/返回数据解密</h2><p>前面抓包我们已经发现 positionAjax.json 是 POST 请求，Form Data 中的数据是加密的，返回的 data 也是加密的，我们分析请求头参数的时候，就涉及到 AES 加密解密，所以我们直接搜索 <code>AES.encrypt</code>、<code>AES.decrypt</code>，下断点调试：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a71d05bb4c558409eea816c1792038e7.png" alt="31"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/1127358d32e96c667e465d71b06365ae.png" alt="32"></p><p>非常明显了，这部分的 JS 代码大致如下：</p><pre><code class="javascript">CryptoJS = require(&#39;crypto-js&#39;)function getRequestData(aesKey, originalData)&#123;    return Rt(JSON.stringify(originalData), aesKey)&#125;function getResponseData(encryptData, aesKey)&#123;    return It(encryptData, aesKey)&#125;Rt = function (t, aesKey) &#123;    var Ot = CryptoJS.enc.Utf8.parse(&quot;c558Gq0YQK2QUlMc&quot;),        Dt = CryptoJS.enc.Utf8.parse(aesKey),        t = CryptoJS.enc.Utf8.parse(t);    t = CryptoJS.AES.encrypt(t, Dt, &#123;        iv: Ot,        mode: CryptoJS.mode.CBC,        padding: CryptoJS.pad.Pkcs7    &#125;);    return t.toString()&#125;;It = function(t, aesKey) &#123;    var Ot = CryptoJS.enc.Utf8.parse(&quot;c558Gq0YQK2QUlMc&quot;),    Dt = CryptoJS.enc.Utf8.parse(aesKey);    t = CryptoJS.AES.decrypt(t, Dt, &#123;        iv: Ot,        mode: CryptoJS.mode.CBC,        padding: CryptoJS.pad.Pkcs7    &#125;).toString(CryptoJS.enc.Utf8);    try &#123;        t = JSON.parse(t)    &#125; catch (t) &#123;&#125;    return t&#125;// 测试样例，注意，encryptedData 数据太多，省略了，直接运行解密是会报错的// var aesKey = &quot;dgHY1qVeo/Z0yDaF5WV/EEXxYiwbr5Jt&quot;// var encryptedData = &quot;r4MqbduYxu3Z9sFL75xDhelMTCYPHLluKaurYgzEXlEQ1Rg......&quot;// var originalData = &#123;&quot;first&quot;: &quot;true&quot;, &quot;needAddtionalResult&quot;: &quot;false&quot;, &quot;city&quot;: &quot;全国&quot;, &quot;pn&quot;: &quot;2&quot;, &quot;kd&quot;: &quot;Java&quot;&#125;// console.log(getRequestData(aesKey, originalData))// console.log(getResponseData(encryptedData, aesKey))</code></pre><p>大致的 Python 代码如下：</p><pre><code class="python">def get_header_params(original_data: dict) -&gt; dict:    # 后续请求数据所需的请求头参数    # 职位搜索 URL，如果是搜索公司，那就是 https://www.脱敏处理.com/jobs/companyAjax.json，根据实际情况更改    u = &quot;https://www.脱敏处理.com/jobs/v2/positionAjax.json&quot;    return &#123;        &quot;traceparent&quot;: lagou_js.call(&quot;getTraceparent&quot;),        &quot;X-K-HEADER&quot;: secret_key_value,        &quot;X-S-HEADER&quot;: lagou_js.call(&quot;getXSHeader&quot;, aes_key, original_data, u),        &quot;X-SS-REQ-HEADER&quot;: json.dumps(&#123;&quot;secret&quot;: secret_key_value&#125;)    &#125;def get_encrypted_data(original_data: dict) -&gt; str:    # AES 加密原始数据    encrypted_data = lagou_js.call(&quot;getRequestData&quot;, aes_key, original_data)    return encrypted_datadef get_data(original_data: dict, encrypted_data: str, header_params: dict) -&gt; dict:    # 携带加密后的请求数据和完整请求头，拿到密文，AES 解密得到明文职位信息    url = &quot;https://www.脱敏处理.com/jobs/v2/positionAjax.json&quot;    referer = parse.urljoin(&quot;https://www.脱敏处理.com/wn/jobs?&quot;, parse.urlencode(original_data))    headers = &#123;        # &quot;content-type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,        &quot;Host&quot;: &quot;www.脱敏处理.com&quot;,        &quot;Origin&quot;: &quot;https://www.脱敏处理.com&quot;,        &quot;Referer&quot;: referer,        &quot;traceparent&quot;: header_params[&quot;traceparent&quot;],        &quot;User-Agent&quot;: UA,        &quot;X-K-HEADER&quot;: header_params[&quot;X-K-HEADER&quot;],        &quot;X-S-HEADER&quot;: header_params[&quot;X-S-HEADER&quot;],        &quot;X-SS-REQ-HEADER&quot;: header_params[&quot;X-SS-REQ-HEADER&quot;],    &#125;    # 添加 x-anit-forge-code 和 x-anit-forge-token    headers.update(x_anit)    data = &#123;&quot;data&quot;: encrypted_data&#125;    response = requests.post(url=url, headers=headers, cookies=global_cookies, data=data).json()    if &quot;status&quot; in response:        if not response[&quot;status&quot;] and &quot;操作太频繁&quot; in response[&quot;msg&quot;]:            raise Exception(&quot;获取数据失败！msg：%s！可以尝试补全登录后的 Cookies，或者添加代理！&quot; % response[&quot;msg&quot;])        else:            raise Exception(&quot;获取数据异常！请检查数据是否完整！&quot;)    else:        response_data = response[&quot;data&quot;]        decrypted_data = lagou_js.call(&quot;getResponseData&quot;, response_data, aes_key)        return decrypted_data</code></pre><p>最终整合所有代码，成功拿到数据：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/113e75fb0750f81f8e39031ce7268bb5.png" alt="33"></p><h2 id="逆向小技巧"><a href="#逆向小技巧" class="headerlink" title="逆向小技巧"></a>逆向小技巧</h2><p>浏览器开发者工具 Application - Storage 选项，可以一键清除所有 Cookies，也可以自定义存储配额：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/05bcd18f355250c4570239163d16cae0.png" alt="34"></p><p>Storage - Cookies 可以查看每个站点的所有 Cookies，HttpOnly 打勾的表示是服务器返回的，选中一条 Cookie，右键可以直接定位到哪个请求带了这个 Cookie，也可以直接编辑值，还可以删除单个 Cookie，当你登录了账号，但又需要清除某个 Cookie，且不想重新登录时，这个功能或许有用。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1cc2ddd95e3c595f71f1760b16d60b08.png" alt="35"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>文中给出了部分关键代码，不能直接运行，部分细节可能没提及到，完整代码已放 GitHub，均有详细注释，欢迎 Star。所有内容仅供学习交流，严禁用于商业用途、非法用途，否则由此产生的一切后果均与作者无关，在仓库中下载的文件学习完毕之后请于 24 小时内删除！</p><p>仓库地址：<a href="https://github.com/TRHX/Python3-Spider-Practice">https://github.com/TRHX/Python3-Spider-Practice</a></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul><li><p>JS 代码里引用了三个库，npm install 安装一下即可，如果安装了还提示找不到库，那就是路径问题，推荐在当前目录下执行命令安装，或者在 Python 代码里指定完整路径，具体方法可自行百度。</p></li><li><p>jsencrypt 这个库，本地运行可能会报错 <code>window is not defined</code>，在 <code>\node_modules\jsencrypt\bin\jsencrypt.js</code> 源码中加入 <code>var window = global;</code> 即可，这是实现 RSA 加密的库，当然还有很多其他实现方法或者库，都可以。</p></li><li><p>execjs 执行 JS 的时候，可能会报编码错误 <code>&quot;gbk&quot; can&#39;t decode byte...</code>，有两种解决方法，一是找到官方源码 subprocess.py，搜索 <code>encoding=None</code> 改成 <code>encoding=&#39;utf-8&#39;</code>，二是直接在 Python 代码里面加入以下代码即可：</p></li></ul><pre><code class="python">import subprocessfrom functools import partialsubprocess.Popen = partial(subprocess.Popen, encoding=&quot;utf-8&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS 逆向 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 中如何解决 asyncio 文件描述符最大数量限制问题</title>
      <link href="/article/048/"/>
      <url>/article/048/</url>
      
        <content type="html"><![CDATA[<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>Windows 平台下，Python 版本 3.5，使用异步框架 asyncio，有时候会出现 <code>ValueError: too many file descriptors in select()</code> 的报错信息，今天我们就来聊一下为什么会出现这种问题，以及问题的一些解决方法。</p><p>写一个小 dome 复现这个问题（环境：Windows 64 位、Python 3.7）：</p><pre><code class="python">import aiohttpimport asyncionum = 0async def main(url):    async with aiohttp.ClientSession() as session:        async with session.get(url) as response:            global num            num += 1            print(&#39;%s ——&gt; %s&#39; % (str(num), response.status))def tasks():    url = &#39;https://www.baidu.com/s?ie=UTF-8&amp;wd=%s&#39;    task = [main(url % i) for i in range(10000)]    return taskloop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks()))</code></pre><p>在打印 500 次左右后就会出现以下报错：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f70f58344164e7929022924cd757a85e.png" alt="01.png"></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>好像这个报错和 select 有关，那什么是 select 呢？要怎么解决呢？别急，我们首先来了解一下 asyncio 中的事件循环，即 EventLoop。</p><h3 id="事件循环-EventLoop"><a href="#事件循环-EventLoop" class="headerlink" title="事件循环 EventLoop"></a>事件循环 EventLoop</h3><p>事件循环是 asyncio 的核心，异步任务的运行、任务完成之后的回调、网络 I/O 操作、子进程的运行，都是通过事件循环完成的，通俗来讲，事件循环所做的就是等待事件发生，然后再将每个事件与我们已明确与所述事件类型匹配的函数进行匹配。下图很好的展示了协程、事件循环之间的相互作用：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/91dc097882fc67be9195869f3b179174.png" alt="02.png"></p><p>在 asyncio 中，主要提供了两种不同事件循环的实现方法： </p><ul><li><p><strong>SelectorEventLoop</strong>：基于 selectors 模块的事件循环，selectors 又是建立在底层的 I/O 复用模块 select 之上的，selectors 提供了高度封装和高效的 I/O 复用，也就是说 SelectorEventLoop 在底层就是使用了 select I/O 多路复用的机制。</p></li><li><p><strong>ProactorEventLoop</strong>：使用 IOCP 专为 Windows 构建的事件循环，IOCP 全称 I/O Completion Port，即 I/O 完成端口。它是支持多个同时发生的异步 I/O 操作的应用程序编程接口，它充分利用内核对象的调度，只使用少量的几个线程来处理和客户端的所有通信，消除了无谓的线程上下文切换，是 Windows 下性能最好的 I/O 模型，有关 IOCP 的详细介绍可参考<a href="https://docs.microsoft.com/en-ca/windows/win32/fileio/i-o-completion-ports">微软文档</a>。</p></li></ul><p>那么这两种方法有什么区别呢？在 asyncio 中什么时候用什么方法呢？</p><p>我们不妨看一下 asyncio 的源码，在 Python 3.7 中，无论在 Windows 还是 Linux 中都可以看到其默认的设置是 SelectorEventLoop：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7d650aeaed8ffcd845b1042a2a790501.png" alt="03.png"></p><p>我们也可以分别在 Windows 平台和 Linux 平台打印一下 EventLoop 对象（Python 3.7），可以看到默认都是 SelectorEventLoop：</p><pre><code class="python">import asyncioloop = asyncio.get_event_loop()print(loop)</code></pre><p>Windows：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bcfeab7170f5de6e7ad605d76aa5868a.png" alt="04.png"></p><p>Linux：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/efb7794e5f2ba360cb3d0f0523061d6e.png" alt="05.png"></p><p>事实上，在 Python 3.7 以及之前的版本中，   所有平台默认使用的都是 SelectorEventLoop，在 Python 3.8 以及以后的版本中，Unix 平台默认使用的是 SelectorEventLoop，Windows 平台默认使用的是 ProactorEventLoop，这个差异可以在官方文档中看到。</p><ul><li>Python 3.7 文档：<a href="https://docs.python.org/3.7/library/asyncio-eventloop.html#event-loop-implementations">https://docs.python.org/3.7/library/asyncio-eventloop.html#event-loop-implementations</a></li><li>Python 3.8 文档：<a href="https://docs.python.org/3.8/library/asyncio-eventloop.html#event-loop-implementations">https://docs.python.org/3.8/library/asyncio-eventloop.html#event-loop-implementations</a></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/30387729cf1d1eaafe4114fb3a4a847d.png" alt="06.png"></p><p>说了这么多，这和 <code>ValueError: too many file descriptors in select()</code> 的报错问题有什么关系呢？select 到底是什么东西呢？</p><h3 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h3><p>要了解 select，我们还要了解一下什么是 I/O 多路复用（I/O multiplexing），服务器端编程经常需要构造高性能的 I/O 模型，常见的 I/O 模型有同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用等；当需要同时处理多个客户端接入请求时，可以利用多线程或者 I/O 多路复用技术进行处理，I/O 多路复用技术就是为了解决进程或线程阻塞到某个 I/O 系统调用而出现的技术，使进程不阻塞于某个特定的 I/O 系统调用。</p><p><strong>select，poll，epoll 等都是 I/O 多路复用的一种机制</strong>，其中后两个在 Linux 中可用，Windows 仅支持 select，I/O 多路复用通过这种机制，可以监视多个描述符，一旦某个描述符就绪，一般是读就绪或者写就绪，就是在这个文件描述符进行读写操作之前，能够通知程序进行相应的读写操作。</p><h3 id="select-的缺点"><a href="#select-的缺点" class="headerlink" title="select 的缺点"></a>select 的缺点</h3><p>I/O 多路复用这个概念被提出来以后， select 是第一个实现这个概念的，select 被实现以后，很快就暴露出了很多问题，其中一个缺点就是 <strong>select 在 Windows 中限制了文件描述符数量为 512 个，在 Linux 中限制为 1024 个</strong>，那么在前面的 dome 中，使用的是 Python 3.5，这个版本的 asyncio 默认使用了 SelectorEventLoop，底层调用的是 select，受 select 缺点的影响，并发量过高，就出现了 <code>ValueError: too many file descriptors in select()</code> 的报错信息。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="1-更换事件循环选择器"><a href="#1-更换事件循环选择器" class="headerlink" title="1.更换事件循环选择器"></a>1.更换事件循环选择器</h3><p>如果你使用的是 Python 3.7 及以下的版本，那么在 Windows 平台，可以使用 ProactorEventLoop。在 Linux 平台可以使用 PollSelector。</p><p><strong>注意</strong>：如果你使用了 ProactorEventLoop，那么你将无法使用代理！这是 asyncio 的 bug，早在 2020 年 1 月就有人提过 <a href="https://github.com/aio-libs/aiohttp/issues/4536">issue</a>，目前仍然可以看到类似的 issue，官方貌似也还没办法解决，所以，如果您必须要使用代理，则可以参考后面的解决办法。</p><pre><code class="python">import selectorsimport asyncioimport sysif sys.platform == &#39;win32&#39;:    loop = asyncio.ProactorEventLoop()    asyncio.set_event_loop(loop)else:    selector = selectors.PollSelector()    loop = asyncio.SelectorEventLoop(selector)    asyncio.set_event_loop(loop)</code></pre><h3 id="2-限制并发量"><a href="#2-限制并发量" class="headerlink" title="2.限制并发量"></a>2.限制并发量</h3><p>可以使用方法 <code>asyncio.Semaphore()</code> 来限制并发量，Semaphore 就是信号量的意思，Semaphore 管理一个内部计数器，该计数器在每次调用 <code>acquire()</code> 方法时递减，每次调用 <code>release()</code> 方法时递增，计数器永远不会低于零，当方法 <code>acquire()</code> 发现它为零时，它会阻塞，等待其他线程调用 <code>release()</code> 方法。通过限制并发量的方法来解决报错问题是个不错的选择。</p><pre><code class="python">import aiohttpimport asyncionum = 0async def main(url, semaphore):    async with semaphore:        async with aiohttp.ClientSession() as session:            async with session.get(url) as response:                global num                num += 1                print(&#39;%s ——&gt; %s&#39; % (str(num), response.status))def tasks():    semaphore = asyncio.Semaphore(300)                         # 限制并发量为 300    url = &#39;https://www.baidu.com/s?ie=UTF-8&amp;wd=%s&#39;    task = [main(url % i, semaphore) for i in range(10000)]    # #总共 10000 任务    return taskloop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks()))</code></pre><h3 id="3-修改最大文件描述符限制"><a href="#3-修改最大文件描述符限制" class="headerlink" title="3.修改最大文件描述符限制"></a>3.修改最大文件描述符限制</h3><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>在 Windows 中，最大文件描述符限制在 C 语言的头文件 Winsock2.h 中使用变量 <code>FD_SETSIZE</code> 进行定义，如果要修改它，可以通过在包含 Winsock2.h 之前将 <code>FD_SETSIZE</code> 定义为另一个值来修改，如果我们使用的编程语言是 Python 的话，是不太好对这个值进行修改的，可以参考微软官方文档：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-select">https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-select</a></p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>在 Linux 平台，可以使用 <code>ulimit</code> 命令来修改最大文件描述符限制：</p><ul><li><p>查看当前会话最大文件描述符限制（默认1024）：<code>ulimit -n</code></p></li><li><p>临时修改限制，只对当前的会话有效：<code>ulimit -SHn 65536</code></p></li><li><p>永久修改限制，在 <code>/etc/security/limits.conf</code> 文件里新增以下内容：</p><pre><code>* hard nofile 65536* soft nofile 65536</code></pre></li></ul><p><code>ulimit</code> 命令参考：</p><pre><code>    -S    使用软 (soft) 资源限制    -H    使用硬 (hard) 资源限制    -a    所有当前限制都被报告    -b    套接字缓存尺寸    -c    创建的核文件的最大尺寸    -d    一个进程的数据区的最大尺寸    -e    最高的调度优先级 (nice)    -f    有 shell 及其子进程可以写的最大文件尺寸    -i    最多的可以挂起的信号数    -k    分配给此进程的最大 kqueue 数量    -l    一个进程可以锁定的最大内存尺寸    -m    最大的内存进驻尺寸    -n    最多的打开的文件描述符个数    -p    管道缓冲区尺寸    -q    POSIX 信息队列的最大字节数    -r    实时调度的最大优先级    -s    最大栈尺寸    -t    最大的CPU时间，以秒为单位    -u    最大用户进程数    -v    虚拟内存尺寸    -x    最大的文件锁数量    -P    最大伪终端数量    -T    最大线程数量</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>asyncio 事件循环选择器，在 Python 3.7 以及之前的版本中，所有平台默认使用的都是 SelectorEventLoop，在 Python 3.8 以及以后的版本中，Unix 平台默认使用的是 SelectorEventLoop，Windows 平台默认使用的是 ProactorEventLoop。</p><p>select 在 Windows 中限制了文件描述符最大数量为 512 个，在 Linux 中限制为 1024 个。</p><p>要解决 <code>ValueError: too many file descriptors in select()</code> 的报错问题，根据您的平台和业务要求选择合理的解决方法：</p><h3 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a>Windows</h3><ol><li><p>通过 <code>asyncio.Semaphore()</code> 方法来限制并发量，通常设置在 300-500 比较合理，这是最优的做法；</p></li><li><p>更换 asyncio 的事件循环选择器为 ProactorEventLoop，<strong>注意：这将导致无法使用代理！</strong></p></li></ol><h3 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h3><ol><li><p>通过 <code>asyncio.Semaphore()</code> 方法来限制并发量，通常设置在 800-1000 比较合理；</p></li><li><p>通过 <code>ulimit</code> 命令来修改最大文件描述符限制；</p></li><li><p>更换 asyncio 的事件循环选择器为 PollSelector。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> asyncio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC 技术及其框架 Sekiro 在爬虫逆向中的应用，加密数据一把梭</title>
      <link href="/article/047/"/>
      <url>/article/047/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC"></a>什么是 RPC</h2><p><del>RPC，英文 RangPaCong，中文让爬虫，旨在为爬虫开路，秒杀一切，让爬虫畅通无阻！</del></p><p>开个玩笑，实际上 RPC 为远程过程调用，全称 Remote Procedure Call，是一种技术思想而非一种规范或协议。RPC 的诞生事实上离不开分布式的发展，RPC 主要解决了两个问题：</p><ol><li>解决了分布式系统中，服务之间的互相调用问题；</li><li>RPC 使得在远程调用时，像本地调用一样方便，让调用者感知不到远程调用的逻辑。</li></ol><p>RPC 的存在让构建分布式系统更加容易，相比于 HTTP 协议，RPC 采用二进制字节码传输，因此也更加高效、安全。在一个典型 RPC 的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，完整 RPC 架构图如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/71bb132886df40999a33ad59bd6a1159.png" alt="01"></p><h2 id="JSRPC"><a href="#JSRPC" class="headerlink" title="JSRPC"></a>JSRPC</h2><p>RPC 技术是非常复杂的，对于我们搞爬虫、逆向的来说，不需要完全了解，只需要知道这项技术如何在逆向中应用就行了。</p><p>RPC 在逆向中，简单来说就是将本地和浏览器，看做是服务端和客户端，二者之间通过 WebSocket 协议进行 RPC 通信，在浏览器中将加密函数暴露出来，在本地直接调用浏览器中对应的加密函数，从而得到加密结果，不必去在意函数具体的执行逻辑，也省去了扣代码、补环境等操作，可以省去大量的逆向调试时间。我们以某团网页端的登录为例来演示 RPC 在逆向中的具体使用方法。（假设你已经有一定逆向基础，了解 WebSocket 协议，纯小白可以先看看以前的文章）</p><ul><li>主页（base64）：<code>aHR0cHM6Ly9wYXNzcG9ydC5tZWl0dWFuLmNvbS9hY2NvdW50L3VuaXRpdmVsb2dpbg==</code></li><li>参数：h5Fingerprint</li></ul><p>首先抓一下包，登录接口有一个超级长的参数 h5Fingerprint，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/8fec89761494422c845e5bc8fb712a9c.png" alt="02"></p><p>直接搜一下就能找到加密函数：</p><p><img src="https://img-blog.csdnimg.cn/59e03ca57d2d4b75937961e81fc7b247.png" alt="03"></p><p>其中 <code>utility.getH5fingerprint()</code> 传入的参数 <code>window.location.origin + url</code> 格式化后，参数如下：</p><pre><code>url = &quot;https://passport.脱敏处理.com/account/unitivelogin&quot;params = &#123;    &quot;risk_partner&quot;: &quot;0&quot;,    &quot;risk_platform&quot;: &quot;1&quot;,    &quot;risk_app&quot;: &quot;-1&quot;,    &quot;uuid&quot;: &quot;96309b5f00ba4143b920.1644805104.1.0.0&quot;,    &quot;token_id&quot;: &quot;DNCmLoBpSbBD6leXFdqIxA&quot;,    &quot;service&quot;: &quot;www&quot;,    &quot;continue&quot;: &quot;https://www.脱敏处理.com/account/settoken?continue=https%3A%2F%2Fwww.脱敏处理.com%2F&quot;&#125;</code></pre><p>uuid 和 token_id 都可以直接搜到，不是本次研究重点，这里不再细说，接下来我们使用 RPC 技术，直接调用浏览器里的 <code>utility.getH5fingerprint()</code> 方法，首先在本地编写服务端代码，使其能够一直输入待加密字符串，接收并打印加密后的字符串：</p><pre><code class="python"># ==================================# --*-- coding: utf-8 --*--# @Time    : 2022-02-14# @Author  : ITBOB# @FileName: ws_server.py# @Software: PyCharm# ==================================import sysimport asyncioimport websocketsasync def receive_massage(websocket):    while True:        send_text = input(&quot;请输入要加密的字符串: &quot;)        if send_text == &quot;exit&quot;:            print(&quot;Exit, goodbye!&quot;)            await websocket.send(send_text)            await websocket.close()            sys.exit()        else:            await websocket.send(send_text)            response_text = await websocket.recv()            print(&quot;\n加密结果：&quot;, response_text)start_server = websockets.serve(receive_massage, &#39;127.0.0.1&#39;, 5678)  # 自定义端口asyncio.get_event_loop().run_until_complete(start_server)asyncio.get_event_loop().run_forever()</code></pre><p>编写浏览器客户端 JS 代码，收到消息就直接 <code>utility.getH5fingerprint()</code> 得到加密参数并发送给服务端：</p><pre><code class="javascript">/* ==================================# @Time    : 2022-02-14# @Author  : ITBOB# @FileName: ws_client.js# @Software: PyCharm# ================================== */var ws = new WebSocket(&quot;ws://127.0.0.1:5678&quot;);  // 自定义端口ws.onmessage = function (evt) &#123;    console.log(&quot;Received Message: &quot; + evt.data);    if (evt.data == &quot;exit&quot;) &#123;        ws.close();    &#125; else &#123;        ws.send(utility.getH5fingerprint(evt.data))    &#125;&#125;;</code></pre><p>然后我们需要把客户端代码注入到网页中，这里方法有很多，比如抓包软件 Fiddler 替换响应、浏览器插件 ReRes 替换 JS、浏览器开发者工具 Overrides 重写功能等，也可以通过插件、油猴等注入 Hook 的方式插入，反正方法很多，对这些方法不太了解的朋友可以去看看以前的文章，都有介绍。</p><p>这里我们使用浏览器开发者工具 Overrides 重写功能，将 WebSocket 客户端代码加到加密的这个 JS 文件里并 Ctrl+S 保存，这里将其写成了 IIFE 自执行方式，这样做的原因是防止污染全局变量，不用自执行方式当然也是可以的。</p><p><img src="https://img-blog.csdnimg.cn/5dfd3cb4f9614bed9b3a2eaa60f20c3d.png" alt="04"></p><p>然后先运行本地服务端代码，网页上先登录一遍，网页上先登录一遍，网页上先登录一遍，重要的步骤说三遍！然后就可以在本地传入待加密字符串，获取 <code>utility.getH5fingerprint()</code> 加密后的结果了：</p><p><img src="https://img-blog.csdnimg.cn/8851ff218c3a424f878fda67ecfe6f45.png" alt="05"></p><h2 id="Sekiro"><a href="#Sekiro" class="headerlink" title="Sekiro"></a>Sekiro</h2><p>通过前面的示例，可以发现自己写服务端太麻烦了，不易扩展，那这方面有没有现成的轮子呢？答案是有的，这里介绍两个项目：</p><ul><li>JsRPC-hliang：<a href="https://github.com/jxhczhl/JsRpc">https://github.com/jxhczhl/JsRpc</a></li><li>Sekiro：<a href="https://github.com/virjar/sekiro">https://github.com/virjar/sekiro</a></li></ul><p>JsRPC-hliang 是用 go 语言写的，是专门为 JS 逆向做的项目，而 Sekiro 功能更加强大，Sekiro 是由邓维佳大佬，俗称渣总，写的一个基于长链接和代码注入的 Android Private API 暴露框架，可以用在 APP 逆向、APP 数据抓取、Android 群控等场景，同时 Sekiro 也是目前公开方案唯一稳定的 JSRPC 框架，两者在 JS 逆向方面的使用方法其实都差不多，本文主要介绍一下 Sekiro 在 Web JS 逆向中的应用。</p><p>参考 Sekiro 文档，首先在本地编译项目：</p><ul><li><p>Linux &amp; Mac：执行脚本 <code>build_demo_server.sh</code>，之后得到产出发布压缩包：<code>sekiro-service-demo/target/sekiro-release-demo.zip</code></p></li><li><p>Windows：可以直接下载：<a href="https://oss.virjar.com/sekiro/sekiro-demo">https://oss.virjar.com/sekiro/sekiro-demo</a></p></li></ul><p>然后在本地运行（需要有 Java 环境，自行配置）：</p><ul><li>Linux &amp; Mac：<code>bin/sekiro.sh</code></li><li>Windows：<code>bin/sekiro.bat</code></li></ul><p>以 Windows 为例，启动后如下：</p><p><img src="https://img-blog.csdnimg.cn/c7acc0ca85e040d38ee97aff3e256f22.png" alt="06"></p><p>接下来就需要在浏览器里注入代码了，需要将作者提供的 sekiro_web_client.js（下载地址：<a href="https://sekiro.virjar.com/sekiro-doc/assets/sekiro_web_client.js%EF%BC%89">https://sekiro.virjar.com/sekiro-doc/assets/sekiro_web_client.js）</a> 注入到浏览器环境，然后通过 SekiroClient 和 Sekiro 服务器通信，即可直接 RPC 调用浏览器内部方法，官方提供的 SekiroClient 代码样例如下：</p><pre><code class="javascript">function guid() &#123;    function S4() &#123;        return (((1+Math.random())*0x10000)|0).toString(16).substring(1);    &#125;    return (S4()+S4()+&quot;-&quot;+S4()+&quot;-&quot;+S4()+&quot;-&quot;+S4()+&quot;-&quot;+S4()+S4()+S4());&#125;var client = new SekiroClient(&quot;wss://sekiro.virjar.com/business/register?group=ws-group&amp;clientId=&quot;+guid());client.registerAction(&quot;clientTime&quot;,function(request, resolve, reject)&#123;    resolve(&quot;&quot;+new Date());&#125;)</code></pre><p>wss 链接里，如果是免费版，要将 business 改成 business-demo，解释一下涉及到的名词：</p><ul><li><strong>group</strong>：业务类型（接口组），每个业务一个 group，group 下面可以注册多个终端（SekiroClient），同时 group 可以挂载多个 Action；</li><li><strong>clientId</strong>：指代设备，多个设备使用多个机器提供 API 服务，提供群控能力和负载均衡能力；</li><li><strong>SekiroClient</strong>：服务提供者客户端，主要场景为手机/浏览器等。最终的 Sekiro 调用会转发到 SekiroClient。每个 client 需要有一个惟一的 clientId；</li><li><strong>registerAction</strong>：接口，同一个 group 下面可以有多个接口，分别做不同的功能；</li><li><strong>resolve</strong>：将内容传回给客户端的方法；</li><li><strong>request</strong>：客户端传过来的请求，如果请求里有多个参数，可以以键值对的方式从里面提取参数然后再做处理。</li></ul><p>说了这么多可能也不好理解，直接实战，还是以某团网页端登录为例，我们将 sekiro_web_client.js 与 SekiroClient 通信代码写在一起，然后根据需求，改写一下通信部分代码：</p><ol><li>ws 链接改为：<code>ws://127.0.0.1:5620/business-demo/register?group=rpc-test&amp;clientId=</code>，自定义 <code>group</code> 为 <code>rpc-test</code>；</li><li>注册一个事件 <code>registerAction</code> 为 <code>getH5fingerprint</code>；</li><li><code>resolve</code> 返回的结果为 <code>utility.getH5fingerprint(request[&quot;url&quot;])</code>，即加密并返回客户端传过来的 url 参数。</li></ol><p>完整代码如下（留意末尾 SekiroClient 通信代码部分的写法）：</p><pre><code class="javascript">/* ==================================# @Time    : 2022-02-14# @Author  : ITBOB# @FileName: sekiro.js# @Software: PyCharm# ================================== */(function () &#123;    &#39;use strict&#39;;    function SekiroClient(wsURL) &#123;        this.wsURL = wsURL;        this.handlers = &#123;&#125;;        this.socket = &#123;&#125;;        // check        if (!wsURL) &#123;            throw new Error(&#39;wsURL can not be empty!!&#39;)        &#125;        this.webSocketFactory = this.resolveWebSocketFactory();        this.connect()    &#125;    SekiroClient.prototype.resolveWebSocketFactory = function () &#123;        if (typeof window === &#39;object&#39;) &#123;            var theWebSocket = window.WebSocket ? window.WebSocket : window.MozWebSocket;            return function (wsURL) &#123;                function WindowWebSocketWrapper(wsURL) &#123;                    this.mSocket = new theWebSocket(wsURL);                &#125;                WindowWebSocketWrapper.prototype.close = function () &#123;                    this.mSocket.close();                &#125;;                WindowWebSocketWrapper.prototype.onmessage = function (onMessageFunction) &#123;                    this.mSocket.onmessage = onMessageFunction;                &#125;;                WindowWebSocketWrapper.prototype.onopen = function (onOpenFunction) &#123;                    this.mSocket.onopen = onOpenFunction;                &#125;;                WindowWebSocketWrapper.prototype.onclose = function (onCloseFunction) &#123;                    this.mSocket.onclose = onCloseFunction;                &#125;;                WindowWebSocketWrapper.prototype.send = function (message) &#123;                    this.mSocket.send(message);                &#125;;                return new WindowWebSocketWrapper(wsURL);            &#125;        &#125;        if (typeof weex === &#39;object&#39;) &#123;            // this is weex env : https://weex.apache.org/zh/docs/modules/websockets.html            try &#123;                console.log(&quot;test webSocket for weex&quot;);                var ws = weex.requireModule(&#39;webSocket&#39;);                console.log(&quot;find webSocket for weex:&quot; + ws);                return function (wsURL) &#123;                    try &#123;                        ws.close();                    &#125; catch (e) &#123;                    &#125;                    ws.WebSocket(wsURL, &#39;&#39;);                    return ws;                &#125;            &#125; catch (e) &#123;                console.log(e);                //ignore            &#125;        &#125;        //TODO support ReactNative        if (typeof WebSocket === &#39;object&#39;) &#123;            return function (wsURL) &#123;                return new theWebSocket(wsURL);            &#125;        &#125;        // weex 和 PC环境的websocket API不完全一致，所以做了抽象兼容        throw new Error(&quot;the js environment do not support websocket&quot;);    &#125;;    SekiroClient.prototype.connect = function () &#123;        console.log(&#39;sekiro: begin of connect to wsURL: &#39; + this.wsURL);        var _this = this;        // 不check close，让        // if (this.socket &amp;&amp; this.socket.readyState === 1) &#123;        //     this.socket.close();        // &#125;        try &#123;            this.socket = this.webSocketFactory(this.wsURL);        &#125; catch (e) &#123;            console.log(&quot;sekiro: create connection failed,reconnect after 2s&quot;);            setTimeout(function () &#123;                _this.connect()            &#125;, 2000)        &#125;        this.socket.onmessage(function (event) &#123;            _this.handleSekiroRequest(event.data)        &#125;);        this.socket.onopen(function (event) &#123;            console.log(&#39;sekiro: open a sekiro client connection&#39;)        &#125;);        this.socket.onclose(function (event) &#123;            console.log(&#39;sekiro: disconnected ,reconnection after 2s&#39;);            setTimeout(function () &#123;                _this.connect()            &#125;, 2000)        &#125;);    &#125;;    SekiroClient.prototype.handleSekiroRequest = function (requestJson) &#123;        console.log(&quot;receive sekiro request: &quot; + requestJson);        var request = JSON.parse(requestJson);        var seq = request[&#39;__sekiro_seq__&#39;];        if (!request[&#39;action&#39;]) &#123;            this.sendFailed(seq, &#39;need request param &#123;action&#125;&#39;);            return        &#125;        var action = request[&#39;action&#39;];        if (!this.handlers[action]) &#123;            this.sendFailed(seq, &#39;no action handler: &#39; + action + &#39; defined&#39;);            return        &#125;        var theHandler = this.handlers[action];        var _this = this;        try &#123;            theHandler(request, function (response) &#123;                try &#123;                    _this.sendSuccess(seq, response)                &#125; catch (e) &#123;                    _this.sendFailed(seq, &quot;e:&quot; + e);                &#125;            &#125;, function (errorMessage) &#123;                _this.sendFailed(seq, errorMessage)            &#125;)        &#125; catch (e) &#123;            console.log(&quot;error: &quot; + e);            _this.sendFailed(seq, &quot;:&quot; + e);        &#125;    &#125;;    SekiroClient.prototype.sendSuccess = function (seq, response) &#123;        var responseJson;        if (typeof response == &#39;string&#39;) &#123;            try &#123;                responseJson = JSON.parse(response);            &#125; catch (e) &#123;                responseJson = &#123;&#125;;                responseJson[&#39;data&#39;] = response;            &#125;        &#125; else if (typeof response == &#39;object&#39;) &#123;            responseJson = response;        &#125; else &#123;            responseJson = &#123;&#125;;            responseJson[&#39;data&#39;] = response;        &#125;        if (Array.isArray(responseJson)) &#123;            responseJson = &#123;                data: responseJson,                code: 0            &#125;        &#125;        if (responseJson[&#39;code&#39;]) &#123;            responseJson[&#39;code&#39;] = 0;        &#125; else if (responseJson[&#39;status&#39;]) &#123;            responseJson[&#39;status&#39;] = 0;        &#125; else &#123;            responseJson[&#39;status&#39;] = 0;        &#125;        responseJson[&#39;__sekiro_seq__&#39;] = seq;        var responseText = JSON.stringify(responseJson);        console.log(&quot;response :&quot; + responseText);        this.socket.send(responseText);    &#125;;    SekiroClient.prototype.sendFailed = function (seq, errorMessage) &#123;        if (typeof errorMessage != &#39;string&#39;) &#123;            errorMessage = JSON.stringify(errorMessage);        &#125;        var responseJson = &#123;&#125;;        responseJson[&#39;message&#39;] = errorMessage;        responseJson[&#39;status&#39;] = -1;        responseJson[&#39;__sekiro_seq__&#39;] = seq;        var responseText = JSON.stringify(responseJson);        console.log(&quot;sekiro: response :&quot; + responseText);        this.socket.send(responseText)    &#125;;    SekiroClient.prototype.registerAction = function (action, handler) &#123;        if (typeof action !== &#39;string&#39;) &#123;            throw new Error(&quot;an action must be string&quot;);        &#125;        if (typeof handler !== &#39;function&#39;) &#123;            throw new Error(&quot;a handler must be function&quot;);        &#125;        console.log(&quot;sekiro: register action: &quot; + action);        this.handlers[action] = handler;        return this;    &#125;;    function guid() &#123;        function S4() &#123;            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);        &#125;        return (S4() + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + S4() + S4());    &#125;    var client = new SekiroClient(&quot;ws://127.0.0.1:5620/business-demo/register?group=rpc-test&amp;clientId=&quot; + guid());    client.registerAction(&quot;getH5fingerprint&quot;, function (request, resolve, reject) &#123;        resolve(utility.getH5fingerprint(request[&quot;url&quot;]));    &#125;)&#125;)();</code></pre><p>与前面的方法一样，使用浏览器开发者工具 Overrides 重写功能，将上面的代码注入到网页 JS 里：</p><p><img src="https://img-blog.csdnimg.cn/608ac74417ac4010be5ae64bc986e926.png" alt="07"></p><p>然后 Sekiro 为我们提供了一些 API：</p><ul><li>查看分组列表：<a href="http://127.0.0.1:5620/business-demo/groupList">http://127.0.0.1:5620/business-demo/groupList</a></li><li>查看队列状态：<a href="http://127.0.0.1:5620/business-demo/clientQueue?group=test">http://127.0.0.1:5620/business-demo/clientQueue?group=test</a></li><li>调用转发：<a href="http://127.0.0.1:5620/business-demo/invoke?group=test&amp;action=test&amp;param=testparm">http://127.0.0.1:5620/business-demo/invoke?group=test&amp;action=test&amp;param=testparm</a></li></ul><p>比如我们现在要调用 <code>utility.getH5fingerprint()</code> 加密方法该怎么办呢？很简单，代码注入到浏览器里后，首先还是要手动登录一遍，手动登录一遍，手动登录一遍，重要的事情说三遍！然后参考上面的调用转发 API 进行改写：</p><ul><li>我们自定义的分组 <code>group</code> 是 <code>rpc-test</code>；</li><li>事件 <code>action</code> 是 <code>getH5fingerprint</code>；</li><li>待加密参数名称为 <code>url</code>， 其值例如为：<code>https://www.baidu.com/</code></li></ul><p>那么我们的调用链接就应该是：<code>http://127.0.0.1:5620/business-demo/invoke?group=rpc-test&amp;action=getH5fingerprint&amp;url=https://www.baidu.com/</code>，直接浏览器打开，返回的字典，data 里面就是加密结果：</p><p><img src="https://img-blog.csdnimg.cn/44e52ae1fd9a4c118f543ff63b1c0537.png" alt="08"></p><p>同样的，在本地用 Python 的话，直接 requests 就完事儿了：</p><p><img src="https://img-blog.csdnimg.cn/4e81520df896457b959c61534ade9103.png" alt="09"></p><p>我们前面是把 sekiro_web_client.js 复制下来和通信代码一起注入到浏览器的，这里我们还可以有更加优雅的方法，直接给 document 新创建一个 script，通过链接的形式插入 sekiro_web_client.js，这里需要注意一下几点问题：</p><ol><li>第一个是时机的问题，需要等待 document 这些元素加载完成才能建立 SekiroClient 通信，不然调用 SekiroClient 是会报错的，这里可以用 setTimeout 方法，该方法用于在指定的毫秒数后调用函数或计算表达式，将 SekiroClient 通信代码单独封装成一个函数，比如 <code>function startSekiro()</code>，然后等待 1-2 秒后再执行 SekiroClient 通信代码；</li><li>由于 SekiroClient 通信代码被封装成了函数，此时直接调用 <code>utility.getH5fingerprint</code> 是会提示未定义的，所以我们要先将其导为全局变量，比如 <code>window.getH5fingerprint = utility.getH5fingerprint</code>，后续直接调用 <code>window.getH5fingerprint</code> 即可。</li></ol><p>完整代码如下所示：</p><pre><code class="javascript">/* ==================================# @Time    : 2022-02-14# @Author  : ITBOB# @FileName: sekiro.js# @Software: PyCharm# ================================== */(function () &#123;    var newElement = document.createElement(&quot;script&quot;);    newElement.setAttribute(&quot;type&quot;, &quot;text/javascript&quot;);    newElement.setAttribute(&quot;src&quot;, &quot;https://sekiro.virjar.com/sekiro-doc/assets/sekiro_web_client.js&quot;);    document.body.appendChild(newElement);    window.getH5fingerprint = utility.getH5fingerprint    function guid() &#123;        function S4() &#123;            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);        &#125;        return (S4() + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + S4() + S4());    &#125;    function startSekiro() &#123;        var client = new SekiroClient(&quot;ws://127.0.0.1:5620/business-demo/register?group=rpc-test&amp;clientId=&quot; + guid());        client.registerAction(&quot;getH5fingerprint&quot;, function (request, resolve, reject) &#123;            resolve(window.getH5fingerprint(request[&quot;url&quot;]));        &#125;)    &#125;    setTimeout(startSekiro, 2000)&#125;)();</code></pre><p><img src="https://img-blog.csdnimg.cn/5657c3efd68048b59db91794a8b9c9c4.png" alt="10"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>目前如果不去逆向 JS 来实现加密参数的话，用得最多的就是自动化工具了，比如 Selenium、Puppeteer 等，很显然这些自动化工具配置繁琐、运行效率极低，而 RPC 技术不需要加载多余的资源，稳定性和效率明显都更高，RPC 不需要考虑浏览器指纹、各种环境，如果风控不严的话，高并发也是能够轻松实现的，相反，由于 RPC 是一直挂载在同一个浏览器上的，所以针对风控较严格的站点，比如检测 UA、IP 与加密参数绑定之类的，那么 PRC 调用太频繁就不太行了，当然也可以研究研究浏览器群控技术，操纵多个不同浏览器可以一定程度上缓解这个问题。总之 RPC 技术还是非常牛的，除了 JS 逆向，可以说是目前比较万能、高效的方法了，一定程度上做到了加密参数一把梭！</p>]]></content>
      
      
      <categories>
          
          <category> JS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS 逆向 </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS 逆向】吾爱破解2022春节解题领红包之番外篇 Web 中级题解</title>
      <link href="/article/046/"/>
      <url>/article/046/</url>
      
        <content type="html"><![CDATA[<h2 id="逆向目标"><a href="#逆向目标" class="headerlink" title="逆向目标"></a>逆向目标</h2><p>本次逆向的目标来源于吾爱破解 2022 春节解题领红包之番外篇 Web 中级题，吾爱破解每年都会有派送红包活动（送吾爱币），需要大家使出看家逆向本领来分析内容获得口令红包，今年一共有五个题，一个送分题，两个 Windows 题、一个 Android 题和一个 Web 题，本文分析的正是  Web 题，<strong>吾爱有规定活动结束前不要外泄口令、讨论分享分析过程，所以本文在活动结束后才发出来。</strong></p><p>此 Web 题题目是：小 D 最爱看的视频网站最近关站了，关站前他用 Fiddler 和 Web Archive 保存了一位主播的视频，但他发现存下来的文件无法播放。你能帮小 D 找回他的回忆吗？（.saz 与 .wacz 任选其一即可解题）</p><ul><li><p>活动地址：<a href="https://www.52pojie.cn/thread-1582582-1-1.html">https://www.52pojie.cn/thread-1582582-1-1.html</a></p></li><li><p>Web 题地址：<a href="https://www.52pojie.cn/home.php?mod=task&amp;do=view&amp;id=17">https://www.52pojie.cn/home.php?mod=task&amp;do=view&amp;id=17</a></p></li></ul><h2 id="HLS-流媒体传输协议"><a href="#HLS-流媒体传输协议" class="headerlink" title="HLS 流媒体传输协议"></a>HLS 流媒体传输协议</h2><p>本题涉及到 HLS 流媒体传输协议，先简单介绍一下，了解的同志可直接跳过。</p><p>HLS 全称 HTTP Live Streaming，即基于 HTTP 的自适应码率流媒体传输协议，是苹果研发的动态码率自适应技术，它包括一个 M3U(8) 的索引文件，若干 TS 视频流文件，如果视频流文件是加密的，那就还会存在一个 key 加密串文件。</p><p>M3U8 文件是 M3U 的一种，只不过文件中存储的文本使用 UTF-8 字符编码，在极少数情况下，M3U8 文件可能会以 M3UP 扩展名保存。M3U8 文件是各种音频和视频播放程序使用的播放列表文件，它包含了媒体文件或媒体文件夹的路径或 URL，以及有关播放列表的相关信息。</p><p>TS 全称为 MPEG2-TS，TS 即 Transport Stream 传输流，又称 MPEG-TS、MTS、TP，这种格式的特点就是从视频流的任一片段开始都是可以独立解码的。</p><p>针对 TS 格式的文件，如果是未加密的，一般的播放器就能够直接播放，也可以使用 FFmpeg 等工具转换为其他格式，FFmpeg 也可以直接处理 M3U8 文件，自动解密合并转换 TS 文件，当然也有其他大佬写好的小工具，拖入 M3U8 文件就直接给你处理好了。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/04101c9e3b5b32d096045bf6be06f40a.png" alt="01"></p><p>M3U8 文件内容的大致格式示例如下：</p><pre><code>#EXTM3U#EXT-X-VERSION:3#EXT-X-MEDIA-SEQUENCE:0#EXT-X-ALLOW-CACHE:YES#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://www.example.com/m3u8.key&quot;#EXT-X-TARGETDURATION:5#EXTINF:4.200000,https://www.example.com/hls/live_00000.ts#EXTINF:4.166667,https://www.example.com/hls/live_00001.ts#EXTINF:3.600000,https://www.example.com/hls/live_00002.ts#EXTINF:2.516667,https://www.example.com/hls/live_00003.ts#EXTINF:4.166667,https://www.example.com/hls/live_00004.ts#EXTINF:4.166667,https://www.example.com/hls/live_00005.ts#EXTINF:4.166667,https://www.example.com/hls/live_00006.ts#EXTINF:1.716667,https://www.example.com/hls/live_00007.ts#EXT-X-ENDLIST</code></pre><p>各标签含义如下：</p><ul><li><code>#EXTM3U</code>：m3u文件头，必须放在第一行，起标示作用；</li><li><code>#EXT-X-VERSION</code>：播放列表文件的兼容版本。若不存在此标记，则默认为协议的第一个版本；</li><li><code>#EXT-X-MEDIA-SEQUENCE</code>： 播放列表中的每个媒体 URI 都有一个唯一的整数序列号。URI 的序列号等于它之前的 URI 的序列号加一；</li><li><code>#EXT-X-ALLOW-CACHE</code>：指示客户端是否可以缓存下载的媒体片段以供以后重播；</li><li><code>#EXT-X-KEY</code>：TS 片段可以被加密，该标签指定加密方式（METHOD）、密钥的 URI 以及偏移量 IV 等信息，没有此标签表示未加密；</li><li><code>#EXT-X-TARGETDURATION</code>：每一份 TS 媒体文件的最大持续时间，以秒为单位；</li><li><code>#EXTINF</code>：每一份媒体文件的详细信息，包括媒体持续时间、媒体 URL 地址等；</li><li><code>#EXT-X-ENDLIST</code>：表示不再将媒体片段添加到播放列表文件中，一般位于文件结尾。</li></ul><p>完整格式、标准标签可参考 HLS 标准协议中，对 Playlist file 的介绍：<a href="https://datatracker.ietf.org/doc/html/draft-pantos-http-live-streaming-08">https://datatracker.ietf.org/doc/html/draft-pantos-http-live-streaming-08</a></p><h2 id="SAZ-分析"><a href="#SAZ-分析" class="headerlink" title="SAZ 分析"></a>SAZ 分析</h2><p>在 Fiddler 软件中，使用 SAZ 格式用来保存和读取 HTTP/HTTPS 请求信息，打开该文件可以注意到一些重要的请求：script.bundle.js、live.m3u8、drm 以及八个 ts 视频流文件。</p><p>先来看看 m3u8 文件，可以看到是 AES-128 加密，加密的 key 文件地址为 <code>key://live</code>，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/082996c240d55cb83e787c489961d98b.png" alt="02.png"></p><p>一般情况下，要想解密 ts，必然会去请求 key 的地址，拿到 key 后再解密 ts，很显然此题的 key 地址不是一个合法的 URL 地址，当然此题的抓包记录可能是出题人伪造的，因为这个 Host 是 52tube.mmxxii，也不是一个合法的域名，最主要的是，抓包记录里没有 <code>key://live</code> 这条请求，那么很大概率真实的地址隐藏在 JS 里，从另一个方面来思考，如果这是完整的抓包记录，不管真实的 key 地址是啥，必然会在记录里出现！</p><p>有经验的朋友应该一眼就能看出来 drm 这条请求最有可能是拿 key 的操作了，第一是 drm 这个关键词在 ts 解密里经常会出现，搞得多的朋友应该见过不少，第二 ping 请求返回的 success，通过其名称和返回值来看也不像 key，剩下就只有 drm 了，查看返回值是乱码的，查看 Hex 值，32 位 16 进制数据，而正常的 key 应该是 16 位 16 进制数据，所以你如果直接拿这个数据当作 key 去解密，肯定也是失败的。</p><p>到这里我们应该有如下猜想：drm 返回的数据，经过了 script.bundle.js 二次处理就能得到正确的 key。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2bbab0520ed00218eebede697b3ab165.png" alt="03"></p><h2 id="JS-逆向"><a href="#JS-逆向" class="headerlink" title="JS 逆向"></a>JS 逆向</h2><p>我们把抓包记录的 script.bundle.js，右键，save - response - response body，保存到本地。</p><p>格式化之后有 15000+ 行代码，又不能动态调试，从哪里找加密入口呢？可以大胆尝试一下：</p><ul><li>JS 里可能会检测到 m3u8 里存在 key 的 URI 之后，发送 /api/drm/ 这个请求，可以直接搜索 <code>/api/drm/</code> 或者 <code>key://live</code> 定位；</li><li>drm 是一个 post 请求，带有 h 和 id 两个参数，可以直接搜索 <code>post</code>、<code>id</code>、<code>h</code> 定位到大致位置。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/ed46b7c9427b23de1fca4ce85d46f1f5.png" alt="04"></p><p>通过搜索可以发现如下可疑代码片段：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2dd7603630340ef2fd14cace1e7fc58e.png" alt="05"></p><p>将关键代码提炼一下：</p><pre><code class="javascript">function n(t) &#123;    return [...new Uint8Array(t)].map((t =&gt; t.toString(16).padStart(2, &quot;0&quot;))).join(&quot;&quot;)&#125;function s(t, e) &#123;    let r = new Uint8Array(t.length);    for (let i = 0; i &lt; t.length; i++) r[i] = t[i] ^ e[i];    return r&#125;let e = &quot;/api/ping/&quot;,    i = &quot;/api/drm/&quot;;class a extends t.DefaultConfig.loader &#123;    let e = await async function() &#123;        let t = new Uint8Array(16);        crypto.getRandomValues(t);        let e = n(t.buffer) + Date.now() + Math.random();        return new Uint8Array((await async function(t) &#123;            const e = (new TextEncoder).encode(t);            return await crypto.subtle.digest(&quot;SHA-256&quot;, e)        &#125; (e)).slice(0, 16))    &#125;();    var r = new URLSearchParams;    r.append(&quot;h&quot;, n(e.buffer)),        r.append(&quot;id&quot;, t);    var a = &#123;        method: &quot;POST&quot;,        headers: &#123;            &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;        &#125;,        body: r    &#125;;    let o = await fetch(i, a),        l = await o.arrayBuffer();    if (32 !== l.byteLength) throw new Error(&quot;Invalid response&quot;);    let u = new Uint8Array(l.slice(0, 16)),        c = new Uint8Array(l.slice(16, 32));    return s(s(u, e), c)&#125;</code></pre><p>可以看到事实上在发送 <code>/api/drm/</code> 请求拿到结果后，先后取前后 16 位数据，然后经过了 s 方法的处理，最后返回的 <code>s(s(u, e), c)</code> 应该才是正确的 key，这里的重点在于 e 的值，上面有个方法，取了当前时间+随机值，经过 SHA-256 加密，再取前 16 位。</p><p>这里可以思考一下，这个 e 的值是不固定的，那么最后的 key 应该也是不固定的，同一个 TS 对应有无数个 key，我反正是没见过，不信的话尝试就用那个方法生成 e，你会发现最终的 key 是错误的。</p><p>仔细看一下，发送 post 请求对 h 值赋值的地方：<code>r.append(&quot;h&quot;, n(e.buffer))</code>，n 方法是转 16 进制，那么我们直接将 h 值倒推，从16进制转为10进制，这才是正确的 e 的值！然后 l 的值是 <code>/api/drm/</code> 请求返回的 32 位 16 进制数据转为 10 进制，剩下的就好说了，直接改写一下 JS 代码拿到正确的 key：</p><pre><code class="javascript">function s(t, e) &#123;    let r = new Uint8Array(t.length);    for (let i = 0; i &lt; t.length; i++)        r[i] = t[i] ^ e[i];    return r&#125;function getKey()&#123;    // /api/drm/ 请求表单的 h 值，16进制数据    const h = [&quot;7b&quot;, &quot;10&quot;, &quot;31&quot;, &quot;1e&quot;, &quot;6e&quot;, &quot;31&quot;, &quot;0f&quot;, &quot;0d&quot;, &quot;f0&quot;, &quot;68&quot;, &quot;d9&quot;, &quot;ed&quot;, &quot;e1&quot;, &quot;04&quot;, &quot;75&quot;, &quot;a8&quot;];    // /api/drm/ 请求返回的32位16进制数据    const drm = [&quot;08&quot;, &quot;A5&quot;, &quot;E6&quot;, &quot;C2&quot;, &quot;C2&quot;, &quot;61&quot;, &quot;A8&quot;, &quot;AC&quot;, &quot;B4&quot;, &quot;D7&quot;, &quot;9C&quot;, &quot;49&quot;, &quot;AF&quot;, &quot;16&quot;, &quot;0A&quot;, &quot;3A&quot;, &quot;DA&quot;, &quot;4E&quot;, &quot;5C&quot;, &quot;EA&quot;, &quot;E1&quot;, &quot;6F&quot;, &quot;ED&quot;, &quot;46&quot;, &quot;EB&quot;, &quot;6F&quot;, &quot;49&quot;, &quot;8C&quot;, &quot;9B&quot;, &quot;63&quot;, &quot;D5&quot;, &quot;3B&quot;]    // 转换为10进制数据，为 e 和 l 赋值    const e = [];    const l = [];    for (let i=0; i&lt;h.length; i++)    &#123;        e.push(parseInt(h[i],16))    &#125;    for (let i=0; i&lt;drm.length; i++)    &#123;        l.push(parseInt(drm[i],16))    &#125;    const u = new Uint8Array(l.slice(0, 16));    const c = new Uint8Array(l.slice(16, 32));    const keyArray = s(s(u, e), c);    const keyHex = new Buffer.from(keyArray).toString(&#39;hex&#39;);    const keyBase64 = new Buffer.from(keyArray).toString(&#39;base64&#39;);    console.log(&quot;keyArray: &quot;, keyArray)    console.log(&quot;keyHex: &quot;, keyHex)    console.log(&quot;keyBase64: &quot;, keyBase64)&#125;getKey()// 输出// keyArray:  Uint8Array(16) [//   169, 251, 139,  54,  77,//    63,  74, 231, 175, 208,//    12,  40, 213, 113, 170,//   169// ]// keyHex:  a9fb8b364d3f4ae7afd00c28d571aaa9// keyBase64:  qfuLNk0/Suev0Awo1XGqqQ==</code></pre><h2 id="TS-解密合并转换"><a href="#TS-解密合并转换" class="headerlink" title="TS 解密合并转换"></a>TS 解密合并转换</h2><p>通过 JS 逆向我们拿到了 16进制和 base64 形式的  key，不管什么形式都可以拿来解密，这里介绍两种对 TS 媒体流解密、合并、转换的方法。</p><p>第一种方法是使用 FFmpeg 工具，FFmpeg 是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。官网地址：<a href="https://ffmpeg.org/">https://ffmpeg.org/</a> ，下载编译好的程序，将 bin 目录添加到环境变量即可。</p><p>首先我们要把 m3u8 文件和 ts 媒体流保存到同一个文件夹，由于是虚假的 Host，所以不能直接浏览器访问保存，可以直接在 Fiddler 里，右键，save - response - response body，保存到本地，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/749cfe83e0a6e2fc1abc53d6f014af20.png" alt="06"></p><p>然后就是保存密钥文件，这里要求密钥文件必须是16进制的数据，如果你直接将 key 以字符串形式保存的话，解密也是失败的，编辑 16 进制文件有专门的工具，比如 HxD、010 editor、winhex 等，以 HxD 为例，新建文件，写入我们前面通过 JS 逆向得到的 key 的 16 进制数据，存为 .key 文件，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c967091a3fe77ae7e1431d7611b724aa.png" alt="07"></p><p>然后修改 m3u8 文件里 key 的地址、名称，建议将 key、m3u8、ts 文件都放同一个文件夹，这样 m3u8 文件里就不用添加资源路径了，不容易出错。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bc34af23050758b3b320b24f057bdfb9.png" alt="08"></p><p>然后在当前文件夹，打开命令行输入命令：<code>ffmpeg -allowed_extensions ALL -i live.m3u8 -c copy live.mp4</code>，即可自动解密 ts，并合并转换为 .mp4 格式：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0a7a0cf737aeae4d01bc9217e07c60f1.png" alt="09"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/db9fdff0a45c6d41333c6d475a12ae08.png" alt="10"></p><p>第二种方法就是使用大佬写的第三方小工具，这里推荐吾爱大佬逍遥一仙写的 M3U8 批量下载器，下载地址、使用方法见原贴：<a href="https://www.52pojie.cn/thread-1374045-1-1.html">https://www.52pojie.cn/thread-1374045-1-1.html</a></p><p>我们可以直接拖入处理好的 M3U8 文件，自动处理：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/985f2c1a952e14b41d264c5e172092be.png" alt="11"></p><p>也可以选择其他 - 工具 - 合并助手，添加所有 TS 文件，输入 key 后自动处理：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/71c5a02310dcc053f385d80116196775.png" alt="12"></p><p>处理完毕后的 mp4 文件默认在软件目录的 output 文件夹里面，解密后是一段动画，往后看会找到 flag：<code>flag&#123;like_sub_52tube&#125;</code> 为正确答案。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/270c7e60d56bc2ea20a33f11c1eb042f.png" alt="13"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/362caaedb5b649cfd650aefd326ae615.png" alt="14"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4dd28112ed306fd0ba26f946f8531891.png" alt="15"></p>]]></content>
      
      
      <categories>
          
          <category> JS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS 逆向 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF&amp;爬虫：掌握这些特征，一秒识别密文加密方式</title>
      <link href="/article/045/"/>
      <url>/article/045/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>爬虫工程师在做加密参数逆向的时候，经常会遇到各种各样的加密算法、编码、混淆，每个算法都有其对应的特征，对于一些较小的网站，往往直接引用这些官方算法，没有进行魔改等其他操作，这种情况下，如果我们能熟悉常见算法的特征，通过密文就能猜测出使用的哪种算法、编码、混淆，将会大大提高工作效率！在 CTF 中通常也会有密码类的题目，掌握一些常见密文特征也是 CTFer 们必备的技能！</p><p>本文将介绍以下编码和加密算法的特征：</p><ul><li>编码：Base 系列、Unicode、Escape、URL、Hex；</li><li>算法：MD5、SHA 系列、HMAC 系列、RSA、AES、DES、3DES、RC4、Rabbit、SM 系列；</li><li>混淆：Obfuscator、JJEncode、AAEncode、JSFuck、Jother、Brainfuck、Ook!、Trivial brainfuck substitution；</li><li>其他：恺撒密码、栅栏密码、猪圈密码、摩斯密码、培根密码、维吉尼亚密码、与佛论禅、当铺密码。</li></ul><p>PS：常见加密算法原理以及在 Python 和 JavaScript 中的实现方法可参见以前的文章：<a href="https://www.itbob.cn/article/039/">爬虫常见加密解密算法总结</a></p><h2 id="编码系列"><a href="#编码系列" class="headerlink" title="编码系列"></a>编码系列</h2><h3 id="Base-系列编码"><a href="#Base-系列编码" class="headerlink" title="Base 系列编码"></a>Base 系列编码</h3><p>Base64 是我们最常见的编码，除此之外，其实还有 Base16、Base32、Base58、Base85、Base100 等，他们之间最明显的区别就是使用了不同数量的可打印字符对任意字节数据进行编码，比如 Base64 使用了64个可打印字符（A-Z、a-z、0-9、+、/），Base16 使用了16个可打印字符（A-F、0-9），这里主要讲怎么快速识别，其具体原理可自行百度，Base 系列主要特征如下：</p><ul><li>Base16：结尾没有等号，数字要多于字母；</li><li>Base32：字母要多于数字，明文数量超过10个，结尾可能会有很多等号；</li><li>Base58：结尾没有等号，字母要多于数字；</li><li>Base64：一般情况下结尾都会有1个或者2个等号，明文很少的时候可能没有；</li><li>Base85：等号一般出现在字符串中间，含有一些奇怪的字符；</li><li>Base100：密文由 Emoji 表情组成。</li></ul><p>示例：</p><table><thead><tr><th align="left">编码类型</th><th align="left">示例一</th><th>示例二</th></tr></thead><tbody><tr><td align="left">明文</td><td align="left">01234567890</td><td>administrators</td></tr><tr><td align="left">Base16</td><td align="left"><code>3031323334353637383930</code></td><td><code>61646D696E6973747261746F7273</code></td></tr><tr><td align="left">Base32</td><td align="left"><code>GAYTEMZUGU3DOOBZGA======</code></td><td><code>MFSG22LONFZXI4TBORXXE4Y=</code></td></tr><tr><td align="left">Base58</td><td align="left"><code>cX8j8pvGzppMKVb</code></td><td><code>BNF5dFLUTN5XwM1yLoF</code></td></tr><tr><td align="left">Base64</td><td align="left"><code>MDEyMzQ1Njc4OTA=</code></td><td><code>YWRtaW5pc3RyYXRvcnM=</code></td></tr><tr><td align="left">Base85</td><td align="left"><code>0JP==1c70M3&amp;rY</code></td><td><code>@:X4hDJ=06Eaa&#39;.EcV</code></td></tr><tr><td align="left">Base100</td><td align="left"><code>🐧🐨🐩🐪🐫🐬🐭🐮🐯🐰🐧</code></td><td><code>👘👛👤👠👥👠👪👫👩👘👫👦👩👪</code></td></tr></tbody></table><h3 id="Unicode-编码"><a href="#Unicode-编码" class="headerlink" title="Unicode 编码"></a>Unicode 编码</h3><p>Unicode 又称为统一码、万国码、单一码，是一种在计算机上使用的字符编码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。其主要特征如下：</p><ul><li>以 <code>\u</code>、<code>&amp;#</code> 或 <code>&amp;#x</code> 开头，后面是数字加字母组合</li></ul><p>PS：<code>\u</code> 开头和 <code>&amp;#x</code> 开头是一样的，都是16进制 Unicode 字符的不同写法，<code>&amp;#</code> 则是 Unicode 字符10进制的写法，此外，<code>&amp;#</code> 和 <code>&amp;#x</code> 开头的，也称为 HTML 字符实体转换，字符实体是用一个编号写入 HTML 代码中来代替一个字符，在 HTML 中，某些字符是预留的，如果希望正确地显示预留字符，就必须在 HTML 源代码中使用字符实体。</p><table><thead><tr><th>编码类型</th><th>示例一</th><th>示例二</th></tr></thead><tbody><tr><td>明文</td><td>12345</td><td>admin</td></tr><tr><td>Unicode</td><td><code>\u0031\u0032\u0033\u0034\u0035</code></td><td><code>\u0061\u0064\u006d\u0069\u006e</code></td></tr></tbody></table><h3 id="Escape-编码"><a href="#Escape-编码" class="headerlink" title="Escape 编码"></a>Escape 编码</h3><p>Escape 编码又叫 %u 编码，Escape 编码就是字符对应 UTF-16BE 表示方式前面加 %u，Escape 不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： <code>* @ - _ + . / </code>，其他所有的字符都会被转义序列替换。其主要特征如下：</p><ul><li>以 <code>%u</code> 开头，后面是数字加字母组合</li></ul><table><thead><tr><th>编码类型</th><th>示例一</th><th>示例二</th></tr></thead><tbody><tr><td>明文</td><td>爬虫</td><td>我爱Python</td></tr><tr><td>Escape</td><td><code>%u722C%u866B</code></td><td><code>%u6211%u7231Python</code></td></tr></tbody></table><h3 id="URL-Hex-编码"><a href="#URL-Hex-编码" class="headerlink" title="URL / Hex 编码"></a>URL / Hex 编码</h3><p>URL 和 Hex 编码的结果是一样的，不同的是当你用 URL 编码网址时是不会把 <code>http</code>、<code>https</code> 关键字和 <code>/</code>、<code>?</code>、<code>&amp;</code>、<code>=</code> 等连接符进行编码的，而 Hex 编码则全部转化了，其主要特征如下：</p><ul><li>以 <code>%</code> 开头，后面是数字加字母组合</li></ul><table><thead><tr><th>编码类型</th><th>示例</th></tr></thead><tbody><tr><td>明文</td><td><a href="https://www.kuaidaili.com/">https://www.kuaidaili.com/</a></td></tr><tr><td>Unicode</td><td><code>https://%77%77%77%2E%6B%75%61%69%64%61%69%6C%69%2E%63%6F%6D/</code></td></tr><tr><td>Hex</td><td><code>%68%74%74%70%73%3a%2f%2f%77%77%77%2e%6b%75%61%69%64%61%69%6c%69%2e%63%6f%6d%2f</code></td></tr></tbody></table><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p>MD5 实质是一种消息摘要算法，一个数据的 MD5 值是唯一的，同一个数据不可能计算出多个不同的 MD5 值，但是，不同数据计算出来的 MD5 值是有可能一样的，知道一个 MD5 值，理论上是无法还原出它的原始数据的，MD5 是最容易辨别的，主要特征如下：</p><ul><li>密文一般为 16 位或者 32 位，其中 16 位是取的 32 位第 9~25 位的值；</li><li>组成方式为字母（a-f）和数字（0-9）混合，字母可以全部是大写或者小写。</li></ul><p>除了通过密文特征来判断以外，我们还可以搜索源代码，标准 MD5 的源码里是包含了一些特定的值的，没有这些特定值，就无法实现 MD5：</p><ul><li><code>0123456789ABCDEF</code>、<code>0123456789abcdef</code></li><li><code>1732584193</code>、<code>-271733879</code>、<code>-1732584194</code>、<code>271733878</code></li></ul><p>PS：某些特殊情况下，密文的长度也有可能不止 16 位或者 32 位，有可能是在官方算法上有一些魔改，通常也是在 16 位的基础上，左右填充了一些随机字符串。</p><p>示例：</p><table><thead><tr><th>编码类型</th><th>示例一</th><th>示例二</th></tr></thead><tbody><tr><td>明文</td><td>123456</td><td>admin</td></tr><tr><td>MD5（16位小写）</td><td><code>49ba59abbe56e057</code></td><td><code>7a57a5a743894a0e</code></td></tr><tr><td>MD5（16位大写）</td><td><code>49BA59ABBE56E057</code></td><td><code>7A57A5A743894A0E</code></td></tr><tr><td>MD5（32位小写）</td><td><code>e10adc3949ba59abbe56e057f20f883e</code></td><td><code>21232f297a57a5a743894a0e4a801fc3</code></td></tr><tr><td>MD5（32位大写）</td><td><code>E10ADC3949BA59ABBE56E057F20F883E</code></td><td><code>21232F297A57A5A743894A0E4A801FC3</code></td></tr></tbody></table><h3 id="SHA-系列"><a href="#SHA-系列" class="headerlink" title="SHA 系列"></a>SHA 系列</h3><p>SHA 是比 MD5 更安全一点的摘要算法，SHA 通常指 SHA 家族算法，分别是 SHA-1、SHA-2、SHA-3，其中 SHA-2 是 SHA-224、SHA-256、SHA-384、SHA-512 的并称，SHA-3 是 SHA3-224、SHA3-256、SHA3-384、SHA3-512、SHAKE128、SHAKE256 的并称，其名字的后缀的数字就代表了结果的大小（bit），注意，SHAKE 算法结果的大小并不是固定的，其他算法特征如下：</p><ul><li>SHA-1：字母（a-f）和数字（0-9）混合，固定位数 40 位；</li><li>SHA-224/SHA3-224：字母（a-f）和数字（0-9）混合，固定位数 56 位；</li><li>SHA-256/SHA3-256：字母（a-f）和数字（0-9）混合，固定位数 64 位；</li><li>SHA-384/SHA3-384：字母（a-f）和数字（0-9）混合，固定位数 96 位；</li><li>SHA-512/SHA3-512：字母（a-f）和数字（0-9）混合，固定位数 128 位。</li></ul><p>示例：</p><table><thead><tr><th>编码类型</th><th>示例</th></tr></thead><tbody><tr><td>明文</td><td>123456</td></tr><tr><td>SHA-1</td><td><code>7c4a8d09ca3762af61e59520943dc26494f8941b</code></td></tr><tr><td>SHA-256</td><td><code>8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92</code></td></tr><tr><td>SHA3-256</td><td><code>c888c9ce9e098d5864d3ded6ebcc140a12142263bace3a23a36f9905f12bd64a</code></td></tr></tbody></table><h3 id="HMAC-系列"><a href="#HMAC-系列" class="headerlink" title="HMAC 系列"></a>HMAC 系列</h3><p>HMAC 这种算法就是在 MD5、SHA 两种加密的基础上引入了秘钥，其密文也和 MD5、SHA 类似，密文的长度和使用的 MD5、SHA 算法对应密文的长度是一样的。特征如下：</p><ul><li>HMAC-MD5：字母（a-f）和数字（0-9）混合，位数一般为 32 位；</li><li>HMAC-SHA-1：字母（a-f）和数字（0-9）混合，固定位数 40 位；</li><li>HMAC-SHA-224 / HMAC-SHA3-224：字母（a-f）和数字（0-9）混合，固定位数 56 位；</li><li>HMAC-SHA-256 / HMAC-SHA3-256：字母（a-f）和数字（0-9）混合，固定位数 64 位；</li><li>HMAC-SHA-384 / HMAC-SHA3-384：字母（a-f）和数字（0-9）混合，固定位数 96 位；</li><li>HMAC-SHA-512 / HMAC-SHA3-512：字母（a-f）和数字（0-9）混合，固定位数 128 位。</li></ul><p>HMAC 和 SHA、MD5 的密文都很像，当无法确定是否为 HMAC 时，可以通过其名称搜索到加密方法，如果传入了密钥 key，说明就是 HMAC，当然你也可以直接当做是 SHA 或 MD5 来解，解密失败时就得考虑是否有密钥，是否为 HMAC 了，在 JS 中，通常一个 HMAC 加密方法是这样写的：</p><pre><code class="javascript">function HmacSHA1Encrypt(word, key) &#123;    return CryptoJS.HmacSHA1(word, key).toString();&#125;</code></pre><p>示例（密钥 123456abcde）：</p><table><thead><tr><th>编码类型</th><th>示例</th></tr></thead><tbody><tr><td>明文</td><td>123456</td></tr><tr><td>HMAC-MD5</td><td><code>432bb95bb00005ddce4a1c757488ed95</code></td></tr><tr><td>HMAC-SHA-1</td><td><code>37a04076b7736c44460d330ee0d00014428b175e</code></td></tr><tr><td>HMAC-SHA-256</td><td><code>50cb1345366df11140fb91b43caaf69627e3f5529705ddf6b0d0cae67986e585</code></td></tr><tr><td>HMAC-SHA3-256</td><td><code>b808ed9f66436e89fba527a01d1d6044318fea8599d9f39bfb6bec4843964bf3</code></td></tr></tbody></table><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>RSA 加密算法是一种非对称加密算法，通过公钥加密结果，必须私钥解密。 同样私钥加密结果，公钥可以解密，应用非常广泛，在网站中通常使用 JSEncrypt 库来实现，其最大的特征就是有一个设置公钥的过程，我们可以通过以下方法来快速初步判断是否为 RSA 算法：</p><ul><li><p>搜索关键词 <code>new JSEncrypt()</code>，<code>JSEncrypt</code> 等，一般会使用 JSEncrypt 库，会有 new 一个实例对象的操作；</p></li><li><p>搜索关键词 <code>setPublicKey</code>、<code>setKey</code>、<code>setPrivateKey</code>、<code>getPublicKey</code> 等，一般实现的代码里都含有设置密钥的过程；</p></li><li><p>RSA 的私钥、公钥、明文、密文长度也有一定对应关系，也可以从这方面初步判断：</p><table><thead><tr><th align="left">私钥长度（Base64）</th><th align="left">公钥长度（Base64）</th><th align="left">明文长度</th><th align="left">密文长度</th></tr></thead><tbody><tr><td align="left">428</td><td align="left">128</td><td align="left">1~53</td><td align="left">88</td></tr><tr><td align="left">812</td><td align="left">216</td><td align="left">1~117</td><td align="left">172</td></tr><tr><td align="left">1588</td><td align="left">392</td><td align="left">1~245</td><td align="left">344</td></tr></tbody></table></li></ul><h3 id="AES、DES、3DES、RC4、Rabbit-等"><a href="#AES、DES、3DES、RC4、Rabbit-等" class="headerlink" title="AES、DES、3DES、RC4、Rabbit 等"></a>AES、DES、3DES、RC4、Rabbit 等</h3><p>AES、DES、3DES、RC4、Rabbit 等加密算法的密文通常没有固定的长度，他们通常使用 crypto-js 来实现，比如 AES 加解密示例如下：</p><pre><code class="javascript">CryptoJS = require(&quot;crypto-js&quot;)var key = CryptoJS.enc.Utf8.parse(&quot;0123456789abcdef&quot;);var iv = CryptoJS.enc.Utf8.parse(&quot;0123456789abcdef&quot;);function AESEncrypt(word) &#123;    var srcs = CryptoJS.enc.Utf8.parse(word);    var encrypted = CryptoJS.AES.encrypt(srcs, key, &#123;        iv: iv,        mode: CryptoJS.mode.CBC,        padding: CryptoJS.pad.Pkcs7    &#125;);    return encrypted.toString();&#125;function AESDecrypt(word) &#123;    var srcs = word;    var decrypt = CryptoJS.AES.decrypt(srcs, key, &#123;        iv: iv,        mode: CryptoJS.mode.CBC,        padding: CryptoJS.pad.Pkcs7    &#125;);    return decrypt.toString(CryptoJS.enc.Utf8);&#125;console.log(AESEncrypt(&quot;K哥爬虫&quot;))console.log(AESDecrypt(&quot;nSk3wCd92s08sQ9N+VHNvA==&quot;))</code></pre><p>在 crypto-js 中，也有一些特定的关键字，我们可以通过搜索这些关键字来快速定位到 crypto-js：</p><ul><li><p><code>CryptoJS</code>、<code>crypto-js</code>、<code>iv</code>、<code>mode</code>、<code>padding</code>、<code>createEncryptor</code>、<code>createDecryptor</code></p></li><li><p><code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=</code>、<code>0xffffffff</code>、<code>0xffff</code></p></li></ul><p>定位到 CryptoJS 后，观察加密方法，比如 AES 就是 <code>CryptoJS.AES.encrypt</code>，DES 就是 <code>CryptoJS.DES.encrypt</code>，3DES 就是 <code>CryptoJS.TripleDES.encrypt</code>，注意他的 iv、mode、padding，拿下来就可以本地复现了。</p><h3 id="SM-系列"><a href="#SM-系列" class="headerlink" title="SM 系列"></a>SM 系列</h3><p>SM 代表商密，即商业密码，是我国发布的一系列国产加密算法，SM 系列包括：SM1、SM2、SM3 、SM4、SM7、SM9，其中 SM1 和 SM7 的算法不公开，SM 系列算法在我国一些 gov 网站上有应用，有关国产加密算法前期文章有介绍：<a href="https://www.itbob.cn/article/041/">《认识 SM1/SM2/SM3/SM4/SM7/SM9/ZUC 国密算法》</a>，本文不再赘述。</p><p>在 SM 的 JavaScript 代码中一般会存在以下关键字，可以通过搜索关键字定位：</p><ul><li><code>SM2</code>、<code>SM3</code>、<code>SM4</code></li><li><code>FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF</code></li><li><code>FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC</code></li><li><code>28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93</code></li><li><code>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789</code></li><li><code>getPublicKeyFromPrivateKey</code>、<code>doEncrypt</code>、<code>doDecrypt</code>、<code>doSignature</code></li></ul><h2 id="混淆系列"><a href="#混淆系列" class="headerlink" title="混淆系列"></a>混淆系列</h2><h3 id="Obfuscator"><a href="#Obfuscator" class="headerlink" title="Obfuscator"></a>Obfuscator</h3><p>Obfuscator 就是混淆的意思，简称 OB 混淆，实战可参考以前的文章：<a href="https://itrhx.blog.csdn.net/article/details/121719631">【JS 逆向百例】W店UA，OB反混淆，抓包替换CORS跨域错误分析</a>，OB 混淆具有以下特征：</p><ul><li>一般由一个大数组或者含有大数组的函数、一个自执行函数、解密函数和加密后的函数四部分组成；</li><li>函数名和变量名通常以 <code>_0x</code> 或者 <code>0x</code> 开头，后接 1~6 位数字或字母组合；</li><li>自执行函数，进行移位操作，有明显的 push、shift 关键字；</li></ul><p>一段正常的代码如下：</p><pre><code class="javascript">function hi() &#123;  console.log(&quot;Hello World!&quot;);&#125;hi();</code></pre><p>经过 OB 混淆后的结果：</p><pre><code class="javascript">function _0x3f26() &#123;    var _0x2dad75 = [&#39;5881925kTCKCP&#39;, &#39;Hello\x20World!&#39;, &#39;600mDvfGa&#39;, &#39;699564jYNxbu&#39;, &#39;1083271cEvuvT&#39;, &#39;log&#39;, &#39;18sKjcFY&#39;, &#39;214857eMgFSU&#39;, &#39;77856FUKcuE&#39;, &#39;736425OzpdFI&#39;, &#39;737172JqcGMg&#39;];    _0x3f26 = function () &#123;        return _0x2dad75;    &#125;;    return _0x3f26();&#125;(function (_0x307c88, _0x4f8223) &#123;    var _0x32807d = _0x1fe9, _0x330c58 = _0x307c88();    while (!![]) &#123;        try &#123;            var _0x5d6354 = parseInt(_0x32807d(0x6f)) / 0x1 + parseInt(_0x32807d(0x6e)) / 0x2 + parseInt(_0x32807d(0x70)) / 0x3 + -parseInt(_0x32807d(0x69)) / 0x4 + parseInt(_0x32807d(0x71)) / 0x5 + parseInt(_0x32807d(0x6c)) / 0x6 * (parseInt(_0x32807d(0x6a)) / 0x7) + -parseInt(_0x32807d(0x73)) / 0x8 * (parseInt(_0x32807d(0x6d)) / 0x9);            if (_0x5d6354 === _0x4f8223) break; else _0x330c58[&#39;push&#39;](_0x330c58[&#39;shift&#39;]());        &#125; catch (_0x3f18e4) &#123;            _0x330c58[&#39;push&#39;](_0x330c58[&#39;shift&#39;]());        &#125;    &#125;&#125;(_0x3f26, 0xaa023));function _0x1fe9(_0xa907e7, _0x410a46) &#123;    var _0x3f261f = _0x3f26();    return _0x1fe9 = function (_0x1fe950, _0x5a08da) &#123;        _0x1fe950 = _0x1fe950 - 0x69;        var _0x82a06 = _0x3f261f[_0x1fe950];        return _0x82a06;    &#125;, _0x1fe9(_0xa907e7, _0x410a46);&#125;function hi() &#123;    var _0x12a222 = _0x1fe9;    console[_0x12a222(0x6b)](_0x12a222(0x72));&#125;hi();</code></pre><h3 id="JJEncode"><a href="#JJEncode" class="headerlink" title="JJEncode"></a>JJEncode</h3><p>JJEncode、AAEncode、JSFuck 都是同一个作者，实战可参考以前的文章：<a href="https://itrhx.blog.csdn.net/article/details/121920783">【JS 逆向百例】网洛者反爬练习平台第二题：JJEncode 加密</a>，JJEncode 具有以下特征：</p><ul><li>大量 <code>$</code>、<code>_</code> 符号，大量重复的自定义变量；</li><li>仅由 18 个符号组成：<code>[]()!+,\&quot;$.:;_&#123;&#125;~=</code></li></ul><p>正常的一段 JS 代码：</p><pre><code class="javascript">alert(&quot;Hello, JavaScript&quot; )</code></pre><p>经过 JJEncode 混淆（自定义变量名为 $）之后的代码：</p><pre><code class="javascript">$=~[];$=&#123;___:++$,$$$$:(![]+&quot;&quot;)[$],__$:++$,$_$_:(![]+&quot;&quot;)[$],_$_:++$,$_$$:(&#123;&#125;+&quot;&quot;)[$],$$_$:($[$]+&quot;&quot;)[$],_$$:++$,$$$_:(!&quot;&quot;+&quot;&quot;)[$],$__:++$,$_$:++$,$$__:(&#123;&#125;+&quot;&quot;)[$],$$_:++$,$$$:++$,$___:++$,$__$:++$&#125;;$.$_=($.$_=$+&quot;&quot;)[$.$_$]+($._$=$.$_[$.__$])+($.$$=($.$+&quot;&quot;)[$.__$])+((!$)+&quot;&quot;)[$._$$]+($.__=$.$_[$.$$_])+($.$=(!&quot;&quot;+&quot;&quot;)[$.__$])+($._=(!&quot;&quot;+&quot;&quot;)[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$=$.$+(!&quot;&quot;+&quot;&quot;)[$._$$]+$.__+$._+$.$+$.$$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$$+&quot;\&quot;&quot;+$.$_$_+(![]+&quot;&quot;)[$._$_]+$.$$$_+&quot;\\&quot;+$.__$+$.$$_+$._$_+$.__+&quot;(\\\&quot;\\&quot;+$.__$+$.__$+$.___+$.$$$_+(![]+&quot;&quot;)[$._$_]+(![]+&quot;&quot;)[$._$_]+$._$+&quot;,\\&quot;+$.$__+$.___+&quot;\\&quot;+$.__$+$.__$+$._$_+$.$_$_+&quot;\\&quot;+$.__$+$.$$_+$.$$_+$.$_$_+&quot;\\&quot;+$.__$+$._$_+$._$$+$.$$__+&quot;\\&quot;+$.__$+$.$$_+$._$_+&quot;\\&quot;+$.__$+$.$_$+$.__$+&quot;\\&quot;+$.__$+$.$$_+$.___+$.__+&quot;\\\&quot;\\&quot;+$.$__+$.___+&quot;)&quot;+&quot;\&quot;&quot;)())();</code></pre><h3 id="AAEncode"><a href="#AAEncode" class="headerlink" title="AAEncode"></a>AAEncode</h3><p>JJEncode、AAEncode、JSFuck 都是同一个作者，实战可参考以前的文章：<a href="https://itrhx.blog.csdn.net/article/details/121920864">【JS 逆向百例】网洛者反爬练习平台第三题：AAEncode 加密</a>，AAEncode 具有以下特征：</p><ul><li>仅由日式表情符号组成</li></ul><p>正常的一段 JS 代码：</p><pre><code class="javascript">alert(&quot;Hello, JavaScript&quot;)</code></pre><p>经过 AAEncode 混淆之后的代码：</p><pre><code class="javascript">ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ [&#39;_&#39;]; o=(ﾟｰﾟ)  =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)=&#123;ﾟΘﾟ: &#39;_&#39; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&#39;_&#39;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &#39;_&#39;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&#39;_&#39;)[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&#39;_&#39;) [c^_^o];(ﾟДﾟ) [&#39;c&#39;] = ((ﾟДﾟ)+&#39;_&#39;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&#39;o&#39;] = ((ﾟДﾟ)+&#39;_&#39;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [&#39;c&#39;]+(ﾟДﾟ) [&#39;o&#39;]+(ﾟωﾟﾉ +&#39;_&#39;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&#39;_&#39;) [ﾟｰﾟ] + ((ﾟДﾟ) +&#39;_&#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&#39;_&#39;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&#39;c&#39;]+((ﾟДﾟ)+&#39;_&#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&#39;o&#39;]+((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ];(ﾟДﾟ) [&#39;_&#39;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&#39;_&#39;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&#39;_&#39;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&#39;_&#39;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&#39;\\&#39;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +&#39;_&#39;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=&#39;\&quot;&#39;;(ﾟДﾟ) [&#39;_&#39;] ( (ﾟДﾟ) [&#39;_&#39;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&#39;_&#39;);</code></pre><h3 id="JSFuck"><a href="#JSFuck" class="headerlink" title="JSFuck"></a>JSFuck</h3><p>JJEncode、AAEncode、JSFuck 都是同一个作者，实战可参考以前的文章：<a href="https://itrhx.blog.csdn.net/article/details/122057377">【JS 逆向百例】网洛者反爬练习平台第四题：JSFuck 加密</a>，JSFuck 具有以下特征：</p><ul><li>仅由 6 个符号组成：<code>[]()!+</code></li></ul><p>正常的一段 JS 代码：</p><pre><code class="javascript">alert(1)</code></pre><p>经过 JSFuck 混淆之后的代码类似于：</p><pre><code class="javascript">[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(+(!+[]+!+[]+!+[]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]])+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]])()((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[+!+[]+[!+[]+!+[]+!+[]]]+[+!+[]]+([+[]]+![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[!+[]+!+[]+[+[]]])</code></pre><h3 id="Jother"><a href="#Jother" class="headerlink" title="Jother"></a>Jother</h3><p>Jother 混淆和 JSFuck 有点儿类似，唯一的区别就是密文比 JSFuck 多了 <code>&#123;&#125;</code>，其解密方式和 JSFuck 是一样的，Jother 混淆现在不太常见了，也很难找到在线混淆之类的工具了，原作者有个在线页面也关闭了，不过仍然可以了解一下，Jother 混淆具有以下特征：</p><ul><li>仅由 8 个符号组成：<code>[]()!+&#123;&#125;</code></li></ul><p>正常的一段代码：</p><pre><code class="javascript">function anonymous() &#123;return location&#125;</code></pre><p>经过 Jother 混淆之后的代码类似于：</p><pre><code class="javascript">[][(![]+[])[!![]+!![]+!![]]+(&#123;&#125;+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]]+(&#123;&#125;+[])[+!![]]+(&#123;&#125;[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+(&#123;&#125;[[]]+[])[+[]]+(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+(&#123;&#125;+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(&#123;&#125;[[]]+[])[+[]]+(!![]+[])[+!![]]+(&#123;&#125;[[]]+[])[+!![]]+(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+(&#123;&#125;+[])[+!![]]+(&#123;&#125;+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+(&#123;&#125;[[]]+[])[!![]+!![]+!![]+!![]+!![]]+(&#123;&#125;+[])[+!![]]+(&#123;&#125;[[]]+[])[+!![]])()</code></pre><h3 id="Brainfuck"><a href="#Brainfuck" class="headerlink" title="Brainfuck"></a>Brainfuck</h3><p>Brainfuck 实际上是一种极小化的计算机语言，又称为 BF 语言，该语言以其极简主义着称，仅包含八个简单的命令、一个数据指针和一个指令指针，这种语言在爬虫领域也可以是一种反爬手段，可以视为一种混淆方式，虽然不常见🤔，这里给一个在线体验的网址：<a href="https://copy.sh/brainfuck/text.html">https://copy.sh/brainfuck/text.html</a> ，感兴趣的同志可以深入研究一下，Brainfuck 具有以下特征：</p><ul><li>仅由 <code>&lt;&gt;+-.[]</code> 组成；</li><li>大量的 <code>+-</code> 符号。</li></ul><p>正常的一段代码：</p><pre><code class="javascript">alert(&quot;Hello, Brainfuck&quot;)</code></pre><p>经过 Brainfuck 混淆之后的代码类似于：</p><pre><code class="javascript">--[-----&gt;+&lt;]&gt;-----.+++++++++++.-------.+++++++++++++.++.+[---&gt;+&lt;]&gt;+.------.++[-&gt;++&lt;]&gt;.-[-&gt;+++++&lt;]&gt;++.+++++++..+++.[-&gt;+++++&lt;]&gt;+.------------.+[-&gt;++&lt;]&gt;.---[-----&gt;+&lt;]&gt;-.+++[-&gt;+++&lt;]&gt;++.++++++++.+++++.--------.-[---&gt;+&lt;]&gt;--.+[-&gt;+++&lt;]&gt;+.++++++++.+[++&gt;---&lt;]&gt;.+++++++.</code></pre><h3 id="Ook"><a href="#Ook" class="headerlink" title="Ook!"></a>Ook!</h3><p>Ook! 和 Brainfuck 的原理都是类似的，只不过符号有差异，同样的，这种语言在爬虫领域也可以是一种反爬手段，可以视为一种混淆方式，虽然不常见🤔，在线体验的网址：<a href="https://www.splitbrain.org/services/ook">https://www.splitbrain.org/services/ook</a> ，Ook! 具有以下特征：</p><ul><li>完整 Ook!：仅由 3 种符号组成 <code>Ook.</code>、<code>Ook?</code>、<code>Ook!</code></li><li>Short Ook!：仅由 3 种符号组成 <code>.!?</code></li></ul><p>正常的一段代码：</p><pre><code class="javascript">alert(&quot;Hello, Ook!&quot;)</code></pre><p>经过 Ook! 混淆之后的代码类似于：</p><pre><code class="javascript">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. </code></pre><h3 id="Trivial-brainfuck-substitution"><a href="#Trivial-brainfuck-substitution" class="headerlink" title="Trivial brainfuck substitution"></a>Trivial brainfuck substitution</h3><p>Trivial brainfuck substitution 不是一种单一的编程语言，而是一大类编程语言，成员超过 20 个，前面提到的 Brainfuck、Ook! 都是其中的一员，在爬虫领域中，说实话这种稀奇古怪的混淆其实并不常见，但是在一些 CTF 中有可能会出现，作为爬虫工程师也可以了解了解😎，具体可以参考：<a href="https://esolangs.org/wiki/Trivial_brainfuck_substitution">https://esolangs.org/wiki/Trivial_brainfuck_substitution</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="恺撒密码"><a href="#恺撒密码" class="headerlink" title="恺撒密码"></a>恺撒密码</h3><p>恺撒密码（Caesar cipher）又称为恺撒加密、恺撒变换、变换加密，它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是 3 的时候，所有的字母 A 将被替换成 D，B 变成 E，以此类推。这个加密方法是以罗马共和时期恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。</p><p>根据偏移量的不同，还存在若干特定的恺撒密码名称：偏移量为10：Avocat（A→K）；偏移量为13：ROT13；偏移量为-5：Cassis (K 6)；偏移量为-6：Cassette (K 7)</p><p>示例（偏移量 3）：</p><ul><li><p>明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ</p></li><li><p>密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC</p></li></ul><h3 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h3><p>栅栏密码就是把要加密的明文分成 N 个一组，然后把每组的第 1 个字连起来，形成一段无规律的话。栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多，一般不超过 30 个。</p><p>示例：明文为 THE LONGEST DAY MUST HAVE AN END。加密时，把将要传递的信息中的字母交替排成上下两行：</p><p>T E O G S D Y U T A E N N</p><p>H L N E T A M S H V A E D</p><p>将下面一行字母排在上面一行的后边组合成密文：</p><p>TEOGSDYUTAENN HLNETAMSHVAED</p><p>栅栏密码还有一种变种，称为栅栏密码 W 型，它会先把明文类似 W 形状进行排列，然后再按栏目顺序 1-N，取每一栏的所有字符值，组成加密后密文，比如字符串 123456789，采用栏目数为 3 时，明文将采用如下排列：<br>1—5—9<br>-2-4-6-8-<br>–3—7–<br>取每一栏所有字符串，组成加密后密文：159246837</p><h3 id="猪圈密码"><a href="#猪圈密码" class="headerlink" title="猪圈密码"></a>猪圈密码</h3><p>猪圈密码也称为朱高密码、共济会暗号、共济会密码或共济会员密码，是一种以格子为基础的简单替代式密码。只能对字母加解密并且符号无法复制，粘贴后会直接显示明文，即使使用符号，也不会影响密码分析，亦可用在其它替代式的方法。曾经是美国内战时盟军使用的密码，目前仅在密码教学、各种竞赛中使用。</p><p><img src="https://img-blog.csdnimg.cn/3f805384f17840368db5e1611a54c9a2.gif#pic_center" alt="01.gif"></p><h3 id="摩斯密码"><a href="#摩斯密码" class="headerlink" title="摩斯密码"></a>摩斯密码</h3><p>摩斯密码（Morse code），又称为摩尔斯电码、摩斯电码，是一种时通时断的信号代码，这种信号代码通过不同的排列顺序来表达不同的英文字母、数字和标点符号等。</p><p>26个字母的摩斯密码表</p><table><thead><tr><th align="left">字符</th><th align="left">摩斯码</th><th align="left">字符</th><th align="left">摩斯码</th><th>字符</th><th>摩斯码</th><th>字符</th><th>摩斯码</th></tr></thead><tbody><tr><td align="left">A</td><td align="left"><code>．━</code></td><td align="left">B</td><td align="left"><code>━ ．．．</code></td><td>C</td><td><code>━ ．━ ．</code></td><td>D</td><td><code>━ ．．</code></td></tr><tr><td align="left">E</td><td align="left"><code>．</code></td><td align="left">F</td><td align="left"><code>．．━ ．</code></td><td>G</td><td><code>━ ━ ．</code></td><td>H</td><td><code>．．．．</code></td></tr><tr><td align="left">I</td><td align="left"><code>．．</code></td><td align="left">J</td><td align="left"><code>．━ ━ ━</code></td><td>K</td><td><code>━ ．━</code></td><td>L</td><td><code>．━ ．．</code></td></tr><tr><td align="left">M</td><td align="left"><code>━ ━</code></td><td align="left">N</td><td align="left"><code>━ ．</code></td><td>O</td><td><code>━ ━ ━</code></td><td>P</td><td><code>．━ ━ ．</code></td></tr><tr><td align="left">Q</td><td align="left"><code>━ ━ ．━</code></td><td align="left">R</td><td align="left"><code>．━ ．</code></td><td>S</td><td><code>．．．</code></td><td>T</td><td><code>━</code></td></tr><tr><td align="left">U</td><td align="left"><code>．．━</code></td><td align="left">V</td><td align="left"><code>．．．━</code></td><td>W</td><td><code>．━ ━</code></td><td>X</td><td><code>━ ．．━</code></td></tr><tr><td align="left">Y</td><td align="left"><code>━ ．━ ━</code></td><td align="left">Z</td><td align="left"><code>━ ━ ．．</code></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>10个数字的摩斯密码表</p><table><thead><tr><th align="left">字符</th><th align="left">摩斯码</th><th align="left">字符</th><th align="left">摩斯码</th><th>字符</th><th>摩斯码</th><th>字符</th><th>摩斯码</th></tr></thead><tbody><tr><td align="left">0</td><td align="left"><code>━ ━ ━ ━ ━</code></td><td align="left">1</td><td align="left"><code>．━ ━ ━ ━</code></td><td>2</td><td><code>．．━ ━ ━</code></td><td>3</td><td><code>．．．━ ━</code></td></tr><tr><td align="left">4</td><td align="left"><code>．．．．━</code></td><td align="left">5</td><td align="left"><code>．．．．．</code></td><td>6</td><td><code>━ ．．．．</code></td><td>7</td><td><code>━ ━ ．．．</code></td></tr><tr><td align="left">8</td><td align="left"><code>━ ━ ━ ．．</code></td><td align="left">9</td><td align="left"><code>━ ━ ━ ━ ．</code></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>标点符号的摩斯密码表</p><table><thead><tr><th align="left">字符</th><th align="left">摩斯码</th><th align="left">字符</th><th align="left">摩斯码</th><th>字符</th><th>摩斯码</th><th>字符</th><th>摩斯码</th></tr></thead><tbody><tr><td align="left">.</td><td align="left"><code>．━ ．━ ．━</code></td><td align="left">:</td><td align="left"><code>━ ━ ━ ．．．</code></td><td>,</td><td><code>━ ━ ．．━ ━</code></td><td>;</td><td><code>━ ．━ ．━ ．</code></td></tr><tr><td align="left">?</td><td align="left"><code>．．━ ━ ．．</code></td><td align="left">=</td><td align="left"><code>━ ．．．━</code></td><td>‘</td><td><code>．━ ━ ━ ━ ．</code></td><td>/</td><td><code>━ ．．━ ．</code></td></tr><tr><td align="left">!</td><td align="left"><code>━ ．━ ．━ ━</code></td><td align="left">━</td><td align="left"><code>━ ．．．．━</code></td><td>_</td><td><code>．．━ ━ ．━</code></td><td>“</td><td><code>．━ ．．━ ．</code></td></tr><tr><td align="left">(</td><td align="left"><code>━ ．━ ━ ．</code></td><td align="left">)</td><td align="left"><code>━ ．━ ━ ．━</code></td><td>$</td><td><code>．．．━ ．．━</code></td><td>&amp;</td><td><code>． ．．．</code></td></tr><tr><td align="left">@</td><td align="left"><code>．━ ━ ．━ ．</code></td><td align="left"></td><td align="left"></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="培根密码"><a href="#培根密码" class="headerlink" title="培根密码"></a>培根密码</h3><p>培根密码，又名倍康尼密码（Bacon’s cipher）是由法兰西斯·培根发明的一种隐写术，它是一种本质上用二进制数设计的，没有用通常的0和1来表示，而是采用a和b，看到一串的a和b，并且五个一组，那么就是培根加密了。</p><p>第一种方式：</p><table><thead><tr><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th></tr></thead><tbody><tr><td>A</td><td>aaaaa</td><td>H</td><td>aabbb</td><td>O</td><td>abbba</td><td>V</td><td>babab</td></tr><tr><td>B</td><td>aaaab</td><td>I</td><td>abaaa</td><td>P</td><td>abbbb</td><td>W</td><td>babba</td></tr><tr><td>C</td><td>aaaba</td><td>J</td><td>abaab</td><td>Q</td><td>baaaa</td><td>X</td><td>babbb</td></tr><tr><td>D</td><td>aaabb</td><td>K</td><td>ababa</td><td>R</td><td>baaab</td><td>Y</td><td>bbaaa</td></tr><tr><td>E</td><td>aabaa</td><td>L</td><td>ababb</td><td>S</td><td>baaba</td><td>Z</td><td>bbaab</td></tr><tr><td>F</td><td>aabab</td><td>M</td><td>abbaa</td><td>T</td><td>baabb</td><td></td><td></td></tr><tr><td>G</td><td>aabba</td><td>N</td><td>abbab</td><td>U</td><td>babaa</td><td></td><td></td></tr></tbody></table><p>第二种方式：</p><table><thead><tr><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th><th>字符</th><th>培根密码</th></tr></thead><tbody><tr><td>a</td><td>AAAAA</td><td>h</td><td>AABBB</td><td>p</td><td>ABBBA</td><td>x</td><td>BABAB</td></tr><tr><td>b</td><td>AAAAB</td><td>i-j</td><td>ABAAA</td><td>q</td><td>ABBBB</td><td>y</td><td>BABBA</td></tr><tr><td>c</td><td>AAABA</td><td>k</td><td>ABAAB</td><td>r</td><td>BAAAA</td><td>z</td><td>BABBB</td></tr><tr><td>d</td><td>AAABB</td><td>l</td><td>ABABA</td><td>s</td><td>BAAAB</td><td></td><td></td></tr><tr><td>e</td><td>AABAA</td><td>m</td><td>ABABB</td><td>t</td><td>BAABA</td><td></td><td></td></tr><tr><td>f</td><td>AABAB</td><td>n</td><td>ABBAA</td><td>u-v</td><td>BAABB</td><td></td><td></td></tr><tr><td>g</td><td>AABBA</td><td>o</td><td>ABBAB</td><td>w</td><td>BABAA</td><td></td><td></td></tr></tbody></table><p>示例：</p><ul><li>明文：kuaidaili</li><li>密文：ABABABABAAAAAAAABAAAAAABBAAAAAABAAAABABBABAAA</li></ul><h3 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h3><p>维吉尼亚密码是在凯撒密码基础上产生的一种加密方法，它将凯撒密码的全部25种位移排序为一张表，与原字母序列共同组成26行及26列的字母表。另外，维吉尼亚密码必须有一个密钥，这个密钥由字母组成，最少一个，最多可与明文字母数量相等。维吉尼亚密码表如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f2d77e1fbf392a531272954ec46a4aa2.png" alt="02.png"></p><p>示例：</p><ul><li>明文：I’ve got it.</li><li>密钥：ok</li><li>密文：W’fs qcd wd.</li></ul><p>首先，密钥长度需要与明文长度相同，如果少于明文长度，则重复拼接直到相同。示例的明文长度为8个字母（非字母均被忽略），密钥会被程序补全为 <code>okokokok</code>，然后根据维吉尼亚密码表进行加密：明文第一个字母是 <code>I</code>，密钥第一个字母是 <code>o</code>，在表格中找到 <code>I</code> 列与 <code>o</code> 行相交点，字母 <code>W</code> 就是密文第一个字母，同理，<code>v</code> 列与 <code>k</code> 行交点字母是 <code>F</code>，<code>e</code> 列与 <code>o</code> 行交点字母是 <code>S</code>，以此类推。注意：维吉尼亚密码只对字母进行加密，不区分大小写，若文本中出现非字母字符会原样保留，如果输入多行文本，每行是单独加密的。</p><h3 id="与佛论禅"><a href="#与佛论禅" class="headerlink" title="与佛论禅"></a>与佛论禅</h3><p>字符串转换后，是一些佛语，在线体验：<a href="https://keyfc.net/bbs/tools/tudoucode.aspx">https://keyfc.net/bbs/tools/tudoucode.aspx</a></p><p>示例：</p><ul><li>明文：爬虫</li><li>密文：佛曰：俱曳栗羅。諳故大多罰顛冥有諳姪帝罰知俱薩心俱智伊</li></ul><h3 id="当铺密码"><a href="#当铺密码" class="headerlink" title="当铺密码"></a>当铺密码</h3><p>当铺密码在 CTF 比赛题目中出现过。该加密算法是根据当前汉字有多少笔画出头，对应的明文就是数字几。</p><p>示例：</p><ul><li>明文：王夫 井工 夫口 由中人 井中 夫夫 由中大</li><li>密文：67 84 70 123 82 77 125</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> JS 逆向 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS 逆向】WebSocket 协议爬虫，智慧树扫码登录案例分析</title>
      <link href="/article/043/"/>
      <url>/article/043/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><strong>本文章中所有内容仅供学习交流，抓包内容、敏感网址、数据接口均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关，若有侵权，请联系我立即删除！</strong></p><h2 id="逆向目标"><a href="#逆向目标" class="headerlink" title="逆向目标"></a>逆向目标</h2><ul><li>目标：智慧树扫码登录，接口使用了 WebSocket 通信协议</li><li>主页：<code>aHR0cHM6Ly9wYXNzcG9ydC56aGlodWlzaHUuY29tL2xvZ2luI3FyQ29kZUxvZ2lu</code></li></ul><h2 id="WebSocket-简介"><a href="#WebSocket-简介" class="headerlink" title="WebSocket 简介"></a>WebSocket 简介</h2><p>WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议，WebSocket 使得客户端和服务器之间的数据交换变得更加简单。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><p>WebSocket 协议简称为 WS 或者 WSS（WebSocket Secure），其发送请求的 URL 以 <code>ws://</code> 或者 <code>wss://</code> 开头，WSS 是 WS 的加密版本，类似于 HTTP 与 HTTPS。</p><p>WebSocket 协议的最大特点就是：服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。与 HTTP 的对比如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20211207170201530.png" alt="01.png"></p><h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p>来到智慧树的扫码登录页面，抓包选中 WS，用来筛选 WebSocket 请求，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20211207170202672.png" alt="02.png"></p><p>其中有一些比较特别的参数，是 HTTP/ HTTPS 请求中没有的：</p><ul><li><code>Upgrade: websocket</code>：表明这是 WebSocket 类型请求；</li><li><code>Sec-WebSocket-Version</code>：告诉服务器所使用的 Websocket Draft（协议版本），必须是 13；</li><li><code>Sec-WebSocket-Extensions</code>：协议扩展，某类协议可能支持多个扩展，通过它可以实现协议增强；</li><li><code>Sec-WebSocket-Key</code>：是 WebSocket 客户端发送的一个 base64 编码的密文，是浏览器随机生成的，要求服务端必须返回一个对应加密的 <code>Sec-WebSocket-Accept</code> 应答，否则客户端会抛出 <code>Error during WebSocket handshake</code> 错误，并关闭连接。</li></ul><p>我们先扫码登录一遍，再选择 Messages 选项卡，可以看到有一些数据交互，其中绿色的箭头是客户端发送给服务器的数据，红色箭头是服务器响应返回给客户端的数据，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20211207170204424.png" alt="03.png"></p><p>我们观察一下整个交互过程，当我们打开二维码页面后，也就是二维码加载出来的同时，WebSocket 连接就建立了，每隔8秒左右，客户端就主动发送一串字符串，服务端也返回相同的字符串，只不过是字典格式，当我们扫码成功时，服务端就返回扫码成功的信息，当我们点击登陆时，客户端又会返回扫码结果，如果成功，就有一个一次性密码 <code>oncePassword</code> 和一个 <code>uuid</code>，这两个参数肯定在后续的请求中会用到的。如果长时间不扫码的话，过段时间就会返回二维码已失效的信息，每隔8秒发送一次消息，正是为了保持连接以及获取二维码状态消息。</p><p>那么到这里就出现了两个问题：</p><ol><li><p>在来回交互发送的那串字符串，是怎么得来的？</p></li><li><p>在 Python 中应该如何实现 WebSocket 请求？</p></li><li><p>如何实现客户端每隔 8 秒发送一次数据的同时，实时接收服务端的信息？（观察请求扫码结果实时返回的，所以不能每隔 8 秒才接收一次）</p></li></ol><h2 id="参数获取"><a href="#参数获取" class="headerlink" title="参数获取"></a>参数获取</h2><p>首先解决第一个问题，客户端发送的那串字符串是怎么来的，这里寻找加密字符串的方式和 HTTP/HTTPS 请求是一样的，在本例中，我们可以直接搜索这个字符串，发现是通过一个接口传过来的，其中 img 就是二维码图片的 base64 值，qrToken 就是客户端发送的那串字符串，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20211207170205334.png" alt="04.png"></p><p>这里需要注意的是，并不是所有的 WebSocket 请求都是如此的简单的，有的客户端发送的数据是 Binary Message（二进制数据）、或者更复杂的加密参数，直接搜索无法获取，针对这种情况，我们也有解决方法：</p><ol><li><p>已知创建 WebSocket 对象的语句为：<code>var Socket = new WebSocket(url, [protocol] );</code>，所以我们可以搜索 <code>new WebSocket</code> 定位到建立请求的位置。</p></li><li><p>已知一个 WebSocket 对象有以下相关事件，我们可以搜索对应事件处理程序代码来定位：</p></li></ol><table><thead><tr><th align="left">事件</th><th align="left">事件处理程序</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">open</td><td align="left">Socket.onopen</td><td align="left">连接建立时触发</td></tr><tr><td align="left">message</td><td align="left">Socket.onmessage</td><td align="left">客户端接收服务端数据时触发</td></tr><tr><td align="left">error</td><td align="left">Socket.onerror</td><td align="left">通信发生错误时触发</td></tr><tr><td align="left">close</td><td align="left">Socket.onclose</td><td align="left">连接关闭时触发</td></tr></tbody></table><ol start="3"><li>已知一个 WebSocket 对象有以下相关方法，我们可以搜索对应方法来定位：</li></ol><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Socket.send()</td><td align="left">使用连接发送数据</td></tr><tr><td align="left">Socket.close()</td><td align="left">关闭连接</td></tr></tbody></table><h2 id="Python-实现-WebSocket-请求"><a href="#Python-实现-WebSocket-请求" class="headerlink" title="Python 实现 WebSocket 请求"></a>Python 实现 WebSocket 请求</h2><p>接着前面说，第二个问题，在 Python 中应该如何实现 WebSocket 请求？Python 库中用于连接 WebSocket 的有很多，比较常用、稳定的有 <a href="https://github.com/websocket-client/websocket-client">websocket-client</a>（非异步）、<a href="https://github.com/aaugustin/websockets">websockets</a>（异步）、<a href="https://github.com/asyncins/aiowebsocket">aiowebsocket</a>（异步）。在本案例中使用 websocket-client，这里还要注意第三个问题，对于客户端来说，要每隔 8 秒发送一次数据，对于服务端，我们需要实时接收服务端的信息，可以观察请求，扫码的结果是实时返回的，如果我们也每隔 8 秒才接收一次数据的话，有可能会丢失数据，而且也会使得整个程序的响应也不及时，效率变低。</p><p>在 websocket-client 官方文档中给我们提供了一个长连接的 demo，它实现了连续发送三次数据，并实时监听服务端返回的数据，其中的 <code>websocket.enableTrace(True)</code> 表示是否显示连接详细信息：</p><pre><code class="python">import websocketimport _threadimport timedef on_message(ws, message):    print(message)def on_error(ws, error):    print(error)def on_close(ws, close_status_code, close_msg):    print(&quot;### closed ###&quot;)def on_open(ws):    def run(*args):        for i in range(3):            time.sleep(1)            ws.send(&quot;Hello %d&quot; % i)        time.sleep(1)        ws.close()        print(&quot;thread terminating...&quot;)    _thread.start_new_thread(run, ())if __name__ == &quot;__main__&quot;:    websocket.enableTrace(True)    ws = websocket.WebSocketApp(        &quot;ws://echo.websocket.org/&quot;, on_open=on_open,        on_message=on_message, on_error=on_error, on_close=on_close    )    ws.run_forever()</code></pre><p>我们将其适当改造一下，客户端在 run 方法里，依然是每隔 8 秒发送一次 qr_token，实时接收服务端的消息，当“扫码成功”字样出现在消息里时，将得到的 <code>oncePassword</code> 和 <code>uuid</code> 存起来，然后关闭连接，逻辑代码如下所示，后续只要将二维码的获取逻辑接入就行了。（已脱敏处理，不能直接运行）</p><pre><code class="python">import jsonimport timeimport _threadimport websocketweb_socket_url = &quot;wss://appcomm-user.脱敏处理.com/app-commserv-user/websocket?qrToken=%s&quot;qr_token = &quot;ca6e6cfb70de4f2f915b968aefcad404&quot;once_password = &quot;&quot;uuid = &quot;&quot;def wss_on_message(ws, message):    print(&quot;=============== [message] ===============&quot;)    message = json.loads(message)    print(message)    if &quot;扫码成功&quot; in message[&quot;msg&quot;]:        global once_password, uuid        once_password = message[&quot;oncePassword&quot;]        uuid = message[&quot;uuid&quot;]        ws.close()def wss_on_error(ws, error):    print(&quot;=============== [error] ===============&quot;)    print(error)    ws.close()def wss_on_close(ws, close_status_code, close_msg):    print(&quot;=============== [closed] ===============&quot;)    print(close_status_code)    print(close_msg)def wss_on_open(ws):    def run(*args):        while True:            ws.send(qr_token)            time.sleep(8)    _thread.start_new_thread(run, (qr_token,))def wss():    # websocket.enableTrace(True)  # 是否显示连接详细信息    ws = websocket.WebSocketApp(        web_socket_url % qr_token, on_open=wss_on_open,        on_message=wss_on_message, on_error=wss_on_error,        on_close=wss_on_close    )    ws.run_forever()</code></pre><h2 id="实现扫码登录"><a href="#实现扫码登录" class="headerlink" title="实现扫码登录"></a>实现扫码登录</h2><p>最重要的 WebSocket 请求部分已经解决了，扫码拿到 <code>oncePassword</code> 和 <code>uuid</code> 后，后续的处理步骤就比较简单了，现在来理一下完整的步骤：</p><ol><li>请求首页，第一次获取 cookie，包含：INGRESSCOOKIE、JSESSIONID、SERVERID、acw_tc；</li><li>请求获取二维码接口，得到二维码的 base64 值和 qrToken；</li><li>建立 WebSocket 连接，扫描二维码，获取一次性密码 oncePassword 和 uuid（好像没什么用）；</li><li>请求一个登录接口，302 重定向，需要携带一次性密码，第二次获取 cookie，包含：CASLOGC、CASTGC，同时更新 SERVERID；</li><li>请求第 4 步 302 重定向地址，第三次获取 cookie，包含：SESSION；</li><li>携带完整 cookie，请求用户信息接口，获取真实用户名等信息。</li></ol><p>实际上 WebSocket 连接结束后，有很多请求，看起来都比较可以，但是经过测试，只有两个重定向比较有用，抓包如下：</p><p><img src="https://img-blog.csdnimg.cn/20211207170206292.png" alt="05.png"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><strong>以下只演示部分关键代码，不能直接运行！</strong> 完整代码仓库地址：<a href="https://github.com/TRHX/Python3-Spider-Practice/">https://github.com/TRHX/Python3-Spider-Practice/</a></p><pre><code class="python">import timeimport jsonimport base64import _threadimport requestsimport websocketfrom PIL import Imageweb_socket_url = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;get_login_qr_img_url = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;login_url = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;user_info_url = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;headers = &#123;    &quot;Host&quot;: &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;,    &quot;Pragma&quot;: &quot;no-cache&quot;,    &quot;Referer&quot;: &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;,    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36&quot;&#125;qr_token = &quot;&quot;once_password = &quot;&quot;uuid = &quot;&quot;cookie = &#123;&#125;def get_cookies_first():    response = requests.get(url=login_url, headers=headers)    global cookie    cookie = response.cookies.get_dict()def get_login_qr_img():    response = requests.get(url=get_login_qr_img_url, headers=headers, cookies=cookie).json()    qr_img = response[&quot;img&quot;]    global qr_token    qr_token = response[&quot;qrToken&quot;]    with open(&#39;code.png&#39;, &#39;wb&#39;) as f:        f.write(base64.b64decode(qr_img))    image = Image.open(&#39;code.png&#39;)    image.show()    print(&quot;请扫描验证码! &quot;)def wss_on_message(ws, message):    print(&quot;=============== [message] ===============&quot;)    message = json.loads(message)    print(message)    if &quot;扫码成功&quot; in message[&quot;msg&quot;]:        global once_password, uuid        once_password = message[&quot;oncePassword&quot;]        uuid = message[&quot;uuid&quot;]        ws.close()def wss_on_error(ws, error):    print(&quot;=============== [error] ===============&quot;)    print(error)    ws.close()def wss_on_close(ws, close_status_code, close_msg):    print(&quot;=============== [closed] ===============&quot;)    print(close_status_code)    print(close_msg)def wss_on_open(ws):    def run(*args):        while True:            ws.send(qr_token)            time.sleep(8)    _thread.start_new_thread(run, (qr_token,))def wss():    # websocket.enableTrace(True)  # 是否显示连接详细信息    ws = websocket.WebSocketApp(        web_socket_url % qr_token, on_open=wss_on_open,        on_message=wss_on_message, on_error=wss_on_error,        on_close=wss_on_close    )    ws.run_forever()def get_cookie_second():    global cookie    params = &#123;        &quot;pwd&quot;: once_password,        &quot;service&quot;: &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;    &#125;    headers[&quot;Host&quot;] = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;    headers[&quot;Referer&quot;] = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;    response = requests.get(url=login_url, params=params, headers=headers, cookies=cookie, allow_redirects=False)    cookie.update(response.cookies.get_dict())    location = response.headers.get(&quot;Location&quot;)    return locationdef get_cookie_third(location):    global cookie    headers[&quot;Host&quot;] = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;    headers[&quot;Referer&quot;] = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;    response = requests.get(url=location, headers=headers, cookies=cookie, allow_redirects=False)    cookie.update(response.cookies.get_dict())    location = response.headers.get(&quot;Location&quot;)    return locationdef get_login_user_info():    headers[&quot;Host&quot;] = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;    headers[&quot;Origin&quot;] = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;    headers[&quot;Referer&quot;] = &quot;脱敏处理，完整代码关注 GitHub：https://github.com/TRHX/Python3-Spider-Practice&quot;    params = &#123;&quot;time&quot;: str(int(time.time() * 1000))&#125;    response = requests.get(url=user_info_url, headers=headers, cookies=cookie, params=params)    print(response.text)def main():    # 第一次获取 cookie，包含 INGRESSCOOKIE、JSESSIONID、SERVERID、acw_tc    get_cookies_first()    # 获取二维码    get_login_qr_img()    # websocket 扫码登录，返回一次性密码    wss()    # 第二次获取 cookie，更新 SERVERID、获取 CASLOGC、CASTGC    location1 = get_cookie_second()    # 第三次获取 cookie，获取 SESSION    get_cookie_third(location1)    # 获取登录用户信息    get_login_user_info()if __name__ == &#39;__main__&#39;:    main()</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS 逆向 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS 逆向】某空气质量监测平台无限 debugger 以及数据动态加密分析</title>
      <link href="/article/044/"/>
      <url>/article/044/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><strong>本文章中所有内容仅供学习交流，抓包内容、敏感网址、数据接口均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关，若有侵权，请联系我立即删除！</strong></p><h2 id="逆向目标"><a href="#逆向目标" class="headerlink" title="逆向目标"></a>逆向目标</h2><ul><li>目标：某空气质量监测平台无限 debugger 以及请求数据、返回数据动态加密、解密</li><li>主页：<code>aHR0cHM6Ly93d3cuYXFpc3R1ZHkuY24v</code></li><li>接口：<code>aHR0cHM6Ly93d3cuYXFpc3R1ZHkuY24vYXBpbmV3L2FxaXN0dWR5YXBpLnBocA==</code></li></ul><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这个站点更新频率很高，在我之前也已经有很多博主写了该站点的分析文章，近期有读者问请求数据的加密和返回数据的解密，发现其加解密 JS 变成了动态的，以前的那些文章提到的解决思路不太行了，但整体上来说也不是很难，只不过处理起来比较麻烦一点，还有一些小细节需要注意。</p><p>在网站的“关于系统”里可以看到，这个站貌似是个人开发者在维护，最早在2013年就有了，在友情赞助列表里，可以看到大多数都是一些环境、测绘、公共卫生相关的大学专业、研究院人员，可以猜测到这些数据对于他们的研究是非常有帮助的，再加上反爬更新频繁，可以看出站长饱受爬虫之苦，K哥也不想给站长添加负担，毕竟这种站点咱们应该支持，让他长久维护下去，<strong>所以本期K哥只分析逻辑和少部分代码，就不放完整代码了，如果有相关专业人士确实需要抓取数据做研究的，可以在公众号后台联系我。</strong></p><h2 id="绕过无限-debugger"><a href="#绕过无限-debugger" class="headerlink" title="绕过无限 debugger"></a>绕过无限 debugger</h2><p>右键 F12，会提示右键被禁用，不要紧，使用快捷键 <code>Ctrl+Shift+i</code> 或者浏览器右上角，更多工具，开发者工具，照样能打开。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/389c5830317031a092ffe6ddd0c10050.png#pic_center" alt="01.png"></p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>打开控制台后会进入第一个无限 debugger，往上跟一个栈，可以看到一个 try-catch 语句，你下断点会发现他会一直走 catch，调用 <code>setTimeout()</code> 方法，该方法用于在指定的毫秒数后调用函数或计算表达式，注意上面，是将 debugger 传递给了构造方法 constructor，所以这里我们有两种方法过掉 debugger，Hook 掉 constructor 或 setTimeout 都可以。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c311099f5c0b77192424c42d937d90c4.png#pic_center" alt="02.png"></p><pre><code class="javascript">// 两种 Hook 任选一中// Hook 构造方法Function.prototype.constructor_ = Function.prototype.constructor;Function.prototype.constructor = function (a) &#123;    if(a == &quot;debugger&quot;) &#123;        return function ()&#123;&#125;;    &#125;    return Function.prototype.constructor_(a);&#125;;// Hook setTimeoutvar setTimeout_ = setTimeoutvar setTimeout = function (func, time)&#123;    if (func == txsdefwsw)&#123;        return function () &#123;&#125;;    &#125;    return setTimeout_(func, time)&#125;</code></pre><p>然后就来到了第二个无限 debugger，同样跟栈，发现有个 setInterval 定时器和构造方法 constructor，类似的，我们 Hook 掉 constructor 或 setInterval 都可以。注意：定时器这里还检测了窗口高宽，即便是你过了 constructor 或 setInterval，如果不把开发者工具单独拿出来也是不行的，会不断输出“检测到非法调试”。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/24fb1072abd88b44ce7e6a836e56af97.png#pic_center" alt="03.png"></p><pre><code class="javascript">// Hook setIntervalvar setInterval_ = setIntervalsetInterval = function (func, time)&#123;    if (time == 2000) &#123;        return function () &#123;&#125;;    &#125;    return setInterval_(func, time)&#125;</code></pre><p>我们观察到，其实这两个无限 debugger 都可以 Hook 构造方法来过掉，所以直接 Fiddler 注入该 Hook 构造方法的代码即可：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/57c491d6b2a5f28110ba422d34355cc9.png#pic_center" alt="04.png"></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>在我们遇到第二个无限 debugger 的时候，还可以直接跟栈到一个 city_realtime.php 的页面，里面有两个 eval 语句，执行第一个 eval 里面的语句你就会发现正是前面我们在 VM 虚拟机里面看到的 debugger 代码，所以这里理论上可以直接替换掉这个页面，去掉 eval 语句，就不会有无限 debugger 了，但是K哥先告诉你，现在不行了，因为里面有加载了某个 JS，这个 JS 在后面加密解密中会用到，但是这个 JS 是动态的，每10分钟就会改变，我们后面还要通过此页面来获取动态的 JS，所以是不能替换的！这里只是提一下这个思路！</p><p><img src="https://img-blog.csdnimg.cn/img_convert/db958514d4e4bc98ffa605cf626ca23a.png#pic_center" alt="05.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/282ada73849ebb74039a98732edaf72e.png#pic_center" alt="06.png"></p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>当然，这里还有一种最简单的方法，直接右键选择 Never pause here，永不在此处断下即可，同样还需要把开发者工具窗口单独拿出来，不然会一直输出“检测到非法调试”。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f5922a0ad3c48adc030e368bf8542b8a.png#pic_center" alt="07.png"></p><h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p>我们在实时监控页面，顺便点击查询一个城市，可以看到请求的 Form Data 和返回的数据都是加密的，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6f1b1872723348480a25b3862201622e.png#pic_center" alt="08.png"></p><h2 id="加密入口"><a href="#加密入口" class="headerlink" title="加密入口"></a>加密入口</h2><p>由于是 XHR，所以我们直接跟栈，很容易找到加密的位置：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ed3d2b8414cdb6f2d434d2534939e379.png#pic_center" alt="09.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/53044ab14dbfdb75bd21657060d6bbd8.png#pic_center" alt="10.png"></p><p>可以看到传递的 data 键值对：<code>&#123;hXM8NDFHN: p7crXYR&#125;</code>，键在这个 JS 里是写死的，值是通过一个方法 <code>pU14VhqrofroULds()</code> 得到的，这个方法需要传递两个参数，第一个是定值 GETDATA，第二个就是城市名称，我们再跟进看看这个方法是啥：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6145ba480135887e42bda4f0f471d3f9.png#pic_center" alt="11.png"></p><p>一些 appId、时间戳、城市等参数，做了一些 MD5、base64 的操作，返回的 param 就是我们要的值了。看起来不难，我们再找找返回的加密数据是如何解密的，我们注意到 ajax 请求有个 success 关键字，我们即便是不懂 JS 逻辑，也可以猜到应该是请求成功后的处理操作吧，如下图所示：传进来的 dzJMI 就是返回的加密的数据，经过 <code>db0HpCYIy97HkHS7RkhUn()</code> 方法后，就解密成功了：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6f5527d38878bcabda88878591aafb3a.png#pic_center" alt="12.png"></p><p>跟进 <code>db0HpCYIy97HkHS7RkhUn()</code> 方法，可以看到是 AES+DES+BASE64 解密，传入的密钥 key 和偏移量 iv 都在头部有定义：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b77e427fed50ef80002d0144fb478741.png#pic_center" alt="13.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/960e2ebfe395fbb139442d10e5f16f43.png#pic_center" alt="14.png"></p><h2 id="动态-JS"><a href="#动态-JS" class="headerlink" title="动态 JS"></a>动态 JS</h2><p>经过以上分析后，我们加密解密的逻辑都搞定了，但是你多调试一下就会发现，这一个加密解密的 JS 是动态变化的，定义的密钥 key 和偏移量 iv 都是隔段时间就会改变的，如果你在这段代码里下断点，停留时间过长，突然发现断点失效无法断下了，那就是 JS 变了，当前代码已经失效了。</p><p>我们随便薅两个不同的 JS 下来（提示：JS 每隔10分钟会变化，后文有详细分析），利用 PyCharm 的文件对比功能（依次选择 View - Compare With）可以总结出以下几个变化的地方（变量名的变化不算）：</p><ol><li>开头的8个参数的值：两个 aes key 和 iv，两个 des key 和 iv；</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/4f48281ff87143bc23a094cf634802d8.png#pic_center" alt="15.png"></p><ol start="2"><li>生成加密的 param 时，appId 是变化的，最后的加密分为 AES、DES 和没有加密，三种情况（这里是最容易忽略的地方，这里没有注意到，请求可能会提示 appId 无效的情况）：</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/762fa747135504fbde73fa6b3986d869.png#pic_center" alt="16.png"></p><ol start="3"><li>最后发送请求时，data 键值对，其中的键也是变化的：</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/67ee28a04033aa503d8e41be6fcf3dbd.png#pic_center" alt="17.png"></p><p>变化的地方我们找到了，那我们怎么获取这个 JS 呢？因为这个 JS 的在 VM 虚拟机里，所以我们还要找到它的源头，是从哪里来的，我们抓包可以看到一个比较特殊的 JS，类似于 encrypt_xxxxxx.js，看这取名就知道不简单，返回的是一段 eval 包裹的代码：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a2f3687fe4ee1aad5c7ca1331bf65a68.png#pic_center" alt="18.png"></p><p>对于 eval 我们已经很熟悉了，直接去掉 eval，让他执行一下，就可以看到正是我们需要的那段 JS：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ab32b5eff66ba4cf024ce79109bea03a.png#pic_center" alt="19.png"></p><p>这里有个小细节，如果你使用控制台，会发现它一直在打印 img 标签，影响我们的输入，这里可以直接跟进去下断点暂时阻止他运行就行了，不需要做其他操作浪费时间：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/54b72f44ae13b7eed13f0f4f6e0e3091.png#pic_center" alt="20.png"></p><p>你以为到这里就差不多搞定了？错了，同样的这个 encrypt_xxxxxx.js 也藏有玄机：</p><ol><li>encrypt_xxxxxx.js 的名称是动态的，后面的 v 值是秒级时间戳，隔600秒，也就是十分钟就会改变，这个 JS 可以在 city_realtime.php 页面找到，还记得我们前面说过的绕过无限 debugger 不能替换此页面吗？我们要通过此页面来获取动态的 JS，所以是不能替换的！</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/73f20c39d6bc6e0cc6ed54815cad99fa.png#pic_center" alt="21.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/fc3eeffb3bf092330e03cefaf34363e6.png#pic_center" alt="22.png"></p><ol start="2"><li>encrypt_xxxxxx.js 返回的 JS，并不是所有的执行一遍 eval 就能得到明文代码了，它是 eval 和 base64 相结合的，第一遍都是 eval，但是后面就说不定了，有可能直接出结果，有可能需要 base64，有可能 base64 两遍，有可能两遍 base64 之后还要再 eval，总之，除了第一遍是 eval 以外，后面是否需要 base64 和 eval，以及需要的次数和先后顺序，都是不确定的！举几个例子：</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/5f2297cf7a0481ae3399b5c2a8fa81c0.png#pic_center" alt="23.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/b2217260728ded9a44be53524f23ad2b.png#pic_center" alt="24.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/9fa531eb305cba680b129ca22d910298.png#pic_center" alt="25.png"></p><p>这里可能有人会问，你怎么看出来那是 base64 呢？很简单，直接在网站页面的控制台里输入 <code>dswejwehxt</code>，点击去看这个函数，就是 base64：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5a0ee651bf758051472d212c7f0a5b07.png#pic_center" alt="26.png"></p><p>那么针对 encrypt_xxxxxx.js 内容不确定的情况，我们可以写一个方法，获取到 encrypt_xxxxxx.js 后，需要执行 eval 就执行 eval，需要执行 base64 就执行 base64，直到没有 eval 和 base64 即可，可以分别用字符串 <code>eval(function</code> 和 <code>dswejwehxt(</code> 来判断是否需要 eval 和 base64（当然也有其他方式，比如 <code>()</code> 的个数等），示例代码如下所示：</p><pre><code class="python">def get_decrypted_js(encrypted_js_url):    &quot;&quot;&quot;    :param encrypted_js_url: encrypt_xxxxxx.js 的地址    :return: 解密后的 JS    &quot;&quot;&quot;    decrypted_js = requests.get(url=encrypted_js_url, headers=headers).text    flag = True    while flag:        if &quot;eval(function&quot; in decrypted_js:            # 需要执行 eval            print(&quot;需要执行 eval！&quot;)            replace_js = decrypted_js.replace(&quot;eval(function&quot;, &quot;(function&quot;)            decrypted_js = execjs.eval(replace_js)        elif &quot;dswejwehxt(&quot; in decrypted_js:            # 需要 base64 解码            base64_num = decrypted_js.count(&quot;dswejwehxt(&quot;)            print(&quot;需要 %s 次 base64 解码！&quot; % base64_num)            decrypted_js = re.findall(r&quot;\(&#39;(.*?)&#39;\)&quot;, decrypted_js)[0]            num = 0            while base64_num &gt; num:                decrypted_js = base64.b64decode(decrypted_js).decode()                num += 1        else:            # 得到明文            flag = False    # print(decrypted_js)    return decrypted_js</code></pre><h2 id="本地改写"><a href="#本地改写" class="headerlink" title="本地改写"></a>本地改写</h2><p>通过以上函数我们就拿到了动态的 JS 了，那么我们可以直接执行拿回来的 JS 吗？当然是不可以的，你可以自己本地执行一下，可以发现里面的 CryptoJS、Base64、hex_md5 都需要补齐才行，所以到这里我们就有两种做法：</p><ol><li>拿到解密后的动态 JS 后，动态 JS 和我们自己写的 Base64、hex_md5 等方法组成新的 JS 代码，执行新的 JS 代码拿到参数，这里还需要注意因为里面的其他方法名都是动态的，所以你还得想办法匹配到正确的方法名来调用才行，所以这种方法个人感觉还是稍微有点儿麻烦的；</li><li>我们本地自己写一个 JS，拿到解密后的动态 JS 后，把里面的 key、iv、appId、data 键名、param 是否需要 AES 或 DES 加密，这些信息都匹配出来，然后传给我们自己写的 JS，调用我们自己的方法拿到加密结果。</li></ol><p>虽然两种方法都很麻烦，但K哥暂时也想不到更好的解决方法了，有比较好的想法的朋友可以留言说一说。</p><p>以第二种方法为例，我们本地的 JS 示例（main.js）：</p><pre><code class="javascript">var CryptoJS = require(&quot;crypto-js&quot;);var BASE64 = &#123;    encrypt: function (text) &#123;        return CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(text))    &#125;,    decrypt: function (text) &#123;        return CryptoJS.enc.Base64.parse(text).toString(CryptoJS.enc.Utf8)    &#125;&#125;;var DES = &#123;    encrypt: function (text, key, iv) &#123;        var secretkey = (CryptoJS.MD5(key).toString()).substr(0, 16);        var secretiv = (CryptoJS.MD5(iv).toString()).substr(24, 8);        secretkey = CryptoJS.enc.Utf8.parse(secretkey);        secretiv = CryptoJS.enc.Utf8.parse(secretiv);        var result = CryptoJS.DES.encrypt(text, secretkey, &#123;            iv: secretiv,            mode: CryptoJS.mode.CBC,            padding: CryptoJS.pad.Pkcs7        &#125;);        return result.toString();    &#125;,    decrypt: function (text, key, iv) &#123;        var secretkey = (CryptoJS.MD5(key).toString()).substr(0, 16);        var secretiv = (CryptoJS.MD5(iv).toString()).substr(24, 8);        secretkey = CryptoJS.enc.Utf8.parse(secretkey);        secretiv = CryptoJS.enc.Utf8.parse(secretiv);        var result = CryptoJS.DES.decrypt(text, secretkey, &#123;            iv: secretiv,            mode: CryptoJS.mode.CBC,            padding: CryptoJS.pad.Pkcs7        &#125;);        return result.toString(CryptoJS.enc.Utf8);    &#125;&#125;;var AES = &#123;    encrypt: function (text, key, iv) &#123;        var secretkey = (CryptoJS.MD5(key).toString()).substr(16, 16);        var secretiv = (CryptoJS.MD5(iv).toString()).substr(0, 16);        secretkey = CryptoJS.enc.Utf8.parse(secretkey);        secretiv = CryptoJS.enc.Utf8.parse(secretiv);        var result = CryptoJS.AES.encrypt(text, secretkey, &#123;            iv: secretiv,            mode: CryptoJS.mode.CBC,            padding: CryptoJS.pad.Pkcs7        &#125;);        return result.toString();    &#125;,    decrypt: function (text, key, iv) &#123;        var secretkey = (CryptoJS.MD5(key).toString()).substr(16, 16);        var secretiv = (CryptoJS.MD5(iv).toString()).substr(0, 16);        secretkey = CryptoJS.enc.Utf8.parse(secretkey);        secretiv = CryptoJS.enc.Utf8.parse(secretiv);        var result = CryptoJS.AES.decrypt(text, secretkey, &#123;            iv: secretiv,            mode: CryptoJS.mode.CBC,            padding: CryptoJS.pad.Pkcs7        &#125;);        return result.toString(CryptoJS.enc.Utf8);    &#125;&#125;;function getDecryptedData(data, AES_KEY_1, AES_IV_1, DES_KEY_1, DES_IV_1) &#123;    data = AES.decrypt(data, AES_KEY_1, AES_IV_1);    data = DES.decrypt(data, DES_KEY_1, DES_IV_1);    data = BASE64.decrypt(data);    return data;&#125;function ObjectSort(obj) &#123;    var newObject = &#123;&#125;;    Object.keys(obj).sort().map(function (key) &#123;        newObject[key] = obj[key];    &#125;);    return newObject;&#125;function getRequestParam(method, obj, appId) &#123;    var clienttype = &#39;WEB&#39;;    var timestamp = new Date().getTime()    var param = &#123;        appId: appId,        method: method,        timestamp: timestamp,        clienttype: clienttype,        object: obj,        secret: CryptoJS.MD5(appId + method + timestamp + clienttype + JSON.stringify(ObjectSort(obj))).toString()    &#125;;    param = BASE64.encrypt(JSON.stringify(param));    return param;&#125;function getRequestAESParam(requestMethod, requestCity, appId, AES_KEY_2, AES_IV_2)&#123;    var param = getRequestParam(requestMethod, requestCity, appId);    return AES.encrypt(param, AES_KEY_2, AES_IV_2);&#125;function getRequestDESParam(requestMethod, requestCity, appId, DES_KEY_2, DES_IV_2)&#123;    var param = getRequestParam(requestMethod, requestCity, appId);    return DES.encrypt(param, DES_KEY_2, DES_IV_2);&#125;</code></pre><p>我们匹配 JS 里面的各项参数的 Python 代码示例（匹配8个 key、iv 值、appId 和 param 的加密方式）：</p><pre><code class="python">def get_key_iv_appid(decrypted_js):    &quot;&quot;&quot;    :param decrypted_js: 解密后的 encrypt_xxxxxx.js    :return: 请求必须的一些参数    &quot;&quot;&quot;    key_iv = re.findall(r&#39;const.*?&quot;(.*?)&quot;;&#39;, decrypted_js)    app_id = re.findall(r&quot;var appId.*?&#39;(.*?)&#39;;&quot;, decrypted_js)    request_data_name = re.findall(r&quot;aqistudyapi.php.*?data.*?&#123;(.*?):&quot;, decrypted_js, re.DOTALL)    # 判断 param 是 AES 加密还是 DES 加密还是没有加密    if &quot;AES.encrypt(param&quot; in decrypted_js:        request_param_encrypt = &quot;AES&quot;    elif &quot;DES.encrypt(param&quot; in decrypted_js:        request_param_encrypt = &quot;DES&quot;    else:        request_param_encrypt = &quot;NO&quot;    key_iv_appid = &#123;        # key 和 iv 的位置和原来 js 里的是一样的        &quot;aes_key_1&quot;: key_iv[0],        &quot;aes_iv_1&quot;: key_iv[1],        &quot;aes_key_2&quot;: key_iv[2],        &quot;aes_iv_2&quot;: key_iv[3],        &quot;des_key_1&quot;: key_iv[4],        &quot;des_iv_1&quot;: key_iv[5],        &quot;des_key_2&quot;: key_iv[6],        &quot;des_iv_2&quot;: key_iv[7],        &quot;app_id&quot;: app_id[0],        # 发送请求的 data 的键名        &quot;request_data_name&quot;: request_data_name[0].strip(),        # 发送请求的 data 值需要哪种加密        &quot;request_param_encrypt&quot;: request_param_encrypt    &#125;    # print(key_iv_appid)    return key_iv_appid</code></pre><p>我们发送请求以及解密返回值的 Python 代码示例（以北京为例）：</p><pre><code class="python">def get_data(key_iv_appid):    &quot;&quot;&quot;    :param key_iv_appid: get_key_iv_appid() 方法返回的值    &quot;&quot;&quot;    request_method = &quot;GETDATA&quot;    request_city = &#123;&quot;city&quot;: &quot;北京&quot;&#125;    with open(&#39;main.js&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:        execjs_ = execjs.compile(f.read())    # 根据不同加密方式调用不同方法获取请求加密的 param 参数    request_param_encrypt = key_iv_appid[&quot;request_param_encrypt&quot;]    if request_param_encrypt == &quot;AES&quot;:        param = execjs_.call(            &#39;getRequestAESParam&#39;, request_method, request_city,            key_iv_appid[&quot;app_id&quot;], key_iv_appid[&quot;aes_key_2&quot;], key_iv_appid[&quot;aes_iv_2&quot;]        )    elif request_param_encrypt == &quot;DES&quot;:        param = execjs_.call(            &#39;getRequestDESParam&#39;, request_method, request_city,            key_iv_appid[&quot;app_id&quot;], key_iv_appid[&quot;des_key_2&quot;], key_iv_appid[&quot;des_iv_2&quot;]        )    else:        param = execjs_.call(&#39;getRequestParam&#39;, request_method, request_city, key_iv_appid[&quot;app_id&quot;])    data = &#123;        key_iv_appid[&quot;request_data_name&quot;]: param    &#125;    response = requests.post(url=aqistudy_api, headers=headers, data=data).text    # print(response)    # 对获取的加密数据解密    decrypted_data = execjs_.call(        &#39;getDecryptedData&#39;, response,        key_iv_appid[&quot;aes_key_1&quot;], key_iv_appid[&quot;aes_iv_1&quot;],        key_iv_appid[&quot;des_key_1&quot;], key_iv_appid[&quot;des_iv_1&quot;]    )    print(json.loads(decrypted_data))</code></pre><p>运行结果，成功请求并解密返回值：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f6243a66a4ddcf72bb77b28bb94bc49d.png#pic_center" alt="27.png"></p>]]></content>
      
      
      <categories>
          
          <category> JS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS 逆向 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Loguru：Python 日志终极解决方案</title>
      <link href="/article/042/"/>
      <url>/article/042/</url>
      
        <content type="html"><![CDATA[<h2 id="日志的重要性"><a href="#日志的重要性" class="headerlink" title="日志的重要性"></a>日志的重要性</h2><p>日志的作用非常重要，日志可以记录用户的操作、程序的异常，还可以为数据分析提供依据，日志的存在意义就是为了能够在程序在运行过程中记录错误，方便维护和调试，能够快速定位出错的地方，减少维护成本。每个程序员都应该知道，不是为了记录日志而记录日志，日志也不是随意记的。要实现能够只通过日志文件还原整个程序执行的过程，达到能透明地看到程序里执行情况，每个线程、每个过程到底执行到哪的目的。日志就像飞机的黑匣子一样，应当能够复原异常的整个现场乃至细节！</p><h2 id="常见日志记录方式"><a href="#常见日志记录方式" class="headerlink" title="常见日志记录方式"></a>常见日志记录方式</h2><h3 id="一、print"><a href="#一、print" class="headerlink" title="一、print()"></a>一、print()</h3><p>最常见的是把输出函数 <code>print()</code> 当作日志记录的方式，直接打印各种提示信息，常见于个人练习项目里，通常是懒得单独配置日志，而且项目太小不需要日志信息，不需要上线，不需要持续运行，完整的项目不推荐直接打印日志信息，现实中也几乎没有人这么做。</p><h3 id="二、自写模板"><a href="#二、自写模板" class="headerlink" title="二、自写模板"></a>二、自写模板</h3><p>我们可以在不少小项目里面看到作者自己写了一个日志模板，通常利用 <code>print()</code> 或者 <code>sys.stdout</code> 稍微封装一下即可实现简单的日志输出，这里的 <code>sys.stdout</code> 是 Python 中的标准输出流，<code>print()</code> 函数是对 <code>sys.stdout</code> 的高级封装，当我们在 Python 中打印对象调用 <code>print(obj)</code> 时候，事实上是调用了 <code>sys.stdout.write(obj+&#39;\n&#39;)</code>，<code>print()</code> 将内容打印到了控制台，然后追加了一个换行符 <code>\n</code>。</p><p>自写日志模板适合比较小的项目，可以按照自己的喜好编写模板，不需要太多复杂配置，方便快捷，但是这种记录日志的方式并不是很规范，有可能你自己觉得阅读体验不错，但是别人在接触你的项目的时候往往需要花费一定的时间去学习日志的逻辑、格式、输出方式等，比较大的项目同样不推荐这种方法。</p><p>一个简单的自写日志模板举例：</p><p>日志模板 log.py：</p><pre><code class="python">import sysimport tracebackimport datetimedef getnowtime():    return datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)def _log(content, level, *args):    sys.stdout.write(&quot;%s - %s - %s\n&quot; % (getnowtime(), level, content))    for arg in args:        sys.stdout.write(&quot;%s\n&quot; % arg)def debug(content, *args):    _log(content, &#39;DEBUG&#39;, *args)def info(content, *args):    _log(content, &#39;INFO&#39;, *args)def warn(content, *args):    _log(content, &#39;WARN&#39;, *args)def error(content, *args):    _log(content, &#39;ERROR&#39;, *args)def exception(content):    sys.stdout.write(&quot;%s - %s\n&quot; % (getnowtime(), content))    traceback.print_exc(file=sys.stdout)</code></pre><p>调用日志模块：</p><pre><code class="python">import loglog.info(&quot;This is log info!&quot;)log.warn(&quot;This is log warn!&quot;)log.error(&quot;This is log error!&quot;)log.debug(&quot;This is log debug!&quot;)people_info = &#123;&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 20&#125;try:    gender = people_info[&quot;gender&quot;]except Exception as error:    log.exception(error)</code></pre><p>日志输出：</p><pre><code class="python">2021-10-19 09:50:58 - INFO - This is log info!2021-10-19 09:50:58 - WARN - This is log warn!2021-10-19 09:50:58 - ERROR - This is log error!2021-10-19 09:50:58 - DEBUG - This is log debug!2021-10-19 09:50:58 - &#39;gender&#39;Traceback (most recent call last):  File &quot;D:/python3Project/test.py&quot;, line 18, in &lt;module&gt;    gender = people_info[&quot;gender&quot;]KeyError: &#39;gender&#39;</code></pre><h3 id="三、Logging"><a href="#三、Logging" class="headerlink" title="三、Logging"></a>三、Logging</h3><p>在一个完整的项目中，大多数人都会引入专门的日志记录库，而 Python 自带的标准库 logging 就是专门为日志记录而生的，logging 模块定义的函数和类为应用程序和库的开发实现了一个灵活的事件日志系统。由标准库模块提供日志记录 API 的关键好处是所有 Python 模块都可以使用这个日志记录功能。所以，你的应用日志可以将你自己的日志信息与来自第三方模块的信息整合起来。</p><p>logging 模块虽然强大，但是其配置也是比较繁琐的，在大型项目中通常需要单独初始化日志、配置日志格式等等，我在日常使用中通常都会对 logging 做如下的封装写法，使日志可以按天保存，保留15天的日志，可以配置是否输出到控制台和文件，如下所示：</p><pre><code class="python"># 实现按天分割保留日志import osimport sysimport loggingfrom logging import handlersPARENT_DIR = os.path.split(os.path.realpath(__file__))[0]  # 父目录LOGGING_DIR = os.path.join(PARENT_DIR, &quot;log&quot;)              # 日志目录LOGGING_NAME = &quot;test&quot;                                      # 日志文件名LOGGING_TO_FILE = True                                     # 日志输出文件LOGGING_TO_CONSOLE = True                                  # 日志输出到控制台LOGGING_WHEN = &#39;D&#39;                                         # 日志文件切分维度LOGGING_INTERVAL = 1                                       # 间隔少个 when 后，自动重建文件LOGGING_BACKUP_COUNT = 15                                  # 日志保留个数，0 保留所有日志LOGGING_LEVEL = logging.DEBUG                              # 日志等级LOGGING_suffix = &quot;%Y.%m.%d.log&quot;                            # 旧日志文件名# 日志输出格式LOGGING_FORMATTER = &quot;%(levelname)s - %(asctime)s - process:%(process)d - %(filename)s - %(name)s - line:%(lineno)d - %(module)s - %(message)s&quot;def logging_init():    if not os.path.exists(LOGGING_DIR):        os.makedirs(LOGGING_DIR)    logger = logging.getLogger()    logger.setLevel(LOGGING_LEVEL)    formatter = logging.Formatter(LOGGING_FORMATTER)    if LOGGING_TO_FILE:        file_handler = handlers.TimedRotatingFileHandler(filename=os.path.join(LOGGING_DIR, LOGGING_NAME), when=LOGGING_WHEN, interval=LOGGING_INTERVAL, backupCount=LOGGING_BACKUP_COUNT)        file_handler.suffix = LOGGING_suffix        file_handler.setFormatter(formatter)        logger.addHandler(file_handler)    if LOGGING_TO_CONSOLE:        stream_handler = logging.StreamHandler(sys.stderr)        stream_handler.setFormatter(formatter)        logger.addHandler(stream_handler)def logging_test():    logging.info(&quot;This is log info!&quot;)    logging.warning(&quot;This is log warn!&quot;)    logging.error(&quot;This is log error!&quot;)    logging.debug(&quot;This is log debug!&quot;)    people_info = &#123;&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 20&#125;    try:        gender = people_info[&quot;gender&quot;]    except Exception as error:        logging.exception(error)if __name__ == &quot;__main__&quot;:    logging_init()    logging_test()</code></pre><p>输出日志：</p><pre><code class="bash">INFO - 2021-10-19 11:28:10,103 - process:15144 - test.py - root - line:52 - test - This is log info!WARNING - 2021-10-19 11:28:10,105 - process:15144 - test.py - root - line:53 - test - This is log warn!ERROR - 2021-10-19 11:28:10,105 - process:15144 - test.py - root - line:54 - test - This is log error!DEBUG - 2021-10-19 11:28:10,105 - process:15144 - test.py - root - line:55 - test - This is log debug!ERROR - 2021-10-19 11:28:10,105 - process:15144 - test.py - root - line:61 - test - &#39;gender&#39;Traceback (most recent call last):  File &quot;D:/python3Project/test.py&quot;, line 59, in logging_test    gender = people_info[&quot;gender&quot;]KeyError: &#39;gender&#39;</code></pre><p>它在控制台中是这样的：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/906ed37334702098905b7cff083f2c6e.png" alt="02.png"></p><p>当然，如果你不需要很复杂的功能，希望简洁一点，仅仅需要在控制台输出一下日志的话，也可以只进行简单的配置：</p><pre><code class="python">import logginglogging.basicConfig(level=logging.DEBUG, format=&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)logging.getLogger()</code></pre><h2 id="更优雅的解决方案：Loguru"><a href="#更优雅的解决方案：Loguru" class="headerlink" title="更优雅的解决方案：Loguru"></a>更优雅的解决方案：Loguru</h2><p>对于 logging 模块，即便是简单的使用，也需要自己定义格式，这里介绍一个更加优雅、高效、简洁的第三方模块：loguru，官方的介绍是：Loguru is a library which aims to bring enjoyable logging in Python. Loguru 旨在为 Python 带来愉快的日志记录。这里引用官方的一个 GIF 来快速演示其功能：</p><p><img src="https://img-blog.csdnimg.cn/d2cfb68d514240209779ae9dac5a42cb.gif#pic_center" alt="02.gif"></p><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Loguru 仅支持 Python 3.5 及以上的版本，使用 pip 安装即可：</p><pre><code class="bash">pip install loguru</code></pre><hr><h3 id="开箱即用"><a href="#开箱即用" class="headerlink" title="开箱即用"></a>开箱即用</h3><p>Loguru 的主要概念是只有一个：logger</p><pre><code class="python">from loguru import loggerlogger.info(&quot;This is log info!&quot;)logger.warning(&quot;This is log warn!&quot;)logger.error(&quot;This is log error!&quot;)logger.debug(&quot;This is log debug!&quot;)</code></pre><p>控制台输出：</p><p><img src="https://img-blog.csdnimg.cn/345214edaba24e988379399393ac0a7f.png" alt="03.png"></p><p>可以看到不需要手动设置，Loguru 会提前配置一些基础信息，自动输出时间、日志级别、模块名、行号等信息，而且根据等级的不同，还自动设置了不同的颜色，方便观察，真正做到了开箱即用！</p><hr><h3 id="add-remove"><a href="#add-remove" class="headerlink" title="add() / remove()"></a>add() / remove()</h3><p>如果想自定义日志级别，自定义日志格式，保存日志到文件该怎么办？与 logging 模块不同，不需要 Handler，不需要 Formatter，只需要一个 <code>add()</code> 函数就可以了，例如我们想把日志储存到文件：</p><pre><code class="python">from loguru import loggerlogger.add(&#39;test.log&#39;)logger.debug(&#39;this is a debug&#39;)</code></pre><p>我们不需要像 logging 模块一样再声明一个 FileHandler 了，就一行 <code>add()</code> 语句搞定，运行之后会发现目录下 test.log 里面同样出现了刚刚控制台输出的 debug 信息。 </p><p>与 <code>add()</code> 语句相反，<code>remove()</code> 语句可以删除我们添加的配置：</p><pre><code class="python">from loguru import loggerlog_file = logger.add(&#39;test.log&#39;)logger.debug(&#39;This is log debug!&#39;)logger.remove(log_file)logger.debug(&#39;This is another log debug!&#39;)</code></pre><p>此时控制台会输出两条 debug 信息：</p><pre><code class="bash">2021-10-19 13:53:36.610 | DEBUG    | __main__:&lt;module&gt;:86 - This is log debug!2021-10-19 13:53:36.611 | DEBUG    | __main__:&lt;module&gt;:88 - This is another log debug!</code></pre><p>而 test.log 日志文件里面只有一条 debug  信息，原因就在于我们在第二条 debug 语句之前使用了 <code>remove()</code> 语句。</p><hr><h3 id="完整参数"><a href="#完整参数" class="headerlink" title="完整参数"></a>完整参数</h3><p>Loguru 对输出到文件的配置有非常强大的支持，比如支持输出到多个文件，分级别分别输出，过大创建新文件，过久自动删除等等。 下面我们来详细看一下 <code>add()</code> 语句的详细参数：</p><p>基本语法：</p><pre><code class="python">add(sink, *, level=&#39;DEBUG&#39;, format=&#39;&lt;green&gt;&#123;time:YYYY-MM-DD HH:mm:ss.SSS&#125;&lt;/green&gt; | &lt;level&gt;&#123;level: &lt;8&#125;&lt;/level&gt; | &lt;cyan&gt;&#123;name&#125;&lt;/cyan&gt;:&lt;cyan&gt;&#123;function&#125;&lt;/cyan&gt;:&lt;cyan&gt;&#123;line&#125;&lt;/cyan&gt; - &lt;level&gt;&#123;message&#125;&lt;/level&gt;&#39;, filter=None, colorize=None, serialize=False, backtrace=True, diagnose=True, enqueue=False, catch=True, **kwargs)</code></pre><p><strong>基本参数释义：</strong></p><ul><li><strong>sink</strong>：可以是一个 file 对象，例如 <code>sys.stderr</code> 或 <code>open(&#39;file.log&#39;, &#39;w&#39;)</code>，也可以是 <code>str</code> 字符串或者 <code>pathlib.Path</code> 对象，即文件路径，也可以是一个方法，可以自行定义输出实现，也可以是一个 logging 模块的 Handler，比如 FileHandler、StreamHandler 等，还可以是 <a href="https://docs.python.org/3/glossary.html#term-coroutine-function">coroutine function</a>，即一个返回协程对象的函数等。</li><li><strong>level</strong>：日志输出和保存级别。</li><li><strong>format</strong>：日志格式模板。</li><li><strong>filter</strong>：一个可选的指令，用于决定每个记录的消息是否应该发送到 sink。</li><li><strong>colorize</strong>：格式化消息中包含的颜色标记是否应转换为用于终端着色的 ansi 代码，或以其他方式剥离。 如果没有，则根据 sink 是否为 tty（电传打字机缩写） 自动做出选择。</li><li><strong>serialize</strong>：在发送到 sink 之前，是否应首先将记录的消息转换为 JSON 字符串。</li><li><strong>backtrace</strong>：格式化的异常跟踪是否应该向上扩展，超出捕获点，以显示生成错误的完整堆栈跟踪。</li><li><strong>diagnose</strong>：异常跟踪是否应显示变量值以简化调试。建议在生产环境中设置 <code>False</code>，避免泄露敏感数据。</li><li><strong>enqueue</strong>：要记录的消息是否应在到达 sink 之前首先通过多进程安全队列，这在通过多个进程记录到文件时很有用，这样做的好处还在于使日志记录调用是非阻塞的。</li><li><strong>catch</strong>：是否应自动捕获 sink 处理日志消息时发生的错误，如果为 <code>True</code>，则会在 <code>sys.stderr</code> 上显示异常消息，但该异常不会传播到 sink，从而防止应用程序崩溃。</li><li>*<strong>*kwargs</strong>：仅对配置协程或文件接收器有效的附加参数（见下文）。</li></ul><p><strong>当且仅当 sink 是协程函数时，以下参数适用：</strong></p><ul><li><strong>loop</strong>：将在其中调度和执行异步日志记录任务的事件循环。如果为 <code>None</code>，将使用 <code>asyncio.get_event_loop()</code> 返回的循环。</li></ul><p><strong>当且仅当 sink 是文件路径时，以下参数适用：</strong></p><ul><li><strong>rotation</strong>：一种条件，指示何时应关闭当前记录的文件并开始新的文件。</li><li>**retention **：过滤旧文件的指令，在循环或程序结束期间会删除旧文件。</li><li><strong>compression</strong>：日志文件在关闭时应转换为的压缩或存档格式。</li><li><strong>delay</strong>：是在配置 sink 后立即创建文件，还是延迟到第一条记录的消息时再创建。默认为 <code>False</code>。</li><li><strong>mode</strong>：内置 <code>open()</code> 函数的打开模式，默认为 <code>a</code>（以追加模式打开文件）。</li><li><strong>buffering</strong>：内置 <code>open()</code> 函数的缓冲策略，默认为<code>1</code>（行缓冲文件）。</li><li><strong>encoding</strong>：内置 <code>open()</code> 函数的文件编码，如果 <code>None</code>，则默认为 <a href="https://docs.python.org/3/library/locale.html#locale.getpreferredencoding"><code>locale.getpreferredencoding()</code></a>。</li><li>*<strong>*kwargs</strong>：其他传递给内置 <code>open()</code> 函数的参数。</li></ul><p>这么多参数可以见识到 <code>add()</code> 函数的强大之处，仅仅一个函数就能实现 logging 模块的诸多功能，接下来介绍几个比较常用的方法。</p><hr><h3 id="rotation-日志文件分隔"><a href="#rotation-日志文件分隔" class="headerlink" title="rotation 日志文件分隔"></a>rotation 日志文件分隔</h3><p><code>add()</code> 函数的 rotation 参数，可以实现按照固定时间创建新的日志文件，比如设置每天 0 点新创建一个 log 文件：</p><pre><code class="python">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, rotation=&#39;00:00&#39;)</code></pre><p>设置超过 500 MB 新创建一个 log 文件：</p><pre><code class="python">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, rotation=&quot;500 MB&quot;)</code></pre><p>设置每隔一个周新创建一个 log 文件：</p><pre><code class="python">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, rotation=&#39;1 week&#39;)</code></pre><hr><h3 id="retention-日志保留时间"><a href="#retention-日志保留时间" class="headerlink" title="retention 日志保留时间"></a>retention 日志保留时间</h3><p><code>add()</code> 函数的 retention 参数，可以设置日志的最长保留时间，比如设置日志文件最长保留 15 天：</p><pre><code class="python">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, retention=&#39;15 days&#39;)</code></pre><p>设置日志文件最多保留 10 个：</p><pre><code class="python">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, retention=10)</code></pre><p>也可以是一个 <code>datetime.timedelta</code> 对象，比如设置日志文件最多保留 5 个小时：</p><pre><code class="python">import datetimefrom loguru import loggerlogger.add(&#39;runtime_&#123;time&#125;.log&#39;, retention=datetime.timedelta(hours=5))</code></pre><hr><h3 id="compression-日志压缩格式"><a href="#compression-日志压缩格式" class="headerlink" title="compression 日志压缩格式"></a>compression 日志压缩格式</h3><p><code>add()</code> 函数的 compression 参数，可以配置日志文件的压缩格式，这样可以更加节省存储空间，比如设置使用 zip 文件格式保存：</p><pre><code class="python">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, compression=&#39;zip&#39;)</code></pre><p>其格式支持：<code>gz</code>、<code>bz2</code>、<code>xz</code>、<code>lzma</code>、<code>tar</code>、<code>tar.gz</code>、<code>tar.bz2</code>、<code>tar.xz</code></p><hr><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>Loguru 在输出 log 的时候还提供了非常友好的字符串格式化功能，相当于 <code>str.format()</code>：</p><pre><code class="python">logger.info(&#39;If you are using Python &#123;&#125;, prefer &#123;feature&#125; of course!&#39;, 3.6, feature=&#39;f-strings&#39;)</code></pre><p>输出：</p><pre><code class="python">2021-10-19 14:59:06.412 | INFO     | __main__:&lt;module&gt;:3 - If you are using Python 3.6, prefer f-strings of course!</code></pre><hr><h3 id="异常追溯"><a href="#异常追溯" class="headerlink" title="异常追溯"></a>异常追溯</h3><p>在 Loguru 里可以直接使用它提供的装饰器就可以直接进行异常捕获，而且得到的日志是无比详细的：</p><pre><code class="python">from loguru import logger@logger.catchdef my_function(x, y, z):    # An error? It&#39;s caught anyway!    return 1 / (x + y + z)my_function(0, 0, 0)</code></pre><p>日志输出：</p><pre><code class="python">2021-10-19 15:04:51.675 | ERROR    | __main__:&lt;module&gt;:10 - An error has been caught in function &#39;&lt;module&gt;&#39;, process &#39;MainProcess&#39; (30456), thread &#39;MainThread&#39; (26268):Traceback (most recent call last):&gt; File &quot;D:/python3Project\test.py&quot;, line 10, in &lt;module&gt;    my_function(0, 0, 0)    └ &lt;function my_function at 0x014CDFA8&gt;  File &quot;D:/python3Project\test.py&quot;, line 7, in my_function    return 1 / (x + y + z)                │   │   └ 0                │   └ 0                └ 0ZeroDivisionError: division by zero</code></pre><p>在控制台的输出是这样的：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3b7fd75ef2a10a5a0dde917280d9224c.png" alt="04.png"></p><p>相比 Logging，Loguru 无论是在配置方面、日志输出样式还是异常追踪，都远优于 Logging，使用 Loguru 无疑能提升开发人员效率。本文仅介绍了一些常用的方法，想要详细了解可参考 <a href="https://loguru.readthedocs.io/">Loguru 官方文档</a>或关注 <a href="https://github.com/Delgan/loguru">Loguru GitHub</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识 SM1/SM2/SM3/SM4/SM7/SM9/ZUC 国密算法</title>
      <link href="/article/041/"/>
      <url>/article/041/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><font color=#B01B15>简介</font></h2><p>国密即国家密码局认定的国产加密算法，爬虫工程师在做 JS 逆向的时候，会遇到各种各样的加密算法，其中 RSA、AES、SHA 等算法是最常见的，这些算法都是国外的，在我以前的文章里也有介绍：<a href="https://itrhx.blog.csdn.net/article/details/119250052">《史上最全总结！爬虫常见加密解密算法》</a></p><p>事实上从 2010 年开始，我国国家密码管理局就已经开始陆续发布了一系列国产加密算法，这其中就包括 SM1、SM2、SM3 、SM4、SM7、SM9、ZUC（祖冲之加密算法）等，SM 代表商密，即商业密码，是指用于商业的、不涉及国家秘密的密码技术。<strong>SM1 和 SM7 的算法不公开</strong>，其余算法都已成为 ISO/IEC 国际标准。</p><p>在这些国产加密算法中，**<font color=#B01B15>SM2、SM3、SM4 三种加密算法是比较常见的</font>**，在爬取部分 gov 网站时，也可能会遇到这些算法，所以作为爬虫工程师是有必要了解一下这些算法的，如下图所示某 gov 网站就使用了 SM2 和 SM4 加密算法：</p><p><img src="https://img-blog.csdnimg.cn/758cb19d1fbc4ec5ad7cc33781c2f34e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVFJIWCDigKIg6bKN5YuD,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"></p><hr><h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a><font color=#B01B15>算法概述</font></h2><table><thead><tr><th align="center">算法名称</th><th align="center">算法类别</th><th align="center">应用领域</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">SM1</td><td align="center">对称（分组）加密算法</td><td align="center">芯片</td><td align="center">分组长度、密钥长度均为 128 比特</td></tr><tr><td align="center">SM2</td><td align="center">非对称（基于椭圆曲线 ECC）加密算法</td><td align="center">数据加密</td><td align="center">ECC 椭圆曲线密码机制 256 位，相比 RSA 处理速度快，消耗更少</td></tr><tr><td align="center">SM3</td><td align="center">散列（hash）函数算法</td><td align="center">完整性校验</td><td align="center">安全性及效率与 SHA-256 相当，压缩函数更复杂</td></tr><tr><td align="center">SM4</td><td align="center">对称（分组）加密算法</td><td align="center">数据加密和局域网产品</td><td align="center">分组长度、密钥长度均为 128 比特，计算轮数多</td></tr><tr><td align="center">SM7</td><td align="center">对称（分组）加密算法</td><td align="center">非接触式 IC 卡</td><td align="center">分组长度、密钥长度均为 128 比特</td></tr><tr><td align="center">SM9</td><td align="center">标识加密算法（IBE）</td><td align="center">端对端离线安全通讯</td><td align="center">加密强度等同于 3072 位密钥的 RSA 加密算法</td></tr><tr><td align="center">ZUC</td><td align="center">对称（序列）加密算法</td><td align="center">移动通信 4G 网络</td><td align="center">流密码</td></tr></tbody></table><hr><h2 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a><font color=#B01B15>算法详解</font></h2><h3 id="SM1-分组加密算法"><a href="#SM1-分组加密算法" class="headerlink" title="SM1 分组加密算法"></a>SM1 分组加密算法</h3><p>SM1 为分组加密算法，对称加密，分组长度和密钥长度都为 128 位，故对消息进行加解密时，若消息长度过长，需要进行分组，要消息长度不足，则要进行填充。算法安全保密强度及相关软硬件实现性能与 AES 相当，该算法不公开，仅以 IP 核的形式存在于芯片中，调用该算法时，需要通过加密芯片的接口进行调用，采用该算法已经研制了系列芯片、智能 IC 卡、智能密码钥匙、加密卡、加密机等安全产品，广泛应用于电子政务、电子商务及国民经济的各个应用领域（包括国家政务通、警务通等重要领域），一般了解的人比较少，爬虫工程师也不会遇到这种加密算法。</p><h3 id="椭圆曲线公钥加密算法"><a href="#椭圆曲线公钥加密算法" class="headerlink" title="椭圆曲线公钥加密算法"></a>椭圆曲线公钥加密算法</h3><p>SM2 为椭圆曲线（ECC）公钥加密算法，非对称加密，SM2 算法和 RSA 算法都是公钥加密算法，SM2 算法是一种更先进安全的算法，在我们国家商用密码体系中被用来替换 RSA 算法，在不少 gov 网站会见到此类加密算法。我国学者对椭圆曲线密码的研究从 20 世纪 80 年代开始，目前已取得不少成果，SM2 椭圆曲线公钥密码算法比 RSA 算法有以下优势：</p><table><thead><tr><th align="center"></th><th align="center">SM2</th><th align="center">RSA</th></tr></thead><tbody><tr><td align="center">安全性</td><td align="center">256 位 SM2 强度已超过 RSA-2048</td><td align="center">一般</td></tr><tr><td align="center">算法结构</td><td align="center">基本椭圆曲线（ECC）</td><td align="center">基于特殊的可逆模幂运算</td></tr><tr><td align="center">计算复杂度</td><td align="center">完全指数级</td><td align="center">亚指数级</td></tr><tr><td align="center">存储空间（密钥长度）</td><td align="center">192-256 bit</td><td align="center">2048-4096 bit</td></tr><tr><td align="center">秘钥生成速度</td><td align="center">较 RSA 算法快百倍以上</td><td align="center">慢</td></tr><tr><td align="center">解密加密速度</td><td align="center">较快</td><td align="center">一般</td></tr></tbody></table><h3 id="杂凑算法"><a href="#杂凑算法" class="headerlink" title="杂凑算法"></a>杂凑算法</h3><p>SM3 为密码杂凑算法，采用密码散列（hash）函数标准，用于替代 MD5/SHA-1/SHA-2 等国际算法，是在 SHA-256 基础上改进实现的一种算法，消息分组长度为 512 位，摘要值长度为 256 位，其中使用了异或、模、模加、移位、与、或、非运算，由填充、迭代过程、消息扩展和压缩函数所构成。在商用密码体系中，SM3 主要用于数字签名及验证、消息认证码生成及验证、随机数生成等。据国家密码管理局表示，其安全性及效率要高于 MD5 算法和 SHA-1 算法，与 SHA-256 相当。</p><h3 id="分组加密算法"><a href="#分组加密算法" class="headerlink" title="分组加密算法"></a>分组加密算法</h3><p>SM4 为无线局域网标准的分组加密算法，对称加密，用于替代 DES/AES 等国际算法，SM4 算法与 AES 算法具有相同的密钥长度和分组长度，均为 128 位，故对消息进行加解密时，若消息长度过长，需要进行分组，要消息长度不足，则要进行填充。加密算法与密钥扩展算法都采用 32 轮非线性迭代结构，解密算法与加密算法的结构相同，只是轮密钥的使用顺序相反，解密轮密钥是加密轮密钥的逆序。</p><table><thead><tr><th></th><th>SM4</th><th>DES</th><th>AES</th></tr></thead><tbody><tr><td>计算轮数</td><td>32</td><td>16（3DES 为 16*3）</td><td>10/12/14</td></tr><tr><td>密码部件</td><td>S 盒、非线性变换、线性变换、合成变换</td><td>标准算术和逻辑运算、先替换后置换，不含线性变换</td><td>S 盒、行移位变换、列混合变换、圈密钥加变换（AddRoundKey）</td></tr></tbody></table><h3 id="分组加密算法-1"><a href="#分组加密算法-1" class="headerlink" title="分组加密算法"></a>分组加密算法</h3><p>SM7 为分组加密算法，对称加密，该算法不公开，应用包括身份识别类应用（非接触式 IC 卡、门禁卡、工作证、参赛证等），票务类应用（大型赛事门票、展会门票等），支付与通卡类应用（积分消费卡、校园一卡通、企业一卡通等）。爬虫工程师基本上不会遇到此类算法。</p><h3 id="标识加密算法"><a href="#标识加密算法" class="headerlink" title="标识加密算法"></a>标识加密算法</h3><p>SM9 为标识加密算法（Identity-Based Cryptography），非对称加密，标识加密将用户的标识（如微信号、邮件地址、手机号码、QQ 号等）作为公钥，省略了交换数字证书和公钥过程，使得安全系统变得易于部署和管理，适用于互联网应用的各种新兴应用的安全保障，如基于云技术的密码服务、电子邮件安全、智能终端保护、物联网安全、云存储安全等等。这些安全应用可采用手机号码或邮件地址作为公钥，实现数据加密、身份认证、通话加密、通道加密等。在商用密码体系中，SM9 主要用于用户的身份认证，据新华网公开报道，SM9 的加密强度等同于 3072 位密钥的 RSA 加密算法。</p><h3 id="祖冲之算法"><a href="#祖冲之算法" class="headerlink" title="祖冲之算法"></a>祖冲之算法</h3><p>ZUC 为流密码算法，对称加密，该机密性算法可适用于 3GPP LTE 通信中的加密和解密，该算法包括祖冲之算法（ZUC）、机密性算法（128-EEA3）和完整性算法（128-EIA3）三个部分。已经被国际组织 3GPP 推荐为 4G 无线通信的第三套国际加密和完整性标准的候选算法。</p><hr><h2 id="编程语言实现"><a href="#编程语言实现" class="headerlink" title="编程语言实现"></a><font color=#B01B15>编程语言实现</font></h2><h3 id="Python-语言实现"><a href="#Python-语言实现" class="headerlink" title="Python 语言实现"></a>Python 语言实现</h3><p>在 Python 里面并没有比较官方的库来实现国密算法，这里仅列出了其中两个较为完善的第三方库，需要注意的是，SM1 和 SM7 算法不公开，目前大多库仅实现了 SM2、SM3、SM4 三种密算法。</p><ul><li>snowland-smx-python：<a href="https://gitee.com/snowlandltd/snowland-smx-python">https://gitee.com/snowlandltd/snowland-smx-python</a></li><li>gmssl：<a href="https://github.com/duanhongyi/gmssl">https://github.com/duanhongyi/gmssl</a></li><li>gmssl-python：<a href="https://github.com/gongxian-ding/gmssl-python">https://github.com/gongxian-ding/gmssl-python</a></li></ul><p>其中 gmssl-python 是 gmssl 的改进版，gmssl-python 新增支持了 SM9 算法，不过截止本文编写时，gmssl-python 并未发布 pypi，也未 PR 到 gmssl，使用 <code>pip install gmssl</code> 安装的 gmssl 不支持 SM9 算法。若要使用 SM9 算法，可下载 gmssl-python 源码手动安装。</p><p>以 gmssl 的 SM2 算法为例，实现如下（其他算法和详细用法可参考其官方文档）：</p><p>SM2 加密（encrypt）和解密（decrypt）：</p><pre><code class="python">from gmssl import sm2# 16 进制的公钥和私钥private_key = &#39;00B9AB0B828FF68872F21A837FC303668428DEA11DCD1B24429D0C99E24EED83D5&#39;public_key = &#39;B9C9A6E04E9C91F7BA880429273747D7EF5DDEB0BB2FF6317EB00BEF331A83081A6994B8993F3F5D6EADDDB81872266C87C018FB4162F5AF347B483E24620207&#39;sm2_crypt = sm2.CryptSM2(public_key=public_key, private_key=private_key)# 待加密数据和加密后数据为 bytes 类型data = b&quot;this is the data to be encrypted&quot;enc_data = sm2_crypt.encrypt(data)dec_data = sm2_crypt.decrypt(enc_data)print(&#39;enc_data: &#39;, enc_data.hex())print(&#39;dec_data: &#39;, dec_data)# enc_data:  3cb96dd2e0b6c24df8e22a5da3951d061a6ee6ce99f46a446426feca83e501073288b1553ca8d91fad79054e26696a27c982492466dafb5ed06a573fb09947f2aed8dfae243b095ab88115c584bb6f0814efe2f338a00de42b244c99698e81c7913c1d82b7609557677a36681dd10b646229350ad0261b51ca5ed6030d660947# dec_data:  b&#39;this is the data to be encrypted&#39;</code></pre><p>SM2 签名（sign）和校验（verify）：</p><pre><code class="python">from gmssl import sm2, func# 16 进制的公钥和私钥private_key = &#39;00B9AB0B828FF68872F21A837FC303668428DEA11DCD1B24429D0C99E24EED83D5&#39;public_key = &#39;B9C9A6E04E9C91F7BA880429273747D7EF5DDEB0BB2FF6317EB00BEF331A83081A6994B8993F3F5D6EADDDB81872266C87C018FB4162F5AF347B483E24620207&#39;sm2_crypt = sm2.CryptSM2(public_key=public_key, private_key=private_key)# 待签名数据为 bytes 类型data = b&quot;this is the data to be signed&quot;random_hex_str = func.random_hex(sm2_crypt.para_len)#  16 进制sign = sm2_crypt.sign(data, random_hex_str)verify = sm2_crypt.verify(sign, data)print(&#39;sign: &#39;, sign)print(&#39;verify: &#39;, verify)# sign:  45cfe5306b1a87cf5d0034ef6712babdd1d98547e75bcf89a17f3bcb617150a3f111ab05597601bab8c41e2b980754b74ebe9a169a59db37d549569910ae273a# verify:  True</code></pre><h3 id="JavaScript-语言实现"><a href="#JavaScript-语言实现" class="headerlink" title="JavaScript 语言实现"></a>JavaScript 语言实现</h3><p>在 JavaScript 中已有比较成熟的实现库，这里推荐 sm-crypto，目前支持 SM2、SM3 和 SM4，需要注意的是，SM2 非对称加密的结果由 C1、C2、C3 三部分组成，其中 C1 是生成随机数的计算出的椭圆曲线点，C2 是密文数据，C3 是 SM3 的摘要值，最开始的国密标准的结果是按 C1C2C3 顺序的，新标准的是按 C1C3C2 顺序存放的，sm-crypto 支持设置 cipherMode，也就是 C1C2C3 的排列顺序。</p><p>sm-crypto：<a href="https://www.npmjs.com/package/sm-crypto">https://www.npmjs.com/package/sm-crypto</a></p><p>以 SM2 算法为例，实现如下（其他算法和详细用法可参考其官方文档）：</p><p>SM2 加密（encrypt）和解密（decrypt）：</p><pre><code class="javascript">const sm2 = require(&#39;sm-crypto&#39;).sm2// 1 - C1C3C2，0 - C1C2C3，默认为1const cipherMode = 1// 获取密钥对let keypair = sm2.generateKeyPairHex()let publicKey = keypair.publicKey   // 公钥let privateKey = keypair.privateKey // 私钥let msgString = &quot;this is the data to be encrypted&quot;let encryptData = sm2.doEncrypt(msgString, publicKey, cipherMode)    // 加密结果let decryptData = sm2.doDecrypt(encryptData, privateKey, cipherMode) // 解密结果console.log(&quot;encryptData: &quot;, encryptData)console.log(&quot;decryptData: &quot;, decryptData)// encryptData:  ddf261103fae06d0efe20ea0fe0d82bcc170e8efd8eeae24e9559b3835993f0ed2acb8ba6782fc21941ee74ca453d77664a5cb7dbb91517e6a3b0c27db7ce587ae7af54f8df48d7fa822b7062e2af66c112aa57de94d12ba28e5ba96bf4439d299b41da4a5282d054696adc64156d248049d1eb1d0af28d76b542fe8a95d427e// decryptData:  this is the data to be encrypted</code></pre><p>SM2 签名（sign）和校验（verify）：</p><pre><code class="javascript">const sm2 = require(&#39;sm-crypto&#39;).sm2// 获取密钥对let keypair = sm2.generateKeyPairHex()let publicKey = keypair.publicKey   // 公钥let privateKey = keypair.privateKey // 私钥// 纯签名 + 生成椭圆曲线点let msgString = &quot;this is the data to be signed&quot;let sigValueHex = sm2.doSignature(msgString, privateKey)                    // 签名let verifyResult = sm2.doVerifySignature(msgString, sigValueHex, publicKey) // 验签结果console.log(&quot;sigValueHex: &quot;, sigValueHex)console.log(&quot;verifyResult: &quot;, verifyResult)// sigValueHex:  924cbb9f2b5adb554ef77129ff1e3a00b2da42017ad3ec2f806d824a77646987ba8c8c4fb94576c38bc11ae69cc98ebbb40b5d47715171ec7dcea913dfc6ccc1// verifyResult:  true</code></pre><h3 id="其他语言实现以及参考资料"><a href="#其他语言实现以及参考资料" class="headerlink" title="其他语言实现以及参考资料"></a>其他语言实现以及参考资料</h3><ul><li>Java 语言实现：<ul><li><a href="https://github.com/bcgit/bc-csharp">https://github.com/bcgit/bc-csharp</a></li><li><a href="https://github.com/xjfuuu/SM2_SM3_SM4Encrypt">https://github.com/xjfuuu/SM2_SM3_SM4Encrypt</a></li></ul></li><li>Go 语言实现：<a href="https://github.com/tjfoc/gmsm">https://github.com/tjfoc/gmsm</a></li><li>开源国密算法工具箱：<a href="http://gmssl.org/">http://gmssl.org/</a></li><li>国密算法源代码下载：<a href="http://www.scctc.org.cn/templates/Download/index.aspx?nodeid=71">http://www.scctc.org.cn/templates/Download/index.aspx?nodeid=71</a></li><li>国家密码管理局：<a href="https://www.sca.gov.cn/">https://www.sca.gov.cn/</a></li><li>密码标准委员会：<a href="http://www.gmbz.org.cn/">http://www.gmbz.org.cn/</a></li></ul><hr><h2 id="附：GM-T-密码行业标准"><a href="#附：GM-T-密码行业标准" class="headerlink" title="附：GM/T 密码行业标准"></a><font color=#B01B15>附：GM/T 密码行业标准</font></h2><ul><li><a href="http://www.gmbz.org.cn/main/viewfile/20180117202410524608.html">GM/T 0001.1-2012：祖冲之序列密码算法：第1部分：算法描述</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180107233806310781.html">GM/T 0001.2-2012：祖冲之序列密码算法：第2部分：基于祖冲之算法的机密性算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180107234058336917.html">GM/T 0001.3-2012：祖冲之序列密码算法：第3部分：基于祖冲之算法的完整性算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180108015515787986.html">GM/T 0003.1-2012：SM2 椭圆曲线公钥密码算法第1部分：总则</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180108023346264349.html">GM/T 0003.2-2012：SM2 椭圆曲线公钥密码算法第2部分：数字签名算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180108023456003485.html">GM/T 0003.3-2012：SM2 椭圆曲线公钥密码算法第3部分：密钥交换协议</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180108023602687857.html">GM/T 0003.4-2012：SM2 椭圆曲线公钥密码算法第4部分：公钥加密算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/2018010802371372251.html">GM/T 0003.5-2012：SM2 椭圆曲线公钥密码算法第5部分：参数定义</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180108023812835219.html">GM/T 0004-2012：SM3 密码杂凑算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180108015408199368.html">GM/T 0002-2012：SM4 分组密码算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/2018011002473633053.html">GM/T 0044.1-2016：SM9 标识密码算法 第1部分：总则</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180110024900801385.html">GM/T 0044.2-2016：SM9 标识密码算法 第2部分：数字签名算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180110025010004565.html">GM/T 0044.3-2016：SM9 标识密码算法 第3部分：密钥交换协议</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180110025115084846.html">GM/T 0044.4-2016：SM9 标识密码算法 第4部分：密钥封装机制和公钥加密算法</a></li><li><a href="http://www.gmbz.org.cn/main/viewfile/20180110025229918536.html">GM/T 0044.5-2016：SM9 标识密码算法 第5部分：参数定义</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS 逆向 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫逆向基础，理解 JavaScript 模块化编程 webpack</title>
      <link href="/article/040/"/>
      <url>/article/040/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><font color=#FFB11B>简介</font></h2><p>在分析一些站点的 JavaScript 代码时，比较简单的代码，函数通常都是一个一个的，例如：</p><pre><code class="javascript">function a() &#123;console.log(&quot;a&quot;)&#125;function b() &#123;console.log(&quot;a&quot;)&#125;function c() &#123;console.log(&quot;a&quot;)&#125;</code></pre><p>但是稍微复杂一点的站点，通常会遇到类似如下的代码结构：</p><pre><code class="javascript">!function(i) &#123;    function n(t) &#123;        return i[t].call(a, b, c, d)    &#125;&#125;([    function(t, e) &#123;&#125;,     function(t, e, n) &#123;&#125;,     function(t, e, r) &#123;&#125;,     function(t, e, o) &#123;&#125;]);</code></pre><p>这种写法在 JavaScript 中很常见，对于熟悉 JavaScript 的人来说可能非常简单，但是爬虫工程师大多数都是用 Python 或者 Java 来写代码的，看到这种语法就有可能懵了，由于在剥离 JS 加密代码时会经常遇到，所以理解这种语法对于爬虫工程师来说是非常重要的。</p><p>这种写法貌似没有官方的名称，相当于进行了模块化编程，因此大多数人称其为 webpack，上面的示例看起来比较费劲，简单优化一下：</p><pre><code class="javascript">!function (allModule) &#123;    function useModule(whichModule) &#123;        allModule[whichModule].call(null, &quot;hello world!&quot;);    &#125;    useModule(0)&#125;([    function module0(param) &#123;console.log(&quot;module0: &quot; + param)&#125;,    function module1(param) &#123;console.log(&quot;module1: &quot; + param)&#125;,    function module2(param) &#123;console.log(&quot;module2: &quot; + param)&#125;,]);</code></pre><p>运行以上代码，会输出 <code>module0: hello world!</code>，相信通过浅显易懂的变量名和函数名，应该就可以看懂大致含义了，调用 <code>useModule(0)</code>，从所有函数里选择第一个，将 <code>hello world!</code> 传递给 <code>module0</code> 并输出。</p><p>仔细观察以上代码，我们会发现主要用到了 <code>!function()&#123;&#125;()</code> 和 <code>function.call()</code> 语法，接下来就一一介绍一下。</p><hr><h2 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a><font color=#FFB11B>函数声明与函数表达式</font></h2><p>在 ECMAScript（JavaScript 的一个标准）中，有两个最常用的创建函数对象的方法，即使用函数声明或者函数表达式，ECMAScript 规范明确了一点，即函数声明必须始终带有一个标识符，也就是我们所说的函数名，而函数表达式则可以省略。</p><p>函数声明，会给函数指定一个名字，会在代码执行以前被加载到作用域中，所以<strong>调用函数在函数声明之前或之后都是可以的</strong>：</p><pre><code class="javascript">test(&quot;Hello World!&quot;)function test(arg) &#123;    console.log(arg)&#125;</code></pre><p>函数表达式，创建一个匿名函数，然后将这个匿名函数赋给一个变量，在代码执行到函数表达式的时候才会有定义，所以<strong>调用函数在函数表达式之后才能正确运行</strong>，否则是会报错的：</p><pre><code class="javascript">var test = function (arg) &#123;    console.log(arg)&#125;test(&quot;Hello World!&quot;)</code></pre><hr><h2 id="IIFE-立即调用函数表达式"><a href="#IIFE-立即调用函数表达式" class="headerlink" title="IIFE 立即调用函数表达式"></a><font color=#FFB11B>IIFE 立即调用函数表达式</font></h2><p>IIFE 全称 Immediately-invoked Function Expressions，译为立即调用函数表达式，也称为自执行函数、立即执行函数、自执行匿名函数等，IIFE 是一种语法，这种模式本质上就是函数表达式（命名的或者匿名的）在创建后立即执行。当函数变成立即执行的函数表达式时，表达式中的变量不能从外部访问。IIFE 主要用来隔离作用域，避免污染。</p><hr><h3 id="IIFE-基本语法"><a href="#IIFE-基本语法" class="headerlink" title="IIFE 基本语法"></a>IIFE 基本语法</h3><p>IIFE 的写法非常灵活，主要有以下几种格式：</p><p>1、匿名函数前面加上一元操作符，后面加上 <code>()</code>：</p><pre><code class="javascript">!function () &#123;    console.log(&quot;I AM IIFE&quot;)&#125;();-function () &#123;    console.log(&quot;I AM IIFE&quot;)&#125;();+function () &#123;    console.log(&quot;I AM IIFE&quot;)&#125;();~function () &#123;    console.log(&quot;I AM IIFE&quot;)&#125;();</code></pre><p>2、匿名函数后面加上 <code>()</code>，然后再用 <code>()</code> 将整个括起来：</p><pre><code class="javascript">(function () &#123;    console.log(&quot;I AM IIFE&quot;)&#125;());</code></pre><p>3、先用 <code>()</code> 将匿名函数括起来，再在后面加上 <code>()</code>：</p><pre><code class="javascript">(function () &#123;    console.log(&quot;I AM IIFE&quot;)&#125;)();</code></pre><p>4、使用箭头函数表达式，先用 <code>()</code> 将箭头函数表达式括起来，再在后面加上 <code>()</code>：</p><pre><code class="javascript">(() =&gt; &#123;  console.log(&quot;I AM IIFE&quot;)&#125;)()</code></pre><p>5、匿名函数前面加上 <code>void</code> 关键字，后面加上 <code>()</code>， <code>void</code> 指定要计算或运行一个表达式，但是不返回值：</p><pre><code class="javascript">void function () &#123;    console.log(&quot;I AM IIFE&quot;)&#125;();</code></pre><p>有的时候，我们还有可能见到立即执行函数前面后分号的情况，例如：</p><pre><code class="javascript">;(function () &#123;    console.log(&quot;I AM IIFE&quot;)&#125;());!function () &#123;    console.log(&quot;I AM IIFE&quot;)&#125;()</code></pre><p>这是因为立即执行函数通常作为一个单独模块使用一般是没有问题的，但是还是建议在立即执行函数前面或者后面加上分号，这样可以有效地与前面或者后面的代码进行隔离，否则可能出现意想不到的错误。</p><hr><h3 id="IIFE-参数传递"><a href="#IIFE-参数传递" class="headerlink" title="IIFE 参数传递"></a>IIFE 参数传递</h3><p>将参数放在末尾的 <code>()</code> 里即可实现参数传递：</p><pre><code class="javascript">var text = &quot;I AM IIFE&quot;;(function (param) &#123;    console.log(param)&#125;)(text);// I AM IIFE</code></pre><pre><code class="javascript">var dict = &#123;name: &quot;Bob&quot;, age: &quot;20&quot;&#125;;(function () &#123;    console.log(dict.name);&#125;)(dict);// Bob</code></pre><pre><code class="javascript">var list = [1, 2, 3, 4, 5];(function () &#123;    var sum = 0;    for (var i = 0; i &lt; list.length; i++) &#123;        sum += list[i];    &#125;    console.log(sum);&#125;)(list);// 15</code></pre><hr><h2 id="Function-prototype-call-apply-bind"><a href="#Function-prototype-call-apply-bind" class="headerlink" title="Function.prototype.call() / apply() / bind()"></a><font color=#FFB11B>Function.prototype.call() / apply() / bind()</font></h2><p><code>Function.prototype.call()</code>、<code>Function.prototype.apply()</code>、<code>Function.prototype.bind()</code> 都是比较常用的方法。它们的作用一模一样，即<strong>改变函数中的 <code>this</code> 指向</strong>，它们的区别如下：</p><ul><li><code>call()</code> 方法会立即执行这个函数，接受一个多个参数，参数之间用逗号隔开；</li><li><code>apply()</code> 方法会立即执行这个函数，接受一个包含多个参数的数组；</li><li><code>bind()</code> 方法不会立即执行这个函数，返回的是一个修改过后的函数，便于稍后调用，接受的参数和 <code>call()</code> 一样。</li></ul><hr><h3 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h3><p><code>call()</code> 方法接受多个参数，第一个参数 thisArg 指定了函数体内 this 对象的指向，如果这个函数处于非严格模式下，指定为 null 或 undefined 时会自动替换为指向全局对象（浏览器中就是 window 对象），在严格模式下，函数体内的 this 还是为 null。从第二个参数开始往后，每个参数被依次传入函数，基本语法如下：</p><pre><code class="javascript">function.call(thisArg, arg1, arg2, ...)</code></pre><p>示例：</p><pre><code class="javascript">function test(a, b, c) &#123;    console.log(a + b + c)&#125;test.call(null, 1, 2, 3)  // 6</code></pre><pre><code class="javascript">function test() &#123;    console.log(this.firstName + &quot; &quot; + this.lastName)&#125;var data = &#123;firstName: &quot;John&quot;, lastName: &quot;Doe&quot;&#125;test.call(data)  // John Doe</code></pre><hr><h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p><code>apply()</code> 方法接受两个参数，第一个参数 thisArg 与 <code>call()</code> 方法一致，第二个参数为一个带下标的集合，从 ECMAScript 第5版开始，这个集合可以为数组，也可以为类数组，<code>apply()</code> 方法把这个集合中的元素作为参数传递给被调用的函数，基本语法如下：</p><pre><code class="javascript">function.apply(thisArg, [arg1, arg2, ...])</code></pre><p>示例：</p><pre><code class="javascript">function test(a, b, c) &#123;    console.log(a + b + c)&#125;test.apply(null, [1, 2, 3])  // 6</code></pre><pre><code class="javascript">function test() &#123;    console.log(this.firstName + &quot; &quot; + this.lastName)&#125;var data = &#123;firstName: &quot;John&quot;, lastName: &quot;Doe&quot;&#125;test.apply(data)  // John Doe</code></pre><hr><h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p><code>bind()</code> 方法和 <code>call()</code> 接受的参数是相同的，只不过 <code>bind()</code> 返回的是一个函数，基本语法如下：</p><pre><code class="javascript">function.bind(thisArg, arg1, arg2, ...)</code></pre><p>示例：</p><pre><code class="javascript">function test(a, b, c) &#123;    console.log(a + b + c)&#125;test.bind(null, 1, 2, 3)()  // 6</code></pre><pre><code class="javascript">function test() &#123;    console.log(this.firstName + &quot; &quot; + this.lastName)&#125;var data = &#123;firstName: &quot;John&quot;, lastName: &quot;Doe&quot;&#125;test.bind(data)()  // John Doe</code></pre><hr><h2 id="理解-webpack"><a href="#理解-webpack" class="headerlink" title="理解 webpack"></a><font color=#FFB11B>理解 webpack</font></h2><p>有了以上知识后，我们再来理解一下模块化编程，也就是前面所说的 webpack 写法：</p><pre><code class="javascript">!function (allModule) &#123;    function useModule(whichModule) &#123;        allModule[whichModule].call(null, &quot;hello world!&quot;);    &#125;    useModule(0)&#125;([    function module0(param) &#123;console.log(&quot;module0: &quot; + param)&#125;,    function module1(param) &#123;console.log(&quot;module1: &quot; + param)&#125;,    function module2(param) &#123;console.log(&quot;module2: &quot; + param)&#125;,]);</code></pre><p>首先，这整个代码是一个 IIFE 立即调用函数表达式，传递的参数是一个数组，里面包含三个方法，分别是 <code>module0</code>、<code>module1</code> 和 <code>module2</code>，可以将其视为三个模块，那么 IIFE 接受的参数 <code>allModule</code> 就包含这三个模块，IIFE 里面还包含一个函数 <code>useModule()</code>，可以将其视为模块加载器，即要使用哪个模块，示例中 <code>useModule(0)</code> 即表示调用第一个模块，函数里面使用 <code>call()</code> 方法改变函数中的 <code>this</code> 指向并传递参数，调用相应的模块进行输出。</p><hr><h2 id="改写-webpack"><a href="#改写-webpack" class="headerlink" title="改写 webpack"></a><font color=#FFB11B>改写 webpack</font></h2><p>对于我们爬虫逆向当中经常遇到的 webpack 模块化的写法，可以很容易对其进行改写，以下以一段加密代码为例：</p><pre><code class="javascript">CryptoJS = require(&quot;crypto-js&quot;)!function (func) &#123;    function acvs() &#123;        var kk = func[1].call(null, 1e3);        var data = &#123;            r: &quot;I LOVE PYTHON&quot;,            e: kk,            i: &quot;62bs819idl00oac2&quot;,            k: &quot;0123456789abcdef&quot;        &#125;        return func[0].call(data);    &#125;    console.log(&quot;加密文本：&quot; + acvs())    function odsc(account) &#123;        var cr = false;        var regExp = /(^\d&#123;7,8&#125;$)|(^0\d&#123;10,12&#125;$)/;        if (regExp.test(account)) &#123;            cr = true;        &#125;        return cr;    &#125;    function mkle(account) &#123;        var cr = false;        var regExp = /^([a-zA-Z0-9_\.\-\+])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]&#123;2,4&#125;)+$/;        if (regExp.test(account)) &#123;            cr = true;        &#125;        return cr;    &#125;&#125;([    function () &#123;        for (var n = &quot;&quot;, t = 0; t &lt; this.r.length; t++) &#123;            var o = this.e ^ this.r.charCodeAt(t);            n += String.fromCharCode(o)        &#125;        return encodeURIComponent(n)    &#125;,    function (x) &#123;        return Math.ceil(x * Math.random())    &#125;,    function (e) &#123;        var a = CryptoJS.MD5(this.k);        var c = CryptoJS.enc.Utf8.parse(a);        var d = CryptoJS.AES.encrypt(e, c, &#123;            iv: this.i        &#125;);        return d + &quot;&quot;    &#125;,    function (e) &#123;        var b = CryptoJS.MD5(this.k);        var d = CryptoJS.enc.Utf8.parse(b);        var a = CryptoJS.AES.decrypt(e, d, &#123;            iv: this.i        &#125;).toString(CryptoJS.enc.Utf8);        return a    &#125;]);</code></pre><p>可以看到关键的加密入口函数是 <code>acvs()</code>，<code>acvs()</code> 里面又调用了 IIFE 参数列表里面的第一个和第二个函数，剩下的其他函数都是干扰项，而第一个函数中用到了 r 和 e 参数，将其直接传入即可，最终改写如下：</p><pre><code class="javascript">function a(r, e) &#123;    for (var n = &quot;&quot;, t = 0; t &lt; r.length; t++) &#123;        var o = e ^ r.charCodeAt(t);        n += String.fromCharCode(o)    &#125;    return encodeURIComponent(n)&#125;function b(x) &#123;    return Math.ceil(x * Math.random())&#125;function acvs() &#123;    var kk = b(1e3);    var r = &quot;I LOVE PYTHON&quot;;    return a(r, kk);&#125;console.log(&quot;加密文本：&quot; + acvs())</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS 逆向 </tag>
            
            <tag> webpack </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫常见加密解密算法总结</title>
      <link href="/article/039/"/>
      <url>/article/039/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文总结了在爬虫中常见的各种加密算法、编码算法的原理、在 JavaScript 中和 Python 中的基本实现方法，遇到 JS 加密的时候可以快速还原加密过程，有的网站在加密的过程中可能还经过了其他处理，但是大致的方法是一样的。</p><p>常见加密算法：</p><ol><li>对称加密（加密解密密钥相同）：DES、3DES、AES、RC4、Rabbit</li><li>非对称加密（区分公钥和私钥）：RSA、DSA、ECC</li><li>消息摘要算法/签名算法：MD5、SHA、HMAC、PBKDF2</li></ol><p>常见编码算法：Base64</p><h3 id="JavaScript-加密解密模块"><a href="#JavaScript-加密解密模块" class="headerlink" title="JavaScript 加密解密模块"></a>JavaScript 加密解密模块</h3><h4 id="Crypto-JS"><a href="#Crypto-JS" class="headerlink" title="Crypto-JS"></a>Crypto-JS</h4><p>Crypto-JS 支持 MD5、SHA、RIPEMD-160、HMAC、PBKDF2、AES、DES、3DES（Triple DES）、Rabbit、RC4 等，<strong>不支持 RSA、ECC</strong>，是应用比较广的加密模块，使用命令 <code>npm install crypto-js</code> 安装。</p><p>参考资料：</p><ul><li><p>Crypto-JS 文档：<a href="https://cryptojs.gitbook.io/docs/">https://cryptojs.gitbook.io/docs/</a></p></li><li><p>Crypto-JS Github：<a href="https://github.com/brix/crypto-js">https://github.com/brix/crypto-js</a></p></li></ul><h4 id="Node-RSA"><a href="#Node-RSA" class="headerlink" title="Node-RSA"></a>Node-RSA</h4><p>Node-RSA 对  RSA 算法提供了支持，使用命令 <code>npm install node-rsa </code> 安装。</p><p>参考资料：Node-RSA Github：<a href="https://github.com/rzcoder/node-rsa">https://github.com/rzcoder/node-rsa</a></p><h4 id="JSEncrypt"><a href="#JSEncrypt" class="headerlink" title="JSEncrypt"></a>JSEncrypt</h4><p>参考资料：JSEncrypt 对  RSA 算法提供了更加全面的支持，使用命令 <code>npm install jsencrypt </code> 安装。</p><ul><li>JSEncrypt 文档：<a href="http://travistidwell.com/jsencrypt/">http://travistidwell.com/jsencrypt/</a></li><li>JSEncrypt Github：<a href="https://github.com/travist/jsencrypt">https://github.com/travist/jsencrypt</a></li></ul><h3 id="Python-加密解密库"><a href="#Python-加密解密库" class="headerlink" title="Python 加密解密库"></a>Python 加密解密库</h3><h4 id="Cryptodome-amp-Crypto"><a href="#Cryptodome-amp-Crypto" class="headerlink" title="Cryptodome &amp; Crypto"></a>Cryptodome &amp; Crypto</h4><p>在 Python 中有很多算法是通过第三方库 Cryptodome 或者 Crypto 来实现的，Cryptodome 几乎是 Crypto 的替代品，Crypto 已经停止更新好多年了，有很多未知错误，所以<strong>不建议安装 Crypto ！</strong></p><p>Cryptodome 支持几乎所有主流加密算法，包括 MD5、SHA、BLAKE2b、BLAKE2s、HMAC、PBKDF2、AES、DES、3DES（Triple DES）、ECC、RSA、RC4 等。</p><p>Cryptodome 使用命令 <code>pip install pycryptodome</code> 进行安装，Crypto 使用命令 <code>pip install pycrypto </code> 进行安装。</p><p>参考资料：</p><ul><li><p>Crypto 库：<a href="https://www.dlitz.net/software/pycrypto/">https://www.dlitz.net/software/pycrypto/</a></p></li><li><p>Cryptodome 库：<a href="https://www.pycryptodome.org/en/latest/">https://www.pycryptodome.org/en/latest/</a></p></li></ul><h4 id="Hashlib"><a href="#Hashlib" class="headerlink" title="Hashlib"></a>Hashlib</h4><p>Python 的标准库 hashlib 提供了常见的摘要算法，如 MD5，SHA、BLAKE2b、BLAKE2s 等。</p><p>参考资料：</p><ul><li>hashlib 库：<a href="https://docs.python.org/3/library/hashlib.html">https://docs.python.org/3/library/hashlib.html</a></li><li>廖雪峰 hashlib：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017686752491744">https://www.liaoxuefeng.com/wiki/1016959663602400/1017686752491744</a></li></ul><h4 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h4><p>Python 的标准库 hmac 对 HMAC 算法提供了支持。</p><p>参考资料：</p><ul><li>hmac 库：<a href="https://docs.python.org/3/library/hmac.html">https://docs.python.org/3/library/hmac.html</a></li><li>廖雪峰 hmac：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1183198304823296">https://www.liaoxuefeng.com/wiki/1016959663602400/1183198304823296</a></li></ul><h4 id="pyDes"><a href="#pyDes" class="headerlink" title="pyDes"></a>pyDes</h4><p>Python 的第三方库 pyDes 对 DES 算法提供了支持。使用命令 <code>pip install pydes</code> 进行安装。</p><p>参考资料：pyDes 库：<a href="https://github.com/twhiteman/pyDes">https://github.com/twhiteman/pyDes</a></p><h4 id="ESA"><a href="#ESA" class="headerlink" title="ESA"></a>ESA</h4><p>Python 的第三方库 rsa 对 RSA 算法提供了支持。使用命令 <code>pip install rsa</code> 进行安装。</p><p>参考资料：rsa 库：<a href="https://stuvel.eu/python-rsa-doc/">https://stuvel.eu/python-rsa-doc/</a></p><h2 id="加密解密基本参数"><a href="#加密解密基本参数" class="headerlink" title="加密解密基本参数"></a>加密解密基本参数</h2><p>在一些对称和非对称加密算法中，经常会用到以下三个参数：初始向量 iv、加密模式 mode、填充方式 padding，先介绍一下这三个参数的含义和作用：</p><h3 id="初始向量-iv"><a href="#初始向量-iv" class="headerlink" title="初始向量 iv"></a>初始向量 iv</h3><p>在密码学中，初始向量（initialization vector，缩写为 iv），又称初始变数（starting variable，缩写为 sv），与密钥结合使用，作为加密数据的手段，它是一个固定长度的值，iv 的长度取决于加密方法，通常与使用的加密密钥或密码块的长度相当，一般在使用过程中会要求它是随机数或拟随机数，使用随机数产生的初始向量才能达到语义安全，让攻击者难以对原文一致且使用同一把密钥生成的密文进行破解。</p><p>参考资料：维基百科：<a href="https://en.wikipedia.org/wiki/Initialization_vector">https://en.wikipedia.org/wiki/Initialization_vector</a></p><h3 id="加密模式-mode"><a href="#加密模式-mode" class="headerlink" title="加密模式 mode"></a>加密模式 mode</h3><p>目前流行的加密和数字认证算法，都是采用块加密方式，就是将需要加密的明文分成固定大小的数据块，然后对其执行密码算法，得到密文。数据块的大小通常采用跟密钥一样的长度。加密模式在加密算法的基础上发展出来，同时也可以独立于加密算法而存在，加密模式定义了怎样通过重复利用加密算法将大于一个数据块大小的明文转化为密文，描述了加密每一数据块的过程。目前利用较多的加密模式有以下几种：</p><ul><li><p><strong>ECB：Electronic Code Book（电子码本模式）</strong>，是一种基础的加密方式，密文被分割成分组长度相等的块（不足补齐），然后单独一个个加密，一个个输出组成密文。</p></li><li><p><strong>CBC：Cipher Block Chaining（密码块链接模式）</strong>，是一种循环模式，前一个分组的密文和当前分组的明文异或操作后再加密，这样做的目的是增强破解难度。</p></li><li><p><strong>PCBC：Propagating Cipher Block Chaining（填充密码块链接模式）</strong>，也称为明文密码块链接模式（Plaintext Cipher Block Chaining），是一种可以使密文中的微小更改在解密时导致明文大部分错误的模式，并在加密的时候也具有同样的特性。</p></li><li><p><strong>CFB：Cipher Feedback（密码反馈模式）</strong>，可以将块密码变为自同步的流密码，类似于 CBC，CFB 的解密过程几乎就是颠倒的 CBC 的加密过程。</p></li><li><p><strong>OFB：Output Feedback（输出反馈模式）</strong>，可以将块密码变成同步的流密码，它产生密钥流的块，然后将其与明文块进行异或，得到密文。与其它流密码一样，密文中一个位的翻转会使明文中同样位置的位也产生翻转。</p></li><li><p><strong>CTR：Counter mode（计数器模式）</strong>，也被称为 ICM 模式（Integer Counter Mode，整数计数模式）和 SIC 模式（Segmented Integer Counter），在 CTR 模式中，有一个自增的算子，这个算子用密钥加密之后的输出和明文异或的结果得到密文，相当于一次一密。这种加密方式简单快速，安全可靠，而且可以并行加密，但是在计算器不能维持很长的情况下，密钥只能使用一次。</p></li></ul><p>参考资料：维基百科：<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation</a></p><h3 id="填充方式-padding"><a href="#填充方式-padding" class="headerlink" title="填充方式 padding"></a>填充方式 padding</h3><p>块密码只能对确定长度的数据块进行处理，而消息的长度通常是可变的。因此部分模式最后一块数据在加密前需要进行填充。有数种填充方法，其中最简单的一种是在明文的最后填充空字符以使其长度为块长度的整数倍。常见填充方式有以下几种：</p><ul><li><p><strong>PKCS7</strong>：在填充时首先获取需要填充的字节长度 = 块长度 - （数据长度 % 块长度）, 在填充字节序列中所有字节填充为需要填充的字节长度值。</p></li><li><p><strong>PKCS5</strong>：PKCS5 作为 PKCS7 的子集算法，概念上没有什么区别，只是在 blockSize 上固定为 8 bytes，即块大小固定为 8 字节。</p></li><li><p><strong>ZeroPadding</strong>：在填充时首先获取需要填充的字节长度 = 块长度 - （数据长度 % 块长度）, 在填充字节序列中所有字节填充为 0 。</p></li><li><p><strong>ISO10126</strong>：在填充时首先获取需要填充的字节长度 = 块长度 - （数据长度 % 块长度），在填充字节序列中最后一个字节填充为需要填充的字节长度值，填充字节中其余字节均填充随机数值。</p></li><li><p><strong>ANSIX923</strong>：在填充时首先获取需要填充的字节长度 = 块长度 - （数据长度 % 块长度），在填充字节序列中最后一个字节填充为需要填充的字节长度值，填充字节中其余字节均填充数字零。</p></li></ul><p>参考资料：</p><ul><li>维基百科：<a href="https://en.wikipedia.org/wiki/Padding_(cryptography)">https://en.wikipedia.org/wiki/Padding_(cryptography)</a></li><li>PKCS7/PKCS5 填充算法：<a href="https://segmentfault.com/a/1190000019793040">https://segmentfault.com/a/1190000019793040</a></li></ul><h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>简介：Base64 是一种用 64 个字符来表示任意二进制数据的方法。</p><p>参考资料：</p><ul><li>Base64 百度百科：<a href="https://baike.baidu.com/item/base64/8545775">https://baike.baidu.com/item/base64/8545775</a></li><li>Base64 维基百科：<a href="https://en.wikipedia.org/wiki/Base64">https://en.wikipedia.org/wiki/Base64</a></li></ul><h3 id="JavaScript-实现"><a href="#JavaScript-实现" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function base64Encode() &#123;    var srcs = CryptoJS.enc.Utf8.parse(text);    var encodeData = CryptoJS.enc.Base64.stringify(srcs);    return encodeData&#125;function base64Decode() &#123;    var srcs = CryptoJS.enc.Base64.parse(encodeData);    var decodeData = srcs.toString(CryptoJS.enc.Utf8);    return decodeData&#125;var text = &quot;I love Python!&quot;var encodeData = base64Encode()var decodeData = base64Decode()console.log(&quot;Base64 编码: &quot;, encodeData)console.log(&quot;Base64 解码: &quot;, decodeData)// Base64 编码:  SSBsb3ZlIFB5dGhvbiE=// Base64 解码:  I love Python!</code></pre><h3 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h3><pre><code class="python">import base64def base64_encode(text):    encode_data = base64.b64encode(text.encode())    return encode_datadef base64_decode(encode_data):    decode_data = base64.b64decode(encode_data)    return decode_dataif __name__ == &#39;__main__&#39;:    text = &#39;I love Python!&#39;    encode_data = base64_encode(text)    decode_data = base64_decode(encode_data)    print(&#39;Base64 编码：&#39;, encode_data)    print(&#39;Base64 解码：&#39;, decode_data)# Base64 编码： b&#39;SSBsb3ZlIFB5dGhvbiE=&#39;# Base64 解码： b&#39;I love Python!&#39;</code></pre><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>简介：全称 MD5 消息摘要算法（英文名称：MD5 Message-Digest Algorithm），又称哈希算法、散列算法，由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于 1992 年作为 RFC 1321 被公布，用以取代 MD4 算法。摘要算法是单向加密的，也就是说明文通过摘要算法加密之后，是不能解密的。摘要算法的第二个特点密文是固定长度的，它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。之所以叫摘要算法，它的算法就是提取明文重要的特征。所以，两个不同的明文，使用了摘要算法之后，有可能他们的密文是一样的，不过这个概率非常的低。</p><p>参考资料：</p><ul><li>RFC 1321：<a href="https://datatracker.ietf.org/doc/rfc1321/">https://datatracker.ietf.org/doc/rfc1321/</a></li><li>MD5 维基百科：<a href="https://en.wikipedia.org/wiki/MD5">https://en.wikipedia.org/wiki/MD5</a></li></ul><h3 id="JavaScript-实现-1"><a href="#JavaScript-实现-1" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function MD5Test() &#123;    var text = &quot;I love python!&quot;    return CryptoJS.MD5(text).toString()&#125;console.log(MD5Test())  // 21169ee3acd4a24e1fcb4322cfd9a2b8</code></pre><h3 id="Python-实现-1"><a href="#Python-实现-1" class="headerlink" title="Python 实现"></a>Python 实现</h3><pre><code class="python">import hashlibdef md5_test1():    md5 = hashlib.new(&#39;md5&#39;, &#39;I love python!&#39;.encode(&#39;utf-8&#39;))    print(md5.hexdigest())def md5_test2():    md5 = hashlib.md5()    md5.update(&#39;I love &#39;.encode(&#39;utf-8&#39;))    md5.update(&#39;python!&#39;.encode(&#39;utf-8&#39;))    print(md5.hexdigest())if __name__ == &#39;__main__&#39;:    md5_test1()  # 21169ee3acd4a24e1fcb4322cfd9a2b8    md5_test2()  # 21169ee3acd4a24e1fcb4322cfd9a2b8</code></pre><h2 id="PBKDF2"><a href="#PBKDF2" class="headerlink" title="PBKDF2"></a>PBKDF2</h2><p>简介：英文名称：Password-Based Key Derivation Function 2，PBKDF2 是 RSA 实验室的公钥加密标准（PKCS）系列的一部分，2017 年发布的 RFC 8018 （PKCS #5 v2.1）推荐使用 PBKDF2 进行密码散列。PBKDF2 将伪随机函数（例如 HMAC），把明文和一个盐值（salt）作为输入参数，然后进行重复运算，并最终产生密钥，如果重复的次数足够大，破解的成本就会变得很高。</p><p>参考资料：</p><ul><li>RFC 8018：<a href="https://datatracker.ietf.org/doc/rfc8018/">https://datatracker.ietf.org/doc/rfc8018/</a></li><li>PBKDF2 维基百科：<a href="https://en.wikipedia.org/wiki/PBKDF2">https://en.wikipedia.org/wiki/PBKDF2</a></li></ul><h3 id="JavaScript-实现-2"><a href="#JavaScript-实现-2" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function pbkdf2Encrypt() &#123;    var text = &quot;I love Python!&quot;    var salt = &quot;43215678&quot;    // key 长度 128，10 次重复运算    var encryptedData = CryptoJS.PBKDF2(text, salt, &#123;keySize: 128/32,iterations: 10&#125;);    return encryptedData.toString()&#125;console.log(pbkdf2Encrypt())  // 7fee6e8350cfe96314c76aaa6e853a50</code></pre><h3 id="Python-实现-2"><a href="#Python-实现-2" class="headerlink" title="Python 实现"></a>Python 实现</h3><pre><code class="python">import binasciifrom Cryptodome.Hash import SHA1from Cryptodome.Protocol.KDF import PBKDF2text = &#39;I love Python!&#39;salt = b&#39;43215678&#39;result = PBKDF2(text,  salt, count=10, hmac_hash_module=SHA1)result = binascii.hexlify(result)print(result)# b&#39;7fee6e8350cfe96314c76aaa6e853a50&#39;</code></pre><h2 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h2><p>简介：全称安全哈希算法（英文名称：Secure Hash Algorithm），由美国国家安全局（NSA）所设计，主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA），SHA 通常指 SHA 家族的五个算法，分别是 SHA-1、SHA-224、SHA-256、SHA-384、SHA-512，后四者有时并称为 SHA-2，SHA 是比 MD5 更安全一点的摘要算法，MD5 的密文是 32 位，而 SHA-1 是 40 位，版本越强，密文越长，代价是速度越慢。</p><p>参考资料：</p><ul><li>RFC 3174：<a href="https://datatracker.ietf.org/doc/rfc3174/">https://datatracker.ietf.org/doc/rfc3174/</a></li><li>SHA 维基百科：<a href="https://en.wikipedia.org/wiki/Secure_Hash_Algorithms">https://en.wikipedia.org/wiki/Secure_Hash_Algorithms</a></li></ul><h3 id="JavaScript-实现-3"><a href="#JavaScript-实现-3" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function SHA1Encrypt() &#123;    var text = &quot;I love python!&quot;    return CryptoJS.SHA1(text).toString();&#125;console.log(SHA1Encrypt())  // 23c02b203bd2e2ca19da911f1d270a06d86719fb</code></pre><h3 id="Python-实现-3"><a href="#Python-实现-3" class="headerlink" title="Python 实现"></a>Python 实现</h3><pre><code class="python">import hashlibdef sha1_test1():    sha1 = hashlib.new(&#39;sha1&#39;, &#39;I love python!&#39;.encode(&#39;utf-8&#39;))    print(sha1.hexdigest())def sha1_test2():    sha1 = hashlib.sha1()    sha1.update(&#39;I love python!&#39;.encode(&#39;utf-8&#39;))    print(sha1.hexdigest())if __name__ == &#39;__main__&#39;:    sha1_test1()  # 23c02b203bd2e2ca19da911f1d270a06d86719fb    sha1_test2()  # 23c02b203bd2e2ca19da911f1d270a06d86719fb</code></pre><h2 id="HMAC-1"><a href="#HMAC-1" class="headerlink" title="HMAC"></a>HMAC</h2><p>简介：全称散列消息认证码、密钥相关的哈希运算消息认证码（英文名称：Hash-based Message Authentication Code 或者 Keyed-hash Message Authentication Code），于 1996 年提出，1997 年作为 RFC 2104 被公布，HMAC 加密算法是一种安全的基于加密 Hash 函数和共享密钥的消息认证协议，它要求通信双方共享密钥 key、约定算法、对报文进行 Hash 运算，形成固定长度的认证码。通信双方通过认证码的校验来确定报文的合法性。</p><p>参考资料：</p><ul><li>RFC 2104：<a href="https://datatracker.ietf.org/doc/rfc2104/">https://datatracker.ietf.org/doc/rfc2104/</a></li><li>HMAC 维基百科：<a href="https://en.wikipedia.org/wiki/HMAC">https://en.wikipedia.org/wiki/HMAC</a></li></ul><h3 id="JavaScript-实现-4"><a href="#JavaScript-实现-4" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function HMACEncrypt() &#123;    var text = &quot;I love python!&quot;    var key = &quot;secret&quot;    return CryptoJS.HmacMD5(text, key).toString();    // return CryptoJS.HmacSHA1(text, key).toString();    // return CryptoJS.HmacSHA256(text, key).toString();&#125;console.log(HMACEncrypt())</code></pre><h3 id="Python-实现-4"><a href="#Python-实现-4" class="headerlink" title="Python 实现"></a>Python 实现</h3><pre><code class="python">import hmacdef hmac_test1():    message = b&#39;I love python!&#39;    key = b&#39;secret&#39;    md5 = hmac.new(key, message, digestmod=&#39;MD5&#39;)    print(md5.hexdigest())def hmac_test2():    key = &#39;secret&#39;.encode(&#39;utf8&#39;)    sha1 = hmac.new(key, digestmod=&#39;sha1&#39;)    sha1.update(&#39;I love &#39;.encode(&#39;utf8&#39;))    sha1.update(&#39;Python!&#39;.encode(&#39;utf8&#39;))    print(sha1.hexdigest())if __name__ == &#39;__main__&#39;:    hmac_test1()  # 9c503a1f852edcc3526ea56976c38edf    hmac_test2()  # 2d8449a4292d4bbeed99ce9ea570880d6e19b61a</code></pre><h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><p>简介：全称数据加密标准（英文名称：Data Encryption Standard），加密与解密使用同一密钥，属于对称加密算法，1977 年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），DES 是一个分组加密算法，使用 56 位的密钥（一般认为密钥是 64 位，但是密钥的每个第 8 位设置为奇偶校验位，所以实际上有效位只有 56 位），由于 56 位密钥长度相对较短，所以 DES 是不安全的，现在基本上已被更高级的加密标准 AES 取代。</p><ul><li>mode 支持：CBC，CFB，CTR，CTRGladman，ECB，OFB 等。</li><li>padding 支持：ZeroPadding，NoPadding，AnsiX923，Iso10126，Iso97971，Pkcs7 等。</li></ul><p>参考资料：</p><ul><li>RFC 4772：<a href="https://datatracker.ietf.org/doc/rfc4772/">https://datatracker.ietf.org/doc/rfc4772/</a></li><li>DES 维基百科：<a href="https://en.wikipedia.org/wiki/Data_Encryption_Standard">https://en.wikipedia.org/wiki/Data_Encryption_Standard</a></li></ul><h3 id="JavaScript-实现-5"><a href="#JavaScript-实现-5" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function desEncrypt() &#123;    var key = CryptoJS.enc.Utf8.parse(desKey),        iv = CryptoJS.enc.Utf8.parse(desIv),        srcs = CryptoJS.enc.Utf8.parse(text),        // CBC 加密模式，Pkcs7 填充方式        encrypted = CryptoJS.DES.encrypt(srcs, key, &#123;            iv: iv,            mode: CryptoJS.mode.CBC,            padding: CryptoJS.pad.Pkcs7        &#125;);    return encrypted.toString();&#125;function desDecrypt() &#123;    var key = CryptoJS.enc.Utf8.parse(desKey),        iv = CryptoJS.enc.Utf8.parse(desIv),        srcs = encryptedData,        // CBC 加密模式，Pkcs7 填充方式        decrypted = CryptoJS.DES.decrypt(srcs, key, &#123;            iv: iv,            mode: CryptoJS.mode.CBC,            padding: CryptoJS.pad.Pkcs7        &#125;);    return decrypted.toString(CryptoJS.enc.Utf8);&#125;var text = &quot;I love Python!&quot;       // 待加密对象var desKey = &quot;6f726c64f2c2057&quot;    // 密钥var desIv = &quot;0123456789ABCDEF&quot;    // 初始向量var encryptedData = desEncrypt()var decryptedData = desDecrypt()console.log(&quot;加密字符串: &quot;, encryptedData)console.log(&quot;解密字符串: &quot;, decryptedData)// 加密字符串:  +ndbEkWNw2QAfIYQtwC14w==// 解密字符串:  I love Python!</code></pre><h3 id="Python-实现-5"><a href="#Python-实现-5" class="headerlink" title="Python 实现"></a>Python 实现</h3><pre><code class="python">import binascii# 加密模式 CBC，填充方式 PAD_PKCS5from pyDes import des, CBC, PAD_PKCS5def des_encrypt(key, text, iv):    k = des(key, CBC, iv, pad=None, padmode=PAD_PKCS5)    en = k.encrypt(text, padmode=PAD_PKCS5)    return binascii.b2a_hex(en)def des_decrypt(key, text, iv):    k = des(key, CBC, iv, pad=None, padmode=PAD_PKCS5)    de = k.decrypt(binascii.a2b_hex(text), padmode=PAD_PKCS5)    return deif __name__ == &#39;__main__&#39;:    secret_key = &#39;12345678&#39;   # 密钥    text = &#39;I love Python!&#39;   # 加密对象    iv = secret_key           # 偏移量    secret_str = des_encrypt(secret_key, text, iv)    print(&#39;加密字符串：&#39;, secret_str)    clear_str = des_decrypt(secret_key, secret_str, iv)    print(&#39;解密字符串：&#39;, clear_str)# 加密字符串： b&#39;302d3abf2421169239f829b38a9545f1&#39;# 解密字符串： b&#39;I love Python!&#39;</code></pre><h2 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h2><p>简介：全称三重数据加密算法（英文名称：Triple Data Encryption Standard、 Triple Data Encryption Algorithm、TDES、TDEA），是对称加密算法中的一种。70 年代初由 IBM 研发，后 1977 年被美国国家标准局采纳为数据加密标准，它相当于是对每个数据块应用三次 DES 加密算法。由于计算机运算能力的增强，原版 DES 密码的密钥长度变得容易被暴力破解；3DES 即是设计用来提供一种相对简单的方法，即通过增加 DES 的密钥长度来避免破解，所以严格来说 3DES 不是设计一种全新的块密码算法。</p><ul><li>mode 支持：CBC，CFB，CTR，CTRGladman，ECB，OFB 等。</li><li>padding 支持：ZeroPadding，NoPadding，AnsiX923，Iso10126，Iso97971，Pkcs7 等。</li></ul><p>参考资料：</p><ul><li>RFC 1851：<a href="https://datatracker.ietf.org/doc/rfc1851/">https://datatracker.ietf.org/doc/rfc1851/</a></li><li>3DES 维基百科：<a href="https://en.wikipedia.org/wiki/Triple_DES">https://en.wikipedia.org/wiki/Triple_DES</a></li></ul><h3 id="JavaScript-实现-6"><a href="#JavaScript-实现-6" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function tripleDesEncrypt() &#123;    var key = CryptoJS.enc.Utf8.parse(desKey),        iv = CryptoJS.enc.Utf8.parse(desIv),        srcs = CryptoJS.enc.Utf8.parse(text),        // ECB 加密方式，Iso10126 填充方式        encrypted = CryptoJS.TripleDES.encrypt(srcs, key, &#123;            iv: iv,            mode: CryptoJS.mode.ECB,            padding: CryptoJS.pad.Iso10126        &#125;);    return encrypted.toString();&#125;function tripleDesDecrypt() &#123;    var key = CryptoJS.enc.Utf8.parse(desKey),        iv = CryptoJS.enc.Utf8.parse(desIv),        srcs = encryptedData,        // ECB 加密方式，Iso10126 填充方式        decrypted = CryptoJS.TripleDES.decrypt(srcs, key, &#123;            iv: iv,            mode: CryptoJS.mode.ECB,            padding: CryptoJS.pad.Iso10126        &#125;);    return decrypted.toString(CryptoJS.enc.Utf8);&#125;var text = &quot;I love Python!&quot;       // 待加密对象var desKey = &quot;6f726c64f2c2057c&quot;    // 密钥var desIv = &quot;0123456789ABCDEF&quot;    // 偏移量var encryptedData = tripleDesEncrypt()var decryptedData = tripleDesDecrypt()console.log(&quot;加密字符串: &quot;, encryptedData)console.log(&quot;解密字符串: &quot;, decryptedData)// 加密字符串:  3J0NX7x6GbewjjhoW2HKqg==// 解密字符串:  I love Python!</code></pre><h3 id="Python-实现-6"><a href="#Python-实现-6" class="headerlink" title="Python 实现"></a>Python 实现</h3><pre><code class="python">from Cryptodome.Cipher import DES3from Cryptodome import Random# 需要补位，str不是16的倍数那就补足为16的倍数def add_to_16(value):    while len(value) % 16 != 0:        value += &#39;\0&#39;    return str.encode(value)def des_encrypt(key, text, iv):    # 加密模式 OFB    cipher_encrypt = DES3.new(add_to_16(key), DES3.MODE_OFB, iv)    encrypted_text = cipher_encrypt.encrypt(text.encode(&quot;utf-8&quot;))    return encrypted_textdef des_decrypt(key, text, iv):    # 加密模式 OFB    cipher_decrypt = DES3.new(add_to_16(key), DES3.MODE_OFB, iv)    decrypted_text = cipher_decrypt.decrypt(text)    return decrypted_textif __name__ == &#39;__main__&#39;:    key = &#39;12345678&#39;            # 密钥，16 位    text = &#39;I love Python!&#39;     # 加密对象    iv = Random.new().read(DES3.block_size)  # DES3.block_size == 8    secret_str = des_encrypt(key, text, iv)    print(&#39;加密字符串：&#39;, secret_str)    clear_str = des_decrypt(key, secret_str, iv)    print(&#39;解密字符串：&#39;, clear_str)# 加密字符串： b&#39;\xa5\x8a\xd4R\x99\x16j\xba?vg\xf2\xb6\xa9&#39;# 解密字符串： b&#39;I love Python!&#39;</code></pre><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><p>简介：全称高级加密标准（英文名称：Advanced Encryption Standard），在密码学中又称 Rijndael 加密法，由美国国家标准与技术研究院 （NIST）于 2001 年发布，并在 2002 年成为有效的标准，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES，已经被多方分析且广为全世界所使用，它本身只有一个密钥，即用来实现加密，也用于解密。</p><ul><li>mode 支持：CBC，CFB，CTR，CTRGladman，ECB，OFB 等。</li><li>padding 支持：ZeroPadding，NoPadding，AnsiX923，Iso10126，Iso97971，Pkcs7 等。</li></ul><p>参考资料：</p><ul><li>RFC 3268：<a href="https://datatracker.ietf.org/doc/rfc3268/">https://datatracker.ietf.org/doc/rfc3268/</a></li><li>AES 维基百科：<a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">https://en.wikipedia.org/wiki/Advanced_Encryption_Standard</a></li></ul><h3 id="JavaScript-实现-7"><a href="#JavaScript-实现-7" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function aesEncrypt() &#123;    var key = CryptoJS.enc.Utf8.parse(aesKey),        iv = CryptoJS.enc.Utf8.parse(aesIv),        srcs = CryptoJS.enc.Utf8.parse(text),        // CBC 加密方式，Pkcs7 填充方式        encrypted = CryptoJS.AES.encrypt(srcs, key, &#123;            iv: iv,            mode: CryptoJS.mode.CBC,            padding: CryptoJS.pad.Pkcs7        &#125;);    return encrypted.toString();&#125;function aesDecrypt() &#123;    var key = CryptoJS.enc.Utf8.parse(aesKey),        iv = CryptoJS.enc.Utf8.parse(aesIv),        srcs = encryptedData,        // CBC 加密方式，Pkcs7 填充方式        decrypted = CryptoJS.AES.decrypt(srcs, key, &#123;            iv: iv,            mode: CryptoJS.mode.CBC,            padding: CryptoJS.pad.Pkcs7        &#125;);    return decrypted.toString(CryptoJS.enc.Utf8);&#125;var text = &quot;I love Python!&quot;       // 待加密对象var aesKey = &quot;6f726c64f2c2057c&quot;   // 密钥，16 倍数var aesIv = &quot;0123456789ABCDEF&quot;    // 偏移量，16 倍数var encryptedData = aesEncrypt()var decryptedData = aesDecrypt()console.log(&quot;加密字符串: &quot;, encryptedData)console.log(&quot;解密字符串: &quot;, decryptedData)// 加密字符串:  dZL7TLJR786VGvuUvqYGoQ==// 解密字符串:  I love Python!</code></pre><h3 id="Python-实现-7"><a href="#Python-实现-7" class="headerlink" title="Python 实现"></a>Python 实现</h3><pre><code class="python">import base64from Cryptodome.Cipher import AES# 需要补位，str不是16的倍数那就补足为16的倍数def add_to_16(value):    while len(value) % 16 != 0:        value += &#39;\0&#39;    return str.encode(value)# 加密方法def aes_encrypt(key, t, iv):    aes = AES.new(add_to_16(key), AES.MODE_CBC, add_to_16(iv))  # 初始化加密器    encrypt_aes = aes.encrypt(add_to_16(t))                    # 先进行 aes 加密    encrypted_text = str(base64.encodebytes(encrypt_aes), encoding=&#39;utf-8&#39;)  # 执行加密并转码返回 bytes    return encrypted_text# 解密方法def aes_decrypt(key, t, iv):    aes = AES.new(add_to_16(key), AES.MODE_CBC, add_to_16(iv))         # 初始化加密器    base64_decrypted = base64.decodebytes(t.encode(encoding=&#39;utf-8&#39;))  # 优先逆向解密 base64 成 bytes    decrypted_text = str(aes.decrypt(base64_decrypted), encoding=&#39;utf-8&#39;).replace(&#39;\0&#39;, &#39;&#39;)  # 执行解密密并转码返回str    return decrypted_textif __name__ == &#39;__main__&#39;:    secret_key = &#39;12345678&#39;   # 密钥    text = &#39;I love Python!&#39;   # 加密对象    iv = secret_key           # 初始向量    encrypted_str = aes_encrypt(secret_key, text, iv)    print(&#39;加密字符串：&#39;, encrypted_str)    decrypted_str = aes_decrypt(secret_key, encrypted_str, iv)    print(&#39;解密字符串：&#39;, decrypted_str)# 加密字符串： lAVKvkQh+GtdNpoKf4/mHA==# 解密字符串： I love Python!</code></pre><h2 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h2><p>简介：英文名称：Rivest Cipher 4，也称为 ARC4 或 ARCFOUR，是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。RC4 是有线等效加密（WEP）中采用的加密算法，也曾经是 TLS 可采用的算法之一，该算法的速度可以达到 DES 加密的 10 倍左右，且具有很高级别的非线性，虽然它在软件方面的简单性和速度非常出色，但在 RC4 中发现了多个漏洞，它特别容易受到攻击，RC4 作为一种老旧的验证和加密算法易于受到黑客攻击，现在逐渐不推荐使用了。</p><p>参考资料：</p><ul><li>RFC 7465：<a href="https://datatracker.ietf.org/doc/rfc7465/">https://datatracker.ietf.org/doc/rfc7465/</a></li><li>RC4 维基百科：<a href="https://en.wikipedia.org/wiki/RC4">https://en.wikipedia.org/wiki/RC4</a></li></ul><h3 id="JavaScript-实现-8"><a href="#JavaScript-实现-8" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function RC4Encrypt() &#123;    return CryptoJS.RC4.encrypt(text, key).toString();&#125;function RC4Decrypt()&#123;    return CryptoJS.RC4.decrypt(encryptedData, key).toString(CryptoJS.enc.Utf8);&#125;var text = &quot;I love Python!&quot;var key = &quot;6f726c64f2c2057c&quot;var encryptedData = RC4Encrypt()var decryptedData = RC4Decrypt()console.log(&quot;加密字符串: &quot;, encryptedData)console.log(&quot;解密字符串: &quot;, decryptedData)// 加密字符串:  U2FsdGVkX18hMm9WWdoEQGPolnXzlg9ryArdGNwv// 解密字符串:  I love Python!</code></pre><h3 id="Python-实现-8"><a href="#Python-实现-8" class="headerlink" title="Python 实现"></a>Python 实现</h3><pre><code class="python">import base64from Cryptodome.Cipher import ARC4def rc4_encrypt(key, t):    enc = ARC4.new(key.encode(&#39;utf8&#39;))    res = enc.encrypt(t.encode(&#39;utf-8&#39;))    res = base64.b64encode(res)    return resdef rc4_decrypt(key, t):    data = base64.b64decode(t)    enc = ARC4.new(key.encode(&#39;utf8&#39;))    res = enc.decrypt(data)    return resif __name__ == &quot;__main__&quot;:    secret_key = &#39;12345678&#39;   # 密钥    text = &#39;I love Python!&#39;   # 加密对象    encrypted_str = rc4_encrypt(secret_key, text)    print(&#39;加密字符串：&#39;, encrypted_str)    decrypted_str = rc4_decrypt(secret_key, encrypted_str)    print(&#39;解密字符串：&#39;, decrypted_str)# 加密字符串： b&#39;8tNVu3/U/veJR2KgyBw=&#39;# 解密字符串： b&#39;I love Python!&#39;</code></pre><h2 id="Rabbit"><a href="#Rabbit" class="headerlink" title="Rabbit"></a>Rabbit</h2><p>简介：Rabbit 加密算法是一个高性能的流密码加密方式，2003 年首次被提出，它从 128 位密钥和 64 位初始向量（iv）创建一个密钥流。</p><p>参考资料：</p><ul><li>RFC 4503：<a href="https://datatracker.ietf.org/doc/rfc4503/">https://datatracker.ietf.org/doc/rfc4503/</a></li><li>Rabbit 维基百科：<a href="https://en.wikipedia.org/wiki/Rabbit_(cipher)">https://en.wikipedia.org/wiki/Rabbit_(cipher)</a></li></ul><h3 id="JavaScript-实现-9"><a href="#JavaScript-实现-9" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 crypto-js 加密模块var CryptoJS = require(&#39;crypto-js&#39;)function rabbitEncrypt() &#123;    return CryptoJS.Rabbit.encrypt(text, key).toString();&#125;function rabbitDecrypt() &#123;    return CryptoJS.Rabbit.decrypt(encryptedData, key).toString(CryptoJS.enc.Utf8);&#125;var text = &quot;I love Python!&quot;var key = &quot;6f726c64f2c2057&quot;var encryptedData = rabbitEncrypt()var decryptedData = rabbitDecrypt()console.log(&quot;加密字符串: &quot;, encryptedData)console.log(&quot;解密字符串: &quot;, decryptedData)// 加密字符串:  U2FsdGVkX1+ZVCHRXlhmG5Xw87YPWMNIBlbukuh8// 解密字符串:  I love Python!</code></pre><h3 id="Python-实现-9"><a href="#Python-实现-9" class="headerlink" title="Python 实现"></a>Python 实现</h3><p>目前没有找到有第三方库可以直接实现 Rabbit 算法，在 Python 中实现可以参考：<a href="https://asecuritysite.com/encryption/rabbit2">https://asecuritysite.com/encryption/rabbit2</a></p><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>简介：英文名称：Rivest-Shamir-Adleman，是 1977 年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的，RSA 就是他们三人姓氏开头字母拼在一起组成的，RSA 加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。它被普遍认为是目前比较优秀的公钥方案之一。RSA是第一个能同时用于加密和数字签名的算法，它能够抵抗到目前为止已知的所有密码攻击。</p><p>参考资料：</p><ul><li>RSA 维基百科：<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">https://en.wikipedia.org/wiki/RSA_(cryptosystem)</a></li></ul><h3 id="JavaScript-实现-10"><a href="#JavaScript-实现-10" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><pre><code class="javascript">// 引用 node-rsa 加密模块var NodeRSA = require(&#39;node-rsa&#39;);function rsaEncrypt() &#123;    pubKey = new NodeRSA(publicKey,&#39;pkcs8-public&#39;);    var encryptedData = pubKey.encrypt(text, &#39;base64&#39;);    return encryptedData&#125;function rsaDecrypt() &#123;    priKey = new NodeRSA(privatekey,&#39;pkcs8-private&#39;);    var decryptedData = priKey.decrypt(encryptedData, &#39;utf8&#39;);    return decryptedData&#125;var key = new NodeRSA(&#123;b: 512&#125;);                    //生成512位秘钥var publicKey = key.exportKey(&#39;pkcs8-public&#39;);    //导出公钥var privatekey = key.exportKey(&#39;pkcs8-private&#39;);  //导出私钥var text = &quot;I love Python!&quot;var encryptedData = rsaEncrypt()var decryptedData = rsaDecrypt()console.log(&quot;公钥:\n&quot;, publicKey)console.log(&quot;私钥:\n&quot;, privatekey)console.log(&quot;加密字符串: &quot;, encryptedData)console.log(&quot;解密字符串: &quot;, decryptedData)/*公钥: -----BEGIN PUBLIC KEY-----MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAOV1BwTJSVce/QjJAro5fXG9WzOpal09Qtv1yuXKE81vZSNTHxW6dICwPT/kjCfC3bA5Qs6wnYBANuwD6wlAS0UCAwEAAQ==-----END PUBLIC KEY-----私钥: -----BEGIN PRIVATE KEY-----MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEA5XUHBMlJVx79CMkCujl9cb1bM6lqXT1C2/XK5coTzW9lI1MfFbp0gLA9P+SMJ8LdsDlCzrCdgEA27APrCUBLRQIDAQABAkAiXwJbJC+5PioXG80tyhjRZdT4iyMkrl2Kh2oKO9f1iLaBXLyaD0HW82wFh+cUy8GcMl9jse8DE8wd1TdORmHhAiEA/rwmWjXHVgDqcH/fqk8Ufku0fXvs56h5QDoh1so5vokCIQDmmL3JDW6Y7RuK2qwFbHBZtYPRFRVdn5X1oqU2FOSX3QIhAOVTjVN5RtNuT6Cn/jvcpZ5tmTe+8TA8w6vGqeAsfn/BAiBvKKIUEQ2HWoU0YkUaODPQiteIKomqIAvB5S2O7HNlYQIgWMuLUxGZbbcAmIX+YmRXuET97S7OWv+zWHVfb/rbXtI=-----END PRIVATE KEY-----加密字符串:  hHXTF1K3w55Wd6OSjVYtqxceJ5VhlySNUahel9pwKD92Ef7wIT7DYPuJRKiqz5tuHtUqujbmbZBSL0qDE/EA+A==解密字符串:  I love Python!*/</code></pre><h3 id="Python-实现-10"><a href="#Python-实现-10" class="headerlink" title="Python 实现"></a>Python 实现</h3><p>模块：rsa：</p><pre><code class="python">import rsadef rsa_encrypt(pu_key, t):    # 公钥加密    rsa = rsa.encrypt(t.encode(&quot;utf-8&quot;), pu_key)    return rsadef rsa_decrypt(pr_key, t):    # 私钥解密    rsa = rsa.decrypt(t, pr_key).decode(&quot;utf-8&quot;)    return rsaif __name__ == &quot;__main__&quot;:    public_key, private_key = rsa.newkeys(512)   # 生成公钥、私钥    print(&#39;公钥：&#39;, public_key)    print(&#39;私钥：&#39;, private_key)    text = &#39;I love Python!&#39;  # 加密对象    encrypted_str = rsa_encrypt(public_key, text)    print(&#39;加密字符串：&#39;, encrypted_str)    decrypted_str = rsa_decrypt(private_key, encrypted_str)    print(&#39;解密字符串：&#39;, decrypted_str)&#39;&#39;&#39;公钥： PublicKey(7636479066127060956100056267701318377455704072072698049978592945665550579944731953431504993757594103617537700972424661030900303472123028864161050235168613, 65537)私钥： PrivateKey(7636479066127060956100056267701318377455704072072698049978592945665550579944731953431504993757594103617537700972424661030900303472123028864161050235168613, 65537, 3850457767980968449796700480128630632818465005441846698224554128042451115530564586537997896922067523638756079019054611200173122138274839877369624069360253, 4713180694194659323798858305046043997526301456820208338158979730140812744181638767, 1620238976946735819854194349514460863335347861649166352709029254680140139)加密字符串： b&quot;\x1aaeps\xa0c&#125;\xb6\xcf\xa3\xb0\xbb\xedA\x7f&#125;\x03\xdc\xd5\x1c\x9b\xdb\xda\xf9q\x80[=\xf5\x91\r\xd0&#39;f\xce\x1f\x01\xef\xa5\xdb3\x96\t0qIxF\xbd\x11\xd6\xb25\xc5\xe1pM\xb4M\xc2\xd4\x03\xa6&quot;解密字符串： I love Python!&#39;&#39;&#39;</code></pre><p>模块 Cryptodome：</p><pre><code class="python">import base64from Cryptodome.PublicKey import RSAfrom Cryptodome.Cipher import PKCS1_v1_5data = &quot;cKK8B2rWwfwWeXhz&quot;public_key = &quot;MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAM1xhOWaThSMpfxFsjV5YaWOFHt+6RvS+zH2Pa47VVr8PkZYnRaaKKy2MYBuEh7mZfM/R1dUXTgu0gp6VTNeNQkCAwEAAQ==&quot;rsa_key = RSA.import_key(base64.b64decode(public_key))  # 导入读取到的公钥cipher = PKCS1_v1_5.new(rsa_key)                        # 生成对象cipher_text = base64.b64encode(cipher.encrypt(data.encode(encoding=&quot;utf-8&quot;)))print(cipher_text)</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> JS 逆向 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据结构之栈的实现</title>
      <link href="/article/038/"/>
      <url>/article/038/</url>
      
        <content type="html"><![CDATA[<h2 id="栈的概念"><a href="#栈的概念" class="headerlink" title="栈的概念"></a>栈的概念</h2><p>栈（stack）又名堆栈，栈是一种线性数据结构，用先进后出或者是后进先出的方式存储数据，栈中数据的插入删除操作都是在栈的顶端进行，这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p><p><img src="https://img-blog.csdnimg.cn/20201101205308521.png" alt="01"></p><hr><h2 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h2><p>元素后进先出（Last in First Out，LIFO）</p><hr><h2 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h2><ul><li><font color=#FF0000><strong>push(item)</strong></font>：进栈（向栈顶添加元素）</li><li><font color=#FF0000><strong>pop()</strong></font>：出栈（删除栈顶元素）</li><li><font color=#FF0000><strong>top()</strong></font>：查看栈顶元素</li><li><font color=#FF0000><strong>empty()</strong></font>：判断栈是否为空</li></ul><hr><h2 id="Python-实现栈"><a href="#Python-实现栈" class="headerlink" title="Python 实现栈"></a>Python 实现栈</h2><p>栈并不是 Python 的内建类型，在必要的时候可以使用列表来模拟基于数组的栈。如果将列表的末尾看作是栈的顶，列表方法 <code>append()</code> 就是将元素压入到栈中（进栈），而列表方法 <code>pop()</code> 会删除并返回栈顶的元素（出栈），列表索引的方式 <code>arr[-1]</code> 可以查看栈顶元素。具体代码实现如下：</p><pre><code class="python">class Stack:    def __init__(self):        self.stack = []    def push(self, item):        self.stack.append(item)    def pop(self):        if self.empty():            return None        else:            return self.stack.pop()    def top(self):        if self.empty():            return None        else:            return self.stack[-1]    def empty(self):        return len(self.stack) == 0</code></pre><hr><h2 id="栈的简单应用：括号匹配问题"><a href="#栈的简单应用：括号匹配问题" class="headerlink" title="栈的简单应用：括号匹配问题"></a>栈的简单应用：括号匹配问题</h2><p><font color=#2DAF8B><strong>问题描述：</strong></font></p><p>给定一个字符串，字符串中只包含小括号 <code>()</code>、中括号 <code>[]</code>、大括号 <code>&#123;&#125;</code>，求该字符串中的括号是否匹配。匹配规则：成对出现或者左右对称出现，例如：</p><p><font color=#FF0000><strong>()[]{}</strong></font>：匹配；<font color=#FF0000><strong>{[()]}</strong></font>：匹配；<font color=#FF0000><strong>({}]</strong></font>：不匹配；<font color=#FF0000><strong>()]</strong></font>：不匹配；<font color=#FF0000><strong>({)}</strong></font>：不匹配</p><p><font color=#2DAF8B><strong>通过栈来解决：</strong></font></p><p>有字符串 <font color=#FF0000><strong>()[{}]</strong></font>，依次取每个括号，只要是左括号就进栈，只要是右括号就判断栈顶是否为对应的左括号，具体步骤如下：</p><ul><li><strong>①</strong> 遇到左小括号 <font color=#FF0000><strong>(</strong></font>，执行进栈操作；</li><li><strong>②</strong> 遇到右小括号 <font color=#FF0000><strong>)</strong></font>，判断此时栈顶是否为左小括号 <font color=#FF0000><strong>(</strong></font>，是则让左小括号 <font color=#FF0000><strong>(</strong></font> 出栈，此时栈为空;</li><li><strong>③</strong> 遇到左中括号 <font color=#FF0000><strong>[</strong></font>，执行进栈操作；</li><li><strong>④</strong> 遇到左大括号 <font color=#FF0000><strong>{</strong></font>，执行进栈操作；</li><li><strong>⑤</strong> 遇到右大括号 <font color=#FF0000><strong>}</strong></font>，判断此时栈顶是否为左大括号 <font color=#FF0000><strong>{</strong></font>，是则让左大括号 <font color=#FF0000><strong>{</strong></font> 出栈，此时栈为空；</li><li><strong>⑥</strong> 遇到右中括号 <font color=#FF0000><strong>]</strong></font>，判断此时栈顶是否为左中括号 <font color=#FF0000><strong>[</strong></font>，是则让左中括号 <font color=#FF0000><strong>[</strong></font> 出栈，此时栈为空；</li><li><strong>⑦</strong> 判断最终的栈是否为空，是则表示匹配，不是则表示不匹配。其中第 <strong>② ⑤ ⑥</strong> 步中，若判断为不是，则直接表示不匹配。</li></ul><p><font color=#2DAF8B><strong>Python 代码实现：</strong></font></p><pre><code class="python">class Stack:    def __init__(self):        self.stack = []    def push(self, item):        self.stack.append(item)    def pop(self):        if self.empty():            return None        else:            return self.stack.pop()    def top(self):        if self.empty():            return None        else:            return self.stack[-1]    def empty(self):        return len(self.stack) == 0def brackets_match(s):    match_dict = &#123;&#39;&#125;&#39;: &#39;&#123;&#39;, &#39;]&#39;: &quot;[&quot;, &#39;)&#39;: &#39;(&#39;&#125;    stack = Stack()    for ch in s:        if ch in [&#39;(&#39;, &#39;[&#39;, &#39;&#123;&#39;]:    # 如果为左括号，则执行进栈操作            stack.push(ch)        else:                        # 如果为右括号            if stack.empty():        # 如果栈为空，则不匹配，即多了一个右括号，没有左括号匹配                return False            elif stack.top() == match_dict[ch]:  # 如果栈顶的元素为对应的左括号，则让栈顶出栈                stack.pop()            else:                    # 如果栈顶元素不是对应的左括号，则不匹配                return False    if stack.empty():                # 最后的栈如果为空，则匹配，否则不匹配        return True    else:        return Falseprint(brackets_match(&#39;[&#123;()&#125;()&#123;()&#125;[](&#123;&#125;)&#123;&#125;]&#39;))print(brackets_match(&#39;()[&#123;&#125;]&#39;))print(brackets_match(&#39;(&#123;)&#125;&#39;))print(brackets_match(&#39;[]&#125;&#39;))</code></pre><p>输出结果：</p><pre><code class="python">TrueTrueFalseFalse</code></pre><hr><h2 id="栈的简单应用：倒序输出一组元素"><a href="#栈的简单应用：倒序输出一组元素" class="headerlink" title="栈的简单应用：倒序输出一组元素"></a>栈的简单应用：倒序输出一组元素</h2><p>把元素存入栈，再顺序取出：</p><pre><code class="python">class Stack:    def __init__(self):        self.stack = []    def push(self, item):        self.stack.append(item)    def pop(self):        if self.empty():            return None        else:            return self.stack.pop()    def top(self):        if self.empty():            return None        else:            return self.stack[-1]    def empty(self):        return len(self.stack) == 0def reverse_list(s):    stack = Stack()    for ch in s:        stack.push(ch)    new_list = []    while not stack.empty():        new_list.append(stack.pop())    return new_listprint(reverse_list([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;]))</code></pre><p>输出结果：</p><pre><code class="python">[&#39;E&#39;, &#39;D&#39;, &#39;C&#39;, &#39;B&#39;, &#39;A&#39;]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 算法之递归与尾递归，斐波那契数列以及汉诺塔的实现</title>
      <link href="/article/037/"/>
      <url>/article/037/</url>
      
        <content type="html"><![CDATA[<h2 id="递归概念"><a href="#递归概念" class="headerlink" title="递归概念"></a>递归概念</h2><p><font color=#ff0000><strong>递归</strong></font>：程序调用自身的编程技巧称为递归（ recursion）。用一种通俗的话来说就是自己调用自己，它通常把一个大型复杂的问题层层转化为一个与原问题相似的、但是规模较小的问题来求解，当问题小到一定规模的时候，需要一个递归出口返回。递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。</p><p><font color=#ff0000><strong>递归函数</strong></font>：在编程语言中，函数直接或间接调用函数本身，则该函数称为递归函数；在数学上的定义如下：对于某一函数 $f(x)$，其定义域是集合 A，那么若对于 A 集合中的某一个值 $X_0$，其函数值 $f(x_0)$ 由 $f(f(x_0))$ 决定，那么就称 $f(x)$ 为递归函数。</p><hr><h2 id="递归要素"><a href="#递归要素" class="headerlink" title="递归要素"></a>递归要素</h2><ul><li><p>递归必须包含一个基本的出口（结束条件），否则就会无限递归，最终导致栈溢出；</p></li><li><p>递归必须包含一个可以分解的问题，例如要想求得 $fact(n)$，就需要用 $n * fact(n-1)$；</p></li><li><p>递归必须必须要向着递归出口靠近，例如每次递归调用都会 $n-1$，向着递归出口 $n == 0$ 靠近。</p></li></ul><hr><h2 id="递归与迭代的区别"><a href="#递归与迭代的区别" class="headerlink" title="递归与迭代的区别"></a>递归与迭代的区别</h2><ul><li><p><font color=#ff0000><strong>递归（recursion）</strong></font>：递归则是一步一步往前递推，直到递归基础，寻找一条路径， 然后再由前向后计算。（A调用A）</p></li><li><p><font color=#ff0000><strong>迭代（iteration）</strong></font>：迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值，因此迭代是从前往后计算的。（A重复调用B）</p></li></ul><hr><h2 id="示例一：阶乘"><a href="#示例一：阶乘" class="headerlink" title="示例一：阶乘"></a>示例一：阶乘</h2><p>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且 0 的阶乘为 1。即 $n!=1×2×3×…×(n-1)×n$，以递归方式定义：$n!=(n-1)!×n$</p><pre><code class="python">def factorial(n):    if n == 0:        return 1    else:        return n * factorial(n-1)</code></pre><hr><h2 id="示例二：斐波那契数列"><a href="#示例二：斐波那契数列" class="headerlink" title="示例二：斐波那契数列"></a>示例二：斐波那契数列</h2><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家莱昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”。</p><p>有一个数列：0、1、1、2、3、5、8、13、21、34、55、89…，这个数列从第3项开始，每一项都等于前两项之和。以递推的方法定义：$F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N^*）$</p><pre><code class="python">def fibonacc(n):    if n == 1 or n == 2:        return 1    else:        return fibonacc(n-1) + fibonacc(n-2)</code></pre><p>以上方法的时间复杂度为$O(2^n)$，稍微大一点的数都会算很久，有一个简单的解决方案，使用 <code>lru_cache</code> 缓存装饰器，缓存一些中间结果：</p><pre><code class="python">from functools import lru_cache# 缓存斐波那契函数已经计算出的结果，最多占用1024字节内存@lru_cache(maxsize=1024)def fibonacc(n):    if n == 1 or n == 2:        return 1    else:        return fibonacc(n-1) + fibonacc(n-2)</code></pre><p>另外还有更加节省时间和空间的方法：</p><pre><code class="python">def fibonacc(n, current=0, next=1):    if n == 0:        return current    else:        return fibonacc(n-1, next, current+next)</code></pre><hr><h2 id="示例三：汉诺塔问题"><a href="#示例三：汉诺塔问题" class="headerlink" title="示例三：汉诺塔问题"></a>示例三：汉诺塔问题</h2><p>汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。64片黄金圆盘移动完毕之日，就是世界毁灭之时。</p><p><img src="https://img-blog.csdnimg.cn/20201028204105893.gif" alt="01汉诺塔"></p><p>对于 n 个盘子，移动步骤如下：</p><ul><li>把 n-1 个盘子由 A 经过 C 移动到 B</li><li>把最后一个盘子移动到 C</li><li>把 n-1 个盘子由 B 经过 A 移动到 C</li></ul><p><img src="https://img-blog.csdnimg.cn/20201028220237371.png" alt="02汉诺塔"></p><p>递归代码实现：</p><pre><code class="python">def hanoi(n, a, b, c):                                # n 个盘子，a，b，c三个柱子    if n &gt; 0:        hanoi(n-1, a, c, b)                           # 把 n-1 个盘子由 a 经过 c 移动到 b        print(&#39;moving from &#123;0&#125; to &#123;1&#125;&#39;.format(a, c))  # 把最后一个盘子移动到 c        hanoi(n-1, b, a, c)                           # 把 n-1 个盘子由 b 经过 a 移动到 c</code></pre><p>示例：</p><pre><code class="python">def hanoi(n, a, b, c):    if n &gt; 0:        hanoi(n-1, a, c, b)        print(&#39;moving from &#123;0&#125; to &#123;1&#125;&#39;.format(a, c))        hanoi(n-1, b, a, c)hanoi(3, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;)</code></pre><pre><code class="python">moving from A to Cmoving from A to Bmoving from C to Bmoving from A to Cmoving from B to Amoving from B to Cmoving from A to C</code></pre><hr><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。通俗来讲就是递归调用放在了函数的最后。</p><pre><code class="python"># 一般递归def func(n):    if n &gt; 0:        func(n-1)        print(n)# 一般递归def func(n):    if n &gt; 0:        return func(n-1) + n# 尾递归def func(n):    a = n    if n &gt; 0:        a += 1        print(a, n)        return func(n-1)</code></pre><p>对于普通的递归，每一级递归都产生了新的局部变量，必须创建新的调用栈，随着递归深度的增加，创建的栈越来越多，容易造成爆栈。</p><pre><code class="python">def normal_recursion(n):    if n == 1:        return 1    else:        return n + normal_recursion(n-1)</code></pre><p><code>normal_recursion(5)</code> 执行：</p><pre><code class="python">normal_recursion(5)5 + normal_recursion(4)5 + 4 + normal_recursion(3)5 + 4 + 3 + normal_recursion(2)5 + 4 + 3 + 2 + normal_recursion(1)5 + 4 + 3 + 35 + 4 + 65 + 1015</code></pre><p>尾递归基于函数的尾调用，每一级调用直接返回递归函数更新调用栈，没有新局部变量的产生，类似迭代的实现。</p><pre><code class="python">def tail_recursion(n, total=0):    if n == 0:        return total    else:        return tail_recursion(n-1, total+n)</code></pre><p><code>normal_recursion(5)</code> 执行：</p><pre><code class="python">tail_recursion(5, 0)tail_recursion(4, 5)tail_recursion(3, 9)tail_recursion(2, 12)tail_recursion(1, 14)tail_recursion(0, 15)15</code></pre><p>在 Python，Java，Pascal 等语言中是无法实现尾递归优化的，所以采用了 for，while，goto 等特殊结构以迭代的方式来代替尾递归。</p><hr><h2 id="Python-中尾递归的解决方案"><a href="#Python-中尾递归的解决方案" class="headerlink" title="Python 中尾递归的解决方案"></a>Python 中尾递归的解决方案</h2><p>使用普通的递归来实现斐波那契数列的计算，代码段如下：</p><pre><code class="python">def fibonacc(n, current=0, next=1):    if n == 0:        return current    else:        return fibonacc(n-1, next, current+next)a = fibonacc(1000)print(a)</code></pre><p>此时会报错，因为超过了最大递归深度（默认深度900-1000左右）：</p><pre><code class="python">Traceback (most recent call last):  File &quot;F:/PycharmProjects/algorithm/fibonacc_test.py&quot;, line 57, in &lt;module&gt;    a = fibonacc(1000)  File &quot;F:/PycharmProjects/algorithm/fibonacc_test.py&quot;, line 47, in fibonacc    return fibonacc(n-1, next, current+next)  File &quot;F:/PycharmProjects/algorithm/fibonacc_test.py&quot;, line 47, in fibonacc    return fibonacc(n-1, next, current+next)  File &quot;F:/PycharmProjects/algorithm/fibonacc_test.py&quot;, line 47, in fibonacc    return fibonacc(n-1, next, current+next)  [Previous line repeated 995 more times]  File &quot;F:/PycharmProjects/algorithm/fibonacc_test.py&quot;, line 44, in fibonacc    if n == 0:RecursionError: maximum recursion depth exceeded in comparison</code></pre><p>如果是递归深度不是很大的情况，可以手动重设递归深度来解决：</p><pre><code class="python">import syssys.setrecursionlimit(10000)  # 递归深度设置为 10000</code></pre><p>如果递归深度非常大，那么就可以采用尾递归优化，但是 Python 官方是并不支持尾递归的（不知道为啥），然而这难不到广大的程序员们，早在 2006 年 <a href="https://code.activestate.com/recipes/users/2792865/">Crutcher Dunnavant</a> 就想出了一个解决办法，实现一个 <code>tail_call_optimized</code> 装饰器，原文链接：<a href="https://code.activestate.com/recipes/474088/">https://code.activestate.com/recipes/474088/</a>，原代码是 Python 2.4 实现的，用 Python 3.x 实现如下：</p><pre><code class="python"># This program shows off a python decorator# which implements tail call optimization. It# does this by throwing an exception if it is# it&#39;s own grandparent, and catching such# exceptions to recall the stack.import sysclass TailRecurseException(BaseException):    def __init__(self, args, kwargs):        self.args = args        self.kwargs = kwargsdef tail_call_optimized(g):    &quot;&quot;&quot;    This function decorates a function with tail call    optimization. It does this by throwing an exception    if it is it&#39;s own grandparent, and catching such    exceptions to fake the tail call optimization.    This function fails if the decorated5    function recurses in a non-tail context.    &quot;&quot;&quot;    def func(*args, **kwargs):        f = sys._getframe()        if f.f_back and f.f_back.f_back and f.f_back.f_back.f_code == f.f_code:            raise TailRecurseException(args, kwargs)        else:            while 1:                try:                    return g(*args, **kwargs)                except TailRecurseException as e:                    args = e.args                    kwargs = e.kwargs    func.__doc__ = g.__doc__    return func</code></pre><p>使用该装饰器再来实现比较大的斐波那契数列的计算：</p><pre><code class="python">@tail_call_optimizeddef fibonacc(n, current=0, next=1):    if n == 0:        return current    else:        return fibonacc(n-1, next, current+next)a = fibonacc(1000)print(a)</code></pre><p>输出结果：</p><pre><code class="python">43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875</code></pre><p><code>tail_call_optimized</code> 实现尾递归优化的原理：当递归函数被该装饰器修饰后，递归调用在装饰器while循环内部进行，每当产生新的递归调用栈帧时，<code>f.f_back.f_back.f_code == f.f_code:</code> 就捕获当前尾调用函数的参数，并抛出异常，从而销毁递归栈并使用捕获的参数手动调用递归函数，所以递归的过程中始终只存在一个栈帧对象，达到优化的目的。</p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX•鲍勃。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/109322815未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 实现十大经典排序算法</title>
      <link href="/article/036/"/>
      <url>/article/036/</url>
      
        <content type="html"><![CDATA[<ul><li>参考资料：<a href="https://www.bilibili.com/video/BV1mp4y1D7UP">https://www.bilibili.com/video/BV1mp4y1D7UP</a></li><li>本文动图演示来源：<a href="https://visualgo.net/">https://visualgo.net/</a></li></ul><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/108987300未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a><font color=#FF0000>排序算法分类</font></h2><ul><li><font color=#FF0000><strong>内部排序</strong></font>：指在排序期间，元素全部存放在内存中的排序，常见的内部排序算法有：<strong>冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、基数排序</strong>等。</li><li><font color=#FF0000><strong>外部排序</strong></font>：指在排序期间，元素无法完全全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序；</li><li><font color=#FF0000><strong>比较类排序</strong></font>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li><li><font color=#FF0000><strong>非比较类排序</strong></font>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 常见的非比较类排序算法有：<strong>基数排序、计数排序、桶排序</strong>等</li></ul><hr><p>一般情况下，内部排序算法在执行过程中都要进行两种操作：比较和移动。通过比较两个关键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。但是，并非所有的内部排序算法都要基于比较操作。</p><p>每种排序算法都有各自的优缺点，适合在不同的环境下使用，就其全面性能而言，很难提出一种被认为是最好的算法。<font color=#FF0000><strong>通常可以将排序算法分为插入排序、交换排序、选择排序、归并排序和基数排序五大类</strong></font>，内部排序算法的性能取决于算法的时间复杂度和空间复杂度，而时间复杂度一般是由比较和移动的次数决定的。</p><hr><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/01.png" alt="01"></p><table><thead><tr><th>排序算法</th><th>时间复杂度（平均）</th><th>时间复杂度（最好）</th><th>时间复杂度（最坏）</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$$ O(n^2) $$</td><td>$$ O(n) $$</td><td>$$ O(n^2) $$</td><td>$$ O(1) $$</td><td>稳定</td></tr><tr><td>选择排序</td><td>$$ O(n^2) $$</td><td>$$ O(n^2) $$</td><td>$$ O(n^2) $$</td><td>$$ O(1) $$</td><td>不稳定</td></tr><tr><td>插入排序</td><td>$$ O(n^2) $$</td><td>$$ O(n) $$</td><td>$$ O(n^2) $$</td><td>$$ O(1) $$</td><td>稳定</td></tr><tr><td>希尔排序</td><td>$$ O(nlogn) $$</td><td>$$ O(nlog^2n) $$</td><td>$$ O(nlog^2n) $$</td><td>$$ O(1) $$</td><td>不稳定</td></tr><tr><td>归并排序</td><td>$$ O(nlogn) $$</td><td>$$ O(nlogn) $$</td><td>$$ O(nlogn) $$</td><td>$$ O(n) $$</td><td>稳定</td></tr><tr><td>快速排序</td><td>$$ O(nlogn) $$</td><td>$$ O(nlogn) $$</td><td>$$ O(n^2) $$</td><td>$$ O(logn) $$</td><td>不稳定</td></tr><tr><td>堆排序</td><td>$$ O(nlogn) $$</td><td>$$ O(nlogn) $$</td><td>$$ O(nlogn) $$</td><td>$$ O(1) $$</td><td>不稳定</td></tr><tr><td>计数排序</td><td>$$ O(n+k) $$</td><td>$$ O(n+k) $$</td><td>$$ O(n+k) $$</td><td>$$ O(k) $$</td><td>稳定</td></tr><tr><td>桶排序</td><td>$$ O(n+k) $$</td><td>$$ O(n+k) $$</td><td>$$ O(n^2) $$</td><td>$$ O(n+k) $$</td><td>稳定</td></tr><tr><td>基数排序</td><td>$$ O(n*k) $$</td><td>$$ O(n*k) $$</td><td>$$ O(n*k) $$</td><td>$$ O(n+k) $$</td><td>稳定</td></tr></tbody></table><p><strong>稳定性</strong>：排序后 2 个相等键值的顺序和排序之前它们的顺序是否相同。例：如果 a 原本在 b 前面，且 a=b，排序之后 a 仍然在 b 的前面，则表示具有稳定性。</p><p>常见时间复杂度大小比较：</p><p>$$<br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt;…&lt; O(2^n)&lt;O (n!)<br>$$</p><hr><h2 id="一、冒泡排序（Bubble-Sort）"><a href="#一、冒泡排序（Bubble-Sort）" class="headerlink" title="一、冒泡排序（Bubble Sort）"></a><font color=#FF0000>一、冒泡排序（Bubble Sort）</font></h2><h3 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h3><p>重复地走访要排序的元素，依次比较两个相邻的元素，如果顺序（如从大到小）错误就把他们交换过来。走访元素的工作是重复地进行，直到没有相邻元素需要交换，也就是说该元素列已经排序完成。冒泡的意思其实就是每一轮冒泡一个最大的元素就会通过不断比较和交换相邻元素使它转移到最右边。</p><p>假如有 10 个小盆友从左到右站成一排，个头不等。老师想让他们按照个头从低到高站好，于是他开始喊口号。 每喊一次，从第一个小盆友开始，相邻的小朋友如果身高不是正序就会两两调换，就这样第一轮个头最高的排到了最右边（冒泡到最右边），第二轮依次这么来，从第一个小朋友开始两两交换，这样次高的小盆友又排到了倒数第二个位置。依次类推。</p><h3 id="2、步骤"><a href="#2、步骤" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li><strong>②</strong> 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li><strong>③</strong> 针对所有的元素重复步骤 <strong>①</strong> ~ <strong>②</strong>，除了最后一个元素，直到排序完成。</li></ul><h3 id="3、动画演示"><a href="#3、动画演示" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/02%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="02冒泡排序"></p><h3 id="4、代码实现"><a href="#4、代码实现" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def bubbleSort(arr):    for i in range(len(arr)-1):         # 循环第 i 趟        for j in range(len(arr)-i-1):   # j 为下标            if arr[j] &gt; arr[j+1]:       # 如果这个数大于后面的数就交换两者的位置                arr[j], arr[j+1] = arr[j+1], arr[j]    return arr</code></pre><p>冒泡排序还有一种优化算法，就是立一个 flag，当某一趟序列遍历中元素没有发生交换，则证明该序列已经有序，就不再进行后续的排序。动画演示里就是改进后的算法，改进后的代码如下：</p><pre><code class="python">def bubbleSort(arr):    for i in range(len(arr)-1):         # 循环第 i 趟    flag = False        for j in range(len(arr)-i-1):   # j 为下标            if arr[j] &gt; arr[j+1]:       # 如果这个数大于后面的数就交换两者的位置                arr[j], arr[j+1] = arr[j+1], arr[j]                flag = True        if not flag:            return    return arr</code></pre><p>冒泡排序最快的情况：当输入的数据是正序时；最慢的情况：当输入的数据是反序时。</p><h3 id="5、具体示例"><a href="#5、具体示例" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><p>未改进版本：</p><pre><code class="python">def bubble_sort(arr):    for i in range(len(arr)-1):         # 循环第 i 趟        for j in range(len(arr)-i-1):   # j 为下标            if arr[j] &gt; arr[j+1]:       # 如果这个数大于后面的数就交换两者的位置                arr[j], arr[j+1] = arr[j+1], arr[j]        print(arr)                      # 每一趟比较完了就打印一次arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]bubble_sort(arr)</code></pre><pre><code class="python">[3, 38, 5, 44, 15, 36, 26, 27, 2, 46, 4, 19, 47, 48, 50][3, 5, 38, 15, 36, 26, 27, 2, 44, 4, 19, 46, 47, 48, 50][3, 5, 15, 36, 26, 27, 2, 38, 4, 19, 44, 46, 47, 48, 50][3, 5, 15, 26, 27, 2, 36, 4, 19, 38, 44, 46, 47, 48, 50][3, 5, 15, 26, 2, 27, 4, 19, 36, 38, 44, 46, 47, 48, 50][3, 5, 15, 2, 26, 4, 19, 27, 36, 38, 44, 46, 47, 48, 50][3, 5, 2, 15, 4, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][3, 2, 5, 4, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</code></pre><p>改进版本：</p><pre><code class="python">def bubble_sort(arr):    for i in range(len(arr)-1):         # 循环第 i 趟        flag = False        for j in range(len(arr)-i-1):   # j 为下标            if arr[j] &gt; arr[j+1]:       # 如果这个数大于后面的数就交换两者的位置                arr[j], arr[j+1] = arr[j+1], arr[j]                flag = True        if not flag:            return        print(arr)                      # 每一趟比较完了就打印一次arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]bubble_sort(arr)</code></pre><pre><code class="python">[3, 38, 5, 44, 15, 36, 26, 27, 2, 46, 4, 19, 47, 48, 50][3, 5, 38, 15, 36, 26, 27, 2, 44, 4, 19, 46, 47, 48, 50][3, 5, 15, 36, 26, 27, 2, 38, 4, 19, 44, 46, 47, 48, 50][3, 5, 15, 26, 27, 2, 36, 4, 19, 38, 44, 46, 47, 48, 50][3, 5, 15, 26, 2, 27, 4, 19, 36, 38, 44, 46, 47, 48, 50][3, 5, 15, 2, 26, 4, 19, 27, 36, 38, 44, 46, 47, 48, 50][3, 5, 2, 15, 4, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][3, 2, 5, 4, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</code></pre><hr><h2 id="二、选择排序（Selection-Sort）"><a href="#二、选择排序（Selection-Sort）" class="headerlink" title="二、选择排序（Selection Sort）"></a><font color=#FF0000>二、选择排序（Selection Sort）</font></h2><h3 id="1、原理-1"><a href="#1、原理-1" class="headerlink" title="1、原理"></a>1、原理</h3><p>第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。可以理解为 一个 0 到 n-1 的迭代，每次向后查找选择一个最小的元素。选择排序是不稳定的排序方法。</p><p>假如有 10 个小盆友从左到右站成一排，个头不等。老师想让他们按照个头从低到高站好，我们从第一个开始，从头到尾找一个个头最小的小盆友，然后把它和第一个小盆友交换。 然后从第二个小盆友开始采取同样的策略，这样一圈下来小盆友就是有序的了。</p><h3 id="2、步骤-1"><a href="#2、步骤-1" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；</li><li><strong>②</strong> 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；</li><li><strong>③</strong> 重复步骤 <strong>②</strong>，直到所有元素均排序完毕。</li></ul><h3 id="3、动画演示-1"><a href="#3、动画演示-1" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/03%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="03选择排序"></p><h3 id="4、代码实现-1"><a href="#4、代码实现-1" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><p>Python 代码：</p><pre><code class="python">def selection_sort(arr):    for i in range(len(arr)-1):          # 循环第 i 趟        min_index = i                    # 记录最小数的下标        for j in range(i+1, len(arr)):   # j 为下标            if arr[j] &lt; arr[min_index]:  # 如果这个数小于记录的最小数，则更新最小数的下标                min_index = j        arr[i], arr[min_index] = arr[min_index], arr[i]  # 将 i 位置的数（已排序序列的末尾的数）和最小数进行交换    return arr</code></pre><h3 id="5、具体示例-1"><a href="#5、具体示例-1" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def selection_sort(arr):    for i in range(len(arr)-1):          # 循环第 i 趟        min_index = i                    # 记录最小数的下标        for j in range(i+1, len(arr)):   # j 为下标            if arr[j] &lt; arr[min_index]:  # 如果这个数小于记录的最小数，则更新最小数的下标                min_index = j        arr[i], arr[min_index] = arr[min_index], arr[i]  # 将 i 位置的数（已排序序列的末尾的数）和最小数进行交换        print(arr)                       # 每一趟比较完了就打印一次arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]selection_sort(arr)</code></pre><pre><code class="python">[2, 44, 38, 5, 47, 15, 36, 26, 27, 3, 46, 4, 19, 50, 48][2, 3, 38, 5, 47, 15, 36, 26, 27, 44, 46, 4, 19, 50, 48][2, 3, 4, 5, 47, 15, 36, 26, 27, 44, 46, 38, 19, 50, 48][2, 3, 4, 5, 47, 15, 36, 26, 27, 44, 46, 38, 19, 50, 48][2, 3, 4, 5, 15, 47, 36, 26, 27, 44, 46, 38, 19, 50, 48][2, 3, 4, 5, 15, 19, 36, 26, 27, 44, 46, 38, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 36, 27, 44, 46, 38, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 44, 46, 38, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 44, 46, 38, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 46, 44, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 50, 48][2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</code></pre><hr><h2 id="三、插入排序（Insertion-Sort）"><a href="#三、插入排序（Insertion-Sort）" class="headerlink" title="三、插入排序（Insertion Sort）"></a><font color=#FF0000>三、插入排序（Insertion Sort）</font></h2><h3 id="1、原理-2"><a href="#1、原理-2" class="headerlink" title="1、原理"></a>1、原理</h3><p>插入排序一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法。它的基本思想是将一个记录插入到已经排好序的有序表中，从而形成一个新的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素进行遍历，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。</p><p>插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。拿在左手上的牌总是排序好的，原来这些牌是桌子上牌堆中顶部的牌。</p><h3 id="2、步骤-2"><a href="#2、步骤-2" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 从第一个元素开始，该元素可以认为已经被排序；</li><li><strong>②</strong> 取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li><strong>③</strong> 如果该元素（已排序的）大于新元素，将该元素往右移到下一位置，重复该步骤，直到找到已排序的元素小于或者等于新元素的位置；</li><li><strong>④</strong> 将新元素插入到步骤 <strong>③</strong> 找到的位置的后面；</li><li><strong>⑤</strong> 重复步骤 <strong>②</strong> ~ <strong>④</strong>。</li></ul><h3 id="3、动画演示-2"><a href="#3、动画演示-2" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/04%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="04插入排序"></p><h3 id="4、代码实现-2"><a href="#4、代码实现-2" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def insertion_sort(arr):    for i in range(1, len(arr)):    # 将 i 看做摸到的牌的下标        tmp = arr[i]                # 将摸到的牌储存到 tmp        j = i-1                     # 将 j 看做手里的牌的下标        while j &gt;= 0 and arr[j] &gt; tmp:  # 如果手里的牌大于摸到的牌            arr[j+1] = arr[j]       # 将手里的牌往右移一个位置（将手里的牌赋值给下一个位置）            j -= 1                  # 将手里的牌的下标减 1，再次准备与摸到的牌进行比较        arr[j+1] = tmp              # 将摸到的牌插入到 j+1 位置    return arr</code></pre><h3 id="5、具体示例-2"><a href="#5、具体示例-2" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def insertion_sort(arr):    for i in range(1, len(arr)):    # 将 i 看做摸到的牌的下标        tmp = arr[i]                # 将摸到的牌储存到 tmp        j = i-1                     # 将 j 看做手里的牌的下标        while j &gt;= 0 and arr[j] &gt; tmp:  # 如果手里的牌大于摸到的牌            arr[j+1] = arr[j]       # 将手里的牌往右移一个位置（将手里的牌赋值给下一个位置）            j -= 1                  # 将手里的牌的下标减 1，再次准备与摸到的牌进行比较        arr[j+1] = tmp              # 将摸到的牌插入到 j+1 位置        print(arr)                  # 每一趟比较完了就打印一次arr = [0, 9, 8, 7, 1, 2, 3, 4, 5, 6]insertion_sort(arr)</code></pre><pre><code class="python">[0, 9, 8, 7, 1, 2, 3, 4, 5, 6]  # 手里第一张牌为 0，摸到 9，此时 i=1，j=0，0 比 9 小，将 9 插到索引 j+1=1 处。[0, 8, 9, 7, 1, 2, 3, 4, 5, 6]  # 手里的牌为 0，9，摸到 8，此时 i=2，j=1，9 比 8 大，将 9 右移一个位置，j-1=0，将 8 插到 j+1=1 处[0, 7, 8, 9, 1, 2, 3, 4, 5, 6][0, 1, 7, 8, 9, 2, 3, 4, 5, 6][0, 1, 2, 7, 8, 9, 3, 4, 5, 6][0, 1, 2, 3, 7, 8, 9, 4, 5, 6][0, 1, 2, 3, 4, 7, 8, 9, 5, 6][0, 1, 2, 3, 4, 5, 7, 8, 9, 6][0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><hr><h2 id="四、希尔排序（Shell-Sort）"><a href="#四、希尔排序（Shell-Sort）" class="headerlink" title="四、希尔排序（Shell Sort）"></a><font color=#FF0000>四、希尔排序（Shell Sort）</font></h2><h3 id="1、原理-3"><a href="#1、原理-3" class="headerlink" title="1、原理"></a>1、原理</h3><p>希尔排序是插入排序的一种更高效的改进版本，是一种分组插入排序算法，又称缩小增量排序（Diminishing Increment Sort），希尔排序是非稳定排序算法。该方法因 D.L.Shell 于 1959 年提出而得名。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h3 id="2、步骤-3"><a href="#2、步骤-3" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> n 为数组长度，首先取一个整数 <strong>d1=n/2</strong>，将元素分为 <strong>d1</strong> 个组，每组相邻量元素之间距离为 <strong>d1-1</strong>，在各组内进行直接插入排序；</li><li><strong>②</strong> 取第二个整数 <strong>d2=d1/2</strong>，重复步骤 <strong>①</strong> 分组排序过程，直到 <strong>di=1</strong>，即所有元素在同一组内进行直接插入排序。</li></ul><p>PS：希尔排序每趟并不使某些元素有序，而是使整体数据越来越接近有序；最后一趟排序使得所有数据有序。</p><h3 id="3、动画演示-3"><a href="#3、动画演示-3" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/05%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt="05希尔排序"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/06%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt="06希尔排序"></p><h3 id="4、代码实现-3"><a href="#4、代码实现-3" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def insertion_sort_gap(arr, gap):     # 将 gap 看做隔 gap 个距离摸一张牌，而不是依次按照顺序摸牌    for i in range(gap, len(arr)):    # 将 i 看做摸到的牌的下标        tmp = arr[i]                  # 将摸到的牌储存到 tmp        j = i-gap                     # 将 j 看做手里的牌的下标        while j &gt;= 0 and arr[j] &gt; tmp:  # 如果手里的牌大于摸到的牌            arr[j+gap] = arr[j]         # 将手里的牌往右移一个位置（将手里的牌赋值给下一个位置）            j -= gap                    # 将手里的牌的下标减 gap，再次准备与摸到的牌进行比较        arr[j+gap] = tmp                # 将摸到的牌插入到 j+gap 位置def shell_sort(arr):    d = len(arr) // 2                   # 第一次分组    while d &gt;= 1:        insertion_sort_gap(arr, d)      # 调用插入排序        d //= 2                         # 整除 2 后再次分组    return arr</code></pre><p>也可以不使用两个函数，写在一起即可：</p><pre><code class="python">def shell_sort(arr):    d = len(arr) // 2                   # 第一次分组    while d &gt;= 1:                       # 将 d 看做隔 d 个距离摸一张牌，而不是依次按照顺序摸牌        for i in range(d, len(arr)):    # 将 i 看做摸到的牌的下标            tmp = arr[i]                # 将摸到的牌储存到 tmp            j = i - d                   # 将 j 看做手里的牌的下标            while j &gt;= 0 and arr[j] &gt; tmp:   # 如果手里的牌大于摸到的牌                arr[j + d] = arr[j]          # 将手里的牌往右移一个位置（将手里的牌赋值给下一个位置）                j -= d                       # 将手里的牌的下标减 d，再次准备与摸到的牌进行比较            arr[j + d] = tmp                 # 将摸到的牌插入到 j+d 位置        d //= 2                              # 整除 2 后再次分组    return arr</code></pre><h3 id="5、具体示例-3"><a href="#5、具体示例-3" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def insertion_sort_gap(arr, gap):     # 将 gap 看做隔 gap 个距离摸一张牌，而不是依次按照顺序摸牌    for i in range(gap, len(arr)):    # 将 i 看做摸到的牌的下标        tmp = arr[i]                  # 将摸到的牌储存到 tmp        j = i-gap                     # 将 j 看做手里的牌的下标        while j &gt;= 0 and arr[j] &gt; tmp:  # 如果手里的牌大于摸到的牌            arr[j+gap] = arr[j]         # 将手里的牌往右移一个位置（将手里的牌赋值给下一个位置）            j -= gap                    # 将手里的牌的下标减 gap，再次准备与摸到的牌进行比较        arr[j+gap] = tmp                # 将摸到的牌插入到 j+gap 位置def shell_sort(arr):    d = len(arr) // 2                   # 第一次分组    while d &gt;= 1:        insertion_sort_gap(arr, d)      # 调用插入排序        print(arr)                      # 每一轮排序后打印一次        d //= 2                         # 整除 2 后再次分组arr = [5, 7, 4, 6, 3, 1, 2, 9, 8]shell_sort(arr)</code></pre><pre><code class="python">[3, 1, 2, 6, 5, 7, 4, 9, 8][2, 1, 3, 6, 4, 7, 5, 9, 8][1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><pre><code class="python">def shell_sort(arr):    d = len(arr) // 2                   # 第一次分组    while d &gt;= 1:                       # 将 d 看做隔 d 个距离摸一张牌，而不是依次按照顺序摸牌        for i in range(d, len(arr)):    # 将 i 看做摸到的牌的下标            tmp = arr[i]                # 将摸到的牌储存到 tmp            j = i - d                   # 将 j 看做手里的牌的下标            while j &gt;= 0 and arr[j] &gt; tmp:   # 如果手里的牌大于摸到的牌                arr[j + d] = arr[j]          # 将手里的牌往右移一个位置（将手里的牌赋值给下一个位置）                j -= d                       # 将手里的牌的下标减 d，再次准备与摸到的牌进行比较            arr[j + d] = tmp                 # 将摸到的牌插入到 j+d 位置        print(arr)                           # 每一轮排序后打印一次        d //= 2                              # 整除 2 后再次分组arr = [5, 7, 4, 6, 3, 1, 2, 9, 8]shell_sort(arr)</code></pre><pre><code class="python">[3, 1, 2, 6, 5, 7, 4, 9, 8][2, 1, 3, 6, 4, 7, 5, 9, 8][1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><hr><h2 id="五、归并排序（Merge-Sort）"><a href="#五、归并排序（Merge-Sort）" class="headerlink" title="五、归并排序（Merge Sort）"></a><font color=#FF0000>五、归并排序（Merge Sort）</font></h2><h3 id="1、原理-4"><a href="#1、原理-4" class="headerlink" title="1、原理"></a>1、原理</h3><p>归并的概念：假设一个列表分为两段，其中每一段都是有序列表，现在将该两段合并为一个有序列表，这种操作称为一次归并。</p><p>归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/08.png" alt="08"></p><h3 id="2、步骤-4"><a href="#2、步骤-4" class="headerlink" title="2、步骤"></a>2、步骤</h3><p><font color=#ff0000><strong>归并的基本步骤：</strong></font></p><ul><li><strong>①</strong> 申请空间，使其大小为<strong>两个已经排序序列之和</strong>，该空间用来存放合并后的序列；</li><li><strong>②</strong> 设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li><strong>③</strong> 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li><strong>④</strong> 重复步骤 <strong>③</strong> 直到某一指针达到序列尾；</li><li><strong>⑤</strong> 将另一序列剩下的所有元素直接复制到合并序列尾。</li></ul><p><font color=#ff0000><strong>归并排序的步骤：</strong></font></p><ul><li><strong>①</strong> 分解：将列表越分越小，直至分成一个元素，终止条件：一个元素是有序的。</li><li><strong>②</strong> 合并：不断将两个有序列表进行归并，列表越来越大，直到所有序列归并完毕。</li></ul><h3 id="3、动画演示-4"><a href="#3、动画演示-4" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/07%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="07归并排序"></p><h3 id="4、代码实现-4"><a href="#4、代码实现-4" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def merge(arr, low, mid, high):    # low 和 high 为整个数组的第一个和最后一个位置索引，mid 为中间位置索引    # i 和 j 为指针，最初位置分别为两个有序序列的起始位置    # ltmp 用来存放合并后的序列    i = low    j = mid+1    ltmp = []    while i &lt;= mid and j &lt;= high:  # 只要左右两边都有数        if arr[i] &lt; arr[j]:        # 当左边的数小于右边的数            ltmp.append(arr[i])    # 将左边的数存入 ltmp            i += 1                 # 左边的指针往右移一位        else:                      # 当右边的数小于左边的数            ltmp.append(arr[j])    # 将右边的数存入 ltmp            j += 1                 # 右边的指针往右移一位    # 上面的 while 语句执行完后，左边或者右边没有数了    while i &lt;= mid:                # 当左边还有数的时候        ltmp.append(arr[i])        # 将左边剩下的数全部存入 ltmp        i += 1    while j &lt;= high:               # 当右边还有数的时候        ltmp.append(arr[j])        # 将右边剩下的数全部存入 ltmp        j += 1    arr[low:high+1] = ltmp         # 将排序后的数组写回原数组def merge_sort(arr, low, high):       # low 和 high 为整个数组的第一个和最后一个位置索引    if low &lt; high:                    # 至少有两个元素        mid = (low + high) // 2        merge_sort(arr, low, mid)     # 把左边递归分解        merge_sort(arr, mid+1, high)  # 把右边递归分解        merge(arr, low, mid, high)    # 做归并</code></pre><h3 id="5、具体示例-4"><a href="#5、具体示例-4" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def merge(arr, low, mid, high):    # low 和 high 为整个数组的第一个和最后一个位置索引，mid 为中间位置索引    # i 和 j 为指针，最初位置分别为两个有序序列的起始位置    # ltmp 用来存放合并后的序列    i = low    j = mid+1    ltmp = []    while i &lt;= mid and j &lt;= high:  # 只要左右两边都有数        if arr[i] &lt; arr[j]:        # 当左边的数小于右边的数            ltmp.append(arr[i])    # 将左边的数存入 ltmp            i += 1                 # 左边的指针往右移一位        else:                      # 当右边的数小于左边的数            ltmp.append(arr[j])    # 将右边的数存入 ltmp            j += 1                 # 右边的指针往右移一位    # 上面的 while 语句执行完后，左边或者右边没有数了    while i &lt;= mid:                # 当左边还有数的时候        ltmp.append(arr[i])        # 将左边剩下的数全部存入 ltmp        i += 1    while j &lt;= high:               # 当右边还有数的时候        ltmp.append(arr[j])        # 将右边剩下的数全部存入 ltmp        j += 1    arr[low:high+1] = ltmp         # 将排序后的数组写回原数组def merge_sort(arr, low, high):       # low 和 high 为整个数组的第一个和最后一个位置索引    if low &lt; high:                    # 至少有两个元素        mid = (low + high) // 2        merge_sort(arr, low, mid)     # 把左边递归分解        merge_sort(arr, mid+1, high)  # 把右边递归分解        merge(arr, low, mid, high)    # 做归并        print(arr)                    # 每一次归并打印一次arr = [7, 1, 3, 2, 6, 9, 4]merge_sort(arr, 0, len(arr)-1)</code></pre><pre><code class="python">[1, 7, 3, 2, 6, 9, 4][1, 7, 2, 3, 6, 9, 4][1, 2, 3, 7, 6, 9, 4][1, 2, 3, 7, 6, 9, 4][1, 2, 3, 7, 4, 6, 9][1, 2, 3, 4, 6, 7, 9]</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/108987300未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="六、快速排序（Quick-Sort）"><a href="#六、快速排序（Quick-Sort）" class="headerlink" title="六、快速排序（Quick Sort）"></a><font color=#FF0000>六、快速排序（Quick Sort）</font></h2><h3 id="1、原理-5"><a href="#1、原理-5" class="headerlink" title="1、原理"></a>1、原理</h3><p>快速排序是对冒泡排序的一种改进。顾名思义快速排序就是快，而且效率高！它是处理大数据最快的排序算法之一了。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h3 id="2、步骤-5"><a href="#2、步骤-5" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 从数列中挑出一个元素，称为 “基准值”;</li><li><strong>②</strong> 重新排序数列，所有元素比基准值小的放在基准值的左边，比基准值大的放在基准值的右边（相同的数可以到任一边）。在这个分区退出之后，该基准值就处于数列的中间位置。这个称为分区（partition）操作，也可以称为一次归位操作，归位操作的过程见下动图；</li><li><strong>③</strong> 递归地把小于基准值元素的子数列和大于基准值元素的子数列按照步骤 <strong>① ②</strong> 排序。</li></ul><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/09%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="09快速排序"></p><h3 id="3、动画演示-5"><a href="#3、动画演示-5" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/10%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="10快速排序"></p><h3 id="4、代码实现-5"><a href="#4、代码实现-5" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def partition(arr, left, right):    # 归位操作，left，right 分别为数组左边和右边的位置索引    tmp = arr[left]    while left &lt; right:        while left &lt; right and arr[right] &gt;= tmp:  # 从右边找比 tmp 小的数，如果比 tmp 大，则移动指针            right -= 1                             # 将指针左移一个位置        arr[left] = arr[right]                     # 将右边的值写到左边的空位上        while left &lt; right and arr[left] &lt;= tmp:   # 从左边找比 tmp 大的数，如果比 tmp 小，则移动指针            left += 1                              # 将指针右移一个位置        arr[right] = arr[left]                     # 将左边的值写到右边的空位上    arr[left] = tmp                                # 把 tmp 归位    return left                   # 返回 left，right 都可以，目的是便于后面的递归操作对左右两部分进行排序def quick_sort(arr, left, right):          # 快速排序    if left &lt; right:        mid = partition(arr, left, right)        quick_sort(arr, left, mid-1)       # 对左半部分进行归位操作        quick_sort(arr, mid+1, right)      # 对右半部分进行归位操作    return arr</code></pre><h3 id="5、具体示例-5"><a href="#5、具体示例-5" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def partition(arr, left, right):    # 归位操作，left，right 分别为数组左边和右边的位置索引    tmp = arr[left]    while left &lt; right:        while left &lt; right and arr[right] &gt;= tmp:  # 从右边找比 tmp 小的数，如果比 tmp 大，则移动指针            right -= 1                             # 将指针左移一个位置        arr[left] = arr[right]                     # 将右边的值写到左边的空位上        while left &lt; right and arr[left] &lt;= tmp:   # 从左边找比 tmp 大的数，如果比 tmp 小，则移动指针            left += 1                              # 将指针右移一个位置        arr[right] = arr[left]                     # 将左边的值写到右边的空位上    arr[left] = tmp                                # 把 tmp 归位    return left                   # 返回 left，right 都可以，目的是便于后面的递归操作对左右两部分进行排序def quick_sort(arr, left, right):    if left &lt; right:        mid = partition(arr, left, right)        print(arr)                         # 每次归位后打印一次        quick_sort(arr, left, mid-1)       # 对左半部分进行归位操作        quick_sort(arr, mid+1, right)      # 对右半部分进行归位操作arr = [5, 7, 4, 6, 3, 1, 2, 9, 8]quick_sort(arr, 0, len(arr)-1)</code></pre><pre><code class="python">[2, 1, 4, 3, 5, 6, 7, 9, 8][1, 2, 4, 3, 5, 6, 7, 9, 8][1, 2, 3, 4, 5, 6, 7, 9, 8][1, 2, 3, 4, 5, 6, 7, 9, 8][1, 2, 3, 4, 5, 6, 7, 9, 8][1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><hr><h2 id="七、堆排序（Heap-Sort）"><a href="#七、堆排序（Heap-Sort）" class="headerlink" title="七、堆排序（Heap Sort）"></a><font color=#FF0000>七、堆排序（Heap Sort）</font></h2><h3 id="1、原理-6"><a href="#1、原理-6" class="headerlink" title="1、原理"></a>1、原理</h3><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><ul><li>堆：一种特殊的完全二叉树结构</li><li>大根堆：一棵完全二叉树，满足任一节点都比其孩子节点大</li><li>小根堆：一棵完全二叉树，满足任一节点都比其孩子节点小</li></ul><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/11%E5%A0%86%E6%8E%92%E5%BA%8F.png" alt="11堆排序"></p><h3 id="2、步骤-6"><a href="#2、步骤-6" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li>① 构建堆：将待排序序列构建成一个堆 H[0……n-1]，从最后一个非叶子结点开始，从左至右，从下至上进行调整。根据升序或降序需求选择大顶堆或小顶堆；</li><li>② 此时的堆顶元素，为最大或者最小元素；</li><li>③ 把堆顶元素和堆尾元素互换，调整堆，重新使堆有序；</li><li>④ 此时堆顶元素为第二大元素；</li><li>⑤ 重复以上步骤，直到堆变空。</li></ul><h3 id="3、动画演示-6"><a href="#3、动画演示-6" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/12%E6%9E%84%E5%BB%BA%E5%A0%86.gif" alt="12构建堆"></p><p>堆构建完成后再进行推排序：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/13%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="13堆排序"></p><h3 id="4、代码实现-6"><a href="#4、代码实现-6" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def sift(arr, low, high):    &quot;&quot;&quot;    :param li: 列表    :param low: 堆的根节点位置    :param high: 堆的最后一个元素的位置    &quot;&quot;&quot;    i = low                 # i最开始指向根节点    j = 2 * i + 1           # j开始是左孩子    tmp = arr[low]          # 把堆顶存起来    while j &lt;= high:        # 只要j位置有数        if j + 1 &lt;= high and arr[j+1] &gt; arr[j]:   # 如果右孩子有并且比较大            j = j + 1       # j指向右孩子        if arr[j] &gt; tmp:            arr[i] = arr[j]            i = j           # 往下看一层            j = 2 * i + 1        else:               # tmp更大，把tmp放到i的位置上            arr[i] = tmp    # 把tmp放到某一级领导位置上            break    else:        arr[i] = tmp        # 把tmp放到叶子节点上def heap_sort(arr):    n = len(arr)    for i in range((n-2)//2, -1, -1):   # i表示建堆的时候调整的部分的根的下标        sift(arr, i, n-1)    # 建堆完成    for i in range(n-1, -1, -1):        # i 指向当前堆的最后一个元素        arr[0], arr[i] = arr[i], arr[0]        sift(arr, 0, i - 1)             # i-1是新的high    return arr</code></pre><h3 id="5、具体示例-6"><a href="#5、具体示例-6" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def sift(arr, low, high):    &quot;&quot;&quot;    :param li: 列表    :param low: 堆的根节点位置    :param high: 堆的最后一个元素的位置    &quot;&quot;&quot;    i = low                 # i最开始指向根节点    j = 2 * i + 1           # j开始是左孩子    tmp = arr[low]          # 把堆顶存起来    while j &lt;= high:        # 只要j位置有数        if j + 1 &lt;= high and arr[j+1] &gt; arr[j]:   # 如果右孩子有并且比较大            j = j + 1       # j指向右孩子        if arr[j] &gt; tmp:            arr[i] = arr[j]            i = j           # 往下看一层            j = 2 * i + 1        else:               # tmp更大，把tmp放到i的位置上            arr[i] = tmp    # 把tmp放到某一级领导位置上            break    else:        arr[i] = tmp        # 把tmp放到叶子节点上def heap_sort(arr):    n = len(arr)    print(&#39;建堆过程：&#39;)    print(arr)    for i in range((n-2)//2, -1, -1):   # i表示建堆的时候调整的部分的根的下标        sift(arr, i, n-1)        print(arr)    # 建堆完成    print(&#39;堆排序过程：&#39;)    print(arr)    for i in range(n-1, -1, -1):        # i 指向当前堆的最后一个元素        arr[0], arr[i] = arr[i], arr[0]        sift(arr, 0, i - 1)             # i-1是新的high        print(arr)arr = [2, 7, 26, 25, 19, 17, 1, 90, 3, 36]heap_sort(arr)</code></pre><pre><code class="python">建堆过程：[2, 7, 26, 25, 19, 17, 1, 90, 3, 36][2, 7, 26, 25, 36, 17, 1, 90, 3, 19][2, 7, 26, 90, 36, 17, 1, 25, 3, 19][2, 7, 26, 90, 36, 17, 1, 25, 3, 19][2, 90, 26, 25, 36, 17, 1, 7, 3, 19][90, 36, 26, 25, 19, 17, 1, 7, 3, 2]堆排序过程：[90, 36, 26, 25, 19, 17, 1, 7, 3, 2][36, 25, 26, 7, 19, 17, 1, 2, 3, 90][26, 25, 17, 7, 19, 3, 1, 2, 36, 90][25, 19, 17, 7, 2, 3, 1, 26, 36, 90][19, 7, 17, 1, 2, 3, 25, 26, 36, 90][17, 7, 3, 1, 2, 19, 25, 26, 36, 90][7, 2, 3, 1, 17, 19, 25, 26, 36, 90][3, 2, 1, 7, 17, 19, 25, 26, 36, 90][2, 1, 3, 7, 17, 19, 25, 26, 36, 90][1, 2, 3, 7, 17, 19, 25, 26, 36, 90][1, 2, 3, 7, 17, 19, 25, 26, 36, 90]</code></pre><hr><h2 id="八、计数排序（Counting-Sort）"><a href="#八、计数排序（Counting-Sort）" class="headerlink" title="八、计数排序（Counting Sort）"></a><font color=#FF0000>八、计数排序（Counting Sort）</font></h2><h3 id="1、原理-7"><a href="#1、原理-7" class="headerlink" title="1、原理"></a>1、原理</h3><p>计数排序是一个非基于比较的排序算法，它的优势在于在对一定范围内的整数排序时，它的复杂度为 Ο(n+k)，其中 k 是整数的范围，快于任何比较排序算法。计数排序是一种牺牲空间换取时间的做法。计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，<strong>计数排序要求输入的数据必须是有确定范围的整数。</strong></p><h3 id="2、步骤-7"><a href="#2、步骤-7" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 找到待排序列表中的最大值 k，开辟一个长度为 k+1 的计数列表，计数列表中的值都为 0。</li><li><strong>②</strong> 遍历待排序列表，如果遍历到的元素值为 i，则计数列表中索引 i 的值加1。</li><li><strong>③</strong> 遍历完整个待排序列表，计数列表中索引 i 的值 j 表示 i 的个数为 j，统计出待排序列表中每个值的数量。</li><li><strong>④</strong> 创建一个新列表（也可以清空原列表，在原列表中添加），遍历计数列表，依次在新列表中添加 j 个 i，新列表就是排好序后的列表，整个过程没有比较待排序列表中的数据大小。</li></ul><h3 id="3、动画演示-7"><a href="#3、动画演示-7" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/14%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="14计数排序"></p><h3 id="4、代码实现-7"><a href="#4、代码实现-7" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def count_sort(arr):    if len(arr) &lt; 2:                       # 如果数组长度小于 2 则直接返回        return arr    max_num = max(arr)    count = [0 for _ in range(max_num+1)]  # 开辟一个计数列表    for val in arr:        count[val] += 1    arr.clear()                        # 原数组清空    for ind, val in enumerate(count):  # 遍历值和下标（值的数量）        for i in range(val):            arr.append(ind)    return arr</code></pre><h3 id="5、具体示例-7"><a href="#5、具体示例-7" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def count_sort(arr):    if len(arr) &lt; 2:                       # 如果数组长度小于 2 则直接返回        return arr    max_num = max(arr)    count = [0 for _ in range(max_num+1)]  # 开辟一个计数列表    for val in arr:        count[val] += 1    arr.clear()                        # 原数组清空    for ind, val in enumerate(count):  # 遍历值和下标（值的数量）        for i in range(val):            arr.append(ind)    return arrarr = [2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2]sorted_arr = count_sort(arr)print(sorted_arr)</code></pre><pre><code class="python">[1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]</code></pre><hr><h2 id="九、桶排序（Bucket-Sort）"><a href="#九、桶排序（Bucket-Sort）" class="headerlink" title="九、桶排序（Bucket Sort）"></a><font color=#FF0000>九、桶排序（Bucket Sort）</font></h2><h3 id="1、原理-8"><a href="#1、原理-8" class="headerlink" title="1、原理"></a>1、原理</h3><p>桶排序又叫箱排序，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。</p><p>桶排序也是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ul><li>在额外空间充足的情况下，尽量增大桶的数量；</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中。</li></ul><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><ul><li>最快情况：当输入的数据可以均匀的分配到每一个桶中；</li><li>最慢情况：当输入的数据被分配到了同一个桶中。</li></ul><h3 id="2、步骤-8"><a href="#2、步骤-8" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 创建一个定量的数组当作空桶子；</li><li><strong>②</strong> 遍历序列，把元素一个一个放到对应的桶子去；</li><li><strong>③</strong> 对每个不是空的桶子进行排序；</li><li><strong>④</strong> 从不是空的桶子里把元素再放回原来的序列中。</li></ul><h3 id="3、动画演示-8"><a href="#3、动画演示-8" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p>（动图来源于@五分钟学算法，侵删）</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/15%E6%A1%B6%E6%8E%92%E5%BA%8F.gif" alt="15桶排序"></p><h3 id="4、代码实现-8"><a href="#4、代码实现-8" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def bucket_sort(arr):    max_num = max(arr)    n = len(arr)    buckets = [[] for _ in range(n)]         # 创建桶    for var in arr:        i = min(var // (max_num // n), n-1)  # i 表示 var 放到几号桶里        buckets[i].append(var)               # 把 var 加到桶里边        # 保持桶内的顺序        for j in range(len(buckets[i])-1, 0, -1):            if buckets[i][j] &lt; buckets[i][j-1]:                buckets[i][j], buckets[i][j-1] = buckets[i][j-1], buckets[i][j]            else:                break    sorted_arr = []    for buc in buckets:        sorted_arr.extend(buc)    return sorted_arr</code></pre><h3 id="5、具体示例-8"><a href="#5、具体示例-8" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def bucket_sort(arr):    max_num = max(arr)    n = len(arr)    buckets = [[] for _ in range(n)]         # 创建桶    for var in arr:        i = min(var // (max_num // n), n-1)  # i 表示 var 放到几号桶里        buckets[i].append(var)               # 把 var 加到桶里边        # 保持桶内的顺序        for j in range(len(buckets[i])-1, 0, -1):            if buckets[i][j] &lt; buckets[i][j-1]:                buckets[i][j], buckets[i][j-1] = buckets[i][j-1], buckets[i][j]            else:                break    sorted_arr = []    for buc in buckets:        sorted_arr.extend(buc)    return sorted_arrarr = [7, 12, 56, 23, 19, 33, 35, 42, 42, 2, 8, 22, 39, 26, 17]sorted_arr = bucket_sort(arr)print(sorted_arr)</code></pre><pre><code class="python">[2, 7, 8, 12, 17, 19, 22, 23, 26, 33, 35, 39, 42, 42, 56]</code></pre><hr><h2 id="十、基数排序（Radix-Sort）"><a href="#十、基数排序（Radix-Sort）" class="headerlink" title="十、基数排序（Radix Sort）"></a><font color=#FF0000>十、基数排序（Radix Sort）</font></h2><h3 id="1、原理-9"><a href="#1、原理-9" class="headerlink" title="1、原理"></a>1、原理</h3><p>基数排序属于分配式排序，是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p>基数排序、计数排序、桶排序三种排序算法都利用了桶的概念，但对桶的使用方法上是有明显差异的：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值。</li></ul><h3 id="2、步骤-9"><a href="#2、步骤-9" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>①</strong> 取数组中的最大数，并取得位数；</li><li><strong>②</strong> 从最低位开始，依次进行一次排序；</li><li><strong>③</strong> 从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li></ul><h3 id="3、动画演示-9"><a href="#3、动画演示-9" class="headerlink" title="3、动画演示"></a>3、动画演示</h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A91/16%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="16基数排序"></p><h3 id="4、代码实现-9"><a href="#4、代码实现-9" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><pre><code class="python">def radix_sort(li):    max_num = max(li)      # 最大值 9-&gt;1次循环, 99-&gt;2次循环, 888-&gt;3次循环, 10000-&gt;5次循环    it = 0    while 10 ** it &lt;= max_num:        buckets = [[] for _ in range(10)]        for var in li:            # var=987, it=1, 987//10-&gt;98, 98%10-&gt;8; it=2, 987//100-&gt;9, 9%10=9            digit = (var // 10 ** it) % 10   # 依次取一位数            buckets[digit].append(var)        # 分桶完成        li.clear()        for buc in buckets:            li.extend(buc)        it += 1            # 把数重新写回 li    return arr</code></pre><h3 id="5、具体示例-9"><a href="#5、具体示例-9" class="headerlink" title="5、具体示例"></a>5、具体示例</h3><pre><code class="python">def radix_sort(li):    max_num = max(li)      # 最大值 9-&gt;1次循环, 99-&gt;2次循环, 888-&gt;3次循环, 10000-&gt;5次循环    it = 0    while 10 ** it &lt;= max_num:        buckets = [[] for _ in range(10)]        for var in li:            # var=987, it=1, 987//10-&gt;98, 98%10-&gt;8; it=2, 987//100-&gt;9, 9%10=9            digit = (var // 10 ** it) % 10   # 依次取一位数            buckets[digit].append(var)        # 分桶完成        li.clear()        for buc in buckets:            li.extend(buc)        it += 1            # 把数重新写回 li    return arrarr = [3221, 1, 10, 9680, 577, 9420, 7, 5622, 4793, 2030, 3138, 82, 2599, 743, 4127]sorted_arr = radix_sort(arr)print(sorted_arr)</code></pre><pre><code class="python">[1, 7, 10, 82, 577, 743, 2030, 2599, 3138, 3221, 4127, 4793, 5622, 9420, 9680]</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/108987300未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>COVID-19 肺炎疫情数据实时监控（python 爬虫 + pyecharts 数据可视化 + wordcloud 词云图）</title>
      <link href="/article/035/"/>
      <url>/article/035/</url>
      
        <content type="html"><![CDATA[<pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/107140534未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】前言"><a href="#【1x00】前言" class="headerlink" title="【1x00】前言"></a><font color=#FF0000>【1x00】前言</font></h2><p>本来两三个月之前就想搞个疫情数据实时数据展示的，由于各种不可抗拒因素一而再再而三的鸽了，最近终于抽空写了一个，数据是用 Python 爬取的<a href="https://voice.baidu.com/act/newpneumonia/newpneumonia/">百度疫情实时大数据报告</a>，请求库用的 requests，解析用的 Xpath 语法，词云用的 wordcloud 库，数据可视化用 pyecharts 绘制的地图和折线图，数据储存在 Excel 表格里面，使用 openpyxl 对表格进行处理。</p><p>本程序实现了累计确诊地图展示和每日数据变化折线图展示，其他更多数据的获取和展示均可在程序中进行拓展，可以将程序部署在服务器上，设置定时运行，即可实时展示数据，pyecharts 绘图模块也可以整合到 Web 框架（Django、Flask等）中使用。</p><p>在获取数据时有<font color=#FF0000><strong>全球</strong></font>和<font color=#FF0000><strong>境外</strong></font>两个概念，全球包含中国，境外不包含中国，后期绘制的四个图：中国累计确诊地图、全球累计确诊地图（包含中国）、中国每日数据折线图、境外每日数据折线图（不包含中国）。</p><p><font color=#FF0000><strong>注意项：直接向该网页发送请求获取的响应中，没有每个国家的每日数据，该数据获取的地址是：<a href="https://voice.baidu.com/newpneumonia/get?target=trend&isCaseIn=1&stage=publish">https://voice.baidu.com/newpneumonia/get?target=trend&amp;isCaseIn=1&amp;stage=publish</a></strong></font></p><ul><li><strong>预览地址</strong>：<del><a href="http://cov.itrhx.com/">http://cov.itrhx.com/</a></del>（已失效）</li><li><strong>数据来源</strong>：<a href="https://voice.baidu.com/act/newpneumonia/newpneumonia/">https://voice.baidu.com/act/newpneumonia/newpneumonia/</a></li><li><strong>pyecharts 文档</strong>：<a href="https://pyecharts.org/">https://pyecharts.org/</a></li><li><strong>openpyxl 文档</strong>：<a href="https://openpyxl.readthedocs.io/">https://openpyxl.readthedocs.io/</a></li><li><strong>wordcloud 文档</strong>：<a href="http://amueller.github.io/word_cloud/">http://amueller.github.io/word_cloud/</a></li></ul><h2 id="【2x00】思维导图"><a href="#【2x00】思维导图" class="headerlink" title="【2x00】思维导图"></a><font color=#FF0000>【2x00】思维导图</font></h2><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/01.png" alt="01"></p><h2 id="【3x00】数据结构分析"><a href="#【3x00】数据结构分析" class="headerlink" title="【3x00】数据结构分析"></a><font color=#FF0000>【3x00】数据结构分析</font></h2><p>通过查看百度的疫情数据页面，可以看到很多整齐的数据，猜测就是疫情相关的数据，保存该页面，对其进行格式化，很容易可以分析出所有的数据都在 <code>&lt;script type=&quot;application/json&quot; id=&quot;captain-config&quot;&gt;&lt;/script&gt;</code> 里面，其中 title 里面是一些 Unicode 编码，将其转为中文后更容易得到不同的分类数据。</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/02.png" alt="02"></p><p>由于数据繁多，可以将数据主体部分提取出来，删除一些重复项和其他杂项，留下数据大体位置并分析数据结构，便于后期的数据提取，经过处理后的数据大致结构如下：</p><pre><code class="json">&lt;script type=&quot;application/json&quot; id=&quot;captain-config&quot;&gt;    &#123;        &quot;component&quot;: [            &#123;                &quot;mapLastUpdatedTime&quot;: &quot;2020.07.05 16:13&quot;,        // 国内疫情数据最后更新时间                &quot;caseList&quot;: [                                    // caseList 列表，每一个元素是一个字典                    &#123;                        &quot;confirmed&quot;: &quot;1&quot;,                        // 每个字典包含中国每个省的每一项疫情数据                        &quot;died&quot;: &quot;0&quot;,                        &quot;crued&quot;: &quot;1&quot;,                        &quot;relativeTime&quot;: &quot;1593792000&quot;,                        &quot;confirmedRelative&quot;: &quot;0&quot;,                        &quot;diedRelative&quot;: &quot;0&quot;,                        &quot;curedRelative&quot;: &quot;0&quot;,                        &quot;curConfirm&quot;: &quot;0&quot;,                        &quot;curConfirmRelative&quot;: &quot;0&quot;,                        &quot;icuDisable&quot;: &quot;1&quot;,                        &quot;area&quot;: &quot;西藏&quot;,                        &quot;subList&quot;: [                            // subList 列表，每一个元素是一个字典                            &#123;                                &quot;city&quot;: &quot;拉萨&quot;,                 // 每个字典包含该省份对应的每个城市疫情数据                                &quot;confirmed&quot;: &quot;1&quot;,                                &quot;died&quot;: &quot;0&quot;,                                &quot;crued&quot;: &quot;1&quot;,                                &quot;confirmedRelative&quot;: &quot;0&quot;,                                &quot;curConfirm&quot;: &quot;0&quot;,                                &quot;cityCode&quot;: &quot;100&quot;                            &#125;                        ]                    &#125;                ],                &quot;caseOutsideList&quot;: [                           // caseOutsideList 列表，每一个元素是一个字典                    &#123;                        &quot;confirmed&quot;: &quot;241419&quot;,                 // 每个字典包含各国的每一项疫情数据                        &quot;died&quot;: &quot;34854&quot;,                        &quot;crued&quot;: &quot;191944&quot;,                        &quot;relativeTime&quot;: &quot;1593792000&quot;,                        &quot;confirmedRelative&quot;: &quot;223&quot;,                        &quot;curConfirm&quot;: &quot;14621&quot;,                        &quot;icuDisable&quot;: &quot;1&quot;,                        &quot;area&quot;: &quot;意大利&quot;,                        &quot;subList&quot;: [                          // subList 列表，每一个元素是一个字典                            &#123;                                &quot;city&quot;: &quot;伦巴第&quot;,              // 每个字典包含每个国家对应的每个城市疫情数据                                &quot;confirmed&quot;: &quot;94318&quot;,                                &quot;died&quot;: &quot;16691&quot;,                                &quot;crued&quot;: &quot;68201&quot;,                                &quot;curConfirm&quot;: &quot;9426&quot;                            &#125;                        ]                    &#125;                ],                &quot;summaryDataIn&quot;: &#123;                           // summaryDataIn 国内总的疫情数据                    &quot;confirmed&quot;: &quot;85307&quot;,                    &quot;died&quot;: &quot;4648&quot;,                    &quot;cured&quot;: &quot;80144&quot;,                    &quot;asymptomatic&quot;: &quot;99&quot;,                    &quot;asymptomaticRelative&quot;: &quot;7&quot;,                    &quot;unconfirmed&quot;: &quot;7&quot;,                    &quot;relativeTime&quot;: &quot;1593792000&quot;,                    &quot;confirmedRelative&quot;: &quot;19&quot;,                    &quot;unconfirmedRelative&quot;: &quot;1&quot;,                    &quot;curedRelative&quot;: &quot;27&quot;,                    &quot;diedRelative&quot;: &quot;0&quot;,                    &quot;icu&quot;: &quot;6&quot;,                    &quot;icuRelative&quot;: &quot;0&quot;,                    &quot;overseasInput&quot;: &quot;1931&quot;,                    &quot;unOverseasInputCumulative&quot;: &quot;83375&quot;,                    &quot;overseasInputRelative&quot;: &quot;6&quot;,                    &quot;unOverseasInputNewAdd&quot;: &quot;13&quot;,                    &quot;curConfirm&quot;: &quot;515&quot;,                    &quot;curConfirmRelative&quot;: &quot;-8&quot;,                    &quot;icuDisable&quot;: &quot;1&quot;                &#125;,                &quot;summaryDataOut&quot;: &#123;                           // summaryDataOut 国外总的疫情数据                    &quot;confirmed&quot;: &quot;11302569&quot;,                    &quot;died&quot;: &quot;528977&quot;,                    &quot;curConfirm&quot;: &quot;4410601&quot;,                    &quot;cured&quot;: &quot;6362991&quot;,                    &quot;confirmedRelative&quot;: &quot;206165&quot;,                    &quot;curedRelative&quot;: &quot;190018&quot;,                    &quot;diedRelative&quot;: &quot;4876&quot;,                    &quot;curConfirmRelative&quot;: &quot;11271&quot;,                    &quot;relativeTime&quot;: &quot;1593792000&quot;                &#125;,                &quot;trend&quot;: &#123;                                    // trend 字典，包含国内每日的疫情数据                    &quot;updateDate&quot;: [],                         // 日期                    &quot;list&quot;: [                                 // list 列表，每项数据及其对应的值                        &#123;                            &quot;name&quot;: &quot;确诊&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;疑似&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;治愈&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;死亡&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;新增确诊&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;新增疑似&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;新增治愈&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;新增死亡&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;累计境外输入&quot;,                            &quot;data&quot;: []                        &#125;,                        &#123;                            &quot;name&quot;: &quot;新增境外输入&quot;,                            &quot;data&quot;: []                        &#125;                    ]                &#125;,                &quot;foreignLastUpdatedTime&quot;: &quot;2020.07.05 16:13&quot;,       // 国外疫情数据最后更新时间                &quot;globalList&quot;: [                                     // globalList 列表，每一个元素是一个字典                    &#123;                        &quot;area&quot;: &quot;亚洲&quot;,                              // 按照不同洲进行分类                        &quot;subList&quot;: [                                // subList 列表，每个洲各个国家的疫情数据                            &#123;                                &quot;died&quot;: &quot;52&quot;,                                &quot;confirmed&quot;: &quot;6159&quot;,                                &quot;crued&quot;: &quot;4809&quot;,                                &quot;curConfirm&quot;: &quot;1298&quot;,                                &quot;confirmedRelative&quot;: &quot;0&quot;,                                &quot;relativeTime&quot;: &quot;1593792000&quot;,                                &quot;country&quot;: &quot;塔吉克斯坦&quot;                            &#125;                        ],                        &quot;died&quot;: &quot;56556&quot;,                            // 每个洲总的疫情数据                        &quot;crued&quot;: &quot;1625562&quot;,                        &quot;confirmed&quot;: &quot;2447873&quot;,                        &quot;curConfirm&quot;: &quot;765755&quot;,                        &quot;confirmedRelative&quot;: &quot;60574&quot;                    &#125;,                    &#123;                        &quot;area&quot;: &quot;其他&quot;,                             // 其他特殊区域疫情数据                        &quot;subList&quot;: [                            &#123;                                &quot;died&quot;: &quot;13&quot;,                                &quot;confirmed&quot;: &quot;712&quot;,                                &quot;crued&quot;: &quot;651&quot;,                                &quot;curConfirm&quot;: &quot;48&quot;,                                &quot;confirmedRelative&quot;: &quot;0&quot;,                                &quot;relativeTime&quot;: &quot;1593792000&quot;,                                &quot;country&quot;: &quot;钻石公主号邮轮&quot;                            &#125;                        ],                        &quot;died&quot;: &quot;13&quot;,                              // 其他特殊区域疫情总的数据                        &quot;crued&quot;: &quot;651&quot;,                        &quot;confirmed&quot;: &quot;712&quot;,                        &quot;curConfirm&quot;: &quot;48&quot;,                        &quot;confirmedRelative&quot;: &quot;0&quot;                    &#125;,                    &#123;                        &quot;area&quot;: &quot;热门&quot;,                            // 热门国家疫情数据                        &quot;subList&quot;: [                            &#123;                                &quot;died&quot;: &quot;5206&quot;,                                &quot;confirmed&quot;: &quot;204610&quot;,                                &quot;crued&quot;: &quot;179492&quot;,                                &quot;curConfirm&quot;: &quot;19912&quot;,                                &quot;confirmedRelative&quot;: &quot;1172&quot;,                                &quot;relativeTime&quot;: &quot;1593792000&quot;,                                &quot;country&quot;: &quot;土耳其&quot;                            &#125;                        ],                        &quot;died&quot;: &quot;528967&quot;,                         // 热门国家疫情总的数据                        &quot;crued&quot;: &quot;6362924&quot;,                        &quot;confirmed&quot;: &quot;11302357&quot;,                        &quot;confirmedRelative&quot;: &quot;216478&quot;,                        &quot;curConfirm&quot;: &quot;4410466&quot;                    &#125;],                &quot;allForeignTrend&quot;: &#123;                            // allForeignTrend 字典，包含国外每日的疫情数据                        &quot;updateDate&quot;: [],                       // 日期                        &quot;list&quot;: [                               // list 列表，每项数据及其对应的值                            &#123;                                &quot;name&quot;: &quot;累计确诊&quot;,                                &quot;data&quot;: []                            &#125;,                            &#123;                                &quot;name&quot;: &quot;治愈&quot;,                                &quot;data&quot;: []                            &#125;,                            &#123;                                &quot;name&quot;: &quot;死亡&quot;,                                &quot;data&quot;: []                            &#125;,                            &#123;                                &quot;name&quot;: &quot;现有确诊&quot;,                                &quot;data&quot;: []                            &#125;,                            &#123;                                &quot;name&quot;: &quot;新增确诊&quot;,                                &quot;data&quot;: []                            &#125;                        ]                    &#125;,                &quot;topAddCountry&quot;: [                    // 确诊增量最高的国家                        &#123;                            &quot;name&quot;: &quot;美国&quot;,                            &quot;value&quot;: 53162                        &#125;                    ],                &quot;topOverseasInput&quot;: [                // 境外输入最多的省份                    &#123;                        &quot;name&quot;: &quot;黑龙江&quot;,                        &quot;value&quot;: 386                    &#125;                ]            &#125;        ]    &#125;&lt;/script&gt;</code></pre><h2 id="【4x00】主函数-main"><a href="#【4x00】主函数-main" class="headerlink" title="【4x00】主函数 main()"></a><font color=#FF0000>【4x00】主函数 main()</font></h2><p>分别将数据获取、词云图绘制、地图绘制写入三个文件：<code>data_get()</code>、<code>data_wordcloud()</code>、<code>data_map()</code>，然后使用一个主函数文件 main.py 来调用这三个文件里面的函数。</p><pre><code class="python">import data_getimport data_wordcloudimport data_mapdata_dict = data_get.init()data_get.china_total_data(data_dict)data_get.global_total_data(data_dict)data_get.china_daily_data(data_dict)data_get.foreign_daily_data(data_dict)data_wordcloud.china_wordcloud()data_wordcloud.global_wordcloud()data_map.all_map()</code></pre><h2 id="【5x00】数据获取模块-data-get"><a href="#【5x00】数据获取模块-data-get" class="headerlink" title="【5x00】数据获取模块 data_get"></a><font color=#FF0000>【5x00】数据获取模块 data_get</font></h2><h3 id="【5x01】初始化函数-init"><a href="#【5x01】初始化函数-init" class="headerlink" title="【5x01】初始化函数 init()"></a><font color="#4876FF">【5x01】初始化函数 init()</font></h3><p>使用 xpath 语法 <code>//script[@id=&quot;captain-config&quot;]/text()</code> 提取里面的值，利用 <code>json.loads</code> 方法将其转换为字典对象，以便后续的其他函数调用。</p><pre><code class="python">def init():    headers = &#123;        &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.13 Safari/537.36&#39;    &#125;    url = &#39;https://voice.baidu.com/act/newpneumonia/newpneumonia/&#39;    response = requests.get(url=url, headers=headers)    tree = etree.HTML(response.text)    dict1 = tree.xpath(&#39;//script[@id=&quot;captain-config&quot;]/text()&#39;)    print(type(dict1[0]))    dict2 = json.loads(dict1[0])    return dict2</code></pre><h3 id="【5x02】中国总数据-china-total-data"><a href="#【5x02】中国总数据-china-total-data" class="headerlink" title="【5x02】中国总数据 china_total_data()"></a><font color="#4876FF">【5x02】中国总数据 china_total_data()</font></h3><pre><code class="python">def china_total_data(data):    &quot;&quot;&quot;    1、中国省/直辖市/自治区/行政区疫情数据    省/直辖市/自治区/行政区：area    现有确诊：    curConfirm    累计确诊：    confirmed    累计治愈：    crued    累计死亡：    died    现有确诊增量： curConfirmRelative    累计确诊增量： confirmedRelative    累计治愈增量： curedRelative    累计死亡增量： diedRelative    &quot;&quot;&quot;    wb = openpyxl.Workbook()            # 创建工作簿    ws_china = wb.active                # 获取工作表    ws_china.title = &quot;中国省份疫情数据&quot;   # 命名工作表    ws_china.append([&#39;省/直辖市/自治区/行政区&#39;, &#39;现有确诊&#39;, &#39;累计确诊&#39;, &#39;累计治愈&#39;,                     &#39;累计死亡&#39;, &#39;现有确诊增量&#39;, &#39;累计确诊增量&#39;,                     &#39;累计治愈增量&#39;, &#39;累计死亡增量&#39;])    china = data[&#39;component&#39;][0][&#39;caseList&#39;]    for province in china:        ws_china.append([province[&#39;area&#39;],                        province[&#39;curConfirm&#39;],                        province[&#39;confirmed&#39;],                        province[&#39;crued&#39;],                        province[&#39;died&#39;],                        province[&#39;curConfirmRelative&#39;],                        province[&#39;confirmedRelative&#39;],                        province[&#39;curedRelative&#39;],                        province[&#39;diedRelative&#39;]])    &quot;&quot;&quot;    2、中国城市疫情数据    城市：city    现有确诊：curConfirm    累计确诊：confirmed    累计治愈：crued    累计死亡：died    累计确诊增量：confirmedRelative    &quot;&quot;&quot;    ws_city = wb.create_sheet(&#39;中国城市疫情数据&#39;)    ws_city.append([&#39;城市&#39;, &#39;现有确诊&#39;, &#39;累计确诊&#39;,                    &#39;累计治愈&#39;, &#39;累计死亡&#39;, &#39;累计确诊增量&#39;])    for province in china:        for city in province[&#39;subList&#39;]:            # 某些城市没有 curConfirm 数据，则将其设置为 0，crued 和 died 为空时，替换成 0            if &#39;curConfirm&#39; not in city:                city[&#39;curConfirm&#39;] = &#39;0&#39;            if city[&#39;crued&#39;] == &#39;&#39;:                city[&#39;crued&#39;] = &#39;0&#39;            if city[&#39;died&#39;] == &#39;&#39;:                city[&#39;died&#39;] = &#39;0&#39;            ws_city.append([city[&#39;city&#39;], &#39;0&#39;, city[&#39;confirmed&#39;],                           city[&#39;crued&#39;], city[&#39;died&#39;], city[&#39;confirmedRelative&#39;]])    &quot;&quot;&quot;    3、中国疫情数据更新时间：mapLastUpdatedTime    &quot;&quot;&quot;    time_domestic = data[&#39;component&#39;][0][&#39;mapLastUpdatedTime&#39;]    ws_time = wb.create_sheet(&#39;中国疫情数据更新时间&#39;)    ws_time.column_dimensions[&#39;A&#39;].width = 22  # 调整列宽    ws_time.append([&#39;中国疫情数据更新时间&#39;])    ws_time.append([time_domestic])    wb.save(&#39;COVID-19-China.xlsx&#39;)    print(&#39;中国疫情数据已保存至 COVID-19-China.xlsx！&#39;)</code></pre><h3 id="【5x03】全球总数据-global-total-data"><a href="#【5x03】全球总数据-global-total-data" class="headerlink" title="【5x03】全球总数据 global_total_data()"></a><font color="#4876FF">【5x03】全球总数据 global_total_data()</font></h3><p>全球总数据在提取完成后，进行地图绘制时发现并没有中国的数据，因此在写入全球数据时注意要单独将中国的数据插入 Excel 中。</p><pre><code class="python">def global_total_data(data):    &quot;&quot;&quot;    1、全球各国疫情数据    国家：country    现有确诊：curConfirm    累计确诊：confirmed    累计治愈：crued    累计死亡：died    累计确诊增量：confirmedRelative    &quot;&quot;&quot;    wb = openpyxl.Workbook()    ws_global = wb.active    ws_global.title = &quot;全球各国疫情数据&quot;    # 按照国家保存数据    countries = data[&#39;component&#39;][0][&#39;caseOutsideList&#39;]    ws_global.append([&#39;国家&#39;, &#39;现有确诊&#39;, &#39;累计确诊&#39;, &#39;累计治愈&#39;, &#39;累计死亡&#39;, &#39;累计确诊增量&#39;])    for country in countries:        ws_global.append([country[&#39;area&#39;],                          country[&#39;curConfirm&#39;],                          country[&#39;confirmed&#39;],                          country[&#39;crued&#39;],                          country[&#39;died&#39;],                          country[&#39;confirmedRelative&#39;]])    # 按照洲保存数据    continent = data[&#39;component&#39;][0][&#39;globalList&#39;]    for area in continent:        ws_foreign = wb.create_sheet(area[&#39;area&#39;] + &#39;疫情数据&#39;)        ws_foreign.append([&#39;国家&#39;, &#39;现有确诊&#39;, &#39;累计确诊&#39;, &#39;累计治愈&#39;, &#39;累计死亡&#39;, &#39;累计确诊增量&#39;])        for country in area[&#39;subList&#39;]:            ws_foreign.append([country[&#39;country&#39;],                               country[&#39;curConfirm&#39;],                               country[&#39;confirmed&#39;],                               country[&#39;crued&#39;],                               country[&#39;died&#39;],                               country[&#39;confirmedRelative&#39;]])    # 在“全球各国疫情数据”和“亚洲疫情数据”两张表中写入中国疫情数据    ws1, ws2 = wb[&#39;全球各国疫情数据&#39;], wb[&#39;亚洲疫情数据&#39;]    original_data = data[&#39;component&#39;][0][&#39;summaryDataIn&#39;]    add_china_data = [&#39;中国&#39;,                      original_data[&#39;curConfirm&#39;],                      original_data[&#39;confirmed&#39;],                      original_data[&#39;cured&#39;],                      original_data[&#39;died&#39;],                      original_data[&#39;confirmedRelative&#39;]]    ws1.append(add_china_data)    ws2.append(add_china_data)    &quot;&quot;&quot;    2、全球疫情数据更新时间：foreignLastUpdatedTime    &quot;&quot;&quot;    time_foreign = data[&#39;component&#39;][0][&#39;foreignLastUpdatedTime&#39;]    ws_time = wb.create_sheet(&#39;全球疫情数据更新时间&#39;)    ws_time.column_dimensions[&#39;A&#39;].width = 22  # 调整列宽    ws_time.append([&#39;全球疫情数据更新时间&#39;])    ws_time.append([time_foreign])    wb.save(&#39;COVID-19-Global.xlsx&#39;)    print(&#39;全球疫情数据已保存至 COVID-19-Global.xlsx！&#39;)</code></pre><h3 id="【5x04】中国每日数据-china-daily-data"><a href="#【5x04】中国每日数据-china-daily-data" class="headerlink" title="【5x04】中国每日数据 china_daily_data()"></a><font color="#4876FF">【5x04】中国每日数据 china_daily_data()</font></h3><pre><code class="python">def china_daily_data(data):    &quot;&quot;&quot;    i_dict = data[&#39;component&#39;][0][&#39;trend&#39;]    i_dict[&#39;updateDate&#39;]：日期    i_dict[&#39;list&#39;][0]：确诊    i_dict[&#39;list&#39;][1]：疑似    i_dict[&#39;list&#39;][2]：治愈    i_dict[&#39;list&#39;][3]：死亡    i_dict[&#39;list&#39;][4]：新增确诊    i_dict[&#39;list&#39;][5]：新增疑似    i_dict[&#39;list&#39;][6]：新增治愈    i_dict[&#39;list&#39;][7]：新增死亡    i_dict[&#39;list&#39;][8]：累计境外输入    i_dict[&#39;list&#39;][9]：新增境外输入    &quot;&quot;&quot;    ccd_dict = data[&#39;component&#39;][0][&#39;trend&#39;]    update_date = ccd_dict[&#39;updateDate&#39;]              # 日期    china_confirmed = ccd_dict[&#39;list&#39;][0][&#39;data&#39;]     # 每日累计确诊数据    china_crued = ccd_dict[&#39;list&#39;][2][&#39;data&#39;]         # 每日累计治愈数据    china_died = ccd_dict[&#39;list&#39;][3][&#39;data&#39;]          # 每日累计死亡数据    wb = openpyxl.load_workbook(&#39;COVID-19-China.xlsx&#39;)    # 写入每日累计确诊数据    ws_china_confirmed = wb.create_sheet(&#39;中国每日累计确诊数据&#39;)    ws_china_confirmed.append([&#39;日期&#39;, &#39;数据&#39;])    for data in zip(update_date, china_confirmed):        ws_china_confirmed.append(data)    # 写入每日累计治愈数据    ws_china_crued = wb.create_sheet(&#39;中国每日累计治愈数据&#39;)    ws_china_crued.append([&#39;日期&#39;, &#39;数据&#39;])    for data in zip(update_date, china_crued):        ws_china_crued.append(data)    # 写入每日累计死亡数据    ws_china_died = wb.create_sheet(&#39;中国每日累计死亡数据&#39;)    ws_china_died.append([&#39;日期&#39;, &#39;数据&#39;])    for data in zip(update_date, china_died):        ws_china_died.append(data)    wb.save(&#39;COVID-19-China.xlsx&#39;)    print(&#39;中国每日累计确诊/治愈/死亡数据已保存至 COVID-19-China.xlsx！&#39;)</code></pre><h3 id="【5x05】境外每日数据-foreign-daily-data"><a href="#【5x05】境外每日数据-foreign-daily-data" class="headerlink" title="【5x05】境外每日数据 foreign_daily_data()"></a><font color="#4876FF">【5x05】境外每日数据 foreign_daily_data()</font></h3><pre><code class="python">def foreign_daily_data(data):    &quot;&quot;&quot;    te_dict = data[&#39;component&#39;][0][&#39;allForeignTrend&#39;]    te_dict[&#39;updateDate&#39;]：日期    te_dict[&#39;list&#39;][0]：累计确诊    te_dict[&#39;list&#39;][1]：治愈    te_dict[&#39;list&#39;][2]：死亡    te_dict[&#39;list&#39;][3]：现有确诊    te_dict[&#39;list&#39;][4]：新增确诊    &quot;&quot;&quot;    te_dict = data[&#39;component&#39;][0][&#39;allForeignTrend&#39;]    update_date = te_dict[&#39;updateDate&#39;]                # 日期    foreign_confirmed = te_dict[&#39;list&#39;][0][&#39;data&#39;]     # 每日累计确诊数据    foreign_crued = te_dict[&#39;list&#39;][1][&#39;data&#39;]         # 每日累计治愈数据    foreign_died = te_dict[&#39;list&#39;][2][&#39;data&#39;]          # 每日累计死亡数据    wb = openpyxl.load_workbook(&#39;COVID-19-Global.xlsx&#39;)    # 写入每日累计确诊数据    ws_foreign_confirmed = wb.create_sheet(&#39;境外每日累计确诊数据&#39;)    ws_foreign_confirmed.append([&#39;日期&#39;, &#39;数据&#39;])    for data in zip(update_date, foreign_confirmed):        ws_foreign_confirmed.append(data)    # 写入累计治愈数据    ws_foreign_crued = wb.create_sheet(&#39;境外每日累计治愈数据&#39;)    ws_foreign_crued.append([&#39;日期&#39;, &#39;数据&#39;])    for data in zip(update_date, foreign_crued):        ws_foreign_crued.append(data)    # 写入累计死亡数据    ws_foreign_died = wb.create_sheet(&#39;境外每日累计死亡数据&#39;)    ws_foreign_died.append([&#39;日期&#39;, &#39;数据&#39;])    for data in zip(update_date, foreign_died):        ws_foreign_died.append(data)    wb.save(&#39;COVID-19-Global.xlsx&#39;)    print(&#39;境外每日累计确诊/治愈/死亡数据已保存至 COVID-19-Global.xlsx！&#39;)</code></pre><h2 id="【6x00】词云图绘制模块-data-wordcloud"><a href="#【6x00】词云图绘制模块-data-wordcloud" class="headerlink" title="【6x00】词云图绘制模块 data_wordcloud"></a><font color=#FF0000>【6x00】词云图绘制模块 data_wordcloud</font></h2><h3 id="【6x01】中国累计确诊词云图-foreign-daily-data"><a href="#【6x01】中国累计确诊词云图-foreign-daily-data" class="headerlink" title="【6x01】中国累计确诊词云图 foreign_daily_data()"></a><font color="#4876FF">【6x01】中国累计确诊词云图 foreign_daily_data()</font></h3><pre><code class="python">def china_wordcloud():    wb = openpyxl.load_workbook(&#39;COVID-19-China.xlsx&#39;)  # 获取已有的xlsx文件    ws_china = wb[&#39;中国省份疫情数据&#39;]                     # 获取中国省份疫情数据表    ws_china.delete_rows(1)                             # 删除第一行    china_dict = &#123;&#125;                                     # 将省份及其累计确诊按照键值对形式储存在字典中    for data in ws_china.values:        china_dict[data[0]] = int(data[2])    word_cloud = wordcloud.WordCloud(font_path=&#39;C:/Windows/Fonts/simsun.ttc&#39;,                                     background_color=&#39;#CDC9C9&#39;,                                     min_font_size=15,                                     width=900, height=500)    word_cloud.generate_from_frequencies(china_dict)    word_cloud.to_file(&#39;WordCloud-China.png&#39;)    print(&#39;中国省份疫情词云图绘制完毕！&#39;)</code></pre><h3 id="【6x02】全球累计确诊词云图-foreign-daily-data"><a href="#【6x02】全球累计确诊词云图-foreign-daily-data" class="headerlink" title="【6x02】全球累计确诊词云图 foreign_daily_data()"></a><font color="#4876FF">【6x02】全球累计确诊词云图 foreign_daily_data()</font></h3><pre><code class="python">def global_wordcloud():    wb = openpyxl.load_workbook(&#39;COVID-19-Global.xlsx&#39;)    ws_global = wb[&#39;全球各国疫情数据&#39;]    ws_global.delete_rows(1)    global_dict = &#123;&#125;    for data in ws_global.values:        global_dict[data[0]] = int(data[2])    word_cloud = wordcloud.WordCloud(font_path=&#39;C:/Windows/Fonts/simsun.ttc&#39;,                                     background_color=&#39;#CDC9C9&#39;,                                     width=900, height=500)    word_cloud.generate_from_frequencies(global_dict)    word_cloud.to_file(&#39;WordCloud-Global.png&#39;)    print(&#39;全球各国疫情词云图绘制完毕！&#39;)</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/107140534未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【7x00】地图绘制模块-data-map"><a href="#【7x00】地图绘制模块-data-map" class="headerlink" title="【7x00】地图绘制模块 data_map"></a><font color=#FF0000>【7x00】地图绘制模块 data_map</font></h2><h3 id="【7x01】中国累计确诊地图-china-total-map"><a href="#【7x01】中国累计确诊地图-china-total-map" class="headerlink" title="【7x01】中国累计确诊地图 china_total_map()"></a><font color="#4876FF">【7x01】中国累计确诊地图 china_total_map()</font></h3><pre><code class="python">def china_total_map():    wb = openpyxl.load_workbook(&#39;COVID-19-China.xlsx&#39;)  # 获取已有的xlsx文件    ws_time = wb[&#39;中国疫情数据更新时间&#39;]                   # 获取文件中中国疫情数据更新时间表    ws_data = wb[&#39;中国省份疫情数据&#39;]                      # 获取文件中中国省份疫情数据表    ws_data.delete_rows(1)                              # 删除第一行    province = []                                       # 省份    curconfirm = []                                     # 累计确诊    for data in ws_data.values:        province.append(data[0])        curconfirm.append(data[2])    time_china = ws_time[&#39;A2&#39;].value                    # 更新时间    # 设置分级颜色    pieces = [        &#123;&#39;max&#39;: 0, &#39;min&#39;: 0, &#39;label&#39;: &#39;0&#39;, &#39;color&#39;: &#39;#FFFFFF&#39;&#125;,        &#123;&#39;max&#39;: 9, &#39;min&#39;: 1, &#39;label&#39;: &#39;1-9&#39;, &#39;color&#39;: &#39;#FFE5DB&#39;&#125;,        &#123;&#39;max&#39;: 99, &#39;min&#39;: 10, &#39;label&#39;: &#39;10-99&#39;, &#39;color&#39;: &#39;#FF9985&#39;&#125;,        &#123;&#39;max&#39;: 999, &#39;min&#39;: 100, &#39;label&#39;: &#39;100-999&#39;, &#39;color&#39;: &#39;#F57567&#39;&#125;,        &#123;&#39;max&#39;: 9999, &#39;min&#39;: 1000, &#39;label&#39;: &#39;1000-9999&#39;, &#39;color&#39;: &#39;#E64546&#39;&#125;,        &#123;&#39;max&#39;: 99999, &#39;min&#39;: 10000, &#39;label&#39;: &#39;≧10000&#39;, &#39;color&#39;: &#39;#B80909&#39;&#125;    ]    # 绘制地图    ct_map = (        Map()        .add(series_name=&#39;累计确诊人数&#39;, data_pair=[list(z) for z in zip(province, curconfirm)], maptype=&quot;china&quot;)        .set_global_opts(            title_opts=opts.TitleOpts(title=&quot;中国疫情数据（累计确诊）&quot;,                                      subtitle=&#39;数据更新至：&#39; + time_china + &#39;\n\n来源：百度疫情实时大数据报告&#39;),            visualmap_opts=opts.VisualMapOpts(max_=300, is_piecewise=True, pieces=pieces)        )    )    return ct_map</code></pre><h3 id="【7x02】全球累计确诊地图-global-total-map"><a href="#【7x02】全球累计确诊地图-global-total-map" class="headerlink" title="【7x02】全球累计确诊地图 global_total_map()"></a><font color="#4876FF">【7x02】全球累计确诊地图 global_total_map()</font></h3><pre><code class="python">def global_total_map():    wb = openpyxl.load_workbook(&#39;COVID-19-Global.xlsx&#39;)    ws_time = wb[&#39;全球疫情数据更新时间&#39;]    ws_data = wb[&#39;全球各国疫情数据&#39;]    ws_data.delete_rows(1)    country = []                        # 国家    curconfirm = []                     # 累计确诊    for data in ws_data.values:        country.append(data[0])        curconfirm.append(data[2])    time_global = ws_time[&#39;A2&#39;].value   # 更新时间    # 国家名称中英文映射表    name_map = &#123;          &quot;Somalia&quot;: &quot;索马里&quot;,          &quot;Liechtenstein&quot;: &quot;列支敦士登&quot;,          &quot;Morocco&quot;: &quot;摩洛哥&quot;,          &quot;W. Sahara&quot;: &quot;西撒哈拉&quot;,          &quot;Serbia&quot;: &quot;塞尔维亚&quot;,          &quot;Afghanistan&quot;: &quot;阿富汗&quot;,          &quot;Angola&quot;: &quot;安哥拉&quot;,          &quot;Albania&quot;: &quot;阿尔巴尼亚&quot;,          &quot;Andorra&quot;: &quot;安道尔共和国&quot;,          &quot;United Arab Emirates&quot;: &quot;阿拉伯联合酋长国&quot;,          &quot;Argentina&quot;: &quot;阿根廷&quot;,          &quot;Armenia&quot;: &quot;亚美尼亚&quot;,          &quot;Australia&quot;: &quot;澳大利亚&quot;,          &quot;Austria&quot;: &quot;奥地利&quot;,          &quot;Azerbaijan&quot;: &quot;阿塞拜疆&quot;,          &quot;Burundi&quot;: &quot;布隆迪&quot;,          &quot;Belgium&quot;: &quot;比利时&quot;,          &quot;Benin&quot;: &quot;贝宁&quot;,          &quot;Burkina Faso&quot;: &quot;布基纳法索&quot;,          &quot;Bangladesh&quot;: &quot;孟加拉国&quot;,          &quot;Bulgaria&quot;: &quot;保加利亚&quot;,          &quot;Bahrain&quot;: &quot;巴林&quot;,          &quot;Bahamas&quot;: &quot;巴哈马&quot;,          &quot;Bosnia and Herz.&quot;: &quot;波斯尼亚和黑塞哥维那&quot;,          &quot;Belarus&quot;: &quot;白俄罗斯&quot;,          &quot;Belize&quot;: &quot;伯利兹&quot;,          &quot;Bermuda&quot;: &quot;百慕大&quot;,          &quot;Bolivia&quot;: &quot;玻利维亚&quot;,          &quot;Brazil&quot;: &quot;巴西&quot;,          &quot;Barbados&quot;: &quot;巴巴多斯&quot;,          &quot;Brunei&quot;: &quot;文莱&quot;,          &quot;Bhutan&quot;: &quot;不丹&quot;,          &quot;Botswana&quot;: &quot;博茨瓦纳&quot;,          &quot;Central African Rep.&quot;: &quot;中非共和国&quot;,          &quot;Canada&quot;: &quot;加拿大&quot;,          &quot;Switzerland&quot;: &quot;瑞士&quot;,          &quot;Chile&quot;: &quot;智利&quot;,          &quot;China&quot;: &quot;中国&quot;,          &quot;Côte d&#39;Ivoire&quot;: &quot;科特迪瓦&quot;,          &quot;Cameroon&quot;: &quot;喀麦隆&quot;,          &quot;Dem. Rep. Congo&quot;: &quot;刚果（布）&quot;,          &quot;Congo&quot;: &quot;刚果（金）&quot;,          &quot;Colombia&quot;: &quot;哥伦比亚&quot;,          &quot;Cape Verde&quot;: &quot;佛得角&quot;,          &quot;Costa Rica&quot;: &quot;哥斯达黎加&quot;,          &quot;Cuba&quot;: &quot;古巴&quot;,          &quot;N. Cyprus&quot;: &quot;北塞浦路斯&quot;,          &quot;Cyprus&quot;: &quot;塞浦路斯&quot;,          &quot;Czech Rep.&quot;: &quot;捷克&quot;,          &quot;Germany&quot;: &quot;德国&quot;,          &quot;Djibouti&quot;: &quot;吉布提&quot;,          &quot;Denmark&quot;: &quot;丹麦&quot;,          &quot;Dominican Rep.&quot;: &quot;多米尼加&quot;,          &quot;Algeria&quot;: &quot;阿尔及利亚&quot;,          &quot;Ecuador&quot;: &quot;厄瓜多尔&quot;,          &quot;Egypt&quot;: &quot;埃及&quot;,          &quot;Eritrea&quot;: &quot;厄立特里亚&quot;,          &quot;Spain&quot;: &quot;西班牙&quot;,          &quot;Estonia&quot;: &quot;爱沙尼亚&quot;,          &quot;Ethiopia&quot;: &quot;埃塞俄比亚&quot;,          &quot;Finland&quot;: &quot;芬兰&quot;,          &quot;Fiji&quot;: &quot;斐济&quot;,          &quot;France&quot;: &quot;法国&quot;,          &quot;Gabon&quot;: &quot;加蓬&quot;,          &quot;United Kingdom&quot;: &quot;英国&quot;,          &quot;Georgia&quot;: &quot;格鲁吉亚&quot;,          &quot;Ghana&quot;: &quot;加纳&quot;,          &quot;Guinea&quot;: &quot;几内亚&quot;,          &quot;Gambia&quot;: &quot;冈比亚&quot;,          &quot;Guinea-Bissau&quot;: &quot;几内亚比绍&quot;,          &quot;Eq. Guinea&quot;: &quot;赤道几内亚&quot;,          &quot;Greece&quot;: &quot;希腊&quot;,          &quot;Grenada&quot;: &quot;格林纳达&quot;,          &quot;Greenland&quot;: &quot;格陵兰岛&quot;,          &quot;Guatemala&quot;: &quot;危地马拉&quot;,          &quot;Guam&quot;: &quot;关岛&quot;,          &quot;Guyana&quot;: &quot;圭亚那合作共和国&quot;,          &quot;Honduras&quot;: &quot;洪都拉斯&quot;,          &quot;Croatia&quot;: &quot;克罗地亚&quot;,          &quot;Haiti&quot;: &quot;海地&quot;,          &quot;Hungary&quot;: &quot;匈牙利&quot;,          &quot;Indonesia&quot;: &quot;印度尼西亚&quot;,          &quot;India&quot;: &quot;印度&quot;,          &quot;Br. Indian Ocean Ter.&quot;: &quot;英属印度洋领土&quot;,          &quot;Ireland&quot;: &quot;爱尔兰&quot;,          &quot;Iran&quot;: &quot;伊朗&quot;,          &quot;Iraq&quot;: &quot;伊拉克&quot;,          &quot;Iceland&quot;: &quot;冰岛&quot;,          &quot;Israel&quot;: &quot;以色列&quot;,          &quot;Italy&quot;: &quot;意大利&quot;,          &quot;Jamaica&quot;: &quot;牙买加&quot;,          &quot;Jordan&quot;: &quot;约旦&quot;,          &quot;Japan&quot;: &quot;日本&quot;,          &quot;Siachen Glacier&quot;: &quot;锡亚琴冰川&quot;,          &quot;Kazakhstan&quot;: &quot;哈萨克斯坦&quot;,          &quot;Kenya&quot;: &quot;肯尼亚&quot;,          &quot;Kyrgyzstan&quot;: &quot;吉尔吉斯斯坦&quot;,          &quot;Cambodia&quot;: &quot;柬埔寨&quot;,          &quot;Korea&quot;: &quot;韩国&quot;,          &quot;Kuwait&quot;: &quot;科威特&quot;,          &quot;Lao PDR&quot;: &quot;老挝&quot;,          &quot;Lebanon&quot;: &quot;黎巴嫩&quot;,          &quot;Liberia&quot;: &quot;利比里亚&quot;,          &quot;Libya&quot;: &quot;利比亚&quot;,          &quot;Sri Lanka&quot;: &quot;斯里兰卡&quot;,          &quot;Lesotho&quot;: &quot;莱索托&quot;,          &quot;Lithuania&quot;: &quot;立陶宛&quot;,          &quot;Luxembourg&quot;: &quot;卢森堡&quot;,          &quot;Latvia&quot;: &quot;拉脱维亚&quot;,          &quot;Moldova&quot;: &quot;摩尔多瓦&quot;,          &quot;Madagascar&quot;: &quot;马达加斯加&quot;,          &quot;Mexico&quot;: &quot;墨西哥&quot;,          &quot;Macedonia&quot;: &quot;马其顿&quot;,          &quot;Mali&quot;: &quot;马里&quot;,          &quot;Malta&quot;: &quot;马耳他&quot;,          &quot;Myanmar&quot;: &quot;缅甸&quot;,          &quot;Montenegro&quot;: &quot;黑山&quot;,          &quot;Mongolia&quot;: &quot;蒙古国&quot;,          &quot;Mozambique&quot;: &quot;莫桑比克&quot;,          &quot;Mauritania&quot;: &quot;毛里塔尼亚&quot;,          &quot;Mauritius&quot;: &quot;毛里求斯&quot;,          &quot;Malawi&quot;: &quot;马拉维&quot;,          &quot;Malaysia&quot;: &quot;马来西亚&quot;,          &quot;Namibia&quot;: &quot;纳米比亚&quot;,          &quot;New Caledonia&quot;: &quot;新喀里多尼亚&quot;,          &quot;Niger&quot;: &quot;尼日尔&quot;,          &quot;Nigeria&quot;: &quot;尼日利亚&quot;,          &quot;Nicaragua&quot;: &quot;尼加拉瓜&quot;,          &quot;Netherlands&quot;: &quot;荷兰&quot;,          &quot;Norway&quot;: &quot;挪威&quot;,          &quot;Nepal&quot;: &quot;尼泊尔&quot;,          &quot;New Zealand&quot;: &quot;新西兰&quot;,          &quot;Oman&quot;: &quot;阿曼&quot;,          &quot;Pakistan&quot;: &quot;巴基斯坦&quot;,          &quot;Panama&quot;: &quot;巴拿马&quot;,          &quot;Peru&quot;: &quot;秘鲁&quot;,          &quot;Philippines&quot;: &quot;菲律宾&quot;,          &quot;Papua New Guinea&quot;: &quot;巴布亚新几内亚&quot;,          &quot;Poland&quot;: &quot;波兰&quot;,          &quot;Puerto Rico&quot;: &quot;波多黎各&quot;,          &quot;Dem. Rep. Korea&quot;: &quot;朝鲜&quot;,          &quot;Portugal&quot;: &quot;葡萄牙&quot;,          &quot;Paraguay&quot;: &quot;巴拉圭&quot;,          &quot;Palestine&quot;: &quot;巴勒斯坦&quot;,          &quot;Qatar&quot;: &quot;卡塔尔&quot;,          &quot;Romania&quot;: &quot;罗马尼亚&quot;,          &quot;Russia&quot;: &quot;俄罗斯&quot;,          &quot;Rwanda&quot;: &quot;卢旺达&quot;,          &quot;Saudi Arabia&quot;: &quot;沙特阿拉伯&quot;,          &quot;Sudan&quot;: &quot;苏丹&quot;,          &quot;S. Sudan&quot;: &quot;南苏丹&quot;,          &quot;Senegal&quot;: &quot;塞内加尔&quot;,          &quot;Singapore&quot;: &quot;新加坡&quot;,          &quot;Solomon Is.&quot;: &quot;所罗门群岛&quot;,          &quot;Sierra Leone&quot;: &quot;塞拉利昂&quot;,          &quot;El Salvador&quot;: &quot;萨尔瓦多&quot;,          &quot;Suriname&quot;: &quot;苏里南&quot;,          &quot;Slovakia&quot;: &quot;斯洛伐克&quot;,          &quot;Slovenia&quot;: &quot;斯洛文尼亚&quot;,          &quot;Sweden&quot;: &quot;瑞典&quot;,          &quot;Swaziland&quot;: &quot;斯威士兰&quot;,          &quot;Seychelles&quot;: &quot;塞舌尔&quot;,          &quot;Syria&quot;: &quot;叙利亚&quot;,          &quot;Chad&quot;: &quot;乍得&quot;,          &quot;Togo&quot;: &quot;多哥&quot;,          &quot;Thailand&quot;: &quot;泰国&quot;,          &quot;Tajikistan&quot;: &quot;塔吉克斯坦&quot;,          &quot;Turkmenistan&quot;: &quot;土库曼斯坦&quot;,          &quot;Timor-Leste&quot;: &quot;东帝汶&quot;,          &quot;Tonga&quot;: &quot;汤加&quot;,          &quot;Trinidad and Tobago&quot;: &quot;特立尼达和多巴哥&quot;,          &quot;Tunisia&quot;: &quot;突尼斯&quot;,          &quot;Turkey&quot;: &quot;土耳其&quot;,          &quot;Tanzania&quot;: &quot;坦桑尼亚&quot;,          &quot;Uganda&quot;: &quot;乌干达&quot;,          &quot;Ukraine&quot;: &quot;乌克兰&quot;,          &quot;Uruguay&quot;: &quot;乌拉圭&quot;,          &quot;United States&quot;: &quot;美国&quot;,          &quot;Uzbekistan&quot;: &quot;乌兹别克斯坦&quot;,          &quot;Venezuela&quot;: &quot;委内瑞拉&quot;,          &quot;Vietnam&quot;: &quot;越南&quot;,          &quot;Vanuatu&quot;: &quot;瓦努阿图&quot;,          &quot;Yemen&quot;: &quot;也门&quot;,          &quot;South Africa&quot;: &quot;南非&quot;,          &quot;Zambia&quot;: &quot;赞比亚&quot;,          &quot;Zimbabwe&quot;: &quot;津巴布韦&quot;,          &quot;Aland&quot;: &quot;奥兰群岛&quot;,          &quot;American Samoa&quot;: &quot;美属萨摩亚&quot;,          &quot;Fr. S. Antarctic Lands&quot;: &quot;南极洲&quot;,          &quot;Antigua and Barb.&quot;: &quot;安提瓜和巴布达&quot;,          &quot;Comoros&quot;: &quot;科摩罗&quot;,          &quot;Curaçao&quot;: &quot;库拉索岛&quot;,          &quot;Cayman Is.&quot;: &quot;开曼群岛&quot;,          &quot;Dominica&quot;: &quot;多米尼加&quot;,          &quot;Falkland Is.&quot;: &quot;福克兰群岛马尔维纳斯&quot;,          &quot;Faeroe Is.&quot;: &quot;法罗群岛&quot;,          &quot;Micronesia&quot;: &quot;密克罗尼西亚&quot;,          &quot;Heard I. and McDonald Is.&quot;: &quot;赫德岛和麦克唐纳群岛&quot;,          &quot;Isle of Man&quot;: &quot;曼岛&quot;,          &quot;Jersey&quot;: &quot;泽西岛&quot;,          &quot;Kiribati&quot;: &quot;基里巴斯&quot;,          &quot;Saint Lucia&quot;: &quot;圣卢西亚&quot;,          &quot;N. Mariana Is.&quot;: &quot;北马里亚纳群岛&quot;,          &quot;Montserrat&quot;: &quot;蒙特塞拉特&quot;,          &quot;Niue&quot;: &quot;纽埃&quot;,          &quot;Palau&quot;: &quot;帕劳&quot;,          &quot;Fr. Polynesia&quot;: &quot;法属波利尼西亚&quot;,          &quot;S. Geo. and S. Sandw. Is.&quot;: &quot;南乔治亚岛和南桑威奇群岛&quot;,          &quot;Saint Helena&quot;: &quot;圣赫勒拿&quot;,          &quot;St. Pierre and Miquelon&quot;: &quot;圣皮埃尔和密克隆群岛&quot;,          &quot;São Tomé and Principe&quot;: &quot;圣多美和普林西比&quot;,          &quot;Turks and Caicos Is.&quot;: &quot;特克斯和凯科斯群岛&quot;,          &quot;St. Vin. and Gren.&quot;: &quot;圣文森特和格林纳丁斯&quot;,          &quot;U.S. Virgin Is.&quot;: &quot;美属维尔京群岛&quot;,          &quot;Samoa&quot;: &quot;萨摩亚&quot;        &#125;    pieces = [        &#123;&#39;max&#39;: 0, &#39;min&#39;: 0, &#39;label&#39;: &#39;0&#39;, &#39;color&#39;: &#39;#FFFFFF&#39;&#125;,        &#123;&#39;max&#39;: 49, &#39;min&#39;: 1, &#39;label&#39;: &#39;1-49&#39;, &#39;color&#39;: &#39;#FFE5DB&#39;&#125;,        &#123;&#39;max&#39;: 99, &#39;min&#39;: 50, &#39;label&#39;: &#39;50-99&#39;, &#39;color&#39;: &#39;#FFC4B3&#39;&#125;,        &#123;&#39;max&#39;: 999, &#39;min&#39;: 100, &#39;label&#39;: &#39;100-999&#39;, &#39;color&#39;: &#39;#FF9985&#39;&#125;,        &#123;&#39;max&#39;: 9999, &#39;min&#39;: 1000, &#39;label&#39;: &#39;1000-9999&#39;, &#39;color&#39;: &#39;#F57567&#39;&#125;,        &#123;&#39;max&#39;: 99999, &#39;min&#39;: 10000, &#39;label&#39;: &#39;10000-99999&#39;, &#39;color&#39;: &#39;#E64546&#39;&#125;,        &#123;&#39;max&#39;: 999999, &#39;min&#39;: 100000, &#39;label&#39;: &#39;100000-999999&#39;, &#39;color&#39;: &#39;#B80909&#39;&#125;,        &#123;&#39;max&#39;: 9999999, &#39;min&#39;: 1000000, &#39;label&#39;: &#39;≧1000000&#39;, &#39;color&#39;: &#39;#8A0808&#39;&#125;    ]    gt_map = (        Map()        .add(series_name=&#39;累计确诊人数&#39;, data_pair=[list(z) for z in zip(country, curconfirm)], maptype=&quot;world&quot;, name_map=name_map, is_map_symbol_show=False)        .set_series_opts(label_opts=opts.LabelOpts(is_show=False))        .set_global_opts(            title_opts=opts.TitleOpts(title=&quot;全球疫情数据（累计确诊）&quot;,                                      subtitle=&#39;数据更新至：&#39; + time_global + &#39;\n\n来源：百度疫情实时大数据报告&#39;),            visualmap_opts=opts.VisualMapOpts(max_=300, is_piecewise=True, pieces=pieces),        )    )    return gt_map</code></pre><h3 id="【7x03】中国每日数据折线图-china-daily-map"><a href="#【7x03】中国每日数据折线图-china-daily-map" class="headerlink" title="【7x03】中国每日数据折线图 china_daily_map()"></a><font color="#4876FF">【7x03】中国每日数据折线图 china_daily_map()</font></h3><pre><code class="python">def china_daily_map():    wb = openpyxl.load_workbook(&#39;COVID-19-China.xlsx&#39;)    ws_china_confirmed = wb[&#39;中国每日累计确诊数据&#39;]    ws_china_crued = wb[&#39;中国每日累计治愈数据&#39;]    ws_china_died = wb[&#39;中国每日累计死亡数据&#39;]    ws_china_confirmed.delete_rows(1)    ws_china_crued.delete_rows(1)    ws_china_died.delete_rows(1)    x_date = []               # 日期    y_china_confirmed = []    # 每日累计确诊    y_china_crued = []        # 每日累计治愈    y_china_died = []         # 每日累计死亡    for china_confirmed in ws_china_confirmed.values:        y_china_confirmed.append(china_confirmed[1])    for china_crued in ws_china_crued.values:        x_date.append(china_crued[0])        y_china_crued.append(china_crued[1])    for china_died in ws_china_died.values:        y_china_died.append(china_died[1])    fi_map = (        Line(init_opts=opts.InitOpts(height=&#39;420px&#39;))            .add_xaxis(xaxis_data=x_date)            .add_yaxis(            series_name=&quot;中国累计确诊数据&quot;,            y_axis=y_china_confirmed,            label_opts=opts.LabelOpts(is_show=False),        )            .add_yaxis(            series_name=&quot;中国累计治愈趋势&quot;,            y_axis=y_china_crued,            label_opts=opts.LabelOpts(is_show=False),        )            .add_yaxis(            series_name=&quot;中国累计死亡趋势&quot;,            y_axis=y_china_died,            label_opts=opts.LabelOpts(is_show=False),        )            .set_global_opts(            title_opts=opts.TitleOpts(title=&quot;中国每日累计确诊/治愈/死亡趋势&quot;),            legend_opts=opts.LegendOpts(pos_bottom=&quot;bottom&quot;, orient=&#39;horizontal&#39;),            tooltip_opts=opts.TooltipOpts(trigger=&quot;axis&quot;),            yaxis_opts=opts.AxisOpts(                type_=&quot;value&quot;,                axistick_opts=opts.AxisTickOpts(is_show=True),                splitline_opts=opts.SplitLineOpts(is_show=True),            ),            xaxis_opts=opts.AxisOpts(type_=&quot;category&quot;, boundary_gap=False),        )    )    return fi_map</code></pre><h3 id="【7x04】境外每日数据折线图-foreign-daily-map"><a href="#【7x04】境外每日数据折线图-foreign-daily-map" class="headerlink" title="【7x04】境外每日数据折线图 foreign_daily_map()"></a><font color="#4876FF">【7x04】境外每日数据折线图 foreign_daily_map()</font></h3><pre><code class="python">def foreign_daily_map():    wb = openpyxl.load_workbook(&#39;COVID-19-Global.xlsx&#39;)    ws_foreign_confirmed = wb[&#39;境外每日累计确诊数据&#39;]    ws_foreign_crued = wb[&#39;境外每日累计治愈数据&#39;]    ws_foreign_died = wb[&#39;境外每日累计死亡数据&#39;]    ws_foreign_confirmed.delete_rows(1)    ws_foreign_crued.delete_rows(1)    ws_foreign_died.delete_rows(1)    x_date = []                # 日期    y_foreign_confirmed = []   # 累计确诊    y_foreign_crued = []       # 累计治愈    y_foreign_died = []        # 累计死亡    for foreign_confirmed in ws_foreign_confirmed.values:        y_foreign_confirmed.append(foreign_confirmed[1])    for foreign_crued in ws_foreign_crued.values:        x_date.append(foreign_crued[0])        y_foreign_crued.append(foreign_crued[1])    for foreign_died in ws_foreign_died.values:        y_foreign_died.append(foreign_died[1])    fte_map = (        Line(init_opts=opts.InitOpts(height=&#39;420px&#39;))            .add_xaxis(xaxis_data=x_date)            .add_yaxis(            series_name=&quot;境外累计确诊趋势&quot;,            y_axis=y_foreign_confirmed,            label_opts=opts.LabelOpts(is_show=False),        )            .add_yaxis(            series_name=&quot;境外累计治愈趋势&quot;,            y_axis=y_foreign_crued,            label_opts=opts.LabelOpts(is_show=False),        )            .add_yaxis(            series_name=&quot;境外累计死亡趋势&quot;,            y_axis=y_foreign_died,            label_opts=opts.LabelOpts(is_show=False),        )            .set_global_opts(            title_opts=opts.TitleOpts(title=&quot;境外每日累计确诊/治愈/死亡趋势&quot;),            legend_opts=opts.LegendOpts(pos_bottom=&quot;bottom&quot;, orient=&#39;horizontal&#39;),            tooltip_opts=opts.TooltipOpts(trigger=&quot;axis&quot;),            yaxis_opts=opts.AxisOpts(                type_=&quot;value&quot;,                axistick_opts=opts.AxisTickOpts(is_show=True),                splitline_opts=opts.SplitLineOpts(is_show=True),            ),            xaxis_opts=opts.AxisOpts(type_=&quot;category&quot;, boundary_gap=False),        )    )    return fte_map</code></pre><h2 id="【8x00】结果截图"><a href="#【8x00】结果截图" class="headerlink" title="【8x00】结果截图"></a><font color=#FF0000>【8x00】结果截图</font></h2><h3 id="【8x01】数据储存-Excel"><a href="#【8x01】数据储存-Excel" class="headerlink" title="【8x01】数据储存 Excel"></a><font color="#4876FF">【8x01】数据储存 Excel</font></h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/03.png" alt="03"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/04.png" alt="04"></p><h3 id="【8x02】词云图"><a href="#【8x02】词云图" class="headerlink" title="【8x02】词云图"></a><font color="#4876FF">【8x02】词云图</font></h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/05.png" alt="05"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/06.png" alt="06"></p><h3 id="【8x03】地图-折线图"><a href="#【8x03】地图-折线图" class="headerlink" title="【8x03】地图 + 折线图"></a><font color="#4876FF">【8x03】地图 + 折线图</font></h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A89/07.png" alt="07"></p><h2 id="【9x00】完整代码"><a href="#【9x00】完整代码" class="headerlink" title="【9x00】完整代码"></a><font color=#FF0000>【9x00】完整代码</font></h2><p>预览地址：<del><a href="http://cov.itrhx.com/">http://cov.itrhx.com/</a></del>（已失效）<br>完整代码地址（点亮 star 有 buff 加成）：<a href="https://github.com/TRHX/Python3-Spider-Practice">https://github.com/TRHX/Python3-Spider-Practice</a><br>爬虫实战专栏（持续更新）：<a href="https://itrhx.blog.csdn.net/article/category/9351278">https://itrhx.blog.csdn.net/article/category/9351278</a></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/107140534未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 肺炎疫情 </tag>
            
            <tag> COVID-19 </tag>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Pandas（十）：数据读写</title>
      <link href="/article/034/"/>
      <url>/article/034/</url>
      
        <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106963135未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】读取数据"><a href="#【01x00】读取数据" class="headerlink" title="【01x00】读取数据"></a><font color=#FF0000>【01x00】读取数据</font></h2><p>Pandas 提供了一些用于将表格型数据读取为 DataFrame 对象的函数。常见方法如下：</p><p>Pandas 官方对 IO 工具的介绍：<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html">https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html</a></p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>read_csv</td><td>从文件、URL、文件型对象中加载带分隔符的数据。默认分隔符为逗号</td></tr><tr><td>read_table</td><td>从文件、URL、文件型对象中加载带分隔符的数据。默认分隔符为制表符（<code>&#39;\t&#39;</code>）</td></tr><tr><td>read_fwf</td><td>读取定宽列格式数据（没有分隔符）</td></tr><tr><td>read_clipboard</td><td>读取剪贴板中的数据，可以看做 read_table 的剪贴板版本。在将网页转换为表格时很有用</td></tr><tr><td>read_excel</td><td>从 Excel XLS 或 XLSX file 读取表格数据</td></tr><tr><td>read_hdf</td><td>读取 pandas写的 HDF5 文件</td></tr><tr><td>read_html</td><td>读取 HTML 文档中的所有表格</td></tr><tr><td>read_json</td><td>读取 JSON（ JavaScript Object Notation）字符串中的数据</td></tr><tr><td>read_msgpack</td><td>读取二进制格式编码的 pandas 数据（Pandas v1.0.0 中已删除对 msgpack 的支持，建议使用 <a href="https://pandas.pydata.org/docs/user_guide/io.html#io-msgpack">pyarrow</a>）</td></tr><tr><td>read_pickle</td><td>读取 Python pickle 格式中存储的任意对象</td></tr><tr><td>read_sas</td><td>读取存储于 SAS 系统自定义存储格式的 SAS 数据集</td></tr><tr><td>read_sql</td><td>（使用 SQLAlchemy）读取 SQL 查询结果为 pandas 的 DataFrame</td></tr><tr><td>read_stata</td><td>读取 Stata 文件格式的数据集</td></tr><tr><td>read_feather</td><td>读取 Feather 二进制格式文件</td></tr></tbody></table><p>以下以 read_csv 和 read_table 为例，它们的参数多达 50 多个，具体可参见官方文档：</p><p>read_csv：<a href="https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html">https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html</a></p><p>read_table：<a href="https://pandas.pydata.org/docs/reference/api/pandas.read_table.html">https://pandas.pydata.org/docs/reference/api/pandas.read_table.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>path</td><td>表示文件系统位置、URL、文件型对象的字符串</td></tr><tr><td>sep / delimiter</td><td>用于对行中各字段进行拆分的字符序列或正则表达式</td></tr><tr><td>header</td><td>用作列名的行号，默认为 0（第一行），如果没有 header 行就应该设置为 None</td></tr><tr><td>index_col</td><td>用作行索引的列编号或列名。可以是单个名称、数字或由多个名称、数字组成的列表（层次化索引）</td></tr><tr><td>names</td><td>用于结果的列名列表，结合 header=None</td></tr><tr><td>skiprows</td><td>需要忽略的行数（从文件开始处算起），或需要跳过的行号列表（从0开始）</td></tr><tr><td>na_values</td><td>指定一组值，将该组值设置为 NaN（缺失值）</td></tr><tr><td>comment</td><td>用于将注释信息从行尾拆分出去的字符（一个或多个）</td></tr><tr><td>parse_dates</td><td>尝试将数据解析为日期，默认为 False。如果为 True，则尝试解析所有列。此外，还可以指定需要解析的一组列号或列名。<br>如果列表的元素为列表或元组，就会将多个列组合到一起再进行日期解析工作（例如，日期、时间分别位于两个列中）</td></tr><tr><td>keep_date_col</td><td>如果连接多列解析日期，则保持参与连接的列。默认为 False</td></tr><tr><td>converters</td><td>由列号 / 列名跟函数之间的映射关系组成的字典。例如，<code>&#123;&#39;foo&#39;: f&#125;</code> 会对 foo 列的所有值应用函数 f</td></tr><tr><td>dayfirst</td><td>当解析有歧义的日期时，将其看做国际格式（例如，7/6/2012 —&gt; June 7,2012），默认为 Fase</td></tr><tr><td>date_parser</td><td>用于解析日期的函数</td></tr><tr><td>nrows</td><td>需要读取的行数（从文件开始处算起）</td></tr><tr><td>iterator</td><td>返回一个 TextParser 以便逐块读取文件</td></tr><tr><td>chunksize</td><td>文件块的大小（用于迭代）</td></tr><tr><td>skip_footer</td><td>需要忽略的行数（从文件末尾处算起）</td></tr><tr><td>verbose</td><td>打印各种解析器输出信息，比如“非数值列中缺失值的数量”等</td></tr><tr><td>encoding</td><td>用于 unicode 的文本编码格式。例如，“utf-8” 表示用 UTF-8 编码的文本</td></tr><tr><td>squeeze</td><td>如果数据经解析后仅含一列，则返回 Series</td></tr><tr><td>thousands</td><td>千分位分隔符，如 <code>,</code> 或 <code>.</code></td></tr></tbody></table><h3 id="【01x01】简单示例"><a href="#【01x01】简单示例" class="headerlink" title="【01x01】简单示例"></a><font color=#4876FF>【01x01】简单示例</font></h3><p>首先创建一个 test1.csv 文件：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/01.png" alt="01"></p><p>使用 read_csv 方法将其读出为一个 DataFrame 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test1.csv&#39;)&gt;&gt;&gt; obj   a   b   c   d message0  1   2   3   4   hello1  5   6   7   8   world2  9  10  11  12  python&gt;&gt;&gt; &gt;&gt;&gt; type(obj)&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</code></pre><p>前面的 csv 文件是以逗号分隔的，可以使用 read_table 方法并指定分隔符来读取：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.read_table(r&#39;C:\Users\TanRe\Desktop\test1.csv&#39;, sep=&#39;,&#39;)&gt;&gt;&gt; obj   a   b   c   d message0  1   2   3   4   hello1  5   6   7   8   world2  9  10  11  12  python</code></pre><h3 id="【01x02】header-names-定制列标签"><a href="#【01x02】header-names-定制列标签" class="headerlink" title="【01x02】header / names 定制列标签"></a><font color=#4876FF>【01x02】header / names 定制列标签</font></h3><p>以上示例中第一行为列标签，如果没有单独定义列标签，使用 read_csv 方法也会默认将第一行当作列标签：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/02.png" alt="02"></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test2.csv&#39;)&gt;&gt;&gt; obj   1   2   3   4   hello0  5   6   7   8   world1  9  10  11  12  python</code></pre><p>避免以上情况，可以设置 <code>header=None</code>，Pandas 会为其自动分配列标签：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test2.csv&#39;, header=None)   0   1   2   3       40  1   2   3   4   hello1  5   6   7   8   world2  9  10  11  12  python</code></pre><p>也可以使用 <code>names</code> 参数自定义列标签，传递的是一个列表：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test2.csv&#39;, names=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;message&#39;])   a   b   c   d message0  1   2   3   4   hello1  5   6   7   8   world2  9  10  11  12  python</code></pre><h3 id="【01x03】index-col-指定列为行索引"><a href="#【01x03】index-col-指定列为行索引" class="headerlink" title="【01x03】index_col 指定列为行索引"></a><font color=#4876FF>【01x03】index_col 指定列为行索引</font></h3><p><code>index_col</code> 参数可以指定某一列作为 DataFrame 的行索引，传递的参数是列名称，在以下示例中，会将列名为 <code>message</code> 的列作为 DataFrame 的行索引：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/03.png" alt="03"></p><pre><code class="python">&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test2.csv&#39;,                 names=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;message&#39;],                 index_col=&#39;message&#39;)         a   b   c   dmessage               hello    1   2   3   4world    5   6   7   8python   9  10  11  12</code></pre><p>如果需要构造多层索引的 DataFrame 对象，则只需传入由列编号或列名组成的列表即可：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/04.png" alt="04"></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test3.csv&#39;, index_col=[&#39;key1&#39;, &#39;key2&#39;])           value1  value2key1 key2                one  a          1       2     b          3       4     c          5       6     d          7       8two  a          9      10     b         11      12     c         13      14     d         15      16</code></pre><h3 id="【01x04】sep-指定分隔符"><a href="#【01x04】sep-指定分隔符" class="headerlink" title="【01x04】sep 指定分隔符"></a><font color=#4876FF>【01x04】sep 指定分隔符</font></h3><p>在 read_table 中，sep 参数用于接收分隔符，如果遇到不是用固定的分隔符去分隔字段的，也可以传递一个正则表达式作为 read_table 的分隔符，如下面的 txt 文件数据之间是由不同的空白字符间隔开的：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/05.png" alt="05"></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.read_table(r&#39;C:\Users\TanRe\Desktop\test1.txt&#39;, sep=&#39;\s+&#39;)            A         B         Caaa -0.264438 -1.026059 -0.619500bbb  0.927272  0.302904 -0.032399ccc -0.264273 -0.386314 -0.217601ddd -0.871858 -0.348382  1.100491</code></pre><h3 id="【01x05】skiprows-忽略行"><a href="#【01x05】skiprows-忽略行" class="headerlink" title="【01x05】skiprows 忽略行"></a><font color=#4876FF>【01x05】skiprows 忽略行</font></h3><p>skiprows    参数可用于设置需要忽略的行数，或需要跳过的行号列表，在下面的示例中，读取文件时选择跳过第1、3、4行（索引值分别为0、2、3）：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/06.png" alt="06"></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test4.csv&#39;, skiprows=[0, 2, 3])   a   b   c   d message0  1   2   3   4   hello1  5   6   7   8   world2  9  10  11  12  python</code></pre><h3 id="【01x06】na-values-设置缺失值"><a href="#【01x06】na-values-设置缺失值" class="headerlink" title="【01x06】na_values 设置缺失值"></a><font color=#4876FF>【01x06】na_values 设置缺失值</font></h3><p>当文件中出现了空字符串或者 NA 值，Pandas 会将其标记成 NaN（缺失值），同样也可以使用 <code>isnull</code> 方法来判断结果值是否为缺失值：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/07.png" alt="07"></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; obj  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt; &gt;&gt;&gt; pd.isnull(obj)   something      a      b      c      d  message0      False  False  False  False  False     True1      False  False  False   True  False    False2      False  False  False  False  False    False</code></pre><p><code>na_values</code> 方法可以传递一组值，将这组值设置为缺失值，如果传递的为字典对象，则字典的各值将被设置为 NaN：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; obj1  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt; &gt;&gt;&gt; obj2 = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;, na_values=[&#39;1&#39;, &#39;12&#39;])&gt;&gt;&gt; obj2  something    a   b     c    d message0       one  NaN   2   3.0  4.0     NaN1       two  5.0   6   NaN  8.0   world2     three  9.0  10  11.0  NaN  python&gt;&gt;&gt; &gt;&gt;&gt; sentinels = &#123;&#39;message&#39;: [&#39;python&#39;, &#39;world&#39;], &#39;something&#39;: [&#39;two&#39;]&#125;&gt;&gt;&gt; obj3 = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;, na_values=sentinels)&gt;&gt;&gt; obj3  something  a   b     c   d  message0       one  1   2   3.0   4      NaN1       NaN  5   6   NaN   8      NaN2     three  9  10  11.0  12      NaN</code></pre><h3 id="【01x07】nrows-chunksize-行与块"><a href="#【01x07】nrows-chunksize-行与块" class="headerlink" title="【01x07】nrows / chunksize 行与块"></a><font color=#4876FF>【01x07】nrows / chunksize 行与块</font></h3><p>以下 test6.csv 文件中包含 50 行数据：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/08.png" alt="08"></p><p>可以设置 <code>pd.options.display.max_rows</code> 来紧凑地显示指定行数的数据：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.options.display.max_rows = 10&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test6.csv&#39;)         one       two     three      four key0   0.467976 -0.038649 -0.295344 -1.824726   L1  -0.358893  1.404453  0.704965 -0.200638   B2  -0.501840  0.659254 -0.421691 -0.057688   G3   0.204886  1.074134  1.388361 -0.982404   R4   0.354628 -0.133116  0.283763 -0.837063   Q..       ...       ...       ...       ...  ..45  2.311896 -0.417070 -1.409599 -0.515821   L46 -0.479893 -0.633419  0.745152 -0.646038   E47  0.523331  0.787112  0.486066  1.093156   K48 -0.362559  0.598894 -1.843201  0.887292   G49 -0.096376 -1.012999 -0.657431 -0.573315   0[50 rows x 5 columns]</code></pre><p>通过 nrows 参数可以读取指定行数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test6.csv&#39;, nrows=5)        one       two     three      four key0  0.467976 -0.038649 -0.295344 -1.824726   L1 -0.358893  1.404453  0.704965 -0.200638   B2 -0.501840  0.659254 -0.421691 -0.057688   G3  0.204886  1.074134  1.388361 -0.982404   R4  0.354628 -0.133116  0.283763 -0.837063   Q</code></pre><p>要逐块读取文件，可以指定 chunksize（行数）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; chunker = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test6.csv&#39;, chunksize=50)&gt;&gt;&gt; chunker&lt;pandas.io.parsers.TextFileReader object at 0x07A20D60&gt;</code></pre><p>返回的 TextParser 对象，可以根据 chunksize 对文件进行逐块迭代。以下示例中，对 test6.csv 文件数据进行迭代处理，将值计数聚合到 “key” 列中：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; chunker = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test6.csv&#39;, chunksize=50)&gt;&gt;&gt; tot = pd.Series([], dtype=&#39;float64&#39;)&gt;&gt;&gt; for piece in chunker:    tot = tot.add(piece[&#39;key&#39;].value_counts(), fill_value=0)&gt;&gt;&gt; tot = tot.sort_values(ascending=False)&gt;&gt;&gt; tot[:10]G    6.0E    5.0B    5.0L    5.00    5.0K    4.0A    4.0R    4.0C    2.0Q    2.0dtype: float64</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106963135未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【02x00】写入数据"><a href="#【02x00】写入数据" class="headerlink" title="【02x00】写入数据"></a><font color=#FF0000>【02x00】写入数据</font></h2><p>Pandas 提供了一些用于将表格型数据读取为 DataFrame 对象的函数。常见方法如下：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>to_csv</td><td>将对象写入逗号分隔值（csv）文件</td></tr><tr><td>to_clipboard</td><td>将对象复制到系统剪贴板</td></tr><tr><td>to_excel</td><td>将对象写入 Excel 工作表</td></tr><tr><td>to_hdf</td><td>使用 HDFStore 将包含的数据写入 HDF5 文件</td></tr><tr><td>to_html</td><td>将 DataFrame 呈现为 HTML 表格</td></tr><tr><td>to_json</td><td>将对象转换为 JSON（ JavaScript Object Notation）字符串</td></tr><tr><td>to_msgpack</td><td>将对象写入二进制格式编码的文件（Pandas v1.0.0 中已删除对 msgpack 的支持，建议使用 <a href="https://pandas.pydata.org/docs/user_guide/io.html#io-msgpack">pyarrow</a>）</td></tr><tr><td>to_pickle</td><td>Pickle（序列化）对象到文件</td></tr><tr><td>to_sql</td><td>将存储在 DataFrame 中的数据写入 SQL 数据库</td></tr><tr><td>to_stata</td><td>将 DataFrame 对象导出为 Stata 格式</td></tr><tr><td>to_feather</td><td>将 DataFrames 写入 Feather 二进制格式文件</td></tr></tbody></table><p>以下以 to_csv 为例，它的参数同样多达 50 多个，具体可参见官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_csv.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_csv.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.to_csv.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.to_csv.html</a></p></li></ul><h3 id="【02x01】简单示例"><a href="#【02x01】简单示例" class="headerlink" title="【02x01】简单示例"></a><font color=#4876FF>【02x01】简单示例</font></h3><p>以之前的 test5.csv 文件为例，先读出数据，再将数据写入另外的文件：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; data  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt; &gt;&gt;&gt; data.to_csv(r&#39;C:\Users\TanRe\Desktop\out1.csv&#39;)</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/09.png" alt="09"></p><h3 id="【02x02】sep-指定分隔符"><a href="#【02x02】sep-指定分隔符" class="headerlink" title="【02x02】sep 指定分隔符"></a><font color=#4876FF>【02x02】sep 指定分隔符</font></h3><p>sep 参数可用于其他分隔符：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; data  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt;&gt;&gt;&gt; data.to_csv(r&#39;C:\Users\TanRe\Desktop\out2.csv&#39;, sep=&#39;|&#39;)</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/10.png" alt="10"></p><h3 id="【02x03】na-rep-替换缺失值"><a href="#【02x03】na-rep-替换缺失值" class="headerlink" title="【02x03】na_rep 替换缺失值"></a><font color=#4876FF>【02x03】na_rep 替换缺失值</font></h3><p>na_rep 参数可将缺失值（NaN）替换成其他字符串：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; data  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt; &gt;&gt;&gt; data.to_csv(r&#39;C:\Users\TanRe\Desktop\out3.csv&#39;, na_rep=&#39;X&#39;)</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/11.png" alt="11"></p><h3 id="【02x04】index-header-行与列标签"><a href="#【02x04】index-header-行与列标签" class="headerlink" title="【02x04】index / header 行与列标签"></a><font color=#4876FF>【02x04】index / header 行与列标签</font></h3><p>设置 <code>index=False</code>, <code>header=False</code>，可以禁用行标签与列标签：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; data  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt; &gt;&gt;&gt; data.to_csv(r&#39;C:\Users\TanRe\Desktop\out4.csv&#39;, index=False, header=False)</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/12.png" alt="12"></p><p>还可以传入列表来重新设置列标签：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; data  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt; &gt;&gt;&gt; data.to_csv(r&#39;C:\Users\TanRe\Desktop\out5.csv&#39;, header=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;])</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/13.png" alt="13"></p><h3 id="【02x05】columns-指定列"><a href="#【02x05】columns-指定列" class="headerlink" title="【02x05】columns 指定列"></a><font color=#4876FF>【02x05】columns 指定列</font></h3><p>可以通过设置 columns 参数，只写入部分列，并按照指定顺序排序：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = pd.read_csv(r&#39;C:\Users\TanRe\Desktop\test5.csv&#39;)&gt;&gt;&gt; data  something  a   b     c   d message0       one  1   2   3.0   4     NaN1       two  5   6   NaN   8   world2     three  9  10  11.0  12  python&gt;&gt;&gt;&gt;&gt;&gt; data.to_csv(r&#39;C:\Users\TanRe\Desktop\out6.csv&#39;, columns=[&#39;c&#39;, &#39;b&#39;, &#39;a&#39;])</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A88/14.png" alt="14"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106963135未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Pandas（九）：时间序列</title>
      <link href="/article/033/"/>
      <url>/article/033/</url>
      
        <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106947061未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】时间序列"><a href="#【01x00】时间序列" class="headerlink" title="【01x00】时间序列"></a><font color=#FF0000>【01x00】时间序列</font></h2><p>官网对于时间序列的介绍：<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html">https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html</a></p><p>时间序列（time series）是一种重要的结构化数据形式，应用于多个领域，包括金融学、经济学、生态学、神经科学、物理学等。在多个时间点观察或测量到的任何事物都可以形成一段时间序列。很多时间序列是固定频率的，也就是说，数据点是根据某种规律定期出现的（比如每15秒、每5分钟、每月出现一次）。时间序列也可以是不定期的，没有固定的时间单位或单位之间的偏移量。时间序列数据的意义取决于具体的应用场景，主要有以下几种：</p><ul><li><p><font color=#4169E1><strong>时间戳（timestamp），表示某个具体的时间点，例如 2020-6-24 15:30；</strong></font></p></li><li><p><font color=#4169E1><strong>固定周期（period），表示某个时间周期，例如 2020-01；</strong></font></p></li><li><p><font color=#4169E1><strong>时间间隔（timedelta），持续时间，即两个日期或时间之间的差异。</strong></font></p></li><li><p><font color=#FFA500><strong>针对时间戳数据，Pandas 提供了 Timestamp 类型。它本质上是 Python 的原生 datetime 类型的替代品，但是在性能更好的 numpy.datetime64 类型的基础上创建。对应的索引数据结构是 DatetimeIndex。</strong></font></p></li><li><p><font color=#FFA500><strong>针对时间周期数据，Pandas 提供了 Period 类型。这是利用 numpy.datetime64 类型将固定频率的时间间隔进行编码。对应的索引数据结构是 PeriodIndex。</strong></font></p></li><li><p><font color=#FFA500><strong>针对时间增量或持续时间，Pandas 提供了 Timedelta 类型。Timedelta 是一种代替 Python 原生datetime.timedelta 类型的高性能数据结构，同样是基于 numpy.timedelta64 类型。对应的索引数据结构是 TimedeltaIndex。</strong></font></p></li></ul><h2 id="【02x00】Timestamp-时间戳"><a href="#【02x00】Timestamp-时间戳" class="headerlink" title="【02x00】Timestamp 时间戳"></a><font color=#FF0000>【02x00】Timestamp 时间戳</font></h2><h3 id="【02x01】pandas-Timestamp"><a href="#【02x01】pandas-Timestamp" class="headerlink" title="【02x01】pandas.Timestamp"></a><font color=#4876FF>【02x01】pandas.Timestamp</font></h3><p>在 pandas 中，<code>pandas.Timestamp</code> 方法用来代替 Python 中的 <code>datetime.datetime</code> 方法。</p><p>Timestamp 与 Python 的 Datetime 等效，在大多数情况下都可以互换。 此类型用于组成 DatetimeIndex 以及 Pandas 中其他面向时间序列的数据结构。</p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Timestamp.html">https://pandas.pydata.org/docs/reference/api/pandas.Timestamp.html</a></p><p>基本语法：</p><pre><code class="python">class pandas.Timestamp(ts_input=&lt;object object&gt;,                        freq=None, tz=None, unit=None,                        year=None, month=None, day=None,                        hour=None, minute=None, second=None,                        microsecond=None, nanosecond=None, tzinfo=None)</code></pre><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>ts_input</td><td>要转换为时间戳的对象，可以是 datetime-like，str，int，float 类型</td></tr><tr><td>freq</td><td>时间戳将具有的偏移量，可以是 str，日期偏移量类型，取值参见<a href="#t4">【02x02】freq 频率部分取值</a></td></tr><tr><td>tz</td><td>时间戳将具有的时区</td></tr><tr><td>unit</td><td>如果 ts_input 是整数或浮点数，该参数用于设置其单位（D、s、ms、us、ns）</td></tr></tbody></table><p>简单示例：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Timestamp(&#39;2017-01-01T12&#39;)Timestamp(&#39;2017-01-01 12:00:00&#39;)</code></pre><p>设置 <code>unit=&#39;s&#39;</code>，即待转换对象单位为秒：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Timestamp(1513393355.5, unit=&#39;s&#39;)Timestamp(&#39;2017-12-16 03:02:35.500000&#39;)</code></pre><p>使用 <code>tz</code> 参数设置时区：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Timestamp(1513393355, unit=&#39;s&#39;, tz=&#39;US/Pacific&#39;)Timestamp(&#39;2017-12-15 19:02:35-0800&#39;, tz=&#39;US/Pacific&#39;)</code></pre><p>单独设置年月日：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Timestamp(year=2020, month=6, day=24, hour=12)Timestamp(&#39;2020-06-24 12:00:00&#39;)</code></pre><h3 id="【02x02】freq-频率部分取值"><a href="#【02x02】freq-频率部分取值" class="headerlink" title="【02x02】freq 频率部分取值"></a><font color=#4876FF>【02x02】freq 频率部分取值</font></h3><p>完整取值参见官方文档：<a href="https://pandas.pydata.org/docs/user_guide/timeseries.html#timeseries-offset-aliases">https://pandas.pydata.org/docs/user_guide/timeseries.html#timeseries-offset-aliases</a></p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>D</td><td>Day</td><td>每日历日</td></tr><tr><td>B</td><td>BusinessDay</td><td>每工作日</td></tr><tr><td>H</td><td>Hour</td><td>每小时</td></tr><tr><td>T 或 min</td><td>Minute</td><td>每分</td></tr><tr><td>S</td><td>Second</td><td>每秒</td></tr><tr><td>L 或 ms</td><td>Milli</td><td>每毫秒（即每千分之一秒）</td></tr><tr><td>U</td><td>Micro</td><td>每微秒（即每百万分之一秒）</td></tr><tr><td>M</td><td>MonthEnd</td><td>每月最后一个日历日</td></tr><tr><td>BM</td><td>BusinessMonthEnd</td><td>每月最后一个工作日</td></tr><tr><td>MS</td><td>MonthBegin</td><td>每月第一个日历日</td></tr><tr><td>BMS</td><td>BusinessMonthBegin</td><td>每月第一个工作日</td></tr><tr><td>W-MON、W-TUE…</td><td>Week</td><td>从指定的星期几（MON、TUE、 WED、THU、FR、SAT、SUN）开始算起，每周</td></tr><tr><td>WoM-1MON、WOM-2MON…</td><td>WeekOfMonth</td><td>产生每月第一、第二、第三或第四周的星期几。例如，WoM-3FRI 表示每月第3个星期五</td></tr><tr><td>Q-JAN、Q-FEB…</td><td>QuarterEnd</td><td>对于以指定月份（JAN、FEB、MAR、APR、MAY、JUN、JUL、AUG、SEP、OCT、NOV、DEC）结束的年度，每季度最后一月的最后个日历日</td></tr><tr><td>BQ-JAN、BQ-FEB…</td><td>BusinessQuarterEnd</td><td>对于以指定月份结束的年度，每季度最后一月的最后一个工作日</td></tr><tr><td>QS-JAN、QS-FEB…</td><td>QuarterBegin</td><td>对于以指定月份结束的年度，每季度最后一月的第一个日历日</td></tr><tr><td>BQS-JAN、 BQS-FEB…</td><td>BusinessQuarterBegin</td><td>对于以指定月份结束的年度，每季度最后一月的第一个工作日</td></tr><tr><td>A-JAN、A-FEB…</td><td>YearEnd</td><td>每年指定月份（JAN、FEB、MAR、APR、MAY、JUN、JUL、AUG、SEP、 OCT、NOV、DEC）的最后一个日历日</td></tr><tr><td>BA-JAN、BA-FEB…</td><td>BusinessYearEnd</td><td>每年指定月份的最后一个工作日</td></tr><tr><td>AS-JAN、AS-FEB…</td><td>YearBegin</td><td>每年指定月份的第一个历日日</td></tr><tr><td>BAS-JAN、BAS-FEB…</td><td>BusinessYearBegin</td><td>每年指定月份的第一个工作日</td></tr></tbody></table><h3 id="【02x03】to-datetime"><a href="#【02x03】to-datetime" class="headerlink" title="【02x03】to_datetime"></a><font color=#4876FF>【02x03】to_datetime</font></h3><p>在 Python 中，datetime 库提供了日期和时间处理方法，利用 <code>str</code> 或 <code>strftime</code> 方法可以将 datetime 对象转化成字符串，具体用法可参见<a href="https://blog.csdn.net/qq_36759224/article/details/104427220">【Python 标准库学习】日期和时间处理库 — datetime</a>。</p><pre><code class="python">&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; stamp = datetime(2020, 6, 24)&gt;&gt;&gt; stampdatetime.datetime(2020, 6, 24, 0, 0)&gt;&gt;&gt;&gt;&gt;&gt; str(stamp)&#39;2020-06-24 00:00:00&#39;&gt;&gt;&gt; &gt;&gt;&gt; stamp.strftime(&#39;%Y-%m-%d&#39;)&#39;2020-06-24&#39;</code></pre><p><font color=#FF0000><strong>在 pandas 中 to_datetime 方法可以将字符串解析成多种不同的 Timestamp（时间戳） 对象：</strong></font></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; datestrs = &#39;2011-07-06 12:00:00&#39;&gt;&gt;&gt; type(datestrs)&lt;class &#39;str&#39;&gt;&gt;&gt;&gt; &gt;&gt;&gt; pd.to_datetime(datestrs)Timestamp(&#39;2011-07-06 12:00:00&#39;)</code></pre><p>基本语法：</p><pre><code class="python">pandas.to_datetime(arg, errors=&#39;raise&#39;, dayfirst=False,                    yearfirst=False, utc=None, format=None,                    exact=True, unit=None, infer_datetime_format=False,                    origin=&#39;unix&#39;, cache=True)</code></pre><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html">https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>arg</td><td>要转换为日期时间的对象，可以接受 int, float, str, datetime, list, tuple, 1-d array, Series DataFrame/dict-like 类型</td></tr><tr><td>errors</td><td>如果字符串不满足时间戳的形式，是否会发生异常<br><code>ignore</code>：不引发异常，返回原始输入；<code>raise</code>：无效解析将引发异常（默认）；<code>coerce</code>：无效解析将被设置为NaT</td></tr><tr><td>dayfirst</td><td>bool 类型，默认 False，如果 arg 是 str 或列表，是否首先解析为日期<br>例如 dayfirst 为 True，<code>10/11/12</code> 被解析为 <code>2012-11-10</code>，为 False 则解析为 <code>2012-10-11</code></td></tr><tr><td>yearfirst</td><td>bool 类型，默认 False，如果 arg 是 str 或列表，是否首先解析为年份<br>例如 dayfirst 为 True，<code>10/11/12</code> 被解析为 <code>2010-11-12</code>，为 False 则解析为 <code>2012-10-11</code><br>如果 dayfirst 和 yearfirst 都为 True，则优先 yearfirst</td></tr><tr><td>utc</td><td>bool 类型，是否转换为协调世界时，默认 None</td></tr><tr><td>format</td><td>格式化时间，如 <code>21/2/20 16:10</code> 使用 <code>%d/%m/%y %H:%M</code> 会被解析为 <code>2020-02-21 16:10:00</code><br>符号含义常见文章：<a href="https://blog.csdn.net/qq_36759224/article/details/104427220">【Python 标准库学习】日期和时间处理库 — datetime</a> 或者<a href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior">官方文档</a></td></tr><tr><td>exact</td><td>如果为 True，则需要精确的格式匹配。如果为 False，则允许格式与目标字符串中的任何位置匹配</td></tr><tr><td>unit</td><td>如果 arg 是整数或浮点数，该参数用于设置其单位（D、s、ms、us、ns）</td></tr></tbody></table><p>简单应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;year&#39;: [2015, 2016], &#39;month&#39;: [2, 3], &#39;day&#39;: [4, 5]&#125;)&gt;&gt;&gt; obj   year  month  day0  2015      2    41  2016      3    5&gt;&gt;&gt; &gt;&gt;&gt; pd.to_datetime(obj)0   2015-02-041   2016-03-05dtype: datetime64[ns]</code></pre><p>设置 <code>format</code> 和 <code>errors</code> 参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.to_datetime(&#39;13000101&#39;, format=&#39;%Y%m%d&#39;, errors=&#39;ignore&#39;)datetime.datetime(1300, 1, 1, 0, 0)&gt;&gt;&gt; &gt;&gt;&gt; pd.to_datetime(&#39;13000101&#39;, format=&#39;%Y%m%d&#39;, errors=&#39;coerce&#39;)NaT&gt;&gt;&gt; &gt;&gt;&gt; pd.to_datetime(&#39;13000101&#39;, format=&#39;%Y%m%d&#39;, errors=&#39;raise&#39;)Traceback (most recent call last):...pandas._libs.tslibs.np_datetime.OutOfBoundsDatetime: Out of bounds nanosecond timestamp: 1300-01-01 00:00:00</code></pre><p>设置 <code>unit</code> 参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.to_datetime(1490195805, unit=&#39;s&#39;)Timestamp(&#39;2017-03-22 15:16:45&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.to_datetime(1490195805433502912, unit=&#39;ns&#39;)Timestamp(&#39;2017-03-22 15:16:45.433502912&#39;)</code></pre><h3 id="【02x04】date-range"><a href="#【02x04】date-range" class="headerlink" title="【02x04】date_range"></a><font color=#4876FF>【02x04】date_range</font></h3><p><code>pandas.date_range</code> 方法可用于根据指定的频率生成指定长度的 DatetimeIndex。</p><p>基本语法：</p><pre><code class="python">pandas.date_range(start=None, end=None, periods=None, freq=None,                   tz=None, normalize=False, name=None, closed=None,                   **kwargs) → pandas.core.indexes.datetimes.DatetimeIndex</code></pre><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.date_range.html">https://pandas.pydata.org/docs/reference/api/pandas.date_range.html</a></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>开始日期</td></tr><tr><td>end</td><td>结束日期</td></tr><tr><td>periods</td><td>int 类型，要生成的时段数（天）</td></tr><tr><td>freq</td><td>频率字符串，即按照某种特定的频率来生成日期，取值参见<a href="#t4">【02x02】freq 频率部分取值</a></td></tr><tr><td>tz</td><td>设置时区，例如 “Asia/Hong_Kong”</td></tr><tr><td>normalize</td><td>bool 类型，默认 False，是否在生成日期之前对其进行规范化（仅保留年月日）</td></tr><tr><td>name</td><td>结果 DatetimeIndex 的名称</td></tr><tr><td>closed</td><td><code>None</code>：默认值，同时保留开始日期和结束日期<br><code>&#39;left&#39;</code>：保留开始日期，不保留结束日期<br><code>&#39;right&#39;</code>：保留结束日期，不保留开始日期</td></tr></tbody></table><p>简单示例：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, end=&#39;1/08/2018&#39;)DatetimeIndex([&#39;2018-01-01&#39;, &#39;2018-01-02&#39;, &#39;2018-01-03&#39;, &#39;2018-01-04&#39;,               &#39;2018-01-05&#39;, &#39;2018-01-06&#39;, &#39;2018-01-07&#39;, &#39;2018-01-08&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</code></pre><p>指定 <code>periods</code> 参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(start=&#39;2012-04-01&#39;, periods=20)DatetimeIndex([&#39;2012-04-01&#39;, &#39;2012-04-02&#39;, &#39;2012-04-03&#39;, &#39;2012-04-04&#39;,               &#39;2012-04-05&#39;, &#39;2012-04-06&#39;, &#39;2012-04-07&#39;, &#39;2012-04-08&#39;,               &#39;2012-04-09&#39;, &#39;2012-04-10&#39;, &#39;2012-04-11&#39;, &#39;2012-04-12&#39;,               &#39;2012-04-13&#39;, &#39;2012-04-14&#39;, &#39;2012-04-15&#39;, &#39;2012-04-16&#39;,               &#39;2012-04-17&#39;, &#39;2012-04-18&#39;, &#39;2012-04-19&#39;, &#39;2012-04-20&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.date_range(end=&#39;2012-06-01&#39;, periods=20)DatetimeIndex([&#39;2012-05-13&#39;, &#39;2012-05-14&#39;, &#39;2012-05-15&#39;, &#39;2012-05-16&#39;,               &#39;2012-05-17&#39;, &#39;2012-05-18&#39;, &#39;2012-05-19&#39;, &#39;2012-05-20&#39;,               &#39;2012-05-21&#39;, &#39;2012-05-22&#39;, &#39;2012-05-23&#39;, &#39;2012-05-24&#39;,               &#39;2012-05-25&#39;, &#39;2012-05-26&#39;, &#39;2012-05-27&#39;, &#39;2012-05-28&#39;,               &#39;2012-05-29&#39;, &#39;2012-05-30&#39;, &#39;2012-05-31&#39;, &#39;2012-06-01&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)&gt;&gt;&gt;&gt;&gt;&gt; pd.date_range(start=&#39;2018-04-24&#39;, end=&#39;2018-04-27&#39;, periods=3)DatetimeIndex([&#39;2018-04-24 00:00:00&#39;, &#39;2018-04-25 12:00:00&#39;, &#39;2018-04-27 00:00:00&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=None)&gt;&gt;&gt;&gt;&gt;&gt; pd.date_range(start=&#39;2018-04-24&#39;, end=&#39;2018-04-28&#39;, periods=3)DatetimeIndex([&#39;2018-04-24&#39;, &#39;2018-04-26&#39;, &#39;2018-04-28&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</code></pre><p>指定 <code>freq=&#39;M&#39;</code> 会按照每月最后一个日历日的频率生成日期，指定 <code>freq=&#39;3M&#39;</code> 会每隔3个月按照每月最后一个日历日的频率生成日期：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, periods=5, freq=&#39;M&#39;)DatetimeIndex([&#39;2018-01-31&#39;, &#39;2018-02-28&#39;, &#39;2018-03-31&#39;, &#39;2018-04-30&#39;,               &#39;2018-05-31&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, periods=5, freq=&#39;3M&#39;)DatetimeIndex([&#39;2018-01-31&#39;, &#39;2018-04-30&#39;, &#39;2018-07-31&#39;, &#39;2018-10-31&#39;,               &#39;2019-01-31&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;3M&#39;)&gt;&gt;&gt; </code></pre><p>使用 <code>tz</code> 参数设置时区：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, periods=5, tz=&#39;Asia/Tokyo&#39;)DatetimeIndex([&#39;2018-01-01 00:00:00+09:00&#39;, &#39;2018-01-02 00:00:00+09:00&#39;,               &#39;2018-01-03 00:00:00+09:00&#39;, &#39;2018-01-04 00:00:00+09:00&#39;,               &#39;2018-01-05 00:00:00+09:00&#39;],              dtype=&#39;datetime64[ns, Asia/Tokyo]&#39;, freq=&#39;D&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.date_range(start=&#39;6/24/2020&#39;, periods=5, tz=&#39;Asia/Hong_Kong&#39;)DatetimeIndex([&#39;2020-06-24 00:00:00+08:00&#39;, &#39;2020-06-25 00:00:00+08:00&#39;,               &#39;2020-06-26 00:00:00+08:00&#39;, &#39;2020-06-27 00:00:00+08:00&#39;,               &#39;2020-06-28 00:00:00+08:00&#39;],              dtype=&#39;datetime64[ns, Asia/Hong_Kong]&#39;, freq=&#39;D&#39;)</code></pre><p>设置 <code>normalize</code> 参数，在生成时间戳之前对其进行格式化操作：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(&#39;2020-06-24 12:56:31&#39;, periods=5, normalize=True)DatetimeIndex([&#39;2020-06-24&#39;, &#39;2020-06-25&#39;, &#39;2020-06-26&#39;, &#39;2020-06-27&#39;,               &#39;2020-06-28&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</code></pre><p>设置 <code>closed</code> 参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(start=&#39;2020-06-20&#39;, end=&#39;2020-06-24&#39;, closed=None)DatetimeIndex([&#39;2020-06-20&#39;, &#39;2020-06-21&#39;, &#39;2020-06-22&#39;, &#39;2020-06-23&#39;,               &#39;2020-06-24&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.date_range(start=&#39;2020-06-20&#39;, end=&#39;2020-06-24&#39;, closed=&#39;left&#39;)DatetimeIndex([&#39;2020-06-20&#39;, &#39;2020-06-21&#39;, &#39;2020-06-22&#39;, &#39;2020-06-23&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.date_range(start=&#39;2020-06-20&#39;, end=&#39;2020-06-24&#39;, closed=&#39;right&#39;)DatetimeIndex([&#39;2020-06-21&#39;, &#39;2020-06-22&#39;, &#39;2020-06-23&#39;, &#39;2020-06-24&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</code></pre><h3 id="【02x05】索引与切片"><a href="#【02x05】索引与切片" class="headerlink" title="【02x05】索引与切片"></a><font color=#4876FF>【02x05】索引与切片</font></h3><p>Pandas 最基本的时间序列类型就是以时间戳（通常以 Python 字符串或 datatime 对象表示）为索引的Series，这些 datetime 对象实际上是被放在 DatetimeIndex 中的，可以使用类似 pandas.Series 对象的切片方法对其进行索引：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; dates = [datetime(2011, 1, 2), datetime(2011, 1, 5),             datetime(2011, 1, 7), datetime(2011, 1, 8),             datetime(2011, 1, 10), datetime(2011, 1, 12)]&gt;&gt;&gt; obj = pd.Series(np.random.randn(6), index=dates)&gt;&gt;&gt; &gt;&gt;&gt; obj2011-01-02   -0.4071102011-01-05   -0.1866612011-01-07   -0.7310802011-01-08    0.8609702011-01-10    1.9299732011-01-12   -0.168599dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.indexDatetimeIndex([&#39;2011-01-02&#39;, &#39;2011-01-05&#39;, &#39;2011-01-07&#39;, &#39;2011-01-08&#39;,               &#39;2011-01-10&#39;, &#39;2011-01-12&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=None)&gt;&gt;&gt;&gt;&gt;&gt; obj.index[0]Timestamp(&#39;2011-01-02 00:00:00&#39;)&gt;&gt;&gt; &gt;&gt;&gt; obj.index[0:3]DatetimeIndex([&#39;2011-01-02&#39;, &#39;2011-01-05&#39;, &#39;2011-01-07&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</code></pre><p>另外还可以传入一个可以被解释为日期的字符串，或者只需传入“年”或“年月”即可轻松选取数据的切片：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series(np.random.randn(1000), index=pd.date_range(&#39;1/1/2000&#39;, periods=1000))&gt;&gt;&gt; obj2000-01-01   -1.1422842000-01-02    1.1987852000-01-03    2.4669092000-01-04   -0.0867282000-01-05   -0.978437                ...   2002-09-22   -0.2522402002-09-23    0.1485612002-09-24   -1.3304092002-09-25   -0.6734712002-09-26   -0.253271Freq: D, Length: 1000, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;26/9/2002&#39;]-0.25327100684233356&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;2002&#39;]2002-01-01    1.0587152002-01-02    0.9008592002-01-03    1.9935082002-01-04   -0.1032112002-01-05   -0.950090                ...   2002-09-22   -0.2522402002-09-23    0.1485612002-09-24   -1.3304092002-09-25   -0.6734712002-09-26   -0.253271Freq: D, Length: 269, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;2002-09&#39;]2002-09-01   -0.9955282002-09-02    0.5015282002-09-03   -0.4867532002-09-04   -1.0839062002-09-05    1.4589752002-09-06   -1.3316852002-09-07    0.1953382002-09-08   -0.4296132002-09-09    1.1258232002-09-10    1.6070512002-09-11    0.5303872002-09-12   -0.0159382002-09-13    1.7810432002-09-14   -0.2771232002-09-15    0.3445692002-09-16   -1.0108102002-09-17    0.4630012002-09-18    1.8836362002-09-19    0.2745202002-09-20    0.6241842002-09-21   -1.2030572002-09-22   -0.2522402002-09-23    0.1485612002-09-24   -1.3304092002-09-25   -0.6734712002-09-26   -0.253271Freq: D, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;20/9/2002&#39;:&#39;26/9/2002&#39;]2002-09-20    0.6241842002-09-21   -1.2030572002-09-22   -0.2522402002-09-23    0.1485612002-09-24   -1.3304092002-09-25   -0.6734712002-09-26   -0.253271Freq: D, dtype: float64</code></pre><h3 id="【02x06】移动数据与数据偏移"><a href="#【02x06】移动数据与数据偏移" class="headerlink" title="【02x06】移动数据与数据偏移"></a><font color=#4876FF>【02x06】移动数据与数据偏移</font></h3><p>移动（shifting）指的是沿着时间轴将数据前移或后移。Series 和 DataFrame 都有一个 shift 方法用于执行单纯的前移或后移操作，保持索引不变：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series(np.random.randn(4),            index=pd.date_range(&#39;1/1/2000&#39;, periods=4, freq=&#39;M&#39;))&gt;&gt;&gt; obj2000-01-31   -0.1002172000-02-29    1.1778342000-03-31   -0.6443532000-04-30   -1.954679Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.shift(2)2000-01-31         NaN2000-02-29         NaN2000-03-31   -0.1002172000-04-30    1.177834Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.shift(-2)2000-01-31   -0.6443532000-02-29   -1.9546792000-03-31         NaN2000-04-30         NaNFreq: M, dtype: float64</code></pre><p>因为简单的移位操作不会修改索引，所以部分数据会被丢弃并引入 NaN（缺失值）。因此，如果频率已知，则可以将其传给 shift 以便实现对时间戳进行位移而不是对数据进行简单位移：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series(np.random.randn(4),            index=pd.date_range(&#39;1/1/2000&#39;, periods=4, freq=&#39;M&#39;))&gt;&gt;&gt; obj2000-01-31   -0.1002172000-02-29    1.1778342000-03-31   -0.6443532000-04-30   -1.954679Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.shift(2, freq=&#39;M&#39;)2000-03-31   -0.1002172000-04-30    1.1778342000-05-31   -0.6443532000-06-30   -1.954679Freq: M, dtype: float64</code></pre><p>Pandas 中的频率是由一个基础频率（base frequency）和一个乘数组成的。基础频率通常以一个字符串别名表示，比如 <code>&quot;M&quot;</code> 表示每月，<code>&quot;H&quot;</code> 表示每小时。对于每个基础频率，都有一个被称为日期偏移量（date offset）的对象与之对应。例如，按小时计算的频率可以用 <code>Hour</code> 类表示：</p><pre><code class="python">&gt;&gt;&gt; from pandas.tseries.offsets import Hour, Minute&gt;&gt;&gt; hour = Hour()&gt;&gt;&gt; hour&lt;Hour&gt;&gt;&gt;&gt; &gt;&gt;&gt; four_hours = Hour(4)&gt;&gt;&gt; four_hours&lt;4 * Hours&gt;</code></pre><p>一般来说，无需明确创建这样的对象，只需使用诸如 <code>&quot;H&quot;</code> 或 <code>&quot;4H&quot;</code> 这样的字符串别名即可。在基础频率前面放上一个整数即可创建倍数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(&#39;2000-01-01&#39;, &#39;2000-01-03 23:59&#39;, freq=&#39;4h&#39;)DatetimeIndex([&#39;2000-01-01 00:00:00&#39;, &#39;2000-01-01 04:00:00&#39;,               &#39;2000-01-01 08:00:00&#39;, &#39;2000-01-01 12:00:00&#39;,               &#39;2000-01-01 16:00:00&#39;, &#39;2000-01-01 20:00:00&#39;,               &#39;2000-01-02 00:00:00&#39;, &#39;2000-01-02 04:00:00&#39;,               &#39;2000-01-02 08:00:00&#39;, &#39;2000-01-02 12:00:00&#39;,               &#39;2000-01-02 16:00:00&#39;, &#39;2000-01-02 20:00:00&#39;,               &#39;2000-01-03 00:00:00&#39;, &#39;2000-01-03 04:00:00&#39;,               &#39;2000-01-03 08:00:00&#39;, &#39;2000-01-03 12:00:00&#39;,               &#39;2000-01-03 16:00:00&#39;, &#39;2000-01-03 20:00:00&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;4H&#39;)</code></pre><p>大部分偏移量对象都可通过加法进行连接：</p><pre><code class="python">&gt;&gt;&gt; from pandas.tseries.offsets import Hour, Minute&gt;&gt;&gt; Hour(2) + Minute(30)&lt;150 * Minutes&gt;</code></pre><p>对于 <code>freq</code> 参数也可以传入频率字符串（如 <code>&quot;2h30min&quot;</code>），这种字符串可以被高效地解析为等效的表达式：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.date_range(&#39;2000-01-01&#39;, periods=10, freq=&#39;1h30min&#39;)DatetimeIndex([&#39;2000-01-01 00:00:00&#39;, &#39;2000-01-01 01:30:00&#39;,               &#39;2000-01-01 03:00:00&#39;, &#39;2000-01-01 04:30:00&#39;,               &#39;2000-01-01 06:00:00&#39;, &#39;2000-01-01 07:30:00&#39;,               &#39;2000-01-01 09:00:00&#39;, &#39;2000-01-01 10:30:00&#39;,               &#39;2000-01-01 12:00:00&#39;, &#39;2000-01-01 13:30:00&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;90T&#39;)</code></pre><p>这种偏移量还可以用在 datetime 或 Timestamp 对象上：</p><pre><code class="python">&gt;&gt;&gt; from pandas.tseries.offsets import Day, MonthEnd&gt;&gt;&gt; now = datetime(2011, 11, 17)&gt;&gt;&gt; now + 3 * Day()Timestamp(&#39;2011-11-20 00:00:00&#39;)</code></pre><p>如果加的是锚点偏移量，比如 MonthEnd，第一次增量会将原日期向前滚动到符合频率规则的下一个日期：</p><pre><code class="python">&gt;&gt;&gt; from pandas.tseries.offsets import Day, MonthEnd&gt;&gt;&gt; now = datetime(2011, 11, 17)&gt;&gt;&gt; now + MonthEnd()Timestamp(&#39;2011-11-30 00:00:00&#39;)&gt;&gt;&gt; now + MonthEnd(2)Timestamp(&#39;2011-12-31 00:00:00&#39;)</code></pre><p>通过锚点偏移量的 rollforward 和 rollback 方法，可明确地将日期向前或向后滚动：</p><pre><code class="python">&gt;&gt;&gt; from pandas.tseries.offsets import Day, MonthEnd&gt;&gt;&gt; now = datetime(2011, 11, 17)&gt;&gt;&gt; offset = MonthEnd()&gt;&gt;&gt; offset.rollforward(now)Timestamp(&#39;2011-11-30 00:00:00&#39;)&gt;&gt;&gt; offset.rollback(now)Timestamp(&#39;2011-10-31 00:00:00&#39;)</code></pre><p>与 <code>groupby</code> 方法结合使用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; from pandas.tseries.offsets import Day, MonthEnd&gt;&gt;&gt; obj = pd.Series(np.random.randn(20),            index=pd.date_range(&#39;1/15/2000&#39;, periods=20, freq=&#39;4d&#39;))&gt;&gt;&gt; obj2000-01-15   -0.5917292000-01-19   -0.7758442000-01-23   -0.7456032000-01-27   -0.0764392000-01-31    1.7964172000-02-04   -0.5003492000-02-08    0.5158512000-02-12   -0.3441712000-02-16    0.4196572000-02-20    0.3072882000-02-24    0.1151132000-02-28   -0.3625852000-03-03    1.0748922000-03-07    1.1113662000-03-11    0.9499102000-03-15   -1.5357272000-03-19    0.5459442000-03-23   -0.8101392000-03-27   -1.2606272000-03-31   -0.128403Freq: 4D, dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; offset = MonthEnd()&gt;&gt;&gt; obj.groupby(offset.rollforward).mean()2000-01-31   -0.0786402000-02-29    0.0215432000-03-31   -0.006598dtype: float64</code></pre><h3 id="【02x07】时区处理"><a href="#【02x07】时区处理" class="headerlink" title="【02x07】时区处理"></a><font color=#4876FF>【02x07】时区处理</font></h3><p>在 Python 中，时区信息来自第三方库 pytz，使用 <code>pytz.common_timezones</code> 方法可以查看所有的时区名称，使用 <code>pytz.timezone</code> 方法从 pytz 中获取时区对象：</p><pre><code class="python">&gt;&gt;&gt; import pytz&gt;&gt;&gt; pytz.common_timezones[&#39;Africa/Abidjan&#39;, &#39;Africa/Accra&#39;, &#39;Africa/Addis_Ababa&#39;, ..., &#39;UTC&#39;]&gt;&gt;&gt;&gt;&gt;&gt; tz = pytz.timezone(&#39;Asia/Shanghai&#39;)&gt;&gt;&gt; tz&lt;DstTzInfo &#39;Asia/Shanghai&#39; LMT+8:06:00 STD&gt;  # 表示与 UTC 时间相差8小时6分</code></pre><p>在 <code>date_range</code> 方法中，<code>tz</code> 参数用于指定时区，默认为 None，可以使用 <code>tz_localize</code> 方法将其进行本地化时区转换，如下示例中，将无时区转本地化 UTC 时区：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; rng = pd.date_range(&#39;3/9/2012 9:30&#39;, periods=6, freq=&#39;D&#39;)&gt;&gt;&gt; ts = pd.Series(np.random.randn(len(rng)), index=rng)&gt;&gt;&gt; ts2012-03-09 09:30:00   -1.5279132012-03-10 09:30:00   -1.1161012012-03-11 09:30:00    0.3593582012-03-12 09:30:00   -0.4759202012-03-13 09:30:00   -0.3365702012-03-14 09:30:00   -1.075952Freq: D, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; print(ts.index.tz)None&gt;&gt;&gt; &gt;&gt;&gt; ts_utc = ts.tz_localize(&#39;UTC&#39;)&gt;&gt;&gt; ts_utc2012-03-09 09:30:00+00:00   -1.5279132012-03-10 09:30:00+00:00   -1.1161012012-03-11 09:30:00+00:00    0.3593582012-03-12 09:30:00+00:00   -0.4759202012-03-13 09:30:00+00:00   -0.3365702012-03-14 09:30:00+00:00   -1.075952Freq: D, dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; ts_utc.indexDatetimeIndex([&#39;2012-03-09 09:30:00+00:00&#39;, &#39;2012-03-10 09:30:00+00:00&#39;,               &#39;2012-03-11 09:30:00+00:00&#39;, &#39;2012-03-12 09:30:00+00:00&#39;,               &#39;2012-03-13 09:30:00+00:00&#39;, &#39;2012-03-14 09:30:00+00:00&#39;],              dtype=&#39;datetime64[ns, UTC]&#39;, freq=&#39;D&#39;)</code></pre><p>时间序列被本地化到某个特定时区后，就可以用 <code>tz_convert</code> 方法将其转换到别的时区了：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; rng = pd.date_range(&#39;3/9/2012 9:30&#39;, periods=6, freq=&#39;D&#39;)&gt;&gt;&gt; ts = pd.Series(np.random.randn(len(rng)), index=rng)&gt;&gt;&gt; ts2012-03-09 09:30:00    0.4803032012-03-10 09:30:00   -1.4610392012-03-11 09:30:00   -1.5127492012-03-12 09:30:00   -2.1854212012-03-13 09:30:00    1.6578452012-03-14 09:30:00    0.175633Freq: D, dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; ts.tz_localize(&#39;UTC&#39;).tz_convert(&#39;Asia/Shanghai&#39;)2012-03-09 17:30:00+08:00    0.4803032012-03-10 17:30:00+08:00   -1.4610392012-03-11 17:30:00+08:00   -1.5127492012-03-12 17:30:00+08:00   -2.1854212012-03-13 17:30:00+08:00    1.6578452012-03-14 17:30:00+08:00    0.175633Freq: D, dtype: float64</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106947061未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【03x00】period-固定时期"><a href="#【03x00】period-固定时期" class="headerlink" title="【03x00】period 固定时期"></a><font color=#FF0000>【03x00】period 固定时期</font></h2><h3 id="【03x01】pandas-Period"><a href="#【03x01】pandas-Period" class="headerlink" title="【03x01】pandas.Period"></a><font color=#4876FF>【03x01】pandas.Period</font></h3><p>固定时期（period）表示的是时间区间，比如数日、数月、数季、数年等。Period 类所表示的就是这种数据类型，其构造函数需要用到一个字符串或整数。</p><p>基本语法：</p><pre><code class="python">class pandas.Period(value=None, freq=None, ordinal=None,                     year=None, month=None, quarter=None,                     day=None, hour=None, minute=None, second=None)</code></pre><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Period.html">https://pandas.pydata.org/docs/reference/api/pandas.Period.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>时间段</td></tr><tr><td>freq</td><td>时间戳将具有的偏移量，可以是 str，日期偏移量类型，取值参见<a href="#t4">【02x02】freq 频率部分取值</a></td></tr></tbody></table><p>以下示例中，Period 对象表示的是从2020年1月1日到2020年12月31日之间的整段时间</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Period(2020, freq=&#39;A-DEC&#39;)Period(&#39;2020&#39;, &#39;A-DEC&#39;)</code></pre><p>利用加减法对其按照频率进行位移：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Period(2020, freq=&#39;A-DEC&#39;)&gt;&gt;&gt; objPeriod(&#39;2020&#39;, &#39;A-DEC&#39;)&gt;&gt;&gt; &gt;&gt;&gt; obj + 5Period(&#39;2025&#39;, &#39;A-DEC&#39;)&gt;&gt;&gt; &gt;&gt;&gt; obj - 5Period(&#39;2015&#39;, &#39;A-DEC&#39;)</code></pre><p>PeriodIndex 类保存了一组 Period，它可以在任何 pandas 数据结构中被用作轴索引：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; rng = [pd.Period(&#39;2000-01&#39;), pd.Period(&#39;2000-02&#39;), pd.Period(&#39;2000-03&#39;),            pd.Period(&#39;2000-04&#39;), pd.Period(&#39;2000-05&#39;), pd.Period(&#39;2000-06&#39;)]&gt;&gt;&gt; obj = pd.Series(np.random.randn(6), index=rng)&gt;&gt;&gt; obj2000-01    0.2290922000-02    1.5154982000-03   -0.3344012000-04   -0.4926812000-05   -2.0128182000-06    0.338804Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.indexPeriodIndex([&#39;2000-01&#39;, &#39;2000-02&#39;, &#39;2000-03&#39;, &#39;2000-04&#39;, &#39;2000-05&#39;, &#39;2000-06&#39;], dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)</code></pre><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; values = [&#39;2001Q3&#39;, &#39;2002Q2&#39;, &#39;2003Q1&#39;]&gt;&gt;&gt; index = pd.PeriodIndex(values, freq=&#39;Q-DEC&#39;)&gt;&gt;&gt; indexPeriodIndex([&#39;2001Q3&#39;, &#39;2002Q2&#39;, &#39;2003Q1&#39;], dtype=&#39;period[Q-DEC]&#39;, freq=&#39;Q-DEC&#39;)&gt;&gt;&gt; </code></pre><h3 id="【03x02】period-range"><a href="#【03x02】period-range" class="headerlink" title="【03x02】period_range"></a><font color=#4876FF>【03x02】period_range</font></h3><p><code>pandas.period_range</code> 方法可根据指定的频率生成指定长度的 PeriodIndex。</p><p>基本语法：</p><p><code>pandas.period_range(start=None, end=None, periods=None, freq=None, name=None) → pandas.core.indexes.period.PeriodIndex</code></p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.period_range.html">https://pandas.pydata.org/docs/reference/api/pandas.period_range.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>起始日期</td></tr><tr><td>end</td><td>结束日期</td></tr><tr><td>periods</td><td>要生成的时段数</td></tr><tr><td>freq</td><td>时间戳将具有的偏移量，可以是 str，日期偏移量类型，取值参见<a href="#t4">【02x02】freq 频率部分取值</a></td></tr><tr><td>name</td><td>结果 PeriodIndex 对象名称</td></tr></tbody></table><p>简单应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.period_range(start=&#39;2019-01-01&#39;, end=&#39;2020-01-01&#39;, freq=&#39;M&#39;)PeriodIndex([&#39;2019-01&#39;, &#39;2019-02&#39;, &#39;2019-03&#39;, &#39;2019-04&#39;, &#39;2019-05&#39;, &#39;2019-06&#39;,             &#39;2019-07&#39;, &#39;2019-08&#39;, &#39;2019-09&#39;, &#39;2019-10&#39;, &#39;2019-11&#39;, &#39;2019-12&#39;,             &#39;2020-01&#39;],            dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)&gt;&gt;&gt;&gt;&gt;&gt; pd.period_range(start=pd.Period(&#39;2017Q1&#39;, freq=&#39;Q&#39;),                    end=pd.Period(&#39;2017Q2&#39;, freq=&#39;Q&#39;), freq=&#39;M&#39;)PeriodIndex([&#39;2017-03&#39;, &#39;2017-04&#39;, &#39;2017-05&#39;, &#39;2017-06&#39;], dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)</code></pre><h3 id="【03x03】asfreq-时期频率转换"><a href="#【03x03】asfreq-时期频率转换" class="headerlink" title="【03x03】asfreq 时期频率转换"></a><font color=#4876FF>【03x03】asfreq 时期频率转换</font></h3><p>Period 和 PeriodIndex 对象都可以通过 asfreq 方法被转换成别的频率。</p><p>基本语法：<code>PeriodIndex.asfreq(self, *args, **kwargs)</code></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>freq</td><td>新的频率（偏移量），取值参见<a href="#t4">【02x02】freq 频率部分取值</a></td></tr><tr><td>how</td><td>按照开始或者结束对齐，<code>&#39;E&#39;</code> or <code>&#39;END&#39;</code> or <code>&#39;FINISH&#39;</code>；<code>&#39;S&#39;</code> or <code>&#39;START&#39;</code> or <code>&#39;BEGIN&#39;</code></td></tr></tbody></table><p>应用示例：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pidx = pd.period_range(&#39;2010-01-01&#39;, &#39;2015-01-01&#39;, freq=&#39;A&#39;)&gt;&gt;&gt; pidxPeriodIndex([&#39;2010&#39;, &#39;2011&#39;, &#39;2012&#39;, &#39;2013&#39;, &#39;2014&#39;, &#39;2015&#39;], dtype=&#39;period[A-DEC]&#39;, freq=&#39;A-DEC&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pidx.asfreq(&#39;M&#39;)PeriodIndex([&#39;2010-12&#39;, &#39;2011-12&#39;, &#39;2012-12&#39;, &#39;2013-12&#39;, &#39;2014-12&#39;, &#39;2015-12&#39;], dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pidx.asfreq(&#39;M&#39;, how=&#39;S&#39;)PeriodIndex([&#39;2010-01&#39;, &#39;2011-01&#39;, &#39;2012-01&#39;, &#39;2013-01&#39;, &#39;2014-01&#39;, &#39;2015-01&#39;], dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)</code></pre><h3 id="【03x04】to-period-与-to-timestamp"><a href="#【03x04】to-period-与-to-timestamp" class="headerlink" title="【03x04】to_period 与 to_timestamp()"></a><font color=#4876FF>【03x04】to_period 与 to_timestamp()</font></h3><p><code>to_period</code> 方法可以将 Timestamp（时间戳） 转换为 Period（固定时期）；</p><p><code>to_timestamp</code> 方法可以将 Period（固定时期）转换为 Timestamp（时间戳） 。</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; rng = pd.date_range(&#39;2000-01-01&#39;, periods=3, freq=&#39;M&#39;)&gt;&gt;&gt; ts = pd.Series(np.random.randn(3), index=rng)&gt;&gt;&gt; ts2000-01-31    0.2207592000-02-29   -0.1082212000-03-31    0.819433Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; pts = ts.to_period()&gt;&gt;&gt; pts2000-01    0.2207592000-02   -0.1082212000-03    0.819433Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; pts2 = pts.to_timestamp()&gt;&gt;&gt; pts22000-01-01    0.2207592000-02-01   -0.1082212000-03-01    0.819433Freq: MS, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; ts.indexDatetimeIndex([&#39;2000-01-31&#39;, &#39;2000-02-29&#39;, &#39;2000-03-31&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pts.indexPeriodIndex([&#39;2000-01&#39;, &#39;2000-02&#39;, &#39;2000-03&#39;], dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pts2.indexDatetimeIndex([&#39;2000-01-01&#39;, &#39;2000-02-01&#39;, &#39;2000-03-01&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;MS&#39;)</code></pre><h2 id="【04x00】timedelta-时间间隔"><a href="#【04x00】timedelta-时间间隔" class="headerlink" title="【04x00】timedelta 时间间隔"></a><font color=#FF0000>【04x00】timedelta 时间间隔</font></h2><h3 id="【04x01】pandas-Timedelta"><a href="#【04x01】pandas-Timedelta" class="headerlink" title="【04x01】pandas.Timedelta"></a><font color=#4876FF>【04x01】pandas.Timedelta</font></h3><p>Timedelta 表示持续时间，即两个日期或时间之间的差。</p><p>Timedelta 相当于 Python 的 datetime.timedelta，在大多数情况下两者可以互换。</p><p>基本语法：<code>class pandas.Timedelta(value=&lt;object object&gt;, unit=None, **kwargs)</code></p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Timedelta.html">https://pandas.pydata.org/docs/reference/api/pandas.Timedelta.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>传入的值，可以是 Timedelta，timedelta，np.timedelta64，string 或 integer 对象</td></tr><tr><td>unit</td><td>用于设置 value 的单位，具体取值参见官方文档</td></tr></tbody></table><p>表示两个 datetime 对象之间的时间差：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.to_datetime(&#39;2020-6-24&#39;) - pd.to_datetime(&#39;2016-1-1&#39;)Timedelta(&#39;1636 days 00:00:00&#39;)</code></pre><p>通过字符串传递参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Timedelta(&#39;3 days 3 hours 3 minutes 30 seconds&#39;)Timedelta(&#39;3 days 03:03:30&#39;)</code></pre><p>通过整数传递参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Timedelta(5,unit=&#39;h&#39;)Timedelta(&#39;0 days 05:00:00&#39;)</code></pre><p>获取属性：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Timedelta(&#39;3 days 3 hours 3 minutes 30 seconds&#39;)&gt;&gt;&gt; objTimedelta(&#39;3 days 03:03:30&#39;)&gt;&gt;&gt; &gt;&gt;&gt; obj.days3&gt;&gt;&gt; obj.seconds11010</code></pre><h3 id="【04x02】to-timedelta"><a href="#【04x02】to-timedelta" class="headerlink" title="【04x02】to_timedelta"></a><font color=#4876FF>【04x02】to_timedelta</font></h3><p>to_timedelta 方法可以将传入的对象转换成 timedelta 对象。</p><p>基本语法：<code>pandas.to_timedelta(arg, unit=&#39;ns&#39;, errors=&#39;raise&#39;)</code></p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.to_timedelta.html">https://pandas.pydata.org/docs/reference/api/pandas.to_timedelta.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>arg</td><td>要转换为 timedelta 的对象，可以是 str，timedelta，list-like 或 Series 对象</td></tr><tr><td>unit</td><td>用于设置 arg 的单位，具体取值参见官方文档</td></tr><tr><td>errors</td><td>如果 arg 不满足时间戳的形式，是否会发生异常<br><code>ignore</code>：不引发异常，返回原始输入；<code>raise</code>：无效解析将引发异常（默认）；<code>coerce</code>：无效解析将被设置为NaT</td></tr></tbody></table><p>将单个字符串解析为 timedelta 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.to_timedelta(&#39;1 days 06:05:01.00003&#39;)Timedelta(&#39;1 days 06:05:01.000030&#39;)&gt;&gt;&gt;&gt;&gt;&gt; pd.to_timedelta(&#39;15.5us&#39;)Timedelta(&#39;0 days 00:00:00.000015&#39;)</code></pre><p>将字符串列表或数组解析为  timedelta 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.to_timedelta([&#39;1 days 06:05:01.00003&#39;, &#39;15.5us&#39;, &#39;nan&#39;])TimedeltaIndex([&#39;1 days 06:05:01.000030&#39;, &#39;0 days 00:00:00.000015&#39;, NaT], dtype=&#39;timedelta64[ns]&#39;, freq=None)</code></pre><p>指定 <code>unit</code> 参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.to_timedelta(np.arange(5), unit=&#39;s&#39;)TimedeltaIndex([&#39;00:00:00&#39;, &#39;00:00:01&#39;, &#39;00:00:02&#39;, &#39;00:00:03&#39;, &#39;00:00:04&#39;], dtype=&#39;timedelta64[ns]&#39;, freq=None)&gt;&gt;&gt; &gt;&gt;&gt; pd.to_timedelta(np.arange(5), unit=&#39;d&#39;)TimedeltaIndex([&#39;0 days&#39;, &#39;1 days&#39;, &#39;2 days&#39;, &#39;3 days&#39;, &#39;4 days&#39;], dtype=&#39;timedelta64[ns]&#39;, freq=None)</code></pre><h3 id="【04x03】timedelta-range"><a href="#【04x03】timedelta-range" class="headerlink" title="【04x03】timedelta_range"></a><font color=#4876FF>【04x03】timedelta_range</font></h3><p><code>timedelta_range</code> 方法可根据指定的频率生成指定长度的 TimedeltaIndex。</p><p>基本语法：</p><pre><code class="python">pandas.timedelta_range(start=None, end=None, periods=None,                       freq=None, name=None, closed=None) → pandas.core.indexes.timedeltas.TimedeltaIndex</code></pre><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.timedelta_range.html">https://pandas.pydata.org/docs/reference/api/pandas.timedelta_range.html</a></p><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>开始日期</td></tr><tr><td>end</td><td>结束日期</td></tr><tr><td>periods</td><td>int 类型，要生成的时段数</td></tr><tr><td>freq</td><td>频率字符串，即按照某种特定的频率来生成日期，取值参见<a href="#t4">【02x02】freq 频率部分取值</a></td></tr><tr><td>name</td><td>结果 TimedeltaIndex 的名称</td></tr><tr><td>closed</td><td><code>None</code>：默认值，同时保留开始日期和结束日期<br><code>&#39;left&#39;</code>：保留开始日期，不保留结束日期<br><code>&#39;right&#39;</code>：保留结束日期，不保留开始日期</td></tr></tbody></table><p>应用示例：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.timedelta_range(start=&#39;1 day&#39;, periods=4)TimedeltaIndex([&#39;1 days&#39;, &#39;2 days&#39;, &#39;3 days&#39;, &#39;4 days&#39;], dtype=&#39;timedelta64[ns]&#39;, freq=&#39;D&#39;)</code></pre><p>closed 参数指定保留哪个端点。默认保留两个端点：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.timedelta_range(start=&#39;1 day&#39;, periods=4, closed=&#39;right&#39;)TimedeltaIndex([&#39;2 days&#39;, &#39;3 days&#39;, &#39;4 days&#39;], dtype=&#39;timedelta64[ns]&#39;, freq=&#39;D&#39;)</code></pre><p>freq 参数指定 TimedeltaIndex 的频率。只接受固定频率，非固定频率如 <code>&#39;M&#39;</code> 将会报错：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.timedelta_range(start=&#39;1 day&#39;, end=&#39;2 days&#39;, freq=&#39;6H&#39;)TimedeltaIndex([&#39;1 days 00:00:00&#39;, &#39;1 days 06:00:00&#39;, &#39;1 days 12:00:00&#39;,                &#39;1 days 18:00:00&#39;, &#39;2 days 00:00:00&#39;],               dtype=&#39;timedelta64[ns]&#39;, freq=&#39;6H&#39;)&gt;&gt;&gt; &gt;&gt;&gt; pd.timedelta_range(start=&#39;1 day&#39;, end=&#39;2 days&#39;, freq=&#39;M&#39;)Traceback (most recent call last):...ValueError: &lt;MonthEnd&gt; is a non-fixed frequency</code></pre><h2 id="【05x00】重采样及频率转换"><a href="#【05x00】重采样及频率转换" class="headerlink" title="【05x00】重采样及频率转换"></a><font color=#FF0000>【05x00】重采样及频率转换</font></h2><p>重采样（resampling）指的是将时间序列从一个频率转换到另一个频率的处理过程。将高频率数据聚合到低频率称为降采样（downsampling），而将低频率数据转换到高频率则称为升采样（upsampling）。并不是所有的重采样都能被划分到这两个大类中。例如，将 W-WED（每周三）转换为 W-FRI 既不是降采样也不是升采样。</p><p>Pandas 中提供了 resample 方法来帮助我们实现重采样。Pandas 对象都带有一个 resample 方法，它是各种频率转换工作的主力函数。</p><p>基本语法：</p><pre><code class="python">Series.resample(self, rule, axis=0,                 closed: Union[str, NoneType] = None,                 label: Union[str, NoneType] = None,                 convention: str = &#39;start&#39;,                 kind: Union[str, NoneType] = None,                 loffset=None, base: int = 0,                 on=None, level=None)</code></pre><pre><code class="python">DataFrame.resample(self, rule, axis=0,                    closed: Union[str, NoneType] = None,                    label: Union[str, NoneType] = None,                    convention: str = &#39;start&#39;,                    kind: Union[str, NoneType] = None,                    loffset=None, base: int = 0,                    on=None, level=None)</code></pre><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>rule</td><td></td></tr><tr><td>axis</td><td>重采样的轴，默认 0</td></tr><tr><td>closed</td><td>在重采样中，各时间段的哪一端是闭合（即包含）的，<br>除 <code>&#39;M&#39;</code>、<code>&#39;A&#39;</code>、<code>&#39;Q&#39;</code>、<code>&#39;BM&#39;</code>、<code>&#39;BA&#39;</code>、<code>&#39;BQ&#39;</code> 和 <code>&#39;W&#39;</code> 默认值为 ‘right’ 外，其他默认值为 ‘left‘</td></tr><tr><td>label</td><td>在重采样中，如何设置聚合值的标签， right 或 left，默认为 None，<br>例如，9:30 到 9:35 之间的这 5 分钟会被标记为 9:30 或 9:35</td></tr><tr><td>convention</td><td>仅用于 PeriodIndex（固定时期），对周期进行重采样，<code>&#39;start&#39;</code> or <code>&#39;s&#39;</code>，<code>&#39;end&#39;</code> or <code>&#39;e&#39;</code></td></tr><tr><td>on</td><td>对于 DataFrame 对象，可用该参数指定重采样后的数据的 index（行索引） 为原数据中的某列</td></tr><tr><td>level</td><td>对于具有层级索引（MultiIndex）的 DataFrame 对象，可以使用该参数来指定需要在哪个级别上进行重新采样</td></tr></tbody></table><p>将序列重采样到三分钟的频率，并将每个频率的值相加：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; series.resample(&#39;3T&#39;).sum()2000-01-01 00:00:00     32000-01-01 00:03:00    122000-01-01 00:06:00    21Freq: 3T, dtype: int64</code></pre><p>设置 <code>label=&#39;right&#39;</code>，即每个索引 index 会使用靠右侧（较大值）的标签：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; series.resample(&#39;3T&#39;, label=&#39;right&#39;).sum()2000-01-01 00:03:00     32000-01-01 00:06:00    122000-01-01 00:09:00    21Freq: 3T, dtype: int64</code></pre><p>设置 <code>closed=&#39;right&#39;</code>，即结果中会包含原数据中最右侧（较大）的值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; series.resample(&#39;3T&#39;, label=&#39;right&#39;, closed=&#39;right&#39;).sum()2000-01-01 00:00:00     02000-01-01 00:03:00     62000-01-01 00:06:00    152000-01-01 00:09:00    15Freq: 3T, dtype: int64</code></pre><p>以下示例将序列重采样到30秒的频率，<code>asfreq()[0:5]</code> 用于选择前5行数据：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; series.resample(&#39;30S&#39;).asfreq()[0:5]2000-01-01 00:00:00    0.02000-01-01 00:00:30    NaN2000-01-01 00:01:00    1.02000-01-01 00:01:30    NaN2000-01-01 00:02:00    2.0Freq: 30S, dtype: float64</code></pre><p>使用 <code>pad</code> 方法向后填充缺失值（NaN）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; series.resample(&#39;30S&#39;).pad()[0:5]2000-01-01 00:00:00    02000-01-01 00:00:30    02000-01-01 00:01:00    12000-01-01 00:01:30    12000-01-01 00:02:00    2Freq: 30S, dtype: int64</code></pre><p>使用 <code>bfill</code> 方法向前填充缺失值（NaN）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; series.resample(&#39;30S&#39;).bfill()[0:5]2000-01-01 00:00:00    02000-01-01 00:00:30    12000-01-01 00:01:00    12000-01-01 00:01:30    22000-01-01 00:02:00    2Freq: 30S, dtype: int64</code></pre><p>通过 <code>apply</code> 方法传递自定义函数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)&gt;&gt;&gt; series = pd.Series(range(9), index=index)&gt;&gt;&gt; series2000-01-01 00:00:00    02000-01-01 00:01:00    12000-01-01 00:02:00    22000-01-01 00:03:00    32000-01-01 00:04:00    42000-01-01 00:05:00    52000-01-01 00:06:00    62000-01-01 00:07:00    72000-01-01 00:08:00    8Freq: T, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; def custom_resampler(array_like):    return np.sum(array_like) + 5&gt;&gt;&gt; series.resample(&#39;3T&#39;).apply(custom_resampler)2000-01-01 00:00:00     82000-01-01 00:03:00    172000-01-01 00:06:00    26Freq: 3T, dtype: int64</code></pre><p>convention 参数的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; s = pd.Series([1, 2], index=pd.period_range(&#39;2012-01-01&#39;, freq=&#39;A&#39;, periods=2))&gt;&gt;&gt; s2012    12013    2Freq: A-DEC, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; s.resample(&#39;Q&#39;, convention=&#39;start&#39;).asfreq()2012Q1    1.02012Q2    NaN2012Q3    NaN2012Q4    NaN2013Q1    2.02013Q2    NaN2013Q3    NaN2013Q4    NaNFreq: Q-DEC, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; s.resample(&#39;Q&#39;, convention=&#39;end&#39;).asfreq()2012Q4    1.02013Q1    NaN2013Q2    NaN2013Q3    NaN2013Q4    2.0Freq: Q-DEC, dtype: float64</code></pre><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; q = pd.Series([1, 2, 3, 4], index=pd.period_range(&#39;2018-01-01&#39;, freq=&#39;Q&#39;, periods=4))&gt;&gt;&gt; q2018Q1    12018Q2    22018Q3    32018Q4    4Freq: Q-DEC, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; q.resample(&#39;M&#39;, convention=&#39;end&#39;).asfreq()2018-03    1.02018-04    NaN2018-05    NaN2018-06    2.02018-07    NaN2018-08    NaN2018-09    3.02018-10    NaN2018-11    NaN2018-12    4.0Freq: M, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; q.resample(&#39;M&#39;, convention=&#39;start&#39;).asfreq()2018-01    1.02018-02    NaN2018-03    NaN2018-04    2.02018-05    NaN2018-06    NaN2018-07    3.02018-08    NaN2018-09    NaN2018-10    4.02018-11    NaN2018-12    NaNFreq: M, dtype: float64</code></pre><p>对于 DataFrame 对象，可以使用关键字 on 来指定原数据中的某列为重采样后数据的行索引：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; d = dict(&#123;&#39;price&#39;: [10, 11, 9, 13, 14, 18, 17, 19],                &#39;volume&#39;: [50, 60, 40, 100, 50, 100, 40, 50]&#125;)&gt;&gt;&gt; df = pd.DataFrame(d)&gt;&gt;&gt; df[&#39;week_starting&#39;] = pd.date_range(&#39;01/01/2018&#39;, periods=8, freq=&#39;W&#39;)&gt;&gt;&gt; df   price  volume week_starting0     10      50    2018-01-071     11      60    2018-01-142      9      40    2018-01-213     13     100    2018-01-284     14      50    2018-02-045     18     100    2018-02-116     17      40    2018-02-187     19      50    2018-02-25&gt;&gt;&gt; &gt;&gt;&gt; df.resample(&#39;M&#39;, on=&#39;week_starting&#39;).mean()               price  volumeweek_starting               2018-01-31     10.75    62.52018-02-28     17.00    60.0</code></pre><p>对于具有层级索引（MultiIndex）的 DataFrame 对象，可以使用关键字 <code>level</code> 来指定需要在哪个级别上进行重新采样：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; days = pd.date_range(&#39;1/1/2000&#39;, periods=4, freq=&#39;D&#39;)&gt;&gt;&gt; d2 = dict(&#123;&#39;price&#39;: [10, 11, 9, 13, 14, 18, 17, 19],                  &#39;volume&#39;: [50, 60, 40, 100, 50, 100, 40, 50]&#125;)&gt;&gt;&gt; df2 = pd.DataFrame(d2, index=pd.MultiIndex.from_product([days, [&#39;morning&#39;, &#39;afternoon&#39;]]))&gt;&gt;&gt; df2                      price  volume2000-01-01 morning       10      50           afternoon     11      602000-01-02 morning        9      40           afternoon     13     1002000-01-03 morning       14      50           afternoon     18     1002000-01-04 morning       17      40           afternoon     19      50&gt;&gt;&gt; &gt;&gt;&gt; df2.resample(&#39;D&#39;, level=0).sum()            price  volume2000-01-01     21     1102000-01-02     22     1402000-01-03     32     1502000-01-04     36      90</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106947061未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Pandas（八）：数据重塑/重复数据处理/数据替换</title>
      <link href="/article/032/"/>
      <url>/article/032/</url>
      
        <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106900748未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】数据重塑"><a href="#【01x00】数据重塑" class="headerlink" title="【01x00】数据重塑"></a><font color=#FF0000>【01x00】数据重塑</font></h2><p>有许多用于重新排列表格型数据的基础运算。这些函数也称作重塑（reshape）或轴向旋转（pivot）运算。重塑层次化索引主要有以下两个方法：</p><ul><li><p><code>stack</code>：将数据的列转换成行；</p></li><li><p><code>unstack</code>：将数据的行转换成列。</p></li></ul><h3 id="【01x01】stack"><a href="#【01x01】stack" class="headerlink" title="【01x01】stack"></a><font color=#4876FF>【01x01】stack</font></h3><p><code>stack</code> 方法用于将数据的列转换成为行；</p><p>基本语法：<code>DataFrame.stack(self, level=-1, dropna=True)</code></p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.stack.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.stack.html</a></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>level</td><td>从列转换到行，指定不同层级的列索引或列标签、由列索引或列标签组成的数组，默认-1</td></tr><tr><td>dropna</td><td>bool 类型，是否删除重塑后数据中所有值为 NaN 的行，默认 True</td></tr></tbody></table><p>单层列（Single level columns）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame([[0, 1], [2, 3]], index=[&#39;cat&#39;, &#39;dog&#39;], columns=[&#39;weight&#39;, &#39;height&#39;])&gt;&gt;&gt; obj     weight  heightcat       0       1dog       2       3&gt;&gt;&gt; &gt;&gt;&gt; obj.stack()cat  weight    0     height    1dog  weight    2     height    3dtype: int64</code></pre><p>多层列（Multi level columns）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; multicol = pd.MultiIndex.from_tuples([(&#39;weight&#39;, &#39;kg&#39;), (&#39;weight&#39;, &#39;pounds&#39;)])&gt;&gt;&gt; obj = pd.DataFrame([[1, 2], [2, 4]], index=[&#39;cat&#39;, &#39;dog&#39;], columns=multicol)&gt;&gt;&gt; obj    weight               kg poundscat      1      2dog      2      4&gt;&gt;&gt; &gt;&gt;&gt; obj.stack()            weightcat kg           1    pounds       2dog kg           2    pounds       4</code></pre><p>缺失值填充：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; multicol = pd.MultiIndex.from_tuples([(&#39;weight&#39;, &#39;kg&#39;), (&#39;height&#39;, &#39;m&#39;)])&gt;&gt;&gt; obj = pd.DataFrame([[1.0, 2.0], [3.0, 4.0]], index=[&#39;cat&#39;, &#39;dog&#39;], columns=multicol)&gt;&gt;&gt; obj    weight height        kg      mcat    1.0    2.0dog    3.0    4.0&gt;&gt;&gt; &gt;&gt;&gt; obj.stack()        height  weightcat kg     NaN     1.0    m      2.0     NaNdog kg     NaN     3.0    m      4.0     NaN</code></pre><p>通过 <code>level</code> 参数指定不同层级的轴进行重塑：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; multicol = pd.MultiIndex.from_tuples([(&#39;weight&#39;, &#39;kg&#39;), (&#39;height&#39;, &#39;m&#39;)])&gt;&gt;&gt; obj = pd.DataFrame([[1.0, 2.0], [3.0, 4.0]], index=[&#39;cat&#39;, &#39;dog&#39;], columns=multicol)&gt;&gt;&gt; obj    weight height        kg      mcat    1.0    2.0dog    3.0    4.0&gt;&gt;&gt; &gt;&gt;&gt; obj.stack(level=0)             kg    mcat height  NaN  2.0    weight  1.0  NaNdog height  NaN  4.0    weight  3.0  NaN&gt;&gt;&gt; &gt;&gt;&gt; obj.stack(level=1)        height  weightcat kg     NaN     1.0    m      2.0     NaNdog kg     NaN     3.0    m      4.0     NaN&gt;&gt;&gt;&gt;&gt;&gt; obj.stack(level=[0, 1])cat  height  m     2.0     weight  kg    1.0dog  height  m     4.0     weight  kg    3.0dtype: float64</code></pre><p>对于重塑后的数据，若有一行的值均为 NaN，则默认会被删除，可以设置 <code>dropna=False</code> 来保留缺失值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; multicol = pd.MultiIndex.from_tuples([(&#39;weight&#39;, &#39;kg&#39;), (&#39;height&#39;, &#39;m&#39;)])&gt;&gt;&gt; obj = pd.DataFrame([[None, 1.0], [2.0, 3.0]], index=[&#39;cat&#39;, &#39;dog&#39;], columns=multicol)&gt;&gt;&gt; obj    weight height        kg      mcat    NaN    1.0dog    2.0    3.0&gt;&gt;&gt; &gt;&gt;&gt; obj.stack(dropna=False)        height  weightcat kg     NaN     NaN    m      1.0     NaNdog kg     NaN     2.0    m      3.0     NaN&gt;&gt;&gt; &gt;&gt;&gt; obj.stack(dropna=True)        height  weightcat m      1.0     NaNdog kg     NaN     2.0    m      3.0     NaN</code></pre><h3 id="【01x02】unstack"><a href="#【01x02】unstack" class="headerlink" title="【01x02】unstack"></a><font color=#4876FF>【01x02】unstack</font></h3><p><code>unstack</code>：将数据的行转换成列。</p><p>基本语法：</p><ul><li><p><code>Series.unstack(self, level=-1, fill_value=None)</code></p></li><li><p><code>DataFrame.unstack(self, level=-1, fill_value=None)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.unstack.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.unstack.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.unstack.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.unstack.html</a></p></li></ul><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>level</td><td>从行转换到列，指定不同层级的行索引，默认-1</td></tr><tr><td>fill_value</td><td>用于替换 NaN 的值</td></tr></tbody></table><p>在 Series 对象中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 2, 3, 4], index=pd.MultiIndex.from_product([[&#39;one&#39;, &#39;two&#39;], [&#39;a&#39;, &#39;b&#39;]]))&gt;&gt;&gt; objone  a    1     b    2two  a    3     b    4dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.unstack()     a  bone  1  2two  3  4&gt;&gt;&gt; &gt;&gt;&gt; obj.unstack(level=0)   one  twoa    1    3b    2    4</code></pre><p>和 <code>stack</code> 方法类似，如果值不存在将会引入缺失值（NaN）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.Series([0, 1, 2, 3], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obj2 = pd.Series([4, 5, 6], index=[&#39;c&#39;, &#39;d&#39;, &#39;e&#39;])&gt;&gt;&gt; obj3 = pd.concat([obj1, obj2], keys=[&#39;one&#39;, &#39;two&#39;])&gt;&gt;&gt; obj3one  a    0     b    1     c    2     d    3two  c    4     d    5     e    6dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj3.unstack()       a    b    c    d    eone  0.0  1.0  2.0  3.0  NaNtwo  NaN  NaN  4.0  5.0  6.0</code></pre><p>在 DataFrame 对象中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.arange(6).reshape((2, 3)),               index=pd.Index([&#39;Ohio&#39;,&#39;Colorado&#39;], name=&#39;state&#39;),               columns=pd.Index([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;],               name=&#39;number&#39;))&gt;&gt;&gt; objnumber    one  two  threestate                    Ohio        0    1      2Colorado    3    4      5&gt;&gt;&gt; &gt;&gt;&gt; obj2 = obj.stack()&gt;&gt;&gt; obj2state     numberOhio      one       0          two       1          three     2Colorado  one       3          two       4          three     5dtype: int32&gt;&gt;&gt; &gt;&gt;&gt; obj3 = pd.DataFrame(&#123;&#39;left&#39;: obj2, &#39;right&#39;: obj2 + 5&#125;,            columns=pd.Index([&#39;left&#39;, &#39;right&#39;], name=&#39;side&#39;))&gt;&gt;&gt; obj3side             left  rightstate    number             Ohio     one        0      5         two        1      6         three      2      7Colorado one        3      8         two        4      9         three      5     10&gt;&gt;&gt; &gt;&gt;&gt; obj3.unstack(&#39;state&#39;)side   left          right         state  Ohio Colorado  Ohio Coloradonumber                             one       0        3     5        8two       1        4     6        9three     2        5     7       10&gt;&gt;&gt; &gt;&gt;&gt; obj3.unstack(&#39;state&#39;).stack(&#39;side&#39;)state         Colorado  Ohionumber side                 one    left          3     0       right         8     5two    left          4     1       right         9     6three  left          5     2       right        10     7</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106900748未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【02x00】重复数据处理"><a href="#【02x00】重复数据处理" class="headerlink" title="【02x00】重复数据处理"></a><font color=#FF0000>【02x00】重复数据处理</font></h2><ul><li><p><code>duplicated</code>：判断是否为重复值；</p></li><li><p><code>drop_duplicates</code>：删除重复值。</p></li></ul><h3 id="【02x01】duplicated"><a href="#【02x01】duplicated" class="headerlink" title="【02x01】duplicated"></a><font color=#4876FF>【02x01】duplicated</font></h3><p><code>duplicated</code> 方法可以判断值是否为重复数据。</p><p>基本语法：</p><ul><li><p><code>Series.duplicated(self, keep=&#39;first&#39;)</code></p></li><li><p><code>DataFrame.duplicated(self, subset: Union[Hashable, Sequence[Hashable], NoneType] = None, keep: Union[str, bool] = &#39;first&#39;) → ’Series’</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.duplicated.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.duplicated.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.duplicated.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.duplicated.html</a></p></li></ul><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>keep</td><td>标记重复项的方法，默认 <code>&#39;first&#39;</code><br><code>&#39;first&#39;</code>：将非重复项和第一个重复项标记为 False，其他重复项标记为 True<br><code>&#39;last&#39;</code>：将非重复项和最后一个重复项标记为 False，其他重复项标记为 True<br><code>False</code>：将所有重复项标记为 True，非重复项标记为 False</td></tr><tr><td>subset</td><td>列标签或标签序列，在 DataFrame 对象中才有此参数，<br>用于指定某列，仅标记该列的重复项，默认情况下将考虑所有列</td></tr></tbody></table><p>默认情况下，对于每组重复的值，第一个出现的重复值标记为 False，其他重复项标记为 True，非重复项标记为 False，相当于 <code>keep=&#39;first&#39;</code>：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;])&gt;&gt;&gt; obj0      lama1       cow2      lama3    beetle4      lamadtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.duplicated()0    False1    False2     True3    False4     Truedtype: bool&gt;&gt;&gt;&gt;&gt;&gt; obj.duplicated(keep=&#39;first&#39;)0    False1    False2     True3    False4     Truedtype: bool</code></pre><p>设置 <code>keep=&#39;last&#39;</code>，将每组非重复项和最后一次出现的重复项标记为 False，其他重复项标记为 True，设置 <code>keep=False</code>，则所有重复项均为 True，其他值为 False：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;])&gt;&gt;&gt; obj0      lama1       cow2      lama3    beetle4      lamadtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.duplicated(keep=&#39;last&#39;)0     True1    False2     True3    False4    Falsedtype: bool&gt;&gt;&gt; &gt;&gt;&gt; obj.duplicated(keep=False)0     True1    False2     True3    False4     Truedtype: bool</code></pre><p>在 DataFrame 对象中，subset 参数用于指定某列，仅标记该列的重复项，默认情况下将考虑所有列：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;data1&#39; : [&#39;a&#39;] * 4 + [&#39;b&#39;] * 4,                       &#39;data2&#39; : np.random.randint(0, 4, 8)&#125;)&gt;&gt;&gt; obj  data1  data20     a      01     a      02     a      03     a      34     b      35     b      36     b      07     b      2&gt;&gt;&gt; &gt;&gt;&gt; obj.duplicated()0    False1     True2     True3    False4    False5     True6    False7    Falsedtype: bool&gt;&gt;&gt; &gt;&gt;&gt; obj.duplicated(subset=&#39;data1&#39;)0    False1     True2     True3     True4    False5     True6     True7     Truedtype: bool&gt;&gt;&gt; &gt;&gt;&gt; obj.duplicated(subset=&#39;data2&#39;, keep=&#39;last&#39;)0     True1     True2     True3     True4     True5    False6    False7    Falsedtype: bool</code></pre><h3 id="【02x02】drop-duplicates"><a href="#【02x02】drop-duplicates" class="headerlink" title="【02x02】drop_duplicates"></a><font color=#4876FF>【02x02】drop_duplicates</font></h3><p><code>drop_duplicates</code> 方法会返回一个删除了重复值的序列。</p><p>基本语法：</p><pre><code class="python">Series.drop_duplicates(self, keep=&#39;first&#39;, inplace=False)</code></pre><pre><code class="python">DataFrame.drop_duplicates(self,                          subset: Union[Hashable, Sequence[Hashable], NoneType] = None,                          keep: Union[str, bool] = &#39;first&#39;,                          inplace: bool = False,                          ignore_index: bool = False) → Union[ForwardRef(‘DataFrame’), NoneType]</code></pre><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.drop_duplicates.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.drop_duplicates.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.drop_duplicates.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.drop_duplicates.html</a></p></li></ul><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>keep</td><td>删除重复项的方法，默认 <code>&#39;first&#39;</code><br><code>&#39;first&#39;</code>：保留非重复项和第一个重复项，其他重复项标记均删除<br><code>&#39;last&#39;</code>：保留非重复项和最后一个重复项，其他重复项删除<br><code>False</code>：将所有重复项删除，非重复项保留</td></tr><tr><td>inplace</td><td>是否返回删除重复项后的值，默认 False，若设置为 True，则不返回值，直接改变原数据</td></tr><tr><td>subset</td><td>列标签或标签序列，在 DataFrame 对象中才有此参数，<br>用于指定某列，仅标记该列的重复项，默认情况下将考虑所有列</td></tr><tr><td>ignore_index</td><td>bool 类型，在 DataFrame 对象中才有此参数，是否忽略原对象的轴标记，<br>默认 False，如果为 True，则新对象的索引将是 0, 1, 2, …, n-1</td></tr></tbody></table><p>keep 参数的使用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;, &#39;hippo&#39;], name=&#39;animal&#39;)&gt;&gt;&gt; obj0      lama1       cow2      lama3    beetle4      lama5     hippoName: animal, dtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.drop_duplicates()0      lama1       cow3    beetle5     hippoName: animal, dtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.drop_duplicates(keep=&#39;last&#39;)1       cow3    beetle4      lama5     hippoName: animal, dtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.drop_duplicates(keep=False)1       cow3    beetle5     hippoName: animal, dtype: object</code></pre><p>如果设置 <code>inplace=True</code>，则不会返回任何值，但原对象的值已被改变：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.Series([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;, &#39;hippo&#39;], name=&#39;animal&#39;)&gt;&gt;&gt; obj10      lama1       cow2      lama3    beetle4      lama5     hippoName: animal, dtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj2 = obj1.drop_duplicates()&gt;&gt;&gt; obj2          # 有返回值0      lama1       cow3    beetle5     hippoName: animal, dtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj3 = obj1.drop_duplicates(inplace=True)&gt;&gt;&gt; obj3         # 无返回值&gt;&gt;&gt;&gt;&gt;&gt; obj1         # 原对象的值已改变0      lama1       cow3    beetle5     hippoName: animal, dtype: object</code></pre><p>在 DataFrame 对象中的使用：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;data1&#39; : [&#39;a&#39;] * 4 + [&#39;b&#39;] * 4,                       &#39;data2&#39; : np.random.randint(0, 4, 8)&#125;)&gt;&gt;&gt; obj  data1  data20     a      21     a      12     a      13     a      24     b      15     b      26     b      07     b      0&gt;&gt;&gt; &gt;&gt;&gt; obj.drop_duplicates()  data1  data20     a      21     a      14     b      15     b      26     b      0&gt;&gt;&gt; &gt;&gt;&gt; obj.drop_duplicates(subset=&#39;data2&#39;)  data1  data20     a      21     a      16     b      0&gt;&gt;&gt; &gt;&gt;&gt; obj.drop_duplicates(subset=&#39;data2&#39;, ignore_index=True)  data1  data20     a      21     a      12     b      0</code></pre><h2 id="【03x00】数据替换"><a href="#【03x00】数据替换" class="headerlink" title="【03x00】数据替换"></a><font color=#FF0000>【03x00】数据替换</font></h2><h3 id="【03x01】replace"><a href="#【03x01】replace" class="headerlink" title="【03x01】replace"></a><font color=#4876FF>【03x01】replace</font></h3><p><code>replace</code> 方法可以根据值的内容进行替换。</p><p>基本语法：</p><ul><li><p><code>Series.replace(self, to_replace=None, value=None, inplace=False, limit=None, regex=False, method=&#39;pad&#39;)</code></p></li><li><p><code>DataFrame.replace(self, to_replace=None, value=None, inplace=False, limit=None, regex=False, method=&#39;pad&#39;)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.replace.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.replace.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.replace.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.replace.html</a></p></li></ul><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>to_replace</td><td>找到要替换值的方法，可以是：字符串、正则表达式、列表、字典、整数、浮点数、Series 对象或者 None<br>使用不同参数的区别参见官方文档</td></tr><tr><td>value</td><td>用于替换匹配项的值， 对于 DataFrame，可以使用字典的值来指定每列要使用的值，<br>还允许使用此类对象的正则表达式，字符串和列表或字典</td></tr><tr><td>inplace</td><td>bool 类型，是否直接改变原数据且不返回值，默认 False</td></tr><tr><td>regex</td><td>bool 类型或者与 to_replace 相同的类型，<br>当 to_replace 参数为正则表达式时，regex 应为 True，或者直接使用该参数代替 to_replace</td></tr></tbody></table><p><code>to_replace</code> 和 <code>value</code> 参数只传入一个值，单个值替换单个值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([0, 1, 2, 3, 4])&gt;&gt;&gt; obj0    01    12    23    34    4dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.replace(0, 5)0    51    12    23    34    4dtype: int64</code></pre><p><code>to_replace</code> 传入多个值，<code>value</code> 传入一个值，多个值替换一个值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([0, 1, 2, 3, 4])&gt;&gt;&gt; obj0    01    12    23    34    4dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.replace([0, 1, 2, 3], 4)0    41    42    43    44    4dtype: int64</code></pre><p><code>to_replace</code> 和 <code>value</code> 参数都传入多个值，多个值替换多个值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([0, 1, 2, 3, 4])&gt;&gt;&gt; obj0    01    12    23    34    4dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.replace([0, 1, 2, 3], [4, 3, 2, 1])0    41    32    23    14    4dtype: int64</code></pre><p><code>to_replace</code> 传入字典：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;A&#39;: [0, 1, 2, 3, 4],            &#39;B&#39;: [5, 6, 7, 8, 9],            &#39;C&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]&#125;)&gt;&gt;&gt; obj   A  B  C0  0  5  a1  1  6  b2  2  7  c3  3  8  d4  4  9  e&gt;&gt;&gt; &gt;&gt;&gt; obj.replace(0, 5)   A  B  C0  5  5  a1  1  6  b2  2  7  c3  3  8  d4  4  9  e&gt;&gt;&gt; &gt;&gt;&gt; obj.replace(&#123;0: 10, 1: 100&#125;)     A  B  C0   10  5  a1  100  6  b2    2  7  c3    3  8  d4    4  9  e&gt;&gt;&gt; &gt;&gt;&gt; obj.replace(&#123;&#39;A&#39;: 0, &#39;B&#39;: 5&#125;, 100)     A    B  C0  100  100  a1    1    6  b2    2    7  c3    3    8  d4    4    9  e&gt;&gt;&gt; obj.replace(&#123;&#39;A&#39;: &#123;0: 100, 4: 400&#125;&#125;)     A  B  C0  100  5  a1    1  6  b2    2  7  c3    3  8  d4  400  9  e</code></pre><p><code>to_replace</code> 传入正则表达式：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;A&#39;: [&#39;bat&#39;, &#39;foo&#39;, &#39;bait&#39;],            &#39;B&#39;: [&#39;abc&#39;, &#39;bar&#39;, &#39;xyz&#39;]&#125;)&gt;&gt;&gt; obj      A    B0   bat  abc1   foo  bar2  bait  xyz&gt;&gt;&gt; &gt;&gt;&gt; obj.replace(to_replace=r&#39;^ba.$&#39;, value=&#39;new&#39;, regex=True)      A    B0   new  abc1   foo  new2  bait  xyz&gt;&gt;&gt; &gt;&gt;&gt; obj.replace(&#123;&#39;A&#39;: r&#39;^ba.$&#39;&#125;, &#123;&#39;A&#39;: &#39;new&#39;&#125;, regex=True)      A    B0   new  abc1   foo  bar2  bait  xyz&gt;&gt;&gt; &gt;&gt;&gt; obj.replace(regex=r&#39;^ba.$&#39;, value=&#39;new&#39;)      A    B0   new  abc1   foo  new2  bait  xyz&gt;&gt;&gt; &gt;&gt;&gt; obj.replace(regex=&#123;r&#39;^ba.$&#39;: &#39;new&#39;, &#39;foo&#39;: &#39;xyz&#39;&#125;)      A    B0   new  abc1   xyz  new2  bait  xyz&gt;&gt;&gt; &gt;&gt;&gt; obj.replace(regex=[r&#39;^ba.$&#39;, &#39;foo&#39;], value=&#39;new&#39;)      A    B0   new  abc1   new  new2  bait  xyz</code></pre><h3 id="【03x02】where"><a href="#【03x02】where" class="headerlink" title="【03x02】where"></a><font color=#4876FF>【03x02】where</font></h3><p><code>where</code> 方法用于替换条件为 False 的值。</p><p>基本语法：</p><ul><li><p><code>Series.where(self, cond, other=nan, inplace=False, axis=None, level=None, errors=&#39;raise&#39;, try_cast=False)</code></p></li><li><p><code>DataFrame.where(self, cond, other=nan, inplace=False, axis=None, level=None, errors=&#39;raise&#39;, try_cast=False)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.where.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.where.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.where.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.where.html</a></p></li></ul><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>cond</td><td>替换条件，如果 cond 为 True，则保留原始值。如果为 False，则替换为来自 other 的相应值</td></tr><tr><td>other</td><td>替换值，如果 cond 为 False，则替换为来自该参数的相应值</td></tr><tr><td>inplace</td><td>bool 类型，是否直接改变原数据且不返回值，默认 False</td></tr></tbody></table><p>在 Series 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series(range(5))&gt;&gt;&gt; obj0    01    12    23    34    4dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.where(obj &gt; 0)0    NaN1    1.02    2.03    3.04    4.0dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.where(obj &gt; 1, 10)0    101    102     23     34     4dtype: int64</code></pre><p>在 DataFrame 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(np.arange(10).reshape(-1, 2), columns=[&#39;A&#39;, &#39;B&#39;])&gt;&gt;&gt; obj   A  B0  0  11  2  32  4  53  6  74  8  9&gt;&gt;&gt; &gt;&gt;&gt; m = obj % 3 == 0&gt;&gt;&gt; obj.where(m, -obj)   A  B0  0 -11 -2  32 -4 -53  6 -74 -8  9&gt;&gt;&gt; &gt;&gt;&gt; obj.where(m, -obj) == np.where(m, obj, -obj)      A     B0  True  True1  True  True2  True  True3  True  True4  True  True</code></pre><h3 id="【03x03】mask"><a href="#【03x03】mask" class="headerlink" title="【03x03】mask"></a><font color=#4876FF>【03x03】mask</font></h3><p><code>mask</code> 方法与 <code>where</code> 方法相反，<code>mask</code> 用于替换条件为 False 的值。</p><p>基本语法：</p><ul><li><p><code>Series.mask(self, cond, other=nan, inplace=False, axis=None, level=None, errors=&#39;raise&#39;, try_cast=False)</code></p></li><li><p><code>DataFrame.mask(self, cond, other=nan, inplace=False, axis=None, level=None, errors=&#39;raise&#39;, try_cast=False)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.mask.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.mask.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mask.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mask.html</a></p></li></ul><p>常用参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>cond</td><td>替换条件，如果 cond 为 False，则保留原始值。如果为 True，则替换为来自 other 的相应值</td></tr><tr><td>other</td><td>替换值，如果 cond 为 False，则替换为来自该参数的相应值</td></tr><tr><td>inplace</td><td>bool 类型，是否直接改变原数据且不返回值，默认 False</td></tr></tbody></table><p>在 Series 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series(range(5))&gt;&gt;&gt; obj0    01    12    23    34    4dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.mask(obj &gt; 0)0    0.01    NaN2    NaN3    NaN4    NaNdtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.mask(obj &gt; 1, 10)0     01     12    103    104    10dtype: int64</code></pre><p>在 DataFrame 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(np.arange(10).reshape(-1, 2), columns=[&#39;A&#39;, &#39;B&#39;])&gt;&gt;&gt; obj   A  B0  0  11  2  32  4  53  6  74  8  9&gt;&gt;&gt; &gt;&gt;&gt; m = obj % 3 == 0&gt;&gt;&gt; &gt;&gt;&gt; obj.mask(m, -obj)   A  B0  0  11  2 -32  4  53 -6  74  8 -9&gt;&gt;&gt; &gt;&gt;&gt; obj.where(m, -obj) == obj.mask(~m, -obj)      A     B0  True  True1  True  True2  True  True3  True  True4  True  True</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106900748未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Pandas（七）：合并数据集</title>
      <link href="/article/031/"/>
      <url>/article/031/</url>
      
        <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106830112未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】concat"><a href="#【01x00】concat" class="headerlink" title="【01x00】concat"></a><font color=#FF0000>【01x00】concat</font></h2><p><code>pandas.concat</code> 可以沿着指定轴将多个对象堆叠到一起。</p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.concat.html">https://pandas.pydata.org/docs/reference/api/pandas.concat.html</a></p><p>基本语法：</p><pre><code class="python">pandas.concat(objs: Union[Iterable[‘DataFrame’], Mapping[Optional[Hashable], ‘DataFrame’]],              axis=&#39;0&#39;,              join: str = &quot;&#39;outer&#39;&quot;,              ignore_index: bool = &#39;False&#39;,              keys=&#39;None&#39;,              levels=&#39;None&#39;,              names=&#39;None&#39;,              verify_integrity: bool = &#39;False&#39;,              sort: bool = &#39;False&#39;,              copy: bool = &#39;True&#39;) → ’DataFrame’</code></pre><pre><code class="python">pandas.concat(objs: Union[Iterable[FrameOrSeriesUnion], Mapping[Optional[Hashable], FrameOrSeriesUnion]],              axis=&#39;0&#39;,              join: str = &quot;&#39;outer&#39;&quot;,              ignore_index: bool = &#39;False&#39;,              keys=&#39;None&#39;,              levels=&#39;None&#39;,              names=&#39;None&#39;,              verify_integrity: bool = &#39;False&#39;,              sort: bool = &#39;False&#39;,              copy: bool = &#39;True&#39;) → FrameOrSeriesUnion</code></pre><p>常用参数描述：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>objs</td><td>Series 或 DataFrame 对象的序列或映射，要合并的对象</td></tr><tr><td>axis</td><td>沿指定轴合并，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>join</td><td>如何处理其他轴（或多个轴）上的索引，可取值：<code>‘inner’</code>，<code>‘outer’</code>（默认值）<br><code>‘outer’</code>：当 axis = 0 时，列名相同的列会合并，其余列都保留（并集），空值填充；<br><code>‘inner’</code>：当 axis = 0 时，列名相同的列会合并，其余列都舍弃（交集）</td></tr><tr><td>ignore_index</td><td>bool 类型，连接后的值是否使用原索引值，如果为 True，则索引将会是 0, 1, …, n-1</td></tr><tr><td>keys</td><td>序列形式，默认 None，传递 keys 后，会构造一个层次索引，即 MultiIndex 对象，keys 为最外层索引</td></tr><tr><td>levels</td><td>用于构造 MultiIndex 的特定级别（唯一值）。未指定则将从键中推断出来</td></tr><tr><td>names</td><td>列表类型，为索引添加标签</td></tr><tr><td>verify_integrity</td><td>bool 类型，是否检查合并后的索引有无重复项，设置为 <code>True</code> 若有重复项则会报错</td></tr><tr><td>sort</td><td>当 <code>join=&#39;outer&#39;</code> 时对列索引进行排序。当 <code>join=&#39;inner&#39;</code> 时此操作无效</td></tr></tbody></table><p>合并两个 Series 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.Series([&#39;a&#39;, &#39;b&#39;])&gt;&gt;&gt; obj2 = pd.Series([&#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; pd.concat([obj1, obj2])0    a1    b0    c1    ddtype: object</code></pre><p>设置 <code>ignore_index=True</code>，放弃原有的索引值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.Series([&#39;a&#39;, &#39;b&#39;])&gt;&gt;&gt; obj2 = pd.Series([&#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; pd.concat([obj1, obj2], ignore_index=True)0    a1    b2    c3    ddtype: object</code></pre><p>设置 <code>keys</code> 参数，添加最外层的索引：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.Series([&#39;a&#39;, &#39;b&#39;])&gt;&gt;&gt; obj2 = pd.Series([&#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; pd.concat([obj1, obj2], keys=[&#39;s1&#39;, &#39;s2&#39;])s1  0    a    1    bs2  0    c    1    ddtype: object</code></pre><p>设置 <code>names</code> 参数，为索引添加标签：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.Series([&#39;a&#39;, &#39;b&#39;])&gt;&gt;&gt; obj2 = pd.Series([&#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; pd.concat([obj1, obj2], keys=[&#39;s1&#39;, &#39;s2&#39;], names=[&#39;Series name&#39;, &#39;Row ID&#39;])Series name  Row IDs1           0         a             1         bs2           0         c             1         ddtype: object</code></pre><p>合并 <code>DataFrame</code> 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame([[&#39;a&#39;, 1], [&#39;b&#39;, 2]], columns=[&#39;letter&#39;, &#39;number&#39;])&gt;&gt;&gt; obj2 = pd.DataFrame([[&#39;c&#39;, 3], [&#39;d&#39;, 4]], columns=[&#39;letter&#39;, &#39;number&#39;])&gt;&gt;&gt; obj1  letter  number0      a       11      b       2&gt;&gt;&gt; &gt;&gt;&gt; obj2  letter  number0      c       31      d       4&gt;&gt;&gt; &gt;&gt;&gt; pd.concat([obj1, obj2])  letter  number0      a       11      b       20      c       31      d       4</code></pre><p>合并 <code>DataFrame</code> 对象，不存在的值将会被 NaN 填充：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame([[&#39;a&#39;, 1], [&#39;b&#39;, 2]], columns=[&#39;letter&#39;, &#39;number&#39;])&gt;&gt;&gt; obj2 = pd.DataFrame([[&#39;c&#39;, 3, &#39;cat&#39;], [&#39;d&#39;, 4, &#39;dog&#39;]], columns=[&#39;letter&#39;, &#39;number&#39;, &#39;animal&#39;])&gt;&gt;&gt; obj1  letter  number0      a       11      b       2&gt;&gt;&gt; &gt;&gt;&gt; obj2  letter  number animal0      c       3    cat1      d       4    dog&gt;&gt;&gt; &gt;&gt;&gt; pd.concat([obj1, obj2])  letter  number animal0      a       1    NaN1      b       2    NaN0      c       3    cat1      d       4    dog</code></pre><p>合并 <code>DataFrame</code> 对象，设置 <code>join=&quot;inner&quot;</code> 不存在的列将会舍弃：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame([[&#39;a&#39;, 1], [&#39;b&#39;, 2]], columns=[&#39;letter&#39;, &#39;number&#39;])&gt;&gt;&gt; obj2 = pd.DataFrame([[&#39;c&#39;, 3, &#39;cat&#39;], [&#39;d&#39;, 4, &#39;dog&#39;]], columns=[&#39;letter&#39;, &#39;number&#39;, &#39;animal&#39;])&gt;&gt;&gt; obj1  letter  number0      a       11      b       2&gt;&gt;&gt; &gt;&gt;&gt; obj2  letter  number animal0      c       3    cat1      d       4    dog&gt;&gt;&gt; &gt;&gt;&gt; pd.concat([obj1, obj2], join=&quot;inner&quot;)  letter  number0      a       11      b       20      c       31      d       4</code></pre><p>合并 <code>DataFrame</code> 对象，设置 <code>axis=1</code> 沿 y 轴合并（增加列）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame([[&#39;a&#39;, 1], [&#39;b&#39;, 2]], columns=[&#39;letter&#39;, &#39;number&#39;])&gt;&gt;&gt; obj2 = pd.DataFrame([[&#39;bird&#39;, &#39;polly&#39;], [&#39;monkey&#39;, &#39;george&#39;]], columns=[&#39;animal&#39;, &#39;name&#39;])&gt;&gt;&gt; obj1  letter  number0      a       11      b       2&gt;&gt;&gt; &gt;&gt;&gt; obj2   animal    name0    bird   polly1  monkey  george&gt;&gt;&gt; &gt;&gt;&gt; pd.concat([obj1, obj2], axis=1)  letter  number  animal    name0      a       1    bird   polly1      b       2  monkey  george</code></pre><p>设置 <code>verify_integrity=True</code> ，检查新的索引是否有重复项，有重复项会报错：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame([1], index=[&#39;a&#39;])&gt;&gt;&gt; obj2 = pd.DataFrame([2], index=[&#39;a&#39;])&gt;&gt;&gt; obj1   0a  1&gt;&gt;&gt; &gt;&gt;&gt; obj2   0a  2&gt;&gt;&gt; &gt;&gt;&gt; pd.concat([obj1, obj2], verify_integrity=True)Traceback (most recent call last):    ...ValueError: Indexes have overlapping values: [&#39;a&#39;]</code></pre><p>设置 <code>sort=True</code>，会对列索引进行排序输出：</p><pre><code class="python">&gt;&gt;&gt; obj1 = pd.DataFrame([[&#39;a&#39;, 3], [&#39;d&#39;, 2]], columns=[&#39;letter&#39;, &#39;number&#39;])&gt;&gt;&gt; obj2 = pd.DataFrame([[&#39;c&#39;, 1, &#39;cat&#39;], [&#39;b&#39;, 4, &#39;dog&#39;]], columns=[&#39;letter&#39;, &#39;number&#39;, &#39;animal&#39;])&gt;&gt;&gt; obj1  letter  number0      a       31      d       2&gt;&gt;&gt; &gt;&gt;&gt; obj2  letter  number animal0      c       1    cat1      b       4    dog&gt;&gt;&gt; &gt;&gt;&gt; pd.concat([obj1, obj2], sort=True)  animal letter  number0    NaN      a       31    NaN      d       20    cat      c       11    dog      b       4</code></pre><h2 id="【02x00】append"><a href="#【02x00】append" class="headerlink" title="【02x00】append"></a><font color=#FF0000>【02x00】append</font></h2><p>Append 方法事实上是在一个 Series / DataFrame 对象后最追加另一个 Series / DataFrame 对象并返回一个新对象，不改变原对象的值。</p><p>基本语法：</p><ul><li><p><code>Series.append(self, to_append, ignore_index=False, verify_integrity=False)</code></p></li><li><p><code>DataFrame.append(self, other, ignore_index=False, verify_integrity=False, sort=False)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.append.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.append.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.append.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.append.html</a></p></li></ul><p>参数描述：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>to_append / other</td><td>要追加的数据</td></tr><tr><td>ignore_index</td><td>bool 类型，连接后的值是否使用原索引值，如果为 True，则索引将会是 0, 1, …, n-1</td></tr><tr><td>verify_integrity</td><td>bool 类型，是否检查合并后的索引有无重复项，设置为 <code>True</code> 若有重复项则会报错</td></tr><tr><td>sort</td><td>bool 类型，是否对列索引（columns）进行排序，默认 False</td></tr></tbody></table><p>合并 Series 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.Series([1, 2, 3])&gt;&gt;&gt; obj2 = pd.Series([4, 5, 6])&gt;&gt;&gt; obj3 = pd.Series([4, 5, 6], index=[3, 4, 5])&gt;&gt;&gt; obj10    11    22    3dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj20    41    52    6dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj33    44    55    6dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj1.append(obj2)0    11    22    30    41    52    6dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj1.append(obj3)0    11    22    33    44    55    6dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj1.append(obj2, ignore_index=True)0    11    22    33    44    55    6dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj1.append(obj2, verify_integrity=True)Traceback (most recent call last):...ValueError: Indexes have overlapping values: Int64Index([0, 1, 2], dtype=&#39;int64&#39;)</code></pre><p>合并 DataFrame 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame([[1, 2], [3, 4]], columns=list(&#39;AB&#39;))&gt;&gt;&gt; obj2 = pd.DataFrame([[5, 6], [7, 8]], columns=list(&#39;AB&#39;))&gt;&gt;&gt; &gt;&gt;&gt; obj1   A  B0  1  21  3  4&gt;&gt;&gt; &gt;&gt;&gt; obj2   A  B0  5  61  7  8&gt;&gt;&gt; &gt;&gt;&gt; obj1.append(obj2)   A  B0  1  21  3  40  5  61  7  8&gt;&gt;&gt; &gt;&gt;&gt; obj1.append(obj2, ignore_index=True)   A  B0  1  21  3  42  5  63  7  8</code></pre><p>以下虽然不是生成 DataFrames 的推荐方法，但演示了从多个数据源生成 DataFrames 的两种方法：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(columns=[&#39;A&#39;])&gt;&gt;&gt; for i in range(5):    obj = obj.append(&#123;&#39;A&#39;: i&#125;, ignore_index=True)    &gt;&gt;&gt; obj   A0  01  12  23  34  4</code></pre><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.concat([pd.DataFrame([i], columns=[&#39;A&#39;]) for i in range(5)], ignore_index=True)   A0  01  12  23  34  4</code></pre><h2 id="【03x00】merge"><a href="#【03x00】merge" class="headerlink" title="【03x00】merge"></a><font color=#FF0000>【03x00】merge</font></h2><p>将不同的数据源进行合并是数据科学中常见的操作，这既包括将两个不同的数据集非常简单地拼接在一起，也包括用数据库那样的连接（join）与合并（merge）操作处理有重叠字段的数据集。Series 与DataFrame 都具备这类操作，Pandas 的函数与方法让数据合并变得快速简单。</p><p>数据集的合并（merge）或连接（join）运算是通过一个或多个键将行连接起来的。这些运算是关系型数据库（基于SQL）的核心。Pandas 的 merge 函数是对数据应用这些算法的主要切入点。</p><p><font color=#FF0000> <strong><code>pandas.merge</code> 可根据一个或多个连接键将不同 DataFrame 中的行连接起来。</strong></font></p><p>基本语法：</p><pre><code class="python">pandas.merge(left,             right,             how: str = &#39;inner&#39;,             on=None,             left_on=None,             right_on=None,             left_index: bool = False,             right_index: bool = False,             sort: bool = False,             suffixes=&#39;_x&#39;, &#39;_y&#39;,             copy: bool = True,             indicator: bool = False,             validate=None) → ’DataFrame’</code></pre><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.merge.html">https://pandas.pydata.org/docs/reference/api/pandas.merge.html</a></p><p>常见参数描述：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>参与合并的左侧 DataFrame 对象</td></tr><tr><td>right</td><td>参与合并的右侧 DataFrame 对象</td></tr><tr><td>how</td><td>合并方式，默认 <code>&#39;inner&#39;</code><br><code>&#39;inner&#39;</code>：内连接，即使用两个对象中<font color=#FF0000><strong>都有</strong></font>的键（交集）；<br><code>&#39;outer&#39;</code>：外连接，即使用两个对象中<font color=#FF0000><strong>所有</strong></font>的键（并集）；<br><code>&#39;left&#39;</code>：左连接，即使用<font color=#FF0000><strong>左</strong></font>对象中所有的键；<br><code>&#39;right&#39;</code>：右连接，即使用<font color=#FF0000><strong>右</strong></font>对象中所有的键；</td></tr><tr><td>on</td><td>用于连接的列名。必须存在于左右两个 Dataframe对象中<br>如果未指定，且其他连接键也未指定，则以 left 和 right 列名的交集作为连接键</td></tr><tr><td>left_on</td><td>左侧 DataFrame 对象中用作连接键的列</td></tr><tr><td>right_on</td><td>右侧 DataFrame 对象中用作连接键的列</td></tr><tr><td>left_index</td><td>bool 类型，是否使用左侧 DataFrame 对象中的索引（index）作为连接键，默认 False</td></tr><tr><td>right_index</td><td>bool 类型，是否使用右侧 DataFrame 对象中的索引（index）作为连接键，默认 False</td></tr><tr><td>sort</td><td>bool 类型，是否在结果中按顺序对连接键排序，默认 False。<br>如果为 False，则连接键的顺序取决于联接类型（how 关键字）</td></tr><tr><td>suffixes</td><td>字符串值元组，用于追加到重叠列名的末尾，默认为 <code>(&#39;_x&#39;, &#39;_y&#39;)</code>。<br>例如，如果左右两个 DataFrame 对象都有 <code>data</code> 列时，则结果中就会出现 <code>data_x</code> 和 <code>data_y</code></td></tr></tbody></table><h3 id="【03x01】一对一连接"><a href="#【03x01】一对一连接" class="headerlink" title="【03x01】一对一连接"></a><font color=#4876FF>【03x01】一对一连接</font></h3><p><font color=#FF0000><strong>一对一连接是指两个 DataFrame 对象的列的值没有重复值。</strong></font></p><p>如果不指定任何参数，调用 <code>merge</code> 方法，<code>merge</code> 就会将重叠的列的列名当做键来合并。</p><p>在下面的示例中，两个 DataFrame 对象都有一个列名为 <code>key</code> 的列，未指定按照哪一列来合并，<code>merge</code> 就会默认按照 <code>key</code> 来合并：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;b&#39;, &#39;a&#39;, &#39;c&#39;], &#39;data1&#39;: range(3)&#125;)&gt;&gt;&gt; obj2 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;c&#39;, &#39;b&#39;], &#39;data2&#39;: range(3)&#125;)&gt;&gt;&gt; obj1  key  data10   b      01   a      12   c      2&gt;&gt;&gt; &gt;&gt;&gt; obj2  key  data20   a      01   c      12   b      2&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(obj1, obj2)  key  data1  data20   b      0      21   a      1      02   c      2      1</code></pre><h3 id="【03x02】多对一连接"><a href="#【03x02】多对一连接" class="headerlink" title="【03x02】多对一连接"></a><font color=#4876FF>【03x02】多对一连接</font></h3><p><font color=#FF0000><strong>多对一连接是指两个 DataFrame 对象中，有一个的列的值有重复值。</strong></font>通过多对一连接获得的结果，DataFrame  将会保留重复值。</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;], &#39;data1&#39;: range(7)&#125;)&gt;&gt;&gt; obj2 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;d&#39;], &#39;data2&#39;: range(3)&#125;)&gt;&gt;&gt; &gt;&gt;&gt; obj1  key  data10   b      01   b      12   a      23   c      34   a      45   a      56   b      6&gt;&gt;&gt; &gt;&gt;&gt; obj2  key  data20   a      01   b      12   d      2&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(obj1, obj2)  key  data1  data20   b      0      11   b      1      12   b      6      13   a      2      04   a      4      05   a      5      0</code></pre><h3 id="【03x03】多对多连接"><a href="#【03x03】多对多连接" class="headerlink" title="【03x03】多对多连接"></a><font color=#4876FF>【03x03】多对多连接</font></h3><p><font color=#FF0000><strong>多对多连接是指两个 DataFrame 对象中的列的值都有重复值。</strong></font></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;], &#39;data1&#39;: range(4)&#125;)&gt;&gt;&gt; obj2 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;], &#39;data2&#39;: range(6)&#125;)&gt;&gt;&gt; obj1  key  data10   a      01   b      12   b      23   c      3&gt;&gt;&gt; &gt;&gt;&gt; obj2  key  data20   a      01   a      12   b      23   b      34   c      45   c      5&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(obj1, obj2)  key  data1  data20   a      0      01   a      0      12   b      1      23   b      1      34   b      2      25   b      2      36   c      3      47   c      3      5</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106830112未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h3 id="【03x04】参数-on-left-on-right-on"><a href="#【03x04】参数-on-left-on-right-on" class="headerlink" title="【03x04】参数 on / left_on / right_on"></a><font color=#4876FF>【03x04】参数 on / left_on / right_on</font></h3><p>参数 <code>on</code> 用于指定按照某一列来进行合并，若不指定该参数，则会默认按照重叠的列的列名当做键来合并：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;b&#39;, &#39;a&#39;, &#39;c&#39;], &#39;data1&#39;: range(3)&#125;)&gt;&gt;&gt; obj2 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;c&#39;, &#39;b&#39;], &#39;data2&#39;: range(3)&#125;)&gt;&gt;&gt; obj1  key  data10   b      01   a      12   c      2&gt;&gt;&gt; &gt;&gt;&gt; obj2  key  data20   a      01   c      12   b      2&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(obj1, obj2, on=&#39;key&#39;)  key  data1  data20   b      0      21   a      1      02   c      2      1</code></pre><p>如果要根据多个键进行合并，传入一个由列名组成的列表即可：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; left = pd.DataFrame(&#123;&#39;key1&#39;: [&#39;foo&#39;, &#39;foo&#39;, &#39;bar&#39;],             &#39;key2&#39;: [&#39;one&#39;, &#39;two&#39;, &#39;one&#39;],             &#39;lval&#39;: [1, 2, 3]&#125;)&gt;&gt;&gt; right = pd.DataFrame(&#123;&#39;key1&#39;: [&#39;foo&#39;, &#39;foo&#39;, &#39;bar&#39;, &#39;bar&#39;],              &#39;key2&#39;: [&#39;one&#39;, &#39;one&#39;, &#39;one&#39;, &#39;two&#39;],              &#39;rval&#39;: [4, 5, 6, 7]&#125;)&gt;&gt;&gt; left  key1 key2  lval0  foo  one     11  foo  two     22  bar  one     3&gt;&gt;&gt; &gt;&gt;&gt; right  key1 key2  rval0  foo  one     41  foo  one     52  bar  one     63  bar  two     7&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(left, right, on=[&#39;key1&#39;, &#39;key2&#39;])  key1 key2  lval  rval0  foo  one     1     41  foo  one     1     52  bar  one     3     6</code></pre><p>如果两个对象的列名不同，就可以使用 <code>left_on</code>、<code>right_on</code> 参数分别进行指定：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame(&#123;&#39;lkey&#39;: [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;], &#39;data1&#39;: range(7)&#125;)&gt;&gt;&gt; obj2 = pd.DataFrame(&#123;&#39;rkey&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;d&#39;], &#39;data2&#39;: range(3)&#125;)&gt;&gt;&gt; obj1  lkey  data10    b      01    b      12    a      23    c      34    a      45    a      56    b      6&gt;&gt;&gt; &gt;&gt;&gt; obj2  rkey  data20    a      01    b      12    d      2&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(obj1, obj2, left_on=&#39;lkey&#39;, right_on=&#39;rkey&#39;)  lkey  data1 rkey  data20    b      0    b      11    b      1    b      12    b      6    b      13    a      2    a      04    a      4    a      05    a      5    a      0</code></pre><h3 id="【03x05】参数-how"><a href="#【03x05】参数-how" class="headerlink" title="【03x05】参数 how"></a><font color=#4876FF>【03x05】参数 how</font></h3><p>在前面的示例中，结果里面 c 和 d 以及与之相关的数据消失了。默认情况下，<code>merge</code> 做的是内连接（<code>&#39;inner&#39;</code>），结果中的键是交集。其他方式还有：<code>&#39;left&#39;</code>、<code>&#39;right&#39;</code>、<code>&#39;outer&#39;</code>，含义如下：</p><ul><li><code>&#39;inner&#39;</code>：内连接，即使用两个对象中<font color=#FF0000><strong>都有</strong></font>的键（交集）；</li><li><code>&#39;outer&#39;</code>：外连接，即使用两个对象中<font color=#FF0000><strong>所有</strong></font>的键（并集）；</li><li><code>&#39;left&#39;</code>：左连接，即使用<font color=#FF0000><strong>左</strong></font>对象中所有的键；</li><li><code>&#39;right&#39;</code>：右连接，即使用<font color=#FF0000><strong>右</strong></font>对象中所有的键；</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;], &#39;data1&#39;: range(7)&#125;)&gt;&gt;&gt; obj2 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;d&#39;], &#39;data2&#39;: range(3)&#125;)&gt;&gt;&gt; obj1  key  data10   b      01   b      12   a      23   c      34   a      45   a      56   b      6&gt;&gt;&gt; &gt;&gt;&gt; obj2  key  data20   a      01   b      12   d      2&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(obj1, obj2, on=&#39;key&#39;, how=&#39;inner&#39;)  key  data1  data20   b      0      11   b      1      12   b      6      13   a      2      04   a      4      05   a      5      0&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(obj1, obj2, on=&#39;key&#39;, how=&#39;outer&#39;)  key  data1  data20   b    0.0    1.01   b    1.0    1.02   b    6.0    1.03   a    2.0    0.04   a    4.0    0.05   a    5.0    0.06   c    3.0    NaN7   d    NaN    2.0&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(obj1, obj2, on=&#39;key&#39;, how=&#39;left&#39;)  key  data1  data20   b      0    1.01   b      1    1.02   a      2    0.03   c      3    NaN4   a      4    0.05   a      5    0.06   b      6    1.0&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(obj1, obj2, on=&#39;key&#39;, how=&#39;right&#39;)  key  data1  data20   b    0.0      11   b    1.0      12   b    6.0      13   a    2.0      04   a    4.0      05   a    5.0      06   d    NaN      2</code></pre><h3 id="【03x06】参数-suffixes"><a href="#【03x06】参数-suffixes" class="headerlink" title="【03x06】参数 suffixes"></a><font color=#4876FF>【03x06】参数 suffixes</font></h3><p><code>suffixes</code> 参数用于指定附加到左右两个 DataFrame 对象的重叠列名上的字符串：</p><p>在以下示例中，选择按照 <code>key1</code> 进行合并，而两个 DataFrame 对象都包含 <code>key2</code> 列，如果未指定 <code>suffixes</code> 参数，则默认会为两个对象的 <code>key2</code> 加上 <code>_x</code> 和 <code>_y</code>，以便区分它们，如果指定了 <code>suffixes</code> 参数，就会按照添加指定的后缀：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; left = pd.DataFrame(&#123;&#39;key1&#39;: [&#39;foo&#39;, &#39;foo&#39;, &#39;bar&#39;],             &#39;key2&#39;: [&#39;one&#39;, &#39;two&#39;, &#39;one&#39;],             &#39;lval&#39;: [1, 2, 3]&#125;)&gt;&gt;&gt; right = pd.DataFrame(&#123;&#39;key1&#39;: [&#39;foo&#39;, &#39;foo&#39;, &#39;bar&#39;, &#39;bar&#39;],              &#39;key2&#39;: [&#39;one&#39;, &#39;one&#39;, &#39;one&#39;, &#39;two&#39;],              &#39;rval&#39;: [4, 5, 6, 7]&#125;)&gt;&gt;&gt; left  key1 key2  lval0  foo  one     11  foo  two     22  bar  one     3&gt;&gt;&gt; &gt;&gt;&gt; right  key1 key2  rval0  foo  one     41  foo  one     52  bar  one     63  bar  two     7&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(left, right, on=&#39;key1&#39;)  key1 key2_x  lval key2_y  rval0  foo    one     1    one     41  foo    one     1    one     52  foo    two     2    one     43  foo    two     2    one     54  bar    one     3    one     65  bar    one     3    two     7&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(left, right, on=&#39;key1&#39;, suffixes=(&#39;_left&#39;, &#39;_right&#39;))  key1 key2_left  lval key2_right  rval0  foo       one     1        one     41  foo       one     1        one     52  foo       two     2        one     43  foo       two     2        one     54  bar       one     3        one     65  bar       one     3        two     7</code></pre><h3 id="【03x07】参数-left-index-right-index"><a href="#【03x07】参数-left-index-right-index" class="headerlink" title="【03x07】参数 left_index / right_index"></a><font color=#4876FF>【03x07】参数 left_index / right_index</font></h3><p>有时候，DataFrame 中的连接键位于其索引中。在这种情况下，可以使用 <code>left_index=True</code> 或<code>right_index=True</code>（或两个都传）以说明索引应该被用作连接键。这种方法称为按索引连接，在 Pandas 中还有个 <code>join</code> 方法可以实现这个功能。</p><p>在以下示例中，按照 left 的 key 列进行连接，而 right 对象的连接键位于其索引中，因此要指定 <code>right_index=True</code>：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; left = pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;], &#39;value&#39;: range(6)&#125;)&gt;&gt;&gt; right = pd.DataFrame(&#123;&#39;group_val&#39;: [3.5, 7]&#125;, index=[&#39;a&#39;, &#39;b&#39;])&gt;&gt;&gt; left  key  value0   a      01   b      12   a      23   a      34   b      45   c      5&gt;&gt;&gt; &gt;&gt;&gt; right   group_vala        3.5b        7.0&gt;&gt;&gt; &gt;&gt;&gt; pd.merge(left, right, left_on=&#39;key&#39;, right_index=True)  key  value  group_val0   a      0        3.52   a      2        3.53   a      3        3.51   b      1        7.04   b      4        7.0</code></pre><h2 id="【04x00】join"><a href="#【04x00】join" class="headerlink" title="【04x00】join"></a><font color=#FF0000>【04x00】join</font></h2><p>join 方法只适用于 DataFrame 对象，Series 对象没有该方法，该方法用于连接另一个 DataFrame 对象的列（columns）。</p><p>基本语法：<code>DataFrame.join(self, other, on=None, how=&#39;left&#39;, lsuffix=&#39;&#39;, rsuffix=&#39;&#39;, sort=False) → ’DataFrame’</code></p><p>参数描述：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>other</td><td>另一个 DataFrame、Series 或 DataFrame 列表对象</td></tr><tr><td>on</td><td>列名称，或者列名称组成的列表、元组，连接的列</td></tr><tr><td>how</td><td>合并方式，默认 <code>&#39;left&#39;</code><br><code>&#39;inner&#39;</code>：内连接，即使用两个对象中<font color=#FF0000><strong>都有</strong></font>的键（交集）；<br><code>&#39;outer&#39;</code>：外连接，即使用两个对象中<font color=#FF0000><strong>所有</strong></font>的键（并集）；<br><code>&#39;left&#39;</code>：左连接，即使用<font color=#FF0000><strong>左</strong></font>对象中所有的键；<br><code>&#39;right&#39;</code>：右连接，即使用<font color=#FF0000><strong>右</strong></font>对象中所有的键；</td></tr><tr><td>lsuffix</td><td>当两个对象有相同的列名时，合并后左边数据列名的后缀</td></tr><tr><td>rsuffix</td><td>当两个对象有相同的列名时，合并后右边数据列名的后缀</td></tr><tr><td>sort</td><td>bool 类型，是否在结果中按顺序对连接键排序，默认 False。<br>如果为 False，则连接键的顺序取决于联接类型（how 关键字）</td></tr></tbody></table><p>使用 <code>lsuffix</code> 和 <code>rsuffix</code> 参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;key&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;, &#39;K3&#39;, &#39;K4&#39;, &#39;K5&#39;],            &#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;, &#39;A4&#39;, &#39;A5&#39;]&#125;)&gt;&gt;&gt; other = pd.DataFrame(&#123;&#39;key&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;],              &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;]&#125;)&gt;&gt;&gt; obj  key   A0  K0  A01  K1  A12  K2  A23  K3  A34  K4  A45  K5  A5&gt;&gt;&gt; &gt;&gt;&gt; other  key   B0  K0  B01  K1  B12  K2  B2&gt;&gt;&gt; &gt;&gt;&gt; obj.join(other, lsuffix=&#39;_1&#39;, rsuffix=&#39;_2&#39;)  key_1   A key_2    B0    K0  A0    K0   B01    K1  A1    K1   B12    K2  A2    K2   B23    K3  A3   NaN  NaN4    K4  A4   NaN  NaN5    K5  A5   NaN  NaN</code></pre><p>如果右表的索引是左表的某一列的值，这时可以将右表的索引和左表的列对齐合并这样的灵活方式进行合并：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;], &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;],&#39;key&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K0&#39;, &#39;K1&#39;]&#125;)&gt;&gt;&gt; other = pd.DataFrame(&#123;&#39;C&#39;: [&#39;C0&#39;, &#39;C1&#39;],&#39;D&#39;: [&#39;D0&#39;, &#39;D1&#39;]&#125;,index=[&#39;K0&#39;, &#39;K1&#39;])&gt;&gt;&gt; obj    A   B key0  A0  B0  K01  A1  B1  K12  A2  B2  K03  A3  B3  K1&gt;&gt;&gt; &gt;&gt;&gt; other     C   DK0  C0  D0K1  C1  D1&gt;&gt;&gt; &gt;&gt;&gt; obj.join(other, on=&#39;key&#39;)    A   B key   C   D0  A0  B0  K0  C0  D01  A1  B1  K1  C1  D12  A2  B2  K0  C0  D03  A3  B3  K1  C1  D1</code></pre><h2 id="【05x00】四种方法的区别"><a href="#【05x00】四种方法的区别" class="headerlink" title="【05x00】四种方法的区别"></a><font color=#FF0000>【05x00】四种方法的区别</font></h2><ul><li><p><code>concat</code>：可用于两个或多个 Series 或 DataFrame 对象间，通过 <code>axis</code> 参数指定按照行方向（增加行）或列方向（增加列）进合并操作，默认行合并（增加行），取并集；</p></li><li><p><code>append</code>：在一个 Series 或 DataFrame 对象后最追加另一个 Series 或 DataFrame 对象并返回一个新对象，不改变原对象的值。只能按行合并（增加行）。</p></li><li><p><code>merge</code>：只能对两个 DataFrame 对象进行合并，一般按照列方向（增加列）进行合并操作，按照行方向合并一般用 join 方法代替，默认列合并（增加列），取交集；</p></li><li><p><code>join</code>：只能对两个 DataFrame 对象进行合并，按照列方向（增加列）进行合并操作，默认左连接。</p></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106830112未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂/应用/合并</title>
      <link href="/article/030/"/>
      <url>/article/030/</url>
      
        <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106804881未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】GroupBy-机制"><a href="#【01x00】GroupBy-机制" class="headerlink" title="【01x00】GroupBy 机制"></a><font color=#FF0000>【01x00】GroupBy 机制</font></h2><p>对数据集进行分组并对各组应用一个函数（无论是聚合还是转换），通常是数据分析工作中的重要环节。在将数据集加载、融合、准备好之后，通常就是计算分组统计或生成透视表。Pandas 提供了一个灵活高效的 GroupBy 功能，虽然“分组”（group by）这个名字是借用 SQL 数据库语言的命令，但其理念引用发明 R 语言 frame 的 Hadley Wickham 的观点可能更合适：分裂（Split）、应用（Apply）和组合（Combine）。</p><p>分组运算过程：Split —&gt; Apply —&gt; Combine</p><ul><li>分裂（Split）：根据某些标准将数据分组；</li><li>应用（Apply）：对每个组独立应用一个函数；</li><li>合并（Combine）：把每个分组的计算结果合并起来。</li></ul><p>官方介绍：<a href="https://pandas.pydata.org/docs/user_guide/groupby.html">https://pandas.pydata.org/docs/user_guide/groupby.html</a></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A84/01.png" alt="01"></p><h2 id="【02x00】GroupBy-对象"><a href="#【02x00】GroupBy-对象" class="headerlink" title="【02x00】GroupBy 对象"></a><font color=#FF0000>【02x00】GroupBy 对象</font></h2><p>常见的 GroupBy 对象：Series.groupby、DataFrame.groupby，基本语法如下：</p><pre><code class="python">Series.groupby(self,               by=None,               axis=0,               level=None,               as_index: bool = True,               sort: bool = True,               group_keys: bool = True,               squeeze: bool = False,               observed: bool = False) → ’groupby_generic.SeriesGroupBy’</code></pre><pre><code class="python">DataFrame.groupby(self,                  by=None,                  axis=0,                  level=None,                  as_index: bool = True,                  sort: bool = True,                  group_keys: bool = True,                  squeeze: bool = False,                  observed: bool = False) → ’groupby_generic.DataFrameGroupBy’</code></pre><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.groupby.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.groupby.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html</a></p></li></ul><p>常用参数解释如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>by</td><td>映射、函数、标签或标签列表，用于确定分组依据的分组。如果 by 是函数，则会在对象索引的每个值上调用它。 <br>如果传递了 dict 或 Series，则将使用 Series 或 dict 的值来确定组（将 Series 的值首先对齐；请参见.align() 方法）。<br> 如果传递了 ndarray，则按原样使用这些值来确定组。标签或标签列表可以按自身中的列传递给分组。 注意，元组被解释为（单个）键</td></tr><tr><td>axis</td><td>沿指定轴拆分，默认 <code>0</code>，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>level</td><td>如果轴是  MultiIndex（层次结构），则按特定层级进行分组，默认 None</td></tr><tr><td>as_index</td><td>bool 类型，默认 True，对于聚合输出，返回以组标签为索引的对象。仅与 DataFrame 输入相关。<br><code>as_index=False</code> 实际上是“SQL样式”分组输出</td></tr><tr><td>sort</td><td>bool 类型，默认 True，对组键排序。关闭此选项可获得更好的性能。注：这不影响每组的观察顺序。Groupby 保留每个组中行的顺序</td></tr><tr><td>group_keys</td><td>bool 类型，默认 True，调用 apply 方法时，是否将组键（keys）添加到索引（ index）以标识块</td></tr><tr><td>squeeze</td><td>bool 类型，默认 False，如果可能，减少返回类型的维度，否则返回一致的类型</td></tr></tbody></table><p>groupby() 进行分组，GroupBy 对象没有进行实际运算，只是包含分组的中间数据，示例如下：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randn(8),    &#39;data2&#39;: np.random.randn(8)&#125;&gt;&gt;&gt; &gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj  key1   key2     data1     data20    a    one -0.804160 -0.8689051    b    one -0.086990  0.3257412    a    two  0.757992  0.5411013    b  three -0.281435  0.0978414    a    two  0.817757 -0.6436995    b    two -0.462760 -0.3211966    a    one -0.403699  0.6021387    a  three  0.883940 -0.850526&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;)&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x03CDB7C0&gt;&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;data1&#39;].groupby(obj[&#39;key1&#39;])&lt;pandas.core.groupby.generic.SeriesGroupBy object at 0x03CDB748&gt;</code></pre><h2 id="【03x00】GroupBy-Split-数据分裂"><a href="#【03x00】GroupBy-Split-数据分裂" class="headerlink" title="【03x00】GroupBy Split 数据分裂"></a><font color=#FF0000>【03x00】GroupBy Split 数据分裂</font></h2><h3 id="【03x01】分组运算"><a href="#【03x01】分组运算" class="headerlink" title="【03x01】分组运算"></a><font color=#4876FF>【03x01】分组运算</font></h3><p>前面通过 <code>groupby()</code> 方法获得了一个 GroupBy 对象，它实际上还没有进行任何计算，只是含有一些有关分组键 <code>obj[&#39;key1&#39;]</code> 的中间数据而已。换句话说，该对象已经有了接下来对各分组执行运算所需的一切信息。例如，我们可以调用 GroupBy 的 <code>mean()</code> 方法来计算分组平均值，<code>size()</code> 方法返回每个分组的元素个数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randn(8),    &#39;data2&#39;: np.random.randn(8)&#125;&gt;&gt;&gt; &gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj  key1   key2     data1     data20    a    one -0.544099 -0.6140791    b    one  2.193712  0.1010052    a    two -0.004683  0.8827703    b  three  0.312858  1.7321054    a    two  0.011089  0.0895875    b    two  0.292165  1.3276386    a    one -1.433291 -0.2389717    a  three -0.004724 -2.117326&gt;&gt;&gt; &gt;&gt;&gt; grouped1 = obj.groupby(&#39;key1&#39;)&gt;&gt;&gt; grouped2 = obj[&#39;data1&#39;].groupby(obj[&#39;key1&#39;])&gt;&gt;&gt; &gt;&gt;&gt; grouped1.mean()         data1     data2key1                    a    -0.395142 -0.399604b     0.932912  1.053583&gt;&gt;&gt; &gt;&gt;&gt; grouped2.mean()key1a   -0.395142b    0.932912Name: data1, dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; grouped1.size()key1a    5b    3dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; grouped2.size()key1a    5b    3Name: data1, dtype: int64</code></pre><h3 id="【03x02】按类型按列分组"><a href="#【03x02】按类型按列分组" class="headerlink" title="【03x02】按类型按列分组"></a><font color=#4876FF>【03x02】按类型按列分组</font></h3><p><code>groupby()</code> 方法 <code>axis</code> 参数默认是 0，通过设置也可以在其他任何轴上进行分组，也支持按照类型（dtype）进行分组：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randn(8),    &#39;data2&#39;: np.random.randn(8)&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj  key1   key2     data1     data20    a    one -0.607009  1.9483011    b    one  0.150818 -0.0250952    a    two -2.086024  0.3581643    b  three  0.446061  1.7087974    a    two  0.745457 -0.9809485    b    two  0.981877  2.1593276    a    one  0.804480 -0.4996617    a  three  0.112884  0.004367&gt;&gt;&gt; &gt;&gt;&gt; obj.dtypeskey1      objectkey2      objectdata1    float64data2    float64dtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(obj.dtypes, axis=1).size()float64    2object     2dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(obj.dtypes, axis=1).sum()    float64  object0  1.341291    aone1  0.125723    bone2 -1.727860    atwo3  2.154858  bthree4 -0.235491    atwo5  3.141203    btwo6  0.304819    aone7  0.117251  athree</code></pre><h3 id="【03x03】自定义分组"><a href="#【03x03】自定义分组" class="headerlink" title="【03x03】自定义分组"></a><font color=#4876FF>【03x03】自定义分组</font></h3><p><code>groupby()</code> 方法中可以一次传入多个数组的列表，也可以自定义一组分组键。也可以通过一个字典、一个函数，或者按照索引层级进行分组。</p><p>传入多个数组的列表：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randn(8),    &#39;data2&#39;: np.random.randn(8)&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj  key1   key2     data1     data20    a    one -0.841652  0.6880551    b    one  0.510042 -0.5611712    a    two -0.418862 -0.1459833    b  three -1.104698  0.5631584    a    two  0.329527 -0.8931085    b    two  0.753653 -0.3425206    a    one -0.882527 -1.1213297    a  three  1.726794  0.160244&gt;&gt;&gt; &gt;&gt;&gt; means = obj[&#39;data1&#39;].groupby([obj[&#39;key1&#39;], obj[&#39;key2&#39;]]).mean()&gt;&gt;&gt; meanskey1  key2 a     one     -0.862090      three    1.726794      two     -0.044667b     one      0.510042      three   -1.104698      two      0.753653Name: data1, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; means.unstack()key2       one     three       twokey1                              a    -0.862090  1.726794 -0.044667b     0.510042 -1.104698  0.753653</code></pre><p>自定义分组键：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;key1&#39; : [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;two&#39;, &#39;one&#39;, &#39;two&#39;, &#39;one&#39;],    &#39;data1&#39; : np.random.randn(5),    &#39;data2&#39; : np.random.randn(5)&#125;)&gt;&gt;&gt; obj  key1 key2     data1     data20    a  one -0.024003  0.3504801    a  two -0.767534 -0.1004262    b  one -0.594983 -1.9455803    b  two -0.374482  0.8175924    a  one  0.755452 -0.137759&gt;&gt;&gt; &gt;&gt;&gt; states = np.array([&#39;Wuhan&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;, &#39;Wuhan&#39;, &#39;Wuhan&#39;])&gt;&gt;&gt; years = np.array([2005, 2005, 2006, 2005, 2006])&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;data1&#39;].groupby([states, years]).mean()Beijing  2005   -0.767534         2006   -0.594983Wuhan    2005   -0.199242         2006    0.755452Name: data1, dtype: float64</code></pre><h4 id="【03x03x01】字典分组"><a href="#【03x03x01】字典分组" class="headerlink" title="【03x03x01】字典分组"></a><font color=#FFA500>【03x03x01】字典分组</font></h4><p>通过字典进行分组：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.random.randint(1, 10, (5,5)),    columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;],    index=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])&gt;&gt;&gt; obj   a  b  c  d  eA  1  4  7  1  9B  8  2  4  7  8C  9  8  2  5  1D  2  4  2  8  3E  7  5  7  2  3&gt;&gt;&gt; &gt;&gt;&gt; obj_dict = &#123;&#39;a&#39;:&#39;Python&#39;, &#39;b&#39;:&#39;Python&#39;, &#39;c&#39;:&#39;Java&#39;, &#39;d&#39;:&#39;C++&#39;, &#39;e&#39;:&#39;Java&#39;&#125;&gt;&gt;&gt; obj.groupby(obj_dict, axis=1).size()C++       1Java      2Python    2dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(obj_dict, axis=1).count()   C++  Java  PythonA    1     2       2B    1     2       2C    1     2       2D    1     2       2E    1     2       2&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(obj_dict, axis=1).sum()   C++  Java  PythonA    1    16       5B    7    12      10C    5     3      17D    8     5       6E    2    10      12</code></pre><h4 id="【03x03x02】函数分组"><a href="#【03x03x02】函数分组" class="headerlink" title="【03x03x02】函数分组"></a><font color=#FFA500>【03x03x02】函数分组</font></h4><p>通过函数进行分组：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.random.randint(1, 10, (5,5)),        columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;],        index=[&#39;AA&#39;, &#39;BBB&#39;, &#39;CC&#39;, &#39;D&#39;, &#39;EE&#39;])&gt;&gt;&gt; obj     a  b  c  d  eAA   3  9  5  8  2BBB  1  4  2  2  6CC   9  2  4  7  6D    2  5  5  7  1EE   8  8  8  2  2&gt;&gt;&gt; &gt;&gt;&gt; def group_key(idx):        &quot;&quot;&quot;            idx 为列索引或行索引        &quot;&quot;&quot;        return len(idx)&gt;&gt;&gt; obj.groupby(group_key).size()    # 等价于 obj.groupby(len).size()1    12    33    1dtype: int64</code></pre><h4 id="【03x03x03】索引层级分组"><a href="#【03x03x03】索引层级分组" class="headerlink" title="【03x03x03】索引层级分组"></a><font color=#FFA500>【03x03x03】索引层级分组</font></h4><p>通过不同索引层级进行分组：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; columns = pd.MultiIndex.from_arrays([[&#39;Python&#39;, &#39;Java&#39;, &#39;Python&#39;, &#39;Java&#39;, &#39;Python&#39;],    [&#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;B&#39;]], names=[&#39;language&#39;, &#39;index&#39;])&gt;&gt;&gt; obj = pd.DataFrame(np.random.randint(1, 10, (5, 5)), columns=columns)&gt;&gt;&gt; objlanguage Python Java Python Java Pythonindex         A    A      B    C      B0             7    1      9    8      51             4    5      4    5      62             4    3      1    9      53             6    6      3    8      14             7    9      2    8      2&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(level=&#39;language&#39;, axis=1).sum()language  Java  Python0            9      211           10      142           12      103           14      104           17      11&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(level=&#39;index&#39;, axis=1).sum()index   A   B  C0       8  14  81       9  10  52       7   6  93      12   4  84      16   4  8</code></pre><h3 id="【03x04】分组迭代"><a href="#【03x04】分组迭代" class="headerlink" title="【03x04】分组迭代"></a><font color=#4876FF>【03x04】分组迭代</font></h3><p>GroupBy 对象支持迭代，对于单层分组，可以产生一组二元元组，由分组名和数据块组成：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randn(8),    &#39;data2&#39;: np.random.randn(8)&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj  key1   key2     data1     data20    a    one -1.088762  0.6685041    b    one  0.275500  0.7878442    a    two -0.108417 -0.4912963    b  three  0.019524 -0.3633904    a    two  0.453612  0.7969995    b    two  1.982858  1.5018776    a    one  1.101132 -1.9283627    a  three  0.524775 -1.205842&gt;&gt;&gt; &gt;&gt;&gt; for group_name, group_data in obj.groupby(&#39;key1&#39;):    print(group_name)    print(group_data)    a  key1   key2     data1     data20    a    one -1.088762  0.6685042    a    two -0.108417 -0.4912964    a    two  0.453612  0.7969996    a    one  1.101132 -1.9283627    a  three  0.524775 -1.205842b  key1   key2     data1     data21    b    one  0.275500  0.7878443    b  three  0.019524 -0.3633905    b    two  1.982858  1.501877</code></pre><p>对于多层分组，元组的第一个元素将会是由键值组成的元组，第二个元素为数据块：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randn(8),    &#39;data2&#39;: np.random.randn(8)&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj  key1   key2     data1     data20    a    one -1.088762  0.6685041    b    one  0.275500  0.7878442    a    two -0.108417 -0.4912963    b  three  0.019524 -0.3633904    a    two  0.453612  0.7969995    b    two  1.982858  1.5018776    a    one  1.101132 -1.9283627    a  three  0.524775 -1.205842&gt;&gt;&gt; &gt;&gt;&gt; for group_name, group_data in obj.groupby([&#39;key1&#39;, &#39;key2&#39;]):    print(group_name)    print(group_data)    (&#39;a&#39;, &#39;one&#39;)  key1 key2     data1     data20    a  one -1.088762  0.6685046    a  one  1.101132 -1.928362(&#39;a&#39;, &#39;three&#39;)  key1   key2     data1     data27    a  three  0.524775 -1.205842(&#39;a&#39;, &#39;two&#39;)  key1 key2     data1     data22    a  two -0.108417 -0.4912964    a  two  0.453612  0.796999(&#39;b&#39;, &#39;one&#39;)  key1 key2   data1     data21    b  one  0.2755  0.787844(&#39;b&#39;, &#39;three&#39;)  key1   key2     data1    data23    b  three  0.019524 -0.36339(&#39;b&#39;, &#39;two&#39;)  key1 key2     data1     data25    b  two  1.982858  1.501877</code></pre><h3 id="【03x05】对象转换"><a href="#【03x05】对象转换" class="headerlink" title="【03x05】对象转换"></a><font color=#4876FF>【03x05】对象转换</font></h3><p>GroupBy 对象支持转换成列表或字典：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randn(8),    &#39;data2&#39;: np.random.randn(8)&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj  key1   key2     data1     data20    a    one -0.607009  1.9483011    b    one  0.150818 -0.0250952    a    two -2.086024  0.3581643    b  three  0.446061  1.7087974    a    two  0.745457 -0.9809485    b    two  0.981877  2.1593276    a    one  0.804480 -0.4996617    a  three  0.112884  0.004367&gt;&gt;&gt; &gt;&gt;&gt; grouped = obj.groupby(&#39;key1&#39;)&gt;&gt;&gt; list(grouped)[(&#39;a&#39;,   key1   key2     data1     data20    a    one -0.607009  1.9483012    a    two -2.086024  0.3581644    a    two  0.745457 -0.9809486    a    one  0.804480 -0.4996617    a  three  0.112884  0.004367),(&#39;b&#39;,   key1   key2     data1     data21    b    one  0.150818 -0.0250953    b  three  0.446061  1.7087975    b    two  0.981877  2.159327)]&gt;&gt;&gt;&gt;&gt;&gt; dict(list(grouped))&#123;&#39;a&#39;:   key1   key2     data1     data20    a    one -0.607009  1.9483012    a    two -2.086024  0.3581644    a    two  0.745457 -0.9809486    a    one  0.804480 -0.4996617    a  three  0.112884  0.004367,&#39;b&#39;:   key1   key2     data1     data21    b    one  0.150818 -0.0250953    b  three  0.446061  1.7087975    b    two  0.981877  2.159327&#125;</code></pre><h2 id="【04x00】GroupBy-Apply-数据应用"><a href="#【04x00】GroupBy-Apply-数据应用" class="headerlink" title="【04x00】GroupBy Apply 数据应用"></a><font color=#FF0000>【04x00】GroupBy Apply 数据应用</font></h2><p>聚合指的是任何能够从数组产生标量值的数据转换过程，常用于对分组后的数据进行计算</p><h3 id="【04x01】聚合函数"><a href="#【04x01】聚合函数" class="headerlink" title="【04x01】聚合函数"></a><font color=#4876FF>【04x01】聚合函数</font></h3><p>之前的例子已经用过一些内置的聚合函数，比如 mean、count、min 以及 sum 等。常见的聚合运算如下表所示：</p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/groupby.html">https://pandas.pydata.org/docs/reference/groupby.html</a></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>count</td><td>非NA值的数量</td></tr><tr><td>describe</td><td>针对Series或各DataFrame列计算汇总统计</td></tr><tr><td>min</td><td>计算最小值</td></tr><tr><td>max</td><td>计算最大值</td></tr><tr><td>argmin</td><td>计算能够获取到最小值的索引位置（整数）</td></tr><tr><td>argmax</td><td>计算能够获取到最大值的索引位置（整数）</td></tr><tr><td>idxmin</td><td>计算能够获取到最小值的索引值</td></tr><tr><td>idxmax</td><td>计算能够获取到最大值的索引值</td></tr><tr><td>quantile</td><td>计算样本的分位数（0到1）</td></tr><tr><td>sum</td><td>值的总和</td></tr><tr><td>mean</td><td>值的平均数</td></tr><tr><td>median</td><td>值的算术中位数（50%分位数）</td></tr><tr><td>mad</td><td>根据平均值计算平均绝对离差</td></tr><tr><td>var</td><td>样本值的方差</td></tr><tr><td>std</td><td>样本值的标准差</td></tr></tbody></table><p>应用示例：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randint(1,10, 8),    &#39;data2&#39;: np.random.randint(1,10, 8)&#125;&gt;&gt;&gt; obj = pd.DataFrame(obj)&gt;&gt;&gt; obj  key1   key2  data1  data20    a    one      9      71    b    one      5      92    a    two      2      43    b  three      3      44    a    two      5      15    b    two      5      96    a    one      1      87    a  three      2      4&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).sum()      data1  data2key1              a        19     24b        13     22&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).max()     key2  data1  data2key1                   a     two      9      8b     two      5      9&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).min()     key2  data1  data2key1                   a     one      1      1b     one      3      4&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).mean()         data1     data2key1                    a     3.800000  4.800000b     4.333333  7.333333&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).size()key1a    5b    3dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).count()      key2  data1  data2key1                    a        5      5      5b        3      3      3&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).describe()     data1                                ... data2                         count      mean       std  min  25%  ...   min  25%  50%  75%  maxkey1                                      ...                          a      5.0  3.800000  3.271085  1.0  2.0  ...   1.0  4.0  4.0  7.0  8.0b      3.0  4.333333  1.154701  3.0  4.0  ...   4.0  6.5  9.0  9.0  9.0[2 rows x 16 columns]</code></pre><h3 id="【04x02】自定义函数"><a href="#【04x02】自定义函数" class="headerlink" title="【04x02】自定义函数"></a><font color=#4876FF>【04x02】自定义函数</font></h3><p>如果自带的内置函数满足不了我们的要求，则可以自定义一个聚合函数，然后传入 <code>GroupBy.agg(func)</code> 或 <code>GroupBy.aggregate(func) </code> 方法中即可。func 的参数为 groupby 索引对应的记录。</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randint(1,10, 8),    &#39;data2&#39;: np.random.randint(1,10, 8)&#125;&gt;&gt;&gt; obj = pd.DataFrame(obj)&gt;&gt;&gt; obj  key1   key2  data1  data20    a    one      9      71    b    one      5      92    a    two      2      43    b  three      3      44    a    two      5      15    b    two      5      96    a    one      1      87    a  three      2      4&gt;&gt;&gt; &gt;&gt;&gt; def peak_range(df):    return df.max() - df.min()&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).agg(peak_range)      data1  data2key1              a         8      7b         2      5&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).agg(lambda df : df.max() - df.min())      data1  data2key1              a         8      7b         2      5</code></pre><h3 id="【04x03】对不同列作用不同函数"><a href="#【04x03】对不同列作用不同函数" class="headerlink" title="【04x03】对不同列作用不同函数"></a><font color=#4876FF>【04x03】对不同列作用不同函数</font></h3><p>使用字典可以对不同列作用不同的聚合函数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],    &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],    &#39;data1&#39;: np.random.randint(1,10, 8),    &#39;data2&#39;: np.random.randint(1,10, 8)&#125;&gt;&gt;&gt; obj = pd.DataFrame(obj)&gt;&gt;&gt; obj  key1   key2  data1  data20    a    one      9      71    b    one      5      92    a    two      2      43    b  three      3      44    a    two      5      15    b    two      5      96    a    one      1      87    a  three      2      4&gt;&gt;&gt; &gt;&gt;&gt; dict1 = &#123;&#39;data1&#39;:&#39;mean&#39;, &#39;data2&#39;:&#39;sum&#39;&#125;&gt;&gt;&gt; dict2 = &#123;&#39;data1&#39;:[&#39;mean&#39;,&#39;max&#39;], &#39;data2&#39;:&#39;sum&#39;&#125;&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).agg(dict1)         data1  data2key1                 a     3.800000     24b     4.333333     22&gt;&gt;&gt; &gt;&gt;&gt; obj.groupby(&#39;key1&#39;).agg(dict2)         data1     data2          mean max   sumkey1                    a     3.800000   9    24b     4.333333   5    22</code></pre><h3 id="【04x04】GroupBy-apply"><a href="#【04x04】GroupBy-apply" class="headerlink" title="【04x04】GroupBy.apply()"></a><font color=#4876FF>【04x04】GroupBy.apply()</font></h3><p><code>apply()</code> 方法会将待处理的对象拆分成多个片段，然后对各片段调用传入的函数，最后尝试将各片段组合到一起。</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;A&#39;:[&#39;bob&#39;,&#39;sos&#39;,&#39;bob&#39;,&#39;sos&#39;,&#39;bob&#39;,&#39;sos&#39;,&#39;bob&#39;,&#39;bob&#39;],              &#39;B&#39;:[&#39;one&#39;,&#39;one&#39;,&#39;two&#39;,&#39;three&#39;,&#39;two&#39;,&#39;two&#39;,&#39;one&#39;,&#39;three&#39;],              &#39;C&#39;:[3,1,4,1,5,9,2,6],              &#39;D&#39;:[1,2,3,4,5,6,7,8]&#125;)&gt;&gt;&gt; obj     A      B  C  D0  bob    one  3  11  sos    one  1  22  bob    two  4  33  sos  three  1  44  bob    two  5  55  sos    two  9  66  bob    one  2  77  bob  three  6  8&gt;&gt;&gt; &gt;&gt;&gt; grouped = obj.groupby(&#39;A&#39;)&gt;&gt;&gt; for name, group in grouped:    print(name)    print(group)    bob     A      B  C  D0  bob    one  3  12  bob    two  4  34  bob    two  5  56  bob    one  2  77  bob  three  6  8sos     A      B  C  D1  sos    one  1  23  sos  three  1  45  sos    two  9  6&gt;&gt;&gt; &gt;&gt;&gt; grouped.apply(lambda x:x.describe())  # 对 bob 和 sos 两组数据使用 describe 方法                  C         DA                            bob count  5.000000  5.000000    mean   4.000000  4.800000    std    1.581139  2.863564    min    2.000000  1.000000    25%    3.000000  3.000000    50%    4.000000  5.000000    75%    5.000000  7.000000    max    6.000000  8.000000sos count  3.000000  3.000000    mean   3.666667  4.000000    std    4.618802  2.000000    min    1.000000  2.000000    25%    1.000000  3.000000    50%    1.000000  4.000000    75%    5.000000  5.000000    max    9.000000  6.000000&gt;&gt;&gt;&gt;&gt;&gt; grouped.apply(lambda x:x.min())  # # 对 bob 和 sos 两组数据使用 min 方法       A    B  C  DA                  bob  bob  one  2  1sos  sos  one  1  2</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106804881未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</title>
      <link href="/article/029/"/>
      <url>/article/029/</url>
      
        <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106788501未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】统计计算"><a href="#【01x00】统计计算" class="headerlink" title="【01x00】统计计算"></a><font color=#FF0000>【01x00】统计计算</font></h2><p>Pandas 对象拥有一组常用的数学和统计方法。它们大部分都属于约简和汇总统计，用于从 Series 中提取单个值（如 sum 或 mean）或从 DataFrame 的行或列中提取一个 Series。跟对应的 NumPy 数组方法相比，它们都是基于没有缺失数据的假设而构建的。</p><h3 id="【01x01】sum-求和"><a href="#【01x01】sum-求和" class="headerlink" title="【01x01】sum() 求和"></a><font color=#4876FF>【01x01】sum() 求和</font></h3><p><code>sum()</code> 方法用于返回指定轴的和，相当于 <code>numpy.sum()</code>。</p><p>在 Series 和 DataFrame 中的基本语法如下：</p><ul><li><p><code>Series.sum(self, axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs)</code></p></li><li><p><code>DataFrame.sum(self, axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.sum.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.sum.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sum.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sum.html</a></p></li></ul><p>常用参数描述如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>axis</td><td>指定轴求和，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>skipna</td><td>bool 类型，求和时是否排除缺失值（NA/null），默认 True</td></tr><tr><td>level</td><td>如果轴是 MultiIndex（层次结构），则沿指定层次求和</td></tr></tbody></table><p>在 Series 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([    [&#39;warm&#39;, &#39;warm&#39;, &#39;cold&#39;, &#39;cold&#39;],    [&#39;dog&#39;, &#39;falcon&#39;, &#39;fish&#39;, &#39;spider&#39;]],    names=[&#39;blooded&#39;, &#39;animal&#39;])&gt;&gt;&gt; obj = pd.Series([4, 2, 0, 8], name=&#39;legs&#39;, index=idx)&gt;&gt;&gt; objblooded  animalwarm     dog       4         falcon    2cold     fish      0         spider    8Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.sum()14&gt;&gt;&gt; &gt;&gt;&gt; obj.sum(level=&#39;blooded&#39;)bloodedwarm    6cold    8Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.sum(level=0)bloodedwarm    6cold    8Name: legs, dtype: int64</code></pre><p>在 DataFrame 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1.4, np.nan], [7.1, -4.5],    [np.nan, np.nan], [0.75, -1.3]],    index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;],    columns=[&#39;one&#39;, &#39;two&#39;])&gt;&gt;&gt; obj    one  twoa  1.40  NaNb  7.10 -4.5c   NaN  NaNd  0.75 -1.3&gt;&gt;&gt; &gt;&gt;&gt; obj.sum()one    9.25two   -5.80dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.sum(axis=1)a    1.40b    2.60c    0.00d   -0.55dtype: float64</code></pre><h3 id="【01x02】min-最小值"><a href="#【01x02】min-最小值" class="headerlink" title="【01x02】min() 最小值"></a><font color=#4876FF>【01x02】min() 最小值</font></h3><p><code>min()</code> 方法用于返回指定轴的最小值。</p><p>在 Series 和 DataFrame 中的基本语法如下：</p><ul><li><p><code>Series.min(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs)</code></p></li><li><p><code>DataFrame.min(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.min.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.min.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.min.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.min.html</a></p></li></ul><p>常用参数描述如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>axis</td><td>指定轴求最小值，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>skipna</td><td>bool 类型，求最小值时是否排除缺失值（NA/null），默认 True</td></tr><tr><td>level</td><td>如果轴是 MultiIndex（层次结构），则沿指定层次求最小值</td></tr></tbody></table><p>在 Series 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([    [&#39;warm&#39;, &#39;warm&#39;, &#39;cold&#39;, &#39;cold&#39;],    [&#39;dog&#39;, &#39;falcon&#39;, &#39;fish&#39;, &#39;spider&#39;]],    names=[&#39;blooded&#39;, &#39;animal&#39;])&gt;&gt;&gt; obj = pd.Series([4, 2, 0, 8], name=&#39;legs&#39;, index=idx)&gt;&gt;&gt; objblooded  animalwarm     dog       4         falcon    2cold     fish      0         spider    8Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.min()0&gt;&gt;&gt; &gt;&gt;&gt; obj.min(level=&#39;blooded&#39;)bloodedwarm    2cold    0Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.min(level=0)bloodedwarm    2cold    0Name: legs, dtype: int64</code></pre><p>在 DataFrame 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1.4, np.nan], [7.1, -4.5],    [np.nan, np.nan], [0.75, -1.3]],    index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;],columns=[&#39;one&#39;, &#39;two&#39;])&gt;&gt;&gt; obj    one  twoa  1.40  NaNb  7.10 -4.5c   NaN  NaNd  0.75 -1.3&gt;&gt;&gt; &gt;&gt;&gt; obj.min()one    0.75two   -4.50dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.min(axis=1)a    1.4b   -4.5c    NaNd   -1.3dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.min(axis=&#39;columns&#39;, skipna=False)a    NaNb   -4.5c    NaNd   -1.3dtype: float64</code></pre><h3 id="【01x03】max-最大值"><a href="#【01x03】max-最大值" class="headerlink" title="【01x03】max() 最大值"></a><font color=#4876FF>【01x03】max() 最大值</font></h3><p><code>max()</code> 方法用于返回指定轴的最大值。</p><p>在 Series 和 DataFrame 中的基本语法如下：</p><ul><li><p><code>Series.max(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs)</code></p></li><li><p><code>DataFrame.max(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.max.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.max.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.max.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.max.html</a></p></li></ul><p>常用参数描述如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>axis</td><td>指定轴求最大值，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>skipna</td><td>bool 类型，求最大值时是否排除缺失值（NA/null），默认 True</td></tr><tr><td>level</td><td>如果轴是 MultiIndex（层次结构），则沿指定层次求最大值</td></tr></tbody></table><p>在 Series 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([    [&#39;warm&#39;, &#39;warm&#39;, &#39;cold&#39;, &#39;cold&#39;],    [&#39;dog&#39;, &#39;falcon&#39;, &#39;fish&#39;, &#39;spider&#39;]],    names=[&#39;blooded&#39;, &#39;animal&#39;])&gt;&gt;&gt; obj = pd.Series([4, 2, 0, 8], name=&#39;legs&#39;, index=idx)&gt;&gt;&gt; objblooded  animalwarm     dog       4         falcon    2cold     fish      0         spider    8Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.max()8&gt;&gt;&gt; &gt;&gt;&gt; obj.max(level=&#39;blooded&#39;)bloodedwarm    4cold    8Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.max(level=0)bloodedwarm    4cold    8Name: legs, dtype: int64</code></pre><p>在 DataFrame 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1.4, np.nan], [7.1, -4.5],    [np.nan, np.nan], [0.75, -1.3]],    index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;],columns=[&#39;one&#39;, &#39;two&#39;])&gt;&gt;&gt; obj    one  twoa  1.40  NaNb  7.10 -4.5c   NaN  NaNd  0.75 -1.3&gt;&gt;&gt; &gt;&gt;&gt; obj.max()one    7.1two   -1.3dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.max(axis=1)a    1.40b    7.10c     NaNd    0.75dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.max(axis=&#39;columns&#39;, skipna=False)a     NaNb    7.10c     NaNd    0.75dtype: float64</code></pre><h3 id="【01x04】mean-平均值"><a href="#【01x04】mean-平均值" class="headerlink" title="【01x04】mean() 平均值"></a><font color=#4876FF>【01x04】mean() 平均值</font></h3><p><code>mean()</code> 方法用于返回指定轴的平均值。</p><p>在 Series 和 DataFrame 中的基本语法如下：</p><ul><li><p><code>Series.mean(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs)</code></p></li><li><p><code>DataFrame.mean(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.mean.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.mean.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mean.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mean.html</a></p></li></ul><p>常用参数描述如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>axis</td><td>指定轴求平均值，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>skipna</td><td>bool 类型，求平均值时是否排除缺失值（NA/null），默认 True</td></tr><tr><td>level</td><td>如果轴是 MultiIndex（层次结构），则沿指定层次求平均值</td></tr></tbody></table><p>在 Series 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([    [&#39;warm&#39;, &#39;warm&#39;, &#39;cold&#39;, &#39;cold&#39;],    [&#39;dog&#39;, &#39;falcon&#39;, &#39;fish&#39;, &#39;spider&#39;]],    names=[&#39;blooded&#39;, &#39;animal&#39;])&gt;&gt;&gt; obj = pd.Series([4, 2, 0, 8], name=&#39;legs&#39;, index=idx)&gt;&gt;&gt; objblooded  animalwarm     dog       4         falcon    2cold     fish      0         spider    8Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.mean()3.5&gt;&gt;&gt; &gt;&gt;&gt; obj.mean(level=&#39;blooded&#39;)bloodedwarm    3cold    4Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.mean(level=0)bloodedwarm    3cold    4Name: legs, dtype: int64</code></pre><p>在 DataFrame 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1.4, np.nan], [7.1, -4.5],    [np.nan, np.nan], [0.75, -1.3]],    index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;],columns=[&#39;one&#39;, &#39;two&#39;])&gt;&gt;&gt; obj    one  twoa  1.40  NaNb  7.10 -4.5c   NaN  NaNd  0.75 -1.3&gt;&gt;&gt; &gt;&gt;&gt; obj.mean()one    3.083333two   -2.900000dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.mean(axis=1)a    1.400b    1.300c      NaNd   -0.275dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.mean(axis=&#39;columns&#39;, skipna=False)a      NaNb    1.300c      NaNd   -0.275dtype: float64</code></pre><h3 id="【01x05】idxmin-最小值索引"><a href="#【01x05】idxmin-最小值索引" class="headerlink" title="【01x05】idxmin() 最小值索引"></a><font color=#4876FF>【01x05】idxmin() 最小值索引</font></h3><p><code>idxmin()</code> 方法用于返回最小值的索引。</p><p>在 Series 和 DataFrame 中的基本语法如下：</p><ul><li><p><code>Series.idxmin(self, axis=0, skipna=True, *args, **kwargs)</code></p></li><li><p><code>DataFrame.idxmin(self, axis=0, skipna=True)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.idxmin.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.idxmin.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.idxmin.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.idxmin.html</a></p></li></ul><p>常用参数描述如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>axis</td><td>指定轴，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>skipna</td><td>bool 类型，是否排除缺失值（NA/null），默认 True</td></tr></tbody></table><p>在 Series 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([    [&#39;warm&#39;, &#39;warm&#39;, &#39;cold&#39;, &#39;cold&#39;],    [&#39;dog&#39;, &#39;falcon&#39;, &#39;fish&#39;, &#39;spider&#39;]],    names=[&#39;blooded&#39;, &#39;animal&#39;])&gt;&gt;&gt; obj = pd.Series([4, 2, 0, 8], name=&#39;legs&#39;, index=idx)&gt;&gt;&gt; objblooded  animalwarm     dog       4         falcon    2cold     fish      0         spider    8Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.idxmin()(&#39;cold&#39;, &#39;fish&#39;)</code></pre><p>在 DataFrame 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1.4, np.nan], [7.1, -4.5],    [np.nan, np.nan], [0.75, -1.3]],    index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;],columns=[&#39;one&#39;, &#39;two&#39;])&gt;&gt;&gt; obj    one  twoa  1.40  NaNb  7.10 -4.5c   NaN  NaNd  0.75 -1.3&gt;&gt;&gt; &gt;&gt;&gt; obj.idxmin()one    dtwo    bdtype: object</code></pre><h3 id="【01x06】idxmax-最大值索引"><a href="#【01x06】idxmax-最大值索引" class="headerlink" title="【01x06】idxmax() 最大值索引"></a><font color=#4876FF>【01x06】idxmax() 最大值索引</font></h3><p><code>idxmax()</code> 方法用于返回最大值的索引。</p><p>在 Series 和 DataFrame 中的基本语法如下：</p><ul><li><p><code>Series.idxmax(self, axis=0, skipna=True, *args, **kwargs)</code></p></li><li><p><code>DataFrame.idxmax(self, axis=0, skipna=True)</code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.idxmax.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.idxmax.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.idxmax.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.idxmax.html</a></p></li></ul><p>常用参数描述如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>axis</td><td>指定轴，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>skipna</td><td>bool 类型，是否排除缺失值（NA/null），默认 True</td></tr></tbody></table><p>在 Series 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([    [&#39;warm&#39;, &#39;warm&#39;, &#39;cold&#39;, &#39;cold&#39;],    [&#39;dog&#39;, &#39;falcon&#39;, &#39;fish&#39;, &#39;spider&#39;]],    names=[&#39;blooded&#39;, &#39;animal&#39;])&gt;&gt;&gt; obj = pd.Series([4, 2, 0, 8], name=&#39;legs&#39;, index=idx)&gt;&gt;&gt; objblooded  animalwarm     dog       4         falcon    2cold     fish      0         spider    8Name: legs, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.idxmax()(&#39;cold&#39;, &#39;spider&#39;)</code></pre><p>在 DataFrame 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1.4, np.nan], [7.1, -4.5],    [np.nan, np.nan], [0.75, -1.3]],    index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;],columns=[&#39;one&#39;, &#39;two&#39;])&gt;&gt;&gt; obj    one  twoa  1.40  NaNb  7.10 -4.5c   NaN  NaNd  0.75 -1.3&gt;&gt;&gt; &gt;&gt;&gt; obj.idxmax()one    btwo    ddtype: object</code></pre><h2 id="【02x00】统计描述"><a href="#【02x00】统计描述" class="headerlink" title="【02x00】统计描述"></a><font color=#FF0000>【02x00】统计描述</font></h2><p><code>describe()</code> 方法用于快速综合统计结果：计数、均值、标准差、最大最小值、四分位数等。还可以通过参数来设置需要忽略或者包含的统计选项。</p><p>在 Series 和 DataFrame 中的基本语法如下：</p><ul><li><p><code>Series.describe(self: ~ FrameOrSeries, percentiles=None, include=None, exclude=None)</code></p></li><li><p><code>DataFrame.describe(self: ~ FrameOrSeries, percentiles=None, include=None, exclude=None) </code></p></li></ul><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.describe.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.describe.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.describe.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.describe.html</a></p></li></ul><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>percentiles</td><td>数字列表，可选项，要包含在输出中的百分比。所有值都应介于 0 和 1 之间。默认值为 [.25、.5、.75]，即返回第 25、50 和 75 个百分点</td></tr><tr><td>include</td><td>要包含在结果中的数据类型，数据类型列表，默认 None，具体取值类型参见官方文档</td></tr><tr><td>exclude</td><td>要从结果中忽略的数据类型，数据类型列表，默认 None，具体取值类型参见官方文档</td></tr></tbody></table><p>描述数字形式的 Series 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 2, 3])&gt;&gt;&gt; obj0    11    22    3dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.describe()count    3.0mean     2.0std      1.0min      1.025%      1.550%      2.075%      2.5max      3.0dtype: float64</code></pre><p>分类描述：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;])&gt;&gt;&gt; obj0    a1    a2    b3    cdtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.describe()count     4unique    3top       afreq      2dtype: object</code></pre><p>描述时间戳：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj  = pd.Series([    np.datetime64(&quot;2000-01-01&quot;),    np.datetime64(&quot;2010-01-01&quot;),    np.datetime64(&quot;2010-01-01&quot;)    ])&gt;&gt;&gt; obj0   2000-01-011   2010-01-012   2010-01-01dtype: datetime64[ns]&gt;&gt;&gt; &gt;&gt;&gt; obj.describe()count                       3unique                      2top       2010-01-01 00:00:00freq                        2first     2000-01-01 00:00:00last      2010-01-01 00:00:00dtype: object</code></pre><p>描述 DataFrame 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;categorical&#39;: pd.Categorical([&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]), &#39;numeric&#39;: [1, 2, 3], &#39;object&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&#125;)&gt;&gt;&gt; obj  categorical  numeric object0           d        1      a1           e        2      b2           f        3      c&gt;&gt;&gt; &gt;&gt;&gt; obj.describe()       numericcount      3.0mean       2.0std        1.0min        1.025%        1.550%        2.075%        2.5max        3.0</code></pre><p>不考虑数据类型，显示所有描述：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;categorical&#39;: pd.Categorical([&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]), &#39;numeric&#39;: [1, 2, 3], &#39;object&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&#125;)&gt;&gt;&gt; obj  categorical  numeric object0           d        1      a1           e        2      b2           f        3      c&gt;&gt;&gt; &gt;&gt;&gt; obj.describe(include=&#39;all&#39;)       categorical  numeric objectcount            3      3.0      3unique           3      NaN      3top              f      NaN      cfreq             1      NaN      1mean           NaN      2.0    NaNstd            NaN      1.0    NaNmin            NaN      1.0    NaN25%            NaN      1.5    NaN50%            NaN      2.0    NaN75%            NaN      2.5    NaNmax            NaN      3.0    NaN</code></pre><p>仅包含 category 列：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;categorical&#39;: pd.Categorical([&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]), &#39;numeric&#39;: [1, 2, 3], &#39;object&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&#125;)&gt;&gt;&gt; obj  categorical  numeric object0           d        1      a1           e        2      b2           f        3      c&gt;&gt;&gt; &gt;&gt;&gt; obj.describe(include=[&#39;category&#39;])       categoricalcount            3unique           3top              ffreq             1</code></pre><h2 id="【03x00】常用统计方法"><a href="#【03x00】常用统计方法" class="headerlink" title="【03x00】常用统计方法"></a><font color=#FF0000>【03x00】常用统计方法</font></h2><p>其他常用统计方法参见下表：</p><table><thead><tr><th>方法</th><th>描述</th><th>官方文档</th></tr></thead><tbody><tr><td>count</td><td>非NA值的数量</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.count.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.count.html">DataFrame</a></td></tr><tr><td>describe</td><td>针对Series或各DataFrame列计算汇总统计</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.describe.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.describe.html">DataFrame</a></td></tr><tr><td>min</td><td>计算最小值</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.min.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.min.html">DataFrame</a></td></tr><tr><td>max</td><td>计算最大值</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.max.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.max.html">DataFrame</a></td></tr><tr><td>argmin</td><td>计算能够获取到最小值的索引位置（整数）</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.argmin.html">Series</a></td></tr><tr><td>argmax</td><td>计算能够获取到最大值的索引位置（整数）</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.argmax.html">Series</a></td></tr><tr><td>idxmin</td><td>计算能够获取到最小值的索引值</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.idxmin.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.idxmin.html">DataFrame</a></td></tr><tr><td>idxmax</td><td>计算能够获取到最大值的索引值</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.idxmax.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.idxmax.html">DataFrame</a></td></tr><tr><td>quantile</td><td>计算样本的分位数（0到1）</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.quantile.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.quantile.html">DataFrame</a></td></tr><tr><td>sum</td><td>值的总和</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.sum.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sum.html">DataFrame</a></td></tr><tr><td>mean</td><td>值的平均数</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.mean.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mean.html">DataFrame</a></td></tr><tr><td>median</td><td>值的算术中位数（50%分位数）</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.median.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.median.html">DataFrame</a></td></tr><tr><td>mad</td><td>根据平均值计算平均绝对离差</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.mad.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mad.html">DataFrame</a></td></tr><tr><td>var</td><td>样本值的方差</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.var.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.var.html">DataFrame</a></td></tr><tr><td>std</td><td>样本值的标准差</td><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.std.html">Series</a>丨<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.std.html">DataFrame</a></td></tr></tbody></table><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106788501未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Pandas（四）：函数应用/映射/排序和层级索引</title>
      <link href="/article/028/"/>
      <url>/article/028/</url>
      
        <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106758103未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】函数应用和映射"><a href="#【01x00】函数应用和映射" class="headerlink" title="【01x00】函数应用和映射"></a><font color=#FF0000>【01x00】函数应用和映射</font></h2><p>Pandas 可直接使用 NumPy 的 ufunc（元素级数组方法） 函数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.random.randn(5,4) - 1)&gt;&gt;&gt; obj          0         1         2         30 -0.228107  1.377709 -1.096528 -2.0510011 -2.477144 -0.500013 -0.040695 -0.2674522 -0.485999 -1.232930 -0.390701 -1.9479843 -0.839161 -0.702802 -1.756359 -1.8731494  0.853121 -1.540105  0.621614 -0.583360&gt;&gt;&gt; &gt;&gt;&gt; np.abs(obj)          0         1         2         30  0.228107  1.377709  1.096528  2.0510011  2.477144  0.500013  0.040695  0.2674522  0.485999  1.232930  0.390701  1.9479843  0.839161  0.702802  1.756359  1.8731494  0.853121  1.540105  0.621614  0.583360</code></pre><p>函数映射：在 Pandas 中 <code>apply</code> 方法可以将函数应用到列或行上，可以通过设置 axis 参数来指定行或列，默认 axis = 0，即按列映射：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.random.randn(5,4) - 1)&gt;&gt;&gt; obj          0         1         2         30 -0.707028 -0.755552 -2.196480 -0.5296761 -0.772668  0.127485 -2.015699 -0.2836542  0.248200 -1.940189 -1.068028 -1.7517373 -0.872904 -0.465371 -1.327951 -2.8831604 -0.092664  0.258351 -1.010747 -2.313039&gt;&gt;&gt; &gt;&gt;&gt; obj.apply(lambda x : x.max())0    0.2482001    0.2583512   -1.0107473   -0.283654dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; obj.apply(lambda x : x.max(), axis=1)0   -0.5296761    0.1274852    0.2482003   -0.4653714    0.258351dtype: float64</code></pre><p>另外还可以通过 <code>applymap</code> 将函数映射到每个数据上：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.random.randn(5,4) - 1)&gt;&gt;&gt; obj          0         1         2         30 -0.772463 -1.597008 -3.196100 -1.9484861 -1.765108 -1.646421 -0.687175 -0.4017822  0.275699 -3.115184 -1.429063 -1.0756103 -0.251734 -0.448399 -3.077677 -0.2946744 -1.495896 -1.689729 -0.560376 -1.808794&gt;&gt;&gt; &gt;&gt;&gt; obj.applymap(lambda x : &#39;%.2f&#39; % x)       0      1      2      30  -0.77  -1.60  -3.20  -1.951  -1.77  -1.65  -0.69  -0.402   0.28  -3.12  -1.43  -1.083  -0.25  -0.45  -3.08  -0.294  -1.50  -1.69  -0.56  -1.81</code></pre><h2 id="【02x00】排序"><a href="#【02x00】排序" class="headerlink" title="【02x00】排序"></a><font color=#FF0000>【02x00】排序</font></h2><h3 id="【02x01】sort-index-索引排序"><a href="#【02x01】sort-index-索引排序" class="headerlink" title="【02x01】sort_index() 索引排序"></a><font color=#4876FF>【02x01】sort_index() 索引排序</font></h3><p>根据条件对数据集排序（sorting）也是一种重要的内置运算。要对行或列索引进行排序（按字典顺序），可使用 <code>sort_index</code> 方法，它将返回一个已排序的新对象。</p><p>在 Series 和 DataFrame 中的基本语法如下：</p><pre><code class="python">Series.sort_index(self,                  axis=0,                  level=None,                  ascending=True,                  inplace=False,                  kind=&#39;quicksort&#39;,                  na_position=&#39;last&#39;,                  sort_remaining=True,                  ignore_index: bool = False)</code></pre><pre><code class="python">DataFrame.sort_index(self,                     axis=0,                     level=None,                     ascending=True,                     inplace=False,                     kind=&#39;quicksort&#39;,                     na_position=&#39;last&#39;,                     sort_remaining=True,                     ignore_index: bool = False)</code></pre><p>官方文档：</p><ul><li><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.sort_index.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.sort_index.html</a></li><li><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_index.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_index.html</a></li></ul><p>常用参数描述如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>axis</td><td>指定轴排序，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>ascending</td><td>为 <code>True</code>时升序排序（默认），为 <code>False</code>时降序排序</td></tr><tr><td>kind</td><td>排序方法，<code>quicksort</code>：快速排序（默认）；<code>&#39;mergesort’</code>：归并排序；<code>&#39;heapsort&#39;</code>：堆排序；具体可参见 <a href="https://numpy.org/doc/stable/reference/generated/numpy.sort.html">numpy.sort()</a></td></tr></tbody></table><p>在 Series 中的应用（按照索引 index 排序）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series(range(4), index=[&#39;d&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;])&gt;&gt;&gt; objd    0a    1b    2c    3dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.sort_index()a    1b    2c    3d    0dtype: int64</code></pre><p>在 DataFrame 中的应用（可按照索引 index 或列标签 columns 排序）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(np.arange(8).reshape((2, 4)), index=[&#39;three&#39;, &#39;one&#39;], columns=[&#39;d&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;])&gt;&gt;&gt; obj       d  a  b  cthree  0  1  2  3one    4  5  6  7&gt;&gt;&gt; &gt;&gt;&gt; obj.sort_index()       d  a  b  cone    4  5  6  7three  0  1  2  3&gt;&gt;&gt; &gt;&gt;&gt; obj.sort_index(axis=1)       a  b  c  dthree  1  2  3  0one    5  6  7  4&gt;&gt;&gt; &gt;&gt;&gt; obj.sort_index(axis=1, ascending=False)       d  c  b  athree  0  3  2  1one    4  7  6  5</code></pre><h3 id="【02x02】sort-values-按值排序"><a href="#【02x02】sort-values-按值排序" class="headerlink" title="【02x02】sort_values() 按值排序"></a><font color=#4876FF>【02x02】sort_values() 按值排序</font></h3><p>在 Series 和 DataFrame 中的基本语法如下：</p><pre><code class="python">Series.sort_values(self,                   axis=0,                   ascending=True,                   inplace=False,                   kind=&#39;quicksort&#39;,                   na_position=&#39;last&#39;,                   ignore_index=False)</code></pre><pre><code class="python">DataFrame.sort_values(self,                      by,                      axis=0,                      ascending=True,                      inplace=False,                      kind=&#39;quicksort&#39;,                      na_position=&#39;last&#39;,                      ignore_index=False)</code></pre><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.sort_values.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.sort_values.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_values.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_values.html</a></p></li></ul><p>常用参数描述如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>by</td><td>DataFrame 中的必须参数，指定列的值进行排序，Series 中没有此参数</td></tr><tr><td>axis</td><td>指定轴排序，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>ascending</td><td>为 <code>True</code>时升序排序（默认），为 <code>False</code>时降序排序</td></tr><tr><td>kind</td><td>排序方法，<code>quicksort</code>：快速排序（默认）；<code>&#39;mergesort’</code>：归并排序；<code>&#39;heapsort&#39;</code>：堆排序；具体可参见 <a href="https://numpy.org/doc/stable/reference/generated/numpy.sort.html">numpy.sort()</a></td></tr></tbody></table><p>在 Series 中的应用，按照值排序，如果有缺失值，默认都会被放到 Series 的末尾：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([4, 7, -3, 2])&gt;&gt;&gt; obj0    41    72   -33    2dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.sort_values()2   -33    20    41    7dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj = pd.Series([4, np.nan, 7, np.nan, -3, 2])&gt;&gt;&gt; obj0    4.01    NaN2    7.03    NaN4   -3.05    2.0dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.sort_values()4   -3.05    2.00    4.02    7.01    NaN3    NaNdtype: float64</code></pre><p>在 DataFrame 中的应用，有时候可能希望根据一个或多个列中的值进行排序。将一个或多个列的名字传递给 <code>sort_values()</code> 的 <code>by</code> 参数即可达到该目的，当传递多个列时，首先会对第一列进行排序，若第一列有相同的值，再根据第二列进行排序，依次类推：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;a&#39;: [4, 4, -3, 2], &#39;b&#39;: [0, 1, 0, 1], &#39;c&#39;: [6, 4, 1, 3]&#125;)&gt;&gt;&gt; obj   a  b  c0  4  0  61  4  1  42 -3  0  13  2  1  3&gt;&gt;&gt; &gt;&gt;&gt; obj.sort_values(by=&#39;c&#39;)   a  b  c2 -3  0  13  2  1  31  4  1  40  4  0  6&gt;&gt;&gt; &gt;&gt;&gt; obj.sort_values(by=&#39;c&#39;, ascending=False)   a  b  c0  4  0  61  4  1  43  2  1  32 -3  0  1&gt;&gt;&gt;&gt;&gt;&gt; obj.sort_values(by=[&#39;a&#39;, &#39;b&#39;])   a  b  c2 -3  0  13  2  1  30  4  0  61  4  1  4</code></pre><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;a&#39;: [4, 4, -3, 2], &#39;b&#39;: [0, 1, 0, 1], &#39;c&#39;: [6, 4, 1, 3]&#125;, index=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])&gt;&gt;&gt; obj   a  b  cA  4  0  6B  4  1  4C -3  0  1D  2  1  3&gt;&gt;&gt; &gt;&gt;&gt; obj.sort_values(by=&#39;B&#39;, axis=1)   b  a  cA  0  4  6B  1  4  4C  0 -3  1D  1  2  3</code></pre><h3 id="【02x03】rank-返回排序后元素索引"><a href="#【02x03】rank-返回排序后元素索引" class="headerlink" title="【02x03】rank() 返回排序后元素索引"></a><font color=#4876FF>【02x03】rank() 返回排序后元素索引</font></h3><p>rank() 函数会返回一个对象，对象的值是原对象经过排序后的索引值，即下标。</p><p>在 Series 和 DataFrame 中的基本语法如下：</p><pre><code class="python">Series.rank(self: ~ FrameOrSeries,            axis=0,            method: str = &#39;average&#39;,            numeric_only: Union[bool, NoneType] = None,            na_option: str = &#39;keep&#39;,            ascending: bool = True,            pct: bool = False)</code></pre><pre><code class="python">DataFrame.rank(self: ~ FrameOrSeries,               axis=0,               method: str = &#39;average&#39;,               numeric_only: Union[bool, NoneType] = None,               na_option: str = &#39;keep&#39;,               ascending: bool = True,               pct: bool = False)</code></pre><p>官方文档：</p><ul><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.rank.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.rank.html</a></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.rank.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.rank.html</a></p></li></ul><p>常用参数描述如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>axis</td><td>指定轴排序，<code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，只有在 DataFrame 中才有 <code>1</code> or <code>&#39;columns’</code></td></tr><tr><td>method</td><td>有相同值时，如何处理：<br><code>‘average’</code>：默认值，去两个相同索引的平均值；<code>‘min’</code>：取两个相同索引的最小值；<br><code>‘max’</code>：取两个相同索引的最大值；<code>‘first’</code>：按照出现的先后顺序；<br><code>‘dense’</code>：和 <code>&#39;min&#39;</code> 差不多，但是各组之间总是+1的，不太好解释，可以看后面的示例</td></tr><tr><td>ascending</td><td>为 <code>True</code>时升序排序（默认），为 <code>False</code>时降序排序</td></tr></tbody></table><p>在 Series 中的应用，按照值排序，如果有缺失值，默认都会被放到 Series 的末尾：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([7, -5, 7, 4, 2, 0, 4])&gt;&gt;&gt; obj0    71   -52    73    44    25    06    4dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.rank()0    6.5  # 第 0 个和第 2 个值从小到大排名分别为 6 和 7，默认取平均值，即 6.51    1.02    6.53    4.5  # 第 3 个和第 6 个值从小到大排名分别为 4 和 5，默认取平均值，即 4.54    3.05    2.06    4.5dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.rank(method=&#39;first&#39;)0    6.0  # 第 0 个和第 2 个值从小到大排名分别为 6 和 7，按照第一次出现排序，分别为 6 和 71    1.02    7.03    4.0  # 第 3 个和第 6 个值从小到大排名分别为 4 和 5，按照第一次出现排序，分别为 4 和 54    3.05    2.06    5.0dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.rank(method=&#39;dense&#39;)0    5.0  # 第 0 个和第 2 个值从小到大排名分别为 6 和 7，按照最小值排序，但 dense 规定间隔为 1 所以为 51    1.02    5.03    4.0  # 第 3 个和第 6 个值从小到大排名分别为 4 和 5，按照最小值排序，即 44    3.05    2.06    4.0dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.rank(method=&#39;min&#39;)0    6.0  # 第 0 个和第 2 个值从小到大排名分别为 6 和 7，按照最小值排序，即 61    1.02    6.03    4.0  # 第 3 个和第 6 个值从小到大排名分别为 4 和 5，按照最小值排序，即 44    3.05    2.06    4.0dtype: float64</code></pre><p>在 DataFrame 中可以使用 axis 参数来指定轴：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(&#123;&#39;b&#39;: [4.3, 7, -3, 2], &#39;a&#39;: [0, 1, 0, 1], &#39;c&#39;: [-2, 5, 8, -2.5]&#125;)&gt;&gt;&gt; obj     b  a    c0  4.3  0 -2.01  7.0  1  5.02 -3.0  0  8.03  2.0  1 -2.5&gt;&gt;&gt; &gt;&gt;&gt; obj.rank()     b    a    c0  3.0  1.5  2.01  4.0  3.5  3.02  1.0  1.5  4.03  2.0  3.5  1.0&gt;&gt;&gt; &gt;&gt;&gt; obj.rank(axis=&#39;columns&#39;)     b    a    c0  3.0  2.0  1.01  3.0  1.0  2.02  1.0  2.0  3.03  3.0  2.0  1.0</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106758103未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【03x00】层级索引"><a href="#【03x00】层级索引" class="headerlink" title="【03x00】层级索引"></a><font color=#FF0000>【03x00】层级索引</font></h2><h3 id="【03x01】认识层级索引"><a href="#【03x01】认识层级索引" class="headerlink" title="【03x01】认识层级索引"></a><font color=#4876FF>【03x01】认识层级索引</font></h3><p>以下示例将创建一个 Series 对象， 索引 Index 由两个子 list 组成，第一个子 list 是外层索引，第二个 list 是内层索引：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series(np.random.randn(12),index=[[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;, &#39;c&#39;, &#39;d&#39;, &#39;d&#39;, &#39;d&#39;], [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2]])&gt;&gt;&gt; obja  0   -0.201536   1   -0.629058   2    0.766716b  0   -1.255831   1   -0.483727   2   -0.018653c  0    0.788787   1    1.010097   2   -0.187258d  0    1.242363   1   -0.822011   2   -0.085682dtype: float64</code></pre><h3 id="【03x02】MultiIndex-索引对象"><a href="#【03x02】MultiIndex-索引对象" class="headerlink" title="【03x02】MultiIndex 索引对象"></a><font color=#4876FF>【03x02】MultiIndex 索引对象</font></h3><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.MultiIndex.html">https://pandas.pydata.org/docs/reference/api/pandas.MultiIndex.html</a></p><p>尝试打印上面示例中 Series 的索引类型，会得到一个 MultiIndex 对象，MultiIndex 对象的 <font color=#FF0000>levels</font> 属性表示两个层级中分别有那些标签，<font color=#FF0000>codes</font> 属性表示每个位置分别是什么标签，如下所示：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series(np.random.randn(12),index=[[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;, &#39;c&#39;, &#39;d&#39;, &#39;d&#39;, &#39;d&#39;], [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2]])&gt;&gt;&gt; obja  0    0.035946   1   -0.867215   2   -0.053355b  0   -0.986616   1    0.026071   2   -0.048394c  0    0.251274   1    0.217790   2    1.137674d  0   -1.245178   1    1.234972   2   -0.035624dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; type(obj.index)&lt;class &#39;pandas.core.indexes.multi.MultiIndex&#39;&gt;&gt;&gt;&gt; &gt;&gt;&gt; obj.indexMultiIndex([(&#39;a&#39;, 0),            (&#39;a&#39;, 1),            (&#39;a&#39;, 2),            (&#39;b&#39;, 0),            (&#39;b&#39;, 1),            (&#39;b&#39;, 2),            (&#39;c&#39;, 0),            (&#39;c&#39;, 1),            (&#39;c&#39;, 2),            (&#39;d&#39;, 0),            (&#39;d&#39;, 1),            (&#39;d&#39;, 2)],           )&gt;&gt;&gt; obj.index.levelsFrozenList([[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], [0, 1, 2]])&gt;&gt;&gt;&gt;&gt;&gt; obj.index.codesFrozenList([[0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2]])</code></pre><p>通常可以使用 <code>from_arrays()</code> 方法来将数组对象转换为 MultiIndex 索引对象：</p><pre><code class="python">&gt;&gt;&gt; arrays = [[1, 1, 2, 2], [&#39;red&#39;, &#39;blue&#39;, &#39;red&#39;, &#39;blue&#39;]]&gt;&gt;&gt; pd.MultiIndex.from_arrays(arrays, names=(&#39;number&#39;, &#39;color&#39;))MultiIndex([(1,  &#39;red&#39;),            (1, &#39;blue&#39;),            (2,  &#39;red&#39;),            (2, &#39;blue&#39;)],           names=[&#39;number&#39;, &#39;color&#39;])</code></pre><p>其他常用方法见下表（更多方法参见官方文档）：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>from_arrays(arrays[, sortorder, names])</td><td>将数组转换为 MultiIndex</td></tr><tr><td>from_tuples(tuples[, sortorder, names])</td><td>将元组列表转换为 MultiIndex</td></tr><tr><td>from_product(iterables[, sortorder, names])</td><td>将多个可迭代的笛卡尔积转换成 MultiIndex</td></tr><tr><td>from_frame(df[, sortorder, names])</td><td>将 DataFrame 对象转换为 MultiIndex</td></tr><tr><td>set_levels(self, levels[, level, inplace, …])</td><td>为 MultiIndex 设置新的 levels</td></tr><tr><td>set_codes(self, codes[, level, inplace, …])</td><td>为 MultiIndex 设置新的 codes</td></tr><tr><td>sortlevel(self[, level, ascending, …])</td><td>根据 level 进行排序</td></tr><tr><td>droplevel(self[, level])</td><td>删除指定的 level</td></tr><tr><td>swaplevel(self[, i, j])</td><td>交换 level i 与 level i，即交换外层索引与内层索引</td></tr></tbody></table><h3 id="【03x03】提取值"><a href="#【03x03】提取值" class="headerlink" title="【03x03】提取值"></a><font color=#4876FF>【03x03】提取值</font></h3><p>对于这种有多层索引的对象，如果只传入一个参数，则会对外层索引进行提取，其中包含对应所有的内层索引，如果传入两个参数，则第一个参数表示外层索引，第二个参数表示内层索引，示例如下：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series(np.random.randn(12),index=[[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;, &#39;c&#39;, &#39;d&#39;, &#39;d&#39;, &#39;d&#39;], [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2]])&gt;&gt;&gt; obja  0    0.550202   1    0.328784   2    1.422690b  0   -1.333477   1   -0.933809   2   -0.326541c  0    0.663686   1    0.943393   2    0.273106d  0    1.354037   1   -2.312847   2   -2.343777dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;b&#39;]0   -1.3334771   -0.9338092   -0.326541dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; obj[&#39;b&#39;, 1]-0.9338094811708413&gt;&gt;&gt; &gt;&gt;&gt; obj[:, 2]a    1.422690b   -0.326541c    0.273106d   -2.343777dtype: float64</code></pre><h3 id="【03x04】交换分层与排序"><a href="#【03x04】交换分层与排序" class="headerlink" title="【03x04】交换分层与排序"></a><font color=#4876FF>【03x04】交换分层与排序</font></h3><p>MultiIndex 对象的 <code>swaplevel()</code> 方法可以交换外层与内层索引，<code>sortlevel()</code> 方法会先对外层索引进行排序，再对内层索引进行排序，默认是升序，如果设置 <code>ascending</code> 参数为 False 则会降序排列，示例如下：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series(np.random.randn(12),index=[[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;, &#39;c&#39;, &#39;d&#39;, &#39;d&#39;, &#39;d&#39;], [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2]])&gt;&gt;&gt; obja  0   -0.110215   1    0.193075   2   -1.101706b  0   -1.325743   1    0.528418   2   -0.127081c  0   -0.733822   1    1.665262   2    0.127073d  0    1.262022   1   -1.170518   2    0.966334dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.swaplevel()0  a   -0.1102151  a    0.1930752  a   -1.1017060  b   -1.3257431  b    0.5284182  b   -0.1270810  c   -0.7338221  c    1.6652622  c    0.1270730  d    1.2620221  d   -1.1705182  d    0.966334dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.swaplevel().index.sortlevel()(MultiIndex([(0, &#39;a&#39;),            (0, &#39;b&#39;),            (0, &#39;c&#39;),            (0, &#39;d&#39;),            (1, &#39;a&#39;),            (1, &#39;b&#39;),            (1, &#39;c&#39;),            (1, &#39;d&#39;),            (2, &#39;a&#39;),            (2, &#39;b&#39;),            (2, &#39;c&#39;),            (2, &#39;d&#39;)],           ), array([ 0,  3,  6,  9,  1,  4,  7, 10,  2,  5,  8, 11], dtype=int32))</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106758103未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</title>
      <link href="/article/027/"/>
      <url>/article/027/</url>
      
        <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106743778未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】Pandas-算术运算"><a href="#【01x00】Pandas-算术运算" class="headerlink" title="【01x00】Pandas 算术运算"></a><font color=#FF0000>【01x00】Pandas 算术运算</font></h2><p>Pandas 继承了 NumPy 的功能，NumPy 的基本能力之一是快速对每个元素进行运算，既包括基本算术运算（加、减、乘、除），也包括更复杂的运算（三角函数、指数函数和对数函数等）。具体可以参考 NumPy 系列文章。</p><h3 id="【01x01】使用-NumPy-通用函数"><a href="#【01x01】使用-NumPy-通用函数" class="headerlink" title="【01x01】使用 NumPy 通用函数"></a><font color=#4876FF>【01x01】使用 NumPy 通用函数</font></h3><p>因为 Pandas 是建立在 NumPy 基础之上的，所以 NumPy 的通用函数同样适用于 Pandas 的 Series 和 DataFrame 对象，如下所示：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; rng = np.random.RandomState(42)&gt;&gt;&gt; ser = pd.Series(rng.randint(0, 10, 4))&gt;&gt;&gt; ser0    61    32    73    4dtype: int32&gt;&gt;&gt; &gt;&gt;&gt; obj = pd.DataFrame(rng.randint(0, 10, (3, 4)), columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])&gt;&gt;&gt; obj   A  B  C  D0  6  9  2  61  7  4  3  72  7  2  5  4</code></pre><p>使用 NumPy 通用函数，生成的结果是另一个保留索引的 Pandas 对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; rng = np.random.RandomState(42)&gt;&gt;&gt; ser = pd.Series(rng.randint(0, 10, 4))&gt;&gt;&gt; ser0    61    32    73    4dtype: int32&gt;&gt;&gt; &gt;&gt;&gt; np.exp(ser)0     403.4287931      20.0855372    1096.6331583      54.598150dtype: float64</code></pre><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(rng.randint(0, 10, (3, 4)), columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])&gt;&gt;&gt; np.sin(obj * np.pi / 4)          A             B         C             D0 -1.000000  7.071068e-01  1.000000 -1.000000e+001 -0.707107  1.224647e-16  0.707107 -7.071068e-012 -0.707107  1.000000e+00 -0.707107  1.224647e-16</code></pre><h3 id="【01x02】数据对齐"><a href="#【01x02】数据对齐" class="headerlink" title="【01x02】数据对齐"></a><font color=#4876FF>【01x02】数据对齐</font></h3><p>Pandas 最重要的一个功能是，它可以对不同索引的对象进行算术运算。在将对象相加时，如果存在不同的索引对，则结果的索引就是该索引对的并集。自动的数据对齐操作会在不重叠的索引处引入缺失值，即 <font color=#FF0000>NaN</font>，缺失值会在算术运算过程中传播。</p><p>Series 对象的数据对齐操作：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.Series([7.3, -2.5, 3.4, 1.5], index=[&#39;a&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;])&gt;&gt;&gt; obj2 = pd.Series([-2.1, 3.6, -1.5, 4, 3.1], index=[&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;])&gt;&gt;&gt; obj1a    7.3c   -2.5d    3.4e    1.5dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj2a   -2.1c    3.6e   -1.5f    4.0g    3.1dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; obj1 + obj2a    5.2c    1.1d    NaNe    0.0f    NaNg    NaNdtype: float64</code></pre><p>DataFrame 对象的数据对齐操作会同时发生在行和列上：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.DataFrame(np.arange(9.).reshape((3, 3)), columns=list(&#39;bcd&#39;), index=[&#39;Ohio&#39;, &#39;Texas&#39;, &#39;Colorado&#39;])&gt;&gt;&gt; obj2 = pd.DataFrame(np.arange(12.).reshape((4, 3)), columns=list(&#39;bde&#39;), index=[&#39;Utah&#39;, &#39;Ohio&#39;, &#39;Texas&#39;, &#39;Oregon&#39;])&gt;&gt;&gt; obj1            b    c    dOhio      0.0  1.0  2.0Texas     3.0  4.0  5.0Colorado  6.0  7.0  8.0&gt;&gt;&gt; &gt;&gt;&gt; obj2          b     d     eUtah    0.0   1.0   2.0Ohio    3.0   4.0   5.0Texas   6.0   7.0   8.0Oregon  9.0  10.0  11.0&gt;&gt;&gt; &gt;&gt;&gt; obj1 + obj2            b   c     d   eColorado  NaN NaN   NaN NaNOhio      3.0 NaN   6.0 NaNOregon    NaN NaN   NaN NaNTexas     9.0 NaN  12.0 NaNUtah      NaN NaN   NaN NaN</code></pre><h3 id="【01x03】DataFrame-与-Series-之间的运算"><a href="#【01x03】DataFrame-与-Series-之间的运算" class="headerlink" title="【01x03】DataFrame 与 Series 之间的运算"></a><font color=#4876FF>【01x03】DataFrame 与 Series 之间的运算</font></h3><p>首先回忆 NumPy 中的广播（参见：<a href="https://itrhx.blog.csdn.net/article/details/104988137">《Python 数据分析三剑客之 NumPy（二）：数组索引 / 切片 / 广播 / 拼接 / 分割》</a>），跟不同维度的 NumPy 数组一样，DataFrame 和 Series 之间算术运算也是有明确规定的。首先回忆一下 NumPy 中不同维度的数组之间的运算：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.arange(12.).reshape((3, 4))&gt;&gt;&gt; arrarray([[ 0.,  1.,  2.,  3.],       [ 4.,  5.,  6.,  7.],       [ 8.,  9., 10., 11.]])&gt;&gt;&gt; &gt;&gt;&gt; arr[0]array([0., 1., 2., 3.])&gt;&gt;&gt; &gt;&gt;&gt; arr - arr[0]array([[0., 0., 0., 0.],       [4., 4., 4., 4.],       [8., 8., 8., 8.]])</code></pre><p>可以看到每一行都进行了减法运算，这正是 NumPy 中的广播，而 DataFrame 与 Series 之间的运算也类似，默认情况下，DataFrame 和 Series 之间的算术运算会将 Series 的索引匹配到 DataFrame 的列，然后沿着行一直向下广播：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; frame = pd.DataFrame(np.arange(12.).reshape((4, 3)), columns=list(&#39;bde&#39;), index=[&#39;AA&#39;, &#39;BB&#39;, &#39;CC&#39;, &#39;DD&#39;])&gt;&gt;&gt; frame      b     d     eAA  0.0   1.0   2.0BB  3.0   4.0   5.0CC  6.0   7.0   8.0DD  9.0  10.0  11.0&gt;&gt;&gt; &gt;&gt;&gt; series = frame.iloc[0]&gt;&gt;&gt; seriesb    0.0d    1.0e    2.0Name: AA, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; frame - series      b    d    eAA  0.0  0.0  0.0BB  3.0  3.0  3.0CC  6.0  6.0  6.0DD  9.0  9.0  9.0</code></pre><p>如果某个索引值在 DataFrame 的列或 Series 的索引中找不到，则参与运算的两个对象就会被重新索引以形成并集：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; frame = pd.DataFrame(np.arange(12.).reshape((4, 3)), columns=list(&#39;bde&#39;), index=[&#39;AA&#39;, &#39;BB&#39;, &#39;CC&#39;, &#39;DD&#39;])&gt;&gt;&gt; frame      b     d     eAA  0.0   1.0   2.0BB  3.0   4.0   5.0CC  6.0   7.0   8.0DD  9.0  10.0  11.0&gt;&gt;&gt; &gt;&gt;&gt; series = pd.Series(range(3), index=[&#39;b&#39;, &#39;e&#39;, &#39;f&#39;])&gt;&gt;&gt; seriesb    0e    1f    2dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; frame + series      b   d     e   fAA  0.0 NaN   3.0 NaNBB  3.0 NaN   6.0 NaNCC  6.0 NaN   9.0 NaNDD  9.0 NaN  12.0 NaN</code></pre><p>如果希望匹配行且在列上广播，则必须使用算术运算方法，在方法中传入的轴（axis）就是希望匹配的轴。在下例中，我们的目的是匹配 DataFrame 的行索引（axis=’index’ or axis=0）并进行广播：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; frame = pd.DataFrame(np.arange(12.).reshape((4, 3)), columns=list(&#39;bde&#39;), index=[&#39;AA&#39;, &#39;BB&#39;, &#39;CC&#39;, &#39;DD&#39;])&gt;&gt;&gt; frame      b     d     eAA  0.0   1.0   2.0BB  3.0   4.0   5.0CC  6.0   7.0   8.0DD  9.0  10.0  11.0&gt;&gt;&gt; &gt;&gt;&gt; series = frame[&#39;d&#39;]&gt;&gt;&gt; seriesAA     1.0BB     4.0CC     7.0DD    10.0Name: d, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; frame.sub(series, axis=&#39;index&#39;)      b    d    eAA -1.0  0.0  1.0BB -1.0  0.0  1.0CC -1.0  0.0  1.0DD -1.0  0.0  1.0</code></pre><h3 id="【01x04】Pandas-算术方法"><a href="#【01x04】Pandas-算术方法" class="headerlink" title="【01x04】Pandas 算术方法"></a><font color=#4876FF>【01x04】Pandas 算术方法</font></h3><p>完整的 Pandas 算术方法见下表：</p><table><thead><tr><th>方法</th><th>副本</th><th>描述</th></tr></thead><tbody><tr><td>add()</td><td>radd()</td><td>加法（+）</td></tr><tr><td>sub()、subtract()</td><td>rsub()</td><td>减法（-）</td></tr><tr><td>mul()、multiply()</td><td>rmul()</td><td>乘法（*）</td></tr><tr><td>pow()</td><td>rpow()</td><td>指数（**）</td></tr><tr><td>truediv()、div()、divide()</td><td>rdiv()</td><td>除法（/）</td></tr><tr><td>floordiv()</td><td>rfloordiv()</td><td>底除（//）</td></tr><tr><td>mod()</td><td>rmod()</td><td>求余（%）</td></tr></tbody></table><p>副本均为原方法前加了个 <code>r</code>，它会翻转参数：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame(np.arange(12.).reshape((3, 4)), columns=list(&#39;abcd&#39;))&gt;&gt;&gt; obj     a    b     c     d0  0.0  1.0   2.0   3.01  4.0  5.0   6.0   7.02  8.0  9.0  10.0  11.0&gt;&gt;&gt; &gt;&gt;&gt; 1 / obj       a         b         c         d0    inf  1.000000  0.500000  0.3333331  0.250  0.200000  0.166667  0.1428572  0.125  0.111111  0.100000  0.090909&gt;&gt;&gt; &gt;&gt;&gt; obj.rdiv(1)       a         b         c         d0    inf  1.000000  0.500000  0.3333331  0.250  0.200000  0.166667  0.1428572  0.125  0.111111  0.100000  0.090909</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106743778未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【02x00】处理缺失值"><a href="#【02x00】处理缺失值" class="headerlink" title="【02x00】处理缺失值"></a><font color=#FF0000>【02x00】处理缺失值</font></h2><p>在现实中遇到的数据很少是干净整齐的，许多数据集都会有数据缺失的现象，缺失值主要有三种形式：null、NaN（NAN，nan） 或 NA。</p><h3 id="【02x01】fill-value-指定值与缺失值进行运算"><a href="#【02x01】fill-value-指定值与缺失值进行运算" class="headerlink" title="【02x01】fill_value() 指定值与缺失值进行运算"></a><font color=#4876FF>【02x01】fill_value() 指定值与缺失值进行运算</font></h3><p>使用 <code>add</code>, <code>sub</code>, <code>div</code>, <code>mul</code> 等算术方法时，通过 <code>fill_value</code> 指定填充值，未对齐的数据将和填充值做运算。</p><p>Series 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj1 = pd.Series([1, 2, 3, 4, 5])&gt;&gt;&gt; obj2 = pd.Series([6, 7])&gt;&gt;&gt; &gt;&gt;&gt; obj10    11    22    33    44    5dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj20    61    7dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj1.add(obj2)0    7.01    9.02    NaN3    NaN4    NaNdtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj1.add(obj2, fill_value=-1)0    7.01    9.02    2.03    3.04    4.0dtype: float64</code></pre><p>DataFrame 中的应用：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj1 = pd.DataFrame(np.arange(12.).reshape((3, 4)), columns=list(&#39;abcd&#39;))&gt;&gt;&gt; obj2 = pd.DataFrame(np.arange(20.).reshape((4, 5)), columns=list(&#39;abcde&#39;))&gt;&gt;&gt; &gt;&gt;&gt; obj2.loc[1, &#39;b&#39;] = np.nan&gt;&gt;&gt; &gt;&gt;&gt; obj1     a    b     c     d0  0.0  1.0   2.0   3.01  4.0  5.0   6.0   7.02  8.0  9.0  10.0  11.0&gt;&gt;&gt; &gt;&gt;&gt; obj2      a     b     c     d     e0   0.0   1.0   2.0   3.0   4.01   5.0   NaN   7.0   8.0   9.02  10.0  11.0  12.0  13.0  14.03  15.0  16.0  17.0  18.0  19.0&gt;&gt;&gt; &gt;&gt;&gt; obj1 + obj2      a     b     c     d   e0   0.0   2.0   4.0   6.0 NaN1   9.0   NaN  13.0  15.0 NaN2  18.0  20.0  22.0  24.0 NaN3   NaN   NaN   NaN   NaN NaN&gt;&gt;&gt; &gt;&gt;&gt; obj1.add(obj2, fill_value=10)      a     b     c     d     e0   0.0   2.0   4.0   6.0  14.01   9.0  15.0  13.0  15.0  19.02  18.0  20.0  22.0  24.0  24.03  25.0  26.0  27.0  28.0  29.0</code></pre><h3 id="【02x02】isnull-notnull-判断缺失值"><a href="#【02x02】isnull-notnull-判断缺失值" class="headerlink" title="【02x02】isnull() / notnull() 判断缺失值"></a><font color=#4876FF>【02x02】isnull() / notnull() 判断缺失值</font></h3><p><code>isnull()</code>：为缺失值时为 <code>True</code>，否则为 <code>False</code>；</p><p><code>notnull()</code> 为缺失值时为 <code>False</code>，否则为 <code>True</code>。</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, np.nan, &#39;hello&#39;, None])&gt;&gt;&gt; obj0        11      NaN2    hello3     Nonedtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.isnull()0    False1     True2    False3     Truedtype: bool&gt;&gt;&gt; &gt;&gt;&gt; obj.notnull()0     True1    False2     True3    Falsedtype: bool</code></pre><h3 id="【02x03】dropna-删除缺失值"><a href="#【02x03】dropna-删除缺失值" class="headerlink" title="【02x03】dropna() 删除缺失值"></a><font color=#4876FF>【02x03】dropna() 删除缺失值</font></h3><p><code>dropna()</code> 方法用于返回一个删除了缺失值的新 Series 或 DataFrame 对象。</p><p>在 Series 对象当中，<code>dropna()</code> 方法的语法如下（其他参数用法可参考在 DataFrame 中的应用）：</p><p><code>Series.dropna(self, axis=0, inplace=False, how=None)</code></p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.dropna.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.dropna.html</a></p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, np.nan, &#39;hello&#39;, None])&gt;&gt;&gt; obj0        11      NaN2    hello3     Nonedtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.dropna()0        12    hellodtype: object</code></pre><p>在 DataFrame 对象中，<code>dropna()</code> 方法的语法如下：</p><p><code>DataFrame.dropna(self, axis=0, how=&#39;any&#39;, thresh=None, subset=None, inplace=False)</code></p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.dropna.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.dropna.html</a></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>axis</td><td>确定是否删除包含缺失值的行或列<br><code>0</code> 或 <code>&#39;index&#39;</code>：删除包含缺失值的行。<code>1</code> 或 <code>&#39;columns&#39;</code>：删除包含缺失值的列</td></tr><tr><td>how</td><td><code>&#39;any&#39;</code>：如果存在任何NA值，则删除该行或列。<code>&#39;all&#39;</code>：如果所有值都是NA，则删除该行或列</td></tr><tr><td>thresh</td><td>设置行或列中<strong>非缺失值</strong>的最小数量</td></tr></tbody></table><p>不传递任何参数，将会删除任何包含缺失值的整行数据：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1, np.nan, 2], [2, 3, 5], [np.nan, 4, 6]])&gt;&gt;&gt; obj     0    1  20  1.0  NaN  21  2.0  3.0  52  NaN  4.0  6&gt;&gt;&gt; &gt;&gt;&gt; obj.dropna()     0    1  21  2.0  3.0  5</code></pre><p>指定 axis 参数，删除包含缺失值的行或列：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1, np.nan, 2], [2, 3, 5], [np.nan, 4, 6]])&gt;&gt;&gt; obj     0    1  20  1.0  NaN  21  2.0  3.0  52  NaN  4.0  6&gt;&gt;&gt; &gt;&gt;&gt; obj.dropna(axis=&#39;columns&#39;)   20  21  52  6</code></pre><p>指定 how 参数，<code>&#39;any&#39;</code>：如果存在任何NA值，则删除该行或列。<code>&#39;all&#39;</code>：如果所有值都是NA，则删除该行或列：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1, np.nan, 2, np.nan], [2, 3, 5, np.nan], [np.nan, 4, 6, np.nan]])&gt;&gt;&gt; obj     0    1  2   30  1.0  NaN  2 NaN1  2.0  3.0  5 NaN2  NaN  4.0  6 NaN&gt;&gt;&gt; obj.dropna(axis=&#39;columns&#39;, how=&#39;all&#39;)     0    1  20  1.0  NaN  21  2.0  3.0  52  NaN  4.0  6</code></pre><p>指定 thresh 参数，设置行或列中<font color=#FF0000><strong>非缺失值</strong></font>的最小数量，以下示例中，第一行和第三行只有两个非缺失值，所以会被删除：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1, np.nan, 2, np.nan], [2, 3, 5, np.nan], [np.nan, 4, 6, np.nan]])&gt;&gt;&gt; obj     0    1  2   30  1.0  NaN  2 NaN1  2.0  3.0  5 NaN2  NaN  4.0  6 NaN&gt;&gt;&gt;&gt;&gt;&gt; obj.dropna(axis=&#39;rows&#39;, thresh=3)     0    1  2   31  2.0  3.0  5 NaN</code></pre><h3 id="【02x04】fillna-填充缺失值"><a href="#【02x04】fillna-填充缺失值" class="headerlink" title="【02x04】fillna() 填充缺失值"></a><font color=#4876FF>【02x04】fillna() 填充缺失值</font></h3><p><code>fillna()</code> 方法可以将缺失值替换成有效的数值。</p><p>在 Series 对象中，<code>fillna()</code> 方法的语法如下：</p><p><code>Series.fillna(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None)</code></p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.fillna.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.fillna.html</a></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>用于填充的值（例如 0），或者是一个 dict / Series / DataFrame 值<br>指定要用于每个 index（对于 Series）或column（对于 DataFrame）的值<br>不在dict / Series / DataFrame中的值将不被填充。此值不能是列表</td></tr><tr><td>method</td><td>填充方法：<code>None</code><br><code>‘pad’</code> / <code>‘ffill’</code>：将上一个有效观测值向前传播到下一个有效观测值<br><code>‘backfill’</code> / <code>‘bfill’</code>：使用下一个有效观察值来填补空白</td></tr><tr><td>axis</td><td><code>0</code> or <code>‘index’</code>，要填充缺失值的轴</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, np.nan, 2, None, 3], index=list(&#39;abcde&#39;))&gt;&gt;&gt; obja    1.0b    NaNc    2.0d    NaNe    3.0dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.fillna(0)a    1.0b    0.0c    2.0d    0.0e    3.0dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.fillna(method=&#39;ffill&#39;)a    1.0b    1.0c    2.0d    2.0e    3.0dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.fillna(method=&#39;bfill&#39;)a    1.0b    2.0c    2.0d    3.0e    3.0dtype: float64</code></pre><p>在 DataFrame 对象中，<code>fillna()</code> 方法的语法如下：</p><p><code>DataFrame.fillna(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None)</code></p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.fillna.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.fillna.html</a></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>用于填充的值（例如 0），或者是一个 dict / Series / DataFrame 值<br>指定要用于每个 index（对于 Series）或column（对于 DataFrame）的值<br>不在dict / Series / DataFrame中的值将不被填充。此值不能是列表</td></tr><tr><td>method</td><td>填充方法：<code>None</code><br><code>‘pad’</code> / <code>‘ffill’</code>：将上一个有效观测值向前传播到下一个有效观测值<br><code>‘backfill’</code> / <code>‘bfill’</code>：使用下一个有效观察值来填补空白</td></tr><tr><td>axis</td><td><code>0</code> or <code>‘index’</code>，<code>1</code> or <code>‘columns’</code>，要填充缺失值的轴</td></tr></tbody></table><p>在 DataFrame 对象中的用法和在 Series 对象中的用法大同小异，只不过 axis 参数多了一个选择：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame([[1, np.nan, 2, np.nan], [2, 3, 5, np.nan], [np.nan, 4, 6, np.nan]])&gt;&gt;&gt; obj     0    1  2   30  1.0  NaN  2 NaN1  2.0  3.0  5 NaN2  NaN  4.0  6 NaN&gt;&gt;&gt; &gt;&gt;&gt; obj.fillna(method=&#39;ffill&#39;, axis=1)     0    1    2    30  1.0  1.0  2.0  2.01  2.0  3.0  5.0  5.02  NaN  4.0  6.0  6.0</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106743778未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</title>
      <link href="/article/026/"/>
      <url>/article/026/</url>
      
        <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106698307未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h1 id="【1】Index-索引对象"><a href="#【1】Index-索引对象" class="headerlink" title="【1】Index 索引对象"></a><font color=#FF0000>【1】Index 索引对象</font></h1><p> Series 和 DataFrame 中的索引都是 Index 对象，为了保证数据的安全，索引对象是不可变的，如果尝试更改索引就会报错；常见的 Index 种类有：索引（Index），整数索引（Int64Index），层级索引（MultiIndex），时间戳类型（DatetimeIndex）。</p><p>一下代码演示了 Index 索引对象和其不可变的性质：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obj.indexIndex([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=&#39;object&#39;)&gt;&gt;&gt; type(obj.index)&lt;class &#39;pandas.core.indexes.base.Index&#39;&gt;&gt;&gt;&gt; obj.index[0] = &#39;e&#39;Traceback (most recent call last):  File &quot;&lt;pyshell#28&gt;&quot;, line 1, in &lt;module&gt;    obj.index[0] = &#39;e&#39;  File &quot;C:\Users\...\base.py&quot;, line 3909, in __setitem__    raise TypeError(&quot;Index does not support mutable operations&quot;)TypeError: Index does not support mutable operations</code></pre><table><tr><td bgcolor="#FFA500"><font size="5" color="#fff">index 索引对象常用属性</font></td></tr></table><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.html">https://pandas.pydata.org/docs/reference/api/pandas.Index.html</a></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>T</td><td>转置</td></tr><tr><td>array</td><td>index 的数组形式，常见<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.array.html">官方文档</a></td></tr><tr><td>dtype</td><td>返回基础数据的 dtype 对象</td></tr><tr><td>hasnans</td><td>是否有 NaN（缺失值）</td></tr><tr><td>inferred_type</td><td>返回一个字符串，表示 index 的类型</td></tr><tr><td>is_monotonic</td><td>判断 index 是否是递增的</td></tr><tr><td>is_monotonic_decreasing</td><td>判断 index 是否单调递减</td></tr><tr><td>is_monotonic_increasing</td><td>判断 index 是否单调递增</td></tr><tr><td>is_unique</td><td>index 是否没有重复值</td></tr><tr><td>nbytes</td><td>返回 index 中的字节数</td></tr><tr><td>ndim</td><td>index 的维度</td></tr><tr><td>nlevels</td><td>Number of levels.</td></tr><tr><td>shape</td><td>返回一个元组，表示 index 的形状</td></tr><tr><td>size</td><td>index 的大小</td></tr><tr><td>values</td><td>返回 index 中的值 / 数组</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obj.indexIndex([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=&#39;object&#39;)&gt;&gt;&gt; &gt;&gt;&gt; obj.index.array&lt;PandasArray&gt;[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]Length: 4, dtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj.index.dtypedtype(&#39;O&#39;)&gt;&gt;&gt; &gt;&gt;&gt; obj.index.hasnansFalse&gt;&gt;&gt;&gt;&gt;&gt; obj.index.inferred_type&#39;string&#39;&gt;&gt;&gt; &gt;&gt;&gt; obj.index.is_monotonicTrue&gt;&gt;&gt;&gt;&gt;&gt; obj.index.is_monotonic_decreasingFalse&gt;&gt;&gt; &gt;&gt;&gt; obj.index.is_monotonic_increasingTrue&gt;&gt;&gt; &gt;&gt;&gt; obj.index.is_uniqueTrue&gt;&gt;&gt; &gt;&gt;&gt; obj.index.nbytes16&gt;&gt;&gt;&gt;&gt;&gt; obj.index.ndim1&gt;&gt;&gt;&gt;&gt;&gt; obj.index.nlevels1&gt;&gt;&gt;&gt;&gt;&gt; obj.index.shape(4,)&gt;&gt;&gt; &gt;&gt;&gt; obj.index.size4&gt;&gt;&gt; &gt;&gt;&gt; obj.index.valuesarray([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=object)</code></pre><table><tr><td bgcolor="#FFA500"><font size="5" color="#fff">index 索引对象常用方法</font></td></tr></table><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.html">https://pandas.pydata.org/docs/reference/api/pandas.Index.html</a></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>all(self, *args, **kwargs)</td><td>判断所有元素是否为真，有 0 会被视为 False</td></tr><tr><td>any(self, *args, **kwargs)</td><td>判断是否至少有一个元素为真，均为 0 会被视为 False</td></tr><tr><td>append(self, other)</td><td>连接另一个 index，产生一个新的 index</td></tr><tr><td>argmax(self[, axis, skipna])</td><td>返回 index 中最大值的索引值</td></tr><tr><td>argmin(self[, axis, skipna])</td><td>返回 index 中最小值的索引值</td></tr><tr><td>argsort(self, *args, **kwargs)</td><td>对 index 从小到大排序，返回排序后的元素在原 index 中的索引值</td></tr><tr><td>delete(self, loc)</td><td>删除指定索引位置的元素，返回删除后的新 index</td></tr><tr><td>difference(self, other[, sort])</td><td>在第一个 index 中删除第二个 index 中的元素，即差集</td></tr><tr><td>drop(self, labels[, errors])</td><td>在原 index 中删除传入的值</td></tr><tr><td>drop_duplicates(self[, keep])</td><td>删除重复值，keep 参数可选值如下：<br><code>‘first’</code>：保留第一次出现的重复项；<br><code>‘last’</code>：保留最后一次出现的重复项；<br><code>False</code>：不保留重复项</td></tr><tr><td>duplicated(self[, keep])</td><td>判断是否为重复值，keep 参数可选值如下：<br><code>‘first’</code>：第一次重复的为 False，其他为 True；<br><code>‘last’</code>：最后一次重复的为 False，其他为 True；<br><code>False</code>：所有重复的均为 True</td></tr><tr><td>dropna(self[, how])</td><td>删除缺失值，即 NaN</td></tr><tr><td>fillna(self[, value, downcast])</td><td>用指定值填充缺失值，即 NaN</td></tr><tr><td>equals(self, other)</td><td>判断两个  index 是否相同</td></tr><tr><td>insert(self, loc, item)</td><td>将元素插入到指定索引处，返回新的 index</td></tr><tr><td>intersection(self, other[, sort])</td><td>返回两个 index 的交集</td></tr><tr><td>isna(self)</td><td>检测 index 元素是否为缺失值，即 NaN</td></tr><tr><td>isnull(self)</td><td>检测 index 元素是否为缺失值，即 NaN</td></tr><tr><td>max(self[, axis, skipna])</td><td>返回 index 的最大值</td></tr><tr><td>min(self[, axis, skipna])</td><td>返回 index 的最小值</td></tr><tr><td>union(self, other[, sort])</td><td>返回两个 index 的并集</td></tr><tr><td>unique(self[, level])</td><td>返回 index 中的唯一值，相当于去除重复值</td></tr></tbody></table><ul><li><p><code>all(self, *args, **kwargs)</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.all.html">官方文档</a>】</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([1, 2, 3]).all()True&gt;&gt;&gt;&gt;&gt;&gt; pd.Index([0, 1, 2]).all()False</code></pre></li><li><p><code>any(self, *args, **kwargs)</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.any.html">官方文档</a>】</p></li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([0, 0, 1]).any()True&gt;&gt;&gt;&gt;&gt;&gt; pd.Index([0, 0, 0]).any()False</code></pre><ul><li><code>append(self, other)</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.append.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]).append(pd.Index([1, 2, 3]))Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2, 3], dtype=&#39;object&#39;)</code></pre><ul><li><code>argmax(self[, axis, skipna])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.argmax.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([5, 2, 3, 9, 1]).argmax()3</code></pre><ul><li><code>argmin(self[, axis, skipna])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.argmin.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([5, 2, 3, 9, 1]).argmin()4</code></pre><ul><li><code>argsort(self, *args, **kwargs)</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.argsort.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([5, 2, 3, 9, 1]).argsort()array([4, 1, 2, 0, 3], dtype=int32)</code></pre><ul><li><code>delete(self, loc)</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.delete.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([5, 2, 3, 9, 1]).delete(0)Int64Index([2, 3, 9, 1], dtype=&#39;int64&#39;)</code></pre><ul><li><code>difference(self, other[, sort])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.difference.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx1 = pd.Index([2, 1, 3, 4])&gt;&gt;&gt; idx2 = pd.Index([3, 4, 5, 6])&gt;&gt;&gt; idx1.difference(idx2)Int64Index([1, 2], dtype=&#39;int64&#39;)&gt;&gt;&gt; idx1.difference(idx2, sort=False)Int64Index([2, 1], dtype=&#39;int64&#39;)</code></pre><ul><li><code>drop(self, labels[, errors])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.drop.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([5, 2, 3, 9, 1]).drop([2, 1])Int64Index([5, 3, 9], dtype=&#39;int64&#39;)</code></pre><ul><li><code>drop_duplicates(self[, keep])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.drop_duplicates.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx = pd.Index([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;, &#39;hippo&#39;])&gt;&gt;&gt; idx.drop_duplicates(keep=&#39;first&#39;)Index([&#39;lama&#39;, &#39;cow&#39;, &#39;beetle&#39;, &#39;hippo&#39;], dtype=&#39;object&#39;)&gt;&gt;&gt; idx.drop_duplicates(keep=&#39;last&#39;)Index([&#39;cow&#39;, &#39;beetle&#39;, &#39;lama&#39;, &#39;hippo&#39;], dtype=&#39;object&#39;)&gt;&gt;&gt; idx.drop_duplicates(keep=False)Index([&#39;cow&#39;, &#39;beetle&#39;, &#39;hippo&#39;], dtype=&#39;object&#39;)</code></pre><ul><li>duplicated(self[, keep]) 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.duplicated.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx = pd.Index([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;])&gt;&gt;&gt; idx.duplicated()array([False, False,  True, False,  True])&gt;&gt;&gt; idx.duplicated(keep=&#39;first&#39;)array([False, False,  True, False,  True])&gt;&gt;&gt; idx.duplicated(keep=&#39;last&#39;)array([ True, False,  True, False, False])&gt;&gt;&gt; idx.duplicated(keep=False)array([ True, False,  True, False,  True])</code></pre><ul><li><code>dropna(self[, how])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.dropna.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([2, 5, np.NaN, 6, np.NaN, np.NaN]).dropna()Float64Index([2.0, 5.0, 6.0], dtype=&#39;float64&#39;)</code></pre><ul><li><code>fillna(self[, value, downcast])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.fillna.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([2, 5, np.NaN, 6, np.NaN, np.NaN]).fillna(5)Float64Index([2.0, 5.0, 5.0, 6.0, 5.0, 5.0], dtype=&#39;float64&#39;)</code></pre><ul><li><code>equals(self, other)</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.equals.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx1 = pd.Index([5, 2, 3, 9, 1])&gt;&gt;&gt; idx2 = pd.Index([5, 2, 3, 9, 1])&gt;&gt;&gt; idx1.equals(idx2)True&gt;&gt;&gt; &gt;&gt;&gt; idx1 = pd.Index([5, 2, 3, 9, 1])&gt;&gt;&gt; idx2 = pd.Index([5, 2, 4, 9, 1])&gt;&gt;&gt; idx1.equals(idx2)False</code></pre><ul><li><code>intersection(self, other[, sort])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.intersection.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx1 = pd.Index([1, 2, 3, 4])&gt;&gt;&gt; idx2 = pd.Index([3, 4, 5, 6])&gt;&gt;&gt; idx1.intersection(idx2)Int64Index([3, 4], dtype=&#39;int64&#39;)</code></pre><ul><li><code>insert(self, loc, item)</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.insert.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([5, 2, 3, 9, 1]).insert(2, &#39;A&#39;)Index([5, 2, &#39;A&#39;, 3, 9, 1], dtype=&#39;object&#39;)</code></pre><ul><li><code>isna(self)</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.isna.html">官方文档</a>】、<code>isnull(self)</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.isnull.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([2, 5, np.NaN, 6, np.NaN, np.NaN]).isna()array([False, False,  True, False,  True,  True])&gt;&gt;&gt; pd.Index([2, 5, np.NaN, 6, np.NaN, np.NaN]).isnull()array([False, False,  True, False,  True,  True])</code></pre><ul><li><code>max(self[, axis, skipna])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.max.html">官方文档</a>】、<code>min(self[, axis, skipna])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.min.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([5, 2, 3, 9, 1]).max()9&gt;&gt;&gt; pd.Index([5, 2, 3, 9, 1]).min()1</code></pre><ul><li><code>union(self, other[, sort])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.union.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; idx1 = pd.Index([1, 2, 3, 4])&gt;&gt;&gt; idx2 = pd.Index([3, 4, 5, 6])&gt;&gt;&gt; idx1.union(idx2)Int64Index([1, 2, 3, 4, 5, 6], dtype=&#39;int64&#39;)</code></pre><ul><li><code>unique(self[, level])</code> 【<a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.unique.html">官方文档</a>】</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Index([5, 1, 3, 5, 1]).unique()Int64Index([5, 1, 3], dtype=&#39;int64&#39;)</code></pre><h1 id="【2】Pandas-一般索引"><a href="#【2】Pandas-一般索引" class="headerlink" title="【2】Pandas 一般索引"></a><font color=#FF0000>【2】Pandas 一般索引</font></h1><p>由于在 Pandas 中，由于有一些更高级的索引操作，比如重新索引，层级索引等，因此将一般的切片索引、花式索引、布尔索引等归纳为一般索引。</p><h2 id="【2-1】Series-索引"><a href="#【2-1】Series-索引" class="headerlink" title="【2.1】Series 索引"></a><font color=#4876FF>【2.1】Series 索引</font></h2><h3 id="【2-1-1】head-tail"><a href="#【2-1-1】head-tail" class="headerlink" title="【2.1.1】head() / tail()"></a><font color=#FFA500>【2.1.1】head() / tail()</font></h3><p><code>Series.head()</code> 和 <code>Series.tail()</code> 方法可以获取的前五行和后五行数据，如果向 head() / tail() 里面传入参数，则会获取指定行：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series(np.random.randn(8))&gt;&gt;&gt; obj0   -0.6434371   -0.3656522   -0.9665543   -0.0361274    1.0460955   -2.0483626   -1.8655517    1.344728dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.head()0   -0.6434371   -0.3656522   -0.9665543   -0.0361274    1.046095dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj.head(3)0   -0.6434371   -0.3656522   -0.966554dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; obj.tail()3    1.2212214   -1.3734965    1.0328436    0.0297347   -1.861485dtype: float64&gt;&gt;&gt;&gt;&gt;&gt; obj.tail(3)5    1.0328436    0.0297347   -1.861485dtype: float64</code></pre><h3 id="【2-1-2】行索引"><a href="#【2-1-2】行索引" class="headerlink" title="【2.1.2】行索引"></a><font color=#FFA500>【2.1.2】行索引</font></h3><p>Pandas 中可以按照位置进行索引，也可以按照索引名（index）进行索引，也可以用 Python 字典的表达式和方法来获取值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obja    1b    5c   -8d    2dtype: int64&gt;&gt;&gt; obj[&#39;c&#39;]-8&gt;&gt;&gt; obj[2]-8&gt;&gt;&gt; &#39;b&#39; in objTrue&gt;&gt;&gt; obj.keys()Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=&#39;object&#39;)&gt;&gt;&gt; list(obj.items())[(&#39;a&#39;, 1), (&#39;b&#39;, 5), (&#39;c&#39;, -8), (&#39;d&#39;, 2)]</code></pre><h3 id="【2-1-3】切片索引"><a href="#【2-1-3】切片索引" class="headerlink" title="【2.1.3】切片索引"></a><font color=#FFA500>【2.1.3】切片索引</font></h3><p>切片的方法有两种：按位置切片和按索引名（index）切片，注意：按位置切片时，<font color=#FF0000><strong>不包含</strong></font>终止索引；按索引名（index）切片时，<font color=#FF0000><strong>包含</strong></font>终止索引。</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obja    1b    5c   -8d    2dtype: int64&gt;&gt;&gt;&gt;&gt;&gt; obj[1:3]b    5c   -8dtype: int64&gt;&gt;&gt;&gt;&gt;&gt; obj[0:3:2]a    1c   -8dtype: int64&gt;&gt;&gt;&gt;&gt;&gt; obj[&#39;b&#39;:&#39;d&#39;]b    5c   -8d    2dtype: int64</code></pre><h3 id="【2-1-4】花式索引"><a href="#【2-1-4】花式索引" class="headerlink" title="【2.1.4】花式索引"></a><font color=#FFA500>【2.1.4】花式索引</font></h3><p>所谓的花式索引，就是间隔索引、不连续的索引，传递一个由索引名（index）或者位置参数组成的<font color=#FF0000><strong>列表</strong></font>来一次性获得多个元素：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obja    1b    5c   -8d    2dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj[[0, 2]]a    1c   -8dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj[[&#39;a&#39;, &#39;c&#39;, &#39;d&#39;]]a    1c   -8d    2dtype: int64</code></pre><h3 id="【2-1-5】布尔索引"><a href="#【2-1-5】布尔索引" class="headerlink" title="【2.1.5】布尔索引"></a><font color=#FFA500>【2.1.5】布尔索引</font></h3><p>可以通过一个布尔数组来索引目标数组，即通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2, -3], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;])&gt;&gt;&gt; obja    1b    5c   -8d    2e   -3dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj[obj &gt; 0]a    1b    5d    2dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj &gt; 0a     Trueb     Truec    Falsed     Truee    Falsedtype: bool</code></pre><h2 id="【2-2】DataFrame-索引"><a href="#【2-2】DataFrame-索引" class="headerlink" title="【2.2】DataFrame 索引"></a><font color=#4876FF>【2.2】DataFrame 索引</font></h2><h3 id="【2-2-1】head-tail"><a href="#【2-2-1】head-tail" class="headerlink" title="【2.2.1】head() / tail()"></a><font color=#FFA500>【2.2.1】head() / tail()</font></h3><p>和 Series 一样，<code>DataFrame.head()</code> 和 <code>DataFrame.tail()</code> 方法同样可以获取 DataFrame 的前五行和后五行数据，如果向 head() / tail() 里面传入参数，则会获取指定行：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.random.randn(8,4), columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obj          a         b         c         d0 -1.399390  0.521596 -0.869613  0.5066211 -0.748562 -0.364952  0.188399 -1.4025662  1.378776 -1.476480  0.361635  0.4511343 -0.206405 -1.188609  3.002599  0.5636504  0.993289  1.133748  1.177549 -2.5622865 -0.482157  1.069293  1.143983 -1.3030796 -1.199154  0.220360  0.801838 -0.1045337 -1.359816 -2.092035  2.003530 -0.151812&gt;&gt;&gt; &gt;&gt;&gt; obj.head()          a         b         c         d0 -1.399390  0.521596 -0.869613  0.5066211 -0.748562 -0.364952  0.188399 -1.4025662  1.378776 -1.476480  0.361635  0.4511343 -0.206405 -1.188609  3.002599  0.5636504  0.993289  1.133748  1.177549 -2.562286&gt;&gt;&gt; &gt;&gt;&gt; obj.head(3)          a         b         c         d0 -1.399390  0.521596 -0.869613  0.5066211 -0.748562 -0.364952  0.188399 -1.4025662  1.378776 -1.476480  0.361635  0.451134&gt;&gt;&gt;&gt;&gt;&gt; obj.tail()          a         b         c         d3 -0.206405 -1.188609  3.002599  0.5636504  0.993289  1.133748  1.177549 -2.5622865 -0.482157  1.069293  1.143983 -1.3030796 -1.199154  0.220360  0.801838 -0.1045337 -1.359816 -2.092035  2.003530 -0.151812&gt;&gt;&gt; &gt;&gt;&gt; obj.tail(3)          a         b         c         d5 -0.482157  1.069293  1.143983 -1.3030796 -1.199154  0.220360  0.801838 -0.1045337 -1.359816 -2.092035  2.003530 -0.151812</code></pre><h3 id="【2-2-2】列索引"><a href="#【2-2-2】列索引" class="headerlink" title="【2.2.2】列索引"></a><font color=#FFA500>【2.2.2】列索引</font></h3><p>DataFrame 可以按照列标签（columns）来进行列索引：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.random.randn(7,2), columns = [&#39;a&#39;, &#39;b&#39;])&gt;&gt;&gt; obj          a         b0 -1.198795  0.9283781 -2.878230  0.0146502  2.267475  0.3709523  0.639340 -1.3010414 -1.953444  0.1489345 -0.445225  0.4596326  0.097109 -2.592833&gt;&gt;&gt;&gt;&gt;&gt; obj[&#39;a&#39;]0   -1.1987951   -2.8782302    2.2674753    0.6393404   -1.9534445   -0.4452256    0.097109Name: a, dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj[[&#39;a&#39;]]          a0 -1.1987951 -2.8782302  2.2674753  0.6393404 -1.9534445 -0.4452256  0.097109&gt;&gt;&gt; &gt;&gt;&gt; type(obj[&#39;a&#39;])&lt;class &#39;pandas.core.series.Series&#39;&gt;&gt;&gt;&gt; type(obj[[&#39;a&#39;]])&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</code></pre><h3 id="【2-2-3】切片索引"><a href="#【2-2-3】切片索引" class="headerlink" title="【2.2.3】切片索引"></a><font color=#FFA500>【2.2.3】切片索引</font></h3><p>DataFrame 中的切片索引是针对行来操作的，切片的方法有两种：按位置切片和按索引名（index）切片，注意：按位置切片时，不包含终止索引；按索引名（index）切片时，包含终止索引。</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = np.random.randn(5,4)&gt;&gt;&gt; index = [&#39;I1&#39;, &#39;I2&#39;, &#39;I3&#39;, &#39;I4&#39;, &#39;I5&#39;]&gt;&gt;&gt; columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]&gt;&gt;&gt; obj = pd.DataFrame(data, index, columns)&gt;&gt;&gt; obj           a         b         c         dI1  0.828676 -1.663337  1.753632  1.432487I2  0.368138  0.222166  0.902764 -1.436186I3  2.285615 -2.415175 -1.344456 -0.502214I4  3.224288 -0.500268  1.293596 -1.235549I5 -0.938833 -0.804433 -0.170047 -0.566766&gt;&gt;&gt; &gt;&gt;&gt; obj[0:3]           a         b         c         dI1  0.828676 -1.663337  1.753632  1.432487I2  0.368138  0.222166  0.902764 -1.436186I3  2.285615 -2.415175 -1.344456 -0.502214&gt;&gt;&gt;&gt;&gt;&gt; obj[0:4:2]           a         b         c         dI1 -0.042168  1.437354 -1.114545  0.830790I3  0.241506  0.018984 -0.499151 -1.190143&gt;&gt;&gt;&gt;&gt;&gt; obj[&#39;I2&#39;:&#39;I4&#39;]           a         b         c         dI2  0.368138  0.222166  0.902764 -1.436186I3  2.285615 -2.415175 -1.344456 -0.502214I4  3.224288 -0.500268  1.293596 -1.235549</code></pre><h3 id="【2-2-4】花式索引"><a href="#【2-2-4】花式索引" class="headerlink" title="【2.2.4】花式索引"></a><font color=#FFA500>【2.2.4】花式索引</font></h3><p>和 Series 一样，所谓的花式索引，就是间隔索引、不连续的索引，传递一个由列名（columns）组成的<font color=#FF0000><strong>列表</strong></font>来一次性获得多列元素：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = np.random.randn(5,4)&gt;&gt;&gt; index = [&#39;I1&#39;, &#39;I2&#39;, &#39;I3&#39;, &#39;I4&#39;, &#39;I5&#39;]&gt;&gt;&gt; columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]&gt;&gt;&gt; obj = pd.DataFrame(data, index, columns)&gt;&gt;&gt; obj           a         b         c         dI1 -1.083223 -0.182874 -0.348460 -1.572120I2 -0.205206 -0.251931  1.180131  0.847720I3 -0.980379  0.325553 -0.847566 -0.882343I4 -0.638228 -0.282882 -0.624997 -0.245980I5 -0.229769  1.002930 -0.226715 -0.916591&gt;&gt;&gt; &gt;&gt;&gt; obj[[&#39;a&#39;, &#39;d&#39;]]           a         dI1 -1.083223 -1.572120I2 -0.205206  0.847720I3 -0.980379 -0.882343I4 -0.638228 -0.245980I5 -0.229769 -0.916591</code></pre><h3 id="【2-2-5】布尔索引"><a href="#【2-2-5】布尔索引" class="headerlink" title="【2.2.5】布尔索引"></a><font color=#FFA500>【2.2.5】布尔索引</font></h3><p>可以通过一个布尔数组来索引目标数组，即通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = np.random.randn(5,4)&gt;&gt;&gt; index = [&#39;I1&#39;, &#39;I2&#39;, &#39;I3&#39;, &#39;I4&#39;, &#39;I5&#39;]&gt;&gt;&gt; columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]&gt;&gt;&gt; obj = pd.DataFrame(data, index, columns)&gt;&gt;&gt; obj           a         b         c         dI1 -0.602984 -0.135716  0.999689 -0.339786I2  0.911130 -0.092485 -0.914074 -0.279588I3  0.849606 -0.420055 -1.240389 -0.179297I4  0.249986 -1.250668  0.329416 -1.105774I5 -0.743816  0.430647 -0.058126 -0.337319&gt;&gt;&gt; &gt;&gt;&gt; obj[obj &gt; 0]           a         b         c   dI1       NaN       NaN  0.999689 NaNI2  0.911130       NaN       NaN NaNI3  0.849606       NaN       NaN NaNI4  0.249986       NaN  0.329416 NaNI5       NaN  0.430647       NaN NaN&gt;&gt;&gt; &gt;&gt;&gt; obj &gt; 0        a      b      c      dI1  False  False   True  FalseI2   True  False  False  FalseI3   True  False  False  FalseI4   True  False   True  FalseI5  False   True  False  False</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106698307未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h1 id="【3】索引器：loc-和-iloc"><a href="#【3】索引器：loc-和-iloc" class="headerlink" title="【3】索引器：loc 和 iloc"></a><font color=#FF0000>【3】索引器：loc 和 iloc</font></h1><p>loc 是标签索引、iloc 是位置索引，注意：在 Pandas1.0.0 之前还有 ix 方法（即可按标签也可按位置索引），在 Pandas1.0.0 之后已被移除。</p><h2 id="【3-1】loc-标签索引"><a href="#【3-1】loc-标签索引" class="headerlink" title="【3.1】loc 标签索引"></a><font color=#4876FF>【3.1】loc 标签索引</font></h2><p>loc 标签索引，即根据 index 和 columns 来选择数据。</p><h3 id="【3-1-1】Series-loc"><a href="#【3-1-1】Series-loc" class="headerlink" title="【3.1.1】Series.loc"></a><font color=#FFA500>【3.1.1】Series.loc</font></h3><p>在 Series 中，允许输入：</p><ul><li>单个标签，例如 <code>5</code> 或 <code>&#39;a&#39;</code>，（注意，<code>5</code> 是 index 的名称，而不是位置索引）；</li><li>标签列表或数组，例如 <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>；</li><li>带有标签的切片对象，例如 <code>&#39;a&#39;:&#39;f&#39;</code>。</li></ul><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.loc.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.loc.html</a></p><pre><code class="python">&gt;&gt;&gt; import pandas as np&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obja    1b    5c   -8d    2dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.loc[&#39;a&#39;]1&gt;&gt;&gt; &gt;&gt;&gt; obj.loc[&#39;a&#39;:&#39;c&#39;]a    1b    5c   -8dtype: int64&gt;&gt;&gt;&gt;&gt;&gt; obj.loc[[&#39;a&#39;, &#39;d&#39;]]a    1d    2dtype: int64</code></pre><h3 id="【3-1-2】DataFrame-loc"><a href="#【3-1-2】DataFrame-loc" class="headerlink" title="【3.1.2】DataFrame.loc"></a><font color=#FFA500>【3.1.2】DataFrame.loc</font></h3><p>在 DataFrame 中，第一个参数索引<font color=#FF0000><strong>行</strong></font>，第二个参数是索引<font color=#FF0000><strong>列</strong></font>，允许输入的格式和 Series 大同小异。</p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html</a></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])&gt;&gt;&gt; obj   A  B  Ca  1  2  3b  4  5  6c  7  8  9&gt;&gt;&gt; &gt;&gt;&gt; obj.loc[&#39;a&#39;]A    1B    2C    3Name: a, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.loc[&#39;a&#39;:&#39;c&#39;]   A  B  Ca  1  2  3b  4  5  6c  7  8  9&gt;&gt;&gt; &gt;&gt;&gt; obj.loc[[&#39;a&#39;, &#39;c&#39;]]   A  B  Ca  1  2  3c  7  8  9&gt;&gt;&gt; &gt;&gt;&gt; obj.loc[&#39;b&#39;, &#39;B&#39;]5&gt;&gt;&gt; obj.loc[&#39;b&#39;, &#39;A&#39;:&#39;C&#39;]A    4B    5C    6Name: b, dtype: int64</code></pre><h2 id="【3-2】iloc-位置索引"><a href="#【3-2】iloc-位置索引" class="headerlink" title="【3.2】iloc 位置索引"></a><font color=#4876FF>【3.2】iloc 位置索引</font></h2><p>作用和 loc 一样，不过是基于索引的编号来索引，即根据 index 和 columns 的位置编号来选择数据。</p><h3 id="【3-2-1】Series-iloc"><a href="#【3-2-1】Series-iloc" class="headerlink" title="【3.2.1】Series.iloc"></a><font color=#FFA500>【3.2.1】Series.iloc</font></h3><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.iloc.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.iloc.html</a></p><p>在 Series 中，允许输入：</p><ul><li>整数，例如 <code>5</code>；</li><li>整数列表或数组，例如 <code>[4, 3, 0]</code>；</li><li>具有整数的切片对象，例如 <code>1:7</code>。</li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as np&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obja    1b    5c   -8d    2dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.iloc[1]5&gt;&gt;&gt; &gt;&gt;&gt; obj.iloc[0:2]a    1b    5dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.iloc[[0, 1, 3]]a    1b    5d    2dtype: int64</code></pre><h3 id="【3-2-2】DataFrame-iloc"><a href="#【3-2-2】DataFrame-iloc" class="headerlink" title="【3.2.2】DataFrame.iloc"></a><font color=#FFA500>【3.2.2】DataFrame.iloc</font></h3><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html</a></p><p>在 DataFrame 中，第一个参数索引<font color=#FF0000><strong>行</strong></font>，第二个参数是索引<font color=#FF0000><strong>列</strong></font>，允许输入的格式和 Series 大同小异：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])&gt;&gt;&gt; obj   A  B  Ca  1  2  3b  4  5  6c  7  8  9&gt;&gt;&gt; &gt;&gt;&gt; obj.iloc[1]A    4B    5C    6Name: b, dtype: int64&gt;&gt;&gt; &gt;&gt;&gt; obj.iloc[0:2]   A  B  Ca  1  2  3b  4  5  6&gt;&gt;&gt; &gt;&gt;&gt; obj.iloc[[0, 2]]   A  B  Ca  1  2  3c  7  8  9&gt;&gt;&gt; &gt;&gt;&gt; obj.iloc[1, 2]6&gt;&gt;&gt; &gt;&gt;&gt; obj.iloc[1, 0:2]A    4B    5Name: b, dtype: int64</code></pre><h1 id="【4】Pandas-重新索引"><a href="#【4】Pandas-重新索引" class="headerlink" title="【4】Pandas 重新索引"></a><font color=#FF0000>【4】Pandas 重新索引</font></h1><p>Pandas 对象的一个重要方法是 reindex，其作用是创建一个新对象，它的数据符合新的索引。以 <code>DataFrame.reindex</code> 为例（Series 类似），基本语法如下：</p><p><code>DataFrame.reindex(self, labels=None, index=None, columns=None, axis=None, method=None, copy=True, level=None, fill_value=nan, limit=None, tolerance=None)</code></p><p>部分参数描述如下：（完整参数解释参见<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.reindex.html">官方文档</a>）</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>index</td><td>用作索引的新序列，既可以是 index 实例，也可以是其他序列型的 Python 数据结构</td></tr><tr><td>method</td><td>插值（填充）方式，取值如下：<br><code>None</code>：不填补空白；<br><code>pad / ffill</code>：将上一个有效的观测值向前传播到下一个有效的观测值；<br><code>backfill / bfill</code>：使用下一个有效观察值来填补空白；<br><code>nearest</code>：使用最近的有效观测值来填补空白。</td></tr><tr><td>fill_value</td><td>在重新索引的过程中，需要引入缺失值时使用的替代值</td></tr><tr><td>limit</td><td>前向或后向填充时的最大填充量</td></tr><tr><td>tolerance</td><td>向前或向后填充时，填充不准确匹配项的最大间距（绝对值距离）</td></tr><tr><td>level</td><td>在 Multilndex 的指定级别上匹配简单索引，否则选其子集</td></tr><tr><td>copy</td><td>默认为 True，无论如何都复制；如果为 False，则新旧相等就不复制</td></tr></tbody></table><p>reindex 将会根据新索引进行重排。如果某个索引值当前不存在，就引入缺失值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([4.5, 7.2, -5.3, 3.6], index=[&#39;d&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;])&gt;&gt;&gt; objd    4.5b    7.2a   -5.3c    3.6dtype: float64&gt;&gt;&gt; &gt;&gt;&gt; obj2 = obj.reindex([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;])&gt;&gt;&gt; obj2a   -5.3b    7.2c    3.6d    4.5e    NaNdtype: float64</code></pre><p>对于时间序列这样的有序数据，重新索引时可能需要做一些插值处理。method 选项即可达到此目的，例如，使用 ffill 可以实现前向值填充：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([&#39;blue&#39;, &#39;purple&#39;, &#39;yellow&#39;], index=[0, 2, 4])&gt;&gt;&gt; obj0      blue2    purple4    yellowdtype: object&gt;&gt;&gt; &gt;&gt;&gt; obj2 = obj.reindex(range(6), method=&#39;ffill&#39;)&gt;&gt;&gt; obj20      blue1      blue2    purple3    purple4    yellow5    yellowdtype: object</code></pre><p>借助 DataFrame，reindex可以修改（行）索引和列。只传递一个序列时，会重新索引结果的行：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.arange(9).reshape((3, 3)), index=[&#39;a&#39;, &#39;c&#39;, &#39;d&#39;], columns=[&#39;Ohio&#39;, &#39;Texas&#39;, &#39;California&#39;])&gt;&gt;&gt; obj   Ohio  Texas  Californiaa     0      1           2c     3      4           5d     6      7           8&gt;&gt;&gt; &gt;&gt;&gt; obj2 = obj.reindex([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obj2   Ohio  Texas  Californiaa   0.0    1.0         2.0b   NaN    NaN         NaNc   3.0    4.0         5.0d   6.0    7.0         8.0</code></pre><p>列可以用 columns 关键字重新索引：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.DataFrame(np.arange(9).reshape((3, 3)), index=[&#39;a&#39;, &#39;c&#39;, &#39;d&#39;], columns=[&#39;Ohio&#39;, &#39;Texas&#39;, &#39;California&#39;])&gt;&gt;&gt; obj   Ohio  Texas  Californiaa     0      1           2c     3      4           5d     6      7           8&gt;&gt;&gt; &gt;&gt;&gt; states = [&#39;Texas&#39;, &#39;Utah&#39;, &#39;California&#39;]&gt;&gt;&gt; obj.reindex(columns=states)   Texas  Utah  Californiaa      1   NaN           2c      4   NaN           5d      7   NaN           8</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106698307未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</title>
      <link href="/article/025/"/>
      <url>/article/025/</url>
      
        <content type="html"><![CDATA[<p>Pandas 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/025/">Python 数据分析三剑客之 Pandas（一）：认识 Pandas 及其 Series、DataFrame 对象</a></li><li><a href="https://www.itbob.cn/article/026/">Python 数据分析三剑客之 Pandas（二）：Index 索引对象以及各种索引操作</a></li><li><a href="https://www.itbob.cn/article/027/">Python 数据分析三剑客之 Pandas（三）：算术运算与缺失值的处理</a></li><li><a href="https://www.itbob.cn/article/028/">Python 数据分析三剑客之 Pandas（四）：函数应用、映射、排序和层级索引</a></li><li><a href="https://www.itbob.cn/article/029/">Python 数据分析三剑客之 Pandas（五）：统计计算与统计描述</a></li><li><a href="https://www.itbob.cn/article/030/">Python 数据分析三剑客之 Pandas（六）：GroupBy 数据分裂、应用与合并</a></li><li><a href="https://www.itbob.cn/article/031/">Python 数据分析三剑客之 Pandas（七）：合并数据集</a></li><li><a href="https://www.itbob.cn/article/032/">Python 数据分析三剑客之 Pandas（八）：数据重塑、重复数据处理与数据替换</a></li><li><a href="https://www.itbob.cn/article/033/">Python 数据分析三剑客之 Pandas（九）：时间序列</a></li><li><a href="https://www.itbob.cn/article/034/">Python 数据分析三剑客之 Pandas（十）：数据读写</a></li></ul><hr><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106676693未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】了解-Pandas"><a href="#【01x00】了解-Pandas" class="headerlink" title="【01x00】了解 Pandas"></a><font color=#FF0000>【01x00】了解 Pandas</font></h2><p><a href="https://pandas.pydata.org/">Pandas</a> 是 <a href="https://www.python.org/">Python</a> 的一个数据分析包，是基于 <a href="https://numpy.org/">NumPy</a> 构建的，最初由 <a href="https://www.aqr.com/">AQR Capital Management</a> 于 2008 年 4 月开发，并于 2009 年底开源出来，目前由专注于 <a href="https://www.python.org/">Python</a> 数据包开发的 <a href="https://pydata.org/">PyData</a> 开发团队继续开发和维护，属于 <a href="https://pydata.org/">PyData</a> 项目的一部分。</p><p><a href="https://pandas.pydata.org/">Pandas</a> 最初被作为金融数据分析工具而开发出来，因此，<a href="https://pandas.pydata.org/">Pandas</a> 为时间序列分析提供了很好的支持。<font color=#FFA500><strong>Pandas 的名称来自于面板数据（panel data）和 Python 数据分析（data analysis）</strong></font>。panel data 是经济学中关于多维数据集的一个术语，在 <a href="https://pandas.pydata.org/">Pandas</a> 中也提供了 panel 的数据类型。</p><p><a href="https://pandas.pydata.org/">Pandas</a> 经常和其它工具一同使用，如数值计算工具 <a href="https://numpy.org/">NumPy</a> 和 <a href="https://www.scipy.org/">SciPy</a>，分析库 <a href="https://www.statsmodels.org/">statsmodels</a> 和 <a href="https://scikit-learn.org/">scikit-learn</a>，数据可视化库 <a href="https://matplotlib.org/">Matplotlib</a> 等，虽然 <a href="https://pandas.pydata.org/">Pandas</a> 采用了大量的 NumPy 编码风格，但二者最大的不同是 <font color=#FFA500><strong>Pandas 是专门为处理表格和混杂数据设计的。而 NumPy 更适合处理统一的数值数组数据。</strong></font></p><hr><p>【以下对 Pandas 的解释翻译自官方文档：<a href="https://pandas.pydata.org/docs/getting_started/overview.html#package-overview">https://pandas.pydata.org/docs/getting_started/overview.html#package-overview</a>】</p><hr><p>Pandas 是 Python 的核心数据分析支持库，提供了快速、灵活、明确的数据结构，旨在简单、直观地处理关系型、标记型数据。Pandas 的目标是成为 Python 数据分析实践与实战的必备高级工具，其长远目标是成为<strong>最强大、最灵活、可以支持任何语言的开源数据分析工具</strong>。经过多年不懈的努力，Pandas 离这个目标已经越来越近了。</p><p>Pandas 适用于处理以下类型的数据：</p><ul><li>与 SQL 或 Excel 表类似的，含异构列的表格数据;</li><li>有序和无序（非固定频率）的时间序列数据;</li><li>带行列标签的矩阵数据，包括同构或异构型数据;</li><li>任意其它形式的观测、统计数据集, 数据转入 Pandas 数据结构时不必事先标记。</li></ul><p>Pandas 的主要数据结构是 <a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.html#pandas.Series">Series</a>（一维数据）与 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html#pandas.DataFrame">DataFrame</a>（二维数据），这两种数据结构足以处理- 金融、统计、社会科学、工程等领域里的大多数典型用例。对于 R 语言用户，<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html#pandas.DataFrame">DataFrame</a> 提供了比 R 语言 <code>data.frame</code> 更丰富的功能。Pandas 基于 <a href="https://www.numpy.org/">NumPy</a> 开发，可以与其它第三方科学计算支持库完美集成。</p><p>Pandas 就像一把万能瑞士军刀，下面仅列出了它的部分优势 ：</p><ul><li>处理浮点与非浮点数据里的<strong>缺失数据</strong>，表示为 NaN；</li><li>大小可变：<strong>插入或删除</strong> DataFrame 等多维对象的列；</li><li>自动、显式<strong>数据对齐</strong>：显式地将对象与一组标签对齐，也可以忽略标签，在 Series、DataFrame 计算时自动与数据对齐；</li><li>强大、灵活的<strong>分组</strong>（group by）功能：<strong>拆分-应用-组合</strong>数据集，聚合、转换数据；</li><li>把 Python 和 NumPy 数据结构里不规则、不同索引的数据<strong>轻松地转换</strong>为 DataFrame 对象；</li><li>基于智能标签，对大型数据集进行<strong>切片、花式索引、子集分解</strong>等操作；</li><li>直观地<strong>合并</strong>和<strong>连接</strong>数据集；</li><li>灵活地<strong>重塑</strong>和<strong>旋转</strong>数据集；</li><li>轴支持<strong>分层</strong>标签（每个刻度可能有多个标签）；</li><li>强大的 IO 工具，读取平面文件（CSV 等支持分隔符的文件）、Excel 文件、数据库等来源的数据，以及从超快 <strong>HDF5 格式</strong>保存 / 加载数据；</li><li><strong>时间序列</strong>：支持日期范围生成、频率转换、移动窗口统计、移动窗口线性回归、日期位移等时间序列功能。</li></ul><p>这些功能主要是为了解决其它编程语言、科研环境的痛点。处理数据一般分为几个阶段：数据整理与清洗、数据分析与建模、数据可视化与制表，Pandas 是处理数据的理想工具。</p><p>其它说明：</p><ul><li>Pandas 速度很快。Pandas 的很多底层算法都用 <a href="https://cython.org/">Cython</a> 优化过。然而，为了保持通用性，必然要牺牲一些性能，如果专注某一功能，完全可以开发出比 Pandas 更快的专用工具。</li><li>Pandas 是 <a href="https://www.statsmodels.org/stable/index.html">statsmodels</a> 的依赖项，因此，Pandas 也是 Python 中统计计算生态系统的重要组成部分。</li><li>Pandas 已广泛应用于金融领域。</li></ul><h2 id="【02x00】Pandas-数据结构"><a href="#【02x00】Pandas-数据结构" class="headerlink" title="【02x00】Pandas 数据结构"></a><font color=#FF0000>【02x00】Pandas 数据结构</font></h2><p>Pandas 的主要数据结构是 <a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.html#pandas.Series">Series</a>（带标签的一维同构数组）与 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html#pandas.DataFrame">DataFrame</a>（带标签的，大小可变的二维异构表格）。</p><p>Pandas 数据结构就像是低维数据的容器。比如，DataFrame 是 Series 的容器，Series 则是标量的容器。使用这种方式，可以在容器中以字典的形式插入或删除对象。</p><p>此外，通用 API 函数的默认操作要顾及时间序列与截面数据集的方向。当使用 Ndarray 存储二维或三维数据时，编写函数要注意数据集的方向，这对用户来说是一种负担；如果不考虑 C 或 Fortran 中连续性对性能的影响，一般情况下，不同的轴在程序里其实没有什么区别。Pandas 里，轴的概念主要是为了给数据赋予更直观的语义，即用更恰当的方式表示数据集的方向。这样做可以让用户编写数据转换函数时，少费点脑子。</p><p>处理 DataFrame 等表格数据时，对比 Numpy，<strong>index</strong>（行）或 <strong>columns</strong>（列）比 <strong>axis 0</strong> 和 <strong>axis 1</strong> 更直观。用这种方式迭代 DataFrame 的列，代码更易读易懂：</p><pre><code class="python">for col in df.columns:    series = df[col]    # do something with series</code></pre><h2 id="【03x00】Series-对象"><a href="#【03x00】Series-对象" class="headerlink" title="【03x00】Series 对象"></a><font color=#FF0000>【03x00】Series 对象</font></h2><p>Series 是带标签的一维数组，可存储整数、浮点数、字符串、Python 对象等类型的数据。轴标签统称为索引。调用 pandas.Series 函数即可创建 Series，基本语法如下：</p><p><code>pandas.Series(data=None[, index=None, dtype=None, name=None, copy=False, fastpath=False])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>data</td><td>数组类型，可迭代的，字典或标量值，存储在序列中的数据</td></tr><tr><td>index</td><td>索引（数据标签），值必须是可哈希的，并且具有与数据相同的长度，<br>允许使用非唯一索引值。如果未提供，将默认为RangeIndex（0，1，2，…，n）</td></tr><tr><td>dtype</td><td>输出系列的数据类型。可选项，如果未指定，则将从数据中推断，具体参考官网 <a href="https://pandas.pydata.org/docs/getting_started/basics.html#dtypes">dtypes</a> 介绍</td></tr><tr><td>name</td><td>str 类型，可选项，给 Series 命名</td></tr><tr><td>copy</td><td>bool 类型，可选项，默认 False，是否复制输入数据</td></tr></tbody></table><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A79/01.png" alt="01"></p><h3 id="【03x01】通过-list-构建-Series"><a href="#【03x01】通过-list-构建-Series" class="headerlink" title="【03x01】通过 list 构建 Series"></a><font color=#4876FF>【03x01】通过 list 构建 Series</font></h3><p>一般情况下我们只会用到 data 和 index 参数，可以通过 list（列表） 构建 Series，示例如下：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2])&gt;&gt;&gt; obj0    11    52   -83    2dtype: int64</code></pre><p>由于我们没有为数据指定索引，于是会自动创建一个 0 到 N-1（N 为数据的长度）的整数型索引，左边一列是自动创建的索引（index），右边一列是数据（data）。</p><p>此外，还可以自定义索引（index）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obja    1b    5c   -8d    2dtype: int64</code></pre><p>索引（index）也可以通过赋值的方式就地修改：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obja    1b    5c   -8d    2dtype: int64&gt;&gt;&gt; obj.index = [&#39;Bob&#39;, &#39;Steve&#39;, &#39;Jeff&#39;, &#39;Ryan&#39;]&gt;&gt;&gt; objBob      1Steve    5Jeff    -8Ryan     2dtype: int64</code></pre><h3 id="【03x02】通过-dict-构建-Series"><a href="#【03x02】通过-dict-构建-Series" class="headerlink" title="【03x02】通过 dict 构建 Series"></a><font color=#4876FF>【03x02】通过 dict 构建 Series</font></h3><p>通过 字典（dict） 构建 Series，字典的键（key）会作为索引（index），字典的值（value）会作为数据（data），示例如下：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;Beijing&#39;: 21530000, &#39;Shanghai&#39;: 24280000, &#39;Wuhan&#39;: 11210000, &#39;Zhejiang&#39;: 58500000&#125;&gt;&gt;&gt; obj = pd.Series(data)&gt;&gt;&gt; objBeijing     21530000Shanghai    24280000Wuhan       11210000Zhejiang    58500000dtype: int64</code></pre><p>如果你想按照某个特定的顺序输出结果，可以传入排好序的字典的键以改变顺序：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;Beijing&#39;: 21530000, &#39;Shanghai&#39;: 24280000, &#39;Wuhan&#39;: 11210000, &#39;Zhejiang&#39;: 58500000&#125;&gt;&gt;&gt; cities = [&#39;Guangzhou&#39;, &#39;Wuhan&#39;, &#39;Zhejiang&#39;, &#39;Shanghai&#39;]&gt;&gt;&gt; obj = pd.Series(data, index=cities)&gt;&gt;&gt; objGuangzhou           NaNWuhan        11210000.0Zhejiang     58500000.0Shanghai     24280000.0dtype: float64</code></pre><p><font color=#FF0000><strong>注意：data 为字典，且未设置 index 参数时：</strong></font></p><ul><li><font color=#FF0000><strong>如果 Python &gt;= 3.6 且 Pandas &gt;= 0.23，Series 按字典的插入顺序排序索引。</strong></font></li><li><font color=#FF0000>**如果 Python &lt; 3.6 或 Pandas &lt; 0.23，Series 按字母顺序排序索引。**</font></li></ul><h3 id="【03x03】获取其数据和索引"><a href="#【03x03】获取其数据和索引" class="headerlink" title="【03x03】获取其数据和索引"></a><font color=#4876FF>【03x03】获取其数据和索引</font></h3><p>我们可以通过 Series 的 values 和 index 属性获取其数据和索引对象：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obj.valuesarray([ 1,  5, -8,  2], dtype=int64)&gt;&gt;&gt; obj.indexIndex([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=&#39;object&#39;)</code></pre><h3 id="【03x04】通过索引获取数据"><a href="#【03x04】通过索引获取数据" class="headerlink" title="【03x04】通过索引获取数据"></a><font color=#4876FF>【03x04】通过索引获取数据</font></h3><p>与普通 NumPy 数组相比，Pandas 可以通过索引的方式选取 Series 中的单个或一组值，获取一组值时，传入的是一个列表，列表中的元素是索引值，另外还可以通过索引来修改其对应的值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obja    1b    5c   -8d    2dtype: int64&gt;&gt;&gt; obj[&#39;a&#39;]1&gt;&gt;&gt; obj[&#39;a&#39;] = 3&gt;&gt;&gt; obj[[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]]a    3b    5c   -8dtype: int64</code></pre><h3 id="【03x05】使用函数运算"><a href="#【03x05】使用函数运算" class="headerlink" title="【03x05】使用函数运算"></a><font color=#4876FF>【03x05】使用函数运算</font></h3><p>在 Pandas 中可以使用 NumPy 函数或类似 NumPy 的运算（如根据布尔型数组进行过滤、标量乘法、应用数学函数等）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obj[obj &gt; 0]a    1b    5d    2dtype: int64&gt;&gt;&gt; obj * 2a     2b    10c   -16d     4dtype: int64&gt;&gt;&gt; np.exp(obj)a      2.718282b    148.413159c      0.000335d      7.389056dtype: float64</code></pre><p>除了这些运算函数以外，还可以将 Series 看成是一个定长的有序字典，因为它是索引值到数据值的一个映射。它可以用在许多原本需要字典参数的函数中：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; obj = pd.Series([1, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; &#39;a&#39; in objTrue&gt;&gt;&gt; &#39;e&#39; in objFalse</code></pre><p>和 NumPy 类似，Pandas 中也有 NaN（即非数字，not a number），在 Pandas 中，它用于表示缺失值，Pandas 的 isnull 和 notnull 函数可用于检测缺失数据：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; obj = pd.Series([np.NaN, 5, -8, 2], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; obja    NaNb    5.0c   -8.0d    2.0dtype: float64&gt;&gt;&gt; pd.isnull(obj)a     Trueb    Falsec    Falsed    Falsedtype: bool&gt;&gt;&gt; pd.notnull(obj)a    Falseb     Truec     Trued     Truedtype: bool&gt;&gt;&gt; obj.isnull()a     Trueb    Falsec    Falsed    Falsedtype: bool&gt;&gt;&gt; obj.notnull()a    Falseb     Truec     Trued     Truedtype: bool</code></pre><h3 id="【03x06】name-属性"><a href="#【03x06】name-属性" class="headerlink" title="【03x06】name 属性"></a><font color=##4876FF>【03x06】name 属性</font></h3><p>可以在 <code>pandas.Series</code> 方法中为 Series 对象指定一个 name：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;Beijing&#39;: 21530000, &#39;Shanghai&#39;: 24280000, &#39;Wuhan&#39;: 11210000, &#39;Zhejiang&#39;: 58500000&#125;&gt;&gt;&gt; obj = pd.Series(data, name=&#39;population&#39;)&gt;&gt;&gt; objBeijing     21530000Shanghai    24280000Wuhan       11210000Zhejiang    58500000Name: population, dtype: int64</code></pre><p>也可以通过 name 和 index.name 属性为 Series 对象和其索引指定 name：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;Beijing&#39;: 21530000, &#39;Shanghai&#39;: 24280000, &#39;Wuhan&#39;: 11210000, &#39;Zhejiang&#39;: 58500000&#125;&gt;&gt;&gt; obj = pd.Series(data)&gt;&gt;&gt; obj.name = &#39;population&#39;&gt;&gt;&gt; obj.index.name = &#39;cities&#39;&gt;&gt;&gt; objcitiesBeijing     21530000Shanghai    24280000Wuhan       11210000Zhejiang    58500000Name: population, dtype: int64</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106676693未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【04x00】DataFrame-对象"><a href="#【04x00】DataFrame-对象" class="headerlink" title="【04x00】DataFrame 对象"></a><font color=#FF0000>【04x00】DataFrame 对象</font></h2><p>DataFrame 是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）。DataFrame 既有行索引也有列索引，它可以被看做由 Series 组成的字典（共用同一个索引）。DataFrame 中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）。</p><ul><li>类似多维数组/表格数据 (如Excel、R 语言中的 data.frame)；</li><li>每列数据可以是不同的类型；</li><li>索引包括列索引和行索引</li></ul><p>基本语法如下：</p><p><code>pandas.DataFrame(data=None, index: Optional[Collection] = None, columns: Optional[Collection] = None, dtype: Union[str, numpy.dtype, ExtensionDtype, None] = None, copy: bool = False)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>data</td><td>ndarray 对象（结构化或同类的）、可迭代的或者字典形式，存储在序列中的数据</td></tr><tr><td>index</td><td>数组类型，索引（数据标签），如果未提供，将默认为 RangeIndex（0，1，2，…，n）</td></tr><tr><td>columns</td><td>列标签。如果未提供，则将默认为 RangeIndex（0、1、2、…、n）</td></tr><tr><td>dtype</td><td>输出系列的数据类型。可选项，如果未指定，则将从数据中推断，具体参考官网 <a href="https://pandas.pydata.org/docs/getting_started/basics.html#dtypes">dtypes</a> 介绍</td></tr><tr><td>copy</td><td>bool 类型，可选项，默认 False，是否复制输入数据，仅影响 DataFrame/2d ndarray 输入</td></tr></tbody></table><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A79/02.png" alt="02"></p><h3 id="【03x01】通过-ndarray-构建-DataFrame"><a href="#【03x01】通过-ndarray-构建-DataFrame" class="headerlink" title="【03x01】通过 ndarray 构建 DataFrame"></a><font color=#4876FF>【03x01】通过 ndarray 构建 DataFrame</font></h3><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = np.random.randn(5,3)&gt;&gt;&gt; dataarray([[-2.16231157,  0.44967198, -0.73131523],       [ 1.18982913,  0.94670798,  0.82973421],       [-1.57680831, -0.99732066,  0.96432   ],       [-0.77483149, -1.23802881,  0.44061227],       [ 1.77666419,  0.24931983, -1.12960153]])&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj          0         1         20 -2.162312  0.449672 -0.7313151  1.189829  0.946708  0.8297342 -1.576808 -0.997321  0.9643203 -0.774831 -1.238029  0.4406124  1.776664  0.249320 -1.129602</code></pre><p>指定索引（index）和列标签（columns），和 Series 对象类似，可以在构建的时候添加索引和标签，也可以直接通过赋值的方式就地修改：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = np.random.randn(5,3)&gt;&gt;&gt; index = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]&gt;&gt;&gt; columns = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]&gt;&gt;&gt; obj = pd.DataFrame(data, index, columns)&gt;&gt;&gt; obj          A         B         Ca -1.042909 -0.238236 -1.050308b  0.587079  0.739683 -0.233624c -0.451254 -0.638496  1.708807d -0.620158 -1.875929 -0.432382e -1.093815  0.396965 -0.759479&gt;&gt;&gt;&gt;&gt;&gt; obj.index = [&#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;, &#39;A4&#39;, &#39;A5&#39;]&gt;&gt;&gt; obj.columns = [&#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;]&gt;&gt;&gt; obj          B1        B2        B3A1 -1.042909 -0.238236 -1.050308A2  0.587079  0.739683 -0.233624A3 -0.451254 -0.638496  1.708807A4 -0.620158 -1.875929 -0.432382A5 -1.093815  0.396965 -0.759479</code></pre><h3 id="【03x02】通过-dict-构建-DataFrame"><a href="#【03x02】通过-dict-构建-DataFrame" class="headerlink" title="【03x02】通过 dict 构建 DataFrame"></a><font color=#4876FF>【03x02】通过 dict 构建 DataFrame</font></h3><p>通过 字典（dict） 构建 DataFrame，字典的键（key）会作为列标签（columns），字典的值（value）会作为数据（data），示例如下：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;city&#39;: [&#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;],        &#39;year&#39;: [2017, 2018, 2019, 2017, 2018, 2019],        &#39;people&#39;: [10892900, 11081000, 11212000, 21707000, 21542000, 21536000]&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj      city  year    people0    Wuhan  2017  108929001    Wuhan  2018  110810002    Wuhan  2019  112120003  Beijing  2017  217070004  Beijing  2018  215420005  Beijing  2019  21536000</code></pre><p>如果指定了列序列，则 DataFrame 的列就会按照指定顺序进行排列，如果传入的列在数据中找不到，就会在结果中产生缺失值（NaN）：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;city&#39;: [&#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;],        &#39;year&#39;: [2017, 2018, 2019, 2017, 2018, 2019],        &#39;people&#39;: [10892900, 11081000, 11212000, 21707000, 21542000, 21536000]&#125;&gt;&gt;&gt; pd.DataFrame(data)      city  year    people0    Wuhan  2017  108929001    Wuhan  2018  110810002    Wuhan  2019  112120003  Beijing  2017  217070004  Beijing  2018  215420005  Beijing  2019  21536000&gt;&gt;&gt; pd.DataFrame(data, columns=[&#39;year&#39;, &#39;city&#39;, &#39;people&#39;])   year     city    people0  2017    Wuhan  108929001  2018    Wuhan  110810002  2019    Wuhan  112120003  2017  Beijing  217070004  2018  Beijing  215420005  2019  Beijing  21536000&gt;&gt;&gt; pd.DataFrame(data, columns=[&#39;year&#39;, &#39;city&#39;, &#39;people&#39;, &#39;money&#39;])   year     city    people money0  2017    Wuhan  10892900   NaN1  2018    Wuhan  11081000   NaN2  2019    Wuhan  11212000   NaN3  2017  Beijing  21707000   NaN4  2018  Beijing  21542000   NaN5  2019  Beijing  21536000   NaN</code></pre><p><font color=#FF0000><strong>注意：data 为字典，且未设置 columns 参数时：</strong></font></p><ul><li><p><font color=#FF0000><strong>Python &gt; = 3.6 且 Pandas &gt; = 0.23，DataFrame 的列按字典的插入顺序排序。</strong></font></p></li><li><p><font color=#FF0000>**Python &lt; 3.6 或 Pandas &lt; 0.23，DataFrame 的列按字典键的字母排序。**</font></p></li></ul><h3 id="【03x03】获取其数据和索引-1"><a href="#【03x03】获取其数据和索引-1" class="headerlink" title="【03x03】获取其数据和索引"></a><font color=#4876FF>【03x03】获取其数据和索引</font></h3><p>和 Series 一样，DataFrame 也可以通过其 values 和 index 属性获取其数据和索引对象：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;city&#39;: [&#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;],    &#39;year&#39;: [2017, 2018, 2019, 2017, 2018, 2019],        &#39;people&#39;: [10892900, 11081000, 11212000, 21707000, 21542000, 21536000]&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj.indexRangeIndex(start=0, stop=6, step=1)&gt;&gt;&gt; obj.valuesarray([[&#39;Wuhan&#39;, 2017, 10892900],       [&#39;Wuhan&#39;, 2018, 11081000],       [&#39;Wuhan&#39;, 2019, 11212000],       [&#39;Beijing&#39;, 2017, 21707000],       [&#39;Beijing&#39;, 2018, 21542000],       [&#39;Beijing&#39;, 2019, 21536000]], dtype=object)</code></pre><h3 id="【03x04】通过索引获取数据-1"><a href="#【03x04】通过索引获取数据-1" class="headerlink" title="【03x04】通过索引获取数据"></a><font color=#4876FF>【03x04】通过索引获取数据</font></h3><p>通过类似字典标记的方式或属性的方式，可以将 DataFrame 的列获取为一个 Series 对象；</p><p>行也可以通过位置或名称的方式进行获取，比如用 loc 属性；</p><p>对于特别大的 DataFrame，有一个 head 方法可以选取前五行数据。</p><p>用法示例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;city&#39;: [&#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;],    &#39;year&#39;: [2017, 2018, 2019, 2017, 2018, 2019],        &#39;people&#39;: [10892900, 11081000, 11212000, 21707000, 21542000, 21536000]&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj      city  year    people0    Wuhan  2017  108929001    Wuhan  2018  110810002    Wuhan  2019  112120003  Beijing  2017  217070004  Beijing  2018  215420005  Beijing  2019  21536000&gt;&gt;&gt;&gt;&gt;&gt; obj[&#39;city&#39;]0      Wuhan1      Wuhan2      Wuhan3    Beijing4    Beijing5    BeijingName: city, dtype: object&gt;&gt;&gt;&gt;&gt;&gt; obj.year0    20171    20182    20193    20174    20185    2019Name: year, dtype: int64&gt;&gt;&gt;&gt;&gt;&gt; type(obj.year)&lt;class &#39;pandas.core.series.Series&#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt; obj.loc[2]city         Wuhanyear          2019people    11212000Name: 2, dtype: object&gt;&gt;&gt;&gt;&gt;&gt; obj.head()      city  year    people0    Wuhan  2017  108929001    Wuhan  2018  110810002    Wuhan  2019  112120003  Beijing  2017  217070004  Beijing  2018  21542000</code></pre><h3 id="【03x05】修改列的值"><a href="#【03x05】修改列的值" class="headerlink" title="【03x05】修改列的值"></a><font color=#4876FF>【03x05】修改列的值</font></h3><p>列可以通过赋值的方式进行修改。在下面示例中，分别给”money”列赋上一个标量值和一组值：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = &#123;&#39;city&#39;: [&#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;],        &#39;year&#39;: [2017, 2018, 2019, 2017, 2018, 2019],        &#39;people&#39;: [10892900, 11081000, 11212000, 21707000, 21542000, 21536000],        &#39;money&#39;:[np.NaN, np.NaN, np.NaN, np.NaN, np.NaN, np.NaN]&#125;&gt;&gt;&gt; obj = pd.DataFrame(data, index=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;])&gt;&gt;&gt; obj      city  year    people  moneyA    Wuhan  2017  10892900    NaNB    Wuhan  2018  11081000    NaNC    Wuhan  2019  11212000    NaND  Beijing  2017  21707000    NaNE  Beijing  2018  21542000    NaNF  Beijing  2019  21536000    NaN&gt;&gt;&gt;&gt;&gt;&gt; obj[&#39;money&#39;] = 6666666666&gt;&gt;&gt; obj      city  year    people       moneyA    Wuhan  2017  10892900  6666666666B    Wuhan  2018  11081000  6666666666C    Wuhan  2019  11212000  6666666666D  Beijing  2017  21707000  6666666666E  Beijing  2018  21542000  6666666666F  Beijing  2019  21536000  6666666666&gt;&gt;&gt;&gt;&gt;&gt; obj[&#39;money&#39;] = np.arange(100000000, 700000000, 100000000)&gt;&gt;&gt; obj      city  year    people      moneyA    Wuhan  2017  10892900  100000000B    Wuhan  2018  11081000  200000000C    Wuhan  2019  11212000  300000000D  Beijing  2017  21707000  400000000E  Beijing  2018  21542000  500000000F  Beijing  2019  21536000  600000000</code></pre><p>将列表或数组赋值给某个列时，其长度必须跟 DataFrame 的长度相匹配。如果赋值的是一个 Series，就会精确匹配 DataFrame 的索引：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data = &#123;&#39;city&#39;: [&#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;],        &#39;year&#39;: [2017, 2018, 2019, 2017, 2018, 2019],        &#39;people&#39;: [10892900, 11081000, 11212000, 21707000, 21542000, 21536000],        &#39;money&#39;:[np.NaN, np.NaN, np.NaN, np.NaN, np.NaN, np.NaN]&#125;&gt;&gt;&gt; obj = pd.DataFrame(data, index=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;])&gt;&gt;&gt; obj      city  year    people  moneyA    Wuhan  2017  10892900    NaNB    Wuhan  2018  11081000    NaNC    Wuhan  2019  11212000    NaND  Beijing  2017  21707000    NaNE  Beijing  2018  21542000    NaNF  Beijing  2019  21536000    NaN&gt;&gt;&gt; &gt;&gt;&gt; new_data = pd.Series([5670000000, 6890000000, 7890000000], index=[&#39;A&#39;, &#39;C&#39;, &#39;E&#39;])&gt;&gt;&gt; obj[&#39;money&#39;] = new_data&gt;&gt;&gt; obj      city  year    people         moneyA    Wuhan  2017  10892900  5.670000e+09B    Wuhan  2018  11081000           NaNC    Wuhan  2019  11212000  6.890000e+09D  Beijing  2017  21707000           NaNE  Beijing  2018  21542000  7.890000e+09F  Beijing  2019  21536000           NaN</code></pre><h3 id="【03x06】增加-删除列"><a href="#【03x06】增加-删除列" class="headerlink" title="【03x06】增加 / 删除列"></a><font color=#4876FF>【03x06】增加 / 删除列</font></h3><p>为不存在的列赋值会创建出一个新列，关键字 del 用于删除列：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;city&#39;: [&#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;],    &#39;year&#39;: [2017, 2018, 2019, 2017, 2018, 2019],        &#39;people&#39;: [10892900, 11081000, 11212000, 21707000, 21542000, 21536000]&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj      city  year    people0    Wuhan  2017  108929001    Wuhan  2018  110810002    Wuhan  2019  112120003  Beijing  2017  217070004  Beijing  2018  215420005  Beijing  2019  21536000&gt;&gt;&gt; &gt;&gt;&gt; obj[&#39;northern&#39;] = obj[&#39;city&#39;] == &#39;Beijing&#39;&gt;&gt;&gt; obj      city  year    people  northern0    Wuhan  2017  10892900     False1    Wuhan  2018  11081000     False2    Wuhan  2019  11212000     False3  Beijing  2017  21707000      True4  Beijing  2018  21542000      True5  Beijing  2019  21536000      True&gt;&gt;&gt; &gt;&gt;&gt; del obj[&#39;northern&#39;]&gt;&gt;&gt; obj      city  year    people0    Wuhan  2017  108929001    Wuhan  2018  110810002    Wuhan  2019  112120003  Beijing  2017  217070004  Beijing  2018  215420005  Beijing  2019  21536000</code></pre><h3 id="【03x07】name-属性"><a href="#【03x07】name-属性" class="headerlink" title="【03x07】name 属性"></a><font color=##4876FF>【03x07】name 属性</font></h3><p>可以通过 index.name 和 columns.name 属性设置索引（index）和列标签（columns）的 name，注意 DataFrame 对象是没有 name 属性的：</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; data = &#123;&#39;city&#39;: [&#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Wuhan&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;, &#39;Beijing&#39;],        &#39;year&#39;: [2017, 2018, 2019, 2017, 2018, 2019],        &#39;people&#39;: [10892900, 11081000, 11212000, 21707000, 21542000, 21536000]&#125;&gt;&gt;&gt; obj = pd.DataFrame(data)&gt;&gt;&gt; obj.index.name = &#39;index&#39;&gt;&gt;&gt; obj.columns.name = &#39;columns&#39;&gt;&gt;&gt; objcolumns     city  year    peopleindex                           0          Wuhan  2017  108929001          Wuhan  2018  110810002          Wuhan  2019  112120003        Beijing  2017  217070004        Beijing  2018  215420005        Beijing  2019  21536000</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106676693未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Matplotlib（十一）：最常用最有价值的 50 个图表【译文】</title>
      <link href="/article/024/"/>
      <url>/article/024/</url>
      
        <content type="html"><![CDATA[<p>Matplotlib 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/014/">Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</a></li><li><a href="https://www.itbob.cn/article/015/">Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/016/">Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/017/">Python 数据分析三剑客之 Matplotlib（四）：线性图的绘制</a></li><li><a href="https://www.itbob.cn/article/018/">Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制</a></li><li><a href="https://www.itbob.cn/article/019/">Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制</a></li><li><a href="https://www.itbob.cn/article/020/">Python 数据分析三剑客之 Matplotlib（七）：饼状图的绘制</a></li><li><a href="https://www.itbob.cn/article/021/">Python 数据分析三剑客之 Matplotlib（八）：等高线 / 等值线图的绘制</a></li><li><a href="https://www.itbob.cn/article/022/">Python 数据分析三剑客之 Matplotlib（九）：极区图 / 极坐标图 / 雷达图的绘制</a></li><li><a href="https://www.itbob.cn/article/023/">Python 数据分析三剑客之 Matplotlib（十）：3D 图的绘制</a></li><li><a href="https://www.itbob.cn/article/024/">Python 数据分析三剑客之 Matplotlib（十一）：最热门最常用的 50 个图表</a>【译文】</li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><blockquote><p>翻译丨<a href="https://itrhx.blog.csdn.net/">TRHX</a><br>作者丨<a href="https://www.machinelearningplus.com/author/selva86/">Selva Prabhakaran</a><br>原文丨<a href="https://www.machinelearningplus.com/plots/top-50-matplotlib-visualizations-the-master-plots-python/">《Top 50 matplotlib Visualizations – The Master Plots (with full python code)》</a></p></blockquote><hr><blockquote><p>★ 本文中的示例原作者使用的编辑器为 Jupyter Notebook；<br>★ 译者使用 PyCharm 测试原文中有部分代码不太准确，部分已进行修改，对应有注释说明；<br>★ 运行本文代码，需要安装 Matplotlib 和 Seaborn 等可视化库，其他的一些辅助可视化库已在代码部分作标注；<br>★ 示例中用到的数据均储存在作者的 GitHub：<a href="https://github.com/selva86/datasets">https://github.com/selva86/datasets</a>，因此运行程序可能需要FQ；<br>★ 译者英文水平有限，若遇到翻译模糊的词建议参考原文来理解。<br>★ 本文50个示例代码已打包为 .py 文件，可直接下载：<a href="https://download.csdn.net/download/qq_36759224/12507219">https://download.csdn.net/download/qq_36759224/12507219</a></p></blockquote><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本译文首发于 CSDN，作者 Selva Prabhakaran，译者 TRHX。本文链接：https://itrhx.blog.csdn.net/article/details/106558131原文链接：https://www.machinelearningplus.com/plots/top-50-matplotlib-visualizations-the-master-plots-python/</code></pre><hr><h2 id="【1x00】介绍（Introduction）"><a href="#【1x00】介绍（Introduction）" class="headerlink" title="【1x00】介绍（Introduction）"></a><font color=#FF0000>【1x00】介绍（Introduction）</font></h2><p>在数据分析和可视化中最常用的、最有价值的前 50 个 Matplotlib 图表。这些图表会让你懂得在不同情况下合理使用 Python 的 Matplotlib 和 Seaborn 库来达到数据可视化效果。</p><p>这些图表根据可视化目标的 7 个不同情景进行分组。 例如，如果要想象两个变量之间的关系，请查看“关联”部分下的图表。 或者，如果您想要显示值如何随时间变化，请查看“变化”部分，依此类推。</p><p>有效图表的重要特征：</p><ul><li>在不歪曲事实的情况下传达正确和必要的信息；</li><li>设计简单，不必太费力就能理解它；</li><li>从审美角度支持信息而不是掩盖信息；</li><li>信息没有超负荷。</li></ul><h2 id="【2x00】准备工作（Setup）"><a href="#【2x00】准备工作（Setup）" class="headerlink" title="【2x00】准备工作（Setup）"></a><font color=#FF0000>【2x00】准备工作（Setup）</font></h2><p>在代码运行前先引入下面的基本设置，当然，个别图表可能会重新定义显示要素。</p><pre><code class="python"># !pip install brewer2mplimport numpy as npimport pandas as pdimport matplotlib as mplimport matplotlib.pyplot as pltimport seaborn as snsimport warnings; warnings.filterwarnings(action=&#39;once&#39;)large = 22; med = 16; small = 12params = &#123;&#39;axes.titlesize&#39;: large,          &#39;legend.fontsize&#39;: med,          &#39;figure.figsize&#39;: (16, 10),          &#39;axes.labelsize&#39;: med,          &#39;axes.titlesize&#39;: med,          &#39;xtick.labelsize&#39;: med,          &#39;ytick.labelsize&#39;: med,          &#39;figure.titlesize&#39;: large&#125;plt.rcParams.update(params)plt.style.use(&#39;seaborn-whitegrid&#39;)sns.set_style(&quot;white&quot;)%matplotlib inline# Versionprint(mpl.__version__)  #&gt; 3.0.0print(sns.__version__)  #&gt; 0.9.0</code></pre><h2 id="【3x00】关联（Correlation）"><a href="#【3x00】关联（Correlation）" class="headerlink" title="【3x00】关联（Correlation） "></a><font color=#FF0000>【3x00】关联（Correlation） </font></h2><p>关联图用于可视化两个或多个变量之间的关系。也就是说，一个变量相对于另一个变量如何变化。</p><h3 id="【01】散点图（Scatter-plot）"><a href="#【01】散点图（Scatter-plot）" class="headerlink" title="【01】散点图（Scatter plot）"></a><font color=##4876FF>【01】散点图（Scatter plot）</font></h3><p>散点图是研究两个变量之间关系的经典和基本的绘图。如果数据中有多个组，则可能需要以不同的颜色显示每个组。在 Matplotlib 中，您可以使用 <code>plt.scatterplot()</code> 方便地执行此操作。</p><pre><code class="python"># Import dataset midwest = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/midwest_filter.csv&quot;)# Prepare Data # Create as many colors as there are unique midwest[&#39;category&#39;]categories = np.unique(midwest[&#39;category&#39;])colors = [plt.cm.tab10(i/float(len(categories)-1)) for i in range(len(categories))]# Draw Plot for Each Categoryplt.figure(figsize=(16, 10), dpi= 80, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)for i, category in enumerate(categories):    plt.scatter(&#39;area&#39;, &#39;poptotal&#39;,                data=midwest.loc[midwest.category==category, :],                s=20, cmap=colors[i], label=str(category))# 原文 c=colors[i] 已修改为 cmap=colors[i]# Decorationsplt.gca().set(xlim=(0.0, 0.1), ylim=(0, 90000),              xlabel=&#39;Area&#39;, ylabel=&#39;Population&#39;)plt.xticks(fontsize=12); plt.yticks(fontsize=12)plt.title(&quot;Scatterplot of Midwest Area vs Population&quot;, fontsize=22)plt.legend(fontsize=12)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/01.png" alt="01"></p><h3 id="【02】带边界的气泡图（Bubble-plot-with-Encircling）"><a href="#【02】带边界的气泡图（Bubble-plot-with-Encircling）" class="headerlink" title="【02】带边界的气泡图（Bubble plot with Encircling）"></a><font color=##4876FF>【02】带边界的气泡图（Bubble plot with Encircling）</font></h3><p>有时候您想在一个边界内显示一组点来强调它们的重要性。在本例中，您将从被包围的数据中获取记录，并将其传递给下面的代码中描述的 <code>encircle()</code>。</p><pre><code class="python">from matplotlib import patchesfrom scipy.spatial import ConvexHullimport warnings; warnings.simplefilter(&#39;ignore&#39;)sns.set_style(&quot;white&quot;)# Step 1: Prepare Datamidwest = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/midwest_filter.csv&quot;)# As many colors as there are unique midwest[&#39;category&#39;]categories = np.unique(midwest[&#39;category&#39;])colors = [plt.cm.tab10(i/float(len(categories)-1)) for i in range(len(categories))]# Step 2: Draw Scatterplot with unique color for each categoryfig = plt.figure(figsize=(16, 10), dpi=80, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)for i, category in enumerate(categories):    plt.scatter(&#39;area&#39;, &#39;poptotal&#39;, data=midwest.loc[midwest.category == category, :], s=&#39;dot_size&#39;, cmap=colors[i], label=str(category), edgecolors=&#39;black&#39;, linewidths=.5)# 原文 c=colors[i] 已修改为 cmap=colors[i]# Step 3: Encircling# https://stackoverflow.com/questions/44575681/how-do-i-encircle-different-data-sets-in-scatter-plotdef encircle(x,y, ax=None, **kw):    if not ax: ax = plt.gca()    p = np.c_[x, y]    hull = ConvexHull(p)    poly = plt.Polygon(p[hull.vertices, :], **kw)    ax.add_patch(poly)# Select data to be encircledmidwest_encircle_data = midwest.loc[midwest.state==&#39;IN&#39;, :]# Draw polygon surrounding verticesencircle(midwest_encircle_data.area, midwest_encircle_data.poptotal, ec=&quot;k&quot;, fc=&quot;gold&quot;, alpha=0.1)encircle(midwest_encircle_data.area, midwest_encircle_data.poptotal, ec=&quot;firebrick&quot;, fc=&quot;none&quot;, linewidth=1.5)# Step 4: Decorationsplt.gca().set(xlim=(0.0, 0.1), ylim=(0, 90000),              xlabel=&#39;Area&#39;, ylabel=&#39;Population&#39;)plt.xticks(fontsize=12); plt.yticks(fontsize=12)plt.title(&quot;Bubble Plot with Encircling&quot;, fontsize=22)plt.legend(fontsize=12)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/02.png" alt="02"></p><h3 id="【03】带线性回归最佳拟合线的散点图（Scatter-plot-with-linear-regression-line-of-best-fit）"><a href="#【03】带线性回归最佳拟合线的散点图（Scatter-plot-with-linear-regression-line-of-best-fit）" class="headerlink" title="【03】带线性回归最佳拟合线的散点图（Scatter plot with linear regression line of best fit）"></a><font color=##4876FF>【03】带线性回归最佳拟合线的散点图（Scatter plot with linear regression line of best fit）</font></h3><p>如果你想了解两个变量之间是如何变化的，那么最佳拟合线就是常用的方法。下图显示了数据中不同组之间的最佳拟合线的差异。若要禁用分组并只为整个数据集绘制一条最佳拟合线，请从 <code>sns.lmplot()</code> 方法中删除 <code>hue =&#39;cyl&#39;</code> 参数。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/mpg_ggplot2.csv&quot;)df_select = df.loc[df.cyl.isin([4, 8]), :]# Plotsns.set_style(&quot;white&quot;)gridobj = sns.lmplot(x=&quot;displ&quot;, y=&quot;hwy&quot;, hue=&quot;cyl&quot;, data=df_select,                     height=7, aspect=1.6, robust=True, palette=&#39;tab10&#39;,                     scatter_kws=dict(s=60, linewidths=.7, edgecolors=&#39;black&#39;))# Decorationsgridobj.set(xlim=(0.5, 7.5), ylim=(0, 50))plt.title(&quot;Scatterplot with line of best fit grouped by number of cylinders&quot;, fontsize=20)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/03.png" alt="03"></p><p>针对每一组数据绘制线性回归线（Each regression line in its own column），可以通过在 <code>sns.lmplot()</code> 中设置 <code>col=groupingcolumn</code> 参数来实现，如下：</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/mpg_ggplot2.csv&quot;)df_select = df.loc[df.cyl.isin([4, 8]), :]# Each line in its own columnsns.set_style(&quot;white&quot;)gridobj = sns.lmplot(x=&quot;displ&quot;, y=&quot;hwy&quot;,                     data=df_select,                     height=7,                     robust=True,                     palette=&#39;Set1&#39;,                     col=&quot;cyl&quot;,                     scatter_kws=dict(s=60, linewidths=.7, edgecolors=&#39;black&#39;))# Decorationsgridobj.set(xlim=(0.5, 7.5), ylim=(0, 50))plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/04.png" alt="04"></p><h3 id="【04】抖动图（Jittering-with-stripplot）"><a href="#【04】抖动图（Jittering-with-stripplot）" class="headerlink" title="【04】抖动图（Jittering with stripplot）"></a><font color=##4876FF>【04】抖动图（Jittering with stripplot）</font></h3><p>通常，多个数据点具有完全相同的 X 和 Y 值。 此时多个点绘制会重叠并隐藏。为避免这种情况，可以将数据点稍微抖动，以便可以直观地看到它们。 使用 <code>seaborn</code> 库的 <code>stripplot()</code> 方法可以很方便的实现这个功能。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/mpg_ggplot2.csv&quot;)# Draw Stripplotfig, ax = plt.subplots(figsize=(16,10), dpi= 80)sns.stripplot(df.cty, df.hwy, jitter=0.25, size=8, ax=ax, linewidth=.5)# Decorationsplt.title(&#39;Use jittered plots to avoid overlapping of points&#39;, fontsize=22)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/05.png" alt="05"></p><h3 id="【05】计数图（Counts-Plot）"><a href="#【05】计数图（Counts-Plot）" class="headerlink" title="【05】计数图（Counts Plot）"></a><font color=##4876FF>【05】计数图（Counts Plot）</font></h3><p>避免点重叠问题的另一个选择是根据点的位置增加点的大小。所以，点的大小越大，它周围的点就越集中。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/mpg_ggplot2.csv&quot;)df_counts = df.groupby([&#39;hwy&#39;, &#39;cty&#39;]).size().reset_index(name=&#39;counts&#39;)# Draw Stripplotfig, ax = plt.subplots(figsize=(16,10), dpi= 80)    # 原文代码# sns.stripplot(df_counts.cty, df_counts.hwy, size=df_counts.counts*2, ax=ax)# 纠正代码sns.stripplot(df_counts.cty, df_counts.hwy, sizes=df_counts.counts*2, ax=ax)# Decorationsplt.title(&#39;Counts Plot - Size of circle is bigger as more points overlap&#39;, fontsize=22)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/06.png" alt="06"></p><h3 id="【06】边缘直方图（Marginal-Histogram）"><a href="#【06】边缘直方图（Marginal-Histogram）" class="headerlink" title="【06】边缘直方图（Marginal Histogram）"></a><font color=##4876FF>【06】边缘直方图（Marginal Histogram）</font></h3><p>边缘直方图是具有沿 X 和 Y 轴变量的直方图。 这用于可视化 X 和 Y 之间的关系以及单独的 X 和 Y 的单变量分布。 这种图经常用于探索性数据分析（EDA）。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/mpg_ggplot2.csv&quot;)# Create Fig and gridspecfig = plt.figure(figsize=(16, 10), dpi= 80)grid = plt.GridSpec(4, 4, hspace=0.5, wspace=0.2)# Define the axesax_main = fig.add_subplot(grid[:-1, :-1])ax_right = fig.add_subplot(grid[:-1, -1], xticklabels=[], yticklabels=[])ax_bottom = fig.add_subplot(grid[-1, 0:-1], xticklabels=[], yticklabels=[])# Scatterplot on main axax_main.scatter(&#39;displ&#39;, &#39;hwy&#39;, s=df.cty*4, c=df.manufacturer.astype(&#39;category&#39;).cat.codes, alpha=.9, data=df, cmap=&quot;tab10&quot;, edgecolors=&#39;gray&#39;, linewidths=.5)# histogram on the rightax_bottom.hist(df.displ, 40, histtype=&#39;stepfilled&#39;, orientation=&#39;vertical&#39;, color=&#39;deeppink&#39;)ax_bottom.invert_yaxis()# histogram in the bottomax_right.hist(df.hwy, 40, histtype=&#39;stepfilled&#39;, orientation=&#39;horizontal&#39;, color=&#39;deeppink&#39;)# Decorationsax_main.set(title=&#39;Scatterplot with Histograms \n displ vs hwy&#39;, xlabel=&#39;displ&#39;, ylabel=&#39;hwy&#39;)ax_main.title.set_fontsize(20)for item in ([ax_main.xaxis.label, ax_main.yaxis.label] + ax_main.get_xticklabels() + ax_main.get_yticklabels()):    item.set_fontsize(14)xlabels = ax_main.get_xticks().tolist()ax_main.set_xticklabels(xlabels)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/07.png" alt="07"></p><h3 id="【07】边缘箱形图（Marginal-Boxplot）"><a href="#【07】边缘箱形图（Marginal-Boxplot）" class="headerlink" title="【07】边缘箱形图（Marginal Boxplot）"></a><font color=##4876FF>【07】边缘箱形图（Marginal Boxplot）</font></h3><p>边缘箱形图与边缘直方图具有相似的用途。 然而，箱线图有助于精确定位 X 和 Y 的中位数、第25和第75百分位数。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/mpg_ggplot2.csv&quot;)# Create Fig and gridspecfig = plt.figure(figsize=(16, 10), dpi= 80)grid = plt.GridSpec(4, 4, hspace=0.5, wspace=0.2)# Define the axesax_main = fig.add_subplot(grid[:-1, :-1])ax_right = fig.add_subplot(grid[:-1, -1], xticklabels=[], yticklabels=[])ax_bottom = fig.add_subplot(grid[-1, 0:-1], xticklabels=[], yticklabels=[])# Scatterplot on main axax_main.scatter(&#39;displ&#39;, &#39;hwy&#39;, s=df.cty*5, c=df.manufacturer.astype(&#39;category&#39;).cat.codes, alpha=.9, data=df, cmap=&quot;Set1&quot;, edgecolors=&#39;black&#39;, linewidths=.5)# Add a graph in each partsns.boxplot(df.hwy, ax=ax_right, orient=&quot;v&quot;)sns.boxplot(df.displ, ax=ax_bottom, orient=&quot;h&quot;)# Decorations ------------------# Remove x axis name for the boxplotax_bottom.set(xlabel=&#39;&#39;)ax_right.set(ylabel=&#39;&#39;)# Main Title, Xlabel and YLabelax_main.set(title=&#39;Scatterplot with Histograms \n displ vs hwy&#39;, xlabel=&#39;displ&#39;, ylabel=&#39;hwy&#39;)# Set font size of different componentsax_main.title.set_fontsize(20)for item in ([ax_main.xaxis.label, ax_main.yaxis.label] + ax_main.get_xticklabels() + ax_main.get_yticklabels()):    item.set_fontsize(14)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/08.png" alt="08"></p><h3 id="【08】相关图（Correllogram）"><a href="#【08】相关图（Correllogram）" class="headerlink" title="【08】相关图（Correllogram）"></a><font color=##4876FF>【08】相关图（Correllogram）</font></h3><p>相关图用于直观地查看给定数据帧（或二维数组）中所有可能的数值变量对之间的相关性度量。</p><pre><code class="python"># Import Datasetdf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mtcars.csv&quot;)# Plotplt.figure(figsize=(12, 10), dpi=80)sns.heatmap(df.corr(), xticklabels=df.corr().columns, yticklabels=df.corr().columns, cmap=&#39;RdYlGn&#39;, center=0, annot=True)# Decorationsplt.title(&#39;Correlogram of mtcars&#39;, fontsize=22)plt.xticks(fontsize=12)plt.yticks(fontsize=12)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/09.png" alt="09"></p><h3 id="【09】成对图（Pairwise-Plot）"><a href="#【09】成对图（Pairwise-Plot）" class="headerlink" title="【09】成对图（Pairwise Plot）"></a><font color=##4876FF>【09】成对图（Pairwise Plot）</font></h3><p>成对图是探索性分析中最受欢迎的一种方法，用来理解所有可能的数值变量对之间的关系。它是二元分析的必备工具。</p><pre><code class="python"># Load Datasetdf = sns.load_dataset(&#39;iris&#39;)# Plotplt.figure(figsize=(10, 8), dpi=80)sns.pairplot(df, kind=&quot;scatter&quot;, hue=&quot;species&quot;, plot_kws=dict(s=80, edgecolor=&quot;white&quot;, linewidth=2.5))plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/10.png" alt="10"></p><pre><code class="python"># Load Datasetdf = sns.load_dataset(&#39;iris&#39;)# Plotplt.figure(figsize=(10, 8), dpi=80)sns.pairplot(df, kind=&quot;reg&quot;, hue=&quot;species&quot;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/11.png" alt="11"></p><h2 id="【4x00】偏差（Deviation）"><a href="#【4x00】偏差（Deviation）" class="headerlink" title="【4x00】偏差（Deviation）"></a><font color=#FF0000>【4x00】偏差（Deviation）</font></h2><h3 id="【10】发散型条形图（Diverging-Bars）"><a href="#【10】发散型条形图（Diverging-Bars）" class="headerlink" title="【10】发散型条形图（Diverging Bars）"></a><font color=##4876FF>【10】发散型条形图（Diverging Bars）</font></h3><p>如果您想根据单个指标查看项目的变化情况，并可视化此差异的顺序和数量，那么散型条形图是一个很好的工具。 它有助于快速区分数据组的性能，并且非常直观，并且可以立即传达这一点。</p><pre><code class="python"># Prepare Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mtcars.csv&quot;)x = df.loc[:, [&#39;mpg&#39;]]df[&#39;mpg_z&#39;] = (x - x.mean())/x.std()df[&#39;colors&#39;] = [&#39;red&#39; if x &lt; 0 else &#39;green&#39; for x in df[&#39;mpg_z&#39;]]df.sort_values(&#39;mpg_z&#39;, inplace=True)df.reset_index(inplace=True)# Draw plotplt.figure(figsize=(14,10), dpi= 80)plt.hlines(y=df.index, xmin=0, xmax=df.mpg_z, color=df.colors, alpha=0.4, linewidth=5)# Decorationsplt.gca().set(ylabel=&#39;$Model$&#39;, xlabel=&#39;$Mileage$&#39;)plt.yticks(df.index, df.cars, fontsize=12)plt.title(&#39;Diverging Bars of Car Mileage&#39;, fontdict=&#123;&#39;size&#39;:20&#125;)plt.grid(linestyle=&#39;--&#39;, alpha=0.5)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/12.png" alt="12"></p><h3 id="【11】发散型文本图（Diverging-Texts）"><a href="#【11】发散型文本图（Diverging-Texts）" class="headerlink" title="【11】发散型文本图（Diverging Texts）"></a><font color=##4876FF>【11】发散型文本图（Diverging Texts）</font></h3><p>发散型文本图与发散型条形图相似，如果你希望以一种美观的方式显示图表中每个项目的值，就可以使用这种方法。</p><pre><code class="python"># Prepare Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mtcars.csv&quot;)x = df.loc[:, [&#39;mpg&#39;]]df[&#39;mpg_z&#39;] = (x - x.mean())/x.std()df[&#39;colors&#39;] = [&#39;red&#39; if x &lt; 0 else &#39;green&#39; for x in df[&#39;mpg_z&#39;]]df.sort_values(&#39;mpg_z&#39;, inplace=True)df.reset_index(inplace=True)# Draw plotplt.figure(figsize=(14, 14), dpi=80)plt.hlines(y=df.index, xmin=0, xmax=df.mpg_z)for x, y, tex in zip(df.mpg_z, df.index, df.mpg_z):    t = plt.text(x, y, round(tex, 2), horizontalalignment=&#39;right&#39; if x &lt; 0 else &#39;left&#39;,                 verticalalignment=&#39;center&#39;, fontdict=&#123;&#39;color&#39;:&#39;red&#39; if x &lt; 0 else &#39;green&#39;, &#39;size&#39;:14&#125;)# Decorationsplt.yticks(df.index, df.cars, fontsize=12)plt.title(&#39;Diverging Text Bars of Car Mileage&#39;, fontdict=&#123;&#39;size&#39;:20&#125;)plt.grid(linestyle=&#39;--&#39;, alpha=0.5)plt.xlim(-2.5, 2.5)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/13.png" alt="13"></p><h3 id="【12】发散型散点图（Diverging-Dot-Plot）"><a href="#【12】发散型散点图（Diverging-Dot-Plot）" class="headerlink" title="【12】发散型散点图（Diverging Dot Plot）"></a><font color=##4876FF>【12】发散型散点图（Diverging Dot Plot）</font></h3><p>发散型散点图类似于发散型条形图。 但是，与发散型条形图相比，没有条形会减少组之间的对比度和差异。</p><pre><code class="python"># Prepare Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mtcars.csv&quot;)x = df.loc[:, [&#39;mpg&#39;]]df[&#39;mpg_z&#39;] = (x - x.mean())/x.std()df[&#39;colors&#39;] = [&#39;red&#39; if x &lt; 0 else &#39;darkgreen&#39; for x in df[&#39;mpg_z&#39;]]df.sort_values(&#39;mpg_z&#39;, inplace=True)df.reset_index(inplace=True)# Draw plotplt.figure(figsize=(14, 16), dpi=80)plt.scatter(df.mpg_z, df.index, s=450, alpha=.6, color=df.colors)for x, y, tex in zip(df.mpg_z, df.index, df.mpg_z):    t = plt.text(x, y, round(tex, 1), horizontalalignment=&#39;center&#39;,                 verticalalignment=&#39;center&#39;, fontdict=&#123;&#39;color&#39;: &#39;white&#39;&#125;)# Decorations# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(.3)plt.gca().spines[&quot;bottom&quot;].set_alpha(.3)plt.gca().spines[&quot;right&quot;].set_alpha(.3)plt.gca().spines[&quot;left&quot;].set_alpha(.3)plt.yticks(df.index, df.cars)plt.title(&#39;Diverging Dotplot of Car Mileage&#39;, fontdict=&#123;&#39;size&#39;: 20&#125;)plt.xlabel(&#39;$Mileage$&#39;)plt.grid(linestyle=&#39;--&#39;, alpha=0.5)plt.xlim(-2.5, 2.5)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/14.png" alt="14"></p><h3 id="【13】带标记的发散型棒棒糖图（Diverging-Lollipop-Chart-with-Markers）"><a href="#【13】带标记的发散型棒棒糖图（Diverging-Lollipop-Chart-with-Markers）" class="headerlink" title="【13】带标记的发散型棒棒糖图（Diverging Lollipop Chart with Markers）"></a><font color=##4876FF>【13】带标记的发散型棒棒糖图（Diverging Lollipop Chart with Markers）</font></h3><p>带有标记的棒棒糖提供了一种灵活的方式，强调您想要引起注意的任何重要数据点并在图表中适当地给出推理。</p><pre><code class="python"># Prepare Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mtcars.csv&quot;)x = df.loc[:, [&#39;mpg&#39;]]df[&#39;mpg_z&#39;] = (x - x.mean())/x.std()df[&#39;colors&#39;] = &#39;black&#39;# color fiat differentlydf.loc[df.cars == &#39;Fiat X1-9&#39;, &#39;colors&#39;] = &#39;darkorange&#39;df.sort_values(&#39;mpg_z&#39;, inplace=True)df.reset_index(inplace=True)# Draw plotimport matplotlib.patches as patchesplt.figure(figsize=(14, 16), dpi=80)plt.hlines(y=df.index, xmin=0, xmax=df.mpg_z, color=df.colors, alpha=0.4, linewidth=1)plt.scatter(df.mpg_z, df.index, color=df.colors, s=[600 if x == &#39;Fiat X1-9&#39; else 300 for x in df.cars], alpha=0.6)plt.yticks(df.index, df.cars)plt.xticks(fontsize=12)# Annotateplt.annotate(&#39;Mercedes Models&#39;, xy=(0.0, 11.0), xytext=(1.0, 11), xycoords=&#39;data&#39;,            fontsize=15, ha=&#39;center&#39;, va=&#39;center&#39;,            bbox=dict(boxstyle=&#39;square&#39;, fc=&#39;firebrick&#39;),            arrowprops=dict(arrowstyle=&#39;-[, widthB=2.0, lengthB=1.5&#39;, lw=2.0, color=&#39;steelblue&#39;), color=&#39;white&#39;)# Add Patchesp1 = patches.Rectangle((-2.0, -1), width=.3, height=3, alpha=.2, facecolor=&#39;red&#39;)p2 = patches.Rectangle((1.5, 27), width=.8, height=5, alpha=.2, facecolor=&#39;green&#39;)plt.gca().add_patch(p1)plt.gca().add_patch(p2)# Decorateplt.title(&#39;Diverging Bars of Car Mileage&#39;, fontdict=&#123;&#39;size&#39;: 20&#125;)plt.grid(linestyle=&#39;--&#39;, alpha=0.5)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/15.png" alt="15"></p><h3 id="【14】面积图（Area-Chart）"><a href="#【14】面积图（Area-Chart）" class="headerlink" title="【14】面积图（Area Chart）"></a><font color=##4876FF>【14】面积图（Area Chart）</font></h3><p>通过对轴和线之间的区域进行着色，面积图不仅强调波峰和波谷，还强调波峰和波谷的持续时间。 高点持续时间越长，线下面积越大。</p><pre><code class="python">import numpy as npimport pandas as pd# Prepare Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/economics.csv&quot;, parse_dates=[&#39;date&#39;]).head(100)x = np.arange(df.shape[0])y_returns = (df.psavert.diff().fillna(0)/df.psavert.shift(1)).fillna(0) * 100# Plotplt.figure(figsize=(16, 10), dpi=80)plt.fill_between(x[1:], y_returns[1:], 0, where=y_returns[1:] &gt;= 0, facecolor=&#39;green&#39;, interpolate=True, alpha=0.7)plt.fill_between(x[1:], y_returns[1:], 0, where=y_returns[1:] &lt;= 0, facecolor=&#39;red&#39;, interpolate=True, alpha=0.7)# Annotateplt.annotate(&#39;Peak \n1975&#39;, xy=(94.0, 21.0), xytext=(88.0, 28),             bbox=dict(boxstyle=&#39;square&#39;, fc=&#39;firebrick&#39;),             arrowprops=dict(facecolor=&#39;steelblue&#39;, shrink=0.05), fontsize=15, color=&#39;white&#39;)# Decorationsxtickvals = [str(m)[:3].upper()+&quot;-&quot;+str(y) for y, m in zip(df.date.dt.year, df.date.dt.month_name())]plt.gca().set_xticks(x[::6])plt.gca().set_xticklabels(xtickvals[::6], rotation=90, fontdict=&#123;&#39;horizontalalignment&#39;: &#39;center&#39;, &#39;verticalalignment&#39;: &#39;center_baseline&#39;&#125;)plt.ylim(-35, 35)plt.xlim(1, 100)plt.title(&quot;Month Economics Return %&quot;, fontsize=22)plt.ylabel(&#39;Monthly returns %&#39;)plt.grid(alpha=0.5)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/16.png" alt="16"></p><h2 id="【5x00】排序（Ranking）"><a href="#【5x00】排序（Ranking）" class="headerlink" title="【5x00】排序（Ranking）"></a><font color=#FF0000>【5x00】排序（Ranking）</font></h2><h3 id="【15】有序条形图（Ordered-Bar-Chart）"><a href="#【15】有序条形图（Ordered-Bar-Chart）" class="headerlink" title="【15】有序条形图（Ordered Bar Chart）"></a><font color=##4876FF>【15】有序条形图（Ordered Bar Chart）</font></h3><p>有序条形图有效地传达了项目的排序顺序。在图表上方添加度量标准的值，用户就可以从图表本身获得精确的信息。</p><pre><code class="python"># Prepare Datadf_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)df = df_raw[[&#39;cty&#39;, &#39;manufacturer&#39;]].groupby(&#39;manufacturer&#39;).apply(lambda x: x.mean())df.sort_values(&#39;cty&#39;, inplace=True)df.reset_index(inplace=True)# Draw plotimport matplotlib.patches as patchesfig, ax = plt.subplots(figsize=(16,10), facecolor=&#39;white&#39;, dpi= 80)ax.vlines(x=df.index, ymin=0, ymax=df.cty, color=&#39;firebrick&#39;, alpha=0.7, linewidth=20)# Annotate Textfor i, cty in enumerate(df.cty):    ax.text(i, cty+0.5, round(cty, 1), horizontalalignment=&#39;center&#39;)# Title, Label, Ticks and Ylimax.set_title(&#39;Bar Chart for Highway Mileage&#39;, fontdict=&#123;&#39;size&#39;:22&#125;)ax.set(ylabel=&#39;Miles Per Gallon&#39;, ylim=(0, 30))plt.xticks(df.index, df.manufacturer.str.upper(), rotation=60, horizontalalignment=&#39;right&#39;, fontsize=12)# Add patches to color the X axis labelsp1 = patches.Rectangle((.57, -0.005), width=.33, height=.13, alpha=.1, facecolor=&#39;green&#39;, transform=fig.transFigure)p2 = patches.Rectangle((.124, -0.005), width=.446, height=.13, alpha=.1, facecolor=&#39;red&#39;, transform=fig.transFigure)fig.add_artist(p1)fig.add_artist(p2)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/17.png" alt="17"></p><h3 id="【16】棒棒糖图（Lollipop-Chart）"><a href="#【16】棒棒糖图（Lollipop-Chart）" class="headerlink" title="【16】棒棒糖图（Lollipop Chart）"></a><font color=##4876FF>【16】棒棒糖图（Lollipop Chart）</font></h3><p>棒棒糖图表以一种视觉上令人愉悦的方式提供与有序条形图类似的目的。</p><pre><code class="python"># Prepare Datadf_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)df = df_raw[[&#39;cty&#39;, &#39;manufacturer&#39;]].groupby(&#39;manufacturer&#39;).apply(lambda x: x.mean())df.sort_values(&#39;cty&#39;, inplace=True)df.reset_index(inplace=True)# Draw plotfig, ax = plt.subplots(figsize=(16, 10), dpi=80)ax.vlines(x=df.index, ymin=0, ymax=df.cty, color=&#39;firebrick&#39;, alpha=0.7, linewidth=2)ax.scatter(x=df.index, y=df.cty, s=75, color=&#39;firebrick&#39;, alpha=0.7)# Title, Label, Ticks and Ylimax.set_title(&#39;Lollipop Chart for Highway Mileage&#39;, fontdict=&#123;&#39;size&#39;: 22&#125;)ax.set_ylabel(&#39;Miles Per Gallon&#39;)ax.set_xticks(df.index)ax.set_xticklabels(df.manufacturer.str.upper(), rotation=60, fontdict=&#123;&#39;horizontalalignment&#39;: &#39;right&#39;, &#39;size&#39;: 12&#125;)ax.set_ylim(0, 30)# Annotatefor row in df.itertuples():    ax.text(row.Index, row.cty+.5, s=round(row.cty, 2), horizontalalignment=&#39;center&#39;, verticalalignment=&#39;bottom&#39;, fontsize=14)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/18.png" alt="18"></p><h3 id="【17】点图（Dot-Plot）"><a href="#【17】点图（Dot-Plot）" class="headerlink" title="【17】点图（Dot Plot）"></a><font color=##4876FF>【17】点图（Dot Plot）</font></h3><p>点图可以表示项目的排名顺序。由于它是沿水平轴对齐的，所以可以更容易地看到点之间的距离。</p><pre><code class="python"># Prepare Datadf_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)df = df_raw[[&#39;cty&#39;, &#39;manufacturer&#39;]].groupby(&#39;manufacturer&#39;).apply(lambda x: x.mean())df.sort_values(&#39;cty&#39;, inplace=True)df.reset_index(inplace=True)# Draw plotfig, ax = plt.subplots(figsize=(16, 10), dpi=80)ax.hlines(y=df.index, xmin=11, xmax=26, color=&#39;gray&#39;, alpha=0.7, linewidth=1, linestyles=&#39;dashdot&#39;)ax.scatter(y=df.index, x=df.cty, s=75, color=&#39;firebrick&#39;, alpha=0.7)# Title, Label, Ticks and Ylimax.set_title(&#39;Dot Plot for Highway Mileage&#39;, fontdict=&#123;&#39;size&#39;: 22&#125;)ax.set_xlabel(&#39;Miles Per Gallon&#39;)ax.set_yticks(df.index)ax.set_yticklabels(df.manufacturer.str.title(), fontdict=&#123;&#39;horizontalalignment&#39;: &#39;right&#39;&#125;)ax.set_xlim(10, 27)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/19.png" alt="19"></p><h3 id="【18】坡度图（Slope-Chart）"><a href="#【18】坡度图（Slope-Chart）" class="headerlink" title="【18】坡度图（Slope Chart）"></a><font color=##4876FF>【18】坡度图（Slope Chart）</font></h3><p>坡度图最适合比较给定人员/项目的“前”和“后”位置。</p><pre><code class="python">import matplotlib.lines as mlines# Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/gdppercap.csv&quot;)left_label = [str(c) + &#39;, &#39; + str(round(y)) for c, y in zip(df.continent, df[&#39;1952&#39;])]right_label = [str(c) + &#39;, &#39; + str(round(y)) for c, y in zip(df.continent, df[&#39;1957&#39;])]klass = [&#39;red&#39; if (y1 - y2) &lt; 0 else &#39;green&#39; for y1, y2 in zip(df[&#39;1952&#39;], df[&#39;1957&#39;])]# draw line# https://stackoverflow.com/questions/36470343/how-to-draw-a-line-with-matplotlib/36479941def newline(p1, p2, color=&#39;black&#39;):    ax = plt.gca()    l = mlines.Line2D([p1[0], p2[0]], [p1[1], p2[1]], color=&#39;red&#39; if p1[1] - p2[1] &gt; 0 else &#39;green&#39;, marker=&#39;o&#39;,                      markersize=6)    ax.add_line(l)    return lfig, ax = plt.subplots(1, 1, figsize=(14, 14), dpi=80)# Vertical Linesax.vlines(x=1, ymin=500, ymax=13000, color=&#39;black&#39;, alpha=0.7, linewidth=1, linestyles=&#39;dotted&#39;)ax.vlines(x=3, ymin=500, ymax=13000, color=&#39;black&#39;, alpha=0.7, linewidth=1, linestyles=&#39;dotted&#39;)# Pointsax.scatter(y=df[&#39;1952&#39;], x=np.repeat(1, df.shape[0]), s=10, color=&#39;black&#39;, alpha=0.7)ax.scatter(y=df[&#39;1957&#39;], x=np.repeat(3, df.shape[0]), s=10, color=&#39;black&#39;, alpha=0.7)# Line Segmentsand Annotationfor p1, p2, c in zip(df[&#39;1952&#39;], df[&#39;1957&#39;], df[&#39;continent&#39;]):    newline([1, p1], [3, p2])    ax.text(1 - 0.05, p1, c + &#39;, &#39; + str(round(p1)), horizontalalignment=&#39;right&#39;, verticalalignment=&#39;center&#39;,            fontdict=&#123;&#39;size&#39;: 14&#125;)    ax.text(3 + 0.05, p2, c + &#39;, &#39; + str(round(p2)), horizontalalignment=&#39;left&#39;, verticalalignment=&#39;center&#39;,            fontdict=&#123;&#39;size&#39;: 14&#125;)# &#39;Before&#39; and &#39;After&#39; Annotationsax.text(1 - 0.05, 13000, &#39;BEFORE&#39;, horizontalalignment=&#39;right&#39;, verticalalignment=&#39;center&#39;,        fontdict=&#123;&#39;size&#39;: 18, &#39;weight&#39;: 700&#125;)ax.text(3 + 0.05, 13000, &#39;AFTER&#39;, horizontalalignment=&#39;left&#39;, verticalalignment=&#39;center&#39;,        fontdict=&#123;&#39;size&#39;: 18, &#39;weight&#39;: 700&#125;)# Decorationax.set_title(&quot;Slopechart: Comparing GDP Per Capita between 1952 vs 1957&quot;, fontdict=&#123;&#39;size&#39;: 22&#125;)ax.set(xlim=(0, 4), ylim=(0, 14000), ylabel=&#39;Mean GDP Per Capita&#39;)ax.set_xticks([1, 3])ax.set_xticklabels([&quot;1952&quot;, &quot;1957&quot;])plt.yticks(np.arange(500, 13000, 2000), fontsize=12)# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(.0)plt.gca().spines[&quot;bottom&quot;].set_alpha(.0)plt.gca().spines[&quot;right&quot;].set_alpha(.0)plt.gca().spines[&quot;left&quot;].set_alpha(.0)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/20.png" alt="20"></p><h3 id="【19】哑铃图（Dumbbell-Plot）"><a href="#【19】哑铃图（Dumbbell-Plot）" class="headerlink" title="【19】哑铃图（Dumbbell Plot）"></a><font color=##4876FF>【19】哑铃图（Dumbbell Plot）</font></h3><p>哑铃图传达了各种项目的“前”和“后”位置以及项目的等级顺序。如果您希望可视化特定项目/计划对不同对象的影响，那么它非常有用。</p><pre><code class="python">import matplotlib.lines as mlines# Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/health.csv&quot;)df.sort_values(&#39;pct_2014&#39;, inplace=True)df.reset_index(inplace=True)# Func to draw line segmentdef newline(p1, p2, color=&#39;black&#39;):    ax = plt.gca()    l = mlines.Line2D([p1[0], p2[0]], [p1[1], p2[1]], color=&#39;skyblue&#39;)    ax.add_line(l)    return l# Figure and Axesfig, ax = plt.subplots(1, 1, figsize=(14, 14), facecolor=&#39;#f7f7f7&#39;, dpi=80)# Vertical Linesax.vlines(x=.05, ymin=0, ymax=26, color=&#39;black&#39;, alpha=1, linewidth=1, linestyles=&#39;dotted&#39;)ax.vlines(x=.10, ymin=0, ymax=26, color=&#39;black&#39;, alpha=1, linewidth=1, linestyles=&#39;dotted&#39;)ax.vlines(x=.15, ymin=0, ymax=26, color=&#39;black&#39;, alpha=1, linewidth=1, linestyles=&#39;dotted&#39;)ax.vlines(x=.20, ymin=0, ymax=26, color=&#39;black&#39;, alpha=1, linewidth=1, linestyles=&#39;dotted&#39;)# Pointsax.scatter(y=df[&#39;index&#39;], x=df[&#39;pct_2013&#39;], s=50, color=&#39;#0e668b&#39;, alpha=0.7)ax.scatter(y=df[&#39;index&#39;], x=df[&#39;pct_2014&#39;], s=50, color=&#39;#a3c4dc&#39;, alpha=0.7)# Line Segmentsfor i, p1, p2 in zip(df[&#39;index&#39;], df[&#39;pct_2013&#39;], df[&#39;pct_2014&#39;]):    newline([p1, i], [p2, i])# Decorationax.set_facecolor(&#39;#f7f7f7&#39;)ax.set_title(&quot;Dumbell Chart: Pct Change - 2013 vs 2014&quot;, fontdict=&#123;&#39;size&#39;: 22&#125;)ax.set(xlim=(0, .25), ylim=(-1, 27), ylabel=&#39;Mean GDP Per Capita&#39;)ax.set_xticks([.05, .1, .15, .20])ax.set_xticklabels([&#39;5%&#39;, &#39;15%&#39;, &#39;20%&#39;, &#39;25%&#39;])ax.set_xticklabels([&#39;5%&#39;, &#39;15%&#39;, &#39;20%&#39;, &#39;25%&#39;])plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/21.png" alt="21"></p><h2 id="【6x00】分布（Distribution）"><a href="#【6x00】分布（Distribution）" class="headerlink" title="【6x00】分布（Distribution）"></a><font color=#FF0000>【6x00】分布（Distribution）</font></h2><h3 id="【20】连续变量的直方图（Histogram-for-Continuous-Variable）"><a href="#【20】连续变量的直方图（Histogram-for-Continuous-Variable）" class="headerlink" title="【20】连续变量的直方图（Histogram for Continuous Variable）"></a><font color=##4876FF>【20】连续变量的直方图（Histogram for Continuous Variable）</font></h3><p>连续变量的直方图显示给定变量的频率分布。下面的图表基于分类变量对频率条进行分组，从而更深入地了解连续变量和分类变量。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Prepare datax_var = &#39;displ&#39;groupby_var = &#39;class&#39;df_agg = df.loc[:, [x_var, groupby_var]].groupby(groupby_var)vals = [df[x_var].values.tolist() for i, df in df_agg]# Drawplt.figure(figsize=(16, 9), dpi=80)colors = [plt.cm.Spectral(i / float(len(vals) - 1)) for i in range(len(vals))]n, bins, patches = plt.hist(vals, 30, stacked=True, density=False, color=colors[:len(vals)])# Decorationplt.legend(&#123;group: col for group, col in zip(np.unique(df[groupby_var]).tolist(), colors[:len(vals)])&#125;)plt.title(f&quot;Stacked Histogram of $&#123;x_var&#125;$ colored by $&#123;groupby_var&#125;$&quot;, fontsize=22)plt.xlabel(x_var)plt.ylabel(&quot;Frequency&quot;)plt.ylim(0, 25)plt.xticks(ticks=bins[::3], labels=[round(b, 1) for b in bins[::3]])plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/22.png" alt="22"></p><h3 id="【21】分类变量的直方图（Histogram-for-Categorical-Variable）"><a href="#【21】分类变量的直方图（Histogram-for-Categorical-Variable）" class="headerlink" title="【21】分类变量的直方图（Histogram for Categorical Variable）"></a><font color=##4876FF>【21】分类变量的直方图（Histogram for Categorical Variable）</font></h3><p>分类变量的直方图显示该变量的频率分布。通过给条形图上色，您可以将分布与表示颜色的另一个类型变量相关联。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Prepare datax_var = &#39;manufacturer&#39;groupby_var = &#39;class&#39;df_agg = df.loc[:, [x_var, groupby_var]].groupby(groupby_var)vals = [df[x_var].values.tolist() for i, df in df_agg]# Drawplt.figure(figsize=(16, 9), dpi=80)colors = [plt.cm.Spectral(i / float(len(vals) - 1)) for i in range(len(vals))]n, bins, patches = plt.hist(vals, df[x_var].unique().__len__(), stacked=True, density=False, color=colors[:len(vals)])# Decorationplt.legend(&#123;group: col for group, col in zip(np.unique(df[groupby_var]).tolist(), colors[:len(vals)])&#125;)plt.title(f&quot;Stacked Histogram of $&#123;x_var&#125;$ colored by $&#123;groupby_var&#125;$&quot;, fontsize=22)plt.xlabel(x_var)plt.ylabel(&quot;Frequency&quot;)plt.ylim(0, 40)plt.xticks(ticks=bins, labels=np.unique(df[x_var]).tolist(), rotation=90, horizontalalignment=&#39;left&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/23.png" alt="23"></p><h3 id="【22】密度图（Density-Plot）"><a href="#【22】密度图（Density-Plot）" class="headerlink" title="【22】密度图（Density Plot）"></a><font color=##4876FF>【22】密度图（Density Plot）</font></h3><p>密度图是连续变量分布可视化的常用工具。通过按“response”变量对它们进行分组，您可以检查 X 和 Y 之间的关系。如果出于代表性目的来描述城市里程分布如何随气缸数而变化，请参见下面的情况。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Draw Plotplt.figure(figsize=(16, 10), dpi=80)sns.kdeplot(df.loc[df[&#39;cyl&#39;] == 4, &quot;cty&quot;], shade=True, color=&quot;g&quot;, label=&quot;Cyl=4&quot;, alpha=.7)sns.kdeplot(df.loc[df[&#39;cyl&#39;] == 5, &quot;cty&quot;], shade=True, color=&quot;deeppink&quot;, label=&quot;Cyl=5&quot;, alpha=.7)sns.kdeplot(df.loc[df[&#39;cyl&#39;] == 6, &quot;cty&quot;], shade=True, color=&quot;dodgerblue&quot;, label=&quot;Cyl=6&quot;, alpha=.7)sns.kdeplot(df.loc[df[&#39;cyl&#39;] == 8, &quot;cty&quot;], shade=True, color=&quot;orange&quot;, label=&quot;Cyl=8&quot;, alpha=.7)# Decorationplt.title(&#39;Density Plot of City Mileage by n_Cylinders&#39;, fontsize=22)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/24.png" alt="24"></p><h3 id="【23】直方图密度曲线（Density-Curves-with-Histogram）"><a href="#【23】直方图密度曲线（Density-Curves-with-Histogram）" class="headerlink" title="【23】直方图密度曲线（Density Curves with Histogram）"></a><font color=##4876FF>【23】直方图密度曲线（Density Curves with Histogram）</font></h3><p>具有直方图的密度曲线将两个图所传达的信息集合在一起，因此您可以将它们都放在一个图形中，而不是放在两个图形中。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Draw Plotplt.figure(figsize=(13, 10), dpi=80)sns.distplot(df.loc[df[&#39;class&#39;] == &#39;compact&#39;, &quot;cty&quot;], color=&quot;dodgerblue&quot;, label=&quot;Compact&quot;, hist_kws=&#123;&#39;alpha&#39;: .7&#125;,             kde_kws=&#123;&#39;linewidth&#39;: 3&#125;)sns.distplot(df.loc[df[&#39;class&#39;] == &#39;suv&#39;, &quot;cty&quot;], color=&quot;orange&quot;, label=&quot;SUV&quot;, hist_kws=&#123;&#39;alpha&#39;: .7&#125;,             kde_kws=&#123;&#39;linewidth&#39;: 3&#125;)sns.distplot(df.loc[df[&#39;class&#39;] == &#39;minivan&#39;, &quot;cty&quot;], color=&quot;g&quot;, label=&quot;minivan&quot;, hist_kws=&#123;&#39;alpha&#39;: .7&#125;,             kde_kws=&#123;&#39;linewidth&#39;: 3&#125;)plt.ylim(0, 0.35)# Decorationplt.title(&#39;Density Plot of City Mileage by Vehicle Type&#39;, fontsize=22)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/25.png" alt="25"></p><h3 id="【24】山峰叠峦图-欢乐图（Joy-Plot）"><a href="#【24】山峰叠峦图-欢乐图（Joy-Plot）" class="headerlink" title="【24】山峰叠峦图 / 欢乐图（Joy Plot）"></a><font color=##4876FF>【24】山峰叠峦图 / 欢乐图（Joy Plot）</font></h3><p>Joy Plot 允许不同组的密度曲线重叠，这是一种很好的可视化方法，可以直观地显示大量分组之间的关系。它看起来赏心悦目，清楚地传达了正确的信息。它可以使用基于 <code>matplotlib</code> 的 <code>joypy</code> 包轻松构建。</p><p>【译者 TRHX 注：Joy Plot 看起来就像是山峰叠峦，山峦起伏，层次分明，但取名为 Joy，欢乐的意思，所以不太好翻译，在使用该方法时要先安装 joypy 库】</p><pre><code class="python"># !pip install joypy# Import Dataimport joypy# 原文没有 import joypy，译者 TRHX 添加mpg = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Draw Plotplt.figure(figsize=(16, 10), dpi=80)fig, axes = joypy.joyplot(mpg, column=[&#39;hwy&#39;, &#39;cty&#39;], by=&quot;class&quot;, ylim=&#39;own&#39;, figsize=(14, 10))# Decorationplt.title(&#39;Joy Plot of City and Highway Mileage by Class&#39;, fontsize=22)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/26.png" alt="26"></p><h3 id="【25】分布式点图（Distributed-Dot-Plot）"><a href="#【25】分布式点图（Distributed-Dot-Plot）" class="headerlink" title="【25】分布式点图（Distributed Dot Plot）"></a><font color=##4876FF>【25】分布式点图（Distributed Dot Plot）</font></h3><p>分布点图显示按组分割的点的单变量分布。点越暗，数据点在该区域的集中程度就越高。通过对中值进行不同的着色，这些组的真实位置立即变得明显。</p><pre><code class="python">import matplotlib.patches as mpatches# Prepare Datadf_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)cyl_colors = &#123;4: &#39;tab:red&#39;, 5: &#39;tab:green&#39;, 6: &#39;tab:blue&#39;, 8: &#39;tab:orange&#39;&#125;df_raw[&#39;cyl_color&#39;] = df_raw.cyl.map(cyl_colors)# Mean and Median city mileage by makedf = df_raw[[&#39;cty&#39;, &#39;manufacturer&#39;]].groupby(&#39;manufacturer&#39;).apply(lambda x: x.mean())df.sort_values(&#39;cty&#39;, ascending=False, inplace=True)df.reset_index(inplace=True)df_median = df_raw[[&#39;cty&#39;, &#39;manufacturer&#39;]].groupby(&#39;manufacturer&#39;).apply(lambda x: x.median())# Draw horizontal linesfig, ax = plt.subplots(figsize=(16, 10), dpi=80)ax.hlines(y=df.index, xmin=0, xmax=40, color=&#39;gray&#39;, alpha=0.5, linewidth=.5, linestyles=&#39;dashdot&#39;)# Draw the Dotsfor i, make in enumerate(df.manufacturer):    df_make = df_raw.loc[df_raw.manufacturer == make, :]    # 原文代码    # ax.scatter(y=np.repeat(i, df_make.shape[0]), x=&#39;cty&#39;, data=df_make, s=75, edgecolors=&#39;gray&#39;, c=&#39;w&#39;, alpha=0.5)    # 纠正代码    ax.scatter(y=list(np.repeat(i, df_make.shape[0])), x=&#39;cty&#39;, data=df_make, s=75, edgecolors=&#39;gray&#39;, c=&#39;w&#39;, alpha=0.5)    ax.scatter(y=i, x=&#39;cty&#39;, data=df_median.loc[df_median.index == make, :], s=75, c=&#39;firebrick&#39;)# Annotateax.text(33, 13, &quot;$red \; dots \; are \; the \: median$&quot;, fontdict=&#123;&#39;size&#39;: 12&#125;, color=&#39;firebrick&#39;)# Decorationsred_patch = plt.plot([], [], marker=&quot;o&quot;, ms=10, ls=&quot;&quot;, mec=None, color=&#39;firebrick&#39;, label=&quot;Median&quot;)plt.legend(handles=red_patch)ax.set_title(&#39;Distribution of City Mileage by Make&#39;, fontdict=&#123;&#39;size&#39;: 22&#125;)ax.set_xlabel(&#39;Miles Per Gallon (City)&#39;, alpha=0.7)ax.set_yticks(df.index)ax.set_yticklabels(df.manufacturer.str.title(), fontdict=&#123;&#39;horizontalalignment&#39;: &#39;right&#39;&#125;, alpha=0.7)ax.set_xlim(1, 40)plt.xticks(alpha=0.7)plt.gca().spines[&quot;top&quot;].set_visible(False)plt.gca().spines[&quot;bottom&quot;].set_visible(False)plt.gca().spines[&quot;right&quot;].set_visible(False)plt.gca().spines[&quot;left&quot;].set_visible(False)plt.grid(axis=&#39;both&#39;, alpha=.4, linewidth=.1)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/27.png" alt="27"></p><h3 id="【26】箱形图（Box-Plot）"><a href="#【26】箱形图（Box-Plot）" class="headerlink" title="【26】箱形图（Box Plot）"></a><font color=##4876FF>【26】箱形图（Box Plot）</font></h3><p>箱形图是可视化分布的一种好方法，同时牢记中位数，第 25 个第 75 个四分位数和离群值。 但是，在解释方框的大小时需要小心，这可能会扭曲该组中包含的点数。 因此，手动提供每个框中的观察次数可以帮助克服此缺点。</p><p>例如，左侧的前两个框，尽管它们分别具有 5 和 47 个 obs，但是却具有相同大小， 因此，有必要写下该组中的观察数。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Draw Plotplt.figure(figsize=(13, 10), dpi=80)sns.boxplot(x=&#39;class&#39;, y=&#39;hwy&#39;, data=df, notch=False)# Add N Obs inside boxplot (optional)def add_n_obs(df, group_col, y):    medians_dict = &#123;grp[0]: grp[1][y].median() for grp in df.groupby(group_col)&#125;    xticklabels = [x.get_text() for x in plt.gca().get_xticklabels()]    n_obs = df.groupby(group_col)[y].size().values    for (x, xticklabel), n_ob in zip(enumerate(xticklabels), n_obs):        plt.text(x, medians_dict[xticklabel] * 1.01, &quot;#obs : &quot; + str(n_ob), horizontalalignment=&#39;center&#39;,                 fontdict=&#123;&#39;size&#39;: 14&#125;, color=&#39;white&#39;)add_n_obs(df, group_col=&#39;class&#39;, y=&#39;hwy&#39;)# Decorationplt.title(&#39;Box Plot of Highway Mileage by Vehicle Class&#39;, fontsize=22)plt.ylim(10, 40)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/28.png" alt="28"></p><h3 id="【27】点-箱形图（Dot-Box-Plot）"><a href="#【27】点-箱形图（Dot-Box-Plot）" class="headerlink" title="【27】点 + 箱形图（Dot + Box Plot）"></a><font color=##4876FF>【27】点 + 箱形图（Dot + Box Plot）</font></h3><p>点 + 箱形图传达类似于分组的箱形图信息。此外，这些点还提供了每组中有多少数据点的含义。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Draw Plotplt.figure(figsize=(13,10), dpi= 80)sns.boxplot(x=&#39;class&#39;, y=&#39;hwy&#39;, data=df, hue=&#39;cyl&#39;)sns.stripplot(x=&#39;class&#39;, y=&#39;hwy&#39;, data=df, color=&#39;black&#39;, size=3, jitter=1)for i in range(len(df[&#39;class&#39;].unique())-1):    plt.vlines(i+.5, 10, 45, linestyles=&#39;solid&#39;, colors=&#39;gray&#39;, alpha=0.2)# Decorationplt.title(&#39;Box Plot of Highway Mileage by Vehicle Class&#39;, fontsize=22)plt.legend(title=&#39;Cylinders&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/29.png" alt="29"></p><h3 id="【28】小提琴图（Violin-Plot）"><a href="#【28】小提琴图（Violin-Plot）" class="headerlink" title="【28】小提琴图（Violin Plot）"></a><font color=##4876FF>【28】小提琴图（Violin Plot）</font></h3><p>小提琴图是箱形图在视觉上令人愉悦的替代品。 小提琴的形状或面积取决于它所持有的观察次数。 但是，小提琴图可能更难以阅读，并且在专业设置中不常用。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Draw Plotplt.figure(figsize=(13, 10), dpi=80)sns.violinplot(x=&#39;class&#39;, y=&#39;hwy&#39;, data=df, scale=&#39;width&#39;, inner=&#39;quartile&#39;)# Decorationplt.title(&#39;Violin Plot of Highway Mileage by Vehicle Class&#39;, fontsize=22)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/30.png" alt="30"></p><h3 id="【29】人口金字塔图（Population-Pyramid）"><a href="#【29】人口金字塔图（Population-Pyramid）" class="headerlink" title="【29】人口金字塔图（Population Pyramid）"></a><font color=##4876FF>【29】人口金字塔图（Population Pyramid）</font></h3><p>人口金字塔可用于显示按体积排序的组的分布。或者它也可以用于显示人口的逐级过滤，因为它是用来显示有多少人通过一个营销漏斗（Marketing Funnel）的每个阶段。</p><pre><code class="python"># Read datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/email_campaign_funnel.csv&quot;)# Draw Plotplt.figure(figsize=(13, 10), dpi=80)group_col = &#39;Gender&#39;order_of_bars = df.Stage.unique()[::-1]colors = [plt.cm.Spectral(i / float(len(df[group_col].unique()) - 1)) for i in range(len(df[group_col].unique()))]for c, group in zip(colors, df[group_col].unique()):    sns.barplot(x=&#39;Users&#39;, y=&#39;Stage&#39;, data=df.loc[df[group_col] == group, :], order=order_of_bars, color=c, label=group)# Decorationsplt.xlabel(&quot;$Users$&quot;)plt.ylabel(&quot;Stage of Purchase&quot;)plt.yticks(fontsize=12)plt.title(&quot;Population Pyramid of the Marketing Funnel&quot;, fontsize=22)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/31.png" alt="31"></p><h3 id="【30】分类图（Categorical-Plots）"><a href="#【30】分类图（Categorical-Plots）" class="headerlink" title="【30】分类图（Categorical Plots）"></a><font color=##4876FF>【30】分类图（Categorical Plots）</font></h3><p>由 <code>seaborn</code> 库提供的分类图可用于可视化彼此相关的两个或更多分类变量的计数分布。</p><pre><code class="python"># Load Datasettitanic = sns.load_dataset(&quot;titanic&quot;)# Plotg = sns.catplot(&quot;alive&quot;, col=&quot;deck&quot;, col_wrap=4,                data=titanic[titanic.deck.notnull()],                kind=&quot;count&quot;, height=3.5, aspect=.8,                palette=&#39;tab20&#39;)# 译者 TRHX 注释掉了这一行代码# fig.suptitle(&#39;sf&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/32.png" alt="32"></p><pre><code class="python"># Load Datasettitanic = sns.load_dataset(&quot;titanic&quot;)# Plotsns.catplot(x=&quot;age&quot;, y=&quot;embark_town&quot;,            hue=&quot;sex&quot;, col=&quot;class&quot;,            data=titanic[titanic.embark_town.notnull()],            orient=&quot;h&quot;, height=5, aspect=1, palette=&quot;tab10&quot;,            kind=&quot;violin&quot;, dodge=True, cut=0, bw=.2)# 译者 TRHX 添加了这行代码plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/33.png" alt="33"></p><h2 id="【7x00】组成（Composition）"><a href="#【7x00】组成（Composition）" class="headerlink" title="【7x00】组成（Composition）"></a><font color=#FF0000>【7x00】组成（Composition）</font></h2><h3 id="【31】华夫饼图（Waffle-Chart）"><a href="#【31】华夫饼图（Waffle-Chart）" class="headerlink" title="【31】华夫饼图（Waffle Chart）"></a><font color=##4876FF>【31】华夫饼图（Waffle Chart）</font></h3><p>华夫饼图可以使用 <code>pywaffle</code> 包创建，用于显示较大群体中的组的组成。</p><p>【译者 TRHX 注：在使用该方法时要先安装 pywaffle 库】</p><pre><code class="python"># ! pip install pywaffle# Reference: https://stackoverflow.com/questions/41400136/how-to-do-waffle-charts-in-python-square-piechartfrom pywaffle import Waffle# Importdf_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Prepare Datadf = df_raw.groupby(&#39;class&#39;).size().reset_index(name=&#39;counts&#39;)n_categories = df.shape[0]colors = [plt.cm.inferno_r(i / float(n_categories)) for i in range(n_categories)]# Draw Plot and Decoratefig = plt.figure(    FigureClass=Waffle,    plots=&#123;        &#39;111&#39;: &#123;            &#39;values&#39;: df[&#39;counts&#39;],            &#39;labels&#39;: [&quot;&#123;0&#125; (&#123;1&#125;)&quot;.format(n[0], n[1]) for n in df[[&#39;class&#39;, &#39;counts&#39;]].itertuples()],            &#39;legend&#39;: &#123;&#39;loc&#39;: &#39;upper left&#39;, &#39;bbox_to_anchor&#39;: (1.05, 1), &#39;fontsize&#39;: 12&#125;,            &#39;title&#39;: &#123;&#39;label&#39;: &#39;# Vehicles by Class&#39;, &#39;loc&#39;: &#39;center&#39;, &#39;fontsize&#39;: 18&#125;        &#125;,    &#125;,    rows=7,    colors=colors,    figsize=(16, 9))# 译者 TRHX 添加了这行代码plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/34.png" alt="34"></p><pre><code class="python"># ! pip install pywafflefrom pywaffle import Waffle# Import# 译者 TRHX 取消注释了这行代码df_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Prepare Data# By Class Datadf_class = df_raw.groupby(&#39;class&#39;).size().reset_index(name=&#39;counts_class&#39;)n_categories = df_class.shape[0]colors_class = [plt.cm.Set3(i / float(n_categories)) for i in range(n_categories)]# By Cylinders Datadf_cyl = df_raw.groupby(&#39;cyl&#39;).size().reset_index(name=&#39;counts_cyl&#39;)n_categories = df_cyl.shape[0]colors_cyl = [plt.cm.Spectral(i / float(n_categories)) for i in range(n_categories)]# By Make Datadf_make = df_raw.groupby(&#39;manufacturer&#39;).size().reset_index(name=&#39;counts_make&#39;)n_categories = df_make.shape[0]colors_make = [plt.cm.tab20b(i / float(n_categories)) for i in range(n_categories)]# Draw Plot and Decoratefig = plt.figure(    FigureClass=Waffle,    plots=&#123;        &#39;311&#39;: &#123;            &#39;values&#39;: df_class[&#39;counts_class&#39;],            &#39;labels&#39;: [&quot;&#123;1&#125;&quot;.format(n[0], n[1]) for n in df_class[[&#39;class&#39;, &#39;counts_class&#39;]].itertuples()],            &#39;legend&#39;: &#123;&#39;loc&#39;: &#39;upper left&#39;, &#39;bbox_to_anchor&#39;: (1.05, 1), &#39;fontsize&#39;: 12, &#39;title&#39;: &#39;Class&#39;&#125;,            &#39;title&#39;: &#123;&#39;label&#39;: &#39;# Vehicles by Class&#39;, &#39;loc&#39;: &#39;center&#39;, &#39;fontsize&#39;: 18&#125;,            &#39;colors&#39;: colors_class        &#125;,        &#39;312&#39;: &#123;            &#39;values&#39;: df_cyl[&#39;counts_cyl&#39;],            &#39;labels&#39;: [&quot;&#123;1&#125;&quot;.format(n[0], n[1]) for n in df_cyl[[&#39;cyl&#39;, &#39;counts_cyl&#39;]].itertuples()],            &#39;legend&#39;: &#123;&#39;loc&#39;: &#39;upper left&#39;, &#39;bbox_to_anchor&#39;: (1.05, 1), &#39;fontsize&#39;: 12, &#39;title&#39;: &#39;Cyl&#39;&#125;,            &#39;title&#39;: &#123;&#39;label&#39;: &#39;# Vehicles by Cyl&#39;, &#39;loc&#39;: &#39;center&#39;, &#39;fontsize&#39;: 18&#125;,            &#39;colors&#39;: colors_cyl        &#125;,        &#39;313&#39;: &#123;            &#39;values&#39;: df_make[&#39;counts_make&#39;],            &#39;labels&#39;: [&quot;&#123;1&#125;&quot;.format(n[0], n[1]) for n in df_make[[&#39;manufacturer&#39;, &#39;counts_make&#39;]].itertuples()],            &#39;legend&#39;: &#123;&#39;loc&#39;: &#39;upper left&#39;, &#39;bbox_to_anchor&#39;: (1.05, 1), &#39;fontsize&#39;: 12, &#39;title&#39;: &#39;Manufacturer&#39;&#125;,            &#39;title&#39;: &#123;&#39;label&#39;: &#39;# Vehicles by Make&#39;, &#39;loc&#39;: &#39;center&#39;, &#39;fontsize&#39;: 18&#125;,            &#39;colors&#39;: colors_make        &#125;    &#125;,    rows=9,    figsize=(16, 14))# 译者 TRHX 添加了这行代码plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/35.png" alt="35"></p><h3 id="【32】饼图（Pie-Chart）"><a href="#【32】饼图（Pie-Chart）" class="headerlink" title="【32】饼图（Pie Chart）"></a><font color=##4876FF>【32】饼图（Pie Chart）</font></h3><p>饼图是显示组成的经典方法。然而，现在一般不宜使用，因为馅饼部分的面积有时会产生误导。因此，如果要使用饼图，强烈建议您显式地记下饼图每个部分的百分比或数字。</p><pre><code class="python"># Importdf_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Prepare Datadf = df_raw.groupby(&#39;class&#39;).size()# Make the plot with pandas&#39;&#39;&#39;原代码：df.plot(kind=&#39;pie&#39;, subplots=True, figsize=(8, 8), dpi=80)译者 TRHX 删除了 dpi= 80&#39;&#39;&#39;df.plot(kind=&#39;pie&#39;, subplots=True, figsize=(8, 8))plt.title(&quot;Pie Chart of Vehicle Class - Bad&quot;)plt.ylabel(&quot;&quot;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/36.png" alt="36"></p><pre><code class="python"># Importdf_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Prepare Datadf = df_raw.groupby(&#39;class&#39;).size().reset_index(name=&#39;counts&#39;)# Draw Plotfig, ax = plt.subplots(figsize=(12, 7), subplot_kw=dict(aspect=&quot;equal&quot;), dpi=80)data = df[&#39;counts&#39;]categories = df[&#39;class&#39;]explode = [0, 0, 0, 0, 0, 0.1, 0]def func(pct, allvals):    absolute = int(pct / 100. * np.sum(allvals))    return &quot;&#123;:.1f&#125;% (&#123;:d&#125; )&quot;.format(pct, absolute)wedges, texts, autotexts = ax.pie(data,                                  autopct=lambda pct: func(pct, data),                                  textprops=dict(color=&quot;w&quot;),                                  colors=plt.cm.Dark2.colors,                                  startangle=140,                                  explode=explode)# Decorationax.legend(wedges, categories, title=&quot;Vehicle Class&quot;, loc=&quot;center left&quot;, bbox_to_anchor=(1, 0, 0.5, 1))plt.setp(autotexts, size=10, weight=700)ax.set_title(&quot;Class of Vehicles: Pie Chart&quot;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/37.png" alt="37"></p><h3 id="【33】矩阵树形图（Treemap）"><a href="#【33】矩阵树形图（Treemap）" class="headerlink" title="【33】矩阵树形图（Treemap）"></a><font color=##4876FF>【33】矩阵树形图（Treemap）</font></h3><p>矩阵树形图类似于饼图，它可以更好地完成工作而不会误导每个组的贡献。</p><p>【译者 TRHX 注：在使用该方法时要先安装 squarify 库】</p><pre><code class="python"># pip install squarifyimport squarify# Import Datadf_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Prepare Datadf = df_raw.groupby(&#39;class&#39;).size().reset_index(name=&#39;counts&#39;)labels = df.apply(lambda x: str(x[0]) + &quot;\n (&quot; + str(x[1]) + &quot;)&quot;, axis=1)sizes = df[&#39;counts&#39;].values.tolist()colors = [plt.cm.Spectral(i / float(len(labels))) for i in range(len(labels))]# Draw Plotplt.figure(figsize=(12, 8), dpi=80)squarify.plot(sizes=sizes, label=labels, color=colors, alpha=.8)# Decorateplt.title(&#39;Treemap of Vechile Class&#39;)plt.axis(&#39;off&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/38.png" alt="38"></p><h3 id="【34】条形图（Bar-Chart）"><a href="#【34】条形图（Bar-Chart）" class="headerlink" title="【34】条形图（Bar Chart）"></a><font color=##4876FF>【34】条形图（Bar Chart）</font></h3><p>条形图是一种基于计数或任何给定度量的可视化项的经典方法。在下面的图表中，我为每个项目使用了不同的颜色，但您通常可能希望为所有项目选择一种颜色，除非您按组对它们进行着色。颜色名称存储在下面代码中的 <code>all_colors</code> 中。您可以通过在 <code>plt.plot()</code> 中设置 <code>color</code> 参数来更改条形的颜色。</p><pre><code class="python">import random# Import Datadf_raw = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mpg_ggplot2.csv&quot;)# Prepare Datadf = df_raw.groupby(&#39;manufacturer&#39;).size().reset_index(name=&#39;counts&#39;)n = df[&#39;manufacturer&#39;].unique().__len__()+1all_colors = list(plt.cm.colors.cnames.keys())random.seed(100)c = random.choices(all_colors, k=n)# Plot Barsplt.figure(figsize=(16,10), dpi= 80)plt.bar(df[&#39;manufacturer&#39;], df[&#39;counts&#39;], color=c, width=.5)for i, val in enumerate(df[&#39;counts&#39;].values):    plt.text(i, val, float(val), horizontalalignment=&#39;center&#39;, verticalalignment=&#39;bottom&#39;, fontdict=&#123;&#39;fontweight&#39;:500, &#39;size&#39;:12&#125;)# Decorationplt.gca().set_xticklabels(df[&#39;manufacturer&#39;], rotation=60, horizontalalignment= &#39;right&#39;)plt.title(&quot;Number of Vehicles by Manaufacturers&quot;, fontsize=22)plt.ylabel(&#39;# Vehicles&#39;)plt.ylim(0, 45)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/39.png" alt="39"></p><h2 id="【8x00】变化（Change）"><a href="#【8x00】变化（Change）" class="headerlink" title="【8x00】变化（Change）"></a><font color=#FF0000>【8x00】变化（Change）</font></h2><h3 id="【35】时间序列图（Time-Series-Plot）"><a href="#【35】时间序列图（Time-Series-Plot）" class="headerlink" title="【35】时间序列图（Time Series Plot）"></a><font color=##4876FF>【35】时间序列图（Time Series Plot）</font></h3><p>时间序列图用于可视化给定指标随时间的变化。在这里你可以看到 1949 年到 1969 年间的航空客运量是如何变化的。</p><pre><code class="python"># Import Datadf = pd.read_csv(&#39;https://github.com/selva86/datasets/raw/master/AirPassengers.csv&#39;)# Draw Plotplt.figure(figsize=(16, 10), dpi=80)plt.plot(&#39;date&#39;, &#39;traffic&#39;, data=df, color=&#39;tab:red&#39;)# Decorationplt.ylim(50, 750)xtick_location = df.index.tolist()[::12]xtick_labels = [x[-4:] for x in df.date.tolist()[::12]]plt.xticks(ticks=xtick_location, labels=xtick_labels, rotation=0, fontsize=12, horizontalalignment=&#39;center&#39;, alpha=.7)plt.yticks(fontsize=12, alpha=.7)plt.title(&quot;Air Passengers Traffic (1949 - 1969)&quot;, fontsize=22)plt.grid(axis=&#39;both&#39;, alpha=.3)# Remove bordersplt.gca().spines[&quot;top&quot;].set_alpha(0.0)plt.gca().spines[&quot;bottom&quot;].set_alpha(0.3)plt.gca().spines[&quot;right&quot;].set_alpha(0.0)plt.gca().spines[&quot;left&quot;].set_alpha(0.3)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/40.png" alt="40"></p><h3 id="【36】带波峰和波谷注释的时间序列图（Time-Series-with-Peaks-and-Troughs-Annotated）"><a href="#【36】带波峰和波谷注释的时间序列图（Time-Series-with-Peaks-and-Troughs-Annotated）" class="headerlink" title="【36】带波峰和波谷注释的时间序列图（Time Series with Peaks and Troughs Annotated）"></a><font color=##4876FF>【36】带波峰和波谷注释的时间序列图（Time Series with Peaks and Troughs Annotated）</font></h3><p>下面的时间序列绘制了所有的波峰和波谷，并注释了所选特殊事件的发生。</p><pre><code class="python"># Import Datadf = pd.read_csv(&#39;https://github.com/selva86/datasets/raw/master/AirPassengers.csv&#39;)# Get the Peaks and Troughsdata = df[&#39;traffic&#39;].valuesdoublediff = np.diff(np.sign(np.diff(data)))peak_locations = np.where(doublediff == -2)[0] + 1doublediff2 = np.diff(np.sign(np.diff(-1 * data)))trough_locations = np.where(doublediff2 == -2)[0] + 1# Draw Plotplt.figure(figsize=(16, 10), dpi=80)plt.plot(&#39;date&#39;, &#39;traffic&#39;, data=df, color=&#39;tab:blue&#39;, label=&#39;Air Traffic&#39;)plt.scatter(df.date[peak_locations], df.traffic[peak_locations], marker=mpl.markers.CARETUPBASE, color=&#39;tab:green&#39;,            s=100, label=&#39;Peaks&#39;)plt.scatter(df.date[trough_locations], df.traffic[trough_locations], marker=mpl.markers.CARETDOWNBASE, color=&#39;tab:red&#39;,            s=100, label=&#39;Troughs&#39;)# Annotatefor t, p in zip(trough_locations[1::5], peak_locations[::3]):    plt.text(df.date[p], df.traffic[p] + 15, df.date[p], horizontalalignment=&#39;center&#39;, color=&#39;darkgreen&#39;)    plt.text(df.date[t], df.traffic[t] - 35, df.date[t], horizontalalignment=&#39;center&#39;, color=&#39;darkred&#39;)# Decorationplt.ylim(50, 750)xtick_location = df.index.tolist()[::6]xtick_labels = df.date.tolist()[::6]plt.xticks(ticks=xtick_location, labels=xtick_labels, rotation=90, fontsize=12, alpha=.7)plt.title(&quot;Peak and Troughs of Air Passengers Traffic (1949 - 1969)&quot;, fontsize=22)plt.yticks(fontsize=12, alpha=.7)# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(.0)plt.gca().spines[&quot;bottom&quot;].set_alpha(.3)plt.gca().spines[&quot;right&quot;].set_alpha(.0)plt.gca().spines[&quot;left&quot;].set_alpha(.3)plt.legend(loc=&#39;upper left&#39;)plt.grid(axis=&#39;y&#39;, alpha=.3)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/41.png" alt="41"></p><h3 id="【37】自相关-ACF-和部分自相关-PACF-图（Autocorrelation-ACF-and-Partial-Autocorrelation-PACF-Plot）"><a href="#【37】自相关-ACF-和部分自相关-PACF-图（Autocorrelation-ACF-and-Partial-Autocorrelation-PACF-Plot）" class="headerlink" title="【37】自相关 (ACF) 和部分自相关 (PACF) 图（Autocorrelation (ACF) and Partial Autocorrelation (PACF) Plot）"></a><font color=##4876FF>【37】自相关 (ACF) 和部分自相关 (PACF) 图（Autocorrelation (ACF) and Partial Autocorrelation (PACF) Plot）</font></h3><p>自相关图（ACF图）显示了时间序列与其自身滞后的相关性。 每条垂直线（在自相关图上）表示系列与滞后 0 之间的滞后的相关性。图中的蓝色阴影区域是显著性级别。 那些位于蓝线之上的滞后是显著的滞后。</p><p>那么如何解释呢？</p><p>对于航空乘客来说，我们看到超过 14 个滞后已经越过蓝线，因此意义重大。这意味着，14 年前的航空客运量对今天的交通量产生了影响。 </p><p>另一方面，部分自相关图（PACF）显示了任何给定滞后（时间序列）相对于当前序列的自相关，但消除了中间滞后的贡献。</p><pre><code class="python">from statsmodels.graphics.tsaplots import plot_acf, plot_pacf# Import Datadf = pd.read_csv(&#39;https://github.com/selva86/datasets/raw/master/AirPassengers.csv&#39;)# Draw Plotfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6), dpi=80)plot_acf(df.traffic.tolist(), ax=ax1, lags=50)plot_pacf(df.traffic.tolist(), ax=ax2, lags=20)# Decorate# lighten the bordersax1.spines[&quot;top&quot;].set_alpha(.3); ax2.spines[&quot;top&quot;].set_alpha(.3)ax1.spines[&quot;bottom&quot;].set_alpha(.3); ax2.spines[&quot;bottom&quot;].set_alpha(.3)ax1.spines[&quot;right&quot;].set_alpha(.3); ax2.spines[&quot;right&quot;].set_alpha(.3)ax1.spines[&quot;left&quot;].set_alpha(.3); ax2.spines[&quot;left&quot;].set_alpha(.3)# font size of tick labelsax1.tick_params(axis=&#39;both&#39;, labelsize=12)ax2.tick_params(axis=&#39;both&#39;, labelsize=12)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/42.png" alt="42"></p><h3 id="【38】交叉相关图（Cross-Correlation-plot）"><a href="#【38】交叉相关图（Cross-Correlation-plot）" class="headerlink" title="【38】交叉相关图（Cross Correlation plot）"></a><font color=##4876FF>【38】交叉相关图（Cross Correlation plot）</font></h3><p>交叉相关图显示了两个时间序列相互之间的滞后。</p><pre><code class="python">import statsmodels.tsa.stattools as stattools# Import Datadf = pd.read_csv(&#39;https://github.com/selva86/datasets/raw/master/mortality.csv&#39;)x = df[&#39;mdeaths&#39;]y = df[&#39;fdeaths&#39;]# Compute Cross Correlationsccs = stattools.ccf(x, y)[:100]nlags = len(ccs)# Compute the Significance level# ref: https://stats.stackexchange.com/questions/3115/cross-correlation-significance-in-r/3128#3128conf_level = 2 / np.sqrt(nlags)# Draw Plotplt.figure(figsize=(12, 7), dpi=80)plt.hlines(0, xmin=0, xmax=100, color=&#39;gray&#39;)  # 0 axisplt.hlines(conf_level, xmin=0, xmax=100, color=&#39;gray&#39;)plt.hlines(-conf_level, xmin=0, xmax=100, color=&#39;gray&#39;)plt.bar(x=np.arange(len(ccs)), height=ccs, width=.3)# Decorationplt.title(&#39;$Cross\; Correlation\; Plot:\; mdeaths\; vs\; fdeaths$&#39;, fontsize=22)plt.xlim(0, len(ccs))plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/43.png" alt="43"></p><h3 id="【39】时间序列分解图（Time-Series-Decomposition-Plot）"><a href="#【39】时间序列分解图（Time-Series-Decomposition-Plot）" class="headerlink" title="【39】时间序列分解图（Time Series Decomposition Plot）"></a><font color=##4876FF>【39】时间序列分解图（Time Series Decomposition Plot）</font></h3><p>时间序列分解图将时间序列分解为趋势、季节和残差分量。</p><pre><code class="python">from statsmodels.tsa.seasonal import seasonal_decomposefrom dateutil.parser import parse# Import Datadf = pd.read_csv(&#39;https://github.com/selva86/datasets/raw/master/AirPassengers.csv&#39;)dates = pd.DatetimeIndex([parse(d).strftime(&#39;%Y-%m-01&#39;) for d in df[&#39;date&#39;]])df.set_index(dates, inplace=True)# Decomposeresult = seasonal_decompose(df[&#39;traffic&#39;], model=&#39;multiplicative&#39;)# Plotplt.rcParams.update(&#123;&#39;figure.figsize&#39;: (10, 10)&#125;)result.plot().suptitle(&#39;Time Series Decomposition of Air Passengers&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/44.png" alt="44"></p><h3 id="【40】多重时间序列（Multiple-Time-Series）"><a href="#【40】多重时间序列（Multiple-Time-Series）" class="headerlink" title="【40】多重时间序列（Multiple Time Series）"></a><font color=##4876FF>【40】多重时间序列（Multiple Time Series）</font></h3><p>您可以在同一图表上绘制多个测量相同值的时间序列，如下所示。</p><pre><code class="python"># Import Datadf = pd.read_csv(&#39;https://github.com/selva86/datasets/raw/master/mortality.csv&#39;)# Define the upper limit, lower limit, interval of Y axis and colorsy_LL = 100y_UL = int(df.iloc[:, 1:].max().max() * 1.1)y_interval = 400mycolors = [&#39;tab:red&#39;, &#39;tab:blue&#39;, &#39;tab:green&#39;, &#39;tab:orange&#39;]# Draw Plot and Annotatefig, ax = plt.subplots(1, 1, figsize=(16, 9), dpi=80)columns = df.columns[1:]for i, column in enumerate(columns):    plt.plot(df.date.values, df[column].values, lw=1.5, color=mycolors[i])    plt.text(df.shape[0] + 1, df[column].values[-1], column, fontsize=14, color=mycolors[i])# Draw Tick linesfor y in range(y_LL, y_UL, y_interval):    plt.hlines(y, xmin=0, xmax=71, colors=&#39;black&#39;, alpha=0.3, linestyles=&quot;--&quot;, lw=0.5)# Decorationsplt.tick_params(axis=&quot;both&quot;, which=&quot;both&quot;, bottom=False, top=False,                labelbottom=True, left=False, right=False, labelleft=True)# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(.3)plt.gca().spines[&quot;bottom&quot;].set_alpha(.3)plt.gca().spines[&quot;right&quot;].set_alpha(.3)plt.gca().spines[&quot;left&quot;].set_alpha(.3)plt.title(&#39;Number of Deaths from Lung Diseases in the UK (1974-1979)&#39;, fontsize=22)plt.yticks(range(y_LL, y_UL, y_interval), [str(y) for y in range(y_LL, y_UL, y_interval)], fontsize=12)plt.xticks(range(0, df.shape[0], 12), df.date.values[::12], horizontalalignment=&#39;left&#39;, fontsize=12)plt.ylim(y_LL, y_UL)plt.xlim(-2, 80)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/45.png" alt="45"></p><h3 id="【41】使用次要的-Y-轴来绘制不同范围的图形（Plotting-with-different-scales-using-secondary-Y-axis）"><a href="#【41】使用次要的-Y-轴来绘制不同范围的图形（Plotting-with-different-scales-using-secondary-Y-axis）" class="headerlink" title="【41】使用次要的 Y 轴来绘制不同范围的图形（Plotting with different scales using secondary Y axis）"></a><font color=##4876FF>【41】使用次要的 Y 轴来绘制不同范围的图形（Plotting with different scales using secondary Y axis）</font></h3><p>如果要显示在同一时间点测量两个不同数量的两个时间序列，则可以在右侧的次要 Y 轴上再绘制第二个系列。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/economics.csv&quot;)x = df[&#39;date&#39;]y1 = df[&#39;psavert&#39;]y2 = df[&#39;unemploy&#39;]# Plot Line1 (Left Y Axis)fig, ax1 = plt.subplots(1, 1, figsize=(16, 9), dpi=80)ax1.plot(x, y1, color=&#39;tab:red&#39;)# Plot Line2 (Right Y Axis)ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axisax2.plot(x, y2, color=&#39;tab:blue&#39;)# Decorations# ax1 (left Y axis)ax1.set_xlabel(&#39;Year&#39;, fontsize=20)ax1.tick_params(axis=&#39;x&#39;, rotation=0, labelsize=12)ax1.set_ylabel(&#39;Personal Savings Rate&#39;, color=&#39;tab:red&#39;, fontsize=20)ax1.tick_params(axis=&#39;y&#39;, rotation=0, labelcolor=&#39;tab:red&#39;)ax1.grid(alpha=.4)# ax2 (right Y axis)ax2.set_ylabel(&quot;# Unemployed (1000&#39;s)&quot;, color=&#39;tab:blue&#39;, fontsize=20)ax2.tick_params(axis=&#39;y&#39;, labelcolor=&#39;tab:blue&#39;)ax2.set_xticks(np.arange(0, len(x), 60))ax2.set_xticklabels(x[::60], rotation=90, fontdict=&#123;&#39;fontsize&#39;: 10&#125;)ax2.set_title(&quot;Personal Savings Rate vs Unemployed: Plotting in Secondary Y Axis&quot;, fontsize=22)fig.tight_layout()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/46.png" alt="46"></p><h3 id="【42】带误差带的时间序列（Time-Series-with-Error-Bands）"><a href="#【42】带误差带的时间序列（Time-Series-with-Error-Bands）" class="headerlink" title="【42】带误差带的时间序列（Time Series with Error Bands）"></a><font color=##4876FF>【42】带误差带的时间序列（Time Series with Error Bands）</font></h3><p>如果您有一个时间序列数据集，其中每个时间点（日期/时间戳）有多个观测值，则可以构造具有误差带的时间序列。下面您可以看到一些基于一天中不同时间的订单的示例。还有一个关于45天内到达的订单数量的例子。</p><p>在这种方法中，订单数量的平均值用白线表示。并计算95%的置信区间，并围绕平均值绘制。</p><pre><code class="python">from scipy.stats import sem# Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/user_orders_hourofday.csv&quot;)df_mean = df.groupby(&#39;order_hour_of_day&#39;).quantity.mean()df_se = df.groupby(&#39;order_hour_of_day&#39;).quantity.apply(sem).mul(1.96)# Plotplt.figure(figsize=(16, 10), dpi=80)plt.ylabel(&quot;# Orders&quot;, fontsize=16)x = df_mean.indexplt.plot(x, df_mean, color=&quot;white&quot;, lw=2)plt.fill_between(x, df_mean - df_se, df_mean + df_se, color=&quot;#3F5D7D&quot;)# Decorations# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(0)plt.gca().spines[&quot;bottom&quot;].set_alpha(1)plt.gca().spines[&quot;right&quot;].set_alpha(0)plt.gca().spines[&quot;left&quot;].set_alpha(1)plt.xticks(x[::2], [str(d) for d in x[::2]], fontsize=12)plt.title(&quot;User Orders by Hour of Day (95% confidence)&quot;, fontsize=22)plt.xlabel(&quot;Hour of Day&quot;)s, e = plt.gca().get_xlim()plt.xlim(s, e)# Draw Horizontal Tick linesfor y in range(8, 20, 2):    plt.hlines(y, xmin=s, xmax=e, colors=&#39;black&#39;, alpha=0.5, linestyles=&quot;--&quot;, lw=0.5)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/47.png" alt="47"></p><pre><code class="python">&quot;Data Source: https://www.kaggle.com/olistbr/brazilian-ecommerce#olist_orders_dataset.csv&quot;from dateutil.parser import parsefrom scipy.stats import sem# Import Datadf_raw = pd.read_csv(&#39;https://raw.githubusercontent.com/selva86/datasets/master/orders_45d.csv&#39;,                     parse_dates=[&#39;purchase_time&#39;, &#39;purchase_date&#39;])# Prepare Data: Daily Mean and SE Bandsdf_mean = df_raw.groupby(&#39;purchase_date&#39;).quantity.mean()df_se = df_raw.groupby(&#39;purchase_date&#39;).quantity.apply(sem).mul(1.96)# Plotplt.figure(figsize=(16, 10), dpi=80)plt.ylabel(&quot;# Daily Orders&quot;, fontsize=16)x = [d.date().strftime(&#39;%Y-%m-%d&#39;) for d in df_mean.index]plt.plot(x, df_mean, color=&quot;white&quot;, lw=2)plt.fill_between(x, df_mean - df_se, df_mean + df_se, color=&quot;#3F5D7D&quot;)# Decorations# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(0)plt.gca().spines[&quot;bottom&quot;].set_alpha(1)plt.gca().spines[&quot;right&quot;].set_alpha(0)plt.gca().spines[&quot;left&quot;].set_alpha(1)plt.xticks(x[::6], [str(d) for d in x[::6]], fontsize=12)plt.title(&quot;Daily Order Quantity of Brazilian Retail with Error Bands (95% confidence)&quot;, fontsize=20)# Axis limitss, e = plt.gca().get_xlim()plt.xlim(s, e - 2)plt.ylim(4, 10)# Draw Horizontal Tick linesfor y in range(5, 10, 1):    plt.hlines(y, xmin=s, xmax=e, colors=&#39;black&#39;, alpha=0.5, linestyles=&quot;--&quot;, lw=0.5)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/48.png" alt="48"></p><h3 id="【43】堆积面积图（Stacked-Area-Chart）"><a href="#【43】堆积面积图（Stacked-Area-Chart）" class="headerlink" title="【43】堆积面积图（Stacked Area Chart）"></a><font color=##4876FF>【43】堆积面积图（Stacked Area Chart）</font></h3><p>堆积面积图提供了多个时间序列的贡献程度的可视化表示，以便相互比较。</p><pre><code class="python"># Import Datadf = pd.read_csv(&#39;https://raw.githubusercontent.com/selva86/datasets/master/nightvisitors.csv&#39;)# Decide Colorsmycolors = [&#39;tab:red&#39;, &#39;tab:blue&#39;, &#39;tab:green&#39;, &#39;tab:orange&#39;, &#39;tab:brown&#39;, &#39;tab:grey&#39;, &#39;tab:pink&#39;, &#39;tab:olive&#39;]# Draw Plot and Annotatefig, ax = plt.subplots(1, 1, figsize=(16, 9), dpi=80)columns = df.columns[1:]labs = columns.values.tolist()# Prepare datax = df[&#39;yearmon&#39;].values.tolist()y0 = df[columns[0]].values.tolist()y1 = df[columns[1]].values.tolist()y2 = df[columns[2]].values.tolist()y3 = df[columns[3]].values.tolist()y4 = df[columns[4]].values.tolist()y5 = df[columns[5]].values.tolist()y6 = df[columns[6]].values.tolist()y7 = df[columns[7]].values.tolist()y = np.vstack([y0, y2, y4, y6, y7, y5, y1, y3])# Plot for each columnlabs = columns.values.tolist()ax = plt.gca()ax.stackplot(x, y, labels=labs, colors=mycolors, alpha=0.8)# Decorationsax.set_title(&#39;Night Visitors in Australian Regions&#39;, fontsize=18)ax.set(ylim=[0, 100000])ax.legend(fontsize=10, ncol=4)plt.xticks(x[::5], fontsize=10, horizontalalignment=&#39;center&#39;)plt.yticks(np.arange(10000, 100000, 20000), fontsize=10)plt.xlim(x[0], x[-1])# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(0)plt.gca().spines[&quot;bottom&quot;].set_alpha(.3)plt.gca().spines[&quot;right&quot;].set_alpha(0)plt.gca().spines[&quot;left&quot;].set_alpha(.3)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/49.png" alt="49"></p><h3 id="【44】未堆积面积图（Area-Chart-UnStacked）"><a href="#【44】未堆积面积图（Area-Chart-UnStacked）" class="headerlink" title="【44】未堆积面积图（Area Chart UnStacked）"></a><font color=##4876FF>【44】未堆积面积图（Area Chart UnStacked）</font></h3><p>未堆积的面积图用于可视化两个或多个序列彼此之间的进度（起伏）。在下面的图表中，你可以清楚地看到，随着失业持续时间的中位数增加，个人储蓄率是如何下降的。未堆积面积图很好地展示了这一现象。</p><pre><code class="python"># Import Datadf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/economics.csv&quot;)# Prepare Datax = df[&#39;date&#39;].values.tolist()y1 = df[&#39;psavert&#39;].values.tolist()y2 = df[&#39;uempmed&#39;].values.tolist()mycolors = [&#39;tab:red&#39;, &#39;tab:blue&#39;, &#39;tab:green&#39;, &#39;tab:orange&#39;, &#39;tab:brown&#39;, &#39;tab:grey&#39;, &#39;tab:pink&#39;, &#39;tab:olive&#39;]columns = [&#39;psavert&#39;, &#39;uempmed&#39;]# Draw Plotfig, ax = plt.subplots(1, 1, figsize=(16, 9), dpi=80)ax.fill_between(x, y1=y1, y2=0, label=columns[1], alpha=0.5, color=mycolors[1], linewidth=2)ax.fill_between(x, y1=y2, y2=0, label=columns[0], alpha=0.5, color=mycolors[0], linewidth=2)# Decorationsax.set_title(&#39;Personal Savings Rate vs Median Duration of Unemployment&#39;, fontsize=18)ax.set(ylim=[0, 30])ax.legend(loc=&#39;best&#39;, fontsize=12)plt.xticks(x[::50], fontsize=10, horizontalalignment=&#39;center&#39;)plt.yticks(np.arange(2.5, 30.0, 2.5), fontsize=10)plt.xlim(-10, x[-1])# Draw Tick linesfor y in np.arange(2.5, 30.0, 2.5):    plt.hlines(y, xmin=0, xmax=len(x), colors=&#39;black&#39;, alpha=0.3, linestyles=&quot;--&quot;, lw=0.5)# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(0)plt.gca().spines[&quot;bottom&quot;].set_alpha(.3)plt.gca().spines[&quot;right&quot;].set_alpha(0)plt.gca().spines[&quot;left&quot;].set_alpha(.3)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/50.png" alt="50"></p><h3 id="【45】日历热力图（Calendar-Heat-Map）"><a href="#【45】日历热力图（Calendar-Heat-Map）" class="headerlink" title="【45】日历热力图（Calendar Heat Map）"></a><font color=##4876FF>【45】日历热力图（Calendar Heat Map）</font></h3><p>与时间序列相比，日历地图是另一种基于时间的数据可视化的不太受欢迎的方法。虽然在视觉上很吸引人，但数值并不十分明显。然而，它能很好地描绘极端值和假日效果。</p><p>【译者 TRHX 注：在使用该方法时要先安装 calmap 库】</p><pre><code class="python">import matplotlib as mplimport calmap# Import Datadf = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/yahoo.csv&quot;, parse_dates=[&#39;date&#39;])df.set_index(&#39;date&#39;, inplace=True)# Plotplt.figure(figsize=(16, 10), dpi=80)calmap.calendarplot(df[&#39;2014&#39;][&#39;VIX.Close&#39;], fig_kws=&#123;&#39;figsize&#39;: (16, 10)&#125;,                    yearlabel_kws=&#123;&#39;color&#39;: &#39;black&#39;, &#39;fontsize&#39;: 14&#125;, subplot_kws=&#123;&#39;title&#39;: &#39;Yahoo Stock Prices&#39;&#125;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/51.png" alt="51"></p><h3 id="【46】季节图（Seasonal-Plot）"><a href="#【46】季节图（Seasonal-Plot）" class="headerlink" title="【46】季节图（Seasonal Plot）"></a><font color=##4876FF>【46】季节图（Seasonal Plot）</font></h3><p>季节图可用于比较上一季度同一天（年/月/周等）时间序列的表现。</p><pre><code class="python">from dateutil.parser import parse# Import Datadf = pd.read_csv(&#39;https://github.com/selva86/datasets/raw/master/AirPassengers.csv&#39;)# Prepare datadf[&#39;year&#39;] = [parse(d).year for d in df.date]df[&#39;month&#39;] = [parse(d).strftime(&#39;%b&#39;) for d in df.date]years = df[&#39;year&#39;].unique()# 译者 TRHX 添加了该行代码df.rename(columns=&#123;&#39;value&#39;: &#39;traffic&#39;&#125;, inplace=True)# Draw Plotmycolors = [&#39;tab:red&#39;, &#39;tab:blue&#39;, &#39;tab:green&#39;, &#39;tab:orange&#39;, &#39;tab:brown&#39;, &#39;tab:grey&#39;, &#39;tab:pink&#39;, &#39;tab:olive&#39;,            &#39;deeppink&#39;, &#39;steelblue&#39;, &#39;firebrick&#39;, &#39;mediumseagreen&#39;]plt.figure(figsize=(16, 10), dpi=80)for i, y in enumerate(years):    plt.plot(&#39;month&#39;, &#39;traffic&#39;, data=df.loc[df.year == y, :], color=mycolors[i], label=y)    plt.text(df.loc[df.year == y, :].shape[0] - .9, df.loc[df.year == y, &#39;traffic&#39;][-1:].values[0], y, fontsize=12,             color=mycolors[i])# Decorationplt.ylim(50, 750)plt.xlim(-0.3, 11)plt.ylabel(&#39;$Air Traffic$&#39;)plt.yticks(fontsize=12, alpha=.7)plt.title(&quot;Monthly Seasonal Plot: Air Passengers Traffic (1949 - 1969)&quot;, fontsize=22)plt.grid(axis=&#39;y&#39;, alpha=.3)# Remove bordersplt.gca().spines[&quot;top&quot;].set_alpha(0.0)plt.gca().spines[&quot;bottom&quot;].set_alpha(0.5)plt.gca().spines[&quot;right&quot;].set_alpha(0.0)plt.gca().spines[&quot;left&quot;].set_alpha(0.5)# plt.legend(loc=&#39;upper right&#39;, ncol=2, fontsize=12)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/52.png" alt="52"></p><h2 id="【9x00】分组（-Groups）"><a href="#【9x00】分组（-Groups）" class="headerlink" title="【9x00】分组（ Groups）"></a><font color=#FF0000>【9x00】分组（ Groups）</font></h2><h3 id="【47】树状图（Dendrogram）"><a href="#【47】树状图（Dendrogram）" class="headerlink" title="【47】树状图（Dendrogram）"></a><font color=##4876FF>【47】树状图（Dendrogram）</font></h3><p>树状图根据给定的距离度量将相似的点组合在一起，并根据点的相似性将它们组织成树状链接。</p><pre><code class="python">import scipy.cluster.hierarchy as shc# Import Datadf = pd.read_csv(&#39;https://raw.githubusercontent.com/selva86/datasets/master/USArrests.csv&#39;)# Plotplt.figure(figsize=(16, 10), dpi=80)plt.title(&quot;USArrests Dendograms&quot;, fontsize=22)dend = shc.dendrogram(shc.linkage(df[[&#39;Murder&#39;, &#39;Assault&#39;, &#39;UrbanPop&#39;, &#39;Rape&#39;]], method=&#39;ward&#39;), labels=df.State.values,                      color_threshold=100)plt.xticks(fontsize=12)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/53.png" alt="53"></p><h3 id="【48】聚类图（Cluster-Plot）"><a href="#【48】聚类图（Cluster-Plot）" class="headerlink" title="【48】聚类图（Cluster Plot）"></a><font color=##4876FF>【48】聚类图（Cluster Plot）</font></h3><p>聚类图可以用来划分属于同一个聚类的点。下面是一个基于 USArrests 数据集将美国各州分成 5 组的代表性示例。这个聚类图使用 ‘murder’ 和 ‘assault’ 作为 X 轴和 Y 轴。或者，您可以将第一个主元件用作 X 轴和 Y 轴。</p><p>【译者 TRHX 注：在使用该方法时要先安装 sklearn 库】</p><pre><code class="python">from sklearn.cluster import AgglomerativeClusteringfrom scipy.spatial import ConvexHull# Import Datadf = pd.read_csv(&#39;https://raw.githubusercontent.com/selva86/datasets/master/USArrests.csv&#39;)# Agglomerative Clusteringcluster = AgglomerativeClustering(n_clusters=5, affinity=&#39;euclidean&#39;, linkage=&#39;ward&#39;)cluster.fit_predict(df[[&#39;Murder&#39;, &#39;Assault&#39;, &#39;UrbanPop&#39;, &#39;Rape&#39;]])# Plotplt.figure(figsize=(14, 10), dpi=80)plt.scatter(df.iloc[:, 0], df.iloc[:, 1], c=cluster.labels_, cmap=&#39;tab10&#39;)# Encircledef encircle(x, y, ax=None, **kw):    if not ax: ax = plt.gca()    p = np.c_[x, y]    hull = ConvexHull(p)    poly = plt.Polygon(p[hull.vertices,:], **kw)    ax.add_patch(poly)# Draw polygon surrounding verticesencircle(df.loc[cluster.labels_ == 0, &#39;Murder&#39;], df.loc[cluster.labels_ == 0, &#39;Assault&#39;], ec=&quot;k&quot;, fc=&quot;gold&quot;, alpha=0.2, linewidth=0)encircle(df.loc[cluster.labels_ == 1, &#39;Murder&#39;], df.loc[cluster.labels_ == 1, &#39;Assault&#39;], ec=&quot;k&quot;, fc=&quot;tab:blue&quot;, alpha=0.2, linewidth=0)encircle(df.loc[cluster.labels_ == 2, &#39;Murder&#39;], df.loc[cluster.labels_ == 2, &#39;Assault&#39;], ec=&quot;k&quot;, fc=&quot;tab:red&quot;, alpha=0.2, linewidth=0)encircle(df.loc[cluster.labels_ == 3, &#39;Murder&#39;], df.loc[cluster.labels_ == 3, &#39;Assault&#39;], ec=&quot;k&quot;, fc=&quot;tab:green&quot;, alpha=0.2, linewidth=0)encircle(df.loc[cluster.labels_ == 4, &#39;Murder&#39;], df.loc[cluster.labels_ == 4, &#39;Assault&#39;], ec=&quot;k&quot;, fc=&quot;tab:orange&quot;, alpha=0.2, linewidth=0)# Decorationsplt.xlabel(&#39;Murder&#39;); plt.xticks(fontsize=12)plt.ylabel(&#39;Assault&#39;); plt.yticks(fontsize=12)plt.title(&#39;Agglomerative Clustering of USArrests (5 Groups)&#39;, fontsize=22)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/54.png" alt="54"></p><h3 id="【49】安德鲁斯曲线（Andrews-Curve）"><a href="#【49】安德鲁斯曲线（Andrews-Curve）" class="headerlink" title="【49】安德鲁斯曲线（Andrews Curve）"></a><font color=##4876FF>【49】安德鲁斯曲线（Andrews Curve）</font></h3><p>安德鲁斯曲线有助于可视化是否存在基于给定分组的数值特征的固有分组。如果特征（数据集中的列）不能帮助区分组（cyl），则行将不会像下图所示被很好地分隔开。</p><pre><code class="python">from pandas.plotting import andrews_curves# Importdf = pd.read_csv(&quot;https://github.com/selva86/datasets/raw/master/mtcars.csv&quot;)df.drop([&#39;cars&#39;, &#39;carname&#39;], axis=1, inplace=True)# Plotplt.figure(figsize=(12, 9), dpi=80)andrews_curves(df, &#39;cyl&#39;, colormap=&#39;Set1&#39;)# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(0)plt.gca().spines[&quot;bottom&quot;].set_alpha(.3)plt.gca().spines[&quot;right&quot;].set_alpha(0)plt.gca().spines[&quot;left&quot;].set_alpha(.3)plt.title(&#39;Andrews Curves of mtcars&#39;, fontsize=22)plt.xlim(-3, 3)plt.grid(alpha=0.3)plt.xticks(fontsize=12)plt.yticks(fontsize=12)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/55.png" alt="55"></p><h3 id="【50】平行坐标图（Parallel-Coordinates）"><a href="#【50】平行坐标图（Parallel-Coordinates）" class="headerlink" title="【50】平行坐标图（Parallel Coordinates）"></a><font color=##4876FF>【50】平行坐标图（Parallel Coordinates）</font></h3><p>平行坐标有助于可视化功能是否有助于有效地隔离组。如果一个分离受到影响，则该特征可能在预测该组时非常有用。</p><pre><code class="python">from pandas.plotting import parallel_coordinates# Import Datadf_final = pd.read_csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/diamonds_filter.csv&quot;)# Plotplt.figure(figsize=(12, 9), dpi=80)parallel_coordinates(df_final, &#39;cut&#39;, colormap=&#39;Dark2&#39;)# Lighten bordersplt.gca().spines[&quot;top&quot;].set_alpha(0)plt.gca().spines[&quot;bottom&quot;].set_alpha(.3)plt.gca().spines[&quot;right&quot;].set_alpha(0)plt.gca().spines[&quot;left&quot;].set_alpha(.3)plt.title(&#39;Parallel Coordinated of Diamonds&#39;, fontsize=22)plt.grid(alpha=0.3)plt.xticks(fontsize=12)plt.yticks(fontsize=12)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A78/56.png" alt="56"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本译文首发于 CSDN，作者 Selva Prabhakaran，译者 TRHX。本文链接：https://itrhx.blog.csdn.net/article/details/106558131原文链接：https://www.machinelearningplus.com/plots/top-50-matplotlib-visualizations-the-master-plots-python/</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Matplotlib（十）：3D 图的绘制</title>
      <link href="/article/023/"/>
      <url>/article/023/</url>
      
        <content type="html"><![CDATA[<p>Matplotlib 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/014/">Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</a></li><li><a href="https://www.itbob.cn/article/015/">Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/016/">Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/017/">Python 数据分析三剑客之 Matplotlib（四）：线性图的绘制</a></li><li><a href="https://www.itbob.cn/article/018/">Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制</a></li><li><a href="https://www.itbob.cn/article/019/">Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制</a></li><li><a href="https://www.itbob.cn/article/020/">Python 数据分析三剑客之 Matplotlib（七）：饼状图的绘制</a></li><li><a href="https://www.itbob.cn/article/021/">Python 数据分析三剑客之 Matplotlib（八）：等高线 / 等值线图的绘制</a></li><li><a href="https://www.itbob.cn/article/022/">Python 数据分析三剑客之 Matplotlib（九）：极区图 / 极坐标图 / 雷达图的绘制</a></li><li><a href="https://www.itbob.cn/article/023/">Python 数据分析三剑客之 Matplotlib（十）：3D 图的绘制</a></li><li><a href="https://www.itbob.cn/article/024/">Python 数据分析三剑客之 Matplotlib（十一）：最热门最常用的 50 个图表</a>【译文】</li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106558131未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01x00】了解-mplot3d-Toolkit"><a href="#【01x00】了解-mplot3d-Toolkit" class="headerlink" title="【01x00】了解 mplot3d Toolkit"></a><font color=#FF0000>【01x00】了解 mplot3d Toolkit</font></h2><p>mplot3d Toolkit 即 mplot3d 工具包，在 matplotlib 中使用 mplot3d 工具包可以绘制 3D 图。</p><p>mplot3d 官方文档：<a href="https://matplotlib.org/tutorials/toolkits/mplot3d.html">https://matplotlib.org/tutorials/toolkits/mplot3d.html</a></p><p>在 matplotlib 中，figure 为画布，axes 为绘图区，<code>fig.add_subplot()</code>、<code>plt.subplot()</code> 方法均可以创建子图，在绘制 3D 图时，某些 2D 图的参数也适用于 3D 图，在本文的示例中，可能会用到的一些没有具体解释的函数或者参数，其用法均可在前面的系列文章中找到：</p><ul><li><p><a href="https://itrhx.blog.csdn.net/article/details/105638122">《Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件》</a> </p></li><li><p><a href="https://itrhx.blog.csdn.net/article/details/105828049">《Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性》</a></p></li><li><p><a href="https://itrhx.blog.csdn.net/article/details/105828143">《Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性》</a></p></li></ul><p><font color=#FF0000><strong>绘制 3D 图的步骤：创建 Axes3D 对象，然后调用 Axes3D 的不同方法来绘制不同类型的 3D 图。以下介绍三种 Axes3D 对象创建的方法。</strong></font></p><h3 id="【01x01】Axes3D-对象创建方法一：Axes3D-fig"><a href="#【01x01】Axes3D-对象创建方法一：Axes3D-fig" class="headerlink" title="【01x01】Axes3D 对象创建方法一：Axes3D(fig)"></a><font color=##4876FF>【01x01】Axes3D 对象创建方法一：Axes3D(fig)</font></h3><p>在 Matplotlib 1.0.0 版本中，绘制 3D 图需要先导入 Axes3D 包，获取 figure 画布对象 fig 后，通过 Axes3D(fig) 方法来创建 Axes3D 对象，具体方法如下：</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3D# 获取 figure 画布并创建 Axes3D 对象fig = plt.figure()ax = Axes3D(fig)# 数据坐标z = np.linspace(0, 15, 1000)x = np.sin(z)y = np.cos(z)# 绘制线性图ax.plot(x, y, z)plt.show()</code></pre><h3 id="【01x02】Axes3D-对象创建方法二：add-subplot"><a href="#【01x02】Axes3D-对象创建方法二：add-subplot" class="headerlink" title="【01x02】Axes3D 对象创建方法二：add_subplot"></a><font color=##4876FF>【01x02】Axes3D 对象创建方法二：add_subplot</font></h3><p>在 Matplotlib 3.2.0 版本中，绘制 3D 图可以通过创建子图，然后指定 projection 参数 为 3d 即可，返回的 ax 为 Axes3D 对象，以下两种方法均可：</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as plt# 获取 figure 画布并通过子图创建 Axes3D 对象fig = plt.figure()ax = fig.add_subplot(111, projection=&#39;3d&#39;)# 数据坐标z = np.linspace(0, 15, 1000)x = np.sin(z)y = np.cos(z)# 绘制线性图ax.plot(x, y, z)plt.show()</code></pre><pre><code class="python">import numpy as npimport matplotlib.pyplot as plt# 通过子图创建 Axes3D 对象ax = plt.subplot(111, projection=&#39;3d&#39;)# 数据坐标z = np.linspace(0, 15, 1000)x = np.sin(z)y = np.cos(z)# 绘制线性图ax.plot(x, y, z)plt.show()</code></pre><h3 id="【01x03】Axes3D-对象创建方法三：gca"><a href="#【01x03】Axes3D-对象创建方法三：gca" class="headerlink" title="【01x03】Axes3D 对象创建方法三：gca"></a><font color=##4876FF>【01x03】Axes3D 对象创建方法三：gca</font></h3><p>除了以上两种方法以外，还可以先获取画布对象 fig，再通过 <code>fig.gca()</code> 方法获取当前绘图区（gca = Get Current Axes），然后指定 projection 参数 为 3d 即可，返回的 ax 为 Axes3D 对象。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as plt# 依次获取画布和绘图区并创建 Axes3D 对象fig = plt.figure()ax = fig.gca(projection=&#39;3d&#39;)# 数据坐标z = np.linspace(0, 15, 1000)x = np.sin(z)y = np.cos(z)# 绘制线性图ax.plot(x, y, z)plt.show()</code></pre><p>以上三种方法运行结果均为下图：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/01.png" alt="01"></p><h2 id="【02x00】cmap-与-colorbar"><a href="#【02x00】cmap-与-colorbar" class="headerlink" title="【02x00】cmap 与 colorbar"></a><font color=#FF0000>【02x00】cmap 与 colorbar</font></h2><p>默认情况下，散点图、线性图、曲面图等将以纯色着色，但可以通过提供 cmap 参数支持颜色映射。cmap 参数用于设置一些特殊的颜色组合，如渐变色等，参数取值通常为 Colormap 中的值，具体取值可参见下图：</p><p>官方文档：<a href="https://matplotlib.org/tutorials/colors/colormaps.html">https://matplotlib.org/tutorials/colors/colormaps.html</a></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/02.png" alt="02"></p><p>如果使用了 cmap 参数，则可以使用 <code>pyplot.colorbar()</code> 函数来绘制一个色条，即颜色对照条。</p><p>基本语法：<code>matplotlib.pyplot.colorbar([mappable=None, cax=None, ax=None, **kw])</code></p><p>部分参数解释如下表，其他参数，如长度，宽度等请参考<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.colorbar.html">官方文档</a>。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>mappable</td><td>要设置色条的图像对象，该参数对于 <code>Figure.colorbar</code> 方法是必需的，但对于 <code>pyplot.colorbar</code> 函数是可选的</td></tr><tr><td>cax</td><td>可选项，要绘制色条的轴</td></tr><tr><td>ax</td><td>可选项，设置色条的显示位置，通常在一个画布上有多个子图时使用</td></tr><tr><td>**kw</td><td>可选项，其他关键字参数，参考<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.colorbar.html">官方文档</a></td></tr></tbody></table><h2 id="【03x00】3D-线性图：Axes3D-plot"><a href="#【03x00】3D-线性图：Axes3D-plot" class="headerlink" title="【03x00】3D 线性图：Axes3D.plot"></a><font color=#FF0000>【03x00】3D 线性图：Axes3D.plot</font></h2><p>基本方法：<code>Axes3D.plot(xs, ys[, zs, zdir=&#39;z&#39;, *args, **kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>xs</td><td>一维数组，点的 x 轴坐标</td></tr><tr><td>ys</td><td>一维数组，点的 y 轴坐标</td></tr><tr><td>zs</td><td>一维数组，可选项，点的 z 轴坐标</td></tr><tr><td>zdir</td><td>可选项，在 3D 轴上绘制 2D 数据时，数据必须以 xs，ys 的形式传递，<br>若此时将 zdir 设置为 ‘y’，数据将会被绘制到 x-z 轴平面上，默认为 ‘z’</td></tr><tr><td>**kwargs</td><td>其他关键字参数，可选项，可参见 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.plot.html">matplotlib.axes.Axes.plot</a></td></tr></tbody></table><pre><code class="python">import numpy as npimport matplotlib.pyplot as plt# 设置中文显示plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 依次获取画布和绘图区并创建 Axes3D 对象fig = plt.figure()ax = fig.gca(projection=&#39;3d&#39;)# 第一条3D线性图数据theta = np.linspace(-4 * np.pi, 4 * np.pi, 100)z1 = np.linspace(-2, 2, 100)r = z1**2 + 1x1 = r * np.sin(theta)y1 = r * np.cos(theta)# 第二条3D线性图数据z2 = np.linspace(-3, 3, 100)x2 = np.sin(z2)y2 = np.cos(z2)# 绘制3D线性图ax.plot(x1, y1, z1, color=&#39;b&#39;, label=&#39;3D 线性图一&#39;)ax.plot(x2, y2, z2, color=&#39;r&#39;, label=&#39;3D 线性图二&#39;)# 设置标题、轴标签、图例，也可以直接使用 plt.title、plt.xlabel、plt.legend...ax.set_title(&#39;绘制 3D 线性图示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;x 轴&#39;, color=&#39;r&#39;, fontsize=&#39;12&#39;)ax.set_ylabel(&#39;y 轴&#39;, color=&#39;g&#39;, fontsize=&#39;12&#39;)ax.set_zlabel(&#39;z 轴&#39;, color=&#39;b&#39;, fontsize=&#39;12&#39;)ax.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/03.png" alt="03"></p><h2 id="【04x00】3D-散点图：Axes3D-scatter"><a href="#【04x00】3D-散点图：Axes3D-scatter" class="headerlink" title="【04x00】3D 散点图：Axes3D.scatter"></a><font color=#FF0000>【04x00】3D 散点图：Axes3D.scatter</font></h2><p>基本方法：<code>Axes3D.scatter(xs, ys[, zs=0, zdir=&#39;z&#39;, s=20, c=None, depthshade=True, *args, **kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>xs</td><td>一维数组，点的 x 轴坐标</td></tr><tr><td>ys</td><td>一维数组，点的 y 轴坐标</td></tr><tr><td>zs</td><td>一维数组，可选项，点的 z 轴坐标</td></tr><tr><td>zdir</td><td>可选项，在 3D 轴上绘制 2D 数据时，数据必须以 xs，ys 的形式传递，<br>若此时将 zdir 设置为 ‘y’，数据将会被绘制到 x-z 轴平面上，默认为 ‘z’</td></tr><tr><td>s</td><td>标量或数组类型，可选项，标记的大小，默认 20</td></tr><tr><td>c</td><td>标记的颜色，可选项，可以是单个颜色或者一个颜色列表<br>支持英文颜色名称及其简写、十六进制颜色码等，更多颜色示例参见官网 <a href="https://matplotlib.org/gallery/color/color_demo.html">Color Demo</a></td></tr><tr><td>depthshade</td><td>bool 值，可选项，默认 True，是否为散点标记着色以提供深度外观</td></tr><tr><td>**kwargs</td><td>其他关键字参数，可选项，可参见 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.scatter.html">scatter</a></td></tr></tbody></table><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 依次获取画布和绘图区并创建 Axes3D 对象fig = plt.figure()ax = fig.gca(projection=&#39;3d&#39;)n = 100def randrange(n, vmin, vmax):    return (vmax - vmin)*np.random.rand(n) + vmin&#39;&#39;&#39;定义绘制 n 个随机点，设置每一组数据点的样式和范围x轴数据位于[23，32]区间，y轴数据位于[0，100]区间，z轴数据位于[zlow，zhigh]区间&#39;&#39;&#39;for m, zlow, zhigh in [(&#39;o&#39;, -50, -25), (&#39;^&#39;, -30, -5)]:    xs = randrange(n, 23, 32)    ys = randrange(n, 0, 100)    zs = randrange(n, zlow, zhigh)    ax.scatter(xs, ys, zs, marker=m)# 设置标题、轴标签、图例，也可以直接使用 plt.title、plt.xlabel...ax.set_title(&#39;绘制 3D 散点图示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;x 轴&#39;, color=&#39;b&#39;)ax.set_ylabel(&#39;y 轴&#39;, color=&#39;b&#39;)ax.set_zlabel(&#39;z 轴&#39;, color=&#39;b&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/04.png" alt="04"></p><h2 id="【05x00】3D-线框图：Axes3D-plot-wireframe"><a href="#【05x00】3D-线框图：Axes3D-plot-wireframe" class="headerlink" title="【05x00】3D 线框图：Axes3D.plot_wireframe"></a><font color=#FF0000>【05x00】3D 线框图：Axes3D.plot_wireframe</font></h2><p>基本方法：<code>Axes3D.plot_wireframe(X, Y, Z[, *args, **kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>X</td><td>二维数组，x 轴数据</td></tr><tr><td>Y</td><td>二维数组，y 轴数据</td></tr><tr><td>Z</td><td>二维数组，z 轴数据</td></tr><tr><td>**kwargs</td><td>其他关键字参数，可选项，如线条样式颜色等，可参见 <a href="https://matplotlib.org/api/_as_gen/mpl_toolkits.mplot3d.art3d.Line3DCollection.html">Line3DCollection</a></td></tr></tbody></table><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 获取 figure 画布并通过子图创建 Axes3D 对象fig = plt.figure()ax = fig.add_subplot(111, projection=&#39;3d&#39;)# 定义Z轴坐标的生成方法def f(m, n):    return np.sin(np.sqrt(m ** 2 + n ** 2))# 设置3D线框图数据x = np.linspace(-6, 6, 30)y = np.linspace(-6, 6, 30)# 生成网格点坐标矩阵，该方法在系列文章八中有具体介绍X, Y = np.meshgrid(x, y)Z = f(X, Y)# 绘制3D线框图ax.plot_wireframe(X, Y, Z, color=&#39;c&#39;)# 设置标题、轴标签、图例，也可以直接使用 plt.title、plt.xlabel...ax.set_title(&#39;绘制 3D 线框图示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;x 轴&#39;)ax.set_ylabel(&#39;y 轴&#39;)ax.set_zlabel(&#39;z 轴&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/05.png" alt="05"></p><h2 id="【06x00】3D-曲面图：Axes3D-plot-surface"><a href="#【06x00】3D-曲面图：Axes3D-plot-surface" class="headerlink" title="【06x00】3D 曲面图：Axes3D.plot_surface"></a><font color=#FF0000>【06x00】3D 曲面图：Axes3D.plot_surface</font></h2><p>基本方法：<code>Axes3D.plot_surface(X, Y, Z[, *args, vmin=None, vmax=None, **kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>X</td><td>二维数组，x 轴数据</td></tr><tr><td>Y</td><td>二维数组，y 轴数据</td></tr><tr><td>Z</td><td>二维数组，z 轴数据</td></tr><tr><td>vmin / vmax</td><td>规定数据界限</td></tr><tr><td>**kwargs</td><td>其他关键字参数，可选项，如线条样式颜色等，可参见 <a href="https://matplotlib.org/api/_as_gen/mpl_toolkits.mplot3d.art3d.Line3DCollection.html">Line3DCollection</a></td></tr></tbody></table><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 获取 figure 画布并通过子图创建 Axes3D 对象fig = plt.figure()ax = fig.add_subplot(111, projection=&#39;3d&#39;)# 设置3D曲面图数据X = np.arange(-5, 5, 0.25)Y = np.arange(-5, 5, 0.25)# 生成网格点坐标矩阵，该方法在系列文章八中有具体介绍X, Y = np.meshgrid(X, Y)R = np.sqrt(X**2 + Y**2)Z = np.sin(R)# 绘制3D曲面图并添加色条（长度0.8）surface = ax.plot_surface(X, Y, Z, cmap=&#39;rainbow&#39;, antialiased=False)fig.colorbar(surface, shrink=0.8)# 设置标题、轴标签、图例，也可以直接使用 plt.title、plt.xlabel...ax.set_title(&#39;绘制 3D 曲面图示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;x 轴&#39;)ax.set_ylabel(&#39;y 轴&#39;)ax.set_zlabel(&#39;z 轴&#39;)# 调整观察角度和方位角，俯仰角25度，方位角40度ax.view_init(25, 40)# 设置Z轴刻度界限ax.set_zlim(-2, 2)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/06.png" alt="06"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106558131未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【07x00】3D-柱状图：Axes3D-bar"><a href="#【07x00】3D-柱状图：Axes3D-bar" class="headerlink" title="【07x00】3D 柱状图：Axes3D.bar"></a><font color=#FF0000>【07x00】3D 柱状图：Axes3D.bar</font></h2><p>基本方法：<code>Axes3D.bar(left, height, zs=0, zdir=&#39;z&#39;, *args, **kwargs)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>一维数组，柱状图最左侧位置的 x 坐标</td></tr><tr><td>height</td><td>一维数组，柱状图的高度（y 坐标）</td></tr><tr><td>zs</td><td>第 i 个多边形将出现在平面 y=zs[i] 上</td></tr><tr><td>zdir</td><td>可选项，在 3D 轴上绘制 2D 数据时，数据必须以 xs，ys 的形式传递，<br>若此时将 zdir 设置为 ‘y’，数据将会被绘制到 x-z 轴平面上，默认为 ‘z’</td></tr><tr><td>**kwargs</td><td>其他关键字参数，参见 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.bar.html">matplotlib.axes.Axes.bar</a></td></tr></tbody></table><pre><code class="python">import matplotlib.pyplot as pltimport numpy as npplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 获取 figure 画布并通过子图创建 Axes3D 对象fig = plt.figure()ax = fig.add_subplot(111, projection=&#39;3d&#39;)colors = [&#39;r&#39;, &#39;g&#39;, &#39;b&#39;, &#39;y&#39;]yticks = [3, 2, 1, 0]# 设置3D柱状图数据并绘制图像for c, k in zip(colors, yticks):    xs = np.arange(20)    ys = np.random.rand(20)    cs = [c] * len(xs)    ax.bar(xs, ys, zs=k, zdir=&#39;y&#39;, color=cs, alpha=0.8)# 设置图像标题、坐标标签以及范围ax.set_title(&#39;绘制 3D 柱状图示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;X 轴&#39;)ax.set_ylabel(&#39;Y 轴&#39;)ax.set_zlabel(&#39;Z 轴&#39;)ax.set_yticks(yticks)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/07.png" alt="07"></p><h2 id="【08x00】3D-箭头图：Axes3D-quiver"><a href="#【08x00】3D-箭头图：Axes3D-quiver" class="headerlink" title="【08x00】3D 箭头图：Axes3D.quiver"></a><font color=#FF0000>【08x00】3D 箭头图：Axes3D.quiver</font></h2><p>基本方法：<code>Axes3D.quiver(X, Y, Z, U, V, W, length=1, arrow_length_ratio=0.3, pivot=&#39;tail&#39;, normalize=False, **kwargs)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>X, Y, Z</td><td>数组形式，箭头位置的 x、y 和 z 轴坐标（默认为箭头尾部）</td></tr><tr><td>U, V, W</td><td>数组形式，箭头向量的 x、y 和 z 轴分量</td></tr><tr><td>length</td><td>float 类型，每个箭筒的长度，默认为 1.0</td></tr><tr><td>arrow_length_ratio</td><td>float 类型，箭头相对于箭身的比率，默认为 0.3</td></tr><tr><td>pivot</td><td>箭头在网格点上的位置；箭头围绕该点旋转，因此命名为 pivot，默认为 ‘tail’<br>可选项：<code>&#39;tail&#39;</code>：尾部；<code>&#39;middle&#39;</code>：中间；<code>&#39;tip&#39;</code>：尖端</td></tr><tr><td>normalize</td><td>bool 类型，如果为 True，则所有箭头的长度都将相同<br>默认为 False，即箭头的长度取决于 U、V、W 的值</td></tr><tr><td>**kwargs</td><td>其他关键字参数，参见 <a href="https://matplotlib.org/api/collections_api.html#matplotlib.collections.LineCollection">LineCollection</a></td></tr></tbody></table><pre><code class="python">import matplotlib.pyplot as pltimport numpy as npplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 依次获取画布和绘图区并创建 Axes3D 对象fig = plt.figure()ax = fig.gca(projection=&#39;3d&#39;)# 设置箭头位置x, y, z = np.meshgrid(np.arange(-0.8, 1, 0.2),                      np.arange(-0.8, 1, 0.2),                      np.arange(-0.8, 1, 0.8))# 设置箭头数据u = np.sin(np.pi * x) * np.cos(np.pi * y) * np.cos(np.pi * z)v = -np.cos(np.pi * x) * np.sin(np.pi * y) * np.cos(np.pi * z)w = (np.sqrt(2.0 / 3.0) * np.cos(np.pi * x) * np.cos(np.pi * y) * np.sin(np.pi * z))# 绘制 3D 箭头图ax.quiver(x, y, z, u, v, w, length=0.1, normalize=True)# 设置图像标题、坐标标签ax.set_title(&#39;绘制 3D 箭头图示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;X 轴&#39;)ax.set_ylabel(&#39;Y 轴&#39;)ax.set_zlabel(&#39;Z 轴&#39;)# 调整观察角度，俯仰角20度ax.view_init(20)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/08.png" alt="08"></p><h2 id="【09x00】3D-等高线图：Axes3D-contour"><a href="#【09x00】3D-等高线图：Axes3D-contour" class="headerlink" title="【09x00】3D 等高线图：Axes3D.contour"></a><font color=#FF0000>【09x00】3D 等高线图：Axes3D.contour</font></h2><p>基本方法：<code>Axes3D.contour(X, Y, Z[, *args, extend3d=False, stride=5, zdir=&#39;z&#39;, offset=None, **kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>X</td><td>一维数组，x 轴数据</td></tr><tr><td>Y</td><td>一维数组，y 轴数据</td></tr><tr><td>Z</td><td>一维数组，z 轴数据</td></tr><tr><td>extend3d</td><td>bool 值，可选项，是否以 3D 延伸轮廓，默认 False</td></tr><tr><td>stride</td><td>int 类型，可选项，用于延伸轮廓的步长</td></tr><tr><td>zdir</td><td>可选项，在 3D 轴上绘制 2D 数据时，数据必须以 xs，ys 的形式传递，<br>若此时将 zdir 设置为 ‘y’，数据将会被绘制到 x-z 轴平面上，默认为 ‘z’</td></tr><tr><td>offset</td><td>标量，可选项，如果指定，则在垂直于 zdir 的平面上的位置绘制轮廓线的投影</td></tr><tr><td>**kwargs</td><td>其他关键字参数，可选项，可参见 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.contour.html">matplotlib.axes.Axes.contour</a></td></tr></tbody></table><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 获取 figure 画布并通过子图创建 Axes3D 对象fig = plt.figure(figsize=(8, 4.8))ax = fig.add_subplot(111, projection=&#39;3d&#39;)# 设置等高线数据X = np.arange(-2.0, 2.0, 0.01)Y = np.arange(-2.0, 2.0, 0.01)# 生成网格点坐标矩阵m, n = np.meshgrid(X, Y)# 指定一个函数用于计算每个点的高度，也可以直接使用二维数组储存每个点的高度def f(a, b):    return (1 - b ** 5 + a ** 5) * np.exp(-a ** 2 - b ** 2)# 绘制3D等高线图并添加色条图（长度0.8）contour = ax.contour(X, Y, f(m, n), cmap=&#39;rainbow&#39;)fig.colorbar(contour, shrink=0.8)# 设置标题、轴标签、图例，也可以直接使用 plt.title、plt.xlabel...ax.set_title(&#39;绘制 3D 等高线图示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;x 轴&#39;)ax.set_ylabel(&#39;y 轴&#39;)ax.set_zlabel(&#39;z 轴&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/09.png" alt="09"></p><h2 id="【10x00】3D-等高线填充图：Axes3D-contourf"><a href="#【10x00】3D-等高线填充图：Axes3D-contourf" class="headerlink" title="【10x00】3D 等高线填充图：Axes3D.contourf"></a><font color=#FF0000>【10x00】3D 等高线填充图：Axes3D.contourf</font></h2><p>基本语法：<code>Axes3D.contourf(X, Y, Z[, *args, zdir=&#39;z&#39;, offset=None, **kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>X</td><td>一维数组，x 轴数据</td></tr><tr><td>Y</td><td>一维数组，y 轴数据</td></tr><tr><td>Z</td><td>一维数组，z 轴数据</td></tr><tr><td>zdir</td><td>可选项，在 3D 轴上绘制 2D 数据时，数据必须以 xs，ys 的形式传递，<br>若此时将 zdir 设置为 ‘y’，数据将会被绘制到 x-z 轴平面上，默认为 ‘z’</td></tr><tr><td>offset</td><td>标量，可选项，如果指定，则在垂直于 zdir 的平面上的位置绘制轮廓线的投影</td></tr><tr><td>**kwargs</td><td>其他关键字参数，可选项，可参见 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.contourf.html">matplotlib.axes.Axes.contourf</a></td></tr></tbody></table><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 获取 figure 画布并通过子图创建 Axes3D 对象fig = plt.figure(figsize=(8, 4.8))ax = fig.add_subplot(111, projection=&#39;3d&#39;)# 设置等高线数据X = np.arange(-2.0, 2.0, 0.01)Y = np.arange(-2.0, 2.0, 0.01)# 生成网格点坐标矩阵m, n = np.meshgrid(X, Y)# 指定一个函数用于计算每个点的高度，也可以直接使用二维数组储存每个点的高度def f(a, b):    return (1 - b ** 5 + a ** 5) * np.exp(-a ** 2 - b ** 2)# 绘制3D等高线图并添加色条图（长度0.8）contourf = ax.contourf(X, Y, f(m, n), cmap=&#39;rainbow&#39;)fig.colorbar(contourf, shrink=0.8)# 设置标题、轴标签、图例，也可以直接使用 plt.title、plt.xlabel...ax.set_title(&#39;绘制 3D 等高线填充图示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;x 轴&#39;)ax.set_ylabel(&#39;y 轴&#39;)ax.set_zlabel(&#39;z 轴&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/10.png" alt="10"></p><h2 id="【11x00】3D-三角曲面图：Axes3D-plot-trisurf"><a href="#【11x00】3D-三角曲面图：Axes3D-plot-trisurf" class="headerlink" title="【11x00】3D 三角曲面图：Axes3D.plot_trisurf"></a><font color=#FF0000>【11x00】3D 三角曲面图：Axes3D.plot_trisurf</font></h2><p>基本方法：<code>Axes3D.plot_trisurf(X, Y, Z[, *args, color=None, vmin=None, vmax=None, **kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>X</td><td>一维数组，x 轴数据</td></tr><tr><td>Y</td><td>一维数组，y 轴数据</td></tr><tr><td>Z</td><td>一维数组，z 轴数据</td></tr><tr><td>color</td><td>曲面表面的颜色</td></tr><tr><td>vmin / vmax</td><td>规定数据界限</td></tr><tr><td>**kwargs</td><td>可选项，其他关键字参数，可参见 <a href="https://matplotlib.org/api/_as_gen/mpl_toolkits.mplot3d.art3d.Poly3DCollection.html">Poly3DCollection</a></td></tr></tbody></table><pre><code class="python">import matplotlib.pyplot as pltimport numpy as npplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 获取 figure 画布并通过子图创建 Axes3D 对象fig = plt.figure()ax = fig.add_subplot(111, projection=&#39;3d&#39;)n_radii = 8n_angles = 36radii = np.linspace(0.125, 1.0, n_radii)angles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)[..., np.newaxis]x = np.append(0, (radii*np.cos(angles)).flatten())y = np.append(0, (radii*np.sin(angles)).flatten())z = np.sin(-x*y)# 绘制3D三角曲面图并添加色条（长度0.8）trisurf = ax.plot_trisurf(x, y, z, cmap=&#39;rainbow&#39;)fig.colorbar(trisurf, shrink=0.8)# 设置标题、轴标签、图例，也可以直接使用 plt.title、plt.xlabel...ax.set_title(&#39;绘制 3D 三角曲面图示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;x 轴&#39;)ax.set_ylabel(&#39;y 轴&#39;)ax.set_zlabel(&#39;z 轴&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/11.png" alt="11"></p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltimport matplotlib.tri as mtriplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]fig = plt.figure(figsize=(15, 6))# ============ 第一个示例图 ============ #ax = fig.add_subplot(1, 2, 1, projection=&#39;3d&#39;)u = np.linspace(0, 2.0 * np.pi, endpoint=True, num=50)v = np.linspace(-0.5, 0.5, endpoint=True, num=10)u, v = np.meshgrid(u, v)u, v = u.flatten(), v.flatten()x = (1 + 0.5 * v * np.cos(u / 2.0)) * np.cos(u)y = (1 + 0.5 * v * np.cos(u / 2.0)) * np.sin(u)z = 0.5 * v * np.sin(u / 2.0)tri = mtri.Triangulation(u, v)trisurf_1 = ax.plot_trisurf(x, y, z, triangles=tri.triangles, cmap=&#39;cool&#39;)fig.colorbar(trisurf_1, shrink=0.8)ax.set_zlim(-1, 1)ax.set_title(&#39;绘制 3D 三角曲面图示例一&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;x 轴&#39;)ax.set_ylabel(&#39;y 轴&#39;)ax.set_zlabel(&#39;z 轴&#39;)# ============ 第二个示例图 ============ #ax = fig.add_subplot(1, 2, 2, projection=&#39;3d&#39;)n_angles = 36n_radii = 8min_radius = 0.25radii = np.linspace(min_radius, 0.95, n_radii)angles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)angles[:, 1::2] += np.pi/n_anglesx = (radii*np.cos(angles)).flatten()y = (radii*np.sin(angles)).flatten()z = (np.cos(radii)*np.cos(3*angles)).flatten()triang = mtri.Triangulation(x, y)xmid = x[triang.triangles].mean(axis=1)ymid = y[triang.triangles].mean(axis=1)mask = xmid**2 + ymid**2 &lt; min_radius**2triang.set_mask(mask)trisurf_2 = ax.plot_trisurf(triang, z, cmap=&#39;hsv&#39;)fig.colorbar(trisurf_2, shrink=0.8)ax.set_title(&#39;绘制 3D 三角曲面图示例二&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;x 轴&#39;)ax.set_ylabel(&#39;y 轴&#39;)ax.set_zlabel(&#39;z 轴&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/12.png" alt="12"></p><h2 id="【12x00】将-2D-图像聚合到-3D-图像中：Axes3D-add-collection3d"><a href="#【12x00】将-2D-图像聚合到-3D-图像中：Axes3D-add-collection3d" class="headerlink" title="【12x00】将 2D 图像聚合到 3D 图像中：Axes3D.add_collection3d"></a><font color=#FF0000>【12x00】将 2D 图像聚合到 3D 图像中：Axes3D.add_collection3d</font></h2><p>基本方法：<code>Axes3D.add_collection3d(col, zs=0, zdir=&#39;z&#39;)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>col</td><td><a href="https://matplotlib.org/api/collections_api.html?highlight=polycollection#matplotlib.collections.PolyCollection">PolyCollection</a> / <a href="https://matplotlib.org/api/collections_api.html?highlight=linecollection#matplotlib.collections.LineCollection">LineCollection</a> / <a href="https://matplotlib.org/api/collections_api.html?highlight=patchcollection#matplotlib.collections.PatchCollection">PatchCollection</a> 对象</td></tr><tr><td>zs</td><td>第 i 个多边形将出现在平面 y=zs[i] 上</td></tr><tr><td>zdir</td><td>可选项，在 3D 轴上绘制 2D 数据时，数据必须以 xs，ys 的形式传递，<br>若此时将 zdir 设置为 ‘y’，数据将会被绘制到 x-z 轴平面上，默认为 ‘z’</td></tr></tbody></table><p>该函数一般用来向图形中添加 3D 集合对象，以下用一个示例来展示某个地区在不同年份和不同月份的降水量：</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.collections import PolyCollectionplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]fig = plt.figure()ax = fig.gca(projection=&#39;3d&#39;)np.random.seed(59)month = np.arange(0, 13)years = [2017, 2018, 2019, 2020]precipitation = []for year in years:    value = np.random.rand(len(month)) * 300    value[0], value[-1] = 0, 0    precipitation.append(list(zip(month, value)))poly = PolyCollection(precipitation, facecolors=[&#39;r&#39;, &#39;g&#39;, &#39;b&#39;, &#39;y&#39;], alpha=.6)ax.add_collection3d(poly, zs=years, zdir=&#39;y&#39;)ax.set_title(&#39;2D 图像聚合到 3D 图像示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;月份&#39;)ax.set_ylabel(&#39;年份&#39;)ax.set_zlabel(&#39;降水量&#39;)ax.set_xlim3d(0, 12)ax.set_ylim3d(2016, 2021)ax.set_zlim3d(0, 300)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/13.png" alt="13"></p><p>此外，该方法也常被用于绘制 3D 多边形图，即多边体，示例如下：</p><pre><code class="python">import matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection, Line3DCollectionplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]fig = plt.figure()ax = fig.gca(projection=&#39;3d&#39;)# 六面体顶点和面verts = [(0, 0, 0), (0, 1, 0), (1, 1, 0), (1, 0, 0), (0, 0, 1), (0, 1, 1), (1, 1, 1), (1, 0, 1)]faces = [[0, 1, 2, 3], [4, 5, 6, 7], [0, 1, 5, 4], [1, 2, 6, 5], [2, 3, 7, 6], [0, 3, 7, 4]]# 获取每个面的顶点poly3d = [[verts[vert_id] for vert_id in face] for face in faces]# 绘制顶点x, y, z = zip(*verts)ax.scatter(x, y, z)# 绘制多边形面ax.add_collection3d(Poly3DCollection(poly3d, facecolors=&#39;w&#39;, linewidths=1, alpha=0.5))# 绘制多边形的边ax.add_collection3d(Line3DCollection(poly3d, colors=&#39;k&#39;, linewidths=0.5, linestyles=&#39;:&#39;))# 设置图像标题、坐标标签以及范围ax.set_title(&#39;绘制多边体示例&#39;, pad=15, fontsize=&#39;12&#39;)ax.set_xlabel(&#39;X 轴&#39;)ax.set_ylabel(&#39;Y 轴&#39;)ax.set_zlabel(&#39;Z 轴&#39;)ax.set_xlim3d(-0.5, 1.5)ax.set_ylim3d(-0.5, 1.5)ax.set_zlim3d(-0.5, 1.5)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/14.png" alt="14"></p><h2 id="【13x00】3D-图添加文本描述：Axes3D-text"><a href="#【13x00】3D-图添加文本描述：Axes3D-text" class="headerlink" title="【13x00】3D 图添加文本描述：Axes3D.text"></a><font color=#FF0000>【13x00】3D 图添加文本描述：Axes3D.text</font></h2><p>基本方法：<code>Axes3D.text(x, y, z, s[, zdir=None, **kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>x, y, z</td><td>文本位置的 x、y、z 轴坐标</td></tr><tr><td>s</td><td>要添加的文本</td></tr><tr><td>zdir</td><td>可选项，若将 zdir 设置为 ‘y’，文本将会被投影到 x-z 轴平面上，默认为 None</td></tr><tr><td>**kwargs</td><td>其他关键字参数，参见 <a href="https://matplotlib.org/api/text_api.html">matplotlib.text</a></td></tr></tbody></table><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 依次获取画布和绘图区并创建 Axes3D 对象fig = plt.figure()ax = fig.gca(projection=&#39;3d&#39;)# Demo 1: zdir 参数用法zdirs = (None, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, (1, 1, 0), (1, 1, 1))xs = (1, 4, 4, 9, 4, 1)ys = (2, 5, 8, 10, 1, 2)zs = (10, 3, 8, 9, 1, 8)for zdir, x, y, z in zip(zdirs, xs, ys, zs):    label = &#39;(%d, %d, %d), dir=%s&#39; % (x, y, z, zdir)    ax.text(x, y, z, label, zdir)# Demo 2：设置颜色ax.text(9, 0, 0, &quot;red&quot;, color=&#39;red&#39;)# Demo 3: text2D，位置(0，0)为左下角，(1，1)为右上角。ax.text2D(0.05, 0.95, &quot;2D Text&quot;, transform=ax.transAxes)# 设置坐标轴界限和标签ax.set_xlim(0, 10)ax.set_ylim(0, 10)ax.set_zlim(0, 10)ax.set_xlabel(&#39;X 轴&#39;)ax.set_ylabel(&#39;Y 轴&#39;)ax.set_zlabel(&#39;Z 轴&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A77/15.png" alt="15"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106558131未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Matplotlib（九）：极区图/极坐标图/雷达图的绘制</title>
      <link href="/article/022/"/>
      <url>/article/022/</url>
      
        <content type="html"><![CDATA[<p>Matplotlib 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/014/">Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</a></li><li><a href="https://www.itbob.cn/article/015/">Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/016/">Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/017/">Python 数据分析三剑客之 Matplotlib（四）：线性图的绘制</a></li><li><a href="https://www.itbob.cn/article/018/">Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制</a></li><li><a href="https://www.itbob.cn/article/019/">Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制</a></li><li><a href="https://www.itbob.cn/article/020/">Python 数据分析三剑客之 Matplotlib（七）：饼状图的绘制</a></li><li><a href="https://www.itbob.cn/article/021/">Python 数据分析三剑客之 Matplotlib（八）：等高线 / 等值线图的绘制</a></li><li><a href="https://www.itbob.cn/article/022/">Python 数据分析三剑客之 Matplotlib（九）：极区图 / 极坐标图 / 雷达图的绘制</a></li><li><a href="https://www.itbob.cn/article/023/">Python 数据分析三剑客之 Matplotlib（十）：3D 图的绘制</a></li><li><a href="https://www.itbob.cn/article/024/">Python 数据分析三剑客之 Matplotlib（十一）：最热门最常用的 50 个图表</a>【译文】</li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106162412未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】了解极坐标"><a href="#【1x00】了解极坐标" class="headerlink" title="【1x00】了解极坐标"></a><font color=#FF0000>【1x00】了解极坐标</font></h2><p>参考百度百科：极坐标，属于二维坐标系统，创始人是牛顿，主要应用于数学领域。极坐标是指在平面内取一个定点 <font color=#FF0000>O</font>，叫极点，引一条射线 <font color=#FF0000>Ox</font>，叫做极轴，再选定一个长度单位和角度的正方向（通常取逆时针方向）。对于平面内任何一点 <font color=#FF0000>M</font>，用 <font color=#FF0000>ρ</font> 表示线段 <font color=#FF0000>OM</font> 的长度（有时也用 <font color=#FF0000>r</font> 表示），<font color=#FF0000>θ</font> 表示从 <font color=#FF0000>Ox</font> 到 <font color=#FF0000>OM</font> 的角度，<font color=#FF0000>ρ</font> 叫做点 <font color=#FF0000>M</font> 的极径，<font color=#FF0000>θ</font> 叫做点 <font color=#FF0000>M</font> 的极角，有序数对 <font color=#FF0000>(ρ,θ)</font> 就叫点 <font color=#FF0000>M</font> 的极坐标，这样建立的坐标系叫做极坐标系。通常情况下，<font color=#FF0000>M</font> 的极径坐标单位为 <font color=#FF0000>1</font>（长度单位），极角坐标单位为 <font color=#FF0000>rad</font>（或<font color=#FF0000>°</font>）。</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/01.png" alt="01"></p><h2 id="【2x00】基本方法-matplotlib-pyplot-polar"><a href="#【2x00】基本方法-matplotlib-pyplot-polar" class="headerlink" title="【2x00】基本方法 matplotlib.pyplot.polar()"></a><font color=#FF0000>【2x00】基本方法 matplotlib.pyplot.polar()</font></h2><p><code>matplotlib.pyplot.polar()</code> 方法可用于绘制极坐标图。</p><p>基本语法：<code>polar(theta, r, **kwargs)</code></p><ul><li><font color=#FF0000><strong>theta</strong></font>：点的角坐标，以弧度单位传入参数；</li><li><font color=#FF0000><strong>r</strong></font>：点的半径坐标；</li><li><font color=#FF0000>**<strong>kwargs</strong></font>：可选项，其他 Line2D 属性，常用属性见<font color=#FF0000><strong>表一</strong></font>。</li></ul><p>拓展：数学上通常是用弧度而非角度，弧度单位缩写为 rad，2π rad = 360°，1° ≈ 0.0174533 rad，1 rad ≈ 57.29578°。</p><ul><li>角度转换为弧度公式：弧度 = 角度 ÷ 180 × π</li><li>弧度转换为角度公式：角度 = 弧度 × 180 ÷ π</li></ul><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font color="FF0000" size=3px>表一：Line2D 部分属性，完整属性参见官方文档：<br>https://matplotlib.org/api/_as_gen/matplotlib.lines.Line2D.html</font></strong></td></tr></table><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>alpha</td><td>线条透明度，float 类型，取值范围：<code>[0, 1]</code>，默认为 1.0，即不透明</td></tr><tr><td>antialiased / aa</td><td>是否使用抗锯齿渲染，默认为 True</td></tr><tr><td>color / c</td><td>线条颜色，支持英文颜色名称及其简写、十六进制颜色码等，更多颜色示例参见官网 <a href="https://matplotlib.org/gallery/color/color_demo.html">Color Demo</a></td></tr><tr><td>fillstyle</td><td>点的填充样式，<code>&#39;full&#39;</code>、<code>&#39;left&#39;</code>、<code>&#39;right&#39;</code>、<code>&#39;bottom&#39;</code>、<code>&#39;top&#39;</code>、<code>&#39;none&#39;</code></td></tr><tr><td>label</td><td>图例，具体参数参见：<br><a href="https://itrhx.blog.csdn.net/article/details/105828143">《Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性》</a></td></tr><tr><td>linestyle / ls</td><td>连接的线条样式：<code>&#39;-&#39;</code> or <code>&#39;solid&#39;</code>, <code>&#39;--&#39;</code> or <code>&#39;dashed&#39;</code>, <code>&#39;-.&#39;</code> or <code>&#39;dashdot&#39;</code> <br> <code>&#39;:&#39;</code> or <code>&#39;dotted&#39;</code>, <code>&#39;none&#39;</code> or <code>&#39; &#39;</code> or <code>&#39;&#39;</code></td></tr><tr><td>linewidth / lw</td><td>连接的线条宽度，float 类型，默认 0.8</td></tr><tr><td>marker</td><td>标记样式，具体样式参见<font color=#FF0000><strong>表二</strong></font></td></tr><tr><td>markeredgecolor / mec</td><td>marker 标记的边缘颜色</td></tr><tr><td>markeredgewidth / mew</td><td>marker 标记的边缘宽度</td></tr><tr><td>markerfacecolor / mfc</td><td>marker 标记的颜色</td></tr><tr><td>markerfacecoloralt / mfcalt</td><td>marker 标记的备用颜色</td></tr><tr><td>markersize / ms</td><td>marker 标记的大小</td></tr></tbody></table><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font color="FF0000" size=3px>表二：marker 标记的样式，官方文档：<br>https://matplotlib.org/api/markers_api.html</font></strong></td></tr></table><table><thead><tr><th>标记</th><th>描述</th></tr></thead><tbody><tr><td><code>&quot;.&quot;</code></td><td>点</td></tr><tr><td><code>&quot;,&quot;</code></td><td>像素点</td></tr><tr><td><code>&quot;o&quot;</code></td><td>圆圈</td></tr><tr><td><code>&quot;v&quot;</code></td><td>倒三角</td></tr><tr><td><code>&quot;^&quot;</code></td><td>正三角</td></tr><tr><td><code>&quot;&lt;&quot;</code></td><td>左三角</td></tr><tr><td><code>&quot;&gt;&quot;</code></td><td>右三角</td></tr><tr><td><code>&quot;1&quot;</code></td><td>倒三叉星</td></tr><tr><td><code>&quot;2&quot;</code></td><td>正三叉星（类似奔驰车标形状）</td></tr><tr><td><code>&quot;3&quot;</code></td><td>左三叉星</td></tr><tr><td><code>&quot;4&quot;</code></td><td>右三叉星</td></tr><tr><td><code>&quot;8&quot;</code></td><td>八边形</td></tr><tr><td><code>&quot;s&quot;</code></td><td>正方形</td></tr><tr><td><code>&quot;p&quot;</code></td><td>五边形</td></tr><tr><td><code>&quot;P&quot;</code></td><td>填充的加号（粗加号）</td></tr><tr><td><code>&quot;+&quot;</code></td><td>加号</td></tr><tr><td><code>&quot;*&quot;</code></td><td>星形</td></tr><tr><td><code>&quot;h&quot;</code></td><td>六边形（底部是角）</td></tr><tr><td><code>&quot;H&quot;</code></td><td>六边形（底部是边）</td></tr><tr><td><code>&quot;x&quot;</code></td><td>x 号</td></tr><tr><td><code>&quot;X&quot;</code></td><td>填充的 x 号（粗 x 号）</td></tr><tr><td><code>&quot;D&quot;</code></td><td>粗菱形（对角线相等）</td></tr><tr><td><code>&quot;d&quot;</code></td><td>细菱形（对角线不等）</td></tr><tr><td>`”</td><td>“`</td></tr><tr><td><code>&quot;_&quot;</code></td><td>水平线</td></tr><tr><td><code>0</code></td><td>水平线靠左</td></tr><tr><td><code>1</code></td><td>水平线靠右</td></tr><tr><td><code>2</code></td><td>垂直线靠上</td></tr><tr><td><code>3</code></td><td>垂直线靠下</td></tr><tr><td><code>4</code></td><td>左三角（比 <code>&quot;&lt;&quot;</code> 更细）</td></tr><tr><td><code>5</code></td><td>右三角（比 <code>&quot;&gt;&quot;</code> 更细）</td></tr><tr><td><code>6</code></td><td>正三角（比 <code>&quot;^&quot;</code> 更细）</td></tr><tr><td><code>7</code></td><td>倒三角（比 <code>&quot;v&quot;</code> 更细）</td></tr><tr><td><code>8</code></td><td>左三角（比 <code>&quot;&lt;&quot;</code> 更细，靠左显示）</td></tr><tr><td><code>9</code></td><td>右三角（比 <code>&quot;&gt;&quot;</code> 更细，靠右显示）</td></tr><tr><td><code>10</code></td><td>正三角（比 <code>&quot;^&quot;</code> 更细，靠上显示）</td></tr><tr><td><code>11</code></td><td>倒三角（比 <code>&quot;v&quot;</code> 更细，靠下显示）</td></tr><tr><td><code>&quot;None&quot;</code> / <code>&quot; &quot;</code> / <code>&quot;&quot;</code></td><td>无样式</td></tr><tr><td><code>&#39;$...$&#39;</code></td><td>支持 LaTeX 数学公式，表达式用美元符号包围起来</td></tr></tbody></table><h2 id="【3x00】绘制极坐标"><a href="#【3x00】绘制极坐标" class="headerlink" title="【3x00】绘制极坐标"></a><font color=#FF0000>【3x00】绘制极坐标</font></h2><pre><code class="python">import numpy as npimport matplotlib.pyplot as plt# 设置中文显示plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]# 设置画布大小plt.figure(figsize=(8.0, 6.0))# 设置三个数据，theta 为点位置的弧度参数，r 为点的半径坐标theta1 = np.array([1.25*np.pi, np.pi/2, 0])theta2 = np.array([-np.pi/6, -np.pi/2, 0, np.pi/2, np.pi])theta3 = np.arange(0., 2*np.pi, 0.5)r1 = np.array([4, 2, 3])r2 = np.array([5, 2, 4, 5, 3])r3 = np.random.randint(0, 5, 13)# 绘制第一个极坐标图，点的标记样式为细菱形，大小为8，点之间的连接线条样式为:plt.polar(theta1, r1, marker=&#39;d&#39;, ms=8, ls=&#39;:&#39;, label=&#39;数据一&#39;)# 填充第一个极坐标图，填充颜色为蓝色，透明度0.3plt.fill(theta1, r1, color=&#39;b&#39;, alpha=0.3)# 绘制第二个极坐标图，marker、linestyle、color 三个参数可以组合以字符串形式传入plt.polar(theta2, r2, &#39;*-g&#39;, ms=10, label=&#39;数据二&#39;)# 绘制第三个极坐标图，设置 linestyle 为 none，即点与点之间不相连plt.polar(theta3, r3, marker=&#39;o&#39;, ls=&#39;none&#39;, ms=8, color=&#39;r&#39;, label=&#39;数据三&#39;)plt.title(&#39;matplotlib.pyplot.polar 用法示例&#39;, pad=25, fontsize=15)plt.legend(bbox_to_anchor=(1.3, 1))plt.show()</code></pre><p>示例中 figure、title、legend 等其他方法的解释可参见我的系列文章：</p><ul><li><a href="https://itrhx.blog.csdn.net/article/details/105638122">《Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件》</a></li><li><a href="https://itrhx.blog.csdn.net/article/details/105828049">《Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性》</a></li><li><a href="https://itrhx.blog.csdn.net/article/details/105828143">《Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性》</a></li></ul><p>绘制结果如下图：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/02.png" alt="02"></p><h2 id="【4x00】绘制雷达图"><a href="#【4x00】绘制雷达图" class="headerlink" title="【4x00】绘制雷达图"></a><font color=#FF0000>【4x00】绘制雷达图</font></h2><p>雷达图是以从同一点开始的轴上表示的三个或更多个定量变量的二维图表的形式显示多变量数据的图形方法。轴的相对位置和角度通常是无信息的。 雷达图也称为网络图，蜘蛛图，星图，蜘蛛网图，不规则多边形，极坐标图或 Kiviat 图。它相当于平行坐标图，轴径向排列。</p><p>在前面的示例中，使用了 <code>matplotlib.pyplot.fill()</code> 方法对三个极坐标点围成的图形进行了填充，这就有点儿接近于雷达图了，仔细观察前面的示例，在填充时第一个点和最后一个点之间没有连线，即没有闭合，而更精确的雷达图应该是闭合的，且外围应该是文字描述而不是度数。</p><p>在绘制雷达图之前需要提前了解一些函数。这些函数可以帮助我们实现闭合、自定义文字标签等。</p><hr><h3 id="【4x01】理解-numpy-concatenate"><a href="#【4x01】理解-numpy-concatenate" class="headerlink" title="【4x01】理解 numpy.concatenate()"></a><font color=##4876FF>【4x01】理解 numpy.concatenate()</font></h3><p><code>numpy.concatenate()</code> 方法用于沿现有轴连接一系列数组，我们可以利用此方法来实现闭合操作。</p><p>基本语法：<code>numpy.concatenate((a1, a2, ...)[, axis=0, out=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a1, a2, …</td><td>要连接的数组，必须拥有相同的维度</td></tr><tr><td>axis</td><td>沿指定轴连接数组，可选项，如果 axis 为 None，则数组在使用前被展平，默认值为 0</td></tr><tr><td>out</td><td>用于接收连接后的数组，可选项</td></tr></tbody></table><p>用法示例：</p><pre><code class="python">import numpy as npa = np.array([1, 2, 3, 4])b = np.array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])print(np.concatenate((a, b)))</code></pre><p>输出结果如下：</p><pre><code class="python">[&#39;1&#39; &#39;2&#39; &#39;3&#39; &#39;4&#39; &#39;a&#39; &#39;b&#39; &#39;c&#39; &#39;d&#39;]</code></pre><p>如果要实现数组的闭合，则可以传入原数组和一个新数组，其中新数组中的元素为原数组中的第一个元素，示例如下：</p><pre><code class="python">import numpy as npa = np.array([1, 2, 3, 4])print(np.concatenate((a, [a[0]])))</code></pre><p>输出结果如下：</p><pre><code class="python">[1 2 3 4 1]</code></pre><hr><h3 id="【4x02】理解-pyplot-thetagrids"><a href="#【4x02】理解-pyplot-thetagrids" class="headerlink" title="【4x02】理解 pyplot.thetagrids()"></a><font color=##4876FF>【4x02】理解 pyplot.thetagrids()</font></h3><p><code>matplotlib.pyplot.thetagrids()</code> 方法用于获取并设置当前极区图上的极轴。</p><p>基本语法：<code>matplotlib.pyplot.thetagrids(angles, labels=None, fmt=None, **kwargs)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>angles</td><td>网格线的角度，浮点数、度数组成的元组</td></tr><tr><td>labels</td><td>每个极轴要使用的文本标签，字符串组成的元组</td></tr><tr><td>fmt</td><td>格式化 angles 参数，如 <code>&#39;%1.2f&#39;</code> 保留两位小数，注意，将使用以弧度为单位的角度</td></tr><tr><td>**kwargs</td><td>其他关键字参数，参见<a href="https://matplotlib.org/api/text_api.html?highlight=text#matplotlib.text.Text">官方文档</a></td></tr></tbody></table><p>应用举例：</p><pre><code class="python"> import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]plt.polar()angles = range(0, 360, 45)labels = (&#39;东&#39;, &#39;东北&#39;, &#39;北&#39;, &#39;西北&#39;, &#39;西&#39;, &#39;西南&#39;, &#39;南&#39;, &#39;东南&#39;)plt.thetagrids(angles, labels)plt.title(&#39;matplotlib.pyplot.thetagrids() 用法示例&#39;, pad=15)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/03.png" alt="03"></p><hr><h3 id="【4x03】绘制雷达图"><a href="#【4x03】绘制雷达图" class="headerlink" title="【4x03】绘制雷达图"></a><font color=##4876FF>【4x03】绘制雷达图</font></h3><p><code>numpy.concatenate()</code> 方法能够解决闭合问题，<code>matplotlib.pyplot.thetagrids()</code> 能够解决自定义极轴和极轴的文本标记问题，因此就可以绘制一个标准的雷达图了。示例如下：</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as plt# 设置中文显示、画布大小plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]plt.figure(figsize=(8.0, 6.0))# 分割圆并执行闭合操作（0-2π之间返回间隔均匀的6个弧度：π/3、2π/3、π、4π/3、5π/3、2π）theta = np.linspace(0, 2*np.pi, 6, endpoint=False)theta = np.concatenate((theta, [theta[0]]))# 设置两组数据并执行闭合操作data1 = np.array([9, 4, 3, 5, 2, 8])data2 = np.array([3, 6, 9, 6, 3, 2])data1 = np.concatenate((data1, [data1[0]]))data2 = np.concatenate((data2, [data2[0]]))# 绘制并填充两组数据plt.polar(theta, data1, &#39;bo-&#39;, label=&#39;小王&#39;)plt.polar(theta, data2, &#39;ro:&#39;, label=&#39;小张&#39;)plt.fill(theta, data1, color=&#39;b&#39;, alpha=0.3)plt.fill(theta, data2, color=&#39;r&#39;, alpha=0.3)# 将六个弧度（π/3、2π/3、π、4π/3、5π/3、2π）转换成角度，并分别设置标签labels = np.array([&#39;Python&#39;, &#39;Golang&#39;, &#39;Java&#39;, &#39;C++&#39;, &#39;PHP&#39;, &#39;JavaScript&#39;])plt.thetagrids(theta * 180/np.pi, labels)# 设置刻度范围、标题、图例plt.ylim(0, 10)plt.title(&#39;编程语言掌握程度&#39;)plt.legend(bbox_to_anchor=(1.3, 1))plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/04.png" alt="04"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106162412未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【5x00】高级用法：绘制极坐标散点图"><a href="#【5x00】高级用法：绘制极坐标散点图" class="headerlink" title="【5x00】高级用法：绘制极坐标散点图"></a><font color=#FF0000>【5x00】高级用法：绘制极坐标散点图</font></h2><p><code>matplotlib.pyplot.polar()</code> 方法可以实现极坐标散点图，但仅用这一个函数的话实现的样式效果并不多，以下介绍另外三种绘制极坐标散点图的方法：</p><ul><li><p><code>matplotlib.pyplot.polar()</code> 和 <code>matplotlib.pyplot.scatter()</code> 结合，前者绘制极坐标图，后者在极坐标图上绘制散点图；</p></li><li><p><code>matplotlib.pyplot.subplot()</code> 和 <code>matplotlib.pyplot.scatter()</code> 结合，前者添加子图，其中指定 <code>projection=&#39;polar&#39;</code> 即为极坐标图， 后者在极坐标图上绘制散点图；</p></li><li><p><code>matplotlib.pyplot.axes()</code> 与 <code>matplotlib.pyplot.scatter()</code> 结合，前者设置绘图区参数，其中指定 <code>projection=&#39;polar&#39;</code> 或 <code>polar=True</code> 即为极坐标图， 后者在极坐标图上绘制散点图。</p></li></ul><hr><h3 id="【5x01】方法一：pyplot-scatter-与-pyplot-polar"><a href="#【5x01】方法一：pyplot-scatter-与-pyplot-polar" class="headerlink" title="【5x01】方法一：pyplot.scatter() 与 pyplot.polar()"></a><font color=##4876FF>【5x01】方法一：pyplot.scatter() 与 pyplot.polar()</font></h3><p>以下用到的 <code>matplotlib.pyplot.scatter()</code> 函数，各参数含义以及支持的其他参数可以参见前文：</p><ul><li><p><a href="https://itrhx.blog.csdn.net/article/details/105828049">《Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性》</a></p></li><li><p><a href="https://itrhx.blog.csdn.net/article/details/105914929">《Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制》</a></p></li></ul><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]N = 50r = 2 * np.random.rand(N)theta = 2 * np.pi * np.random.rand(N)size = 200 * r ** 2colors = N * np.random.rand(N)plt.polar()plt.scatter(theta, r, s=size, c=colors, alpha=0.8)plt.title(&#39;极坐标散点图示例一&#39;, pad=15)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/05.png" alt="05"></p><hr><h3 id="【5x02】方法二：pyplot-scatter-与-pyplot-subplot"><a href="#【5x02】方法二：pyplot-scatter-与-pyplot-subplot" class="headerlink" title="【5x02】方法二：pyplot.scatter() 与 pyplot.subplot()"></a><font color=##4876FF>【5x02】方法二：pyplot.scatter() 与 pyplot.subplot()</font></h3><p><code>matplotlib.pyplot.subplot()</code> 方法用于添加子图，如果想要子图为极坐标图，则需要指定 <code>projection</code> 参数为 <code>polar</code>，有关此函数的具体介绍可参见<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.subplot.html">官方文档</a>。其他函数的参数解释可参考前文：</p><ul><li><p><a href="https://itrhx.blog.csdn.net/article/details/105828143">《Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性》</a></p></li><li><p><a href="https://itrhx.blog.csdn.net/article/details/105914929">《Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制》</a></p></li></ul><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]N = 50r = 2 * np.random.rand(N)theta = 2 * np.pi * np.random.rand(N)size = 200 * r ** 2colors = N * np.random.rand(N)# 一行一列第一个子图plt.subplot(111, projection=&#39;polar&#39;)plt.scatter(theta, r, s=size, c=colors, alpha=0.8)plt.title(&#39;极坐标散点图示例二&#39;, pad=15)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/06.png" alt="06"></p><hr><h3 id="【5x03】方法三：pyplot-scatter-与-pyplot-axes"><a href="#【5x03】方法三：pyplot-scatter-与-pyplot-axes" class="headerlink" title="【5x03】方法三：pyplot.scatter() 与 pyplot.axes()"></a><font color=##4876FF>【5x03】方法三：pyplot.scatter() 与 pyplot.axes()</font></h3><p>axes 为 Matplotlib 图像中的绘图区，<code>matplotlib.pyplot.axes()</code> 方法可以对绘图区进行设置，同样的也可以设置 <code>projection</code> 参数为 <code>polar</code> 来实现极坐标图，设置 <code>polar=True</code> 也行。示例中其他函数的参数解释可参考前文：</p><ul><li><p><a href="https://itrhx.blog.csdn.net/article/details/105638122">《Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件》</a></p></li><li><p><a href="https://itrhx.blog.csdn.net/article/details/105914929">《Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制》</a></p></li></ul><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]N = 50r = 2 * np.random.rand(N)theta = 2 * np.pi * np.random.rand(N)size = 200 * r ** 2colors = N * np.random.rand(N)# plt.axes(polar=True)plt.axes(projection=&#39;polar&#39;)plt.scatter(theta, r, s=size, c=colors, alpha=0.8)plt.title(&#39;极坐标散点图示例三&#39;, pad=15)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/07.png" alt="07"></p><h2 id="【6x00】高级用法：绘制极坐标柱状图"><a href="#【6x00】高级用法：绘制极坐标柱状图" class="headerlink" title="【6x00】高级用法：绘制极坐标柱状图"></a><font color=#FF0000>【6x00】高级用法：绘制极坐标柱状图</font></h2><p>和极坐标散点图的绘制类似，<code>matplotlib.pyplot.polar()</code> 方法可以实现极坐标图，但仅用这一个函数的话实现的样式效果并不多，以下介绍另外三种绘制极坐标柱状图的方法：</p><ul><li><p><code>matplotlib.pyplot.polar()</code> 和 <code>matplotlib.pyplot.bar()</code> 结合，前者绘制极坐标图，后者在极坐标图上绘制柱状图；</p></li><li><p><code>matplotlib.pyplot.subplot()</code> 和 <code>matplotlib.pyplot.bar()</code> 结合，前者添加子图，其中指定 <code>projection=&#39;polar&#39;</code> 即为极坐标图， 后者在极坐标图上绘制柱状图；</p></li><li><p><code>matplotlib.pyplot.axes()</code> 与 <code>matplotlib.pyplot.bar()</code> 结合，前者设置绘图区参数，其中指定 <code>projection=&#39;polar&#39;</code> 或 <code>polar=True</code> 即为极坐标图， 后者在极坐标图上绘制柱状图。</p></li></ul><hr><h3 id="【6x01】方法一：pyplot-bar-与-pyplot-polar"><a href="#【6x01】方法一：pyplot-bar-与-pyplot-polar" class="headerlink" title="【6x01】方法一：pyplot.bar() 与 pyplot.polar()"></a><font color=##4876FF>【6x01】方法一：pyplot.bar() 与 pyplot.polar()</font></h3><p>以下用到的 <code>matplotlib.pyplot.bar()</code> 函数，各参数含义以及支持的其他参数可以参见前文：</p><ul><li><p><a href="https://itrhx.blog.csdn.net/article/details/105828049">《Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性》</a></p></li><li><p><a href="https://itrhx.blog.csdn.net/article/details/105952856">《Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制》</a></p></li></ul><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]r = np.random.rand(8)theta = np.arange(0, 2 * np.pi, 2 * np.pi / 8)colors = np.array([&#39;#4bb2c5&#39;, &#39;#c5b47f&#39;, &#39;#EAA228&#39;, &#39;#579575&#39;, &#39;#839557&#39;, &#39;#958c12&#39;, &#39;#953579&#39;, &#39;#4b5de4&#39;])plt.polar()plt.bar(theta, r, color=colors, alpha=0.8)plt.title(&#39;极坐标柱状图示例一&#39;, pad=15)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/08.png" alt="08"></p><hr><h3 id="【6x02】方法二：pyplot-bar-与-pyplot-subplot"><a href="#【6x02】方法二：pyplot-bar-与-pyplot-subplot" class="headerlink" title="【6x02】方法二：pyplot.bar() 与 pyplot.subplot()"></a><font color=##4876FF>【6x02】方法二：pyplot.bar() 与 pyplot.subplot()</font></h3><p><code>matplotlib.pyplot.subplot()</code> 方法用于添加子图，如果想要子图为极坐标图，则需要指定 <code>projection</code> 参数为 <code>polar</code>，有关此函数的具体介绍可参见<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.subplot.html">官方文档</a>。其他函数的参数解释可参考前文：</p><ul><li><p><a href="https://itrhx.blog.csdn.net/article/details/105828143">《Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性》</a></p></li><li><p><a href="https://itrhx.blog.csdn.net/article/details/105952856">《Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制》</a></p></li></ul><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]r = np.random.rand(8)theta = np.arange(0, 2 * np.pi, 2 * np.pi / 8)colors = np.array([&#39;#4bb2c5&#39;, &#39;#c5b47f&#39;, &#39;#EAA228&#39;, &#39;#579575&#39;, &#39;#839557&#39;, &#39;#958c12&#39;, &#39;#953579&#39;, &#39;#4b5de4&#39;])plt.subplot(111, projection=&#39;polar&#39;)plt.bar(theta, r, color=colors, alpha=0.8)plt.title(&#39;极坐标柱状图示例二&#39;, pad=15)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/09.png" alt="09"></p><hr><h3 id="【6x03】方法三：pyplot-bar-与-pyplot-axes"><a href="#【6x03】方法三：pyplot-bar-与-pyplot-axes" class="headerlink" title="【6x03】方法三：pyplot.bar() 与 pyplot.axes()"></a><font color=##4876FF>【6x03】方法三：pyplot.bar() 与 pyplot.axes()</font></h3><p>axes 为 Matplotlib 图像中的绘图区，<code>matplotlib.pyplot.axes()</code> 方法可以对绘图区进行设置，同样的也可以设置 <code>projection</code> 参数为 <code>polar</code> 来实现极坐标图，设置 <code>polar=True</code> 也行。示例中其他函数的参数解释可参考前文：</p><ul><li><p><a href="https://itrhx.blog.csdn.net/article/details/105638122">《Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件》</a></p></li><li><p><a href="https://itrhx.blog.csdn.net/article/details/105952856">《Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制》</a></p></li></ul><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]r = np.random.rand(8)theta = np.arange(0, 2 * np.pi, 2 * np.pi / 8)colors = np.array([&#39;#4bb2c5&#39;, &#39;#c5b47f&#39;, &#39;#EAA228&#39;, &#39;#579575&#39;, &#39;#839557&#39;, &#39;#958c12&#39;, &#39;#953579&#39;, &#39;#4b5de4&#39;])# plt.axes(polar=True)plt.axes(projection=&#39;polar&#39;)plt.bar(theta, r, color=colors, alpha=0.8)plt.title(&#39;极坐标柱状图示例三&#39;, pad=15)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A76/10.png" alt="10"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106162412未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Matplotlib（八）：等高线/等值线图的绘制</title>
      <link href="/article/021/"/>
      <url>/article/021/</url>
      
        <content type="html"><![CDATA[<p>Matplotlib 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/014/">Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</a></li><li><a href="https://www.itbob.cn/article/015/">Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/016/">Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/017/">Python 数据分析三剑客之 Matplotlib（四）：线性图的绘制</a></li><li><a href="https://www.itbob.cn/article/018/">Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制</a></li><li><a href="https://www.itbob.cn/article/019/">Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制</a></li><li><a href="https://www.itbob.cn/article/020/">Python 数据分析三剑客之 Matplotlib（七）：饼状图的绘制</a></li><li><a href="https://www.itbob.cn/article/021/">Python 数据分析三剑客之 Matplotlib（八）：等高线 / 等值线图的绘制</a></li><li><a href="https://www.itbob.cn/article/022/">Python 数据分析三剑客之 Matplotlib（九）：极区图 / 极坐标图 / 雷达图的绘制</a></li><li><a href="https://www.itbob.cn/article/023/">Python 数据分析三剑客之 Matplotlib（十）：3D 图的绘制</a></li><li><a href="https://www.itbob.cn/article/024/">Python 数据分析三剑客之 Matplotlib（十一）：最热门最常用的 50 个图表</a>【译文】</li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106066852未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】等高线概念"><a href="#【1x00】等高线概念" class="headerlink" title="【1x00】等高线概念"></a><font color=#FF0000>【1x00】等高线概念</font></h2><p>参考百度百科，等高线概念总结如下：等高线指的是地形图上高程相等的相邻各点所连成的闭合曲线。把地面上海拔高度相同的点连成的闭合曲线，并垂直投影到一个水平面上，并按比例缩绘在图纸上，就得到等高线。等高线也可以看作是不同海拔高度的水平面与实际地面的交线，所以等高线是闭合曲线。在等高线上标注的数字为该等高线的海拔。</p><ul><li>位于同一等高线上的地面点，海拔高度相同。但海拔高度相同的点不一定位于同一条等高线上；</li><li>在同一幅图内，除了陡崖以外，不同高程的等高线不能相交；</li><li>在图廓内相邻等高线的高差一般是相同的，因此地面坡度与等高线之间的等高线平距成反比，等高线平距愈小，等高线排列越密，说明地面坡度越大；等高线平距愈大，等高线排列越稀，则说明地面坡度愈小；</li><li>等高线是一条闭合的曲线，如果不能在同一幅内闭合，则必在相邻或者其他图幅内闭合。</li><li>等高线经过山脊或山谷时改变方向，因此，山脊线或者山谷线应垂直于等高线转折点处的切线，即等高线与山脊线或者山谷线正交。</li></ul><p><font color=#FF0000><strong>在 Matplotlib 等高线的绘制中，需要传递三个基本参数：某个点的 x、y 轴坐标以及其高度。</strong></font></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A75/01.png" alt="01"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A75/02.png" alt="02"></p><h2 id="【2x00】理解-numpy-meshgrid"><a href="#【2x00】理解-numpy-meshgrid" class="headerlink" title="【2x00】理解 numpy.meshgrid()"></a><font color=#FF0000>【2x00】理解 numpy.meshgrid()</font></h2><p><code>numpy.meshgrid()</code> 方法用于生成网格点坐标矩阵。</p><pre><code class="python">import numpy as npa = np.array([1, 2, 3])b = np.array([7, 8, 9])res = np.meshgrid(a, b)print(res)</code></pre><p>输出结果：</p><pre><code class="python">[array([[1, 2, 3],       [1, 2, 3],       [1, 2, 3]]), array([[7, 7, 7],       [8, 8, 8],       [9, 9, 9]])]</code></pre><p>给定两个数组，<code>a[1, 2, 3]</code> 和 <code>b[7, 8, 9]</code>，a 作为 x 轴数据，b 作为 y 轴数据，那么一共可以绘制出 9 个点： (1,7)、(1,8)、(1,9)、(2,7)、(2,8)、(2,9)、(3,7)、(3,8)、(3,9)，而 <code>numpy.meshgrid()</code> 方法就是起这样的作用，返回的两个二维数组，横坐标矩阵 a 中的每个元素，与纵坐标矩阵 b 中对应位置元素，共同构成一个点的完整坐标。</p><p><font color=#FF0000><strong>因为在 <code>matplotlib.pyplot.contour()</code> 等高线绘制函数中接收的是二维坐标信息，所以在绘制等高线图之前要将原数据经过 <code>numpy.meshgrid()</code> 方法处理，也可以自己构建类似于上述的二维数组。</strong></font></p><p><img src="https://img-blog.csdnimg.cn/20200512112427932.png" alt="分割线"></p><h2 id="【3x00】绘制方法-matplotlib-pyplot-contour"><a href="#【3x00】绘制方法-matplotlib-pyplot-contour" class="headerlink" title="【3x00】绘制方法 matplotlib.pyplot.contour()"></a><font color=#FF0000>【3x00】绘制方法 matplotlib.pyplot.contour()</font></h2><p><code>matplotlib.pyplot.contour()</code> 方法可用于绘制等高线图。</p><p>基本语法：<code>matplotlib.pyplot.contour(\*args, data=None, \*\*kwargs)</code></p><p>通用格式：<code>matplotlib.pyplot.contour([X, Y,] Z, [levels], **kwargs)</code></p><p>基本参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>X, Y</td><td>数组形式的点的 x 和 y 轴坐标，两者都必须是二维的，形状与 Z 相同</td></tr><tr><td>Z</td><td>绘制轮廓的高度值，二维数组，每个元素是其对应点的高度</td></tr><tr><td>levels</td><td>确定等高线的数目和位置，如果是整数 N，则使用 N 个数据间隔，即绘制 N+1 条等高线<br>如果是数组形式，则绘制指定的等高线。值必须按递增顺序排列</td></tr></tbody></table><p>其他参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>colors</td><td>等高线的颜色，颜色字符串或颜色序列</td></tr><tr><td>cmap</td><td>等高线的颜色，字符串或者 <a href="https://matplotlib.org/tutorials/colors/colormaps.html">Colormap</a><br>通常包含一系列的渐变色或其他颜色组合，取值参见<font color=#FF0000><strong>【6x00】Colormap 取值</strong></font></td></tr><tr><td>alpha</td><td>透明度，介于0（透明）和1（不透明）之间</td></tr><tr><td>origin</td><td>通过指定 Z[0，0] 的位置来确定 Z 的方向和确切位置，仅当未指定 X, Y 时才有意义<br><code>None</code>：Z[0，0] 位于左下角的 X=0, Y=0 处<br><code>&#39;lower&#39;</code>：Z [0, 0] 位于左下角的 X = 0.5, Y = 0.5 处<br><code>&#39;upper&#39;</code>：Z[0，0] 位于左上角的 X=N+0.5, Y=0.5 处<br><code>&#39;image&#39;</code>：使用 <code>rcParams[“image.origin”] = &#39;upper&#39;</code>的值</td></tr><tr><td>antialiased</td><td>是否启用抗锯齿渲染，默认 True</td></tr><tr><td>linewidths</td><td>等高线的线宽，如果是数字，则所有等高线都将使用此线宽<br>如果是序列，则将按指定的顺序以升序打印线宽<br>默认为 <code>rcParams[“lines.linewidth”] = 1.5</code></td></tr><tr><td>linestyles</td><td>等高线的样式，如果线条颜色为单色，则负等高线默认为虚线<br><code>&#39;-&#39;</code> or <code>&#39;solid&#39;</code>, <code>&#39;--&#39;</code> or <code>&#39;dashed&#39;</code>, <code>&#39;-.&#39;</code> or <code>&#39;dashdot&#39;</code> <code>&#39;:&#39;</code> or <code>&#39;dotted&#39;</code>, <code>&#39;none&#39;</code> or <code>&#39; &#39;</code> or <code>&#39;&#39;</code></td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20200512112427932.png" alt="分割线"></p><h2 id="【4x00】填充方法-matplotlib-pyplot-contourf"><a href="#【4x00】填充方法-matplotlib-pyplot-contourf" class="headerlink" title="【4x00】填充方法 matplotlib.pyplot.contourf()"></a><font color=#FF0000>【4x00】填充方法 matplotlib.pyplot.contourf()</font></h2><p><code>matplotlib.pyplot.contourf()</code> 方法与 <code>matplotlib.pyplot.contour()</code> 的区别在于：<code>contourf()</code> 会对等高线间的区域进行颜色填充（filled contours）。除此之外两者的函数签名和返回值都相同。</p><p>基本语法：<code>matplotlib.pyplot.contourf(\*args, data=None, \*\*kwargs)</code></p><p>通用格式：<code>matplotlib.pyplot.contour([X, Y,] Z, [levels], **kwargs)</code></p><p>基本参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>X, Y</td><td>数组形式的点的 x 和 y 轴坐标，两者都必须是二维的，形状与 Z 相同</td></tr><tr><td>Z</td><td>绘制轮廓的高度值，二维数组，每个元素是其对应点的高度</td></tr><tr><td>levels</td><td>确定等高线的数目和位置，如果是整数 N，则使用 N 个数据间隔，即绘制 N+1 条等高线<br>如果是数组形式，则绘制指定的等高线。值必须按递增顺序排列</td></tr></tbody></table><p>其他参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>colors</td><td>等高线的填充颜色，颜色字符串或颜色序列</td></tr><tr><td>cmap</td><td>等高线的填充颜色，字符串或者 <a href="https://matplotlib.org/tutorials/colors/colormaps.html">Colormap</a><br>通常包含一系列的渐变色或其他颜色组合，取值参见<font color=#FF0000><strong>【6x00】Colormap 取值</strong></font></td></tr><tr><td>alpha</td><td>透明度，介于0（透明）和1（不透明）之间</td></tr><tr><td>origin</td><td>通过指定 Z[0，0] 的位置来确定 Z 的方向和确切位置，仅当未指定 X, Y 时才有意义<br><code>None</code>：Z[0，0] 位于左下角的 X=0, Y=0 处<br><code>&#39;lower&#39;</code>：Z [0, 0] 位于左下角的 X = 0.5, Y = 0.5 处<br><code>&#39;upper&#39;</code>：Z[0，0] 位于左上角的 X=N+0.5, Y=0.5 处<br><code>&#39;image&#39;</code>：使用 <code>rcParams[“image.origin”] = &#39;upper&#39;</code>的值</td></tr><tr><td>antialiased</td><td>是否启用抗锯齿渲染，默认 True</td></tr><tr><td>linewidths</td><td>等高线的线宽，如果是数字，则所有等高线都将使用此线宽<br>如果是序列，则将按指定的顺序以升序打印线宽<br>默认为 <code>rcParams[“lines.linewidth”] = 1.5</code></td></tr><tr><td>linestyles</td><td>等高线的样式，如果线条颜色为单色，则负等高线默认为虚线<br><code>&#39;-&#39;</code> or <code>&#39;solid&#39;</code>, <code>&#39;--&#39;</code> or <code>&#39;dashed&#39;</code>, <code>&#39;-.&#39;</code> or <code>&#39;dashdot&#39;</code> <code>&#39;:&#39;</code> or <code>&#39;dotted&#39;</code>, <code>&#39;none&#39;</code> or <code>&#39; &#39;</code> or <code>&#39;&#39;</code></td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20200512180336350.png" alt="分割线"></p><h2 id="【5x00】标记方法-matplotlib-pyplot-clabel"><a href="#【5x00】标记方法-matplotlib-pyplot-clabel" class="headerlink" title="【5x00】标记方法 matplotlib.pyplot.clabel()"></a><font color=#FF0000>【5x00】标记方法 matplotlib.pyplot.clabel()</font></h2><p><code>matplotlib.pyplot.clabel(CS, \*args, \*\*kwargs)</code> 方法可用于标记等高线图。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>CS</td><td>ContourSet（等高线集）对象，即 <code>pyplot.contour()</code> 返回的对象</td></tr><tr><td>levels</td><td>需要标记的等高线集，数组类型，如果未指定则默认标记所有等高线</td></tr><tr><td>fontsize</td><td>标记的字体大小，可选项：<br><code>&#39;xx-small&#39;</code>, <code>&#39;x-small&#39;</code>, <code>&#39;small&#39;</code>, <code>&#39;medium&#39;</code>, <code>&#39;large&#39;</code>, <code>&#39;x-large&#39;</code>, <code>&#39;xx-large&#39;</code></td></tr><tr><td>colors</td><td>标记的颜色，颜色字符串或颜色序列</td></tr><tr><td>inline</td><td>是否在标签位置移除轮廓显示，bool 类型，默认 True</td></tr><tr><td>inline_spacing</td><td>标签位置移除轮廓的宽度，float 类型，默认为 5</td></tr><tr><td>fmt</td><td>标签的格式字符串。str 或 dict 类型，默认值为 <code>%1.3f</code></td></tr><tr><td>rightside_up</td><td>是否将标签旋转始终与水平面成正负90度，bool 类型，默认 True</td></tr><tr><td>use_clabeltext</td><td>默认为 False，如果为 True，则使用 <a href="https://matplotlib.org/api/contour_api.html#matplotlib.contour.ClabelText">ClabelText</a> 类（而不是 <a href="https://matplotlib.org/api/text_api.html#matplotlib.text.Text">Text</a>）创建标签<br>ClabelText  在绘图期间重新计算文本的旋转角度，如果轴的角度发生变化，则可以使用此功能</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20200512112427932.png" alt="分割线"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106066852未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【6x00】Colormap-取值"><a href="#【6x00】Colormap-取值" class="headerlink" title="【6x00】Colormap 取值"></a><font color=#FF0000>【6x00】Colormap 取值</font></h2><p><code>matplotlib.pyplot.contour()</code> 和 <code>matplotlib.pyplot.contourf()</code> 中 <code>cmap</code> 参数用于设置等高线的颜色，取值通常为 Colormap 中的值，通常包含一系列的渐变色或其他颜色组合。具体参加下图。</p><p>官方文档：<a href="https://matplotlib.org/tutorials/colors/colormaps.html">https://matplotlib.org/tutorials/colors/colormaps.html</a></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A75/03.png" alt="03"></p><p><img src="https://img-blog.csdnimg.cn/20200512112427932.png" alt="分割线"></p><h2 id="【7x00】简单示例"><a href="#【7x00】简单示例" class="headerlink" title="【7x00】简单示例"></a><font color=#FF0000>【7x00】简单示例</font></h2><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(-2.0, 2.0, 0.01)y = np.arange(-2.0, 2.0, 0.01)m, n = np.meshgrid(x, y)        # 生成网格点坐标矩阵# 指定一个函数用于计算每个点的高度，也可以直接使用二维数组储存每个点的高度def f(a, b):    return (1 - b ** 5 + a ** 5) * np.exp(-a ** 2 - b ** 2)# 绘制等高线图，8 个数据间隔，颜色为黑色plt.contour(m, n, f(m, n), 8, colors=&#39;k&#39;)plt.title(&#39;等高线图简单示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A75/04.png" alt="04"></p><p><img src="https://img-blog.csdnimg.cn/20200512112427932.png" alt="分割线"></p><h2 id="【8x00】添加标记"><a href="#【8x00】添加标记" class="headerlink" title="【8x00】添加标记"></a><font color=#FF0000>【8x00】添加标记</font></h2><p><code>matplotlib.pyplot.clabel()</code> 方法用于给等高线添加标记。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(-2.0, 2.0, 0.01)y = np.arange(-2.0, 2.0, 0.01)m, n = np.meshgrid(x, y)        # 生成网格点坐标矩阵# 指定一个函数用于计算每个点的高度，也可以直接使用二维数组储存每个点的高度def f(a, b):    return (1 - b ** 5 + a ** 5) * np.exp(-a ** 2 - b ** 2)# 绘制等高线图，8 个数据间隔，颜色为黑色C = plt.contour(m, n, f(m, n), 8, colors=&#39;k&#39;)# 添加标记，标记处不显示轮廓线，颜色为黑红绿蓝四种，保留两位小数plt.clabel(C, inline=True, colors=[&#39;k&#39;, &#39;r&#39;, &#39;g&#39;, &#39;b&#39;], fmt=&#39;%1.2f&#39;)plt.title(&#39;等高线图添加标记示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A75/05.png" alt="05"></p><p><img src="https://img-blog.csdnimg.cn/20200512112427932.png" alt="分割线"></p><h2 id="【9x00】轮廓线颜色和样式"><a href="#【9x00】轮廓线颜色和样式" class="headerlink" title="【9x00】轮廓线颜色和样式"></a><font color=#FF0000>【9x00】轮廓线颜色和样式</font></h2><p><code>matplotlib.pyplot.contour()</code> 方法中，<code>colors</code> 参数即可为等高线轮廓设置颜色，可以是单色，也可以是一个颜色列表，<code>linestyles</code> 参数可以设置轮廓线样式，注意，如果线条颜色为单色，则负等高线（高度值为负）默认为虚线。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(-2.0, 2.0, 0.01)y = np.arange(-2.0, 2.0, 0.01)m, n = np.meshgrid(x, y)        # 生成网格点坐标矩阵# 指定一个函数用于计算每个点的高度，也可以直接使用二维数组储存每个点的高度def f(a, b):    return (1 - b ** 5 + a ** 5) * np.exp(-a ** 2 - b ** 2)colors = [&#39;k&#39;, &#39;r&#39;, &#39;g&#39;, &#39;b&#39;]# 绘制等高线图，8 个数据间隔，颜色为黑色，线条样式为 --C = plt.contour(m, n, f(m, n), 8, colors=colors, linestyles=&#39;--&#39;)# 添加标记，标记处不显示轮廓线，颜色为黑红绿蓝四种，保留两位小数plt.clabel(C, inline=True, colors=colors, fmt=&#39;%1.2f&#39;)plt.title(&#39;等高线图设置颜色/样式示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A75/06.png" alt="06"></p><p>如果想启用渐变色，则可以设置 <code>cmap</code>，取值参见<font color=#FF0000><strong>【6x00】Colormap 取值</strong></font>，<code>colorbar()</code> 方法可以显示颜色对照条。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(-2.0, 2.0, 0.01)y = np.arange(-2.0, 2.0, 0.01)m, n = np.meshgrid(x, y)        # 生成网格点坐标矩阵# 指定一个函数用于计算每个点的高度，也可以直接使用二维数组储存每个点的高度def f(a, b):    return (1 - b ** 5 + a ** 5) * np.exp(-a ** 2 - b ** 2)# 绘制等高线图，8 个数据间隔，颜色为 plasmaC = plt.contour(m, n, f(m, n), 8, cmap=&#39;plasma&#39;)# 添加标记，标记处不显示轮廓线，颜色为黑色，保留两位小数plt.clabel(C, inline=True, colors=&#39;k&#39;, fmt=&#39;%1.2f&#39;)# 显示颜色条plt.colorbar()plt.title(&#39;等高线图设置渐变色示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A75/07.png" alt="07"></p><p><img src="https://img-blog.csdnimg.cn/20200512112427932.png" alt="分割线"></p><h2 id="【10x00】颜色填充"><a href="#【10x00】颜色填充" class="headerlink" title="【10x00】颜色填充"></a><font color=#FF0000>【10x00】颜色填充</font></h2><p><code>matplotlib.pyplot.contourf()</code> 方法用于对等高线之间的地方进行颜色填充。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(-2.0, 2.0, 0.01)y = np.arange(-2.0, 2.0, 0.01)m, n = np.meshgrid(x, y)        # 生成网格点坐标矩阵# 指定一个函数用于计算每个点的高度，也可以直接使用二维数组储存每个点的高度def f(a, b):    return (1 - b ** 5 + a ** 5) * np.exp(-a ** 2 - b ** 2)# 绘制等高线图，8 个数据间隔，颜色为 plasmaplt.contourf(m, n, f(m, n), 8, cmap=&#39;plasma&#39;)C = plt.contour(m, n, f(m, n), 8, cmap=&#39;plasma&#39;)# 添加标记，标记处不显示轮廓线，颜色为黑色，保留两位小数plt.clabel(C, inline=True, colors=&#39;k&#39;, fmt=&#39;%1.2f&#39;)# 显示颜色条plt.colorbar()plt.title(&#39;等高线图颜色填充示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A75/08.png" alt="08"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106066852未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Matplotlib（七）：饼状图的绘制</title>
      <link href="/article/020/"/>
      <url>/article/020/</url>
      
        <content type="html"><![CDATA[<p>Matplotlib 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/014/">Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</a></li><li><a href="https://www.itbob.cn/article/015/">Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/016/">Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/017/">Python 数据分析三剑客之 Matplotlib（四）：线性图的绘制</a></li><li><a href="https://www.itbob.cn/article/018/">Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制</a></li><li><a href="https://www.itbob.cn/article/019/">Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制</a></li><li><a href="https://www.itbob.cn/article/020/">Python 数据分析三剑客之 Matplotlib（七）：饼状图的绘制</a></li><li><a href="https://www.itbob.cn/article/021/">Python 数据分析三剑客之 Matplotlib（八）：等高线 / 等值线图的绘制</a></li><li><a href="https://www.itbob.cn/article/022/">Python 数据分析三剑客之 Matplotlib（九）：极区图 / 极坐标图 / 雷达图的绘制</a></li><li><a href="https://www.itbob.cn/article/023/">Python 数据分析三剑客之 Matplotlib（十）：3D 图的绘制</a></li><li><a href="https://www.itbob.cn/article/024/">Python 数据分析三剑客之 Matplotlib（十一）：最热门最常用的 50 个图表</a>【译文】</li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106025845未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】方法描述"><a href="#【1x00】方法描述" class="headerlink" title="【1x00】方法描述"></a><font color=#FF0000>【1x00】方法描述</font></h2><p><code>matplotlib.pyplot.pie()</code> 方法用于绘制饼状图。</p><p>基本语法：</p><pre><code class="python">matplotlib.pyplot.pie(        x[, explode=None, labels=None, colors=None,        autopct=None, pctdistance=0.6, shadow=False,        labeldistance=1.1, startangle=None, radius=None,        counterclock=True, wedgeprops=None, textprops=None,        center=(0, 0), frame=False, rotatelabels=False, \*, data=None]        )</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>x</td><td>每个扇形块的大小，数组形式，大小单位是比例</td></tr><tr><td>explode</td><td>指定对应扇形块脱离饼图的半径大小，数组形式，其中元素个数应该是 len(x)</td></tr><tr><td>labels</td><td>每个扇形块上的文本标签，列表形式</td></tr><tr><td>labeldistance</td><td>每个扇形块上的文本标签与扇形中心的距离，float 类型，默认 1.1</td></tr><tr><td>colors</td><td>每个扇形块对应的颜色，数组形式</td></tr><tr><td>autopct</td><td>用于计算每个扇形块所占比例，字符串或者函数类型<br>例如：<code>autopct=&#39;%1.1f%%&#39;</code> 表示浮点数，保留一位小数，并添加百分比符号</td></tr><tr><td>pctdistance</td><td>每个扇形块的中心与 autopct 生成的文本之间的距离，float 类型，默认 0.6</td></tr><tr><td>shadow</td><td>是否为扇形添加阴影效果</td></tr><tr><td>startangle</td><td>将饼图按照逆时针旋转指定的角度，float 类型</td></tr><tr><td>radius</td><td>饼图的半径，如果是 None，则将被设置为 1，float 类型</td></tr><tr><td>counterclock</td><td>是否按照逆时针对扇形图进行排列，bool 类型，默认 True</td></tr><tr><td>wedgeprops</td><td>传递给绘制每个扇形图对象的参数，字典形式，参数值参见 <a href="https://matplotlib.org/api/_as_gen/matplotlib.patches.Wedge.html#matplotlib.patches.Wedge">Wedge</a><br>例如：<code>wedgeprops = &#123;&#39;linewidth&#39;: 3&#125;</code> 设置扇形边框线宽度为 3</td></tr><tr><td>textprops</td><td>传递给文本对象的参数，字典形式<br>例如：<code>textprops=&#123;&#39;color&#39;: &#39;r&#39;, &#39;fontsize&#39;: 15&#125;</code> 设置文字为红色，大小为15</td></tr><tr><td>center</td><td>饼图圆心在画布上是坐标，默认 (0, 0)</td></tr><tr><td>frame</td><td>是否显示 x, y 坐标轴外框，默认 False</td></tr><tr><td>rotatelabels</td><td>是否按照角度进行调整每块饼的 label 文本标签，默认 False</td></tr></tbody></table><h2 id="【2x00】简单示例"><a href="#【2x00】简单示例" class="headerlink" title="【2x00】简单示例"></a><font color=#FF0000>【2x00】简单示例</font></h2><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = [10, 30, 45, 15]labels = [&#39;Java&#39;, &#39;Golang&#39;, &#39;Python&#39;, &#39;C++&#39;]colors = [&#39;red&#39;, &#39;yellow&#39;, &#39;blue&#39;, &#39;green&#39;]# 指定4个扇区所占比例以及扇区的颜色，扇区文本标签距离扇区中心1.1plt.pie(x, labels=labels, colors=colors, labeldistance=1.1)plt.title(&#39;饼状图简单示例&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A74/01.png" alt="01"></p><h2 id="【3x00】按角度调整扇形标签"><a href="#【3x00】按角度调整扇形标签" class="headerlink" title="【3x00】按角度调整扇形标签"></a><font color=#FF0000>【3x00】按角度调整扇形标签</font></h2><p><code>rotatelabels</code> 属性可以设置是否按照角度调整每块饼的 label（标签）显示方式。</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = [10, 30, 45, 15]labels = [&#39;Java&#39;, &#39;Go&#39;, &#39;Python&#39;, &#39;C++&#39;]colors = [&#39;red&#39;, &#39;yellow&#39;, &#39;blue&#39;, &#39;green&#39;]# 指定4个扇区所占比例以及扇区的颜色，扇区文本标签距离扇区中心1.1，按角度调整 labelsplt.pie(x, labels=labels, colors=colors, labeldistance=1.1, rotatelabels=True)plt.title(&#39;饼状图按角度调整 labels 示例&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A74/02.png" alt="02"></p><h2 id="【4x00】显示图例"><a href="#【4x00】显示图例" class="headerlink" title="【4x00】显示图例"></a><font color=#FF0000>【4x00】显示图例</font></h2><p>与前面文章中绘制线性图、散点图、条形图一样，调用 <code>matplotlib.pyplot.legend()</code> 方法可绘制图例，该方法的参数解释参见前文<a href="https://itrhx.blog.csdn.net/article/details/105828143">《Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性》</a></p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = [10, 30, 45, 15]labels = [&#39;Java&#39;, &#39;Go&#39;, &#39;Python&#39;, &#39;C++&#39;]colors = [&#39;red&#39;, &#39;yellow&#39;, &#39;blue&#39;, &#39;green&#39;]plt.pie(x, labels=labels, colors=colors, labeldistance=1.1)plt.title(&#39;饼状图显示图例示例&#39;)plt.legend(bbox_to_anchor=(1, 1))plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A74/03.png" alt="03"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106025845未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【5x00】突出显示扇形块"><a href="#【5x00】突出显示扇形块" class="headerlink" title="【5x00】突出显示扇形块"></a><font color=#FF0000>【5x00】突出显示扇形块</font></h2><p><code>explode</code> 参数可以实现突出显示某一块扇区，接收数组形式的参数，这个数组中的元素个数应该是 len(x)，即和扇区块的数量相同。</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = [10, 30, 45, 15]labels = [&#39;Java&#39;, &#39;Golang&#39;, &#39;Python&#39;, &#39;C++&#39;]colors = [&#39;red&#39;, &#39;yellow&#39;, &#39;blue&#39;, &#39;green&#39;]# 指定第一个扇区块脱离饼图的半径大小为0.3，其它扇区不脱离plt.pie(x, labels=labels, colors=colors, labeldistance=1.1, explode=[0.3, 0, 0, 0])plt.title(&#39;饼状图突出显示扇形块示例&#39;)plt.legend(bbox_to_anchor=(1, 1))plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A74/04.png" alt="04"></p><h2 id="【6x00】显示各扇区所占百分比"><a href="#【6x00】显示各扇区所占百分比" class="headerlink" title="【6x00】显示各扇区所占百分比"></a><font color=#FF0000>【6x00】显示各扇区所占百分比</font></h2><p><code>autopct</code> 参数可用于计算每个扇形块所占比例，接收字符串或者函数类型，例如：<code>autopct=&#39;%1.1f%%&#39;</code> 表示浮点数，保留一位小数，并添加百分比符号。<code>pctdistance</code> 参数用于调整每个扇形块的中心与 <code>autopct</code> 生成的文本之间的距离，float 类型，默认 0.6。</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = [10, 30, 45, 15]labels = [&#39;Java&#39;, &#39;Golang&#39;, &#39;Python&#39;, &#39;C++&#39;]colors = [&#39;red&#39;, &#39;yellow&#39;, &#39;blue&#39;, &#39;green&#39;]plt.pie(    x,                        # 每个扇形块所占比例    labels=labels,            # 扇形块文本标签    colors=colors,            # 扇形块颜色    labeldistance=1.1,        # 扇形块标签距离中心的距离    explode=[0.3, 0, 0, 0],   # 第一个扇形块突出显示    autopct=&#39;%1.1f%%&#39;,        # 显示百分比，保留一位小数    pctdistance=0.5           # 百分比文本距离饼状图中心的距离)plt.title(&#39;饼状图显示各扇区所占百分比示例&#39;)plt.legend(bbox_to_anchor=(1, 1))  # 显示图例plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A74/05.png" alt="05"></p><h2 id="【7x00】旋转饼状图"><a href="#【7x00】旋转饼状图" class="headerlink" title="【7x00】旋转饼状图"></a><font color=#FF0000>【7x00】旋转饼状图</font></h2><p><code>startangle</code> 参数可以选择饼状图，改变饼状图放置的角度。注意是按照逆时针旋转。</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = [10, 30, 45, 15]labels = [&#39;Java&#39;, &#39;Golang&#39;, &#39;Python&#39;, &#39;C++&#39;]colors = [&#39;red&#39;, &#39;yellow&#39;, &#39;blue&#39;, &#39;green&#39;]plt.pie(    x,                        # 每个扇形块所占比例    labels=labels,            # 扇形块文本标签    colors=colors,            # 扇形块颜色    labeldistance=1.1,        # 扇形块标签距离中心的距离    explode=[0.3, 0, 0, 0],   # 第一个扇形块突出显示    autopct=&#39;%1.1f%%&#39;,        # 显示百分比，保留一位小数    pctdistance=0.5,          # 百分比文本距离饼状图中心的距离    startangle=-90            # 逆时针旋转-90°，即顺时针旋转90°)plt.title(&#39;饼状图旋转角度示例&#39;)plt.legend(bbox_to_anchor=(1, 1))  # 显示图例plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A74/06.png" alt="06"></p><h2 id="【8x00】自定义每个扇形和文字属性"><a href="#【8x00】自定义每个扇形和文字属性" class="headerlink" title="【8x00】自定义每个扇形和文字属性"></a><font color=#FF0000>【8x00】自定义每个扇形和文字属性</font></h2><p><code>wedgeprops</code> 参数以字典形式为每个扇形添加自定义属性，例如：<code>wedgeprops = &#123;&#39;linewidth&#39;: 3&#125;</code> 设置扇形边框线宽度为 3，更多其他参数值参见 <a href="https://matplotlib.org/api/_as_gen/matplotlib.patches.Wedge.html#matplotlib.patches.Wedge">Wedge</a>；</p><p><code>textprops</code> 参数同样以字典形式为文本对象添加自定义属性，例如：<code>textprops=&#123;&#39;color&#39;: &#39;r&#39;, &#39;fontsize&#39;: 15&#125;</code> 设置文字为红色，大小为15，更多其他参数值参见 <a href="https://matplotlib.org/api/text_api.html?highlight=text#matplotlib.text.Text">Text</a>。</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = [10, 30, 45, 15]labels = [&#39;Java&#39;, &#39;Golang&#39;, &#39;Python&#39;, &#39;C++&#39;]colors = [&#39;red&#39;, &#39;yellow&#39;, &#39;blue&#39;, &#39;green&#39;]plt.pie(    x,                           # 每个扇形块所占比例    labels=labels,               # 扇形块文本标签    colors=colors,               # 扇形块颜色    labeldistance=1.1,           # 扇形块标签距离中心的距离    explode=[0.3, 0, 0, 0],      # 第一个扇形块突出显示    autopct=&#39;%1.1f%%&#39;,           # 显示百分比，保留一位小数    pctdistance=0.6,             # 百分比文本距离饼状图中心的距离    shadow=True,                 # 显示阴影效果    wedgeprops=&#123;                 # 为每个扇形添加属性        &#39;width&#39;: 0.7,            # 扇形宽度0.7        &#39;edgecolor&#39;: &#39;#98F5FF&#39;,  # 扇形边缘线颜色        &#39;linewidth&#39;: 3           # 扇形边缘线宽度    &#125;,    textprops=&#123;                  # 为文字添加属性        &#39;fontsize&#39;: 13,          # 文字大小        &#39;fontweight&#39;: &#39;bold&#39;,    # 文字粗细        &#39;color&#39;: &#39;k&#39;             # 文字颜色，黑色    &#125;)plt.title(&#39;饼状图自定义每个扇形和文字属性示例&#39;, fontweight=&#39;bold&#39;)plt.legend(bbox_to_anchor=(1, 1), borderpad=0.6)  # 显示图例plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A74/07.png" alt="07"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/106025845未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Matplotlib（六）：直方图/柱状图/条形图的绘制</title>
      <link href="/article/019/"/>
      <url>/article/019/</url>
      
        <content type="html"><![CDATA[<p>Matplotlib 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/014/">Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</a></li><li><a href="https://www.itbob.cn/article/015/">Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/016/">Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/017/">Python 数据分析三剑客之 Matplotlib（四）：线性图的绘制</a></li><li><a href="https://www.itbob.cn/article/018/">Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制</a></li><li><a href="https://www.itbob.cn/article/019/">Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制</a></li><li><a href="https://www.itbob.cn/article/020/">Python 数据分析三剑客之 Matplotlib（七）：饼状图的绘制</a></li><li><a href="https://www.itbob.cn/article/021/">Python 数据分析三剑客之 Matplotlib（八）：等高线 / 等值线图的绘制</a></li><li><a href="https://www.itbob.cn/article/022/">Python 数据分析三剑客之 Matplotlib（九）：极区图 / 极坐标图 / 雷达图的绘制</a></li><li><a href="https://www.itbob.cn/article/023/">Python 数据分析三剑客之 Matplotlib（十）：3D 图的绘制</a></li><li><a href="https://www.itbob.cn/article/024/">Python 数据分析三剑客之 Matplotlib（十一）：最热门最常用的 50 个图表</a>【译文】</li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105952856未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】直方图-柱状图-条形图的区别"><a href="#【1x00】直方图-柱状图-条形图的区别" class="headerlink" title="【1x00】直方图 / 柱状图 / 条形图的区别"></a><font color=#FF0000>【1x00】直方图 / 柱状图 / 条形图的区别</font></h2><ul><li><p>直方图：直方图（Histogram）又称质量分布图，是一种统计报告图，由一系列高度不等的纵向条纹或线段表示数据分布的情况。<font color=##0000FF><strong>一般用于描述连续型数据的分布关系</strong></font>，用横轴表示数据类型，纵轴表示分布情况。直方图是用面积表示各组频数的多少，矩形的高度表示每一组的频数或频率，宽度则表示各组的组距，因此其<font color=##32CD32><strong>高度与宽度均有意义</strong></font>。其次，由于分组数据具有连续性，<font color=##32CD32><strong>直方图的各矩形通常是连续排列。</strong></font></p></li><li><p>柱状图：柱状图（bar chart）又称条图、长条图、柱状统计图、条状图、棒形图，是一种以长方形的长度为变量的统计图表。<font color=##0000FF><strong>一般用于描述离散型分类数据的对比</strong></font>，长条图用来比较两个或以上的价值（不同时间或者不同条件），只有一个变量，通常利用于较小的数据集分析。柱状图亦可横向排列，或用多维方式表达。<font color=##32CD32><strong>柱状图各矩形的宽度固定，矩形之间分开排列，会有间距。</strong></font></p></li><li><p>条形图：通常情况下<font color=#FF0000><strong>条形图 = 柱状图</strong></font>，也可以<font color=#FF0000><strong>将横向排列的柱状图称为条形图</strong></font>。在本文中会将条形图视为后者。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200509010455973.png" alt="分割线"></p><h2 id="【2x00】直方图的绘制"><a href="#【2x00】直方图的绘制" class="headerlink" title="【2x00】直方图的绘制"></a><font color=#FF0000>【2x00】直方图的绘制</font></h2><h3 id="【2x01】函数介绍-matplotlib-pyplot-hist"><a href="#【2x01】函数介绍-matplotlib-pyplot-hist" class="headerlink" title="【2x01】函数介绍 matplotlib.pyplot.hist()"></a><font color=##4876FF>【2x01】函数介绍 matplotlib.pyplot.hist()</font></h3><p><code>matplotlib.pyplot.hist()</code> 函数用于绘制直方图。</p><p>基本语法：<code>matplotlib.pyplot.hist(x[, bins=None, range=None, density=False, bottom=None, histtype=&#39;bar&#39;, align=&#39;mid&#39;, orientation=&#39;vertical&#39;, rwidth=None, log=False, color=None, label=None, stacked=False, \*\*kwargs])</code></p><p>基本参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>x</td><td>数据集，数组或数组序列</td></tr><tr><td>bins</td><td>统计的分布区间、条形数，可以是整数、序列或字符串，默认 <code>rcParams[&quot;hist.bins&quot;] =10</code><br>如果 bins 是整数，则定义的是等宽的矩形的个数<br>如果 bins 是序列，则定义的是每个矩形的区间，如：<code>bins = [1, 2, 3, 4]</code>，则矩形分布区间为 <code>[1,2)</code>、<code>[2,3)</code>、<code>[3,4]</code><br>如果 bins 是字符串，则它应该是 <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram_bin_edges.html#numpy.histogram_bin_edges">numpy.histogram_bin_edges</a> 所支持的策略之一</td></tr><tr><td>range</td><td>矩形分布的区间，在没有指定 bins 生效，元组类型</td></tr><tr><td>density</td><td>是否<strong>显示频率统计结果</strong>，<code>频率统计结果=区间数目/(总数*区间宽度)</code></td></tr><tr><td>bottom</td><td>y 轴的起始位置，默认为 0</td></tr><tr><td>histtype</td><td>矩形的样式，有四种类型可选：<br><code>&#39;bar&#39;</code>：默认值，传统的条形直方图，如果给出多个数据，则条形图并排排列<br><code>&#39;barstacked&#39;</code>：当数据为 1 个时，和 bar 结果一样，当数据为多个时，则进行垂直堆叠<br><code>&#39;step&#39;</code>：未填充的线条形式；<code>&#39;stepfilled&#39;</code>：填充的线条形式，效果与 bar 差不多</td></tr><tr><td>align</td><td>矩形的中心位于 bins（x 轴） 的位置，<code>&#39;left&#39;</code>：左；<code>&#39;mid&#39;</code>：中；<code>&#39;right&#39;</code>：右</td></tr><tr><td>orientation</td><td>矩形的方向，<code>vertical</code>：垂直；<code>horizontal</code>：水平</td></tr><tr><td>rwidth</td><td>矩形的相对宽度，如果未指定，则自动计算宽度</td></tr><tr><td>log</td><td>y 坐标轴是否以指数刻度显示</td></tr><tr><td>color</td><td>矩形的颜色，默认蓝色，与 facecolor 作用相同，指定一个即可，如果两者都指定，则取 facecolor 的值</td></tr><tr><td>label</td><td>数据的标签，展示图例时使用</td></tr><tr><td>stacked</td><td>是否为堆积状图（当两个数据相似时，堆积在一起就会把第一个数据的显示相对缩小一点）</td></tr></tbody></table><p>其他参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>facecolor</td><td>标量或数组类型，每个矩形的颜色，与 color 作用相同，指定一个即可，如果两者都指定，则取 facecolor 的值</td></tr><tr><td>edgecolor</td><td>标量或数组类型，直方图边缘线的颜色</td></tr><tr><td>linewidth</td><td>标量或数组类型，直方图边缘线的宽度，如果为 0，则不绘制边</td></tr><tr><td>alpha</td><td>float 类型，矩形透明度</td></tr><tr><td>label</td><td>图例中显示的标签</td></tr><tr><td>linestyle / ls</td><td>线条样式，此处指矩形边缘线条样式<br><code>&#39;-&#39;</code> or <code>&#39;solid&#39;</code>, <code>&#39;--&#39;</code> or <code>&#39;dashed&#39;</code>, <code>&#39;-.&#39;</code> or <code>&#39;dashdot&#39;</code> or <code>&#39;:&#39;</code> or <code>&#39;dotted&#39;</code>, <code>&#39;none&#39;</code> or <code>&#39; &#39;</code> or <code>&#39;&#39;</code></td></tr><tr><td>linewidth / lw</td><td>线条宽度，此处指矩形边缘线的宽度，float 类型，默认 0.8</td></tr><tr><td>hatch</td><td>矩形的填充图案，可以是组合形式，如果有相同的图案，则会增加填充的密度<br>取值可以是：<code>&#39;/&#39;</code>, <code>&#39;\&#39;</code>, `’</td></tr></tbody></table><h3 id="【2x02】简单直方图示例"><a href="#【2x02】简单直方图示例" class="headerlink" title="【2x02】简单直方图示例"></a><font color=##4876FF>【2x02】简单直方图示例</font></h3><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]  # 设置中文显示x = np.random.randint(0, 101, 100)  # 数据集bins = np.arange(0, 101, 10)        # 分布区间 [0,10)、[10,20)...[90,100]plt.hist(x, bins=bins, linewidth=0.5, edgecolor=&#39;k&#39;)  # 边缘线宽0.5，颜色为黑色plt.xlim(0, 100)                    # x 轴刻度范围       plt.title(&#39;简单直方图示例&#39;)         # 标题plt.xlabel(&#39;x axis label&#39;)         # x 轴标签plt.ylabel(&#39;y axis label&#39;)         # y 轴标签plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/01.png" alt="01"></p><h3 id="【2x03】堆积的直方图"><a href="#【2x03】堆积的直方图" class="headerlink" title="【2x03】堆积的直方图"></a><font color=##4876FF>【2x03】堆积的直方图</font></h3><p>参数 <code>stacked</code> 决定了将两份数据进行堆积显示。注意，有可能两个数据相似（y 轴的值相似），但是堆积在一起的时候，会把第一个数据的显示相对缩小一点。</p><pre><code class="python">import matplotlib.pyplot as pltimport numpy as npplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]hist1 = np.random.randint(0, 100, 100)hist2 = np.random.randint(0, 100, 100)x = [hist1, hist2]colors = [&#39;orchid&#39;, &#39;deepskyblue&#39;]labels = [&#39;hist1&#39;, &#39;hist2&#39;]bins = range(0, 101, 10)# 绘制两份数据的直方图，数据集等其他参数可以使用列表形式传递，也可以使用两次 hist 函数单独传递plt.hist(x, bins=bins, color=colors, stacked=True, label=labels)plt.title(&#39;堆积的直方图示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.legend(loc=&quot;upper left&quot;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/02.png" alt="02"></p><h3 id="【2x04】填充其他样式"><a href="#【2x04】填充其他样式" class="headerlink" title="【2x04】填充其他样式"></a><font color=##4876FF>【2x04】填充其他样式</font></h3><p><code>hatch</code> 参数可以让直方图的矩形填充其他样式，可选值有：<code>&#39;/&#39;</code>, <code>&#39;\&#39;</code>, <code>&#39;|&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;x&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;O&#39;</code>, <code>&#39;.&#39;</code>, <code>&#39;*&#39;</code>。可以是不同图案的组合形式，如果有相同的图案，则会增加填充的密度。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]  # 设置中文显示x = np.random.randint(0, 101, 100)  # 数据集bins = np.arange(0, 101, 10)        # 分布区间 [0,10)、[10,20)...[90,100]# 矩形颜色为白色，使用 / 填充，边缘线宽0.5，颜色为黑色plt.hist(x, bins=bins, color=&#39;w&#39;, hatch=&#39;///&#39;, linewidth=0.5, edgecolor=&#39;k&#39;)plt.xlim(0, 100)                   # x 轴刻度范围plt.title(&#39;直方图图案填充示例&#39;)     # 标题plt.xlabel(&#39;x axis label&#39;)         # x 轴标签plt.ylabel(&#39;y axis label&#39;)         # y 轴标签plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/03.png" alt="03"></p><p><img src="https://img-blog.csdnimg.cn/20200509010455973.png" alt="分割线"></p><h2 id="【3x00】柱状图的绘制"><a href="#【3x00】柱状图的绘制" class="headerlink" title="【3x00】柱状图的绘制"></a><font color=#FF0000>【3x00】柱状图的绘制</font></h2><h3 id="【3x01】函数介绍-matplotlib-pyplot-bar"><a href="#【3x01】函数介绍-matplotlib-pyplot-bar" class="headerlink" title="【3x01】函数介绍 matplotlib.pyplot.bar()"></a><font color=##4876FF>【3x01】函数介绍 matplotlib.pyplot.bar()</font></h3><p><code>matplotlib.pyplot.bar()</code> 函数用于绘制柱状图。</p><p>基本语法：<code>matplotlib.pyplot.bar(x, height[, width=0.8, bottom=None, align=&#39;center&#39;, \*\*kwargs])</code></p><p>基本参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>x</td><td>标量序列，每个矩形对应的 x 轴刻度</td></tr><tr><td>height</td><td>标量或标量序列，每个矩形对应的高度，即 y 轴刻度</td></tr><tr><td>width</td><td>标量或数组类型，每个矩形的宽度，默认为 0.8</td></tr><tr><td>bottom</td><td>标量或数组类型，y 轴的起始位置，默认为 0</td></tr><tr><td>align</td><td>矩形与 x 轴刻度对齐的位置，<code>&#39;center&#39;</code>：中；<code>&#39;edge&#39;</code>：左边缘</td></tr></tbody></table><p>其他参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>color</td><td>标量或数组类型，每个矩形的颜色，与 facecolor 作用相同，指定一个即可，如果两者都指定，则取 facecolor 的值</td></tr><tr><td>edgecolor</td><td>标量或数组类型，柱状图边缘线的颜色</td></tr><tr><td>linewidth</td><td>标量或数组类型，柱状图边缘线的宽度，如果为0，则不绘制边</td></tr><tr><td>tick_label</td><td>标量或数组类型，柱状图 x 轴的刻度标签，默认使用数字标签</td></tr><tr><td>xerr / yerr</td><td>标量，指定对应标准差（添加误差线时会用到）</td></tr><tr><td>ecolor</td><td>标量或数组类型，误差线的线条颜色，默认值为 black</td></tr><tr><td>capsize</td><td>标量，误差线两头横线的宽度，默认为 <code>rcParams[&quot;errorbar.capsize&quot;] = 0.0</code></td></tr><tr><td>error_kw</td><td>字典类型，可以此字典中定义 ecolor 和 capsize，比单独指定的优先级要高</td></tr><tr><td>log</td><td>bool 值，y 坐标轴是否以指数刻度显示</td></tr><tr><td>alpha</td><td>float 类型，矩形透明度</td></tr><tr><td>label</td><td>图例中显示的标签</td></tr><tr><td>linestyle / ls</td><td>线条样式，此处指矩形边缘线条样式<br><code>&#39;-&#39;</code> or <code>&#39;solid&#39;</code>, <code>&#39;--&#39;</code> or <code>&#39;dashed&#39;</code>, <code>&#39;-.&#39;</code> or <code>&#39;dashdot&#39;</code> or <code>&#39;:&#39;</code> or <code>&#39;dotted&#39;</code>, <code>&#39;none&#39;</code> or <code>&#39; &#39;</code> or <code>&#39;&#39;</code></td></tr><tr><td>linewidth / lw</td><td>线条宽度，此处指矩形边缘线的宽度，float 类型，默认 0.8</td></tr><tr><td>hatch</td><td>矩形的填充图案，可以是组合形式，如果有相同的图案，则会增加填充的密度<br>取值可以是：<code>&#39;/&#39;</code>, <code>&#39;\&#39;</code>, `’</td></tr></tbody></table><h3 id="【3x02】简单柱状图示例"><a href="#【3x02】简单柱状图示例" class="headerlink" title="【3x02】简单柱状图示例"></a><font color=##4876FF>【3x02】简单柱状图示例</font></h3><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = [1, 2, 3, 4, 5]height = [5, 7, 4, 3, 1]# 设置 x 轴的标签，也可以用 plt.xticks 方法来设置tick_label = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;]# 设置颜色序列color = [&#39;red&#39;, &#39;yellow&#39;, &#39;peru&#39;, &#39;orchid&#39;, &#39;deepskyblue&#39;]# 绘制柱状图，边缘线宽度为1，颜色为黑色，样式为 --plt.bar(x, height, tick_label=tick_label, color=color, edgecolor=&#39;k&#39;, linewidth=1, linestyle=&#39;--&#39;)plt.title(&#39;简单柱状图示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/04.png" alt="04"></p><h3 id="【3x03】添加与标准差的误差线"><a href="#【3x03】添加与标准差的误差线" class="headerlink" title="【3x03】添加与标准差的误差线"></a><font color=##4876FF>【3x03】添加与标准差的误差线</font></h3><p>首先定义一个列表，其中的元素是与每个值对应的标准差，<code>ecolor</code> 和 <code>capsize</code> 参数分别指定误差线的颜色和两头横线的宽度。这两个参数可以通过 <code>error_kw</code> 字典形式组合起来。以字典形式的组合优先级别要比单独指定高。另外，柱状图指定标准差时要用 <code>yerr</code>，条形图（横向排列的柱状图）指定标准差时要用 <code>xerr</code>。</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = [1, 2, 3, 4, 5]height = [5, 7, 4, 3, 2]std = [0.5, 0.1, 1.2, 0.3, 1.0]   # 标准差tick_label = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;]  # 设置 x 轴的标签，也可以用 plt.xticks 方法来设置color = [&#39;red&#39;, &#39;yellow&#39;, &#39;peru&#39;, &#39;orchid&#39;, &#39;deepskyblue&#39;]  # 设置颜色序列plt.bar(    x,    height,    tick_label=tick_label,    color=color,    yerr=std,              # 指定对应标准差    # error_kw=&#123;    #     &#39;ecolor&#39;: &#39;k&#39;,   # 指定误差线的颜色    #     &#39;capsize&#39;: 6     # 指定误差线两头横线的宽度    # &#125;,    ecolor=&#39;k&#39;,    capsize=6,    edgecolor=&#39;k&#39;,         # 指定边缘线颜色    linewidth=1            # 指定边缘线宽度)plt.title(&#39;柱状图添加误差线示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/05.png" alt="05"></p><h3 id="【3x04】多序列柱状图"><a href="#【3x04】多序列柱状图" class="headerlink" title="【3x04】多序列柱状图"></a><font color=##4876FF>【3x04】多序列柱状图</font></h3><p>在绘制多序列的柱状图时，只需要多次调用 <code>matplotlib.pyplot.bar()</code> 函数即可，指定一个较小的宽度值（偏移量），绘制不同数据时设置不同的 x 位置刻度即可。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(5)height1 = np.array([5, 7, 4, 3, 2])height2 = np.array([2, 4, 6, 7, 3])height3 = np.array([3, 1, 7, 5, 2])# 设置宽度值（偏移量）width = 0.3# 绘制不同数据时，x 轴依次增加一个偏移量plt.bar(x, height1, width, label=&#39;bar1&#39;)plt.bar(x + width, height2, width, label=&#39;bar2&#39;)plt.bar(x + width * 2, height3, width, label=&#39;bar3&#39;)# 设置 x 轴刻度的标签plt.xticks(x + width, [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])plt.title(&#39;多序列柱状图示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/06.png" alt="06"></p><h3 id="【3x05】堆积的柱状图"><a href="#【3x05】堆积的柱状图" class="headerlink" title="【3x05】堆积的柱状图"></a><font color=##4876FF>【3x05】堆积的柱状图</font></h3><p>所谓堆积图，就是将多序列数据堆积到一个矩形上显示，在柱状图中要实现堆积图，只需要改变 <code>bottom</code> 参数即可，<code>bottom</code> 参数用于设置 y 轴基线，即柱状图的底边在 y 轴上的起始刻度，第一条数据 <code>data1</code> 的基线可以设置为 0，即默认值，第二条数据 <code>data2</code> 的基线可以设置在 <code>data1</code> 的上方，即 <code>bottom=data1</code>，第三条数据 <code>data3</code> 的基线可以设置在 <code>data1 + data2</code> 的上方，即 <code>bottom=data1+data2</code>，以此类推。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(5)height1 = np.array([5, 7, 4, 3, 2])height2 = np.array([2, 4, 6, 7, 3])height3 = np.array([3, 1, 7, 5, 2])plt.bar(x, height1, label=&#39;bar1&#39;)plt.bar(x, height2, label=&#39;bar2&#39;, bottom=height1)plt.bar(x, height3, label=&#39;bar3&#39;, bottom=(height2+height1))plt.xticks(x, [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])plt.title(&#39;堆积的柱状图示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/07.png" alt="07"></p><h3 id="【3x06】填充其他样式"><a href="#【3x06】填充其他样式" class="headerlink" title="【3x06】填充其他样式"></a><font color=##4876FF>【3x06】填充其他样式</font></h3><p><code>hatch</code> 参数可以让柱状图的矩形填充其他样式，可选值有：<code>&#39;/&#39;</code>, <code>&#39;\&#39;</code>, <code>&#39;|&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;x&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;O&#39;</code>, <code>&#39;.&#39;</code>, <code>&#39;*&#39;</code>。可以是不同图案的组合形式，如果有相同的图案，则会增加填充的密度。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(5)height1 = np.array([5, 7, 4, 3, 2])height2 = np.array([2, 4, 6, 7, 3])height3 = np.array([3, 1, 7, 5, 2])plt.bar(x, height1, label=&#39;bar1&#39;, color=&#39;w&#39;, hatch=&#39;///&#39;)plt.bar(x, height2, label=&#39;bar2&#39;, bottom=height1, color=&#39;w&#39;, hatch=&#39;xxx&#39;)plt.bar(x, height3, label=&#39;bar3&#39;, bottom=(height2+height1), color=&#39;w&#39;, hatch=&#39;|||&#39;)plt.xticks(x, [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])plt.title(&#39;柱状图图案填充示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/08.png" alt="08"></p><h3 id="【3x07】添加文字描述"><a href="#【3x07】添加文字描述" class="headerlink" title="【3x07】添加文字描述"></a><font color=##4876FF>【3x07】添加文字描述</font></h3><p>利用 <code>matplotlib.pyplot.text()</code> 方法可以在柱状图每个矩形上方添加文字描述。具体参数解释可参考前面的文章：<a href="https://itrhx.blog.csdn.net/article/details/105828049">《Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性》</a></p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(5)height1 = np.array([5, 7, 4, 3, 2])height2 = np.array([2, 4, 6, 7, 3])height3 = np.array([3, 1, 7, 5, 2])width = 0.3# 绘制不同数据时，x 轴依次增加一个偏移量plt.bar(x, height1, width, label=&#39;bar1&#39;)plt.bar(x + width, height2, width, label=&#39;bar2&#39;)plt.bar(x + width * 2, height3, width, label=&#39;bar3&#39;)# 依次添加每条数据的标签for a, b in zip(x, height1):    plt.text(a, b, b, ha=&#39;center&#39;, va=&#39;bottom&#39;)for c, d in zip(x, height2):    plt.text(c + width, d, d, ha=&#39;center&#39;, va=&#39;bottom&#39;)for e, f in zip(x, height3):    plt.text(e + width * 2, f, f, ha=&#39;center&#39;, va=&#39;bottom&#39;)# 设置 x 轴刻度的标签plt.xticks(x + width, [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])plt.title(&#39;柱状图添加文字描述示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/09.png" alt="09"></p><p><img src="https://img-blog.csdnimg.cn/20200509010455973.png" alt="分割线"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105952856未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【4x00】条形图的绘制"><a href="#【4x00】条形图的绘制" class="headerlink" title="【4x00】条形图的绘制"></a><font color=#FF0000>【4x00】条形图的绘制</font></h2><h3 id="【4x01】函数介绍-matplotlib-pyplot-barh"><a href="#【4x01】函数介绍-matplotlib-pyplot-barh" class="headerlink" title="【4x01】函数介绍 matplotlib.pyplot.barh()"></a><font color=##4876FF>【4x01】函数介绍 matplotlib.pyplot.barh()</font></h3><p><code>matplotlib.pyplot.barh()</code> 函数用于绘制条形图（水平排列的柱状图）。</p><p>基本语法：<code>matplotlib.pyplot.barh(y, width[, height=0.8, left=None, align=&#39;center&#39;, color, \*\*kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>y</td><td>标量或数组类型，每个矩形对应的 y 轴刻度</td></tr><tr><td>width</td><td>标量或数组类型，每个矩形的宽度，即 x 轴刻度</td></tr><tr><td>height</td><td>标量序列，每个矩形的高度，默认 0.8</td></tr><tr><td>left</td><td>标量序列，每个矩形的左侧 x 坐标的起始位置，默认值为 0</td></tr><tr><td>align</td><td>矩形的底边与 y 轴刻度对齐的位置，<code>&#39;center&#39;</code>：中；<code>&#39;edge&#39;</code>：底边</td></tr></tbody></table><p>其他参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>color</td><td>标量或数组类型，每个矩形的颜色，与 facecolor 作用相同，指定一个即可，如果两者都指定，则取 facecolor 的值</td></tr><tr><td>edgecolor</td><td>标量或数组类型，条形图边缘线的颜色</td></tr><tr><td>linewidth</td><td>标量或数组类型，条形图边缘线的宽度，如果为0，则不绘制边</td></tr><tr><td>tick_label</td><td>标量或数组类型，条形图 y 轴的刻度标签，默认使用数字标签</td></tr><tr><td>xerr / yerr</td><td>标量，指定对应标准差（添加误差线时会用到）</td></tr><tr><td>ecolor</td><td>标量或数组类型，误差线的线条颜色，默认值为 black</td></tr><tr><td>capsize</td><td>标量，误差线两头横线的宽度，默认为 <code>rcParams[&quot;errorbar.capsize&quot;] = 0.0</code></td></tr><tr><td>error_kw</td><td>字典类型，可以此字典中定义 ecolor 和 capsize，比单独指定的优先级要高</td></tr><tr><td>log</td><td>bool 值，y 坐标轴是否以指数刻度显示</td></tr><tr><td>alpha</td><td>float 类型，矩形透明度</td></tr><tr><td>label</td><td>图例中显示的标签</td></tr><tr><td>linestyle / ls</td><td>线条样式，此处指矩形边缘线条样式<br><code>&#39;-&#39;</code> or <code>&#39;solid&#39;</code>, <code>&#39;--&#39;</code> or <code>&#39;dashed&#39;</code>, <code>&#39;-.&#39;</code> or <code>&#39;dashdot&#39;</code> or <code>&#39;:&#39;</code> or <code>&#39;dotted&#39;</code>, <code>&#39;none&#39;</code> or <code>&#39; &#39;</code> or <code>&#39;&#39;</code></td></tr><tr><td>linewidth / lw</td><td>线条宽度，此处指矩形边缘线的宽度，float 类型，默认 0.8</td></tr><tr><td>hatch</td><td>矩形的填充图案，可以是组合形式，如果有相同的图案，则会增加填充的密度<br>取值可以是：<code>&#39;/&#39;</code>, <code>&#39;\&#39;</code>, `’</td></tr></tbody></table><h3 id="【4x02】简单条形图示例"><a href="#【4x02】简单条形图示例" class="headerlink" title="【4x02】简单条形图示例"></a><font color=##4876FF>【4x02】简单条形图示例</font></h3><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]y = [1, 2, 3, 4, 5]width = [5, 7, 4, 3, 1]tick_label = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;]color = [&#39;red&#39;, &#39;yellow&#39;, &#39;peru&#39;, &#39;orchid&#39;, &#39;deepskyblue&#39;]plt.barh(y, width, tick_label=tick_label, color=color, edgecolor=&#39;k&#39;, linewidth=1, linestyle=&#39;--&#39;)plt.title(&#39;简单条形图示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/10.png" alt="10"></p><h3 id="【4x03】添加与标准差的误差线"><a href="#【4x03】添加与标准差的误差线" class="headerlink" title="【4x03】添加与标准差的误差线"></a><font color=##4876FF>【4x03】添加与标准差的误差线</font></h3><p>与柱状图一样，首先定义一个列表，其中的元素是与每个值对应的标准差，<code>ecolor</code> 和 <code>capsize</code> 参数分别指定误差线的颜色和两头横线的宽度。这两个参数可以通过 <code>error_kw</code> 字典形式组合起来。以字典形式的组合优先级别要比单独指定高。另外，柱状图指定标准差时要用 <code>yerr</code>，条形图（横向排列的柱状图）指定标准差时要用 <code>xerr</code>。</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]y = [1, 2, 3, 4, 5]width = [5, 7, 4, 3, 2]std = [0.5, 0.1, 1.2, 0.3, 1.0]  # 标准差tick_label = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;]   # 设置 x 轴的标签，也可以用 plt.xticks 方法来设置color = [&#39;red&#39;, &#39;yellow&#39;, &#39;peru&#39;, &#39;orchid&#39;, &#39;deepskyblue&#39;]  # 颜色序列plt.barh(    y,    width,    tick_label=tick_label,    color=color,    xerr=std,               # 指定对应标准差    # error_kw=&#123;    #     &#39;ecolor&#39;: &#39;k&#39;,    # 指定误差线的颜色    #     &#39;capsize&#39;: 6      # 指定误差线两头横线的宽度    # &#125;,    ecolor=&#39;k&#39;,    capsize=6,    edgecolor=&#39;k&#39;,          # 指定边缘线颜色    linewidth=1             # 指定边缘线宽度)plt.title(&#39;条形图添加误差线示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/11.png" alt="11"></p><h3 id="【4x04】多序列条形图"><a href="#【4x04】多序列条形图" class="headerlink" title="【4x04】多序列条形图"></a><font color=##4876FF>【4x04】多序列条形图</font></h3><p>与多序列柱状图类似，在绘制多序列的条形图时，只需要多次调用 <code>matplotlib.pyplot.barh()</code> 函数即可，指定一个较小的高度值（偏移量），绘制不同数据时设置不同的 y 位置刻度即可。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]y = np.arange(5)width1 = np.array([5, 7, 4, 3, 2])width2 = np.array([2, 4, 6, 7, 3])width3 = np.array([3, 1, 7, 5, 2])# 设置高度值（偏移量）height = 0.3# 绘制不同数据时，y 轴依次增加一个偏移量plt.barh(y, width1, height, label=&#39;bar1&#39;)plt.barh(y + height, width2, height, label=&#39;bar2&#39;)plt.barh(y + height * 2, width3, height, label=&#39;bar3&#39;)# 设置 y 轴刻度的标签plt.yticks(y + height, [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])plt.title(&#39;多序列条形图示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/12.png" alt="12"></p><h3 id="【4x05】堆积的条形图"><a href="#【4x05】堆积的条形图" class="headerlink" title="【4x05】堆积的条形图"></a><font color=##4876FF>【4x05】堆积的条形图</font></h3><p>堆积图就是将多序列数据堆积到一个矩形上显示，和堆积的柱状图类似，在条形图中要实现堆积图，只需要改变 <code>left</code> 参数即可，<code>left</code> 参数用于设置 x 轴基线，即柱状图的底边在 x 轴上的起始刻度，第一条数据 <code>data1</code> 的基线可以设置为 0，即默认值，第二条数据 <code>data2</code> 的基线可以设置在 <code>data1</code> 的上方，即 <code>left=data1</code>，第三条数据 <code>data3</code> 的基线可以设置在 <code>data1 + data2</code> 的上方，即 <code>left=data1+data2</code>，以此类推。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]y = np.arange(5)width1 = np.array([5, 7, 4, 3, 2])width2 = np.array([2, 4, 6, 7, 3])width3 = np.array([3, 1, 7, 5, 2])plt.barh(y, width1, label=&#39;bar1&#39;)plt.barh(y, width2, label=&#39;bar2&#39;, left=width1)plt.barh(y, width3, label=&#39;bar3&#39;, left=(width1+width2))plt.yticks(y, [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])plt.title(&#39;堆积的条形图示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/13.png" alt="13"></p><h3 id="【4x06】填充其他样式"><a href="#【4x06】填充其他样式" class="headerlink" title="【4x06】填充其他样式"></a><font color=##4876FF>【4x06】填充其他样式</font></h3><p><code>hatch</code> 参数可以让柱状图的矩形填充其他样式，可选值有：<code>&#39;/&#39;</code>, <code>&#39;\&#39;</code>, <code>&#39;|&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;x&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;O&#39;</code>, <code>&#39;.&#39;</code>, <code>&#39;*&#39;</code>。可以是不同图案的组合形式，如果有相同的图案，则会增加填充的密度。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]y = np.arange(5)width1 = np.array([5, 7, 4, 3, 2])width2 = np.array([2, 4, 6, 7, 3])width3 = np.array([3, 1, 7, 5, 2])plt.barh(y, width1, label=&#39;bar1&#39;, color=&#39;w&#39;, hatch=&#39;///&#39;)plt.barh(y, width2, label=&#39;bar2&#39;, left=width1, color=&#39;w&#39;, hatch=&#39;xxx&#39;)plt.barh(y, width3, label=&#39;bar3&#39;, left=(width1+width2), color=&#39;w&#39;, hatch=&#39;|||&#39;)plt.yticks(y, [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])plt.title(&#39;条形图图案填充示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/14.png" alt="14"></p><h3 id="【4x07】添加文字描述"><a href="#【4x07】添加文字描述" class="headerlink" title="【4x07】添加文字描述"></a><font color=##4876FF>【4x07】添加文字描述</font></h3><p>利用 <code>matplotlib.pyplot.text()</code> 方法可以在条形图每个矩形上方添加文字描述。具体参数解释可参考前面的文章：<a href="https://itrhx.blog.csdn.net/article/details/105828049">《Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性》</a></p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]y = np.arange(5)width1 = np.array([5, 7, 4, 3, 2])width2 = np.array([2, 4, 6, 7, 3])width3 = np.array([3, 1, 7, 5, 2])height = 0.3# 绘制不同数据时，y 轴依次增加一个偏移量plt.barh(y, width1, height, label=&#39;bar1&#39;)plt.barh(y + height, width2, height, label=&#39;bar2&#39;)plt.barh(y + height * 2, width3, height, label=&#39;bar3&#39;)# 依次添加每条数据的标签for a, b in zip(width1, y):    plt.text(a, b-0.05, a)for c, d in zip(width2, y):    plt.text(c, d+0.20, c)for e, f in zip(width3, y):    plt.text(e, f+0.50, e)# 设置 y 轴刻度的标签plt.yticks(y + height, [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])plt.title(&#39;条形图添加文字描述示例&#39;)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A73/15.png" alt="15"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105952856未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制</title>
      <link href="/article/018/"/>
      <url>/article/018/</url>
      
        <content type="html"><![CDATA[<p>Matplotlib 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/014/">Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</a></li><li><a href="https://www.itbob.cn/article/015/">Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/016/">Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/017/">Python 数据分析三剑客之 Matplotlib（四）：线性图的绘制</a></li><li><a href="https://www.itbob.cn/article/018/">Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制</a></li><li><a href="https://www.itbob.cn/article/019/">Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制</a></li><li><a href="https://www.itbob.cn/article/020/">Python 数据分析三剑客之 Matplotlib（七）：饼状图的绘制</a></li><li><a href="https://www.itbob.cn/article/021/">Python 数据分析三剑客之 Matplotlib（八）：等高线 / 等值线图的绘制</a></li><li><a href="https://www.itbob.cn/article/022/">Python 数据分析三剑客之 Matplotlib（九）：极区图 / 极坐标图 / 雷达图的绘制</a></li><li><a href="https://www.itbob.cn/article/023/">Python 数据分析三剑客之 Matplotlib（十）：3D 图的绘制</a></li><li><a href="https://www.itbob.cn/article/024/">Python 数据分析三剑客之 Matplotlib（十一）：最热门最常用的 50 个图表</a>【译文】</li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105914929未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】方法描述"><a href="#【1x00】方法描述" class="headerlink" title="【1x00】方法描述"></a><font color=#FF0000>【1x00】方法描述</font></h2><p><code>matplotlib.pyplot.scatter()</code> 方法可用于绘制散点图。</p><p>本文用到的其他图像属性可参考前面的两篇文章：</p><p><a href="https://itrhx.blog.csdn.net/article/details/105828049">《Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性》</a><br><a href="https://itrhx.blog.csdn.net/article/details/105828143">《Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图等基本图像属性》</a></p><p>基本语法：<code>matplotlib.pyplot.scatter(x, y, s=None, c=None, marker=None, cmap=None, alpha=None, linewidths=None, edgecolors=None, \*\*kwargs)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>x,y</td><td>数据位置，标量或类似数组的形式</td></tr><tr><td>s</td><td>标记的大小，以磅为单位，默认 <code>rcParams[&#39;lines.markersize&#39;] ** 2</code>，即 6**2=36</td></tr><tr><td>color / c</td><td>标记的颜色，可以是单个颜色或者一个颜色列表<br>支持英文颜色名称及其简写、十六进制颜色码等，更多颜色示例参见官网 <a href="https://matplotlib.org/gallery/color/color_demo.html">Color Demo</a></td></tr><tr><td>marker</td><td>标记的样式，默认为 <code>rcParams[&quot;scatter.marker&quot;] = &#39;o&#39;</code>，更多样式参见<font color=#FF0000><strong>表一</strong></font></td></tr><tr><td>cmap</td><td>将浮点数映射成颜色的颜色映射表，即一个 <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Colormap.html#matplotlib.colors.Colormap">Colormap</a> 实例或注册的颜色表名，仅当 c 是浮点数数组时才使用 cmap</td></tr><tr><td>alpha</td><td>标记的透明度，float 类型，取值范围：[0, 1]，默认为 1.0，即不透明</td></tr><tr><td>linewidths</td><td>标记边缘的线宽，默认为 <code>rcParams[&quot;lines.linewidth&quot;] = 1.5</code></td></tr><tr><td>edgecolors</td><td>标记边缘的颜色，可以是单个颜色或者一个颜色列表<br>支持英文颜色名称及其简写、十六进制颜色码等，更多颜色示例参见官网 <a href="https://matplotlib.org/gallery/color/color_demo.html">Color Demo</a></td></tr></tbody></table><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font color="FF0000" size=3px>表一：marker 标记的样式</font></strong></td></tr></table><table><thead><tr><th>标记</th><th>描述</th></tr></thead><tbody><tr><td><code>&quot;.&quot;</code></td><td>点</td></tr><tr><td><code>&quot;,&quot;</code></td><td>像素点</td></tr><tr><td><code>&quot;o&quot;</code></td><td>圆圈</td></tr><tr><td><code>&quot;v&quot;</code></td><td>倒三角</td></tr><tr><td><code>&quot;^&quot;</code></td><td>正三角</td></tr><tr><td><code>&quot;&lt;&quot;</code></td><td>左三角</td></tr><tr><td><code>&quot;&gt;&quot;</code></td><td>右三角</td></tr><tr><td><code>&quot;1&quot;</code></td><td>倒三叉星</td></tr><tr><td><code>&quot;2&quot;</code></td><td>正三叉星（类似奔驰车标形状）</td></tr><tr><td><code>&quot;3&quot;</code></td><td>左三叉星</td></tr><tr><td><code>&quot;4&quot;</code></td><td>右三叉星</td></tr><tr><td><code>&quot;8&quot;</code></td><td>八边形</td></tr><tr><td><code>&quot;s&quot;</code></td><td>正方形</td></tr><tr><td><code>&quot;p&quot;</code></td><td>五边形</td></tr><tr><td><code>&quot;P&quot;</code></td><td>填充的加号（粗加号）</td></tr><tr><td><code>&quot;+&quot;</code></td><td>加号</td></tr><tr><td><code>&quot;*&quot;</code></td><td>星形</td></tr><tr><td><code>&quot;h&quot;</code></td><td>六边形（底部是角）</td></tr><tr><td><code>&quot;H&quot;</code></td><td>六边形（底部是边）</td></tr><tr><td><code>&quot;x&quot;</code></td><td>x 号</td></tr><tr><td><code>&quot;X&quot;</code></td><td>填充的 x 号（粗 x 号）</td></tr><tr><td><code>&quot;D&quot;</code></td><td>粗菱形（对角线相等）</td></tr><tr><td><code>&quot;d&quot;</code></td><td>细菱形（对角线不等）</td></tr><tr><td>`”</td><td>“`</td></tr><tr><td><code>&quot;_&quot;</code></td><td>水平线</td></tr><tr><td><code>0</code></td><td>水平线靠左</td></tr><tr><td><code>1</code></td><td>水平线靠右</td></tr><tr><td><code>2</code></td><td>垂直线靠上</td></tr><tr><td><code>3</code></td><td>垂直线靠下</td></tr><tr><td><code>4</code></td><td>左三角（比 <code>&quot;&lt;&quot;</code> 更细）</td></tr><tr><td><code>5</code></td><td>右三角（比 <code>&quot;&gt;&quot;</code> 更细）</td></tr><tr><td><code>6</code></td><td>正三角（比 <code>&quot;^&quot;</code> 更细）</td></tr><tr><td><code>7</code></td><td>倒三角（比 <code>&quot;v&quot;</code> 更细）</td></tr><tr><td><code>8</code></td><td>左三角（比 <code>&quot;&lt;&quot;</code> 更细，靠左显示）</td></tr><tr><td><code>9</code></td><td>右三角（比 <code>&quot;&gt;&quot;</code> 更细，靠右显示）</td></tr><tr><td><code>10</code></td><td>正三角（比 <code>&quot;^&quot;</code> 更细，靠上显示）</td></tr><tr><td><code>11</code></td><td>倒三角（比 <code>&quot;v&quot;</code> 更细，靠下显示）</td></tr><tr><td><code>&quot;None&quot;</code> / <code>&quot; &quot;</code> / <code>&quot;&quot;</code></td><td>无样式</td></tr><tr><td><code>&#39;$...$&#39;</code></td><td>支持 LaTeX 数学公式，表达式用美元符号包围起来</td></tr></tbody></table><h2 id="【2x00】简单示例"><a href="#【2x00】简单示例" class="headerlink" title="【2x00】简单示例"></a><font color=#FF0000>【2x00】简单示例</font></h2><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltx = np.arange(0, 10, 1)y = np.array([3, 8, 1, 5, 7, 2, 3, 4, 5, 7])plt.scatter(x, y)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A72/01.png" alt="01"></p><h2 id="【3x00】多条数据"><a href="#【3x00】多条数据" class="headerlink" title="【3x00】多条数据"></a><font color=#FF0000>【3x00】多条数据</font></h2><p>绘制多条数据，设置不同数据，然后多次调用 <code>plt.scatter()</code> 函数即可，不同数据的线条颜色会不同，系统随机，可单独指定不同颜色。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(-2*np.pi, 2*np.pi, 1)y1 = np.sin(3*x)/xy2 = np.sin(2*x)/xy3 = np.sin(1*x)/xplt.title(&#39;多数据散点图示例&#39;)plt.xlabel(&#39;x 轴&#39;)plt.ylabel(&#39;y 轴&#39;)plt.scatter(x, y1)plt.scatter(x, y2)plt.scatter(x, y3)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A72/02.png" alt="02"></p><h2 id="【4x00】设置颜色-样式-图例"><a href="#【4x00】设置颜色-样式-图例" class="headerlink" title="【4x00】设置颜色 / 样式 / 图例"></a><font color=#FF0000>【4x00】设置颜色 / 样式 / 图例</font></h2><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(-2*np.pi, 2*np.pi, 1)y1 = np.sin(3*x)/xy2 = np.sin(2*x)/xy3 = np.sin(1*x)/xplt.title(&#39;散点图自定义样式示例&#39;)plt.xlabel(&#39;x 轴&#39;)plt.ylabel(&#39;y 轴&#39;)plt.scatter(x, y1, color=&#39;g&#39;, s=30, label=&#39;(x, y1)&#39;)              # 默认绿色样式plt.scatter(x, y2, color=&#39;r&#39;, s=40, marker=&#39;d&#39;, label=&#39;(x, y2)&#39;)  # 红色菱形plt.scatter(x, y3, color=&#39;b&#39;, s=50, marker=&#39;2&#39;, label=&#39;(x, y3)&#39;)  # 蓝色正三叉星plt.legend(framealpha=0)    # 显示图例，设置为全透明plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A72/03.png" alt="03"></p><h2 id="【5x00】指定位置显示文本注释"><a href="#【5x00】指定位置显示文本注释" class="headerlink" title="【5x00】指定位置显示文本注释"></a><font color=#FF0000>【5x00】指定位置显示文本注释</font></h2><p><code>matplotlib.pyplot.annotate()</code> 方法可以在指定位置显示文本注释，参数解释常见前文：<br><a href="https://itrhx.blog.csdn.net/article/details/105828049">《Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性》</a></p><p>应用举例：</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = [0.13, 0.22, 0.39, 0.59, 0.68, 0.74, 0.93]y = [0.75, 0.34, 0.44, 0.52, 0.80, 0.25, 0.55]plt.title(&#39;散点图添加文本注释示例&#39;)plt.xlabel(&#39;x 轴&#39;)plt.ylabel(&#39;y 轴&#39;)plt.xlim([0, 1])       # 设置 x 轴刻度的范围plt.ylim([0, 1])       # 设置 y 轴刻度的范围plt.scatter(x, y, marker=&#39;o&#39;, s=50)for m, n in zip(x, y):    plt.annotate(&#39;(%s,%s)&#39; % (m, n),                 xy=(m, n),                 xytext=(0, -10),                 textcoords=&#39;offset points&#39;,                 ha=&#39;center&#39;,      # 点在注释文本的中心                 va=&#39;top&#39;)         # 点在注释文本的上方plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A72/04.png" alt="04"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105914929未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【6x00】随机数据散点图"><a href="#【6x00】随机数据散点图" class="headerlink" title="【6x00】随机数据散点图"></a><font color=#FF0000>【6x00】随机数据散点图</font></h2><p>随机数据可以用 numpy 的 random 模块来实现。</p><p><code>numpy.random.rand(d0, d1, …, dn)</code>：根据给定维度生成 [0,1) 之间的数据。</p><p><code>numpy.random.randn(d0, d1, …, dn)</code> ：返回一个或一组具有标准正态分布的样本。</p><p><code>numpy.random.randint(low, high, size)</code>：返回随机整数，范围区间为 [low,high），size 为数组维度大小</p><p>应用举例：</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]N = 1000x = np.random.randn(N)y = np.random.randn(N)plt.title(&#39;散点图随机数据示例&#39;)plt.xlabel(&#39;x 轴&#39;)plt.ylabel(&#39;y 轴&#39;)plt.scatter(x, y, alpha=0.5)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A72/05.png" alt="05"></p><h2 id="【7x00】随机颜色与色条"><a href="#【7x00】随机颜色与色条" class="headerlink" title="【7x00】随机颜色与色条"></a><font color=#FF0000>【7x00】随机颜色与色条</font></h2><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]N = 1000x = np.random.randn(N)y = np.random.randn(N)color = np.random.rand(N)size = np.random.rand(N) * 1000plt.figure(figsize=(8.4, 5.8))    # 设置画布大小 840x580plt.title(&#39;散点图随机大小颜色示例&#39;)plt.xlabel(&#39;x 轴&#39;)plt.ylabel(&#39;y 轴&#39;)plt.scatter(x, y, c=color, s=size, alpha=0.5)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A72/06.png" alt="06"></p><p>可以用 <code>pyplot.colorbar()</code> 方法绘制颜色对照条。</p><p>基本语法：<code>matplotlib.pyplot.colorbar([mappable=None, cax=None, ax=None, **kw])</code></p><p>部分参数解释如下表，其他参数，如长度，宽度等请参考<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.colorbar.html">官方文档</a>。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>mappable</td><td>要设置色条的图像对象，该参数对于 <code>Figure.colorbar</code> 方法是必需的，但对于 <code>pyplot.colorbar</code> 函数是可选的</td></tr><tr><td>cax</td><td>可选项，要绘制色条的轴</td></tr><tr><td>ax</td><td>可选项，设置色条的显示位置，通常在一个画布上有多个子图时使用</td></tr><tr><td>**kw</td><td>可选项，其他关键字参数，参考<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.colorbar.html">官方文档</a></td></tr></tbody></table><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]N = 1000x = np.random.randn(N)y = np.random.randn(N)color = np.random.rand(N)size = np.random.rand(N) * 1000plt.figure(figsize=(8.4, 5.8))plt.title(&#39;散点图颜色对照条示例&#39;)plt.xlabel(&#39;x 轴&#39;)plt.ylabel(&#39;y 轴&#39;)plt.scatter(x, y, c=color, s=size, alpha=0.5)plt.colorbar()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A72/07.png" alt="07"></p><h2 id="【8x00】不同图像之间的层级调整"><a href="#【8x00】不同图像之间的层级调整" class="headerlink" title="【8x00】不同图像之间的层级调整"></a><font color=#FF0000>【8x00】不同图像之间的层级调整</font></h2><p><code>zorder</code> 参数用于设置不同图像之间的层级关系，数字越大，所处的层级越大，即显示越靠上。</p><p>未设置 <code>zorder</code> 参数前：</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x1 = np.arange(-2*np.pi, 2*np.pi, 0.01)y1 = np.sin(3*x1)/x1x2 = np.arange(-2*np.pi, 2*np.pi, 1)y2 = np.sin(3*x2)/x2plt.title(&#39;不同图像之间层级调整示例&#39;)plt.xlabel(&#39;x 轴&#39;)plt.ylabel(&#39;y 轴&#39;)plt.plot(x1, y1, c=&#39;b&#39;, linewidth=3.5, label=&#39;线性图&#39;)plt.scatter(x2, y2, c=&#39;r&#39;, s=40, label=&#39;散点图&#39;)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A72/08.png" alt="08"></p><p>设置 <code>zorder</code> 参数后：</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x1 = np.arange(-2*np.pi, 2*np.pi, 0.01)y1 = np.sin(3*x1)/x1x2 = np.arange(-2*np.pi, 2*np.pi, 1)y2 = np.sin(3*x2)/x2plt.title(&#39;不同图像之间层级调整示例&#39;)plt.xlabel(&#39;x 轴&#39;)plt.ylabel(&#39;y 轴&#39;)plt.plot(x1, y1, zorder=1, c=&#39;b&#39;, linewidth=3.5, label=&#39;线性图&#39;)plt.scatter(x2, y2, zorder=2, c=&#39;r&#39;, s=40, label=&#39;散点图&#39;)plt.legend()plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A72/09.png" alt="09"></p><h2 id="【9x00】框选部分数据"><a href="#【9x00】框选部分数据" class="headerlink" title="【9x00】框选部分数据"></a><font color=#FF0000>【9x00】框选部分数据</font></h2><p>有时候我们希望能够框选一部分数据来强调其重要性，<code>matplotlib.patches.Polygon()</code> 方法的作用是生成不规则的多边形补丁，<code>matplotlib.patches</code> 还有另外的方法可以生成矩形、圆形等其他图形，具体参见前面的文章<a href="https://itrhx.blog.csdn.net/article/details/105828143">《Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性》</a>，生成补丁之后，通过 <code>axes.add_patch()</code> 方法将其添加到绘图区（axes）即可。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltimport matplotlib.patches as mpathesplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]plt.figure(figsize=(8.4, 5.8))x1 = np.arange(0, 1000, 10)y1 = np.random.randint(0, 1000, 100)x2 = np.arange(0, 500, 10)y2 = np.random.randint(200, 800, 50)x3 = np.random.randint(50, 800, 80)y3 = np.random.randint(50, 800, 80)x4 = np.array([0, 100, 300, 400, 350, 500, 450, 367, 420, 490])y4 = np.array([267, 800, 453, 500, 600, 420, 380, 503, 390, 600])plt.title(&#39;散点图数据框选示例&#39;, fontsize=15)plt.xlabel(&#39;x 轴&#39;, fontsize=15)plt.ylabel(&#39;y 轴&#39;, fontsize=15)plt.scatter(x1, y1, c=&#39;r&#39;, s=50, alpha=0.7, label=&#39;RED&#39;)plt.scatter(x2, y2, c=&#39;b&#39;, s=100, alpha=0.7, label=&#39;BLUE&#39;)plt.scatter(x3, y3, c=&#39;g&#39;, s=150, alpha=0.7, label=&#39;GREEN&#39;)plt.scatter(x4, y4, c=&#39;y&#39;, s=250, alpha=0.7, label=&#39;YELLOW&#39;)plt.legend(loc=&#39;upper right&#39;, borderpad=1, edgecolor=&#39;k&#39;, framealpha=1, labelspacing=1)Polygon_point = [[100, 800], [0, 267], [500, 420], [490, 600]]        # 多边形补丁的顶点坐标polygon = mpathes.Polygon(Polygon_point, color=&#39;#FF69B4&#39;, alpha=0.3)  # 绘制补丁，框选部分数据ax = plt.gca()          # 获取当前绘图区（gca = Get Current Axes）ax.add_patch(polygon)   # 将补丁添加到当前绘图区plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A72/10.png" alt="10"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105914929未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Matplotlib（四）：线性图的绘制</title>
      <link href="/article/017/"/>
      <url>/article/017/</url>
      
        <content type="html"><![CDATA[<p>Matplotlib 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/014/">Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</a></li><li><a href="https://www.itbob.cn/article/015/">Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/016/">Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/017/">Python 数据分析三剑客之 Matplotlib（四）：线性图的绘制</a></li><li><a href="https://www.itbob.cn/article/018/">Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制</a></li><li><a href="https://www.itbob.cn/article/019/">Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制</a></li><li><a href="https://www.itbob.cn/article/020/">Python 数据分析三剑客之 Matplotlib（七）：饼状图的绘制</a></li><li><a href="https://www.itbob.cn/article/021/">Python 数据分析三剑客之 Matplotlib（八）：等高线 / 等值线图的绘制</a></li><li><a href="https://www.itbob.cn/article/022/">Python 数据分析三剑客之 Matplotlib（九）：极区图 / 极坐标图 / 雷达图的绘制</a></li><li><a href="https://www.itbob.cn/article/023/">Python 数据分析三剑客之 Matplotlib（十）：3D 图的绘制</a></li><li><a href="https://www.itbob.cn/article/024/">Python 数据分析三剑客之 Matplotlib（十一）：最热门最常用的 50 个图表</a>【译文】</li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105839855未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】方法描述"><a href="#【1x00】方法描述" class="headerlink" title="【1x00】方法描述"></a><font color=#FF0000>【1x00】方法描述</font></h2><p><code>matplotlib.pyplot.plot()</code> 函数可以用于绘制线性图。</p><p>本文用到的其他图像属性可参考前面的两篇文章：</p><p><a href="https://itrhx.blog.csdn.net/article/details/105828049">《Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性》</a><br><a href="https://itrhx.blog.csdn.net/article/details/105828143">《Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图等基本图像属性》</a></p><p>基本语法：<code>matplotlib.pyplot.plot(x, y[, fmt, \*\*kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>x</td><td>x 轴数据，数组类型或者标量，x 值是可选的，默认为 <code>range(len(y))</code>，通常为一维数组</td></tr><tr><td>y</td><td>y 轴数据，数组类型或者标量，通常为一维数组</td></tr><tr><td>fmt</td><td>str 类型，格式字符串，由标记、线条和颜色部分组成<br><code>fmt = &#39;[marker][line][color]&#39;</code>，例如 <code>ro</code> 表示红色圆圈，三个参数的取值见后表</td></tr><tr><td>**kwargs</td><td>可选项，其他 <a href="https://matplotlib.org/api/_as_gen/matplotlib.lines.Line2D.html#matplotlib.lines.Line2D">Line2D</a> 属性，常用属性见下表</td></tr></tbody></table><p>部分常见 Line2D 属性如下表，完整属性参见<a href="https://matplotlib.org/api/_as_gen/matplotlib.lines.Line2D.html#matplotlib.lines.Line2D">官方文档</a>。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>alpha</td><td>线条透明度，float 类型，取值范围：<code>[0, 1]</code>，默认为 1.0，即不透明</td></tr><tr><td>antialiased / aa</td><td>是否使用抗锯齿渲染，默认为 True</td></tr><tr><td>color / c</td><td>线条颜色，支持英文颜色名称及其简写、十六进制颜色码等，更多颜色示例参见官网 <a href="https://matplotlib.org/gallery/color/color_demo.html">Color Demo</a></td></tr><tr><td>linestyle / ls</td><td>线条样式：<code>&#39;-&#39;</code> or <code>&#39;solid&#39;</code>, <code>&#39;--&#39;</code> or <code>&#39;dashed&#39;</code>, <code>&#39;-.&#39;</code> or <code>&#39;dashdot&#39;</code> <br> <code>&#39;:&#39;</code> or <code>&#39;dotted&#39;</code>, <code>&#39;none&#39;</code> or <code>&#39; &#39;</code> or <code>&#39;&#39;</code></td></tr><tr><td>linewidth / lw</td><td>线条宽度，float 类型，默认 0.8</td></tr><tr><td>markeredgecolor / mec</td><td>marker 标记的边缘颜色</td></tr><tr><td>markeredgewidth / mew</td><td>marker 标记的边缘宽度</td></tr><tr><td>markerfacecolor / mfc</td><td>marker 标记的颜色</td></tr><tr><td>markerfacecoloralt / mfcalt</td><td>marker 标记的备用颜色</td></tr><tr><td>markersize / ms</td><td>marker 标记的大小</td></tr></tbody></table><p>fmt 中 <code>marker</code>、<code>line</code>、<code>color</code> 三个参数的取值：</p><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font size=3px>marker：线条标记样式（线条上每个数据点的样式）</font></strong></td></tr></table><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>&#39;.&#39;</code></td><td>点标记（point marker）</td></tr><tr><td><code>&#39;,&#39;</code></td><td>像素点标记（pixel marker）</td></tr><tr><td><code>&#39;o&#39;</code></td><td>圆圈标记（circle marker）</td></tr><tr><td><code>&#39;v&#39;</code></td><td>下三角标记（triangle_down marker）</td></tr><tr><td><code>&#39;^&#39;</code></td><td>上三角标记（triangle_up marker）</td></tr><tr><td><code>&#39;&lt;&#39;</code></td><td>左三角标记（triangle_left marker）</td></tr><tr><td><code>&#39;&gt;&#39;</code></td><td>右三角标记（triangle_right marker）</td></tr><tr><td><code>&#39;1&#39;</code></td><td>下三叉星标记（tri_down marker）</td></tr><tr><td><code>&#39;2&#39;</code></td><td>上三叉星标记（tri_up marker）</td></tr><tr><td><code>&#39;3&#39;</code></td><td>左三叉星标记（tri_left marker）</td></tr><tr><td><code>&#39;4&#39;</code></td><td>右三叉星标记（tri_right marker）</td></tr><tr><td><code>&#39;s&#39;</code></td><td>正方形标记（square marker）</td></tr><tr><td><code>&#39;p&#39;</code></td><td>五角形标记（pentagon marker）</td></tr><tr><td><code>&#39;*&#39;</code></td><td>星号标记（star marker）</td></tr><tr><td><code>&#39;h&#39;</code></td><td>六边形标记（hexagon1 marker）</td></tr><tr><td><code>&#39;H&#39;</code></td><td>六边形标记（hexagon2 marker）</td></tr><tr><td><code>&#39;+&#39;</code></td><td>加号标记（plus marker）</td></tr><tr><td><code>&#39;x&#39;</code></td><td>X 号标记（x marker）</td></tr><tr><td><code>&#39;D&#39;</code></td><td>菱形标记（diamond marker）</td></tr><tr><td><code>&#39;d&#39;</code></td><td>细菱形标记（thin_diamond marker）</td></tr><tr><td>`’</td><td>‘`</td></tr><tr><td><code>&#39;_&#39;</code></td><td>水平线标记（hline marker）</td></tr></tbody></table><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font size=3px>line：线条样式</font></strong></td></tr></table><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>&#39;-&#39;</code></td><td>实线样式（solid line style）</td></tr><tr><td><code>&#39;--&#39;</code></td><td>虚线样式（dashed line style）</td></tr><tr><td><code>&#39;-.&#39;</code></td><td>点划线样式（dash-dot line style）</td></tr><tr><td><code>&#39;:&#39;</code></td><td>点样式（dotted line style）</td></tr></tbody></table><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font size=3px>color：线条颜色，支持英文颜色名称及其简写、十六进制颜色码等</font></strong></td></tr></table><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>&#39;b&#39;</code></td><td>蓝色（blue）</td></tr><tr><td><code>&#39;g&#39;</code></td><td>绿色（green）</td></tr><tr><td><code>&#39;r&#39;</code></td><td>红色（red）</td></tr><tr><td><code>&#39;c&#39;</code></td><td>青色（cyan）</td></tr><tr><td><code>&#39;m&#39;</code></td><td>品红（magenta）</td></tr><tr><td><code>&#39;y&#39;</code></td><td>黄色（yellow）</td></tr><tr><td><code>&#39;k&#39;</code></td><td>黑色（black）</td></tr><tr><td><code>&#39;w&#39;</code></td><td>白色（white）</td></tr></tbody></table><p>fmt 举例：</p><pre><code class="powershell">&#39;b&#39;    # 默认形状的蓝色标记&#39;or&#39;   # 红圈&#39;-g&#39;   # 绿色实线&#39;--&#39;   # 默认颜色的虚线&#39;^k:&#39;  # 黑色三角形标记，由虚线连接</code></pre><h2 id="【2x00】基本示例"><a href="#【2x00】基本示例" class="headerlink" title="【2x00】基本示例"></a><font color=#FF0000>【2x00】基本示例</font></h2><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]  # 设置显示中文x = np.arange(-2*np.pi, 2*np.pi, 0.01)y = np.sin(3*x)/xplt.title(&#39;线性图示例&#39;)   # 设置标题plt.xlabel(&#39;x 轴&#39;)       # 设置 x 轴标签plt.ylabel(&#39;y 轴&#39;)       # 设置 y 轴标签plt.plot(x, y)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A71/01.png" alt="01"></p><h2 id="【3x00】多条数据"><a href="#【3x00】多条数据" class="headerlink" title="【3x00】多条数据"></a><font color=#FF0000>【3x00】多条数据</font></h2><p>绘制多条数据，设置不同数据，然后多次调用 <code>plt.plot()</code> 函数即可，不同数据的线条颜色会不同，系统随机，可单独指定不同颜色。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(-2*np.pi, 2*np.pi, 0.01)y1 = np.sin(3*x)/xy2 = np.sin(2*x)/xy3 = np.sin(1*x)/xplt.title(&#39;多数据线性图示例&#39;)plt.xlabel(&#39;x 轴&#39;)plt.ylabel(&#39;y 轴&#39;)plt.plot(x, y1)plt.plot(x, y2)plt.plot(x, y3)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A71/02.png" alt="02"></p><h2 id="【4x00】设置颜色-样式-图例"><a href="#【4x00】设置颜色-样式-图例" class="headerlink" title="【4x00】设置颜色 / 样式 / 图例"></a><font color=#FF0000>【4x00】设置颜色 / 样式 / 图例</font></h2><p>设置线条颜色样式等属性直接在 <code>plot()</code> 函数里面添加相应参数即可，设置图例则需要调用 <code>legend()</code> 方法。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x1 = np.arange(-2*np.pi, 2*np.pi, 0.01)y1 = np.sin(3*x1)/x1y2 = np.sin(2*x1)/x1x3 = np.arange(-2*np.pi, 2*np.pi, 2)y3 = np.array([0, 2, 1.5, 1, 2.4, -0.2, 1.7])plt.title(&#39;线性图自定义样式示例&#39;)plt.xlabel(&#39;x 轴&#39;)plt.ylabel(&#39;y 轴&#39;)plt.plot(x1, y1, &#39;--r&#39;, label=&#39;x1, y1&#39;)                               # 线条样式为 --，颜色为 r（红色）plt.plot(x1, y2, color=&#39;green&#39;, label=&#39;x1, y2&#39;)                       # 样式默认，颜色为绿色plt.plot(x3, y3, marker=&#39;o&#39;, mfc=&#39;r&#39;, linestyle=&#39;:&#39;, label=&#39;x3, y3&#39;)  # 标记样式为 o，颜色为 r（红色），线条样式为 :plt.legend(edgecolor=&#39;#87A3CC&#39;, facecolor=&#39;#F5F5F5&#39;)                  # 图例plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A71/03.png" alt="03"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105839855未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【5x00】设置刻度"><a href="#【5x00】设置刻度" class="headerlink" title="【5x00】设置刻度"></a><font color=#FF0000>【5x00】设置刻度</font></h2><p>调用 <code>xticks()</code> 和 <code>yticks()</code> 函数可以对坐标刻度进行自定义，该函数接收两个参数，第一个参数表示要显示的刻度位置，第二个参数表示在对应刻度线上要显示的标签信息，标签信息支持 LeTeX 数学公式，使用时要用美元符号 <code>$</code> 包围起来。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(-2*np.pi, 2*np.pi, 0.01)y1 = np.sin(3*x)/xy2 = np.sin(2*x)/xy3 = np.sin(1*x)/xplt.title(&#39;线性图设置刻度示例&#39;)plt.xlabel(&#39;x 轴&#39;)plt.ylabel(&#39;y 轴&#39;)plt.plot(x, y1, &#39;--r&#39;, label=&#39;sin(3*x)/x&#39;)plt.plot(x, y2, color=&#39;green&#39;, linestyle=&#39;:&#39;, label=&#39;sin(2*x)/x&#39;)plt.plot(x, y3, label=&#39;sin(1*x)/x&#39;)plt.legend(edgecolor=&#39;#87A3CC&#39;, facecolor=&#39;#F5F5F5&#39;)plt.xticks((-2*np.pi, -np.pi, 0, np.pi, 2*np.pi), (r&#39;$-2\pi$&#39;, r&#39;$-\pi$&#39;, &#39;$0$&#39;, r&#39;$\pi$&#39;, r&#39;$2\pi$&#39;))plt.yticks((-1, 0, 1, 2, 3))plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A71/04.png" alt="04"></p><h2 id="【6x00】隐藏画布边框"><a href="#【6x00】隐藏画布边框" class="headerlink" title="【6x00】隐藏画布边框"></a><font color=#FF0000>【6x00】隐藏画布边框</font></h2><p>Matplotlib 所绘制的图表中的每个绘图元素，例如线条 Line2D、文字 Text、刻度等在内存中都有一个对象与之对应。</p><p><code>matplotlib.pyplot.gca()</code> 函数用于获取当前的绘图区 <code>Axes</code>（Get Current Axes）</p><p><code>matplotlib.pyplot.gcf()</code> 函数用于获取当前的画布 <code>Figure</code>（Get Current Figure）</p><p>例如：<code>matplotlib.pyplot.plot()</code> 实际上会通过 <code>matplotlib.pyplot.gca()</code> 获得当前的 <code>Axes</code> 对象 <code>ax</code>，然后再调用 <code>ax.plot()</code> 方法实现真正的绘图。我们可以通过这种方法来实现画布边框的隐藏和坐标轴的移动。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(-2*np.pi, 2*np.pi, 0.01)y1 = np.sin(3*x)/xy2 = np.sin(2*x)/xy3 = np.sin(1*x)/xplt.title(&#39;线性图隐藏画布边框示例&#39;)plt.xlabel(&#39;x 轴&#39;)plt.ylabel(&#39;y 轴&#39;)plt.plot(x, y1, &#39;--r&#39;, label=&#39;sin(3*x)/x&#39;)plt.plot(x, y2, color=&#39;green&#39;, linestyle=&#39;:&#39;, label=&#39;sin(2*x)/x&#39;)plt.plot(x, y3, label=&#39;sin(1*x)/x&#39;)plt.legend(edgecolor=&#39;#87A3CC&#39;, facecolor=&#39;#F5F5F5&#39;)plt.xticks((-2*np.pi, -np.pi, 0, np.pi, 2*np.pi), (r&#39;$-2\pi$&#39;, r&#39;$-\pi$&#39;, &#39;$0$&#39;, r&#39;$\pi$&#39;, r&#39;$2\pi$&#39;))plt.yticks((-1, 0, 1, 2, 3))ax = plt.gca()                          # 获取当前的画布, gca = get current axesax.spines[&#39;right&#39;].set_visible(False)   # 获取绘图区的轴对象（spines），设置右边框不显示ax.spines[&#39;top&#39;].set_visible(False)     # 获取绘图区的轴对象（spines），设置上边框不显示# ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)  # 设置颜色为 none，效果与上面的一致# ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A71/05.png" alt="05"></p><h2 id="【7x00】移动坐标轴"><a href="#【7x00】移动坐标轴" class="headerlink" title="【7x00】移动坐标轴"></a><font color=#FF0000>【7x00】移动坐标轴</font></h2><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(-2*np.pi, 2*np.pi, 0.01)y1 = np.sin(3*x)/xy2 = np.sin(2*x)/xy3 = np.sin(1*x)/xplt.title(&#39;线性图移动坐标轴示例&#39;)plt.xlabel(&#39;x 轴&#39;)plt.ylabel(&#39;y 轴&#39;)plt.plot(x, y1, &#39;--r&#39;, label=&#39;sin(3*x)/x&#39;)plt.plot(x, y2, color=&#39;green&#39;, linestyle=&#39;:&#39;, label=&#39;sin(2*x)/x&#39;)plt.plot(x, y3, label=&#39;sin(1*x)/x&#39;)plt.legend(edgecolor=&#39;#87A3CC&#39;, facecolor=&#39;#F5F5F5&#39;)plt.xticks((-2*np.pi, -np.pi, 0, np.pi, 2*np.pi), (r&#39;$-2\pi$&#39;, r&#39;$-\pi$&#39;, &#39;$0$&#39;, r&#39;$\pi$&#39;, r&#39;$2\pi$&#39;))plt.yticks((-1, 0, 1, 2, 3))ax = plt.gca()                          # 获取当前的画布, gca = get current axesax.spines[&#39;right&#39;].set_visible(False)   # 获取绘图区的轴对象（spines），设置右边框不显示ax.spines[&#39;top&#39;].set_visible(False)     # 获取绘图区的轴对象（spines），设置上边框不显示# ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)  # 设置颜色为 none，效果与上面的一致# ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)ax.spines[&#39;left&#39;].set_position((&#39;data&#39;, 0))    # 设置两个坐标轴在（0, 0）位置相交ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;, 0))ax.xaxis.set_ticks_position(&#39;bottom&#39;)          # 设置 x 坐标轴标签的位置ax.yaxis.set_ticks_position(&#39;left&#39;)            # 设置 y 坐标轴标签的位置plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A71/06.png" alt="06"></p><h2 id="【8x00】指定位置显示文本"><a href="#【8x00】指定位置显示文本" class="headerlink" title="【8x00】指定位置显示文本"></a><font color=#FF0000>【8x00】指定位置显示文本</font></h2><p><code>matplotlib.pyplot.annotate()</code> 方法可以在指定坐标点添加文本或 LaTeX 描述，也可以在其他位置添加描述后，使用箭头指向某个坐标点。</p><p>基本语法：<code>matplotlib.pyplot.annotate(text, xy, xytext, xycoords, textcoords, ha, va, arrowprops, \*\*kwargs)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>text</td><td>str 类型，注释的文本</td></tr><tr><td>xy</td><td>被注释的坐标点，格式：<code>(x, y)</code></td></tr><tr><td>xytext</td><td>注释文本的坐标点，格式：<code>(x, y)</code>，默认与 xy 相同</td></tr><tr><td>xycoords</td><td>被注释的坐标点的参考系，取值参见<font color=#FF0000><strong>表一</strong></font>，默认为 ‘data’</td></tr><tr><td>textcoords</td><td>注释文本的坐标点的参考系，取值参见<font color=#FF0000><strong>表二</strong></font>，默认为 xycoords 的值</td></tr><tr><td>ha</td><td>注释点在注释文本的左边、右边或中间（<code>left</code>、<code>right</code>、<code>center</code>）</td></tr><tr><td>va</td><td>注释点在注释文本的上边、下边、中间或基线 （<code>top</code>、<code>bottom</code>、<code>center</code>、<code>baseline</code>）</td></tr><tr><td>arrowprops</td><td>dict 字典类型，箭头的样式<br>如果 arrowprops 不包含键 arrowstyle，则允许的键参见<font color=#FF0000><strong>表三</strong></font><br>如果 arrowprops 包含键 arrowstyle，则允许的键参见<font color=#FF0000><strong>表四</strong></font></td></tr></tbody></table><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font color=#FF0000 size=3px>表一：xycoords 取值类型</font></strong></td></tr></table><table><thead><tr><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>‘figure points’</td><td>以画布左下角为参考，单位为点数</td></tr><tr><td>‘figure pixels’</td><td>以画布左下角为参考，单位为像素</td></tr><tr><td>‘figure fraction’</td><td>以画布左下角为参考，单位为百分比</td></tr><tr><td>‘axes points’</td><td>以绘图区左下角为参考，单位为点数</td></tr><tr><td>‘axes pixels’</td><td>以绘图区左下角为参考，单位为像素</td></tr><tr><td>‘axes fraction’</td><td>以绘图区左下角为参考，单位为百分比</td></tr><tr><td>‘data’</td><td>使用被注释对象的坐标系，即数据的 x, y 轴（默认）</td></tr><tr><td>‘polar’</td><td>使用（θ，r）形式的极坐标系</td></tr></tbody></table><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font color=#FF0000 size=3px>表二：textcoords 取值类型</font></strong></td></tr></table><table><thead><tr><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>‘figure points’</td><td>以画布左下角为参考，单位为点数</td></tr><tr><td>‘figure pixels’</td><td>以画布左下角为参考，单位为像素</td></tr><tr><td>‘figure fraction’</td><td>以画布左下角为参考，单位为百分比</td></tr><tr><td>‘axes points’</td><td>以绘图区左下角为参考，单位为点数</td></tr><tr><td>‘axes pixels’</td><td>以绘图区左下角为参考，单位为像素</td></tr><tr><td>‘axes fraction’</td><td>以绘图区左下角为参考，单位为百分比</td></tr><tr><td>‘data’</td><td>使用被注释对象的坐标系，即数据的 x, y 轴</td></tr><tr><td>‘polar’</td><td>使用（θ，r）形式的极坐标系</td></tr><tr><td>‘offset points’</td><td>相对于被注释点的坐标 xy 的偏移量，单位是点</td></tr><tr><td>‘offset pixels’</td><td>相对于被注释点的坐标 xy 的偏移量，单位是像素</td></tr></tbody></table><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font color=#FF0000 size=3px>表三：arrowprops 不包含键 arrowstyle 时的取值</font></strong></td></tr></table><table><thead><tr><th>键</th><th>描述</th></tr></thead><tbody><tr><td>width</td><td>箭头的宽度，以点为单位</td></tr><tr><td>headwidth</td><td>箭头底部的宽度，以点为单位</td></tr><tr><td>headlength</td><td>箭头的长度，以点为单位</td></tr><tr><td>shrink</td><td>箭头两端收缩占总长的百分比</td></tr><tr><td>?</td><td>其他 <a href="https://matplotlib.org/api/_as_gen/matplotlib.patches.FancyArrowPatch.html#matplotlib.patches.FancyArrowPatch">matplotlib.patches.FancyArrowPatch</a> 中的关键字，部分常用关键字参见<font color=#FF0000><strong>表五</strong></font></td></tr></tbody></table><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font color=#FF0000 size=3px>表四：arrowprops 包含键 arrowstyle 时的取值</font></strong></td></tr></table><table><thead><tr><th>取值</th><th>描述</th></tr></thead><tbody><tr><td><code>&#39;-&#39;</code></td><td>None</td></tr><tr><td><code>&#39;-&gt;&#39;</code></td><td>head_length=0.4,head_width=0.2</td></tr><tr><td><code>&#39;-[&#39;</code></td><td>widthB=1.0,lengthB=0.2,angleB=None</td></tr><tr><td><code>&#39;]-&#39;</code></td><td>widthA=1.0, lengthA=0.2, angleA=None</td></tr><tr><td><code>]-[</code></td><td>widthA=1.0, lengthA=0.2, angleA=None, widthB=1.0, lengthB=0.2, angleB=None</td></tr><tr><td>`’</td><td>-</td></tr><tr><td>`’-</td><td>&gt;’`</td></tr><tr><td><code>&#39;&lt;-&#39;</code></td><td>head_length=0.4,head_width=0.2</td></tr><tr><td><code>&#39;&lt;-&gt;&#39;</code></td><td>head_length=0.4,head_width=0.2</td></tr><tr><td>`’&lt;</td><td>-‘`</td></tr><tr><td>`’&lt;</td><td>-</td></tr><tr><td><code>&#39;fancy&#39;</code></td><td>head_length=0.4,head_width=0.4,tail_width=0.4</td></tr><tr><td><code>&#39;simple&#39;</code></td><td>head_length=0.5,head_width=0.5,tail_width=0.2</td></tr><tr><td><code>&#39;wedge&#39;</code></td><td>tail_width=0.3,shrink_factor=0.5</td></tr></tbody></table><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font color=#FF0000 size=3px>表五：matplotlib.patches.FancyArrowPatch 常用的键</font></strong></td></tr></table><table><thead><tr><th>键</th><th>描述</th></tr></thead><tbody><tr><td>arrowstyle</td><td>箭头样式，取值参见<font color=#FF0000><strong>表四</strong></font></td></tr><tr><td>connectionstyle</td><td>连接方式，默认为 <code>arc3</code>，有以下五种取值：<br><code>angle</code>：angleA=90, angleB=0, rad=0.0<br><code>angle3</code>：angleA=90, angleB=0<br><code>arc</code>：angleA=0, angleB=0, armA=None, armB=None, rad=0.0<br><code>arc3</code>：rad=0.0<br><code>bar</code>：armA=0.0, armB=0.0, fraction=0.3, angle=None<br>angle 为箭头旋转的角度，rad 为弧度</td></tr><tr><td>relpos</td><td>箭头起始点相对注释文本的位置，默认为 (0.5, 0.5)，即文本的中心<br>（0，0）表示左下角，（1，1）表示右上角</td></tr><tr><td>patchA</td><td>箭头起点处的图形，默认为文本的边框</td></tr><tr><td>patchB</td><td>箭头终点处的图形，默认为空</td></tr><tr><td>shrinkA</td><td>箭头起点的缩进点数，默认为2</td></tr><tr><td>shrinkB</td><td>箭头终点的缩进点数，默认为2</td></tr><tr><td>？</td><td>其他键值，参见官方文档 <a href="https://matplotlib.org/api/_as_gen/matplotlib.patches.PathPatch.html#matplotlib.patches.PathPatch">matplotlib.patches.PathPatch</a></td></tr></tbody></table><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font color=#FF0000 size=3px>connectionstyle 样式举例</font></strong></td></tr></table><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A71/07.png" alt="07"></p><p>应用举例：</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = np.arange(-2*np.pi, 2*np.pi, 0.01)y1 = np.sin(3*x)/xy2 = np.sin(2*x)/xy3 = np.sin(1*x)/xplt.title(&#39;线性图显示文本注释示例&#39;)plt.xlabel(&#39;x 轴&#39;)plt.ylabel(&#39;y 轴&#39;)plt.plot(x, y1, &#39;--r&#39;, label=&#39;sin(3*x)/x&#39;)plt.plot(x, y2, color=&#39;green&#39;, linestyle=&#39;:&#39;, label=&#39;sin(2*x)/x&#39;)plt.plot(x, y3, label=&#39;sin(1*x)/x&#39;)plt.legend(edgecolor=&#39;#87A3CC&#39;, facecolor=&#39;#F5F5F5&#39;)plt.xticks((-2*np.pi, -np.pi, 0, np.pi, 2*np.pi), (r&#39;$-2\pi$&#39;, r&#39;$-\pi$&#39;, &#39;$0$&#39;, r&#39;$\pi$&#39;, r&#39;$2\pi$&#39;))plt.yticks((-1, 0, 1, 2, 3))ax = plt.gca()                          # 获取当前的画布, gca = get current axesax.spines[&#39;right&#39;].set_visible(False)   # 获取绘图区的轴对象（spines），设置右边框不显示ax.spines[&#39;top&#39;].set_visible(False)     # 获取绘图区的轴对象（spines），设置上边框不显示# ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)  # 设置颜色为 none，效果与上面的一致# ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)ax.spines[&#39;left&#39;].set_position((&#39;data&#39;, 0))    # 设置两个坐标轴在（0, 0）位置相交ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;, 0))ax.xaxis.set_ticks_position(&#39;bottom&#39;)          # 设置 x 坐标轴标签的位置ax.yaxis.set_ticks_position(&#39;left&#39;)            # 设置 y 坐标轴标签的位置plt.annotate(r&#39;$\lim_&#123;x\to 0&#125;\frac&#123;\sin(x)&#125;&#123;x&#125;=1$&#39;,  # 插入 LaTeX 表达式             xy=[0, 1],                              # 被标记的坐标             xycoords=&#39;data&#39;,                        # 被标记的坐标的参考系             xytext=[30, 30],                        # 注释文本的坐标             textcoords=&#39;offset points&#39;,             # 注释文本的坐标的参考系             fontsize=16,                            # 字体大小             arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3, rad=.2&quot;))  # 箭头样式plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A71/08.png" alt="08"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105839855未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Matplotlib（三）：图例/LaTeX/刻度/子图/补丁等基本图像属性</title>
      <link href="/article/016/"/>
      <url>/article/016/</url>
      
        <content type="html"><![CDATA[<p>Matplotlib 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/014/">Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</a></li><li><a href="https://www.itbob.cn/article/015/">Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/016/">Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/017/">Python 数据分析三剑客之 Matplotlib（四）：线性图的绘制</a></li><li><a href="https://www.itbob.cn/article/018/">Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制</a></li><li><a href="https://www.itbob.cn/article/019/">Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制</a></li><li><a href="https://www.itbob.cn/article/020/">Python 数据分析三剑客之 Matplotlib（七）：饼状图的绘制</a></li><li><a href="https://www.itbob.cn/article/021/">Python 数据分析三剑客之 Matplotlib（八）：等高线 / 等值线图的绘制</a></li><li><a href="https://www.itbob.cn/article/022/">Python 数据分析三剑客之 Matplotlib（九）：极区图 / 极坐标图 / 雷达图的绘制</a></li><li><a href="https://www.itbob.cn/article/023/">Python 数据分析三剑客之 Matplotlib（十）：3D 图的绘制</a></li><li><a href="https://www.itbob.cn/article/024/">Python 数据分析三剑客之 Matplotlib（十一）：最热门最常用的 50 个图表</a>【译文】</li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105828143未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】设置图例"><a href="#【1x00】设置图例" class="headerlink" title="【1x00】设置图例"></a><font color=#FF0000>【1x00】设置图例</font></h2><p><code>matplotlib.pyplot.legend()</code> 方法可以为图表设置图例。</p><p>基本语法：<code>matplotlib.pyplot.legend(\*args, \*\*kwargs)</code></p><p>部分常见参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>loc</td><td>图例在画布中的位置，默认为 best，其他取值：<br><code>best</code>, <code>upper right</code>, <code>upper left</code>, <code>lower left</code> <br> <code>lower right</code>, <code>right</code>, <code>center left</code>, <code>center right</code> <br> <code>lower center</code>, <code>upper center</code>, <code>center</code><br>也可以用数字 0 - 10 来表示上述位置</td></tr><tr><td>bbox_to_anchor</td><td>调整图例在画布中的位置，当 loc 达不到我们想要的效果时，就可以使用该参数<br>该参数接收一个二元数组 (x, y)，x 用于控制图例的左右移动，值越大越向右边移动<br>y 用于控制图例的上下移动，值越大，越向上移动</td></tr><tr><td>borderaxespad</td><td>图例距离轴之间的距离，float 类型，默认为 0.5</td></tr><tr><td>borderpad</td><td>图例边框空白区域大小，float 类型，默认为 0.4</td></tr><tr><td>columnspacing</td><td>图例列间距，float 类型，默认为 2.0</td></tr><tr><td>edgecolor</td><td>图例边缘线颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>facecolor</td><td>图例背景颜色，默认继承自 <code>axes.facecolor</code><br>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>fancybox</td><td>是否使用圆形框作为图例背景， 默认为 True</td></tr><tr><td>fontsize</td><td>图例字体大小，默认为 <code>medium</code>，<code>xx-small</code>, <code>x-small</code>, <code>small</code>, <code>medium</code> <br> <code>large</code>, <code>x-large</code>, <code>xx-large</code>, <code>smaller</code>, <code>larger</code><br>也可以使用数字来表示字体大小</td></tr><tr><td>framealpha</td><td>图例透明度，float 类型，默认为 0.8，取值范围：<code>[0, 1]</code></td></tr><tr><td>handleheight</td><td>图例的高度 ，float 类型，默认为 0.7</td></tr><tr><td>handlelength</td><td>图例的宽度，float 类型，默认为 2.0</td></tr><tr><td>handletextpad</td><td>图例和图例文本之间的水平距离，float 类型，默认为 0.8</td></tr><tr><td>labelspacing</td><td>不同图例之间的垂直距离，float 类型，默认为 0.5</td></tr><tr><td>shadow</td><td>是否给图例添加阴影效果，默认为 False</td></tr></tbody></table><h3 id="【1x01】方法一：指定-label-参数"><a href="#【1x01】方法一：指定-label-参数" class="headerlink" title="【1x01】方法一：指定 label 参数"></a><font color=#1BC3FB>【1x01】方法一：指定 label 参数</font></h3><p>在画图的时候先指定 <code>label</code> 标签文本，再调用 <code>legend()</code> 方法即可。</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = range(2, 26, 2)y = range(0, 12)a = [5, 10, 15, 20, 25, 30]b = [3, 4, 5, 6, 7, 8]plt.plot(a, b, label=&#39;图例一&#39;)    # 指定 a,b 数据的图例plt.plot(x, y, label=&#39;图例二&#39;)    # 指定 x,y 数据的图例plt.legend(loc=2, edgecolor=&#39;red&#39;, facecolor=&#39;#F5F5F5&#39;)  # 指定图例位置、边缘线条颜色和背景色plt.show()</code></pre><h3 id="【1x02】方法二：使用-set-label-方法"><a href="#【1x02】方法二：使用-set-label-方法" class="headerlink" title="【1x02】方法二：使用 set_label 方法"></a><font color=#1BC3FB>【1x02】方法二：使用 set_label 方法</font></h3><p>在画图的时候先使用 <code>set_label()</code> 方法指定标签文本，再调用 <code>legend()</code> 方法即可。</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = range(2, 26, 2)y = range(0, 12)a = [5, 10, 15, 20, 25, 30]b = [3, 4, 5, 6, 7, 8]line1, = plt.plot(a, b)line2, = plt.plot(x, y)line1.set_label(&#39;图例一&#39;)    # 指定 a,b 数据的图例line2.set_label(&#39;图例二&#39;)    # 指定 x,y 数据的图例plt.legend(loc=2, edgecolor=&#39;red&#39;, facecolor=&#39;#F5F5F5&#39;)  # 指定图例位置、边缘线条颜色和背景色plt.show()</code></pre><h3 id="【1x03】方法三：直接使用-legend-方法"><a href="#【1x03】方法三：直接使用-legend-方法" class="headerlink" title="【1x03】方法三：直接使用 legend 方法"></a><font color=#1BC3FB>【1x03】方法三：直接使用 legend 方法</font></h3><p>直接使用 <code>legend()</code> 方法来指定图例标签也可以达到同样效果，图例以列表或者元组形式储存，图例与绘制图形的顺序一一对应。</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = range(2, 26, 2)y = range(0, 12)a = [5, 10, 15, 20, 25, 30]b = [3, 4, 5, 6, 7, 8]plt.plot(a, b)plt.plot(x, y)plt.legend([&#39;图例一&#39;, &#39;图例二&#39;], loc=2, edgecolor=&#39;red&#39;, facecolor=&#39;#F5F5F5&#39;)plt.show()</code></pre><p>也可以使用两个元组，将绘制的图形和图例一一对应来储存：</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = range(2, 26, 2)y = range(0, 12)a = [5, 10, 15, 20, 25, 30]b = [3, 4, 5, 6, 7, 8]line1, = plt.plot(a, b)line2, = plt.plot(x, y)plt.legend((line1, line2), (&#39;图例一&#39;, &#39;图例二&#39;), loc=2, edgecolor=&#39;red&#39;, facecolor=&#39;#F5F5F5&#39;)plt.show()</code></pre><p>以上三种方法绘制的图形均一致：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A70/01.png" alt="01"></p><h2 id="【2x00】数学公式-LaTeX"><a href="#【2x00】数学公式-LaTeX" class="headerlink" title="【2x00】数学公式 LaTeX"></a><font color=#FF0000>【2x00】数学公式 LaTeX</font></h2><p>LaTeX（LATEX，音译“拉泰赫”）是一种基于 TeX 的排版系统，常用于生成复杂表格和数学公式，Matplotlib 提供了自己的 TeX 表达式解析器，布局引擎和字体，布局引擎基于 Donald Knuth 的 TeX 布局算法改编。使用数学公式时用 <code>$</code> 将其包围起来即可。具体的符号与其对应的英文表示参见官方文档：<a href="https://matplotlib.org/tutorials/text/mathtext.html">https://matplotlib.org/tutorials/text/mathtext.html</a></p><p>应用举例：</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltt = np.arange(0.0, 2.0, 0.01)s = np.sin(2*np.pi*t)plt.title(r&#39;$\alpha_i &gt; \beta_i$&#39;, fontsize=20)plt.text(1, -0.6, r&#39;$\sum_&#123;i=0&#125;^\infty x_i$&#39;, fontsize=20)plt.text(0.6, 0.6, r&#39;$\mathcal&#123;A&#125;\mathrm&#123;sin&#125;(2 \omega t)$&#39;, fontsize=20)plt.xlabel(&#39;time (s)&#39;)plt.ylabel(&#39;volts (mV)&#39;)plt.plot(t, s)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A70/02.png" alt="02"></p><h2 id="【3x00】调整-x-y-轴刻度和范围"><a href="#【3x00】调整-x-y-轴刻度和范围" class="headerlink" title="【3x00】调整 x / y 轴刻度和范围"></a><font color=#FF0000>【3x00】调整 x / y 轴刻度和范围</font></h2><p>在生成图像时，默认会按照所给的数据均匀设置几个刻度，如果对默认的刻度不满意，则可以使用 <code>xticks()</code> 或 <code>yticks()</code> 方法指定刻度值。<code>xlim()</code> 与 <code>ylim()</code> 则可以设置刻度的范围。</p><p>基本语法：<br><code>matplotlib.pyplot.xticks([ticks=None, labels=None, \*\*kwargs])</code><br><code>matplotlib.pyplot.yticks([ticks=None, labels=None, \*\*kwargs])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>ticks</td><td>数组形式的位置列表，即显示第 n 个位置的刻度，可选项，若传递空列表将删除所有 xtick / ytick</td></tr><tr><td>labels</td><td>数组形式的值，在对应刻度线显示的标签信息。仅当同时传递了刻度时，才能传递此参数</td></tr><tr><td>**kwargs</td><td>其他参数参见 <a href="https://matplotlib.org/api/text_api.html#matplotlib.text.Text">Text</a></td></tr></tbody></table><p>其他参数里面有一个常用的 <code>rotation</code> 参数，次参数可以用于设置刻度标签的旋转角度，对于标签太长的可以将其旋转一个角度来显示。</p><p>应用举例：</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = range(2, 26, 2)y = range(0, 12)plt.plot(x, y)# x 轴每隔三个显示一次刻度，旋转45°显示标签plt.xticks(range(2, 26, 3), (&#39;the &#123;&#125; ticks&#39;.format(i) for i in range(2, 26, 3)), rotation=45)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A70/03.png" alt="03"></p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = range(2, 26, 2)y = range(0, 12)plt.xlim((0, 30))   # 设置 x 轴刻度范围plt.plot(x, y)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A70/04.png" alt="04"></p><h2 id="【4x00】画布边框与坐标轴的移动"><a href="#【4x00】画布边框与坐标轴的移动" class="headerlink" title="【4x00】画布边框与坐标轴的移动"></a><font color=#FF0000>【4x00】画布边框与坐标轴的移动</font></h2><p>Matplotlib 所绘制的图表中的每个绘图元素，例如线条 Line2D、文字 Text、刻度等在内存中都有一个对象与之对应。</p><p><code>matplotlib.pyplot.gca()</code> 函数用于获取当前的绘图区 <code>Axes</code>（Get Current Axes）</p><p><code>matplotlib.pyplot.gcf()</code> 函数用于获取当前的画布 <code>Figure</code>（Get Current Figure）</p><p>例如：<code>matplotlib.pyplot.plot()</code> 实际上会通过 <code>matplotlib.pyplot.gca()</code> 获得当前的 Axes对象 <code>ax</code>，然后再调用 <code>ax.plot()</code> 方法实现真正的绘图。我们可以通过这种方法来实现画布边框的隐藏和坐标轴的移动。</p><p>应用举例：</p><pre><code class="python">import matplotlib.pyplot as pltimport numpy as npx = np.arange(0, 2*np.pi, np.pi/100)y = np.sin(x)plt.plot(x, y)plt.xlabel(&#39;X axis&#39;)plt.ylabel(&#39;Y axis&#39;)ticks = (0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi)labels = (&#39;0&#39;, r&#39;$\frac&#123;\pi&#125; &#123;2&#125;$&#39;, r&#39;$\pi$&#39;, r&#39;$\frac&#123;3\pi&#125; &#123;2&#125;$&#39;, r&#39;$2\pi$&#39;)plt.xticks(ticks, labels)                      # 设置 x 坐标轴显示的数据ax = plt.gca()                                 # 获取当前的画布, gca = get current axesax.spines[&#39;right&#39;].set_visible(False)          # 设置右边框不显示ax.spines[&#39;top&#39;].set_visible(False)            # 设置上边框不显示# ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)           # 设置颜色为无也可以ax.xaxis.set_ticks_position(&#39;bottom&#39;)          # 设置 x 坐标轴的标签位置ax.yaxis.set_ticks_position(&#39;left&#39;)            # 设置 y 坐标轴的标签位置ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;, 0))  # 设置 x 轴在 (0, 0) 位置ax.spines[&#39;left&#39;].set_position((&#39;data&#39;, 0))    # 设置 y 轴在 (0, 0) 位置plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A70/05.png" alt="05"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105828143未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【5x00】创建子图"><a href="#【5x00】创建子图" class="headerlink" title="【5x00】创建子图"></a><font color=#FF0000>【5x00】创建子图</font></h2><p>子图的概念：在同一张画布中创建多个图像，方便对数据进行对比。</p><h3 id="【5x01】方法一：add-subplot"><a href="#【5x01】方法一：add-subplot" class="headerlink" title="【5x01】方法一：add_subplot()"></a><font color=#1BC3FB>【5x01】方法一：add_subplot()</font></h3><p>首先创建一个画布，然后利用 <code>add_subplot()</code> 方法填充子图，该方法接收三个参数，前两个参数表示子图有几行几列，最后一个参数表示第几个子图，如：<code>fig.add_subplot(221)</code> 表示总共有两行两列（2x2=4）一共4个子图，当前是第一个子图。若子图大于9个则用逗号隔开即可。</p><p>应用举例：</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltx = np.arange(100)fig = plt.figure(figsize=(12, 6))ax1 = fig.add_subplot(221)   # 第 1 个子图ax1.plot(x, x)ax2 = fig.add_subplot(222)   # 第 2 个子图ax2.plot(x, -x)ax3 = fig.add_subplot(223)   # 第 3 个子图ax3.plot(x, x ** 2)ax4 = fig.add_subplot(224)   # 第 4 个子图ax4.plot(-x, x ** 2)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A70/06.png" alt="06"></p><h3 id="【5x02】方法二：pyplot-subplot"><a href="#【5x02】方法二：pyplot-subplot" class="headerlink" title="【5x02】方法二：pyplot.subplot()"></a><font color=#1BC3FB>【5x02】方法二：pyplot.subplot()</font></h3><p><code>matplotlib.pyplot.subplot()</code> 方法和 <code>add_subplot()</code> 方法有点儿类似，同样接收三个参数，前两个参数表示子图有几行几列，最后一个参数表示第几个子图。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltx = np.arange(100)plt.figure(figsize=(12, 6))plt.subplot(221)     # 第 1 个子图plt.plot(x, x)plt.subplot(222)     # 第 2 个子图plt.plot(x, x ** 2)plt.subplot(223)     # 第 3 个子图plt.plot(x, x ** 3)plt.subplot(224)     # 第 4 个子图plt.plot(x, x ** 4)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A70/07.png" alt="07"></p><h3 id="【5x03】方法三：pyplot-subplots"><a href="#【5x03】方法三：pyplot-subplots" class="headerlink" title="【5x03】方法三：pyplot.subplots()"></a><font color=#1BC3FB>【5x03】方法三：pyplot.subplots()</font></h3><p><code>matplotlib.pyplot.subplots()</code> 函数会将画布分割成指定的列和行，分割后依次在各个区域画图即可。注意与 <code>matplotlib.pyplot.subplot()</code> 略有差别。</p><p><code>fig, axes = plt.subplots</code> 的意思是：<code>plt.subplots</code> 方法会返回一个包含 figure（画布） 和 axes（绘图区） 对象的元组，fig 和 axes 参数分别接收这两个对象，后期对不同绘图区进行处理即可。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltx = np.arange(100)fig, axes = plt.subplots(figsize=(12, 6), nrows=2, ncols=2)  # 将画布分割为2行2列，起始值为0axes[0][0].plot(x, x)         # 绘制第1行第1列axes[0][1].plot(x, -x)        # 绘制第1行第2列axes[1][0].plot(-x, x ** 2)   # 绘制第2行第1列axes[1][1].plot(x, -x ** 2)   # 绘制第2行第2列plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A70/08.png" alt="08"></p><h2 id="【6x00】填充补丁"><a href="#【6x00】填充补丁" class="headerlink" title="【6x00】填充补丁"></a><font color=#FF0000>【6x00】填充补丁</font></h2><p><code>matplotlib.patches</code> 可用于在画布上填充圆形、长方形、椭圆形、多边形等多种图像补丁。</p><p>官方文档：<a href="https://matplotlib.org/api/patches_api.html">https://matplotlib.org/api/patches_api.html</a></p><table><thead><tr><th>类</th><th>描述</th></tr></thead><tbody><tr><td>matplotlib.patches.Arc(xy, width, height, angle=0.0, theta1=0.0, theta2=360.0, **kwargs)</td><td>椭圆弧</td></tr><tr><td>matplotlib.patches.Arrow(x, y, dx, dy, width=1.0, **kwargs)</td><td>箭头</td></tr><tr><td>matplotlib.patches.Circle(xy, radius=5, **kwargs)</td><td>圆</td></tr><tr><td>matplotlib.patches.Ellipse(xy, width, height, angle=0, **kwargs)</td><td>椭圆</td></tr><tr><td>matplotlib.patches.CirclePolygon(xy, radius=5, resolution=20, **kwargs)</td><td>近似多边形的圆形面片</td></tr><tr><td>matplotlib.patches.Polygon(xy, closed=True, **kwargs)</td><td>不规则多边形</td></tr><tr><td>matplotlib.patches.Rectangle(xy, width, height, angle=0.0, **kwargs)</td><td>矩形</td></tr><tr><td>matplotlib.patches.RegularPolygon(xy, numVertices, radius=5, orientation=0, **kwargs)</td><td>正多边形</td></tr><tr><td>matplotlib.patches.Shadow(patch, ox, oy, props=None, **kwargs)</td><td>创建给定补丁的阴影</td></tr><tr><td>matplotlib.patches.Wedge(center, r, theta1, theta2, width=None, **kwargs)</td><td>楔形</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltimport matplotlib.patches as mpathesx = np.arange(0.0, 2.0, 0.01)y = np.sin(2*np.pi*x)# 获取当前绘图区（gca = Get Current Axesax = plt.gca()# 圆形：圆点(0.2, -0.25)，半径0.2，红色circle = mpathes.Circle((0.2, -0.25), 0.2, color=&#39;r&#39;)# 长方形：左侧和底部坐标(0.25, 0.75)，宽0.25，高0.15，透明度0.5rect = mpathes.Rectangle((0.25, 0.75), 0.25, 0.15, alpha=0.5)# 正多边形：中心点坐标(1.0, 0)，顶点数6，中心到每个顶点的距离0.25regular_polygon = mpathes.RegularPolygon((1.0, 0), 6, 0.25, color=&#39;g&#39;)# 不规则多边形：polygon_point 为要连接的点的坐标polygon_point = [[1.5, -0.75], [1.75, -1], [2.0, 0], [1.5, -0.25]]polygon = mpathes.Polygon(polygon_point, color=&#39;#FF69B4&#39;, alpha=0.3)# 椭圆形：中心点坐标(1.25, 0.75)，横轴长度0.4，垂直轴长度0.2ellipse = mpathes.Ellipse((1.25, 0.75), 0.4, 0.2, color=&#39;y&#39;)# 将补丁添加到当前绘图区ax.add_patch(circle)ax.add_patch(rect)ax.add_patch(regular_polygon)ax.add_patch(polygon)ax.add_patch(ellipse)plt.xlabel(&#39;x axis label&#39;)plt.ylabel(&#39;y axis label&#39;)plt.grid()plt.plot(x, y)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A70/09.png" alt="09"></p><h2 id="【7x00】保存图像"><a href="#【7x00】保存图像" class="headerlink" title="【7x00】保存图像"></a><font color=#FF0000>【7x00】保存图像</font></h2><p><code>matplotlib.pyplot.savefig()</code> 方法可以将绘制的图像保存到本地，支持多种格式：eps, pdf, pgf, png, ps, raw, rgba, svg, svgz。</p><p><font color=#FF0000> <strong>注意：因为调用 <code>plt.show()</code> 函数后，会创建一个新的空白的图片，所以在保存图片时注意要在 <code>plt.show()</code> 前调用 <code>plt.savefig()</code></strong> </font></p><p>基本语法：<code>matplotlib.pyplot.savefig(fname, dpi=None, facecolor=&#39;w&#39;, edgecolor=&#39;w&#39;, format=None, transparent=False)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>fname</td><td>str 类型 / 文件路径 / 类似文件的对象<br>如果未设置格式，则根据 fname 的扩展名（如果有）和 <code>rcParams[“savefig.format”] = ‘png’</code> 推断输出格式<br>如果设置了格式，则它将确定输出格式</td></tr><tr><td>dpi</td><td>保存图片的像素（dpi），以每英寸点数为单位。如果为 None，则默认取 <code>rcParams[’savefig.dpi’] = ‘figure’</code></td></tr><tr><td>facecolor</td><td>保存图片的画布颜色，默认为 white</td></tr><tr><td>edgecolor</td><td>保存图片的边缘颜色，默认为 white</td></tr><tr><td>format</td><td>保存图片的格式，未设置则取 fname 中的格式</td></tr><tr><td>transparent</td><td>保存图片的背景是否透明</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = range(2, 26, 2)y = range(0, 12)a = [5, 10, 15, 20, 25, 30]b = [3, 4, 5, 6, 7, 8]line1, = plt.plot(a, b)line2, = plt.plot(x, y)plt.legend((line1, line2), (&#39;图例一&#39;, &#39;图例二&#39;), loc=2, edgecolor=&#39;red&#39;, facecolor=&#39;#F5F5F5&#39;)plt.savefig(&#39;D:\\data\\pic.png&#39;, transparent=True)  # 保存为透明文件plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A70/10.png" alt="10"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105828143未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Matplotlib（二）：文本描述/中文支持/画布/网格等基本图像属性</title>
      <link href="/article/015/"/>
      <url>/article/015/</url>
      
        <content type="html"><![CDATA[<p>Matplotlib 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/014/">Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</a></li><li><a href="https://www.itbob.cn/article/015/">Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/016/">Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/017/">Python 数据分析三剑客之 Matplotlib（四）：线性图的绘制</a></li><li><a href="https://www.itbob.cn/article/018/">Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制</a></li><li><a href="https://www.itbob.cn/article/019/">Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制</a></li><li><a href="https://www.itbob.cn/article/020/">Python 数据分析三剑客之 Matplotlib（七）：饼状图的绘制</a></li><li><a href="https://www.itbob.cn/article/021/">Python 数据分析三剑客之 Matplotlib（八）：等高线 / 等值线图的绘制</a></li><li><a href="https://www.itbob.cn/article/022/">Python 数据分析三剑客之 Matplotlib（九）：极区图 / 极坐标图 / 雷达图的绘制</a></li><li><a href="https://www.itbob.cn/article/023/">Python 数据分析三剑客之 Matplotlib（十）：3D 图的绘制</a></li><li><a href="https://www.itbob.cn/article/024/">Python 数据分析三剑客之 Matplotlib（十一）：最热门最常用的 50 个图表</a>【译文】</li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105828049未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】添加文本描述"><a href="#【1x00】添加文本描述" class="headerlink" title="【1x00】添加文本描述"></a><font color=#FF0000>【1x00】添加文本描述</font></h2><h3 id="【1x01】添加标题：matplotlib-pyplot-title"><a href="#【1x01】添加标题：matplotlib-pyplot-title" class="headerlink" title="【1x01】添加标题：matplotlib.pyplot.title()"></a><font color=#1BC3FB>【1x01】添加标题：matplotlib.pyplot.title()</font></h3><p><code>matplotlib.pyplot.title()</code> 方法可为图表添加标题。</p><p>基本语法：<code>matplotlib.pyplot.title(label[, fontdict=None, loc=None, pad=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>label</td><td>str 类型，标题文字</td></tr><tr><td>fontdict</td><td>字典类型，控制标题文本外观，可选项，默认值为：<br><code>&#123;&#39;fontsize&#39;: rcParams[&#39;axes.titlesize&#39;], </code><br><code>&#39;fontweight&#39; : rcParams[&#39;axes.titleweight&#39;], </code><br><code>&#39;color&#39; : rcParams[&#39;axes.titlecolor&#39;], </code><br><code>&#39;verticalalignment&#39;: &#39;baseline&#39;, </code><br><code>&#39;horizontalalignment&#39;: loc&#125;</code></td></tr><tr><td>loc</td><td>str 类型，可选项，三个可选值：center、left、right，默认为 <code>rcParams[&quot;axes.titlelocation&quot;]</code>（默认为 <code>center</code>）</td></tr><tr><td>pad</td><td>float 类型，可选项，标题距轴顶部的偏移量（以磅为单位）。如果为 None，则默认为 <code>rcParams[&quot;axes.titlepad&quot;]</code>（默认为：6.0）</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">import matplotlib.pyplot as pltx = range(2, 26, 2)y = range(0, 12)plt.title(&#39;This is a title&#39;)plt.plot(x, y)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A69/01.png" alt="01"></p><h3 id="【1x02】为坐标轴添加标签：matplotlib-pyplot-xlabel-ylabel"><a href="#【1x02】为坐标轴添加标签：matplotlib-pyplot-xlabel-ylabel" class="headerlink" title="【1x02】为坐标轴添加标签：matplotlib.pyplot.xlabel() / ylabel()"></a><font color=#1BC3FB>【1x02】为坐标轴添加标签：matplotlib.pyplot.xlabel() / ylabel()</font></h3><p><code>matplotlib.pyplot.xlabel()</code>：为 x 轴添加标签；<br><code>matplotlib.pyplot.ylabel()</code>：为 y 轴添加标签。</p><p>基本语法：<br><code>matplotlib.pyplot.xlabel(xlabel[, fontdict=None, labelpad=None])</code><br><code>matplotlib.pyplot.ylabel(ylabel[, fontdict=None, labelpad=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>xlabel / ylabel</td><td>str 类型，要添加的文本信息</td></tr><tr><td>fontdict</td><td>字典类型，控制标题文本外观，可选项，默认值为：<br><code>&#123;&#39;fontsize&#39;: rcParams[&#39;axes.titlesize&#39;], </code><br><code>&#39;fontweight&#39; : rcParams[&#39;axes.titleweight&#39;], </code><br><code>&#39;color&#39; : rcParams[&#39;axes.titlecolor&#39;], </code><br><code>&#39;verticalalignment&#39;: &#39;baseline&#39;, </code><br><code>&#39;horizontalalignment&#39;: loc&#125;</code></td></tr><tr><td>labelpad</td><td>float 类型，可选项，x 轴标签距离 x 轴的距离</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">import matplotlib.pyplot as pltx = range(2, 26, 2)y = range(0, 12)a = [5, 10, 15, 20, 25, 30]b = [3, 4, 5, 6, 7, 8]plt.title(&#39;This is a title&#39;)plt.xlabel(&#39;This is x label&#39;, fontdict=&#123;&#39;fontsize&#39;: 15, &#39;fontweight&#39;: &#39;bold&#39;, &#39;color&#39;: &#39;red&#39;&#125;, labelpad=15.0)plt.ylabel(&#39;This is y label&#39;, fontsize=10, fontweight=&#39;light&#39;, color=&#39;blue&#39;, labelpad=15.0)plt.plot(x, y)plt.plot(a, b)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A69/02.png" alt="02"></p><h3 id="【1x03】任意位置添加文本：matplotlib-pyplot-text"><a href="#【1x03】任意位置添加文本：matplotlib-pyplot-text" class="headerlink" title="【1x03】任意位置添加文本：matplotlib.pyplot.text()"></a><font color=#1BC3FB>【1x03】任意位置添加文本：matplotlib.pyplot.text()</font></h3><p><code>matplotlib.pyplot.text()</code> 方法可以在画布上任意位置添加文本描述。</p><p>基本语法：<code>matplotlib.pyplot.text(x, y, s[, fontdict=None, withdash=&lt;deprecated parameter&gt;])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>x, y</td><td>放置文本的坐标位置</td></tr><tr><td>s</td><td>str 类型，要添加的文本信息</td></tr><tr><td>fontdict</td><td>字典类型，控制标题文本外观，可选项，默认值为：<br><code>&#123;&#39;fontsize&#39;: rcParams[&#39;axes.titlesize&#39;], </code><br><code>&#39;fontweight&#39; : rcParams[&#39;axes.titleweight&#39;], </code><br><code>&#39;color&#39; : rcParams[&#39;axes.titlecolor&#39;], </code><br><code>&#39;verticalalignment&#39;: &#39;baseline&#39;, </code><br><code>&#39;horizontalalignment&#39;: loc&#125;</code></td></tr><tr><td>ha</td><td>注释点在注释文本的左边、右边或中间（<code>left</code>、<code>right</code>、<code>center</code>）</td></tr><tr><td>va</td><td>注释点在注释文本的上边、下边、中间或基线 （<code>top</code>、<code>bottom</code>、<code>center</code>、<code>baseline</code>）</td></tr><tr><td>withdash</td><td>bool 类型，可选项，默认为 False，创建一个 <a href="https://matplotlib.org/api/text_api.html#matplotlib.text.TextWithDash">TextWithDash</a> 实例而不是一个 <a href="https://matplotlib.org/api/text_api.html#matplotlib.text.Text">Text</a> 实例</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;lines.marker&#39;] = &#39;o&#39;  # 设置线条上点的形状a = [5, 10, 15, 20, 25, 30]b = [3, 4, 5, 6, 7, 8]plt.title(&#39;This is a title&#39;)plt.xlabel(&#39;This is x label&#39;)plt.ylabel(&#39;This is y label&#39;)plt.text(4, 3.2, &#39;text1&#39;)plt.text(9, 4.2, &#39;text2&#39;)plt.text(14, 5.2, &#39;text3&#39;)plt.text(19, 6.2, &#39;text4&#39;)plt.text(24, 7.2, &#39;text5&#39;)plt.text(27.5, 7.9, &#39;text6&#39;)plt.plot(a, b)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A69/03.png" alt="03"></p><h3 id="【1x03】任意位置添加文本：matplotlib-pyplot-annotate"><a href="#【1x03】任意位置添加文本：matplotlib-pyplot-annotate" class="headerlink" title="【1x03】任意位置添加文本：matplotlib.pyplot.annotate()"></a><font color=#1BC3FB>【1x03】任意位置添加文本：matplotlib.pyplot.annotate()</font></h3><p><code>matplotlib.pyplot.annotate()</code> 方法可以在指定坐标点添加文本或 LaTeX 描述，也可以在其他位置添加描述后，使用箭头指向某个坐标点。比 <code>matplotlib.pyplot.text()</code> 更高级。</p><p>基本语法：<code>matplotlib.pyplot.annotate(text, xy, xytext, xycoords, textcoords, ha, va, arrowprops, \*\*kwargs)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>text</td><td>str 类型，注释的文本</td></tr><tr><td>xy</td><td>被注释的坐标点，格式：<code>(x, y)</code></td></tr><tr><td>xytext</td><td>注释文本的坐标点，格式：<code>(x, y)</code>，默认与 xy 相同</td></tr><tr><td>xycoords</td><td>被注释的坐标点的参考系，取值参见<font color=#FF0000><strong>表一</strong></font>，默认为 ‘data’</td></tr><tr><td>textcoords</td><td>注释文本的坐标点的参考系，取值参见<font color=#FF0000><strong>表二</strong></font>，默认为 xycoords 的值</td></tr><tr><td>ha</td><td>注释点在注释文本的左边、右边或中间（<code>left</code>、<code>right</code>、<code>center</code>）</td></tr><tr><td>va</td><td>注释点在注释文本的上边、下边、中间或基线 （<code>top</code>、<code>bottom</code>、<code>center</code>、<code>baseline</code>）</td></tr><tr><td>arrowprops</td><td>dict 字典类型，箭头的样式<br>如果 arrowprops 不包含键 arrowstyle，则允许的键参见<font color=#FF0000><strong>表三</strong></font><br>如果 arrowprops 包含键 arrowstyle，则允许的键参见<font color=#FF0000><strong>表四</strong></font></td></tr></tbody></table><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font color=#FF0000 size=3px>表一：xycoords 取值类型</font></strong></td></tr></table><table><thead><tr><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>‘figure points’</td><td>以画布左下角为参考，单位为点数</td></tr><tr><td>‘figure pixels’</td><td>以画布左下角为参考，单位为像素</td></tr><tr><td>‘figure fraction’</td><td>以画布左下角为参考，单位为百分比</td></tr><tr><td>‘axes points’</td><td>以绘图区左下角为参考，单位为点数</td></tr><tr><td>‘axes pixels’</td><td>以绘图区左下角为参考，单位为像素</td></tr><tr><td>‘axes fraction’</td><td>以绘图区左下角为参考，单位为百分比</td></tr><tr><td>‘data’</td><td>使用被注释对象的坐标系，即数据的 x, y 轴（默认）</td></tr><tr><td>‘polar’</td><td>使用（θ，r）形式的极坐标系</td></tr></tbody></table><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font color=#FF0000 size=3px>表二：textcoords 取值类型</font></strong></td></tr></table><table><thead><tr><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>‘figure points’</td><td>以画布左下角为参考，单位为点数</td></tr><tr><td>‘figure pixels’</td><td>以画布左下角为参考，单位为像素</td></tr><tr><td>‘figure fraction’</td><td>以画布左下角为参考，单位为百分比</td></tr><tr><td>‘axes points’</td><td>以绘图区左下角为参考，单位为点数</td></tr><tr><td>‘axes pixels’</td><td>以绘图区左下角为参考，单位为像素</td></tr><tr><td>‘axes fraction’</td><td>以绘图区左下角为参考，单位为百分比</td></tr><tr><td>‘data’</td><td>使用被注释对象的坐标系，即数据的 x, y 轴</td></tr><tr><td>‘polar’</td><td>使用（θ，r）形式的极坐标系</td></tr><tr><td>‘offset points’</td><td>相对于被注释点的坐标 xy 的偏移量，单位是点</td></tr><tr><td>‘offset pixels’</td><td>相对于被注释点的坐标 xy 的偏移量，单位是像素</td></tr></tbody></table><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font color=#FF0000 size=3px>表三：arrowprops 不包含键 arrowstyle 时的取值</font></strong></td></tr></table><table><thead><tr><th>键</th><th>描述</th></tr></thead><tbody><tr><td>width</td><td>箭头的宽度，以点为单位</td></tr><tr><td>headwidth</td><td>箭头底部的宽度，以点为单位</td></tr><tr><td>headlength</td><td>箭头的长度，以点为单位</td></tr><tr><td>shrink</td><td>箭头两端收缩占总长的百分比</td></tr><tr><td>?</td><td>其他 <a href="https://matplotlib.org/api/_as_gen/matplotlib.patches.FancyArrowPatch.html#matplotlib.patches.FancyArrowPatch">matplotlib.patches.FancyArrowPatch</a> 中的关键字，部分常用关键字参见<font color=#FF0000><strong>表五</strong></font></td></tr></tbody></table><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font color=#FF0000 size=3px>表四：arrowprops 包含键 arrowstyle 时的取值</font></strong></td></tr></table><table><thead><tr><th>取值</th><th>描述</th></tr></thead><tbody><tr><td><code>&#39;-&#39;</code></td><td>None</td></tr><tr><td><code>&#39;-&gt;&#39;</code></td><td>head_length=0.4,head_width=0.2</td></tr><tr><td><code>&#39;-[&#39;</code></td><td>widthB=1.0,lengthB=0.2,angleB=None</td></tr><tr><td><code>&#39;]-&#39;</code></td><td>widthA=1.0, lengthA=0.2, angleA=None</td></tr><tr><td><code>]-[</code></td><td>widthA=1.0, lengthA=0.2, angleA=None, widthB=1.0, lengthB=0.2, angleB=None</td></tr><tr><td>`’</td><td>-</td></tr><tr><td>`’-</td><td>&gt;’`</td></tr><tr><td><code>&#39;&lt;-&#39;</code></td><td>head_length=0.4,head_width=0.2</td></tr><tr><td><code>&#39;&lt;-&gt;&#39;</code></td><td>head_length=0.4,head_width=0.2</td></tr><tr><td>`’&lt;</td><td>-‘`</td></tr><tr><td>`’&lt;</td><td>-</td></tr><tr><td><code>&#39;fancy&#39;</code></td><td>head_length=0.4,head_width=0.4,tail_width=0.4</td></tr><tr><td><code>&#39;simple&#39;</code></td><td>head_length=0.5,head_width=0.5,tail_width=0.2</td></tr><tr><td><code>&#39;wedge&#39;</code></td><td>tail_width=0.3,shrink_factor=0.5</td></tr></tbody></table><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font color=#FF0000 size=3px>表五：matplotlib.patches.FancyArrowPatch 常用的键</font></strong></td></tr></table><table><thead><tr><th>键</th><th>描述</th></tr></thead><tbody><tr><td>arrowstyle</td><td>箭头样式，取值参见<font color=#FF0000><strong>表四</strong></font></td></tr><tr><td>connectionstyle</td><td>连接方式，默认为 <code>arc3</code>，有以下五种取值：<br><code>angle</code>：angleA=90, angleB=0, rad=0.0<br><code>angle3</code>：angleA=90, angleB=0<br><code>arc</code>：angleA=0, angleB=0, armA=None, armB=None, rad=0.0<br><code>arc3</code>：rad=0.0<br><code>bar</code>：armA=0.0, armB=0.0, fraction=0.3, angle=None<br>angle 为箭头旋转的角度，rad 为弧度</td></tr><tr><td>relpos</td><td>箭头起始点相对注释文本的位置，默认为 (0.5, 0.5)，即文本的中心<br>（0，0）表示左下角，（1，1）表示右上角</td></tr><tr><td>patchA</td><td>箭头起点处的图形，默认为文本的边框</td></tr><tr><td>patchB</td><td>箭头终点处的图形，默认为空</td></tr><tr><td>shrinkA</td><td>箭头起点的缩进点数，默认为2</td></tr><tr><td>shrinkB</td><td>箭头终点的缩进点数，默认为2</td></tr><tr><td>？</td><td>其他键值，参见官方文档 <a href="https://matplotlib.org/api/_as_gen/matplotlib.patches.PathPatch.html#matplotlib.patches.PathPatch">matplotlib.patches.PathPatch</a></td></tr></tbody></table><table><tr><td bgcolor="#7FFFD4" colspan="2"><strong><font color=#FF0000 size=3px>connectionstyle 样式举例</font></strong></td></tr></table><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A69/04.png" alt="04"></p><p>应用举例：</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltx = np.arange(-2*np.pi, 2*np.pi, 0.01)y = np.sin(1*x)/xplt.title(&#39;This is a title&#39;)plt.xlabel(&#39;This is x label&#39;)plt.ylabel(&#39;This is y label&#39;)plt.plot(x, y)plt.annotate(r&#39;$\lim_&#123;x\to 0&#125;\frac&#123;\sin(x)&#125;&#123;x&#125;=1$&#39;,  # 插入 LaTeX 表达式             xy=[0, 1],                              # 被标记的坐标             xycoords=&#39;data&#39;,                        # 被标记的坐标的参考系             xytext=[50, -40],                        # 注释文本的坐标             textcoords=&#39;offset points&#39;,             # 注释文本的坐标的参考系             fontsize=16,                            # 字体大小             arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3, rad=.2&quot;))  # 箭头样式plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A69/05.png" alt="05"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105828049未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【2x00】设置中文显示"><a href="#【2x00】设置中文显示" class="headerlink" title="【2x00】设置中文显示"></a><font color=#FF0000>【2x00】设置中文显示</font></h2><h3 id="【2x01】常见系统自带文字及其英文名称"><a href="#【2x01】常见系统自带文字及其英文名称" class="headerlink" title="【2x01】常见系统自带文字及其英文名称"></a><font color=#1BC3FB>【2x01】常见系统自带文字及其英文名称</font></h3><p>Windows 系统中常见自带字体：</p><table><thead><tr><th>字体</th><th>英文名称</th></tr></thead><tbody><tr><td>黑体</td><td>SimHei</td></tr><tr><td>宋体</td><td>SimSun</td></tr><tr><td>新宋体</td><td>NSimSun</td></tr><tr><td>仿宋</td><td>FangSong</td></tr><tr><td>仿宋_GB2312</td><td>FangSong_GB2312</td></tr><tr><td>楷体_GB2312</td><td>KaiTi_GB2312</td></tr><tr><td>楷体</td><td>KaiTi</td></tr><tr><td>微软正黑</td><td>Microsoft JhengHei</td></tr><tr><td>微软雅黑</td><td>Microsoft YaHei</td></tr><tr><td>细明体</td><td>MingLiU</td></tr><tr><td>标楷体</td><td>DFKai-SB</td></tr><tr><td>新细明体</td><td>PMingLiU</td></tr></tbody></table><p>装有 office 后新添加的字体：</p><table><thead><tr><th>字体</th><th>英文名称</th></tr></thead><tbody><tr><td>隶书</td><td>LiSu</td></tr><tr><td>幼圆</td><td>YouYuan</td></tr><tr><td>华文细黑</td><td>STXihei</td></tr><tr><td>华文楷体</td><td>STKaiti</td></tr><tr><td>华文宋体</td><td>STSong</td></tr><tr><td>华文中宋</td><td>STZhongsong</td></tr><tr><td>华文仿宋</td><td>STFangsong</td></tr><tr><td>方正舒体</td><td>FZShuTi</td></tr><tr><td>方正姚体</td><td>FZYaoti</td></tr><tr><td>华文彩云</td><td>STCaiyun</td></tr><tr><td>华文琥珀</td><td>STHupo</td></tr><tr><td>华文隶书</td><td>STLiti</td></tr><tr><td>华文行楷</td><td>STXingkai</td></tr><tr><td>华文新魏</td><td>STXinwei</td></tr></tbody></table><p>Mac OS 系统中常见自带字体：</p><table><thead><tr><th>字体</th><th>英文名称</th></tr></thead><tbody><tr><td>华文细黑</td><td>STHeiti Light / STXihei</td></tr><tr><td>华文黑体</td><td>STHeiti</td></tr><tr><td>华文楷体</td><td>STKaiti</td></tr><tr><td>华文宋体</td><td>STSong</td></tr><tr><td>华文仿宋</td><td>STFangsong</td></tr><tr><td>丽黑 Pro</td><td>LiHei Pro Medium</td></tr><tr><td>丽宋 Pro</td><td>LiSong Pro Light</td></tr><tr><td>标楷体</td><td>BiauKai</td></tr><tr><td>苹果丽中黑</td><td>Apple LiGothic Medium</td></tr><tr><td>苹果丽细宋</td><td>Apple LiSung Light</td></tr></tbody></table><h3 id="【2x02】指定全局字体：rcParams"><a href="#【2x02】指定全局字体：rcParams" class="headerlink" title="【2x02】指定全局字体：rcParams"></a><font color=#1BC3FB>【2x02】指定全局字体：rcParams</font></h3><p>通过 <code>rcParams[&#39;font.sans-serif&#39;]</code> 可以配置全局字体。</p><p>优点：只需设置一次即可显示所有中文；缺点：污染全局，无法对单个中文设置字体。</p><p>应用举例：</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]   # 配置全局字体为微软雅黑plt.rcParams[&#39;axes.unicode_minus&#39;] = False              # 部分字体负号会显示乱码，可添加此参数进行配置a = [-15, -10, -5, 20, 25, 30]b = [-5, -4, -3, 6, 7, 8]plt.title(&#39;这是中文标题&#39;)plt.xlabel(&#39;这是 x 轴标签&#39;)plt.ylabel(&#39;这是 y 轴标签&#39;)plt.plot(a, b)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A69/06.png" alt="06"></p><h3 id="【2x03】指定单个字体：fontproperties"><a href="#【2x03】指定单个字体：fontproperties" class="headerlink" title="【2x03】指定单个字体：fontproperties"></a><font color=#1BC3FB>【2x03】指定单个字体：fontproperties</font></h3><p><code>fontproperties</code> 参数可以加在要设置中文的地方</p><p>优点：不污染全局；缺点：中文太多了挨个设置比较繁琐。</p><p>应用举例：</p><pre><code class="python">import matplotlib.pyplot as plta = [-15, -10, -5, 20, 25, 30]b = [-5, -4, -3, 6, 7, 8]plt.title(&#39;这是中文标题&#39;, fontproperties=&#39;Microsoft JhengHei&#39;)   # 微软正黑plt.xlabel(&#39;这是 x 轴标签&#39;, fontproperties=&#39;STLiti&#39;)             # 华文隶书plt.ylabel(&#39;这是 y 轴标签&#39;, fontproperties=&#39;Microsoft YaHei&#39;)    # 微软雅黑plt.plot(a, b)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A69/07.png" alt="07"></p><h3 id="【2x04】指定文字路径：FontProperties"><a href="#【2x04】指定文字路径：FontProperties" class="headerlink" title="【2x04】指定文字路径：FontProperties"></a><font color=#1BC3FB>【2x04】指定文字路径：FontProperties</font></h3><p><code>matplotlib</code> 中 <code>font_manager</code> 模块的 <code>FontProperties</code> 方法可以通过指定文字路径来使用本地文字，在 Windows 中，文字路径一般是 <code>C:\Windows\Fonts\</code>，文字名称可以通过其属性来获取，部分用户自己安装的字体可能包含多个类型，可打开字体合集后通过其属性来获取。</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A69/08.png" alt="08"></p><pre><code class="python">import matplotlib.pyplot as pltfrom matplotlib.font_manager import FontPropertiesfont = FontProperties(fname=r&quot;C:\Windows\Fonts\STXINGKA.TTF&quot;, size=14)a = [-15, -10, -5, 20, 25, 30]b = [-5, -4, -3, 6, 7, 8]plt.title(&#39;这是中文标题&#39;, fontproperties=font)plt.xlabel(&#39;这是 x 轴标签&#39;, fontproperties=font)plt.ylabel(&#39;这是 y 轴标签&#39;, fontproperties=font)plt.plot(a, b)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A69/09.png" alt="09"></p><h3 id="【2x05】文字更多属性：rc"><a href="#【2x05】文字更多属性：rc" class="headerlink" title="【2x05】文字更多属性：rc"></a><font color=#1BC3FB>【2x05】文字更多属性：rc</font></h3><p>rc 参数支持文字的更多属性设置，如字体粗细、大小等，这种方法同样将影响全局。</p><p>官方参考：<a href="https://matplotlib.org/api/matplotlib_configuration_api.html?highlight=rc#matplotlib.rc">https://matplotlib.org/api/matplotlib_configuration_api.html?highlight=rc#matplotlib.rc</a></p><p>应用举例：</p><pre><code class="python">import matplotlib.pyplot as pltfont = &#123;&#39;family&#39;: &#39;SimHei&#39;,        &#39;weight&#39;: &#39;bold&#39;,        &#39;size&#39;: &#39;10&#39;&#125;plt.rc(&#39;font&#39;, **font)               # 设置字体的更多属性plt.rc(&#39;axes&#39;, unicode_minus=False)  # 显示负号a = [-15, -10, -5, 20, 25, 30]b = [-5, -4, -3, 6, 7, 8]plt.title(&#39;这是中文标题&#39;)plt.xlabel(&#39;这是 x 轴标签&#39;)plt.ylabel(&#39;这是 y 轴标签&#39;)plt.plot(a, b)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A69/10.png" alt="10"></p><h2 id="【3x00】设置画布大小-分辨率-颜色"><a href="#【3x00】设置画布大小-分辨率-颜色" class="headerlink" title="【3x00】设置画布大小 / 分辨率 / 颜色"></a><font color=#FF0000>【3x00】设置画布大小 / 分辨率 / 颜色</font></h2><p><code>matplotlib.pyplot.figure()</code> 可以设置画布的大小、图片分辨率、颜色等。</p><p>基本语法：<code>matplotlib.pyplot.figure(figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True, \*\*kwargs)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>figsize</td><td><code>(float, float)</code> 的格式，代表宽度和高度，单位为英寸<br>默认为 <code>rcParams[&quot;figure.figsize&quot;] = [6.4, 4.8]</code>，即：640 x 480</td></tr><tr><td>dpi</td><td>图像分辨率，默认为 <code>rcParams[&quot;figure.figsize&quot;] = 100</code></td></tr><tr><td>facecolor</td><td>图像背景颜色，默认为 <code>rcParams[&quot;figure.edgecolor&quot;] = ‘white’</code></td></tr><tr><td>edgecolor</td><td>图像边缘颜色，默认为 <code>rcParams[’figure.edgecolor’] = ‘white’</code></td></tr><tr><td>frameon</td><td>是否启用图框</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]x = range(2, 26, 2)y = range(0, 12)plt.figure(figsize=(6.5, 5), dpi=120, facecolor=&#39;#BBFFFF&#39;)plt.plot(x, y)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A69/11.png" alt="11"></p><h2 id="【4x00】设置网格"><a href="#【4x00】设置网格" class="headerlink" title="【4x00】设置网格"></a><font color=#FF0000>【4x00】设置网格</font></h2><p><code>matplotlib.pyplot.grid()</code> 方法可以为图表设置网格显示。</p><p>基本语法：<code>matplotlib.pyplot.grid([b=None, which=&#39;major&#39;, axis=&#39;both&#39;, \*\*kwargs])</code></p><table><thead><tr><th>参数</th><th>属性</th></tr></thead><tbody><tr><td>b</td><td>bool 值，可选项，是否显示网格，值为 <code>None</code> 或 <code>True</code> 则显示，<code>False</code> 不显示</td></tr><tr><td>which</td><td>可选项，在主/次刻度显示网格线，<code>major</code>：主（大）刻度；<code>minor</code>：次（小）刻度；<code>both</code>：两者同时显示</td></tr><tr><td>axis</td><td>可选项，在横/竖轴显示网格线，<code>x</code>：x 轴；<code>y</code>：y 轴；<code>both</code>：两者同时显示</td></tr><tr><td>**kwargs</td><td>其他 <a href="https://matplotlib.org/api/_as_gen/matplotlib.lines.Line2D.html#matplotlib.lines.Line2D">Line2D</a> 属性，常见 <a href="https://matplotlib.org/api/_as_gen/matplotlib.lines.Line2D.html#matplotlib.lines.Line2D">Line2D</a> 属性见下表</td></tr></tbody></table><p>Line2D 属性用法：<code>grid(color=&#39;r&#39;, linestyle=&#39;-&#39;, linewidth=2)</code>，部分常见 <a href="https://matplotlib.org/api/_as_gen/matplotlib.lines.Line2D.html#matplotlib.lines.Line2D">Line2D</a> 属性如下：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>alpha</td><td>网格透明度，float 类型，取值范围：<code>[0, 1]</code>，默认为 1.0，即不透明</td></tr><tr><td>antialiased / aa</td><td>是否使用抗锯齿渲染，默认为 True</td></tr><tr><td>color / c</td><td>网格颜色，支持英文颜色名称及其简写、十六进制颜色码等，更多颜色示例参见官网 <a href="https://matplotlib.org/gallery/color/color_demo.html">Color Demo</a></td></tr><tr><td>linestyle / ls</td><td>网格线条样式：<code>&#39;-&#39;</code> or <code>&#39;solid&#39;</code>, <code>&#39;--&#39;</code> or <code>&#39;dashed&#39;</code>, <code>&#39;-.&#39;</code> or <code>&#39;dashdot&#39;</code> <br> <code>&#39;:&#39;</code> or <code>&#39;dotted&#39;</code>, <code>&#39;none&#39;</code> or <code>&#39; &#39;</code> or <code>&#39;&#39;</code></td></tr><tr><td>linewidth / lw</td><td>网格线条宽度，float 类型，默认 0.8</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]a = [-15, -10, -5, 20, 25, 30]b = [-5, -4, -3, 6, 7, 8]plt.title(&#39;这是中文标题&#39;)plt.xlabel(&#39;这是 x 轴标签&#39;)plt.ylabel(&#39;这是 y 轴标签&#39;)plt.grid(axis=&#39;x&#39;, color=&#39;red&#39;, linestyle=&#39;-.&#39;, linewidth=2)plt.plot(a, b)plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A69/12.png" alt="12"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105828049未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</title>
      <link href="/article/014/"/>
      <url>/article/014/</url>
      
        <content type="html"><![CDATA[<p>Matplotlib 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/014/">Python 数据分析三剑客之 Matplotlib（一）：初识 Matplotlib 与其 matplotibrc 配置文件</a></li><li><a href="https://www.itbob.cn/article/015/">Python 数据分析三剑客之 Matplotlib（二）：文本描述 / 中文支持 / 画布 / 网格等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/016/">Python 数据分析三剑客之 Matplotlib（三）：图例 / LaTeX / 刻度 / 子图 / 补丁等基本图像属性</a></li><li><a href="https://www.itbob.cn/article/017/">Python 数据分析三剑客之 Matplotlib（四）：线性图的绘制</a></li><li><a href="https://www.itbob.cn/article/018/">Python 数据分析三剑客之 Matplotlib（五）：散点图的绘制</a></li><li><a href="https://www.itbob.cn/article/019/">Python 数据分析三剑客之 Matplotlib（六）：直方图 / 柱状图 / 条形图的绘制</a></li><li><a href="https://www.itbob.cn/article/020/">Python 数据分析三剑客之 Matplotlib（七）：饼状图的绘制</a></li><li><a href="https://www.itbob.cn/article/021/">Python 数据分析三剑客之 Matplotlib（八）：等高线 / 等值线图的绘制</a></li><li><a href="https://www.itbob.cn/article/022/">Python 数据分析三剑客之 Matplotlib（九）：极区图 / 极坐标图 / 雷达图的绘制</a></li><li><a href="https://www.itbob.cn/article/023/">Python 数据分析三剑客之 Matplotlib（十）：3D 图的绘制</a></li><li><a href="https://www.itbob.cn/article/024/">Python 数据分析三剑客之 Matplotlib（十一）：最热门最常用的 50 个图表</a>【译文】</li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105638122未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】认识-Matplotlib"><a href="#【1x00】认识-Matplotlib" class="headerlink" title="【1x00】认识 Matplotlib"></a><font color=#FF0000>【1x00】认识 Matplotlib</font></h2><p>Matplotlib 是建立在 NumPy 数组基础上的多平台数据可视化程序库，用于在 Python 中绘制数组的 2D 图形库，最初被设计用于完善 SciPy 的生态环境，虽然它起源于模仿 Matlab 图形命令，但它独立于 Matlab，可以以 Pythonic 和面向对象的方式使用。虽然 Matplotlib 主要是在纯 Python 中编写的，但它大量使用 NumPy 和其他扩展代码，即使对于大型数组也能提供良好的性能。它与 NumPy 一起使用，提供了一种有效的 Matlab 开源替代方案。 它也可以和图形工具包一起使用，如 PyQt 和 wxPython。Matplotlib 最重要的特性之一就是具有良好的操作系统兼容性和图形显示底层接口兼容性。</p><h3 id="【1x01】简单示例"><a href="#【1x01】简单示例" class="headerlink" title="【1x01】简单示例"></a><font color=#1BC3FB>【1x01】简单示例</font></h3><pre><code class="python">&gt;&gt;&gt; import matplotlib.pyplot as plt&gt;&gt;&gt; x = range(2, 26, 2)     # 数据在 x 轴的位置，是一个可迭代对象&gt;&gt;&gt; y = range(0, 12)        # 数据在 y 轴的位置，是一个可迭代对象&gt;&gt;&gt; plt.plot(x, y)          # 绘制线形图[&lt;matplotlib.lines.Line2D object at 0x00BA1D18&gt;]&gt;&gt;&gt; plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A68/01.png" alt="01"></p><h3 id="【1x02】图像结构"><a href="#【1x02】图像结构" class="headerlink" title="【1x02】图像结构"></a><font color=#1BC3FB>【1x02】图像结构</font></h3><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A68/02.png" alt="02"></p><h3 id="【1x03】三层结构"><a href="#【1x03】三层结构" class="headerlink" title="【1x03】三层结构"></a><font color=#1BC3FB>【1x03】三层结构</font></h3><p>Matplotlib 三层结构：容器层、辅助显示层、图像层</p><table><tr><td bgcolor=#7FFFD4>容器层</td></tr></table><p>容器层主要由 Canvas、Figure、Axes 组成。</p><ul><li>Canvas 是位于最底层的系统层，在绘图的过程中充当画板的角色，即放置画布（Figure）的工具。</li><li>Figure 是 Canvas 上方的第一层，也是需要用户来操作的应用层的第一层，在绘图的过程中充当画布的角色，可以通过 plt.figure() 设置画布的大小和分辨率等</li><li>Axes 是应用层的第二层，在绘图的过程中相当于画布上的绘图区的角色，注意与 Axis 的区别，Axis 是坐标轴，包含大小限制、刻度和刻度标签。</li></ul><p>注意点：</p><ul><li> 一个figure（画布）可以包含多个axes（坐标系/绘图区），但是一个 axes 只能属于一个figure。</li><li>一个axes（坐标系/绘图区）可以包含多个axis（坐标轴），包含两个即为 2d 坐标系，三个即为 3d 坐标系 。</li></ul><table><tr><td bgcolor=#7FFFD4>辅助显示层</td></tr></table><p>辅助显示层为 Axes（绘图区）内的除了根据数据绘制出的图像以外的内容，主要包括 Axes 外观（facecolor）、边框线(spines）、坐标轴（axis）、坐标轴名称（axis label）、坐标轴刻度（tick）、坐标轴刻度标签（tick label）、网格线（grid）、图例（legend）、标题（title）等内容。该层的设置可使图像显示更加直观更加容易被用户理解，但又不会对图像产生实质的影响。</p><table><tr><td bgcolor=#7FFFD4>图像层</td></tr></table><p>图像层指 Axes 内通过 plot（线形图）、scatter（散点图）、bar（柱状图）、histogram（直方图）、pie（饼图） 等函数根据数据绘制出的图像。</p><table><tr><td bgcolor=#7FFFD4>三者关系总结</td></tr></table><ul><li>Canvas（画板）位于最底层，用户一般接触不到；</li><li>Figure（画布）建立在 Canvas 之上；</li><li>Axes（绘图区）建立在Figure之上；</li><li>坐标轴（axis）、图例（legend）等辅助显示层以及图像层都是建立在 Axes 之上。</li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105638122未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【2x00】了解-matplotlib-rcParams"><a href="#【2x00】了解-matplotlib-rcParams" class="headerlink" title="【2x00】了解 matplotlib.rcParams"></a><font color=#FF0000>【2x00】了解 matplotlib.rcParams</font></h2><p><code>matplotlib</code> 使用 <code>matplotlibrc</code> 配置文件来自定义图形的各种默认属性，称之为 <code>rc</code> 配置或 <code>rc</code> 参数。通过 <code>rc</code> 参数可以修改默认的属性，包括窗体大小、每英寸的点数、线条宽度、颜色、样式、坐标轴、坐标和网络属性、文本、字体等。<code>rc</code> 参数存储在字典变量中，通过字典的方式进行访问。</p><p>执行 <code>matplotlib.rcParams.keys()</code> 命令可以查看所有的 rc 参数及其默认值；<br>执行 <code>matplotlib.matplotlib_fname()</code> 命令可以查看 <code>matplotlibrc</code> 配置文件在本地的路径。</p><p>官网介绍：<a href="https://matplotlib.org/tutorials/introductory/customizing.html">https://matplotlib.org/tutorials/introductory/customizing.html</a></p><p>配置文件 matplotibrc 主要包括以下配置要素：</p><ul><li><font color=#FF0000><strong>axes</strong></font>：坐标轴的背景颜色、坐标轴的边缘颜色、刻度线的大小、刻度标签的字体大小等；</li><li><font color=#FF0000><strong>figure</strong></font>：画布标题大小、画布标题粗细、画布像素（dpi）、 画布背景颜色和边缘颜色等；</li><li><font color=#FF0000><strong>font</strong></font>：字体类别、字体风格、字体粗细和字体大小等；</li><li><font color=#FF0000><strong>grid</strong></font>：网格颜色、网格线条风格、网格线条宽度和网格透明度；</li><li><font color=#FF0000><strong>legend</strong></font>：图例的文本大小、阴影、图例线框风格等；</li><li><font color=#FF0000><strong>lines</strong></font>：设置线条属性，包括颜色、线条风格、线条宽度和标记风格等；</li><li><font color=#FF0000><strong>patch</strong></font>：填充 2D 空间的图形对象，包括多边形和圆；</li><li><font color=#FF0000><strong>savefig</strong></font>：保存画布图像的分辨率、背景颜色和边缘颜色等；</li><li><font color=#FF0000><strong>text</strong></font>：文本颜色、LaTex 渲染文本等；</li><li><font color=#FF0000><strong>xtick / ytick</strong></font>：x 轴和 y 轴的主次要刻度线的大小、宽度、刻度线颜色和刻度标签大小等。</li></ul><hr><p><font color=#FF0000><strong>我们可以在 Python 项目中动态设置 <code>rc</code> 参数，所有 <code>rc</code> 参数设置都存储在名为 <code>matplotlib.rcParams</code> 的类似于字典的变量中，该变量对于 Matplotlib 软件包是全局的。<code>rcParams</code> 可以直接修改。通过这种方法的修改会对全局产生影响，在 Matplotlib 的其他方法中也可以单独对某个参数进行修改，后续介绍不同方法时会见到。</strong></font></p><hr><p><code>rcParams</code> 修改示例：</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]   # 定义全局字体plt.rcParams[&#39;xtick.color&#39;] = &#39;red&#39;         # 定义 x 轴刻度颜色plt.rcParams[&#39;lines.marker&#39;] = &#39;o&#39;          # 定义线条上点的形状plt.rcParams[&#39;legend.loc&#39;] = &#39;upper left&#39;   # 定义图例在左上角x = range(2, 26, 2)y = range(0, 12)a = [5, 10, 15, 20, 25, 30]b = [3, 4, 5, 6, 7, 8]plt.title(&#39;This is a title / 这是标题&#39;)plt.xlabel(&#39;这是 x 轴标题&#39;)plt.ylabel(&#39;这是 y 轴标题&#39;)plt.grid(True)plt.plot(x, y)plt.plot(a, b)plt.legend([&#39;图例一&#39;, &#39;图例二&#39;])plt.show()</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A68/03.png" alt="03"></p><hr><h3 id="【2x01】axes-部分属性"><a href="#【2x01】axes-部分属性" class="headerlink" title="【2x01】axes 部分属性"></a><font color=#1BC3FB>【2x01】axes 部分属性</font></h3><table><thead><tr><th>属性及其默认值</th><th>描述</th><th>其他取值</th></tr></thead><tbody><tr><td>mpl.rcParams[‘<code>axes.axisbelow</code>‘] = ‘line’</td><td>网格线和刻度的位置</td><td><code>line</code>：在画板上方，在线条下方<br><code>False</code>：在线条和画板的上方<br><code>True</code>：在画板下方</td></tr><tr><td>mpl.rcParams[‘<code>axes.edgecolor</code>‘] = ‘black’</td><td>轴边缘颜色</td><td>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>mpl.rcParams[‘<code>axes.facecolor</code>‘] = ‘white’</td><td>轴背景色</td><td>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>mpl.rcParams[‘<code>axes.labelcolor</code>‘] = ‘black’</td><td>轴标题颜色</td><td>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>mpl.rcParams[‘<code>axes.grid</code>‘] = False</td><td>是否显示网格</td><td><code>False</code>：不显示网格；<code>True</code>：显示网格</td></tr><tr><td>mpl.rcParams[‘<code>axes.grid.axis</code>‘] = ‘both’</td><td>网格应用于哪个轴</td><td><code>x</code>：x 轴；<code>y</code>：y 轴；<code>both</code>：同时应用于两个轴</td></tr><tr><td>mpl.rcParams[‘<code>axes.grid.which</code>‘] = ‘major’</td><td>网格应用于哪个刻度</td><td><code>major</code>：主（大）刻度；<code>minor</code>：次（小刻度）；<br><code>both</code>：同时应用于两个刻度</td></tr><tr><td>mpl.rcParams[‘<code>axes.labelpad</code>‘] = 4.0</td><td>轴标题和轴之间的间距</td><td>float 类型间距值</td></tr><tr><td>mpl.rcParams[‘<code>axes.labelsize</code>‘] = ‘medium’</td><td>x 轴和 y 轴标题的字体大小</td><td><code>xx-small</code>, <code>x-small</code>, <code>small</code>, <code>medium</code> <br> <code>large</code>, <code>x-large</code>, <code>xx-large</code>, <code>smaller</code>, <code>larger</code><br>也可以使用数字来表示字体大小</td></tr><tr><td>mpl.rcParams[‘<code>axes.labelweight</code>‘] = ‘normal’</td><td>x 轴和 y 轴标题的字体粗细</td><td><code>normal</code>：正常粗细；<code>bold</code>：粗体；<code>light</code>：细体<br>数字值 <code>400</code> 等价于 <code>normal</code>，<code>700</code> 等价于 <code>bold</code></td></tr><tr><td>mpl.rcParams[‘<code>axes.linewidth</code>‘] = 0.8</td><td>轴边线宽度</td><td>float 类型宽度值</td></tr><tr><td>mpl.rcParams[‘<code>axes.titlecolor</code>‘] = ‘auto’</td><td>图表标题颜色</td><td>默认取 <code>text.color</code> 的值<br>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>mpl.rcParams[‘<code>axes.titlelocation</code>‘] = ‘center’</td><td>图表标题位置</td><td><code>left</code>：左；<code>right</code>：右；<code>center</code>：中间</td></tr><tr><td>mpl.rcParams[‘<code>axes.titlepad</code>‘] = 6.0</td><td>图表标题和轴之间的间距</td><td>float 类型间距值</td></tr><tr><td>mpl.rcParams[‘<code>axes.titlesize</code>‘] = ‘large’</td><td>图表标题字体大小</td><td><code>xx-small</code>, <code>x-small</code>, <code>small</code>, <code>medium</code> <br> <code>large</code>, <code>x-large</code>, <code>xx-large</code>, <code>smaller</code>, <code>larger</code><br>也可以使用数字来表示字体大小</td></tr><tr><td>mpl.rcParams[‘<code>axes.titleweight</code>‘] = ‘normal’</td><td>图表标题字体粗细</td><td><code>normal</code>：正常粗细；<code>bold</code>：粗体；<code>light</code>：细体<br>数字值 <code>400</code> 等价于 <code>normal</code>，<code>700</code> 等价于 <code>bold</code></td></tr><tr><td>mpl.rcParams[‘<code>axes.xmargin</code>‘] = 0.05</td><td>x 轴边距</td><td>取值范围 <code>[0, 1]</code></td></tr><tr><td>mpl.rcParams[‘<code>axes.ymargin</code>‘] = 0.05</td><td>y 轴边距</td><td>取值范围 <code>[0, 1]</code></td></tr><tr><td>mpl.rcParams[‘<code>axes.unicode_minus</code>‘] = True</td><td>对负号使用 Unicode 而不是连字符</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>axes3d.grid</code>‘] = True</td><td>是否在三维轴上显示网格</td><td><code>True</code>：是；<code>False</code>：否</td></tr></tbody></table><h3 id="【2x02】figure-部分属性"><a href="#【2x02】figure-部分属性" class="headerlink" title="【2x02】figure 部分属性"></a><font color=#1BC3FB>【2x02】figure 部分属性</font></h3><table><thead><tr><th>属性及其默认值</th><th>描述</th><th>其他取值</th></tr></thead><tbody><tr><td>mpl.rcParams[‘<code>figure.dpi</code>‘] = 100</td><td>画布像素（dpi）</td><td>float 类型像素值</td></tr><tr><td>mpl.rcParams[‘<code>figure.edgecolor</code>‘] = ‘white’</td><td>画布边缘颜色</td><td>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>mpl.rcParams[‘<code>figure.facecolor</code>‘] = ‘white’</td><td>画布背景颜色</td><td>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>mpl.rcParams[‘<code>figure.figsize</code>‘] = [6.4, 4.8]</td><td>画布尺寸 <code>[长, 宽]</code></td><td>float 类型尺寸值（英寸）</td></tr><tr><td>mpl.rcParams[‘<code>figure.frameon</code>‘] = True</td><td>是否启用图框</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>figure.titlesize</code>‘] = ‘large’</td><td>画布标题大小</td><td><code>xx-small</code>, <code>x-small</code>, <code>small</code>, <code>medium</code> <br> <code>large</code>, <code>x-large</code>, <code>xx-large</code>, <code>smaller</code>, <code>larger</code><br>也可以使用数字来表示字体大小</td></tr><tr><td>mpl.rcParams[‘<code>figure.titleweight</code>‘] = ‘normal’</td><td>画布标题粗细</td><td><code>normal</code>：正常粗细；<code>bold</code>：粗体；<code>light</code>：细体<br>数字值 <code>400</code> 等价于 <code>normal</code>，<code>700</code> 等价于 <code>bold</code></td></tr></tbody></table><h3 id="【2x03】font-部分属性"><a href="#【2x03】font-部分属性" class="headerlink" title="【2x03】font 部分属性"></a><font color=#1BC3FB>【2x03】font 部分属性</font></h3><table><thead><tr><th>属性及其默认值</th><th>描述</th><th>其他取值</th></tr></thead><tbody><tr><td>mpl.rcParams[‘<code>font.family</code>‘] = [‘sans-serif’]</td><td>规定字体系列</td><td>字体名称</td></tr><tr><td>mpl.rcParams[‘<code>font.sans-serif</code>‘] = [‘DejaVu Sans, ……’]</td><td>定义无衬线字体</td><td>默认是一些西文字体，可将其设置成其他字体来显示中文</td></tr><tr><td>mpl.rcParams[‘<code>font.serif</code>‘] = [‘DejaVu Sans, ……’]</td><td>定义有衬线字体</td><td>默认是一些西文字体，可将其设置成其他字体来显示中文</td></tr><tr><td>mpl.rcParams[‘<code>font.size</code>‘] = 10.0</td><td>定义字体大小</td><td>float 数字类型字体大小</td></tr><tr><td>mpl.rcParams[‘<code>font.weight</code>‘] = ‘normal’</td><td>定义字体粗细</td><td><code>normal</code>：正常粗细；<code>bold</code>：粗体；<code>light</code>：细体<br>数字值 <code>400</code> 等价于 <code>normal</code>，<code>700</code> 等价于 <code>bold</code></td></tr></tbody></table><h3 id="【2x04】grid-部分属性"><a href="#【2x04】grid-部分属性" class="headerlink" title="【2x04】grid 部分属性"></a><font color=#1BC3FB>【2x04】grid 部分属性</font></h3><table><thead><tr><th>属性及其默认值</th><th>描述</th><th>其他取值</th></tr></thead><tbody><tr><td>mpl.rcParams[‘<code>grid.alpha</code>‘] = 1.0</td><td>网格透明度</td><td>float 类型，取值范围：<code>[0, 1]</code></td></tr><tr><td>mpl.rcParams[‘<code>grid.color</code>‘] = ‘#b0b0b0’</td><td>网格颜色</td><td>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>mpl.rcParams[‘<code>grid.linestyle</code>‘] = ‘-‘</td><td>网格线的样式</td><td><code>&#39;-&#39;</code> or <code>&#39;solid&#39;</code>, <code>&#39;--&#39;</code> or <code>&#39;dashed&#39;</code>, <code>&#39;-.&#39;</code> or <code>&#39;dashdot&#39;</code> <br> <code>&#39;:&#39;</code> or <code>&#39;dotted&#39;</code>, <code>&#39;none&#39;</code> or <code>&#39; &#39;</code> or <code>&#39;&#39;</code></td></tr><tr><td>mpl.rcParams[‘<code>grid.linewidth</code>‘] = 0.8</td><td>网格宽度</td><td>float 类型宽度值</td></tr></tbody></table><h3 id="【2x05】legend-部分属性"><a href="#【2x05】legend-部分属性" class="headerlink" title="【2x05】legend 部分属性"></a><font color=#1BC3FB>【2x05】legend 部分属性</font></h3><table><thead><tr><th>属性及其默认值</th><th>描述</th><th>其他取值</th></tr></thead><tbody><tr><td>mpl.rcParams[‘<code>legend.borderaxespad</code>‘] = 0.5</td><td>图例距离轴之间的距离</td><td>float 类型距离值</td></tr><tr><td>mpl.rcParams[‘<code>legend.borderpad</code>‘] = 0.4</td><td>图例边框空白区域大小</td><td>float 类型大小值</td></tr><tr><td>mpl.rcParams[‘<code>legend.columnspacing</code>‘] = 2.0</td><td>图例列间距</td><td>float 类型距离值</td></tr><tr><td>mpl.rcParams[‘<code>legend.edgecolor</code>‘] = 0.8</td><td>图例边缘线颜色</td><td>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>mpl.rcParams[‘<code>legend.facecolor</code>‘] = ‘inherit’</td><td>图例背景颜色</td><td>默认继承自 <code>axes.facecolor</code><br>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>mpl.rcParams[‘<code>legend.fancybox</code>‘] = True</td><td>是否使用圆形框作为图例背景</td><td><code>True</code>：使用圆形框；<code>False</code>：使用矩形框</td></tr><tr><td>mpl.rcParams[‘<code>legend.fontsize</code>‘] = ‘medium’</td><td>图例字体大小</td><td><code>xx-small</code>, <code>x-small</code>, <code>small</code>, <code>medium</code> <br> <code>large</code>, <code>x-large</code>, <code>xx-large</code>, <code>smaller</code>, <code>larger</code><br>也可以使用数字来表示字体大小</td></tr><tr><td>mpl.rcParams[‘<code>legend.framealpha</code>‘] = 0.8</td><td>图例透明度</td><td>float 类型，取值范围：<code>[0, 1]</code></td></tr><tr><td>mpl.rcParams[‘<code>legend.frameon</code>‘] = True</td><td>是否在画布之上绘制图例</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>legend.handleheight</code>‘] = 0.7</td><td>图例的高度</td><td>float 类型高度值</td></tr><tr><td>mpl.rcParams[‘<code>legend.handlelength</code>‘] = 2.0</td><td>图例的宽度</td><td>float 类型宽度值</td></tr><tr><td>mpl.rcParams[‘<code>legend.handletextpad</code>‘] = 0.8</td><td>图例和图例文本之间的水平距离</td><td>float 类型距离值</td></tr><tr><td>mpl.rcParams[‘<code>legend.labelspacing</code>‘] = 0.5</td><td>不同图例之间的垂直距离</td><td>float 类型距离值</td></tr><tr><td>mpl.rcParams[‘<code>legend.loc</code>‘] = ‘best’</td><td>图例在画布中的位置</td><td><code>best</code>, <code>upper right</code>, <code>upper left</code>, <code>lower left</code> <br> <code>lower right</code>, <code>right</code>, <code>center left</code>, <code>center right</code> <br> <code>lower center</code>, <code>upper center</code>, <code>center</code></td></tr><tr><td>mpl.rcParams[‘<code>legend.shadow</code>‘] = False</td><td>是否给图例添加阴影效果</td><td><code>True</code>：是；<code>False</code>：否</td></tr></tbody></table><h3 id="【2x06】lines-部分属性"><a href="#【2x06】lines-部分属性" class="headerlink" title="【2x06】lines 部分属性"></a><font color=#1BC3FB>【2x06】lines 部分属性</font></h3><table><thead><tr><th>属性及其默认值</th><th>描述</th><th>其他取值</th></tr></thead><tbody><tr><td>mpl.rcParams[‘<code>lines.antialiased</code>‘] = True</td><td>是否以抗锯齿方式渲染线条</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>lines.color</code>‘] = ‘C0’</td><td>线条颜色（对 <code>plot()</code> 没有影响）</td><td>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>mpl.rcParams[‘<code>lines.linestyle</code>‘] = ‘-‘</td><td>线条样式</td><td><code>&#39;-&#39;</code>, <code>&#39;--&#39;</code>, <code>&#39;-.&#39;</code>, <code>&#39;:&#39;</code>, <code>&#39;solid&#39;</code>, <code>&#39;dashed&#39;</code>, <br><code>&#39;dashdot&#39;</code>, <code>&#39;dotted&#39;</code>, <code>&#39;none&#39;</code>, <code>&#39; &#39;</code>, <code>&#39;&#39;</code></td></tr><tr><td>mpl.rcParams[‘<code>lines.linewidth</code>‘] = 1.5</td><td>线条宽度</td><td>float 类型宽度值</td></tr><tr><td>mpl.rcParams[‘<code>lines.marker</code>‘] = ‘None’</td><td>线条上点的形状</td><td><code>.</code>, <code>,</code>, <code>o</code>, <code>v</code>, <code>^</code> 等，具体常见 <a href="https://matplotlib.org/api/markers_api.html">matplotlib.markers</a></td></tr><tr><td>mpl.rcParams[‘<code>lines.markeredgecolor</code>‘] = ‘auto’</td><td>线条上点边缘的颜色</td><td>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>mpl.rcParams[‘<code>lines.markerfacecolor</code>‘] = ‘auto’</td><td>线条上点的颜色</td><td>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>mpl.rcParams[‘<code>lines.markeredgewidth</code>‘] = 1.0</td><td>线条上点的粗细</td><td>float 类型粗细值</td></tr><tr><td>mpl.rcParams[‘<code>lines.markersize</code>‘] = 6.0</td><td>线条上点的大小</td><td>float 类型大小值</td></tr></tbody></table><h3 id="【2x07】patch-部分属性"><a href="#【2x07】patch-部分属性" class="headerlink" title="【2x07】patch 部分属性"></a><font color=#1BC3FB>【2x07】patch 部分属性</font></h3><table><thead><tr><th>属性及其默认值</th><th>描述</th><th>其他取值</th></tr></thead><tbody><tr><td>mpl.rcParams[‘<code>patch.antialiased</code>‘] = True</td><td>以抗锯齿方式渲染补丁</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>patch.edgecolor</code>‘] = ‘black’</td><td>补丁边缘颜色</td><td>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>mpl.rcParams[‘<code>patch.facecolor</code>‘] = ‘C0’</td><td>补丁颜色</td><td>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>mpl.rcParams[‘<code>patch.linewidth</code>‘] = 1.0</td><td>补丁边缘宽度（以磅为单位）</td><td>float 类型宽度值</td></tr></tbody></table><h3 id="【2x08】savefig-部分属性"><a href="#【2x08】savefig-部分属性" class="headerlink" title="【2x08】savefig 部分属性"></a><font color=#1BC3FB>【2x08】savefig 部分属性</font></h3><table><thead><tr><th>属性及其默认值</th><th>描述</th><th>其他取值</th></tr></thead><tbody><tr><td>mpl.rcParams[‘<code>savefig.bbox</code>‘] = None</td><td>是否以紧凑形式保存图片</td><td><code>standard</code>：标准形式；<code>tight</code>：紧凑形式<br>（去掉边上多余的空白）</td></tr><tr><td>mpl.rcParams[‘<code>savefig.pad_inches</code>‘] = 0.1</td><td><code>savefig.bbox</code> 参数为 <code>tight</code> 时，<br>图片使用的填充值<br>（相当于 html 中的 Padding）</td><td>float 类型填充值</td></tr><tr><td>mpl.rcParams[‘<code>savefig.dpi</code>‘] = ‘figure’</td><td>保存图片的像素（dpi）</td><td>str 类型像素值</td></tr><tr><td>mpl.rcParams[‘<code>savefig.edgecolor</code>‘] = ‘white’</td><td>保存图片的边缘颜色</td><td>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>mpl.rcParams[‘<code>savefig.facecolor</code>‘] = ‘white’</td><td>保存图片的画布颜色</td><td>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>mpl.rcParams[‘<code>savefig.format</code>‘] = ‘png’</td><td>保存图片的格式</td><td><code>eps</code>, <code>pdf</code>, <code>pgf</code>, <code>png</code>, <code>ps</code>, <code>raw</code>, <code>rgba</code>, <code>svg</code>, <code>svgz</code></td></tr><tr><td>mpl.rcParams[‘<code>savefig.transparent</code>‘] = False</td><td>保存图片的背景是否透明</td><td><code>True</code>：是；<code>False</code>：否</td></tr></tbody></table><h3 id="【2x09】text-部分属性"><a href="#【2x09】text-部分属性" class="headerlink" title="【2x09】text 部分属性"></a><font color=#1BC3FB>【2x09】text 部分属性</font></h3><table><thead><tr><th>属性及其默认值</th><th>描述</th><th>其他取值</th></tr></thead><tbody><tr><td>mpl.rcParams[‘<code>text.antialiased</code>‘] = True</td><td>是否以抗锯齿方式渲染文本</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>text.color</code>‘] = ‘red’</td><td>文本颜色</td><td>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>mpl.rcParams[‘<code>text.usetex</code>‘] = False</td><td>是否使用 <a href="https://baike.baidu.com/item/LaTeX/1212106">LaTeX</a> 排版系统<br>（主要用于生成复杂表格和数学公式）</td><td><code>True</code>：是；<code>False</code>：否</td></tr></tbody></table><h3 id="【2x10】xtick-部分属性"><a href="#【2x10】xtick-部分属性" class="headerlink" title="【2x10】xtick 部分属性"></a><font color=#1BC3FB>【2x10】xtick 部分属性</font></h3><table><thead><tr><th>属性及其默认值</th><th>描述</th><th>其他取值</th></tr></thead><tbody><tr><td>mpl.rcParams[‘<code>xtick.color</code>‘] = ‘black’</td><td>x 轴刻度的颜色</td><td>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>mpl.rcParams[‘<code>xtick.direction</code>‘] = ‘out’</td><td>x 轴刻度的方向</td><td><code>in</code>：内部（x 轴上方）；<code>out</code>：外部（x 轴下方）<br><code>inout</code>：同时在内部和外部</td></tr><tr><td>mpl.rcParams[‘<code>xtick.bottom</code>‘] = True</td><td>是否在画布底部显示 x 轴刻度</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>xtick.top</code>‘] = False</td><td>是否在画布顶部显示 x 轴刻度</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>xtick.labelbottom</code>‘] = True</td><td>是否在画布底部显示 x 轴刻度文字标签</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>xtick.labeltop</code>‘] = False</td><td>是否在画布顶部显示 x 轴刻度文字标签</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>xtick.labelsize</code>‘] = ‘medium’</td><td>x 轴刻度文字大小</td><td><code>xx-small</code>, <code>x-small</code>, <code>small</code>, <code>medium</code> <br> <code>large</code>, <code>x-large</code>, <code>xx-large</code>, <code>smaller</code>, <code>larger</code><br>也可以使用数字来表示字体大小</td></tr><tr><td>mpl.rcParams[‘<code>xtick.major.bottom</code>‘] = True</td><td>是否在画布底部显示 x 轴主（大）刻度</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>xtick.major.top</code>‘] = True</td><td>是否在画布顶部显示 x 轴主（大）刻度</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>xtick.major.pad</code>‘] = 3.5</td><td>x 轴主（大）刻度与文字标签的距离</td><td>float 类型距离值</td></tr><tr><td>mpl.rcParams[‘<code>xtick.major.size</code>‘] = 3.5</td><td>x 轴主（大）刻度的大小</td><td>float 类型大小值</td></tr><tr><td>mpl.rcParams[‘<code>xtick.major.width</code>‘] = 0.8</td><td>x 轴主（大）刻度的宽度</td><td>float 类型宽度值</td></tr><tr><td>mpl.rcParams[‘<code>xtick.minor.bottom</code>‘] = True</td><td>是否在画布底部显示 x 轴次（小）刻度</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>xtick.minor.top</code>‘] = True</td><td>是否在画布顶部显示 x 轴次（小）刻度</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>xtick.minor.pad</code>‘] = 3.4</td><td>x 轴次（小）刻度与文字标签的距离</td><td>float 类型距离值</td></tr><tr><td>mpl.rcParams[‘<code>xtick.minor.size</code>‘] = 2.0</td><td>x 轴次（小）刻度的大小</td><td>float 类型大小值</td></tr><tr><td>mpl.rcParams[‘<code>xtick.minor.width</code>‘] = 0.6</td><td>x 轴次（小）刻度的宽度</td><td>float 类型宽度值</td></tr><tr><td>mpl.rcParams[‘<code>xtick.minor.visible</code>‘] = False</td><td>x 轴次（小）刻度的可见性</td><td><code>True</code>：是；<code>False</code>：否</td></tr></tbody></table><h3 id="【2x11】ytick-部分属性"><a href="#【2x11】ytick-部分属性" class="headerlink" title="【2x11】ytick 部分属性"></a><font color=#1BC3FB>【2x11】ytick 部分属性</font></h3><table><thead><tr><th>属性及其默认值</th><th>描述</th><th>其他取值</th></tr></thead><tbody><tr><td>mpl.rcParams[‘<code>ytick.color</code>‘] = ‘black’</td><td>y 轴刻度的颜色</td><td>其他颜色，支持英文颜色名称及其简写、十六进制颜色码等<br>更多颜色示例参见<a href="https://matplotlib.org/gallery/color/color_demo.html">官网 Color Demo</a></td></tr><tr><td>mpl.rcParams[‘<code>ytick.direction</code>‘] = ‘out’</td><td>y 轴刻度的方向</td><td><code>in</code>：内部（y 轴右方）；<code>out</code>：外部（y 轴左方）<br><code>inout</code>：同时在内部和外部</td></tr><tr><td>mpl.rcParams[‘<code>ytick.left</code>‘] = True</td><td>是否在画布左边显示 y 轴刻度</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>ytick.right</code>‘] = False</td><td>是否在画布右边显示 y 轴刻度</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>ytick.labelleft</code>‘] = True</td><td>是否在画布左边显示 y 轴刻度文字标签</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>ytick.labelright</code>‘] = False</td><td>是否在画布右边显示 y 轴刻度文字标签</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>ytick.labelsize</code>‘] = ‘medium’</td><td>y 轴刻度文字大小</td><td><code>xx-small</code>, <code>x-small</code>, <code>small</code>, <code>medium</code> <br> <code>large</code>, <code>x-large</code>, <code>xx-large</code>, <code>smaller</code>, <code>larger</code><br>也可以使用数字来表示字体大小</td></tr><tr><td>mpl.rcParams[‘<code>ytick.major.left</code>‘] = True</td><td>是否在画布左边显示 y 轴主（大）刻度</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>ytick.major.right</code>‘] = True</td><td>是否在画布右边显示 y 轴主（大）刻度</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>ytick.major.pad</code>‘] = 3.5</td><td>y 轴主（大）刻度与文字标签的距离</td><td>float 类型距离值</td></tr><tr><td>mpl.rcParams[‘<code>ytick.major.size</code>‘] = 3.5</td><td>y 轴主（大）刻度的大小</td><td>float 类型大小值</td></tr><tr><td>mpl.rcParams[‘<code>ytick.major.width</code>‘] = 0.8</td><td>y 轴主（大）刻度的宽度</td><td>float 类型宽度值</td></tr><tr><td>mpl.rcParams[‘<code>ytick.minor.left</code>‘] = True</td><td>是否在画布左边显示 y 轴次（小）刻度</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>ytick.minor.right</code>‘] = True</td><td>是否在画布右边显示 y 轴次（小）刻度</td><td><code>True</code>：是；<code>False</code>：否</td></tr><tr><td>mpl.rcParams[‘<code>ytick.minor.pad</code>‘] = 3.4</td><td>y 轴次（小）刻度与文字标签的距离</td><td>float 类型距离值</td></tr><tr><td>mpl.rcParams[‘<code>ytick.minor.size</code>‘] = 2.0</td><td>y 轴次（小）刻度的大小</td><td>float 类型大小值</td></tr><tr><td>mpl.rcParams[‘<code>ytick.minor.width</code>‘] = 0.6</td><td>y 轴次（小）刻度的宽度</td><td>float 类型宽度值</td></tr><tr><td>mpl.rcParams[‘<code>ytick.minor.visible</code>‘] = False</td><td>y 轴次（小）刻度的可见性</td><td><code>True</code>：是；<code>False</code>：否</td></tr></tbody></table><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105638122未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 NumPy（六）：矩阵 / 线性代数库与 IO 操作</title>
      <link href="/article/013/"/>
      <url>/article/013/</url>
      
        <content type="html"><![CDATA[<p>NumPy 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/008/">Python 数据分析三剑客之 NumPy（一）：理解 NumPy / 数组基础</a></li><li><a href="https://www.itbob.cn/article/009/">Python 数据分析三剑客之 NumPy（二）：数组索引 / 切片 / 广播 / 拼接 / 分割</a></li><li><a href="https://www.itbob.cn/article/010/">Python 数据分析三剑客之 NumPy（三）：数组的迭代与位运算</a></li><li><a href="https://www.itbob.cn/article/011/">Python 数据分析三剑客之 NumPy（四）：字符串函数总结与对比</a></li><li><a href="https://www.itbob.cn/article/012/">Python 数据分析三剑客之 NumPy（五）：数学 / 算术 / 统计 / 排序 / 条件 / 判断函数合集</a></li><li><a href="https://www.itbob.cn/article/013/">Python 数据分析三剑客之 NumPy（六）：矩阵 / 线性代数库与 IO 操作</a></li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105511641未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】NumPy-矩阵库"><a href="#【1x00】NumPy-矩阵库" class="headerlink" title="【1x00】NumPy 矩阵库"></a><font color=#FF0000>【1x00】NumPy 矩阵库</font></h2><p><code>numpy.matlib</code> 模块是 NumPy 的矩阵库，该矩阵库包含多种函数，函数返回的是一个矩阵，而不是 Ndarray 对象。</p><p>官方文档介绍：<a href="https://numpy.org/doc/1.18/reference/routines.matlib.html">https://numpy.org/doc/1.18/reference/routines.matlib.html</a></p><h3 id="【1x01】numpy-mat"><a href="#【1x01】numpy-mat" class="headerlink" title="【1x01】numpy.mat()"></a><font color=#1BC3FB>【1x01】numpy.mat()</font></h3><p><code>numpy.mat()</code> 函数将输入数组转换为为矩阵。</p><p>基本语法：<code>numpy.mat(data[, dtype=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>data</td><td>输入数据，如果 data 为字符串，则需要用逗号或空格分隔列，用分号分隔行</td></tr><tr><td>dtype</td><td>输出矩阵的数据类型，可选项</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.mat([1, 2, 3])&gt;&gt;&gt; amatrix([[1, 2, 3]])&gt;&gt;&gt; a[0]matrix([[1, 2, 3]])&gt;&gt;&gt; a[0,1]2</code></pre><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])&gt;&gt;&gt; aarray([[1, 2],       [3, 4]])&gt;&gt;&gt; b = np.mat(a)&gt;&gt;&gt; bmatrix([[1, 2],        [3, 4]])</code></pre><h3 id="【1x02】numpy-asmatrix"><a href="#【1x02】numpy-asmatrix" class="headerlink" title="【1x02】numpy.asmatrix()"></a><font color=#1BC3FB>【1x02】numpy.asmatrix()</font></h3><p><code>numpy.asmatrix()</code> 函数将输入数组转换为为矩阵。</p><p>基本语法：<code>numpy.asmatrix(data[, dtype=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>data</td><td>输入数据，如果 data 为字符串，则需要用逗号或空格分隔列，用分号分隔行</td></tr><tr><td>dtype</td><td>输出矩阵的数据类型，可选项</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])&gt;&gt;&gt; np.asmatrix(a)matrix([[1, 2],        [3, 4]])</code></pre><h3 id="【1x03】numpy-matrix"><a href="#【1x03】numpy-matrix" class="headerlink" title="【1x03】numpy.matrix()"></a><font color=#1BC3FB>【1x03】numpy.matrix()</font></h3><p><code>numpy.matrix()</code> 函数从类似数组的对象或数据字符串中返回一个矩阵。</p><p><font color=#FF0000><strong>注意：此函数已经不建议再使用，在未来的版本当中可能会被删除。</strong></font></p><p>基本语法：<code>class numpy.matrix(data[, dtype=None, copy=True])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>data</td><td>数组或者字符串，如果 data 为字符串，则需要用逗号或空格分隔列，用分号分隔行</td></tr><tr><td>dtype</td><td>输出矩阵的数据类型，可选项</td></tr><tr><td>copy</td><td>是否复制数据到一个新矩阵，可选项</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.matrix(&#39;1 2; 3 4&#39;)&gt;&gt;&gt; amatrix([[1, 2],        [3, 4]])&gt;&gt;&gt; &gt;&gt;&gt; b = np.matrix([[1, 2], [3, 4]])&gt;&gt;&gt; bmatrix([[1, 2],        [3, 4]])</code></pre><h3 id="【1x04】mat-asmatrix-matrix-的区别"><a href="#【1x04】mat-asmatrix-matrix-的区别" class="headerlink" title="【1x04】mat() / asmatrix() / matrix() 的区别"></a><font color=#1BC3FB>【1x04】mat() / asmatrix() / matrix() 的区别</font></h3><p>如果输入已经是一个矩阵或一个数组，则 <code>mat()</code> 和 <code>asmatrix()</code> 函数不会执行复制操作，相当于 <code>matrix(data, copy=False)</code></p><p>对比举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])&gt;&gt;&gt; b = np.mat(a)&gt;&gt;&gt; c = np.matrix(a)&gt;&gt;&gt; d = np.asmatrix(a)&gt;&gt;&gt; &gt;&gt;&gt; aarray([[1, 2],       [3, 4]])&gt;&gt;&gt; bmatrix([[1, 2],        [3, 4]])&gt;&gt;&gt; cmatrix([[1, 2],        [3, 4]])&gt;&gt;&gt; dmatrix([[1, 2],        [3, 4]])&gt;&gt;&gt; &gt;&gt;&gt; a[1][1] = 0&gt;&gt;&gt; &gt;&gt;&gt; aarray([[1, 2],       [3, 0]])&gt;&gt;&gt; bmatrix([[1, 2],        [3, 0]])&gt;&gt;&gt; c              # matrix() 函数默认执行 copy 操作，所以数据不变matrix([[1, 2],        [3, 4]])&gt;&gt;&gt; dmatrix([[1, 2],        [3, 0]])</code></pre><h3 id="【1x05】numpy-bmat"><a href="#【1x05】numpy-bmat" class="headerlink" title="【1x05】numpy.bmat()"></a><font color=#1BC3FB>【1x05】numpy.bmat()</font></h3><p><code>numpy.bmat()</code> 函数用于从字符串、嵌套序列或数组生成矩阵对象，一般用于创建复合矩阵。</p><p>基本语法：<code>numpy.bmat(obj[, ldict=None, gdict=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>obj</td><td>数组或者字符串，如果 data 为字符串，则需要用逗号或空格分隔列，用分号分隔行</td></tr><tr><td>ldict</td><td>字典，用于替换当前帧中的本地操作数。如果 obj 不是字符串或 gdict 为 None，则将被忽略</td></tr><tr><td>gdict</td><td>字典，用于替换当前帧中的全局操作数。如果 obj 不是字符串则忽略</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.mat(&#39;1 1; 1 1&#39;)&gt;&gt;&gt; b = np.mat(&#39;2 2; 2 2&#39;)&gt;&gt;&gt; c = np.mat(&#39;3 4; 5 6&#39;)&gt;&gt;&gt; d = np.mat(&#39;7 8; 9 0&#39;)&gt;&gt;&gt; &gt;&gt;&gt; np.bmat([[a, b], [c, d]])matrix([[1, 1, 2, 2],        [1, 1, 2, 2],        [3, 4, 7, 8],        [5, 6, 9, 0]])&gt;&gt;&gt; np.bmat(np.r_[np.c_[a, b], np.c_[c, d]])matrix([[1, 1, 2, 2],        [1, 1, 2, 2],        [3, 4, 7, 8],        [5, 6, 9, 0]])&gt;&gt;&gt; np.bmat(&#39;a,b; c,d&#39;)matrix([[1, 1, 2, 2],        [1, 1, 2, 2],        [3, 4, 7, 8],        [5, 6, 9, 0]])</code></pre><h3 id="【1x06】numpy-matlib-empty"><a href="#【1x06】numpy-matlib-empty" class="headerlink" title="【1x06】numpy.matlib.empty()"></a><font color=#1BC3FB>【1x06】numpy.matlib.empty()</font></h3><p><code>numpy.matlib.empty()</code> 函数用于创建一个给定形状和数据类型的新矩阵。</p><p>基本语法：<code>numpy.matlib.empty(shape[, dtype=None, order=&#39;C&#39;])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>shape</td><td>定义新矩阵的形状</td></tr><tr><td>dtype</td><td>数据类型，可选项</td></tr><tr><td>order</td><td>以行优先（C）或列优先（Fortran）的顺序存储多维数据在内存中，可选项</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.matlib.empty((2, 2)))[[9.90263869e+067 8.01304531e+262] [2.60799828e-310 0.00000000e+000]]&gt;&gt;&gt; print(np.matlib.empty((2, 2), dtype=int))[[ -793016358  -243407933] [ -959331519 -2060787213]]</code></pre><h3 id="【1x07】numpy-matlib-zeros"><a href="#【1x07】numpy-matlib-zeros" class="headerlink" title="【1x07】numpy.matlib.zeros()"></a><font color=#1BC3FB>【1x07】numpy.matlib.zeros()</font></h3><p><code>numpy.matlib.zeros()</code> 函数创建一个以 0 填充的给定形状和类数据型的矩阵。</p><p>基本语法：<code>numpy.matlib.zeros(shape[, dtype=None, order=&#39;C&#39;])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>shape</td><td>定义新矩阵的形状</td></tr><tr><td>dtype</td><td>数据类型，可选项</td></tr><tr><td>order</td><td>以行优先（C）或列优先（Fortran）的顺序存储多维数据在内存中，可选项</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.matlib.zeros((2, 3))matrix([[0., 0., 0.],        [0., 0., 0.]])</code></pre><h3 id="【1x08】numpy-matlib-ones"><a href="#【1x08】numpy-matlib-ones" class="headerlink" title="【1x08】numpy.matlib.ones()"></a><font color=#1BC3FB>【1x08】numpy.matlib.ones()</font></h3><p><code>numpy.matlib.ones()</code> 函数创建一个以 1 填充的给定形状和类数据型的矩阵。</p><p>基本语法：<code>numpy.matlib.ones(shape[, dtype=None, order=&#39;C&#39;])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>shape</td><td>定义新矩阵的形状</td></tr><tr><td>dtype</td><td>数据类型，可选项</td></tr><tr><td>order</td><td>以行优先（C）或列优先（Fortran）的顺序存储多维数据在内存中，可选项</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.matlib.ones((2, 3))matrix([[1., 1., 1.],        [1., 1., 1.]])</code></pre><h3 id="【1x09】numpy-matlib-eye"><a href="#【1x09】numpy-matlib-eye" class="headerlink" title="【1x09】numpy.matlib.eye()"></a><font color=#1BC3FB>【1x09】numpy.matlib.eye()</font></h3><p><code>numpy.matlib.eye()</code> 函数创建一个对角线元素为 1，其他位置为零的矩阵。</p><p>基本语法：<code>numpy.matlib.eye(n[, M=None, k=0, dtype=&lt;class &#39;float&#39;&gt;, order=&#39;C&#39;])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>n</td><td>返回的矩阵的行数，int 类型</td></tr><tr><td>M</td><td>返回的矩阵的列数，int 类型，可选项，默认为 n</td></tr><tr><td>k</td><td>对角线索引，可选项，0 表示主对角线，正值表示上对角线，负值表示下对角线，该对角线上元素的值将会是 1</td></tr><tr><td>dtype</td><td>返回矩阵的数据类型，可选项</td></tr><tr><td>order</td><td>以行优先（C）或列优先（Fortran）的顺序存储多维数据在内存中，可选项</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.matlib.eye(n=3, k=1))[[0. 1. 0.] [0. 0. 1.] [0. 0. 0.]]&gt;&gt;&gt; print(np.matlib.eye(n=3, k=-1))[[0. 0. 0.] [1. 0. 0.] [0. 1. 0.]]&gt;&gt;&gt; print(np.matlib.eye(n=3, M=4, k=0, dtype=int))[[1 0 0 0] [0 1 0 0] [0 0 1 0]]</code></pre><h3 id="【1x10】numpy-matlib-identity"><a href="#【1x10】numpy-matlib-identity" class="headerlink" title="【1x10】numpy.matlib.identity()"></a><font color=#1BC3FB>【1x10】numpy.matlib.identity()</font></h3><p><code>numpy.matlib.identity()</code> 函数创建一个给定大小的单位矩阵。</p><p>单位矩阵：在矩阵的乘法中，有一种矩阵起着特殊的作用，如同数的乘法中的1，这种矩阵被称为单位矩阵。它是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为1。除此以外全都为0。</p><p>基本语法：<code>numpy.matlib.identity(n[, dtype=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>n</td><td>返回的单位矩阵的大小，int 类型</td></tr><tr><td>dtype</td><td>可选项，返回的单位矩阵的数据类型</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.matlib.identity(3, dtype=int))[[1 0 0] [0 1 0] [0 0 1]]</code></pre><h3 id="【1x11】numpy-matlib-repmat"><a href="#【1x11】numpy-matlib-repmat" class="headerlink" title="【1x11】numpy.matlib.repmat()"></a><font color=#1BC3FB>【1x11】numpy.matlib.repmat()</font></h3><p><code>numpy.matlib.repmat()</code> 函数用于重复数组或矩阵 m*n 次。</p><p>基本语法：<code>numpy.matlib.repmat(a, m, n)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>待处理的数组对象</td></tr><tr><td>m,n</td><td>沿第一轴和第二轴重复的次数</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array(1)&gt;&gt;&gt; b = np.arange(4)&gt;&gt;&gt; aarray(1)&gt;&gt;&gt; barray([0, 1, 2, 3])&gt;&gt;&gt; &gt;&gt;&gt; print(np.matlib.repmat(a, 2, 3))[[1 1 1] [1 1 1]]&gt;&gt;&gt; print(np.matlib.repmat(b, 2, 2))[[0 1 2 3 0 1 2 3] [0 1 2 3 0 1 2 3]]</code></pre><h3 id="【1x12】numpy-matlib-rand"><a href="#【1x12】numpy-matlib-rand" class="headerlink" title="【1x12】numpy.matlib.rand()"></a><font color=#1BC3FB>【1x12】numpy.matlib.rand()</font></h3><p><code>numpy.matlib.rand()</code> 函数创建一个给定大小的矩阵，其中的数据在 <code>[0, 1)</code> 区间随机取值来填充。</p><p>基本语法：<code>numpy.matlib.rand(*args)</code></p><p>参数解释：<code>*args</code>：输出矩阵的形状，如果给定为 N 个整数，则每个整数指定一维的大小，如果以元组形式给出，则该元组表示输出矩阵完整的形状。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.matlib.rand(2, 3))[[0.27957871 0.48748368 0.0970184 ] [0.71062224 0.92503824 0.72415015]]&gt;&gt;&gt;&gt;&gt;&gt; print(np.matlib.rand((2, 3)))[[0.08814715 0.0307317  0.77775332] [0.81158748 0.09173265 0.77497881]]&gt;&gt;&gt;&gt;&gt;&gt; print(np.matlib.rand(2, 3), 4)     # 如果第一个参数是元组，则其他参数将被忽略[[0.53407924 0.56006372 0.63903716] [0.56132381 0.90300814 0.44074964]] 4</code></pre><h3 id="【1x13】numpy-matlib-randn"><a href="#【1x13】numpy-matlib-randn" class="headerlink" title="【1x13】numpy.matlib.randn()"></a><font color=#1BC3FB>【1x13】numpy.matlib.randn()</font></h3><p><code>numpy.matlib.randn()</code> 函数创建一个标准正态分布的随机矩阵。</p><p>标准正态分布，是一个在数学、物理及工程等领域都非常重要的概率分布，在统计学的许多方面有着重大的影响力。期望值<code>μ=0</code>，即曲线图象对称轴为Y轴，标准差 <code>σ=1</code> 条件下的正态分布，记为 <code>N（0，1）</code>。</p><p>标准正态分布又称为 u 分布，是以 0 为均数、以 1 为标准差的正态分布，记为 <code>N（0，1）</code></p><p>基本语法：<code>numpy.matlib.randn(*args)</code></p><p>参数解释：<code>*args</code>：输出矩阵的形状，如果给定为 N 个整数，则每个整数指定一维的大小，如果以元组形式给出，则该元组表示输出矩阵完整的形状。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.matlib.randn(2, 3))[[ 0.82976978 -0.9798698   0.71262414] [ 2.31211127 -0.5090537   1.12357032]]&gt;&gt;&gt; &gt;&gt;&gt; print(2.5 * np.matlib.randn((2, 4)) + 3)         # 2 x 4 矩阵 N(3, 6.25)[[-0.66974538  4.9354863   2.46138048  7.05576713] [ 0.80688217  1.79017491  3.78979646 -1.99071372]]</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105511641未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【2x00】NumPy-线性代数库"><a href="#【2x00】NumPy-线性代数库" class="headerlink" title="【2x00】NumPy 线性代数库"></a><font color=#FF0000>【2x00】NumPy 线性代数库</font></h2><p>线性代数是数学的一个分支，它的研究对象是向量，向量空间（或称线性空间），线性变换和有限维的线性方程组。NumPy 中也提供了线性代数函数库 <code>numpy.linalg</code>。</p><p>官方文档介绍：<a href="https://numpy.org/doc/1.18/reference/routines.linalg.html">https://numpy.org/doc/1.18/reference/routines.linalg.html</a></p><h3 id="【2x01】numpy-dot"><a href="#【2x01】numpy-dot" class="headerlink" title="【2x01】numpy.dot()"></a><font color=#1BC3FB>【2x01】numpy.dot()</font></h3><p><code>numpy.dot()</code> 函数用于计算两个数组的点积。</p><p>基本语法：<code>numpy.dot(a, b[, out=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>第一个数组</td></tr><tr><td>b</td><td>第二个数组</td></tr><tr><td>out</td><td>可选项，放置结果的备用输出数组</td></tr></tbody></table><ul><li>如果 a 和 b 均为一维数组，计算的是这两个数组对应下标元素的乘积和（数学上称之为内积）；</li><li>如果 a 和 b 均为二维数组，计算的是两个数组的矩阵乘积；</li><li>如果 a 和 b 均为多维数组，它的通用计算公式为：<code>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</code>，即结果数组中的每个元素都是数组 a 的最后一维上的所有元素与数组 b 的倒数第二维上的所有元素的乘积和。</li></ul><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1,2],[3,4]])&gt;&gt;&gt; b = np.array([[11,12],[13,14]])&gt;&gt;&gt; print(np.dot(a,b))     # [[1*11+2*13, 1*12+2*14],[3*11+4*13, 3*12+4*14]][[37 40] [85 92]]&gt;&gt;&gt; &gt;&gt;&gt; c = np.arange(3*4*5*6).reshape((3,4,5,6))&gt;&gt;&gt; d = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))&gt;&gt;&gt; print(np.dot(c, d)[2,3,2,1,2,2])499128&gt;&gt;&gt; print(sum(c[2,3,2,:] * d[1,2,:,2]))499128</code></pre><h3 id="【2x02】numpy-vdot"><a href="#【2x02】numpy-vdot" class="headerlink" title="【2x02】numpy.vdot()"></a><font color=#1BC3FB>【2x02】numpy.vdot()</font></h3><p><code>numpy.vdot()</code> 函数返回两个向量的点积，如果第一个参数是复数，那么它的共轭复数会用于计算。 如果参数是多维数组，它会被展开。</p><p>共轭复数：两个实部相等，虚部互为相反数的复数互为共轭复数。</p><p>基本语法：<code>numpy.vdot(a, b)</code></p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1+2j, 3+4j])&gt;&gt;&gt; b = np.array([5+6j, 7+8j])&gt;&gt;&gt; print(np.vdot(a, b))       # a 的共轭复数用于计算：(1-2j) * (5+6j) + (3-4j) * (7+8j)(70-8j)&gt;&gt;&gt; print(np.vdot(b, a))       # b 的共轭复数用于计算：(1+2j) * (5-6j) + (3+4j) * (7-8j)(70+8j)&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; c = np.array([[1, 4], [5, 6]])&gt;&gt;&gt; d = np.array([[4, 1], [2, 2]])&gt;&gt;&gt; print(np.vdot(c, d))              # 1*4 + 4*1 + 5*2 + 6*230</code></pre><h3 id="【2x03】numpy-inner"><a href="#【2x03】numpy-inner" class="headerlink" title="【2x03】numpy.inner()"></a><font color=#1BC3FB>【2x03】numpy.inner()</font></h3><p><code>numpy.inner()</code> 函数计算一维数组的点积，对于其他维度，返回最后一个轴上的和的乘积。</p><p>基本语法：<code>numpy.inner(a, b)</code></p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1,2],[3,4]])&gt;&gt;&gt; b = np.array([[11,12],[13,14]])&gt;&gt;&gt; print(np.inner(a,b))       # [[1*11+2*12, 1*13+2*14], [3*11+4*12, 3*13+4*14]][[35 41] [81 95]]&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; c = np.array([1,2,3])&gt;&gt;&gt; d = np.array([0,1,0])&gt;&gt;&gt; print(np.inner(c,d))      # 1*0+2*1+3*02</code></pre><h3 id="【2x04】numpy-outer"><a href="#【2x04】numpy-outer" class="headerlink" title="【2x04】numpy.outer()"></a><font color=#1BC3FB>【2x04】numpy.outer()</font></h3><p><code>numpy.outer()</code> 函数计算两个向量的外积。</p><p>基本语法：<code>numpy.outer(a, b[, out=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>第一个向量，如果不是一维的则在计算前会将其展平</td></tr><tr><td>b</td><td>第一个向量，如果不是一维的则在计算前会将其展平</td></tr><tr><td>out</td><td>结果存储的位置，可选项，类似于 (M, N) 结构的 Ndarray 对象</td></tr></tbody></table><p>外积一般指两个向量的向量积，若两向量：<code>a = [a0, a1, ..., aM]</code>  <code>b = [b0, b1, ..., bN]</code>，外积如下：</p><pre><code>[[a0*b0  a0*b1 ... a0*bN ] [a1*b0    . [ ...          . [aM*b0            aM*bN ]]</code></pre><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 2, 3, 4])&gt;&gt;&gt; b = np.array([5, 6, 7, 8])&gt;&gt;&gt; print(np.outer(a, b))[[ 5  6  7  8] [10 12 14 16] [15 18 21 24] [20 24 28 32]]&gt;&gt;&gt; &gt;&gt;&gt; c = np.array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=object)&gt;&gt;&gt; print(np.outer(c, [1, 2, 3]))[[&#39;a&#39; &#39;aa&#39; &#39;aaa&#39;] [&#39;b&#39; &#39;bb&#39; &#39;bbb&#39;] [&#39;c&#39; &#39;cc&#39; &#39;ccc&#39;]]</code></pre><h3 id="【2x05】numpy-matmul"><a href="#【2x05】numpy-matmul" class="headerlink" title="【2x05】numpy.matmul()"></a><font color=#1BC3FB>【2x05】numpy.matmul()</font></h3><p><code>numpy.matmul()</code> 函数计算两个矩阵的乘积。</p><p>矩阵的乘积运算：</p><p>设 A 为 <code>m x p</code> 的矩阵，B 为 <code>p x n</code> 的矩阵，那么称 <code>m x n</code> 的矩阵 C 为矩阵 A 与 B 的乘积，记作 C = AB，其中矩阵 C 中的第 i 行第 j 列元素可以表示为：</p><p>$$ (AB)<em>{ij} = \sum</em>{k=1}^p a_{ik}b_{kj} = a_{i1}b_{1j} + a_{i2}b_{2j} + … + a_{ip}b_{pj} $$</p><hr><p>$$<br>A =<br>\left[<br>\begin{matrix}<br>a_{1,1} &amp; a_{1,2} &amp; a_{1,3} \<br>a_{2,1} &amp; a_{2,2} &amp; a_{2,3}<br>\end{matrix}<br>\right]<br>\qquad\qquad\qquad\qquad\qquad\qquad B =<br>\left[<br>\begin{matrix}<br>b_{1,1} &amp; b_{1,2} \<br>b_{2,1} &amp; b_{2,2} \<br>b_{3,1} &amp; b_{3,2}<br>\end{matrix}<br>\right]<br>$$</p><p>$$<br>C = AB =<br>\left[<br>\begin{matrix}<br>a_{1,1}b_{1,1} &amp; a_{1,2}b_{2,1} &amp; a_{1,3}b_{3,1}, &amp; a_{1,1}b_{1,2} &amp; a_{1,2}b_{2,2} &amp; a_{1,3}b_{3,2} \<br>a_{2,1}b_{1,1} &amp; a_{2,2}b_{2,1} &amp; a_{2,3}b_{3,1}, &amp; a_{2,1}b_{1,2} &amp; a_{2,2}b_{2,2} &amp; a_{2,3}b_{3,2}<br>\end{matrix}<br>\right]<br>$$</p><hr><p>矩阵相乘的条件：</p><ul><li>当矩阵 A 的列数（column）等于矩阵 B 的行数（row）时，A 与 B 可以相乘；</li><li>矩阵 C 的行数等于矩阵 A 的行数，C 的列数等于 B 的列数；</li><li>乘积 C 的第 m 行第 n 列的元素等于矩阵 A 的第 m 行的元素与矩阵 B 的第 n 列对应元素乘积之和。</li></ul><hr><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1,0], [0,1]])&gt;&gt;&gt; b = np.array([[4,1], [2,2]])&gt;&gt;&gt; print(np.matmul(a, b))[[4 1] [2 2]]&gt;&gt;&gt; &gt;&gt;&gt; c = np.array([[1,0], [0,1]])&gt;&gt;&gt; d = np.array([1,2])&gt;&gt;&gt; print(np.matmul(c, d))[1 2]&gt;&gt;&gt; print(np.matmul(d, c))[1 2]&gt;&gt;&gt; &gt;&gt;&gt; e = np.arange(8).reshape(2,2,2)&gt;&gt;&gt; f = np.arange(4).reshape(2,2)&gt;&gt;&gt; print(np.matmul(e, f))[[[ 2  3]  [ 6 11]] [[10 19]  [14 27]]]</code></pre><h3 id="【2x06】numpy-tensordot"><a href="#【2x06】numpy-tensordot" class="headerlink" title="【2x06】numpy.tensordot()"></a><font color=#1BC3FB>【2x06】numpy.tensordot()</font></h3><p><code>numpy.tensordot()</code> 函数计算两个不同维度矩阵的乘积。</p><p>基本语法：<code>numpy.tensordot(a, b, axes=2)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>第一个矩阵</td></tr><tr><td>b</td><td>第二个矩阵</td></tr><tr><td>axis</td><td>指定收缩的轴<br>如果是一个整型 m，表示指定数组 a 的后 m 个轴和数组 b 的前 m 个轴分别进行内积，即对应位置元素相乘、再整体求和<br>如果是一个列表 [m, n]，那么表示 a 的第 m+1 个 (索引为m) 轴和 b 的第 n+1 (索引为n) 个轴进行内积</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.random.randint(0, 9, (3, 4))&gt;&gt;&gt; b = np.random.randint(0, 9, (4, 5))&gt;&gt;&gt; aarray([[4, 0, 3, 6],       [1, 3, 2, 2],       [6, 1, 3, 4]])&gt;&gt;&gt; barray([[1, 0, 0, 7, 6],       [3, 8, 7, 5, 0],       [4, 7, 0, 8, 0],       [3, 8, 5, 0, 1]])&gt;&gt;&gt; print(np.tensordot(a, b, 1))[[34 69 30 52 30] [24 54 31 38  8] [33 61 27 71 40]]&gt;&gt;&gt;&gt;&gt;&gt; c = np.array(range(1, 9)).reshape(2, 2, 2)&gt;&gt;&gt; d = np.array((&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;), dtype=object).reshape(2, 2)&gt;&gt;&gt; carray([[[1, 2],        [3, 4]],       [[5, 6],        [7, 8]]])&gt;&gt;&gt; darray([[&#39;a&#39;, &#39;b&#39;],       [&#39;c&#39;, &#39;d&#39;]], dtype=object)&gt;&gt;&gt; print(np.tensordot(c, d))[&#39;abbcccdddd&#39; &#39;aaaaabbbbbbcccccccdddddddd&#39;]</code></pre><h3 id="【2x07】numpy-linalg-det"><a href="#【2x07】numpy-linalg-det" class="headerlink" title="【2x07】numpy.linalg.det()"></a><font color=#1BC3FB>【2x07】numpy.linalg.det()</font></h3><p><code>numpy.linalg.det()</code> 函数计算矩阵的行列式。</p><p>阵行列式是指矩阵的全部元素构成的行列式，设 A=(a<sub>ij</sub>) 是数域 P 上的一个 n 阶矩阵，则所有 A=(a<sub>ij</sub>) 中的元素组成的行列式称为矩阵 A 的行列式，记为 <code>|A|</code> 或 <code>det(A)</code></p><p>一个 2×2 矩阵的行列式可表示如下：</p><p>$$ det = \left[ \begin{matrix} a &amp; b \ c &amp; d \end{matrix} \right] = ad - bc $$</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])&gt;&gt;&gt; print(np.linalg.det(a))-2.0000000000000004</code></pre><h3 id="【2x08】numpy-linalg-solve"><a href="#【2x08】numpy-linalg-solve" class="headerlink" title="【2x08】numpy.linalg.solve()"></a><font color=#1BC3FB>【2x08】numpy.linalg.solve()</font></h3><p><code>numpy.linalg.solve()</code> 函数求解线性矩阵方程或线性标量方程组。</p><hr><p>$$<br>\left {<br>\begin{aligned}<br>3x+y=9 \<br>x+2y=8<br>\end{aligned}<br>\right.<br>\qquad用矩阵可表示为：\qquad<br>\left[<br>\begin{matrix}<br>3 &amp; 1 \<br>1 &amp; 2<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>x &amp; y<br>\end{matrix}<br>\right]<br>= \left[<br>\begin{matrix}<br>9 &amp; 8<br>\end{matrix}<br>\right]<br>$$</p><hr><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[3,1], [1,2]])&gt;&gt;&gt; b = np.array([9,8])&gt;&gt;&gt; print(np.linalg.solve(a, b))[2. 3.]</code></pre><h3 id="【2x09】numpy-linalg-inv"><a href="#【2x09】numpy-linalg-inv" class="headerlink" title="【2x09】numpy.linalg.inv()"></a><font color=#1BC3FB>【2x09】numpy.linalg.inv()</font></h3><p><code>numpy.linalg.inv()</code> 函数计算矩阵的逆矩阵。</p><p>设 A 是数域上的一个 n 阶矩阵，若在相同数域上存在另一个 n 阶矩阵 B，使得：AB = BA = E，则我们称 B 是 A 的逆矩阵，而 A 则被称为可逆矩阵。注：E 为单位矩阵。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])&gt;&gt;&gt; b = np.linalg.inv(a)&gt;&gt;&gt; print(b)[[-2.   1. ] [ 1.5 -0.5]]&gt;&gt;&gt; &gt;&gt;&gt; a * b == b * aarray([[ True,  True],       [ True,  True]])</code></pre><h2 id="【3x00】NumPy-IO-操作"><a href="#【3x00】NumPy-IO-操作" class="headerlink" title="【3x00】NumPy IO 操作"></a><font color=#FF0000>【3x00】NumPy IO 操作</font></h2><p>NumPy IO 操作即读写磁盘上的文本数据或二进制数据，在 NumPy 中有专门的 <code>.npy</code> / <code>npy</code> 文件，<code>.npy</code> 文件用于储存单个 Ndarray 对象；<code>.npz</code> 文件用于储存多个 Ndarray 对象。</p><h3 id="【3x01】numpy-save"><a href="#【3x01】numpy-save" class="headerlink" title="【3x01】numpy.save()"></a><font color=#1BC3FB>【3x01】numpy.save()</font></h3><p><code>numpy.save()</code> 函数将数组保存到二进制文件（<code>.npy</code> 文件）中。</p><p>基本语法：<code>numpy.save(file, arr[, allow_pickle=True, fix_imports=True])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>file</td><td>要保存的文件名，可以带路径，文件后缀为 <code>.npy</code>，若路径末尾没有后缀，则会默认加上 <code>.npy</code> 后缀</td></tr><tr><td>arr</td><td>要保存的数组</td></tr><tr><td>allow_pickle</td><td>bool 值，可选项，是否允许使用 Python pickle 保存数组对象<br>Python pickle 用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化<br>pickle 序列化后的数据，可读性差，人一般无法识别</td></tr><tr><td>fix_imports</td><td>bool 值，可选项，强制以 Python 2 兼容方式对 Python 3 上的数组对象进行处理<br>如果 fix_imports 为True，则 pickle 将尝试将新的 Python 3 名称映射到 Python 2 中使用的旧模块名称，以便 pickle 数据流可被 Python 2 读取</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])&gt;&gt;&gt; np.save(&#39;D:\\file\\outfile.npy&#39;, a)</code></pre><h3 id="【3x02】numpy-load"><a href="#【3x02】numpy-load" class="headerlink" title="【3x02】numpy.load()"></a><font color=#1BC3FB>【3x02】numpy.load()</font></h3><p><code>numpy.load()</code> 函数用于读取 <code>.npy</code> / <code>npz</code> 文件里面的内容。</p><p>基本语法：<code>numpy.load(file[, mmap_mode=None, allow_pickle=False, fix_imports=True, encoding=&#39;ASCII&#39;])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>file</td><td>要读取的 <code>npy</code> 文件对象</td></tr><tr><td>mmap_mode</td><td>可选项，读取文件的模式，可选参数  <code>r+</code> <code>r</code> <code>w+</code> <code>c</code>，与 Python 读取文件模式类似，模式含义参见 <a href="https://numpy.org/doc/1.18/reference/generated/numpy.memmap.html">numpy.memmap</a></td></tr><tr><td>allow_pickle</td><td>bool 值，可选项，是否允许使用 Python pickle 保存数组对象<br>Python pickle 用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化<br>pickle 序列化后的数据，可读性差，人一般无法识别</td></tr><tr><td>fix_imports</td><td>bool 值，可选项，强制以 Python 2 兼容方式对 Python 3 上的数组对象进行处理<br>如果 fix_imports 为True，则 pickle 将尝试将新的 Python 3 名称映射到 Python 2 中使用的旧模块名称，以便 pickle 数据流可被 Python 2 读取</td></tr><tr><td>encoding</td><td>str 类型，可选项，读取 Python2 字符串时使用什么编码<br>仅当在 Python3 中加载 Python 2 生成的 pickled 文件（包括包含对象数组的 npy/npz 文件）时才有用<br>不允许使用 <code>latin1</code>、<code>ASCII</code> 和 <code>bytes</code> 以外的值，因为它们可能损坏数字数据。默认值为 <code>ASCII</code></td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])&gt;&gt;&gt; np.save(&#39;D:\\file\\outfile.npy&#39;, a)&gt;&gt;&gt; np.load(&#39;D:\\file\\outfile.npy&#39;)array([[1, 2, 3],       [4, 5, 6]])</code></pre><h3 id="【3x03】numpy-savez"><a href="#【3x03】numpy-savez" class="headerlink" title="【3x03】numpy.savez()"></a><font color=#1BC3FB>【3x03】numpy.savez()</font></h3><p><code>numpy.savez()</code> 函数将多个数组保存到二进制文件（<code>.npz</code> 文件）中。</p><p>基本语法：<code>numpy.savez(file, *args[, **kwds])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>file</td><td>要保存的文件名，可以带路径，文件后缀为 <code>.npz</code>，若路径末尾没有后缀，则会默认加上 <code>.npz</code> 后缀</td></tr><tr><td>args</td><td>保存的数组，由于 Python 不知道外面 savez 的数组的名称，因此将使用 <code>arr_0</code>，<code>arr_1</code> 等名称保存数组，这些参数可以是任何表达式</td></tr><tr><td>kwds</td><td>关键字参数，可选项，数组将与关键字名称一起保存在文件中</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1,2,3],[4,5,6]])&gt;&gt;&gt; b = np.arange(0, 1.0, 0.1)&gt;&gt;&gt; c = np.sin(b)           # c 使用关键字参数 sin_array&gt;&gt;&gt; np.savez(&#39;D:\\file\\outfile.npz&#39;, a, b, sin_array=c)&gt;&gt;&gt; r = np.load(&#39;D:\\file\\outfile.npz&#39;)&gt;&gt;&gt; print(r.files)         # 查看各个数组名称[&#39;sin_array&#39;, &#39;arr_0&#39;, &#39;arr_1&#39;]&gt;&gt;&gt; &gt;&gt;&gt; print(r[&#39;arr_0&#39;])      # 数组 a[[1 2 3] [4 5 6]]&gt;&gt;&gt; &gt;&gt;&gt; print(r[&#39;arr_1&#39;])      # 数组 b[0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]&gt;&gt;&gt; &gt;&gt;&gt; print(r[&#39;sin_array&#39;])  # 数组 c[0.         0.09983342 0.19866933 0.29552021 0.38941834 0.47942554 0.56464247 0.64421769 0.71735609 0.78332691]</code></pre><h3 id="【3x04】numpy-savetxt"><a href="#【3x04】numpy-savetxt" class="headerlink" title="【3x04】numpy.savetxt()"></a><font color=#1BC3FB>【3x04】numpy.savetxt()</font></h3><p><code>numpy.savetxt()</code> 函数将数组保存到文本文件中（txt）。</p><p>基本语法：<code>numpy.savetxt(fname, X[, fmt=&#39;%.18e&#39;, delimiter=&#39; &#39;, newline=&#39;n&#39;, header=&#39;&#39;, footer=&#39;&#39;, comments=&#39;# &#39;, encoding=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>fname</td><td>要保存的文件名，可以带路径，如果文件后缀为 <code>.gz</code>，则文件将自动以压缩格式 <code>gzip</code> 保存</td></tr><tr><td>X</td><td>要保存的数组</td></tr><tr><td>fmt</td><td>格式序列或多格式字符串，可选项</td></tr><tr><td>delimiter</td><td>指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等，可选项</td></tr><tr><td>newline</td><td>字符串或字符分隔线，可选项</td></tr><tr><td>header</td><td>写入文件开头的字符串，可选项</td></tr><tr><td>footer</td><td>写入文件末尾的字符串，可选项</td></tr><tr><td>comments</td><td>注释，在 header 和 footer 字符串之前添加的字符串，可选项</td></tr><tr><td>encoding</td><td>对输出文件进行编码，可选项</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1,2,3,4,5])&gt;&gt;&gt; np.savetxt(&#39;D:\\file\\outfile.txt&#39;, a)&gt;&gt;&gt; np.loadtxt(&#39;D:\\file\\outfile.txt&#39;)array([1., 2., 3., 4., 5.])&gt;&gt;&gt; &gt;&gt;&gt; b = np.arange(0,10,0.5).reshape(4,-1)&gt;&gt;&gt; np.savetxt(&#39;D:\\file\\outfile2.txt&#39;, b, fmt=&quot;%d&quot;, delimiter=&#39;,&#39;)  # 保存为整数，以逗号分隔&gt;&gt;&gt; np.loadtxt(&#39;D:\\file\\outfile2.txt&#39;, delimiter=&#39;,&#39;)               # 读取数据时也要指定相同的分隔符array([[0., 0., 1., 1., 2.],       [2., 3., 3., 4., 4.],       [5., 5., 6., 6., 7.],       [7., 8., 8., 9., 9.]])</code></pre><h3 id="【3x05】numpy-loadtxt"><a href="#【3x05】numpy-loadtxt" class="headerlink" title="【3x05】numpy.loadtxt()"></a><font color=#1BC3FB>【3x05】numpy.loadtxt()</font></h3><p><code>numpy.loadtxt()</code> 函数用于读取文本文件（txt）里面的内容。</p><p>基本语法：<code>numpy.loadtxt(fname[, dtype=&lt;class &#39;float&#39;&gt;, comments=&#39;#&#39;, delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0, encoding=&#39;bytes&#39;, max_rows=None])</code></p><p>重要参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>fname</td><td>要读取的文件，文件名或生成器。如果文件扩展名是 <code>.gz</code> 或 <code>.bz2</code>，则首先将文件解压缩，注意，生成器应返回字节字符串</td></tr><tr><td>dtype</td><td>可选项，结果数组的数据类型</td></tr><tr><td>comments</td><td>str 或 str 序列，可选项，用于指示注释开始的字符或字符列表</td></tr><tr><td>delimiter</td><td>str 类型，可选项，指定分隔符</td></tr><tr><td>skiprows</td><td>int 类型，可选项，跳过前 n 行，一般用于跳过第一行表头</td></tr><tr><td>usecols</td><td>int 类型的索引值，读取指定的列</td></tr><tr><td>unpack</td><td>bool 值，可选项，如果为True，则会对返回的数组进行转置</td></tr><tr><td>ndmin</td><td>int 类型，可选项，返回的数组将至少具有 ndmin 维度，否则一维轴将被压缩</td></tr><tr><td>encoding</td><td>str 类型，可选项，用于解码输入文件的编码</td></tr><tr><td>max_rows</td><td>int 类型，可选项，读取 skiprows 行之后的最大行内容。默认值是读取所有行</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1,2,3,4,5])&gt;&gt;&gt; np.savetxt(&#39;D:\\file\\outfile.txt&#39;, a)&gt;&gt;&gt; np.loadtxt(&#39;D:\\file\\outfile.txt&#39;)array([1., 2., 3., 4., 5.])</code></pre><h3 id="【3x06】numpy-genfromtxt"><a href="#【3x06】numpy-genfromtxt" class="headerlink" title="【3x06】numpy.genfromtxt()"></a><font color=#1BC3FB>【3x06】numpy.genfromtxt()</font></h3><p><code>numpy.genfromtxt()</code> 函数同样用于读取文本文件（txt）里面的内容。该函数比 <code>loadtxt()</code> 函数功能更加强大，<code>genfromtxt()</code> 主要面向结构数组和缺失数据处理。</p><p>官方文档介绍：<a href="https://numpy.org/doc/1.18/reference/generated/numpy.genfromtxt.html">https://numpy.org/doc/1.18/reference/generated/numpy.genfromtxt.html</a></p><p>推荐文章：<a href="https://www.cnblogs.com/Simplelee/p/8975763.html">https://www.cnblogs.com/Simplelee/p/8975763.html</a></p><p>主要语法：<code>numpy.genfromtxt(fname[, dtype=&lt;class &#39;float&#39;&gt;, comments=&#39;#&#39;, delimiter=None, skip_header=0, skip_footer=0, converters=None, missing_values=None, filling_values=None, usecols=None, encoding=&#39;bytes&#39;])</code></p><p>主要参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>fname</td><td>要读取的文件，文件名或生成器。如果文件扩展名是 <code>.gz</code> 或 <code>.bz2</code>，则首先将文件解压缩，注意，生成器应返回字节字符串</td></tr><tr><td>dtype</td><td>可选项，结果数组的数据类型</td></tr><tr><td>comments</td><td>str 或 str 序列，可选项，用于指示注释开始的字符或字符列表</td></tr><tr><td>delimiter</td><td>str 类型，可选项，指定分隔符</td></tr><tr><td>skip_header</td><td>int 类型，可选项，文件开头要跳过的行数</td></tr><tr><td>skip_footer</td><td>int 类型，可选项，文件末尾要跳过的行数</td></tr><tr><td>converters</td><td>变量，可选项，将列的数据转换为值的一组函数<br>还可以为丢失的数据提供默认值：<code>converters = &#123;3: lambda s: float(s or 0)&#125;</code></td></tr><tr><td>missing_values</td><td>变量，可选项，与缺少的数据相对应的字符串集，默认情况下使用空格表示缺失</td></tr><tr><td>filling_values</td><td>变量，可选项，缺少数据时用作默认值的一组值</td></tr><tr><td>usecols</td><td>序列，可选项，读取指定的列</td></tr><tr><td>encoding</td><td>str 类型，可选项，用于解码输入文件的编码</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1,2,3,4,5])&gt;&gt;&gt; np.savetxt(&#39;D:\\file\\outfile.txt&#39;, a)&gt;&gt;&gt; np.genfromtxt(&#39;D:\\file\\outfile.txt&#39;)array([1., 2., 3., 4., 5.])&gt;&gt;&gt;&gt;&gt;&gt; b = np.arange(0,10,0.5).reshape(4,-1)&gt;&gt;&gt; np.savetxt(&#39;D:\\file\\outfile2.txt&#39;, b, fmt=&quot;%d&quot;, delimiter=&quot;,&quot;)&gt;&gt;&gt; np.genfromtxt(&#39;D:\\file\\outfile2.txt&#39;, delimiter=&#39;,&#39;)array([[0., 0., 1., 1., 2.],       [2., 3., 3., 4., 4.],       [5., 5., 6., 6., 7.],       [7., 8., 8., 9., 9.]])</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105511641未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> NumPy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 NumPy（五）：数学 / 算术 / 统计 / 排序 / 条件 / 判断函数合集</title>
      <link href="/article/012/"/>
      <url>/article/012/</url>
      
        <content type="html"><![CDATA[<p>NumPy 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/008/">Python 数据分析三剑客之 NumPy（一）：理解 NumPy / 数组基础</a></li><li><a href="https://www.itbob.cn/article/009/">Python 数据分析三剑客之 NumPy（二）：数组索引 / 切片 / 广播 / 拼接 / 分割</a></li><li><a href="https://www.itbob.cn/article/010/">Python 数据分析三剑客之 NumPy（三）：数组的迭代与位运算</a></li><li><a href="https://www.itbob.cn/article/011/">Python 数据分析三剑客之 NumPy（四）：字符串函数总结与对比</a></li><li><a href="https://www.itbob.cn/article/012/">Python 数据分析三剑客之 NumPy（五）：数学 / 算术 / 统计 / 排序 / 条件 / 判断函数合集</a></li><li><a href="https://www.itbob.cn/article/013/">Python 数据分析三剑客之 NumPy（六）：矩阵 / 线性代数库与 IO 操作</a></li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105398131未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】NumPy-函数速查表"><a href="#【1x00】NumPy-函数速查表" class="headerlink" title="【1x00】NumPy 函数速查表"></a><font color=#FF0000>【1x00】NumPy 函数速查表</font></h2><table>    <tr>        <td bgcolor="#7FFFD4" colspan="2"><strong><font size=3px>NumPy 三角函数</font></strong></td>    </tr>    <tr>        <th><font color="#FF0000">函数</font></th>        <th><font color="#FF0000">描述</font></th>    </tr>    <tr>        <td>sin()</font></td>        <td>正弦函数</td>    </tr>    <tr>        <td>cos()</font></td>        <td>余弦函数</td>    </tr>    <tr>        <td>tan()</font></td>        <td>正切函数</td>    </tr>    <tr>        <td>arcsin()</font></td>        <td>反正弦函数</td>    </tr>    <tr>        <td>arccos()</font></td>        <td>反余弦函数</td>    </tr>    <tr>        <td>arctan()</font></td>        <td>反正切函数</td>    </tr>    <tr>        <td bgcolor="#7FFFD4" colspan="2"><strong><font size=3px>NumPy 舍入函数</font></strong></td>    </tr>    <tr>        <th><font color="#FF0000">函数</font></th>        <th><font color="#FF0000">描述</font></th>    </tr>    <tr>        <td>around()</font></td>        <td>将指定数字四舍五入到指定的小数位</td>    </tr>    <tr>        <td>rint()</font></td>        <td>将指定数字四舍五入到最近的整数</td>    </tr>    <tr>        <td>floor()</font></td>        <td>返回小于或者等于指定表达式的最大整数，即向下取整</td>    </tr>    <tr>        <td>ceil()</font></td>        <td>返回大于或者等于指定表达式的最小整数，即向上取整</td>    </tr>    <tr>        <td bgcolor="#7FFFD4" colspan="2"><strong><font size=3px>NumPy 算术函数</font></strong></td>    </tr>    <tr>        <th><font color="#FF0000">函数</font></th>        <th><font color="#FF0000">描述</font></th>    </tr>    <tr>        <td>add()</font></td>        <td>数组元素加法运算</td>    </tr>    <tr>        <td>subtract()</font></td>        <td>数组元素减法运算</td>    </tr>    <tr>        <td>multiply()</font></td>        <td>数组元素乘法运算</td>    </tr>    <tr>        <td>divide()</font></td>        <td>数组元素除法运算</td>    </tr>    <tr>        <td>reciprocal()</font></td>        <td>返回数组元素的倒数</td>    </tr>    <tr>        <td>power()</font></td>        <td>返回数组元素的乘幂</td>    </tr>    <tr>        <td>mod()</font></td>        <td>返回数组元素的相除后的余数</td>    </tr>    <tr>        <td>remainder()</font></td>        <td>返回数组元素的相除后的余数</td>    </tr>    <tr>        <td bgcolor="#7FFFD4" colspan="2"><strong><font size=3px>NumPy 统计函数</font></strong></td>    </tr>    <tr>        <th><font color="#FF0000">函数</font></th>        <th><font color="#FF0000">描述</font></th>    </tr>    <tr>        <td>amax()</font></td>        <td>计算数组元素沿指定轴的最大值</td>    </tr>    <tr>        <td>amin()</font></td>        <td>计算数组元素沿指定轴的最小值</td>    </tr>    <tr>        <td>argmax()</font></td>        <td>计算数组元素沿指定轴的最大值的索引值</td>    </tr>    <tr>        <td>argmin()</font></td>        <td>计算数组元素沿指定轴的最小值的索引值</td>    </tr>    <tr>        <td>sum()</font></td>        <td>计算数组中所有元素的和</td>    </tr>    <tr>        <td>cumsum()</font></td>        <td>返回一个一维数组，每个元素都是之前所有元素的累加和</td>    </tr>    <tr>        <td>cumprod()</font></td>        <td>返回一个一维数组，每个元素都是之前所有元素的累乘积</td>    </tr>    <tr>        <td>ptp()</font></td>        <td>计算数组元素最大值与最小值的差</td>    </tr>    <tr>        <td>percentile()</font></td>        <td>计算多维数组的任意百分位数</td>    </tr>    <tr>        <td>median()</font></td>        <td>计算数组元素的中位数</td>    </tr>    <tr>        <td>mean()</font></td>        <td>计算数组元素的算术平均值</td>    </tr>    <tr>        <td>average()</font></td>        <td>计算数组元素的加权平均值</td>    </tr>    <tr>        <td>std()</font></td>        <td>计算数组元素的标准差</td>    </tr>    <tr>        <td>var()</font></td>        <td>计算数组元素的方差</td>    </tr>        <td bgcolor="#7FFFD4" colspan="2"><strong><font size=3px>NumPy 排序函数</font></strong></td>    <tr>        <td>sort()</font></td>        <td>将原数组元素按照从小到大排序</td>    </tr>    <tr>        <td>msort()</font></td>        <td>将原数组元素按照第一个轴的从小到大排序</td>    </tr>    <tr>        <td>argsort()</font></td>        <td>将元素从小到大排列，提取对应的索引值并返回</td>    </tr>    <tr>        <td>lexsort()</font></td>        <td>将多个序列按照从小到大排序，返回其索引值</td>    </tr>    <tr>        <td>sort_complex()</font></td>        <td>对复数数组进行从小到大排序</td>    </tr>    <tr>        <td>partition()</font></td>        <td>对数组进行分区排序</td>    </tr>    <tr>        <td>argpartition()</font></td>        <td>对数组进行分区排序，返回元素的索引值</td>    </tr>    <tr>        <td>unique()</font></td>        <td>将数组元素去重后返回从小到大的排序结果</td>    </tr>        <td bgcolor="#7FFFD4" colspan="2"><strong><font size=3px>NumPy 条件函数</font></strong></td>    <tr>        <td>nonzero()</font></td>        <td>返回原数组中非零元素的索引值</td>    </tr>    <tr>        <td>where()</font></td>        <td>返回数组中满足指定条件的元素的索引值</td>    </tr>    <tr>        <td>extract()</font></td>        <td>返回数组中满足指定条件的元素</td>    </tr>        <td bgcolor="#7FFFD4" colspan="2"><strong><font size=3px>NumPy 判断函数</font></strong></td>    <tr>        <td>any()</font></td>        <td>至少有一个元素满足指定条件，则返回 True，否则返回 False</td>    </tr>    <tr>        <td>all()</font></td>        <td>所有的元素满足指定条件，则返回 True，否则返回 False</td>    </tr></table><h2 id="【2x00】NumPy-数学函数"><a href="#【2x00】NumPy-数学函数" class="headerlink" title="【2x00】NumPy 数学函数"></a><font color=#FF0000>【2x00】NumPy 数学函数</font></h2><p>NumPy 数学函数包含三角函数、舍入函数等。</p><h3 id="【2x01】sin-cos-tan"><a href="#【2x01】sin-cos-tan" class="headerlink" title="【2x01】sin() / cos() / tan()"></a><font color=#1BC3FB>【2x01】sin() / cos() / tan()</font></h3><p><code>numpy.sin()</code>、<code>numpy.cos()</code>、<code>numpy.tan()</code> 分别对应<font color=#FF0000><strong>正弦函数</strong></font>、<font color=#FF0000><strong>余弦函数</strong></font>、<font color=#FF0000><strong>正切函数</strong></font>。</p><p>在求三角函数时，会先将角度转化成弧度，在 NumPy 中的转化公式：<code>角度 * numpy.pi/180</code></p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([0, 30, 45, 60 ,90])&gt;&gt;&gt; print(np.sin(a*np.pi/180))[0.         0.5        0.70710678 0.8660254  1.        ]&gt;&gt;&gt; print(np.cos(a*np.pi/180))[1.00000000e+00 8.66025404e-01 7.07106781e-01 5.00000000e-01 6.12323400e-17]&gt;&gt;&gt; print(np.tan(a*np.pi/180))[0.00000000e+00 5.77350269e-01 1.00000000e+00 1.73205081e+00 1.63312394e+16]</code></pre><hr><h3 id="【2x02】arcsin-arccos-arctan"><a href="#【2x02】arcsin-arccos-arctan" class="headerlink" title="【2x02】arcsin() / arccos() / arctan()"></a><font color=#1BC3FB>【2x02】arcsin() / arccos() / arctan()</font></h3><p><code>numpy.arcsin()</code>、<code>numpy.arccos()</code>、<code>numpy.arctan()</code> 分别对应<font color=#FF0000><strong>反正弦函数</strong></font>、<font color=#FF0000><strong>反余弦函数</strong></font>、<font color=#FF0000><strong>反正切函数</strong></font>。</p><p>在求三角函数时，会先将角度转化成弧度，在 NumPy 中的转化公式：<code>角度 * numpy.pi/180</code></p><p>arcsin、arccos、arctan 接收的参数是三角函数值，函数返回给定角度的 sin，cos 和 tan 的反三角函数，如果 sinθ=x，那么 arcsinx=θ，其他类似，这些函数的结果可以通过 <code>numpy.degrees()</code> 函数将弧度转换为角度。</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([0, 30, 45, 60 ,90])&gt;&gt;&gt; a_sin = np.sin(a*np.pi/180)&gt;&gt;&gt; a_arcsin = np.arcsin(a_sin)&gt;&gt;&gt; print(a_sin)                                           # 角度的正弦值[0.         0.5        0.70710678 0.8660254  1.        ]&gt;&gt;&gt; print(a_arcsin)                                        # 角度的反正弦值，返回值的单位为弧度[0.         0.52359878 0.78539816 1.04719755 1.57079633]&gt;&gt;&gt; print(np.degrees(a_arcsin))                            # 弧度转化为角度[ 0. 30. 45. 60. 90.]</code></pre><hr><h3 id="【2x03】around-rint-floor-ceil"><a href="#【2x03】around-rint-floor-ceil" class="headerlink" title="【2x03】around() / rint() / floor() / ceil()"></a><font color=#1BC3FB>【2x03】around() / rint() / floor() / ceil()</font></h3><p>1、<code>numpy.around()</code> 函数将指定数字四舍五入到<font color=#FF0000><strong>指定的小数位</strong></font>，可指定保留的小数位数。</p><p>基本语法：<code>numpy.around(a[, decimals=0, out=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>输入数组</td></tr><tr><td>decimals</td><td>int 类型，可选项，舍入的小数位数，默认值为 0，如果为负，整数将四舍五入到小数点左侧的位置</td></tr><tr><td>out</td><td>ndarray 对象，可选项，放置结果的备用输出数组。它必须具有与预期输出相同的形状，但是如有必要，将强制转换输出值的类型</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([13, 1.4, 6.23, 12.834])&gt;&gt;&gt; print(np.around(a))[13.  1.  6. 13.]&gt;&gt;&gt; print(np.around(a, decimals=1))[13.   1.4  6.2 12.8]&gt;&gt;&gt; print(np.around(a, decimals=-1))[10.  0. 10. 10.]</code></pre><p>2、<code>numpy.rint()</code> 函数将指定数字四舍五入到<font color=#FF0000><strong>最近的整数</strong></font>，不保留小数位。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.rint([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]))[-2. -2. -0.  0.  2.  2.  2.]</code></pre><p>3、<code>numpy.floor()</code> 函数会返回小于或者等于指定表达式的最大整数，即<font color=#FF0000><strong>向下取整</strong></font>。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.floor([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]))[-2. -2. -1.  0.  1.  1.  2.]</code></pre><p>4、<code>numpy.ceil()</code> 函数会返回大于或者等于指定表达式的最小整数，即<font color=#FF0000><strong>向上取整</strong></font>。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.ceil([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]))[-1. -1. -0.  1.  2.  2.  2.]</code></pre><h2 id="【3x00】NumPy-算术函数"><a href="#【3x00】NumPy-算术函数" class="headerlink" title="【3x00】NumPy 算术函数"></a><font color=#FF0000>【3x00】NumPy 算术函数</font></h2><p>NumPy 算术函数包含了基本的加减乘除运算、求倒数、幂、余数等。</p><h3 id="【3x01】add-subtract-multiply-divide"><a href="#【3x01】add-subtract-multiply-divide" class="headerlink" title="【3x01】add() / subtract() / multiply() / divide()"></a><font color=#1BC3FB>【3x01】add() / subtract() / multiply() / divide()</font></h3><p><code>add()</code>、<code>subtract()</code>、<code>multiply()</code>、<code>divide()</code> 分别对应 <code>NumPy</code> 中的<font color=#FF0000><strong>加减乘除</strong></font>运算。</p><p>注意：两个数组必须具有相同的形状或符合数组的广播规则才能进行运算。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])&gt;&gt;&gt; b = np.array([5, 5, 5])&gt;&gt;&gt; print(np.add(a, b))[[ 5  6  7] [ 8  9 10] [11 12 13]]&gt;&gt;&gt; print(np.subtract(a, b))[[-5 -4 -3] [-2 -1  0] [ 1  2  3]]&gt;&gt;&gt; print(np.multiply(a, b))[[ 0  5 10] [15 20 25] [30 35 40]]&gt;&gt;&gt; print(np.divide(a, b))[[0.  0.2 0.4] [0.6 0.8 1. ] [1.2 1.4 1.6]]</code></pre><h3 id="【3x02】reciprocal-power-mod-remainder"><a href="#【3x02】reciprocal-power-mod-remainder" class="headerlink" title="【3x02】reciprocal() / power() / mod() / remainder()"></a><font color=#1BC3FB>【3x02】reciprocal() / power() / mod() / remainder()</font></h3><p>1、<code>numpy.reciprocal()</code> 函数用于返回各数组元素的<font color=#FF0000><strong>倒数</strong></font>。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.reciprocal([0.25, 4, 1, 2.10]))[4.         0.25       1.         0.47619048]</code></pre><p>2、<code>numpy.power()</code> 函数将第一个数组中的元素作为底数，计算它与第二个数组中相应元素的<font color=#FF0000><strong>幂</strong></font>。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([5, 10, 100])&gt;&gt;&gt; b = np.array([3, 2, 1])&gt;&gt;&gt; print(np.power(a, b))[125 100 100]&gt;&gt;&gt;&gt;&gt;&gt; print(np.power(a, 2))[   25   100 10000]</code></pre><p>3、<code>numpy.mod()</code> 与 <code> numpy.remainder()</code> 都可以计算数组中相应元素相除后的<font color=#FF0000><strong>余数</strong></font>。 </p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([10, 15, 20])&gt;&gt;&gt; b = np.array([3, 4, 5])&gt;&gt;&gt; print(np.mod(a, b))[1 3 0]&gt;&gt;&gt; print(np.remainder(a, b))[1 3 0]&gt;&gt;&gt; print(np.mod(a, 6))[4 3 2]&gt;&gt;&gt; print(np.remainder(a, 9))[1 6 2]</code></pre><h3 id="【3x03】absolute-isnan"><a href="#【3x03】absolute-isnan" class="headerlink" title="【3x03】absolute() / isnan()"></a><font color=#1BC3FB>【3x03】absolute() / isnan()</font></h3><p>1、<code>numpy.absolute()</code> 函数用于计算<font color=#FF0000><strong>元素的绝对值</strong></font>。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.absolute([-1.2, 1.2, 13, -10]))[ 1.2  1.2 13.  10. ]</code></pre><p>2、<code>numpy.isnan()</code> 函数用于<font color=#FF0000><strong>判断元素是否为 NaN（Not a Number）</strong></font>。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.isnan(np.nan)True&gt;&gt;&gt; np.isnan(np.inf)False&gt;&gt;&gt; print(np.isnan([np.nan, 2, 3, np.nan]))[ True False False  True]</code></pre><h2 id="【4x00】NumPy-统计函数"><a href="#【4x00】NumPy-统计函数" class="headerlink" title="【4x00】NumPy 统计函数"></a><font color=#FF0000>【4x00】NumPy 统计函数</font></h2><p>NumPy 统计函数包含了计算最大值、最小值、最大值与最小值的差、百分位数、中位数、算术平均值、加权平均值、标准差与方差等。</p><h3 id="【4x01】amax-amin"><a href="#【4x01】amax-amin" class="headerlink" title="【4x01】amax() / amin()"></a><font color=#1BC3FB>【4x01】amax() / amin()</font></h3><p><code>numpy.amax()</code> 和 <code>numpy.amin()</code> 函数分别用于计算数组中的元素沿指定轴的<font color=#FF0000><strong>最大值</strong></font>和<font color=#FF0000><strong>最小值</strong></font>。</p><p>基本语法：</p><p><code>numpy.amax(a[, axis=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;])</code></p><p><code>numpy.amin(a[, axis=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;])</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>待处理的数组对象</td></tr><tr><td>axis</td><td>指定轴，可选项，整数或者整数元组类型</td></tr><tr><td>out</td><td>ndarray 对象，可选项，放置结果的备用输出数组，必须具有与预期输出数组相同的形状和缓冲区长度</td></tr><tr><td>keepdims</td><td>bool 类型，可选项，是否保持数组的二维特性</td></tr><tr><td>initial</td><td>初始值标量，可选项，如果设置了标量，则除了元素之间的比较外，还会和标量进行对比</td></tr><tr><td>where</td><td>比较条件，通常和 initial 参数一起使用<br>如果当前是 amax 函数，where 为 True 时则会比较最大值， Flase 则会比较最小值<br>该参数含义比较模糊，参考资料较少，准确描述请参考<a href="https://numpy.org/doc/1.18/reference/generated/numpy.amax.html">官方文档</a></td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[2, 4], [8, 9]])&gt;&gt;&gt; print(a)[[2 4] [8 9]]&gt;&gt;&gt; &gt;&gt;&gt; print(np.amax(a))9&gt;&gt;&gt; &gt;&gt;&gt; print(np.amax(a, axis=0))                                  # 元素按行比较[8 9]&gt;&gt;&gt;&gt;&gt;&gt; print(np.amax(a, axis=0, keepdims=True))                   # 元素按行比较并保持数组的二维特性[[8 9]]&gt;&gt;&gt; &gt;&gt;&gt; print(np.amax(a, axis=1))                                  # 元素按列比较[4 9]&gt;&gt;&gt; &gt;&gt;&gt; print(np.amax(a, axis=1, initial=5))                       # 元素按列比较（包括标量一起比较）[5 9]</code></pre><h3 id="【4x02】argmax-argmin"><a href="#【4x02】argmax-argmin" class="headerlink" title="【4x02】argmax() / argmin()"></a><font color=#1BC3FB>【4x02】argmax() / argmin()</font></h3><p><code>numpy.argmax()</code> 和 <code>numpy.argmin()</code> 函数分别沿指定轴返回<font color=#FF0000><strong>最大元素和最小元素的索引值</strong></font>。</p><p>基本语法：<code>numpy.argmax(a[, axis=None, out=None])</code>；<code>numpy.argmin(a[, axis=None, out=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>待处理的数组对象</td></tr><tr><td>axis</td><td>指定轴，可选项，整数或者整数元组类型，若未指定，则在操作前会将数组展开</td></tr><tr><td>out</td><td>可选项，放置结果的备用输出数组，必须具有与预期输出数组相同的形状和缓冲区长度</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[30,40,70],[80,20,10],[50,90,60]])&gt;&gt;&gt; print(a)[[30 40 70] [80 20 10] [50 90 60]]&gt;&gt;&gt; &gt;&gt;&gt; print (np.argmax(a))7&gt;&gt;&gt; &gt;&gt;&gt; print(np.argmin(a))5&gt;&gt;&gt; &gt;&gt;&gt; print(np.argmax(a, axis=0))[1 2 0]&gt;&gt;&gt; &gt;&gt;&gt; print(np.argmin(a, axis=0))[0 1 1]</code></pre><h3 id="【4x03】sum"><a href="#【4x03】sum" class="headerlink" title="【4x03】sum()"></a><font color=#1BC3FB>【4x03】sum()</font></h3><p><code>numpy.sum()</code> 函数用于计算所有元素的<font color=#FF0000><strong>和</strong></font>。</p><p>基本语法：<code>numpy.sum(a, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>待处理的数组对象</td></tr><tr><td>axis</td><td>指定轴，可选项，整数或者整数元组类型，若未指定则运算前会将数组展平</td></tr><tr><td>dtype</td><td>指定数据类型，可选项</td></tr><tr><td>out</td><td>可选项，放置结果的备用输出数组，必须具有与预期输出数组相同的形状和缓冲区长度</td></tr><tr><td>keepdims</td><td>bool 类型，可选项，是否保持数组的二维特性</td></tr><tr><td>initial</td><td>初始值标量，可选项，如果设置了标量，则除了元素之间的求和外，还会和标量进行求和</td></tr><tr><td>where</td><td>求和条件，总和中要包括的元素</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.sum([[0, 1], [0, 5]]))6&gt;&gt;&gt; print(np.sum([[0, 1], [0, 5]], axis=0))[0 6]&gt;&gt;&gt; print(np.sum([[0, 1], [0, 5]], axis=1))[1 5]&gt;&gt;&gt; print(np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1))[1. 5.]&gt;&gt;&gt; print(np.sum([10], initial=5))15</code></pre><h3 id="【4x04】cumsum-cumprod"><a href="#【4x04】cumsum-cumprod" class="headerlink" title="【4x04】cumsum() / cumprod()"></a><font color=#1BC3FB>【4x04】cumsum() / cumprod()</font></h3><p><code>numpy.cumsum()</code>：返回一个一维数组，每个元素都是之前所有元素的<font color=#FF0000><strong>累加和</strong></font>。<br><code>numpy.cumprod()</code>：返回一个一维数组，每个元素都是之前所有元素的<font color=#FF0000><strong>累乘积</strong></font>。</p><p>基本语法：<code>numpy.cumsum(a, axis=None, dtype=None, out=None)</code>；<code>numpy.cumprod(a, axis=None, dtype=None, out=None)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>待处理的数组对象</td></tr><tr><td>axis</td><td>指定轴，可选项，整数或者整数元组类型，若未指定则运算前会将数组展平</td></tr><tr><td>dtype</td><td>指定数据类型，可选项</td></tr><tr><td>out</td><td>可选项，放置结果的备用输出数组，必须具有与预期输出数组相同的形状和缓冲区长度</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])&gt;&gt;&gt; print(np.cumsum(a))[ 1  3  6 10 15 21]&gt;&gt;&gt; &gt;&gt;&gt; print(np.cumsum(a, axis=0))[[1 2 3] [5 7 9]]&gt;&gt;&gt; &gt;&gt;&gt; print(np.cumsum(a, axis=1))[[ 1  3  6] [ 4  9 15]]&gt;&gt;&gt; &gt;&gt;&gt; print(np.cumprod(a))[  1   2   6  24 120 720]&gt;&gt;&gt; &gt;&gt;&gt; print(np.cumprod(a, axis=0))[[ 1  2  3] [ 4 10 18]]&gt;&gt;&gt; &gt;&gt;&gt; print(np.cumprod(a, axis=1))[[  1   2   6] [  4  20 120]]</code></pre><h3 id="【4x05】ptp"><a href="#【4x05】ptp" class="headerlink" title="【4x05】ptp()"></a><font color=#1BC3FB>【4x05】ptp()</font></h3><p><code>numpy.ptp()</code> 函数用于计算数组中元素<font color=#FF0000><strong>最大值与最小值的差</strong></font>。</p><p>基本语法：<code>numpy.ptp(a[, axis=None, out=None, keepdims=&lt;no value&gt;])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>待处理的数组对象</td></tr><tr><td>axis</td><td>指定轴，可选项，整数或者整数元组类型</td></tr><tr><td>out</td><td>可选项，放置结果的备用输出数组，必须具有与预期输出数组相同的形状和缓冲区长度</td></tr><tr><td>keepdims</td><td>bool 类型，可选项，是否保持数组的二维特性</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[2,5,8],[7,6,3],[2,9,4]])&gt;&gt;&gt; print(a)[[2 5 8] [7 6 3] [2 9 4]]&gt;&gt;&gt; print(np.ptp(a))7&gt;&gt;&gt; &gt;&gt;&gt; print(np.ptp(a, axis=0))[5 4 5]&gt;&gt;&gt; &gt;&gt;&gt; print(np.ptp(a, axis=1))[6 4 7]&gt;&gt;&gt; print(np.ptp(a, axis=1, keepdims=True))[[6] [4] [7]]</code></pre><h3 id="【4x06】percentile"><a href="#【4x06】percentile" class="headerlink" title="【4x06】percentile()"></a><font color=#1BC3FB>【4x06】percentile()</font></h3><p><code>numpy.percentile()</code> 函数用于计算一个多维数组的任意<font color=#FF0000><strong>百分位数</strong></font>。</p><p>百分位数：统计学术语，如果将一组数据从小到大排序，并计算相应的累计百分位，则某一百分位所对应数据的值就称为这一百分位的百分位数。可表示为：一组 n 个观测值按数值大小排列。如：处于 p% 位置的值称第 p 百分位数。</p><p>基本语法：<code>numpy.percentile(a, q[, axis=None, out=None, overwrite_input=False, interpolation=&#39;linear&#39;, keepdims=False])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>待处理的数组对象</td></tr><tr><td>q</td><td>要计算的百分位数，在 [0, 100] 之间</td></tr><tr><td>axis</td><td>指定轴，可选项，整数或者整数元组类型</td></tr><tr><td>out</td><td>可选项，放置结果的备用输出数组，必须具有与预期输出数组相同的形状和缓冲区长度</td></tr><tr><td>overwrite_input</td><td>bool 值，可选项，如果为True，则允许通过中间计算来修改输入数组 a 以节省内存<br>在这种情况下，此操作完成后 a 的内容是不确定的</td></tr><tr><td>interpolation</td><td>可选项，指定当所需百分比位于两个数据点 <code>i&lt;j</code> 之间时要使用的插值方法：<br><font color=#ff0000><strong>linear</strong></font>：<code>i + (j - i) * fraction</code>，其中 fraction 是由 i 和 j 包围的索引的分数部分<br><font color=#ff0000><strong>lower</strong></font>：<code>i</code>；<font color=#ff0000><strong>higher</strong></font>：<code>j</code>；<font color=#ff0000><strong>nearest</strong></font>：<code>i</code> 或 <code>j</code>，以最近者为准；<font color=#ff0000><strong>midpoint</strong></font>：<code>(i + j) / 2</code></td></tr><tr><td>keepdims</td><td>bool 类型，可选项，是否保持数组的二维特性</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])&gt;&gt;&gt; print(a)[[10  7  4] [ 3  2  1]]&gt;&gt;&gt; &gt;&gt;&gt; print(np.percentile(a, 50))3.5&gt;&gt;&gt; &gt;&gt;&gt; print(np.percentile(a, 50, axis=0))[6.5 4.5 2.5]&gt;&gt;&gt; &gt;&gt;&gt; print(np.percentile(a, 50, axis=1))[7. 2.]&gt;&gt;&gt; &gt;&gt;&gt; print(np.percentile(a, 50, axis=1, keepdims=True))[[7.] [2.]]</code></pre><h3 id="【4x07】median"><a href="#【4x07】median" class="headerlink" title="【4x07】median()"></a><font color=#1BC3FB>【4x07】median()</font></h3><p><code>numpy.median()</code> 函数用于计算数组元素的<font color=#FF0000><strong>中位数</strong></font>。</p><p>基本语法：<code>numpy.median(a[, axis=None, out=None, overwrite_input=False, keepdims=False])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>待处理的数组对象</td></tr><tr><td>axis</td><td>指定轴，可选项，整数或者整数元组类型</td></tr><tr><td>out</td><td>可选项，放置结果的备用输出数组，必须具有与预期输出数组相同的形状和缓冲区长度</td></tr><tr><td>overwrite_input</td><td>bool 值，可选项，如果为True，则允许通过中间计算来修改输入数组 a 以节省内存<br>在这种情况下，此操作完成后 a 的内容是不确定的</td></tr><tr><td>keepdims</td><td>bool 类型，可选项，是否保持数组的二维特性</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])&gt;&gt;&gt; print(a)[[10  7  4] [ 3  2  1]]&gt;&gt;&gt;&gt;&gt;&gt; print(np.median(a))3.5&gt;&gt;&gt;&gt;&gt;&gt; print(np.median(a, axis=0))[6.5 4.5 2.5]&gt;&gt;&gt; &gt;&gt;&gt; print(np.median(a, axis=1))[7. 2.]</code></pre><h3 id="【4x08】mean"><a href="#【4x08】mean" class="headerlink" title="【4x08】mean()"></a><font color=#1BC3FB>【4x08】mean()</font></h3><p><code>numpy.mean()</code> 函数计算数组中元素的<font color=#FF0000><strong>算术平均值</strong></font>。</p><p>算术平均值：沿轴的元素的总和除以元素的数量。</p><p>基本语法：<code>numpy.mean(a[, axis=None, dtype=None, out=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>待处理的数组对象</td></tr><tr><td>axis</td><td>指定轴，可选项，整数或者整数元组类型</td></tr><tr><td>dtype</td><td>可选项，用于计算平均值的类型</td></tr><tr><td>out</td><td>可选项，放置结果的备用输出数组，必须具有与预期输出数组相同的形状和缓冲区长度</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])&gt;&gt;&gt; print(a)[[10  7  4] [ 3  2  1]]&gt;&gt;&gt; &gt;&gt;&gt; print(np.mean(a))4.5&gt;&gt;&gt; &gt;&gt;&gt; print(np.mean(a, axis=0))[6.5 4.5 2.5]&gt;&gt;&gt; &gt;&gt;&gt; print(np.mean(a, axis=1))[7. 2.]</code></pre><h3 id="【4x09】average"><a href="#【4x09】average" class="headerlink" title="【4x09】average()"></a><font color=#1BC3FB>【4x09】average()</font></h3><p><code>numpy.average()</code> 函数根据在另一个数组中给出的各自的权重来计算数组中元素的<font color=#FF0000><strong>加权平均值</strong></font>。</p><p>加权平均值：将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。</p><p>例如：现有数组 <code>[1, 2, 3, 4]</code>，相应的权重为 <code>[5, 6, 7, 8]</code>，则计算方法为：<code>（1*5+2*6+3*7+4*8）/（5+6+7+8）≈ 2.6923</code></p><p>基本语法：<code>numpy.average(a[, axis=None, weights=None, returned=False])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>待处理的数组对象</td></tr><tr><td>axis</td><td>指定轴，可选项，整数或者整数元组类型</td></tr><tr><td>weights</td><td>可选项，与 a 中的值相关联的权重数组，如果 weights=None，则 a 中的所有数据都具有 1 的权重，相当于 <code>mean</code> 函数</td></tr><tr><td>returned</td><td>可选项，bool 类型，默认为 False，如果为 True，则返回元组 <code>(加权平均值, 权重)</code>，否则只返回加权平均值</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 2, 3, 4])&gt;&gt;&gt; print(np.average(a))          # 不指定权重时相当于 mean 函数2.5&gt;&gt;&gt; &gt;&gt;&gt; print(np.average(a, weights=[5, 6, 7, 8]))2.6923076923076925&gt;&gt;&gt; &gt;&gt;&gt; print(np.average(a, weights=[5, 6, 7, 8], returned=True))(2.6923076923076925, 26.0)</code></pre><h3 id="【4x10】std-var"><a href="#【4x10】std-var" class="headerlink" title="【4x10】std() / var()"></a><font color=#1BC3FB>【4x10】std() / var()</font></h3><p><code>numpy.std()</code> 和 <code>numpy.var()</code> 分别用于计算数组元素的<font color=#FF0000><strong>标准差</strong></font>与<font color=#FF0000><strong>方差</strong></font>。</p><p>标准差是一组数据平均值分散程度的一种度量，标准差是方差的算术平方根。</p><p>方差为 S<sup>2</sup>，标准差为 S，计算公式如下：</p><p>$$S^2 = \frac {1} {n} \sum_{i=1} ^ {n} (x_i - \overline {x})^2$$</p><p>$$S = \sqrt {S^2}$$</p><p>基本语法：</p><p><code>numpy.std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=&lt;no value&gt;)</code></p><p><code>numpy.var(a[, axis=None, dtype=None, out=None, ddof=0, keepdims=&lt;no value&gt;])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>待处理的数组对象</td></tr><tr><td>axis</td><td>指定轴，可选项，整数或者整数元组类型</td></tr><tr><td>dtype</td><td>可选项，值的数据类型</td></tr><tr><td>out</td><td>可选项，放置结果的备用输出数组，必须具有与预期输出数组相同的形状和缓冲区长度</td></tr><tr><td>ddof</td><td>自由度（Delta Degrees of Freedom），计算中使用的除数是 N-ddof，其中 N 表示元素的数量，ddof 默认为零</td></tr><tr><td>keepdims</td><td>bool 类型，可选项，是否保持数组的二维特性</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])&gt;&gt;&gt; print(a)[[1 2] [3 4]]&gt;&gt;&gt; &gt;&gt;&gt; print(np.std(a))1.118033988749895&gt;&gt;&gt; &gt;&gt;&gt; print(np.std(a, axis=0))[1. 1.]&gt;&gt;&gt; &gt;&gt;&gt; print(np.std(a, axis=1))[0.5 0.5]&gt;&gt;&gt; &gt;&gt;&gt; print(np.var(a))1.25&gt;&gt;&gt; &gt;&gt;&gt; print(np.var(a, axis=0))[1. 1.]&gt;&gt;&gt; &gt;&gt;&gt; print(np.var(a, axis=1))[0.25 0.25]</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105398131未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【5x00】NumPy-排序函数"><a href="#【5x00】NumPy-排序函数" class="headerlink" title="【5x00】NumPy 排序函数"></a><font color=#FF0000>【5x00】NumPy 排序函数</font></h2><p>NumPy 排序函数中可以指定使用的排序方法，各种分类算法的特征在于它们的平均速度，最坏情况下的性能，工作空间大小以及它们是否稳定，三种算法对比如下：</p><table><thead><tr><th>方法</th><th>速度</th><th>最坏情况</th><th>工作空间</th><th>稳定性</th></tr></thead><tbody><tr><td>快速排序（quicksort）</td><td>1</td><td>O(n^2)</td><td>0</td><td>no</td></tr><tr><td>归并排序（mergesort）</td><td>2</td><td>O(n*log(n))</td><td>~n/2</td><td>yes</td></tr><tr><td>堆排序（heapsort）</td><td>3</td><td>O(n*log(n))</td><td>0</td><td>no</td></tr></tbody></table><h3 id="【5x01】sort"><a href="#【5x01】sort" class="headerlink" title="【5x01】sort()"></a><font color=#1BC3FB>【5x01】sort()</font></h3><p><code>numpy.sort()</code> 函数会将原数组元素<font color=#FF0000><strong>从小到大排序</strong></font>，返回输入数组的排序副本。</p><p>基本语法：<code>numpy.sort(a[, axis=-1, kind=&#39;quicksort&#39;, order=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>要排序的数组</td></tr><tr><td>axis</td><td>要排序的轴，可选项，如果为 None，则在排序之前会将数组展平，默认值为 -1，它沿着最后一个轴排序</td></tr><tr><td>kind</td><td>排序算法，可选项，默认值为快速排序（quicksort）</td></tr><tr><td>order</td><td>字符串或者字符串列表，可选项，若指定 order 值，将按照该字段进行排序</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1,4],[3,1]])&gt;&gt;&gt; print(np.sort(a))[[1 4] [1 3]]&gt;&gt;&gt; &gt;&gt;&gt; print(np.sort(a, axis=None))   # 数组将展平[1 1 3 4]&gt;&gt;&gt; &gt;&gt;&gt; print(np.sort(a, axis=0))[[1 1] [3 4]]&gt;&gt;&gt; &gt;&gt;&gt; print(np.sort(a, axis=1))[[1 4] [1 3]]</code></pre><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; dtype = [(&#39;name&#39;, &#39;S10&#39;), (&#39;height&#39;, float), (&#39;age&#39;, int)]&gt;&gt;&gt; values = [(&#39;Arthur&#39;, 1.8, 41), (&#39;Lancelot&#39;, 1.9, 38), (&#39;Galahad&#39;, 1.7, 38)]&gt;&gt;&gt; a = np.array(values, dtype=dtype)&gt;&gt;&gt; print(a)[(b&#39;Arthur&#39;, 1.8, 41) (b&#39;Lancelot&#39;, 1.9, 38) (b&#39;Galahad&#39;, 1.7, 38)]&gt;&gt;&gt; &gt;&gt;&gt; print(np.sort(a, order=&#39;height&#39;))                # 按 height 排序[(b&#39;Galahad&#39;, 1.7, 38) (b&#39;Arthur&#39;, 1.8, 41) (b&#39;Lancelot&#39;, 1.9, 38)]&gt;&gt;&gt; &gt;&gt;&gt; print(np.sort(a, order=[&#39;age&#39;, &#39;height&#39;]))      # 按 age 排序，如果 age 相等，则按 height 排序[(b&#39;Galahad&#39;, 1.7, 38) (b&#39;Lancelot&#39;, 1.9, 38) (b&#39;Arthur&#39;, 1.8, 41)]</code></pre><h3 id="【5x02】msort"><a href="#【5x02】msort" class="headerlink" title="【5x02】msort()"></a><font color=#1BC3FB>【5x02】msort()</font></h3><p><code>numpy.msort()</code> 函数将数组<font color=#FF0000><strong>按第一个轴从小到大排序</strong></font>，返回排序后的数组副本，相当于 <code>numpy.sort(a, axis=0)</code></p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.msort([[1, 4, 5], [2, 1, 3]]))[[1 1 3] [2 4 5]]&gt;&gt;&gt; print(np.sort([[1, 4, 5], [2, 1, 3]], axis=0))[[1 1 3] [2 4 5]]</code></pre><h3 id="【5x03】argsort"><a href="#【5x03】argsort" class="headerlink" title="【5x03】argsort()"></a><font color=#1BC3FB>【5x03】argsort()</font></h3><p><code>numpy.argsort()</code> 函数将原数组元素<font color=#FF0000><strong>从小到大排列</strong></font>，提取其对应在原数组中的<font color=#FF0000><strong>索引值</strong></font>并返回。</p><p>举例：原数组为：<code>[3, 1, 2]</code>，从小到大排列：<code>[1, 2, 3]</code>，排列后的各元素在原数组中对应的索引值：<code>[1, 2, 0]</code></p><p>基本语法：<code>numpy.argsort(a[, axis=-1, kind=None, order=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>要排序的数组</td></tr><tr><td>axis</td><td>要排序的轴，可选项，如果为 None，则在排序之前会将数组展平，默认值为 -1，它沿着最后一个轴排序</td></tr><tr><td>kind</td><td>排序算法，可选项，默认值为快速排序（quicksort）</td></tr><tr><td>order</td><td>字符串或者字符串列表，可选项，若指定 order 值，将按照该字段进行排序</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([3, 1, 2])&gt;&gt;&gt; print(np.argsort(a))[1 2 0]&gt;&gt;&gt; &gt;&gt;&gt; b = np.array([[0, 3], [2, 2]])&gt;&gt;&gt; print(np.argsort(b))[[0 1] [0 1]]&gt;&gt;&gt; &gt;&gt;&gt; print(np.argsort(b, axis=0))[[0 1] [1 0]]&gt;&gt;&gt; &gt;&gt;&gt; print(np.argsort(b, axis=1))[[0 1] [0 1]]</code></pre><h3 id="【5x04】lexsort"><a href="#【5x04】lexsort" class="headerlink" title="【5x04】lexsort()"></a><font color=#1BC3FB>【5x04】lexsort()</font></h3><p><code>numpy.lexsort()</code> 函数使用键序列执行间接稳定排序，用于<font color=#FF0000><strong>对多个序列进行排序，返回其索引值</strong></font>。</p><p>基本语法：<code>numpy.lexsort(keys, axis=-1)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>keys</td><td>类似于 <code>(k, N)</code> 的要排序的数组</td></tr><tr><td>axis</td><td>指定要排序的轴，默认对最后一个轴进行排序</td></tr></tbody></table><p>举例：现有数组 <code>a = [1,5,1,4,3,4,4]</code>，<code>b = [9,4,0,4,0,2,1]</code>，利用 lexsort() 函数排序后的结果为：<code>[2,0,4,6,5,3,1]</code>，排序过程如下：</p><p>假设数组 a1 为语文成绩：<code>a1 = [1,5,1,4,3,4,4]</code><br>假设数组 b1 为数学成绩：<code>b1 = [9,4,0,4,0,2,1]</code><br>数组索引值 c1 为同学姓名： <code>c1 = [0,1,2,3,4,5,6]</code></p><p><font color=#FF0000><strong>1、首先按照语文成绩进行排名：</strong></font><br>语文成绩（数组 a）从小到大排名：<code>a2 =  [1,1,3,4,4,4,5]</code>，对应的学生姓名（索引值）为：<code>c2 = [0,2,4,3,5,6,1]</code>，现在可以看到：<br><font color=#1BC3FB><strong>0</strong></font>、<font color=#1BC3FB><strong>2</strong></font> 同学的语文成绩都一样，均为 <font color=#32CD32><strong>1</strong></font><br><font color=#1BC3FB><strong>3</strong></font>、<font color=#1BC3FB><strong>5</strong></font>、<font color=#1BC3FB><strong>6</strong></font> 同学的语文成绩都一样，均为 <font color=#32CD32><strong>4</strong></font></p><p><font color=#FF0000><strong>2、接下来，对于语文成绩相同的，按照他们的数学成绩再次进行排名：</strong></font><br><font color=#1BC3FB><strong>0</strong></font>、<font color=#1BC3FB><strong>2</strong></font> 同学对应的数学成绩分别为：<font color=#32CD32><strong>9</strong></font> 和 <font color=#32CD32><strong>0</strong></font>，从小到大再次排序，即 <font color=#1BC3FB><strong>0</strong></font> 排在 <font color=#1BC3FB><strong>2</strong></font> 的后面，对应的学生姓名为 <code>c3 = [2,0,4,3,5,6,1]</code><br><font color=#1BC3FB><strong>3</strong></font>、<font color=#1BC3FB><strong>5</strong></font>、<font color=#1BC3FB><strong>6</strong></font> 同学对应的数学成绩分别为：<font color=#32CD32><strong>4</strong></font>、<font color=#32CD32><strong>2</strong></font>、<font color=#32CD32><strong>1</strong></font>，从小到大再次排序后，对应的学生姓名为 <code>c4 = [2,0,4,6,5,3,1]</code>，即最终结果。</p><p>简单来说，先对数组 a 从小到大排序，提取排序后元素对应的索引值，排序后元素有相同的，再根据数组 b 从小到大排序，得到最终的索引值。</p><p>以上步骤用 <code>numpy.lexsort()</code> 函数实现如下：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = [1,5,1,4,3,4,4]&gt;&gt;&gt; b = [9,4,0,4,0,2,1]&gt;&gt;&gt; &gt;&gt;&gt; c1 = np.lexsort((a,b))    # 先按 b 排序，再按照 a 排序&gt;&gt;&gt; c2 = np.lexsort((b,a))    # 先按 a 排序，再按照 b 排序&gt;&gt;&gt; &gt;&gt;&gt; print(c1)[2 4 6 5 3 1 0]&gt;&gt;&gt; print(c2)[2 0 4 6 5 3 1]&gt;&gt;&gt; &gt;&gt;&gt; print([(a[i],b[i]) for i in c1])[(1, 0), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4), (1, 9)]&gt;&gt;&gt; print([(a[i],b[i]) for i in c2])[(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)]</code></pre><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; first_names = (&#39;Hertz&#39;, &#39;Galilei&#39;, &#39;Hertz&#39;)&gt;&gt;&gt; second_names = (&#39;Heinrich&#39;, &#39;Galileo&#39;, &#39;Gustav&#39;)&gt;&gt;&gt; &gt;&gt;&gt; print(np.lexsort((second_names, first_names)))   # 按照字母对应的 ascii 码从小到大进行排序[1 2 0]</code></pre><h3 id="【5x05】sort-complex"><a href="#【5x05】sort-complex" class="headerlink" title="【5x05】sort_complex()"></a><font color=#1BC3FB>【5x05】sort_complex()</font></h3><p><code>numpy.sort_complex()</code> 函数先使用实部，再使用虚部<font color=#FF0000><strong>对复数数组进行排序</strong></font>。</p><p>复数：把形如 z=a+bi（a,b 均为实数）的数称为复数，其中 a 称为实部，b 称为虚部，i 称为虚数单位。</p><p>基本语法：<code>numpy.sort_complex(a)</code></p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.sort_complex([5, 3, 6, 2, 1]))[1.+0.j 2.+0.j 3.+0.j 5.+0.j 6.+0.j]&gt;&gt;&gt; &gt;&gt;&gt; print(np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j]))[1.+2.j 2.-1.j 3.-3.j 3.-2.j 3.+5.j]</code></pre><h3 id="【5x06】partition"><a href="#【5x06】partition" class="headerlink" title="【5x06】partition()"></a><font color=#1BC3FB>【5x06】partition()</font></h3><p><code>numpy.partition()</code> 函数用于对数组进行<font color=#FF0000><strong>分区排序</strong></font>，返回数组的分区副本。</p><p>基本语法：<code>numpy.partition(a, kth[, axis=-1, kind=&#39;introselect&#39;, order=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>待排序数组</td></tr><tr><td>kth</td><td>整数或者整数序列，原数组元素中从小到大的第 k 个元素，在排序后的数组中，仍然处于第 k 位置<br>小于该元素的位于该元素的左边，大于该元素的位于该元素的右边，左右两边没有特别的排序要求</td></tr><tr><td>axis</td><td>指定要排序的轴，可选项，默认对最后一个轴进行排序</td></tr><tr><td>kind</td><td>排序算法，可选项，默认值为快速排序（quicksort）</td></tr><tr><td>order</td><td>字符串或者字符串列表，可选项，若指定 order 值，将按照该字段进行排序</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([3, 4, 2, 1])&gt;&gt;&gt; print(np.partition(a, 3))       # 原数组元素中从小到大的第 3 个元素，排序后仍然处于第 3 位置，小于 3 的在前面，大于 3 的在后面，前后无特别排序要求[2 1 3 4]&gt;&gt;&gt; &gt;&gt;&gt; print(np.partition(a, (1, 3)))  # 小于 1 的在前面，大于 3 的在后面，1 和 3 之间的在中间[1 2 3 4]</code></pre><h3 id="【5x07】argpartition"><a href="#【5x07】argpartition" class="headerlink" title="【5x07】argpartition()"></a><font color=#1BC3FB>【5x07】argpartition()</font></h3><p><code>numpy.argpartition()</code> 函数用于对数组进行<font color=#FF0000><strong>分区排序</strong></font>，返回重组后的<font color=#FF0000><strong>索引值数组</strong></font>。</p><p>利用该函数可以很快地找出第 k 大的数的位置，以及大于 k（排在 k 后面）和小于 k（排在 k 前面）的数的位置。</p><p>基本语法：<code>numpy.argpartition(a[, kth, axis=-1, kind=&#39;introselect&#39;, order=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>待排序数组</td></tr><tr><td>kth</td><td>整数或者整数序列，原数组元素中从小到大的第 k 个元素，在排序后的数组中，仍然处于第 k 位置<br>小于该元素的位于该元素的左边，大于该元素的位于该元素的右边，左右两边没有特别的排序要求</td></tr><tr><td>axis</td><td>指定要排序的轴，可选项，默认对最后一个轴进行排序</td></tr><tr><td>kind</td><td>排序算法，可选项，默认值为快速排序（quicksort）</td></tr><tr><td>order</td><td>字符串或者字符串列表，可选项，若指定 order 值，将按照该字段进行排序</td></tr></tbody></table><p>以下实例将找到数组的第 3 小（索引值 2）的值和第 2 大（索引值 -2）的值：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([46, 57, 23, 39, 1, 10, 0, 120])&gt;&gt;&gt; print(a[np.argpartition(a, 2)[2]])10&gt;&gt;&gt; print(a[np.argpartition(a, -2)[-2]])57</code></pre><h3 id="【5x08】unique"><a href="#【5x08】unique" class="headerlink" title="【5x08】unique()"></a><font color=#1BC3FB>【5x08】unique()</font></h3><p><code>numpy.unique()</code> 函数<font color=#FF0000><strong>找到唯一值并返回从小到大的排序结果</strong></font>，类似于 Python 的 set 集合。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.unique([1, 1, 2, 2, 3, 3]))[1 2 3]&gt;&gt;&gt; &gt;&gt;&gt; a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])&gt;&gt;&gt; print(np.unique(a, axis=0))[[1 0 0] [2 3 4]]</code></pre><h2 id="【6x00】NumPy-条件函数"><a href="#【6x00】NumPy-条件函数" class="headerlink" title="【6x00】NumPy 条件函数"></a><font color=#FF0000>【6x00】NumPy 条件函数</font></h2><h3 id="【6x01】nonzero"><a href="#【6x01】nonzero" class="headerlink" title="【6x01】nonzero()"></a><font color=#1BC3FB>【6x01】nonzero()</font></h3><p><code>numpy.nonzero()</code> 函数将返回原数组中<font color=#FF0000><strong>非零元素的索引值</strong></font>。</p><p>基本语法：<code>numpy.nonzero(a)</code></p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])&gt;&gt;&gt; print(np.nonzero(a))(array([0, 1, 2, 2], dtype=int32),  array([0, 1, 0, 1], dtype=int32))</code></pre><p>返回两个数组，其中的元素一一对应，比如数字 <code>3</code> 的索引值为 <code>(0,0)</code>，数字 <code>4</code> 的索引值为 <code>(1,1)</code></p><h3 id="【6x02】where"><a href="#【6x02】where" class="headerlink" title="【6x02】where()"></a><font color=#1BC3FB>【6x02】where()</font></h3><p><code>numpy.where()</code> 函数<font color=#FF0000><strong>返回数组中满足指定条件的元素的索引值</strong></font>。</p><p>基本语法：<code>numpy.where(condition[, x, y])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>condition</td><td>判断条件，如果满足该条件，则产生 x，否则产生 y，若未指定 x 与 y，则返回满足该条件元素的索引值</td></tr><tr><td>x, y</td><td>返回的值为数组对象，如果满足 condition，则产生 x，否则产生 y</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([12, 7, 9, 10, 21, 5, 11, 1])&gt;&gt;&gt;&gt;&gt;&gt; print(np.where(a&gt;8))(array([0, 2, 3, 4, 6], dtype=int32),)         # 返回满足 a&gt;8 的元素的索引值&gt;&gt;&gt; &gt;&gt;&gt; print(np.where(a&gt;8, a, 10*a))              # 如果原数组中的元素 a&gt;8，则返回 a，否则返回 10*a[12 70  9 10 21 50 11 10]</code></pre><h3 id="【6x03】extract"><a href="#【6x03】extract" class="headerlink" title="【6x03】extract()"></a><font color=#1BC3FB>【6x03】extract()</font></h3><p><code>numpy.extract()</code> 函数<font color=#FF0000><strong>返回数组中满足指定条件的元素</strong></font>。</p><p>基本语法：<code>numpy.extract(condition, arr)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>condition</td><td>判断条件</td></tr><tr><td>arr</td><td>原数组</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([12, 7, 9, 10, 21, 5, 11, 1])&gt;&gt;&gt; print(np.extract(a&gt;8, a))[12  9 10 21 11]</code></pre><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(9).reshape(3,3)&gt;&gt;&gt; print(a)[[0 1 2] [3 4 5] [6 7 8]]&gt;&gt;&gt; &gt;&gt;&gt; condition = np.mod(a,2) == 0     # 定义筛选条件（余数为 0，即偶数）&gt;&gt;&gt; print(condition)[[ True False  True] [False  True False] [ True False  True]]&gt;&gt;&gt;&gt;&gt;&gt; print(np.extract(condition, a))[0 2 4 6 8]</code></pre><h2 id="【7x00】NumPy-判断函数"><a href="#【7x00】NumPy-判断函数" class="headerlink" title="【7x00】NumPy 判断函数"></a><font color=#FF0000>【7x00】NumPy 判断函数</font></h2><h3 id="【7x01】any-all"><a href="#【7x01】any-all" class="headerlink" title="【7x01】any() / all()"></a><font color=#1BC3FB>【7x01】any() / all()</font></h3><p><code>numpy.any()</code>：如果<font color=#FF0000><strong>至少有一个</strong></font>元素满足指定条件，则返回 True，否则返回 False。</p><p><code>numpy.all()</code>：如果<font color=#FF0000><strong>所有</strong></font>的元素满足指定条件，则返回 True，否则返回 False。</p><p>基本语法：<code>numpy.any(a[, axis=None, out=None, keepdims=&lt;no value&gt;])</code>；<code>numpy.all(a[, axis=None, out=None, keepdims=&lt;no value&gt;])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>待处理的数组对象</td></tr><tr><td>axis</td><td>指定轴，可选项，整数或者整数元组类型</td></tr><tr><td>out</td><td>可选项，放置结果的备用输出数组，必须具有与预期输出数组相同的形状和缓冲区长度</td></tr><tr><td>keepdims</td><td>bool 类型，可选项，是否保持数组的二维特性</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.any([[True, False], [True, True]]))True&gt;&gt;&gt; &gt;&gt;&gt; a = np.array([-3, -2, 4, 2, 8, 1])&gt;&gt;&gt; print(np.any(a&lt;0))True</code></pre><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.all([[True, False], [True, True]]))False&gt;&gt;&gt; &gt;&gt;&gt; a = np.array([-3, -2, 4, 2, 8, 1])&gt;&gt;&gt; print(np.all(a&lt;0))False</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105398131未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> NumPy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 NumPy（四）：字符串函数总结与对比</title>
      <link href="/article/011/"/>
      <url>/article/011/</url>
      
        <content type="html"><![CDATA[<p>NumPy 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/008/">Python 数据分析三剑客之 NumPy（一）：理解 NumPy / 数组基础</a></li><li><a href="https://www.itbob.cn/article/009/">Python 数据分析三剑客之 NumPy（二）：数组索引 / 切片 / 广播 / 拼接 / 分割</a></li><li><a href="https://www.itbob.cn/article/010/">Python 数据分析三剑客之 NumPy（三）：数组的迭代与位运算</a></li><li><a href="https://www.itbob.cn/article/011/">Python 数据分析三剑客之 NumPy（四）：字符串函数总结与对比</a></li><li><a href="https://www.itbob.cn/article/012/">Python 数据分析三剑客之 NumPy（五）：数学 / 算术 / 统计 / 排序 / 条件 / 判断函数合集</a></li><li><a href="https://www.itbob.cn/article/013/">Python 数据分析三剑客之 NumPy（六）：矩阵 / 线性代数库与 IO 操作</a></li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105350414未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【01】NumPy-字符串函数速查表"><a href="#【01】NumPy-字符串函数速查表" class="headerlink" title="【01】NumPy 字符串函数速查表"></a><font color=#ff0000>【01】NumPy 字符串函数速查表</font></h2><p>和 Python 一样，NumPy 也可以进行字符串相关操作。字符串函数在字符数组类（<code>numpy.char</code>）中定义。</p><table><tr><td bgcolor=#7FFFD4>NumPy 字符串函数速查表</td></tr></table><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>add()</td><td>对两个数组的字符串元素进行连接</td></tr><tr><td>join()</td><td>通过指定分隔符来连接数组中的元素</td></tr><tr><td>mod()</td><td>格式化字符串，相当于 Python 字符串中的 % 和 format</td></tr><tr><td>multiply()</td><td>按照给定值返回元素多重连接后的字符串</td></tr><tr><td>capitalize()</td><td>将字符串（字符串可同时包含字母和数字，只要是连续的都会被视为一个同字符串）第一个字母转换为大写</td></tr><tr><td>title()</td><td>将单词（仅包含字母，若同时包含数字和字母，则数字之后元素被视为另一个单词）第一个字母转换为大写</td></tr><tr><td>lower()</td><td>将数组中所有的元素转换为小写</td></tr><tr><td>upper()</td><td>将数组中所有的元素转换为大写</td></tr><tr><td>swapcase()</td><td>将数组中每个元素字母大写转为小写，小写转为大写</td></tr><tr><td>center()</td><td>居中字符串，并使用指定字符在左右侧进行填充</td></tr><tr><td>ljust()</td><td>左对齐字符串，并使用指定字符在右侧进行填充</td></tr><tr><td>rjust()</td><td>右对齐字符串，并使用指定字符在左侧进行填充</td></tr><tr><td>zfill()</td><td>在数组元素的左边填充指定个数的数字 0</td></tr><tr><td>strip()</td><td>移除数组每个元素开头和者结尾处的特定字符</td></tr><tr><td>lstrip()</td><td>移除数组每个元素开头（最左边）的特定字符</td></tr><tr><td>rstrip()</td><td>移除数组每个元素结尾（最右边）的特定字符</td></tr><tr><td>partition()</td><td>指定分割符对字符串进行分割（从最左边的分割符开始分割，仅分割一次，返回三个元素）</td></tr><tr><td>rpartition()</td><td>指定分割符对字符串进行分割（从最右边的分割符开始分割，仅分割一次，返回三个元素）</td></tr><tr><td>split()</td><td>指定分割符对字符串进行分割（从最左边的分割符开始分割，可指定分割次数，返回多个元素）</td></tr><tr><td>rsplit()</td><td>指定分割符对字符串进行分割（从最右边的分割符开始分割，可指定分割次数，返回多个元素）</td></tr><tr><td>replace()</td><td>使用新字符串替换原字符串中的子字符串</td></tr><tr><td>splitlines()</td><td>以换行符作为分隔符来分割字符串</td></tr><tr><td>translate()</td><td>将数组元素字符串按照给定的转换表进行映射</td></tr><tr><td>encode()</td><td>编码操作，数组元素依次调用 str.encode</td></tr><tr><td>decode()</td><td>解码操作，数组元素依次调用 str.decode</td></tr></tbody></table><h2 id="【02】numpy-char-add"><a href="#【02】numpy-char-add" class="headerlink" title="【02】numpy.char.add()"></a><font color=#ff0000>【02】numpy.char.add()</font></h2><p>numpy.char.add() 函数用于对两个数组的字符串元素进行连接。</p><p>基本语法：<code>numpy.char.add(x1, x2)</code>，数组 x1 和 x2 必须具有相同的形状。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>x1</td><td>要处理的 str 或 unicode 数组</td></tr><tr><td>x2</td><td>要处理的 str 或 unicode 数组</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.add([&#39;hello&#39;],[&#39; world&#39;]))[&#39;hello world&#39;]&gt;&gt;&gt; print(np.char.add([&#39;123&#39;, &#39;abc&#39;], [&#39; 456&#39;, &#39; def&#39;]))[&#39;123 456&#39; &#39;abc def&#39;]</code></pre><h2 id="【03】numpy-char-join"><a href="#【03】numpy-char-join" class="headerlink" title="【03】numpy.char.join()"></a><font color=#ff0000>【03】numpy.char.join()</font></h2><p>numpy.char.join() 函数通过指定分隔符来连接数组中的元素。</p><p>基本语法：<code>numpy.char.join(sep1, seq2)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>seq1</td><td>分割符，str 或 unicode 数组</td></tr><tr><td>seq2</td><td>被分割的 str 或 unicode 数组</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.join(&#39;-&#39;, &#39;python&#39;))p-y-t-h-o-n&gt;&gt;&gt;&gt;&gt;&gt; print(np.char.join([&#39;+&#39;,&#39;-&#39;],[&#39;python&#39;,&#39;java&#39;]))[&#39;p+y+t+h+o+n&#39; &#39;j-a-v-a&#39;]</code></pre><h2 id="【04】numpy-char-mod"><a href="#【04】numpy-char-mod" class="headerlink" title="【04】numpy.char.mod()"></a><font color=#ff0000>【04】numpy.char.mod()</font></h2><p>numpy.char.mod() 函数用于格式化字符串，相当于 Python 字符串中的 % 和 format。</p><p>基本语法：<code>numpy.char.mod(value , a)</code></p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.mod(&#39;value=%.2f&#39;, np.arange(6)))[&#39;value=0.00&#39; &#39;value=1.00&#39; &#39;value=2.00&#39; &#39;value=3.00&#39; &#39;value=4.00&#39; &#39;value=5.00&#39;]&gt;&gt;&gt;&gt;&gt;&gt; print(np.char.mod(&#39;value=%.4f&#39;, [[1.1, 2, 3.021], [4.12, 5, 6.1]]))[[&#39;value=1.1000&#39; &#39;value=2.0000&#39; &#39;value=3.0210&#39;] [&#39;value=4.1200&#39; &#39;value=5.0000&#39; &#39;value=6.1000&#39;]]</code></pre><h2 id="【05】numpy-char-multiply"><a href="#【05】numpy-char-multiply" class="headerlink" title="【05】numpy.char.multiply()"></a><font color=#ff0000>【05】numpy.char.multiply()</font></h2><p>numpy.char.multiply() 函数用于元素的多重连接，即返回 <code>a*i</code>。</p><p>基本语法：<code>numpy.char.multiply(a, i)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>要处理的 str 或 unicode 数组</td></tr><tr><td>i</td><td>整数数组</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.multiply(&#39;Python &#39;, 4))Python Python Python Python</code></pre><h2 id="【06】numpy-char-capitalize"><a href="#【06】numpy-char-capitalize" class="headerlink" title="【06】numpy.char.capitalize()"></a><font color=#ff0000>【06】numpy.char.capitalize()</font></h2><p>numpy.char.capitalize() 函数将字符串第一个字母转换为大写。</p><p>基本语法：<code>numpy.char.capitalize(a)</code></p><p>参数解释：<code>a</code>：要处理的 str 或 unicode 数组。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.capitalize(&#39;python&#39;))Python&gt;&gt;&gt; print(np.char.capitalize([&#39;a1b2&#39;,&#39;1b2a&#39;,&#39;b2a1&#39;,&#39;2a1b&#39;]))[&#39;A1b2&#39; &#39;1b2a&#39; &#39;B2a1&#39; &#39;2a1b&#39;]</code></pre><h2 id="【07】numpy-char-title"><a href="#【07】numpy-char-title" class="headerlink" title="【07】numpy.char.title()"></a><font color=#ff0000>【07】numpy.char.title()</font></h2><p>numpy.char.title() 函数将数组元素字符串的每个单词的第一个字母转换为大写。<font color=#ff0000>注意：如果一个字符串中间有非字母，则非字母之后的字符串会被视为另一个单词。</font></p><p>基本语法：<code>numpy.char.title(a)</code></p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.title(&#39;i love python!&#39;))I Love Python!&gt;&gt;&gt; print(np.char.title(&#39;a1bc2def3h&#39;))A1Bc2Def3H&gt;&gt;&gt; print(np.char.title([&#39;a1bc&#39;, &#39;a 1bc&#39;, &#39;a1 bc&#39;, &#39;a1b c&#39;]))[&#39;A1Bc&#39; &#39;A 1Bc&#39; &#39;A1 Bc&#39; &#39;A1B C&#39;]</code></pre><h2 id="【08】numpy-char-lower"><a href="#【08】numpy-char-lower" class="headerlink" title="【08】numpy.char.lower()"></a><font color=#ff0000>【08】numpy.char.lower()</font></h2><p>numpy.char.lower() 函数将数组中所有的元素转换为小写。</p><p>基本语法：<code>numpy.char.lower(a)</code></p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.lower(&#39;PYTHON&#39;))python&gt;&gt;&gt; print(np.char.lower([&#39;PYTHON&#39;, &#39;A123C&#39;, &#39;Ba1A&#39;]))[&#39;python&#39; &#39;a123c&#39; &#39;ba1a&#39;]</code></pre><h2 id="【09】numpy-char-upper"><a href="#【09】numpy-char-upper" class="headerlink" title="【09】numpy.char.upper()"></a><font color=#ff0000>【09】numpy.char.upper()</font></h2><p>numpy.char.upper() 函数将数组中所有的元素转换为大写。</p><p>基本语法：<code>numpy.char.upper(a)</code></p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.upper(&#39;python&#39;))PYTHON&gt;&gt;&gt; print(np.char.upper([&#39;python&#39;, &#39;a123c&#39;, &#39;ba1A&#39;]))[&#39;PYTHON&#39; &#39;A123C&#39; &#39;BA1A&#39;]</code></pre><h2 id="【10】numpy-char-swapcase"><a href="#【10】numpy-char-swapcase" class="headerlink" title="【10】numpy.char.swapcase()"></a><font color=#ff0000>【10】numpy.char.swapcase()</font></h2><p>numpy.char.swapcase() 函数将数组中每个元素字母大写转为小写，小写转为大写。</p><p>基本语法：<code>numpy.char.swapcase(a)</code></p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.swapcase(&#39;Abc123DEf456gHI&#39;))aBC123deF456Ghi&gt;&gt;&gt; print(np.char.swapcase([&#39;Abc&#39;, &#39;1De&#39;, &#39;23F&#39;, &#39;Ghi&#39;]))[&#39;aBC&#39; &#39;1dE&#39; &#39;23f&#39; &#39;gHI&#39;]</code></pre><h2 id="【11】numpy-char-center"><a href="#【11】numpy-char-center" class="headerlink" title="【11】numpy.char.center()"></a><font color=#ff0000>【11】numpy.char.center()</font></h2><p>numpy.char.center() 函数用于<font color=#FF000000><strong>居中</strong></font>字符串，并使用指定字符在<font color=#FF000000><strong>左右侧</strong></font>进行填充。</p><p>基本语法：<code>numpy.char.center(a, width[, fillchar=&#39; &#39;])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>要处理的 str 或 unicode 数组</td></tr><tr><td>width</td><td>int 类型，结果字符串的总长度</td></tr><tr><td>fillchar</td><td>可选项，str 或 unicode 数组，要使用的填充字符，默认为空格</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.center(&#39;python&#39;, 10))  python  &gt;&gt;&gt; print(np.char.center(&#39;python&#39;, 12, fillchar=&#39;-&#39;))---python---&gt;&gt;&gt; print(np.char.center(&#39;python&#39;, 11, fillchar=&#39;-&#39;))---python--</code></pre><h2 id="【12】numpy-char-ljust"><a href="#【12】numpy-char-ljust" class="headerlink" title="【12】numpy.char.ljust()"></a><font color=#ff0000>【12】numpy.char.ljust()</font></h2><p>numpy.char.ljust() 函数用于<font color=#FF000000><strong>左对齐</strong></font>字符串，并使用指定字符在<font color=#FF000000><strong>右侧</strong></font>进行填充。</p><p>基本语法：<code>numpy.char.ljust(a, width[, fillchar=&#39; &#39;])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>要处理的 str 或 unicode 数组</td></tr><tr><td>width</td><td>int 类型，结果字符串的总长度</td></tr><tr><td>fillchar</td><td>可选项，str 或 unicode 数组，要使用的填充字符，默认为空格</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.ljust(&#39;python&#39;, 10, fillchar=&#39;-&#39;))python----</code></pre><h2 id="【13】numpy-char-rjust"><a href="#【13】numpy-char-rjust" class="headerlink" title="【13】numpy.char.rjust()"></a><font color=#ff0000>【13】numpy.char.rjust()</font></h2><p>numpy.char.ljust() 函数用于<font color=#FF000000><strong>右对齐</strong></font>字符串，并使用指定字符在<font color=#FF000000><strong>左侧</strong></font>进行填充。</p><p>基本语法：<code>numpy.char.rjust(a, width[, fillchar=&#39; &#39;])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>要处理的 str 或 unicode 数组</td></tr><tr><td>width</td><td>int 类型，结果字符串的总长度</td></tr><tr><td>fillchar</td><td>可选项，str 或 unicode 数组，要使用的填充字符，默认为空格</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.rjust(&#39;python&#39;, 10, fillchar=&#39;-&#39;))----python</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105350414未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【14】numpy-char-zfill"><a href="#【14】numpy-char-zfill" class="headerlink" title="【14】numpy.char.zfill()"></a><font color=#ff0000>【14】numpy.char.zfill()</font></h2><p>numpy.char.zfill() 函数在数组元素的左边填充指定个数的数字 0。</p><p>基本语法：<code>numpy.char.zfill(a, width)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>要处理的 str 或 unicode 数组</td></tr><tr><td>width</td><td>int 类型，数组字符串在左边填充 0 后整个字符串的宽度<br>如果宽度小于原字符串的宽度，则结果会去掉原字符串中多余的元素</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.zfill(&#39;python&#39;, 3))pyt&gt;&gt;&gt; print(np.char.zfill(&#39;python&#39;, 10))0000python</code></pre><h2 id="【15】numpy-char-strip"><a href="#【15】numpy-char-strip" class="headerlink" title="【15】numpy.char.strip()"></a><font color=#ff0000>【15】numpy.char.strip()</font></h2><p>numpy.char.strip() 函数用于移除开头和结尾处的特定字符。</p><p>基本语法：<code>numpy.char.strip(a[, chars=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>要处理的 str 或 unicode 数组</td></tr><tr><td>chars</td><td>可选项，str 类型，指定要删除的字符集，如果省略或者为 None，则默认为删除空白</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.strip(&#39;alibaba&#39;,&#39;a&#39;))libab&gt;&gt;&gt; &gt;&gt;&gt; print(np.char.strip([&#39;Alibaba&#39;,&#39;admin&#39;,&#39;java&#39;, &#39;ABBA&#39;],&#39;a&#39;))[&#39;Alibab&#39; &#39;dmin&#39; &#39;jav&#39; &#39;ABBA&#39;]</code></pre><h2 id="【16】numpy-char-lstrip"><a href="#【16】numpy-char-lstrip" class="headerlink" title="【16】numpy.char.lstrip()"></a><font color=#ff0000>【16】numpy.char.lstrip()</font></h2><p>numpy.char.lstrip() 函数用于移除数组每个元素最右边的特定字符。</p><p>基本语法：<code>numpy.char.lstrip(a[, chars=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>要处理的 str 或 unicode 数组</td></tr><tr><td>chars</td><td>可选项，str 类型，指定要删除的字符集，如果省略或者为 None，则默认为删除空白</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.lstrip(&#39;alibaba&#39;,&#39;a&#39;))libaba&gt;&gt;&gt; &gt;&gt;&gt; print(np.char.lstrip([&#39;Alibaba&#39;,&#39;admin&#39;,&#39;java&#39;, &#39;aBBa&#39;],&#39;a&#39;))[&#39;Alibaba&#39; &#39;dmin&#39; &#39;java&#39; &#39;BBa&#39;]</code></pre><h2 id="【17】numpy-char-rstrip"><a href="#【17】numpy-char-rstrip" class="headerlink" title="【17】numpy.char.rstrip()"></a><font color=#ff0000>【17】numpy.char.rstrip()</font></h2><p>numpy.char.rstrip() 函数用于移除数组每个元素最右边的特定字符。</p><p>基本语法：<code>numpy.char.rstrip(a[, chars=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>要处理的 str 或 unicode 数组</td></tr><tr><td>chars</td><td>可选项，str 类型，指定要删除的字符集，如果省略或者为 None，则默认为删除空白</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.rstrip(&#39;alibaba&#39;,&#39;a&#39;))alibab&gt;&gt;&gt; print(np.char.rstrip([&#39;Alibaba&#39;,&#39;admin&#39;,&#39;java&#39;, &#39;aBBa&#39;],&#39;a&#39;))[&#39;Alibab&#39; &#39;admin&#39; &#39;jav&#39; &#39;aBB&#39;]</code></pre><h2 id="【18】numpy-char-partition"><a href="#【18】numpy-char-partition" class="headerlink" title="【18】numpy.char.partition()"></a><font color=#ff0000>【18】numpy.char.partition()</font></h2><p>numpy.char.partition() 函数通过指定分割符对字符串进行分割，从<font color=#FF0000><strong>最左边</strong></font>第一次出现的分割符开始分割，仅分割一次，返回三个元素。</p><p>基本语法：<code>numpy.char.partition(a, sep)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>要处理的 str 或 unicode 数组</td></tr><tr><td>sep</td><td>分割字符，str 或 unicode 类型，返回三个元素：分割字符前的字符，分割字符，分割字符后的字符<br>如果元素包含多个分割字符，以<font color=#FF0000><strong>最左边</strong></font>的为准，如果找不到分隔符，则返回三个元素：<font color=#FF0000><strong>字符串本身以及两个空字符串</strong></font></td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; print(np.char.partition(&#39;111a222&#39;,&#39;a&#39;))[&#39;111&#39; &#39;a&#39; &#39;222&#39;]&gt;&gt;&gt; print(np.char.partition(&#39;111a222a333&#39;,&#39;a&#39;))[&#39;111&#39; &#39;a&#39; &#39;222a333&#39;]&gt;&gt;&gt; print(np.char.partition(&#39;111a222a333&#39;,&#39;b&#39;))[&#39;111a222a333&#39; &#39;&#39; &#39;&#39;]&gt;&gt;&gt; print(np.char.partition([&#39;111a222&#39;, &#39;23a45&#39;],&#39;a&#39;))[[&#39;111&#39; &#39;a&#39; &#39;222&#39;] [&#39;23&#39; &#39;a&#39; &#39;45&#39;]]</code></pre><h2 id="【19】numpy-char-rpartition"><a href="#【19】numpy-char-rpartition" class="headerlink" title="【19】numpy.char.rpartition()"></a><font color=#ff0000>【19】numpy.char.rpartition()</font></h2><p>numpy.char.partition() 函数通过指定分割符对字符串进行分割，从<font color=#FF0000><strong>最右边</strong></font>第一次出现的分割符开始分割，仅分割一次，返回三个元素。</p><p>基本语法：<code>numpy.char.rpartition(a, sep)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>要处理的 str 或 unicode 数组</td></tr><tr><td>sep</td><td>分割字符，str 或 unicode 类型，返回三个元素：分割字符前的字符，分割字符，分割字符后的字符<br>如果元素包含多个分割字符，以<font color=#FF0000><strong>最右边</strong></font>的为准，如果找不到分隔符，则返回三个元素：<font color=#FF0000><strong>两个空字符串以及字符串本身</strong></font></td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.rpartition(&#39;111a222a333&#39;,&#39;a&#39;))[&#39;111a222&#39; &#39;a&#39; &#39;333&#39;]&gt;&gt;&gt; print(np.char.rpartition(&#39;111a222a333&#39;,&#39;b&#39;))[&#39;&#39; &#39;&#39; &#39;111a222a333&#39;]&gt;&gt;&gt; print(np.char.rpartition([&#39;111a222a333&#39;, &#39;23a45&#39;],&#39;a&#39;))[[&#39;111a222&#39; &#39;a&#39; &#39;333&#39;] [&#39;23&#39; &#39;a&#39; &#39;45&#39;]]</code></pre><h2 id="【20】numpy-char-split"><a href="#【20】numpy-char-split" class="headerlink" title="【20】numpy.char.split()"></a><font color=#ff0000>【20】numpy.char.split()</font></h2><p>numpy.char.split() 函数通过指定分割符对字符串进行分割，从<font color=#FF0000><strong>最左边</strong></font>的分割符开始分割，可指定分割次数，返回多个元素。</p><p>基本语法：<code>numpy.char.split(a[, sep=None, maxsplit=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>要处理的 str 或 unicode 数组</td></tr><tr><td>sep</td><td>分隔符，可选项，str 或者 unicode 类型，如果 sep 未指定或者为 None，则默认为空格</td></tr><tr><td>maxsplit</td><td>可选项，int 类型，如果指定 maxsplit，则最多完成 maxsplit 次分割</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.split(&#39;I love python!&#39;))[&#39;I&#39;, &#39;love&#39;, &#39;python!&#39;]&gt;&gt;&gt; print(np.char.split(&#39;www.itrhx.com&#39;, sep=&#39;.&#39;))[&#39;www&#39;, &#39;itrhx&#39;, &#39;com&#39;]&gt;&gt;&gt; print(np.char.split(&#39;one.two.itrhx.com&#39;, sep=&#39;.&#39;, maxsplit=2))[&#39;one&#39;, &#39;two&#39;, &#39;itrhx.com&#39;]&gt;&gt;&gt; print(np.char.split(&#39;one.two.itrhx.com&#39;, &#39;.&#39;, 2))[&#39;one&#39;, &#39;two&#39;, &#39;itrhx.com&#39;]</code></pre><h2 id="【21】numpy-char-rsplit"><a href="#【21】numpy-char-rsplit" class="headerlink" title="【21】numpy.char.rsplit()"></a><font color=#ff0000>【21】numpy.char.rsplit()</font></h2><p>numpy.char.split() 函数通过指定分割符对字符串进行分割，从<font color=#FF0000><strong>最右边</strong></font>的分割符开始分割，可指定分割次数，返回多个元素。</p><p>基本语法：<code>numpy.char.rsplit(a[, sep=None, maxsplit=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>要处理的 str 或 unicode 数组</td></tr><tr><td>sep</td><td>分隔符，可选项，str 或者 unicode 类型，如果 sep 未指定或者为 None，则默认为空格</td></tr><tr><td>maxsplit</td><td>可选项，int 类型，如果指定 maxsplit，则最多完成 maxsplit 次分割</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.rsplit(&#39;one.two.itrhx.com&#39;, &#39;.&#39;, 2))[&#39;one.two&#39;, &#39;itrhx&#39;, &#39;com&#39;]</code></pre><h2 id="【22】numpy-char-replace"><a href="#【22】numpy-char-replace" class="headerlink" title="【22】numpy.char.replace()"></a><font color=#ff0000>【22】numpy.char.replace()</font></h2><p>numpy.char.replace() 函数可以使用新字符串来替换原字符串中的子字符串。</p><p>基本语法：<code>numpy.char.replace(a, old, new[, count=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>要处理的 str 或 unicode 数组</td></tr><tr><td>old</td><td>旧的字符串，即要替换的字符串，str 或 unicode 类型</td></tr><tr><td>new</td><td>新的字符串，即替换的字符串，str 或 unicode 类型</td></tr><tr><td>count</td><td>int 类型，如果指定该值 N，则会替换 old 中出现的前 N 个字符串</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.replace(&#39;i like python&#39;, &#39;python&#39;, &#39;java&#39;))i like java&gt;&gt;&gt; &gt;&gt;&gt; print(np.char.replace(&#39;aaaaaaa&#39;, &#39;a&#39;, &#39;b&#39;, count=3))bbbaaaa&gt;&gt;&gt;&gt;&gt;&gt; print(np.char.replace(&#39;a111a11a1a111aa&#39;, &#39;a&#39;, &#39;A&#39;, count=3))A111A11A1a111aa</code></pre><h2 id="【23】numpy-char-splitlines"><a href="#【23】numpy-char-splitlines" class="headerlink" title="【23】numpy.char.splitlines()"></a><font color=#ff0000>【23】numpy.char.splitlines()</font></h2><p>numpy.char.splitlines() 函数以换行符作为分隔符来分割字符串，并返回数组。</p><p>基本语法：<code>numpy.char.splitlines(a[, keepends=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>要处理的 str 或 unicode 数组</td></tr><tr><td>keepends</td><td>如果指定 keepends 为 True，则换行符会包含在结果列表中，否则不包含</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.splitlines(&#39;hi python!\nhi java!&#39;))[&#39;hi python!&#39;, &#39;hi java!&#39;]&gt;&gt;&gt; print(np.char.splitlines(&#39;hi python!\nhi java!&#39;, keepends=True))[&#39;hi python!\n&#39;, &#39;hi java!&#39;]</code></pre><h2 id="【24】numpy-char-translate"><a href="#【24】numpy-char-translate" class="headerlink" title="【24】numpy.char.translate()"></a><font color=#ff0000>【24】numpy.char.translate()</font></h2><p>numpy.char.translate() 函数将数组元素字符串按照给定的转换表进行映射。</p><p>基本语法：<code>numpy.char.translate(a, table[, deletechars=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>要处理的 str 或 unicode 数组</td></tr><tr><td>table</td><td>包含 256 个字符的映射表，映射表通过 <code>str.maketrans()</code> 方法转换而来</td></tr><tr><td>deletechars</td><td>可选项，str 类型，字符串中要过滤的字符列表</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; intab = &#39;abcdef&#39;&gt;&gt;&gt; outtab = &#39;123456&#39;&gt;&gt;&gt; table = str.maketrans(intab, outtab)    #  制作映射表&gt;&gt;&gt; print(np.char.translate(&#39;this is a translate example!&#39;, table))this is 1 tr1nsl1t5 5x1mpl5!</code></pre><h2 id="【25】numpy-char-encode"><a href="#【25】numpy-char-encode" class="headerlink" title="【25】numpy.char.encode()"></a><font color=#ff0000>【25】numpy.char.encode()</font></h2><p>numpy.char.encode() 函数用于编码操作，数组元素依次调用 str.encode，可以使用 Python 标准库中的编解码器。</p><p>基本语法：<code>numpy.char.encode(a[, encoding=None, errors=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>要处理的 str 或 unicode 数组</td></tr><tr><td>encoding</td><td>编码名称，可选项，str 类型，默认编码为 utf-8</td></tr><tr><td>errors</td><td>指定如何处理编码错误，可选项，str 类型</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.encode(&#39;python&#39;, &#39;cp500&#39;))b&#39;\x97\xa8\xa3\x88\x96\x95&#39;&gt;&gt;&gt;&gt;&gt;&gt; print(np.char.encode([&#39;aAaAaA&#39;, &#39;  aA  &#39;, &#39;abBABba&#39;], &#39;cp037&#39;))[b&#39;\x81\xc1\x81\xc1\x81\xc1&#39; b&#39;@@\x81\xc1@@&#39; b&#39;\x81\x82\xc2\xc1\xc2\x82\x81&#39;]</code></pre><h2 id="【26】numpy-char-decode"><a href="#【26】numpy-char-decode" class="headerlink" title="【26】numpy.char.decode()"></a><font color=#ff0000>【26】numpy.char.decode()</font></h2><p>numpy.char.decode() 函数用于解码操作，数组元素依次调用 str.decode，可以使用 Python 标准库中的编解码器。</p><p>基本语法：<code>numpy.char.decode(a[, encoding=None, errors=None])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>要处理的 str 或 unicode 数组</td></tr><tr><td>encoding</td><td>编码名称，可选项，str 类型，默认编码为 utf-8</td></tr><tr><td>errors</td><td>指定如何处理编码错误，可选项，str 类型</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.char.decode(b&#39;\x97\xa8\xa3\x88\x96\x95&#39;, &#39;cp500&#39;))python&gt;&gt;&gt;&gt;&gt;&gt; print(np.char.decode([b&#39;\x81\xc1\x81\xc1\x81\xc1&#39; b&#39;@@\x81\xc1@@&#39; b&#39;\x81\x82\xc2\xc1\xc2\x82\x81&#39;], &#39;cp500&#39;))[&#39;aAaAaA  aA  abBABba&#39;]</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105350414未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> NumPy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 NumPy（三）：数组的迭代与位运算</title>
      <link href="/article/010/"/>
      <url>/article/010/</url>
      
        <content type="html"><![CDATA[<p>NumPy 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/008/">Python 数据分析三剑客之 NumPy（一）：理解 NumPy / 数组基础</a></li><li><a href="https://www.itbob.cn/article/009/">Python 数据分析三剑客之 NumPy（二）：数组索引 / 切片 / 广播 / 拼接 / 分割</a></li><li><a href="https://www.itbob.cn/article/010/">Python 数据分析三剑客之 NumPy（三）：数组的迭代与位运算</a></li><li><a href="https://www.itbob.cn/article/011/">Python 数据分析三剑客之 NumPy（四）：字符串函数总结与对比</a></li><li><a href="https://www.itbob.cn/article/012/">Python 数据分析三剑客之 NumPy（五）：数学 / 算术 / 统计 / 排序 / 条件 / 判断函数合集</a></li><li><a href="https://www.itbob.cn/article/013/">Python 数据分析三剑客之 NumPy（六）：矩阵 / 线性代数库与 IO 操作</a></li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105185337未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】numpy-nditer-迭代器对象"><a href="#【1x00】numpy-nditer-迭代器对象" class="headerlink" title="【1x00】numpy.nditer 迭代器对象"></a><font color=#ff0000>【1x00】numpy.nditer 迭代器对象</font></h2><p>numpy.nditer 是 NumPy 的迭代器对象，迭代器对象提供了许多灵活的方法来访问一个或多个数组中的所有元素，简单来说，迭代器最基本的任务就是完成对数组元素的访问。</p><h3 id="【1x01】单数组的迭代"><a href="#【1x01】单数组的迭代" class="headerlink" title="【1x01】单数组的迭代"></a><font color=#1BC3FB>【1x01】单数组的迭代</font></h3><p>单数组迭代示例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(10).reshape(2, 5)&gt;&gt;&gt; print(a)[[0 1 2 3 4] [5 6 7 8 9]]&gt;&gt;&gt; for i in np.nditer(a):    print(i, end=&#39; &#39;)    0 1 2 3 4 5 6 7 8 9 </code></pre><p>注意：默认对数组元素的访问顺序，既不是以标准 C（行优先） 也不是 Fortran 顺序（列优先），选择的顺序是和数组内存布局一致的，这样做是为了提高访问效率，反映了默认情况下只需要访问每个元素而不关心特定排序的想法。以下用一个数组的转置来理解这种访问机制。</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(10).reshape(2, 5)&gt;&gt;&gt; print(a)[[0 1 2 3 4] [5 6 7 8 9]]&gt;&gt;&gt; &gt;&gt;&gt; b = a.T&gt;&gt;&gt; print(b)[[0 5] [1 6] [2 7] [3 8] [4 9]]&gt;&gt;&gt; &gt;&gt;&gt; c = a.T.copy(order=&#39;C&#39;)&gt;&gt;&gt; print(c)[[0 5] [1 6] [2 7] [3 8] [4 9]]&gt;&gt;&gt; &gt;&gt;&gt; for i in np.nditer(a):    print(i, end=&#39; &#39;)    0 1 2 3 4 5 6 7 8 9 &gt;&gt;&gt; &gt;&gt;&gt; for i in np.nditer(b):    print(i, end=&#39; &#39;)    0 1 2 3 4 5 6 7 8 9 &gt;&gt;&gt; &gt;&gt;&gt; for i in np.nditer(c):    print(i, end=&#39; &#39;)    0 5 1 6 2 7 3 8 4 9 </code></pre><p>例子中 a 是一个 2 行 5 列的数组，b 数组对 a 进行了转置，而 c 数组则是对 a 进行转置后按照 C order（行优先）的形式复制到新内存中储存，b 数组虽然进行了转置操作，但是其元素在内存当中的储存顺序仍然和 a 一样，所以对其迭代的效果也和 a 一样，c 数组元素在新内存当中的储存顺序不同于 a 和 b，因此对其迭代的效果也不一样。</p><h3 id="【1x02】控制迭代顺序"><a href="#【1x02】控制迭代顺序" class="headerlink" title="【1x02】控制迭代顺序"></a><font color=#1BC3FB>【1x02】控制迭代顺序</font></h3><p>如果想要按照特定顺序来对数组进行迭代，nditer 同样也提供了 order 参数，可选值为：<code>C</code> <code>F</code> <code>A</code> <code>K</code></p><ul><li><code>numpy.nditer(a, order=&#39;C&#39;)</code>：标准 C 顺序，即行优先；</li><li><code>numpy.nditer(a, order=&#39;F&#39;)</code>： Fortran 顺序，即列优先；</li><li><code>numpy.nditer(a, order=&#39;A&#39;)</code>：如果所有数组都是 Fortran 顺序的，则 A 表示以 F 顺序，否则以 C 顺序；</li><li><code>numpy.nditer(a, order=&#39;K&#39;)</code>：默认值，保持原数组在内存当中的顺序。</li></ul><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(12).reshape(3, 4)&gt;&gt;&gt; print(a)[[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11]]&gt;&gt;&gt; &gt;&gt;&gt; for i in np.nditer(a, order=&#39;C&#39;):    print(i, end= &#39; &#39;)    0 1 2 3 4 5 6 7 8 9 10 11 &gt;&gt;&gt; &gt;&gt;&gt; for i in np.nditer(a, order=&#39;F&#39;):    print(i, end= &#39; &#39;)    0 4 8 1 5 9 2 6 10 3 7 11 &gt;&gt;&gt; &gt;&gt;&gt; for i in np.nditer(a, order=&#39;K&#39;):    print(i, end= &#39; &#39;)    0 1 2 3 4 5 6 7 8 9 10 11 </code></pre><h3 id="【1x03】修改数组元素"><a href="#【1x03】修改数组元素" class="headerlink" title="【1x03】修改数组元素"></a><font color=#1BC3FB>【1x03】修改数组元素</font></h3><p>nditer 对象提供了可选参数 <code>op_flags</code>，默认情况下，该参数值为 <code>readonly</code>（只读），如果在遍历数组的同时，要实现对数组中元素值的修改，则可指定 <code>op_flags</code> 值为 <code>readwrite</code>（读写） 或者 <code>writeonly</code>（只读）。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(10).reshape(2, 5)&gt;&gt;&gt; print(a)[[0 1 2 3 4] [5 6 7 8 9]]&gt;&gt;&gt; &gt;&gt;&gt; for i in np.nditer(a, op_flags=[&#39;readwrite&#39;]):        i[...] = i+1    &gt;&gt;&gt; print(a)[[ 1  2  3  4  5] [ 6  7  8  9 10]]</code></pre><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; li = []&gt;&gt;&gt; a = np.arange(12).reshape(3, 4)&gt;&gt;&gt; print(a)[[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11]]&gt;&gt;&gt; &gt;&gt;&gt; for i in np.nditer(a, op_flags=[&#39;readwrite&#39;]):        li.append(i*2)    &gt;&gt;&gt; print(li)[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22]</code></pre><h3 id="【1x04】使用外部循环"><a href="#【1x04】使用外部循环" class="headerlink" title="【1x04】使用外部循环"></a><font color=#1BC3FB>【1x04】使用外部循环</font></h3><p>nditer 对象支持 <code>flags</code> 参数，该参数最常用的值是 <code>external_loop</code>，表示使给定的值为具有多个值的一维数组。</p><p>通俗来讲，当 Ndarray 的顺序和遍历的顺序一致时，就会将所有元素组成一个一维数组返回；当 Ndarray 的顺序和遍历的顺序不一致时，则返回每次遍历的一维数组</p><p>官方介绍：<a href="https://docs.scipy.org/doc/numpy/reference/arrays.nditer.html#using-an-external-loop">https://docs.scipy.org/doc/numpy/reference/arrays.nditer.html#using-an-external-loop</a></p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[0,1,2,3], [4,5,6,7], [8,9,10,11]], order=&#39;C&#39;)&gt;&gt;&gt; for i in np.nditer(a, flags=[&#39;external_loop&#39;], order=&#39;C&#39; ):        print(i, end=&#39; &#39;)    [ 0  1  2  3  4  5  6  7  8  9 10 11] &gt;&gt;&gt; for i in np.nditer(a, flags=[&#39;external_loop&#39;], order=&#39;F&#39; ):        print(i, end=&#39; &#39;)    [0 4 8] [1 5 9] [ 2  6 10] [ 3  7 11] </code></pre><h3 id="【1x05】跟踪元素索引"><a href="#【1x05】跟踪元素索引" class="headerlink" title="【1x05】跟踪元素索引"></a><font color=#1BC3FB>【1x05】跟踪元素索引</font></h3><p>在迭代期间，我们有可能希望在计算中使用当前元素的索引值，同样可以通过指定 <code>flags</code> 参数的取值来实现：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>c_index</code></td><td>跟踪 C 顺序索引</td></tr><tr><td><code>f_index</code></td><td>跟踪 Fortran 顺序索引</td></tr><tr><td><code>multi_index</code></td><td>跟踪多个索引或每个迭代维度一个索引的元组（多重索引）</td></tr></tbody></table><p>在以下实例当中：</p><p>当参数为 <code>c_index</code> 和 <code>f_index</code> 时，<code>it.index</code> 用于输出元素的索引值</p><p>当参数为 <code>multi_index</code> 时，<code>it.multi_index</code>  用于输出元素的索引值</p><p><code>it.iternext()</code> 表示进入下一次迭代，直到迭代完成为止</p><p><code>multi_index</code> 可理解为对迭代对象进行多重索引</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(6).reshape(2, 3)&gt;&gt;&gt; it = np.nditer(a, flags=[&#39;c_index&#39;])&gt;&gt;&gt; while not it.finished:        print(&#39;%d &lt;%s&gt;&#39; %(it[0], it.index))        it.iternext()    0 &lt;0&gt;True1 &lt;1&gt;True2 &lt;2&gt;True3 &lt;3&gt;True4 &lt;4&gt;True5 &lt;5&gt;False</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A64/01.png" alt="01"></p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(6).reshape(2, 3)&gt;&gt;&gt; it = np.nditer(a, flags=[&#39;f_index&#39;])&gt;&gt;&gt; while not it.finished:        print(&#39;%d &lt;%s&gt;&#39; %(it[0], it.index))        it.iternext()    0 &lt;0&gt;True1 &lt;2&gt;True2 &lt;4&gt;True3 &lt;1&gt;True4 &lt;3&gt;True5 &lt;5&gt;False</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A64/02.png" alt="02"></p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(6).reshape(2, 3)&gt;&gt;&gt; it = np.nditer(a, flags=[&#39;multi_index&#39;])&gt;&gt;&gt; while not it.finished:        print(&#39;%d &lt;%s&gt;&#39; %(it[0], it.multi_index))        it.iternext()    0 &lt;(0, 0)&gt;True1 &lt;(0, 1)&gt;True2 &lt;(0, 2)&gt;True3 &lt;(1, 0)&gt;True4 &lt;(1, 1)&gt;True5 &lt;(1, 2)&gt;False</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A64/03.png" alt="03"></p><h3 id="【1x06】广播数组迭代"><a href="#【1x06】广播数组迭代" class="headerlink" title="【1x06】广播数组迭代"></a><font color=#1BC3FB>【1x06】广播数组迭代</font></h3><p>如果两个数组满足<a href="https://itrhx.blog.csdn.net/article/details/104988137#font_colorff00004x00NumPy_font_429">广播原则</a>，nditer 对象能够同时迭代它们，即广播数组迭代（多数组的迭代）。</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(3)&gt;&gt;&gt; b = np.arange(6).reshape(2,3)&gt;&gt;&gt; print(a)[0 1 2]&gt;&gt;&gt; print(b)[[0 1 2] [3 4 5]]&gt;&gt;&gt; for m, n in np.nditer([a,b]):    print(m,n)    0 01 12 20 31 42 5</code></pre><p>如果两个数组不满足广播原则，将会抛出异常：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(4)&gt;&gt;&gt; b = np.arange(6).reshape(2,3)&gt;&gt;&gt; print(a)[0 1 2 3]&gt;&gt;&gt; print(b)[[0 1 2] [3 4 5]]&gt;&gt;&gt; for m, n in np.nditer([a,b]):        print(m,n)    Traceback (most recent call last):  File &quot;&lt;pyshell#55&gt;&quot;, line 1, in &lt;module&gt;    for m, n in np.nditer([a,b]):ValueError: operands could not be broadcast together with shapes (4,) (2,3) </code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105185337未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【2x00】NumPy-位运算"><a href="#【2x00】NumPy-位运算" class="headerlink" title="【2x00】NumPy 位运算"></a><font color=#ff0000>【2x00】NumPy 位运算</font></h2><p>由于位运算是直接对整数在内存中的二进制位进行操作，所以有必要先了解一下如何来表示数字的二进制。</p><p>在 Python 中，提供了一个内置函数 <code>bin()</code>，将整数转换为以 <code>0b</code> 为前缀的二进制字符串，如果要去掉 <code>0b</code> 前缀，则可以使用 <code>format</code> 方法，因为返回的是字符串，所以也可以使用切片等其他方法去掉前缀。</p><pre><code class="python">&gt;&gt;&gt; bin(3)&#39;0b11&#39;&gt;&gt;&gt; format(3, &#39;b&#39;)&#39;11&#39;&gt;&gt;&gt; f&#39;&#123;3:b&#125;&#39;&#39;11&#39;</code></pre><p>除了内置函数以外，NumPy 还提供了一个 <code>numpy.binary_repr</code> 函数，该函数的作用也是以字符串形式返回输入数字的二进制表示形式。</p><p>基本语法：<code>numpy.binary_repr(num, width=None)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>num</td><td>要表示的数，只能是整数形式</td></tr><tr><td>width</td><td>可选项，对于负数，如果未指定 width，则会在前面添加减号，如果指定了 width，则返回该宽度的负数的二进制补码</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.binary_repr(3)&#39;11&#39;&gt;&gt;&gt; np.binary_repr(-3)&#39;-11&#39;&gt;&gt;&gt; np.binary_repr(-3, width=4)&#39;1101&#39;&gt;&gt;&gt; np.binary_repr(3, width=4)&#39;0011&#39;</code></pre><hr><p>以下是 NumPy 数组当中用到的位运算函数，各函数与其对应的用操作符计算的作用相同。</p><table><thead><tr><th>函数</th><th>描述</th><th>操作符</th></tr></thead><tbody><tr><td><code>bitwise_and</code></td><td>对数组元素进行按位<font color=#FF0000><strong>与（AND）</strong></font>操作</td><td>&amp;</td></tr><tr><td><code>bitwise_or</code></td><td>对数组元素进行按位<font color=#FF0000><strong>或（OR）</strong></font>操作</td><td>|</td></tr><tr><td><code>bitwise_xor</code></td><td>对数组元素执行按位<font color=#FF0000><strong>异或（XOR）</strong></font>操作</td><td>^</td></tr><tr><td><code>invert</code></td><td>对数组元素执行按位<font color=#FF0000><strong>取反（NOT）</strong></font>操作</td><td>~</td></tr><tr><td><code>left_shift</code></td><td>将数组元素的二进制形式向<font color=#FF0000><strong>左移</strong></font>动指定位，右侧附加相等数量的 0</td><td>&lt;&lt;</td></tr><tr><td><code>right_shift</code></td><td>将数组元素的二进制形式向<font color=#FF0000><strong>右移</strong></font>动指定位，左侧附加相等数量的 0</td><td>&gt;&gt;</td></tr></tbody></table><h3 id="【2x01】numpy-bitwise-and"><a href="#【2x01】numpy-bitwise-and" class="headerlink" title="【2x01】numpy.bitwise_and()"></a><font color=#1BC3FB>【2x01】numpy.bitwise_and()</font></h3><p>numpy.bitwise_and() 函数对数组元素进行按位与（AND）操作。</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.binary_repr(10), np.binary_repr(15)(&#39;1010&#39;, &#39;1111&#39;)&gt;&gt;&gt; np.bitwise_and(10, 15)10&gt;&gt;&gt; np.binary_repr(10)&#39;1010&#39;</code></pre><p>numpy.bitwise_and() 函数还支持多个元素同时进行按位与操作：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.bitwise_and([14,3], 13)array([12,  1], dtype=int32)</code></pre><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.bitwise_and([11,7], [4,25])array([0, 1], dtype=int32)&gt;&gt;&gt;&gt;&gt;&gt; np.array([11,7]) &amp; np.array([4,25])    # 函数与 &amp; 操作符作用一样array([0, 1], dtype=int32)</code></pre><p>还可以传入布尔值：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.bitwise_and([True,False,True],[True,True,True])array([ True, False,  True])</code></pre><h3 id="【2x02】numpy-bitwise-or"><a href="#【2x02】numpy-bitwise-or" class="headerlink" title="【2x02】numpy.bitwise_or()"></a><font color=#1BC3FB>【2x02】numpy.bitwise_or()</font></h3><p>numpy.bitwise_or() 函数对数组元素进行按位或（OR）操作。</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.binary_repr(10), np.binary_repr(14)(&#39;1010&#39;, &#39;1110&#39;)&gt;&gt;&gt; np.bitwise_or(10, 14)14&gt;&gt;&gt; np.binary_repr(14)&#39;1110&#39;</code></pre><p>和按位与操作一样，numpy.bitwise_or() 函数也支持传入布尔值和多个元素同时进行操作：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.bitwise_or([33,4], 1)array([33,  5], dtype=int32)&gt;&gt;&gt;&gt;&gt;&gt; np.bitwise_or([33,4], [1,2])array([33,  6], dtype=int32)&gt;&gt;&gt;&gt;&gt;&gt; np.bitwise_or(np.array([2,5,255]), np.array([4,4,4]))array([  6,   5, 255], dtype=int32)&gt;&gt;&gt;&gt;&gt;&gt; np.array([2,5,255]) | np.array([4,4,4])   # 函数与 | 运算符作用相同array([  6,   5, 255], dtype=int32)&gt;&gt;&gt;&gt;&gt;&gt; np.bitwise_or([True, True], [False,True])array([ True,  True])</code></pre><h3 id="【2x03】numpy-bitwise-xor"><a href="#【2x03】numpy-bitwise-xor" class="headerlink" title="【2x03】numpy.bitwise_xor()"></a><font color=#1BC3FB>【2x03】numpy.bitwise_xor()</font></h3><p>numpy.bitwise_xor() 函数对数组元素执行按位异或（XOR）操作。</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; bin(13), bin(17)(&#39;0b1101&#39;, &#39;0b10001&#39;)&gt;&gt;&gt; np.bitwise_xor(13,17)28&gt;&gt;&gt; bin(28)&#39;0b11100&#39;</code></pre><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.bitwise_xor([31,3], 5)array([26,  6], dtype=int32)&gt;&gt;&gt; &gt;&gt;&gt; np.bitwise_xor([31,3], [5,6])array([26,  5], dtype=int32)&gt;&gt;&gt; &gt;&gt;&gt; np.array([31,3]) ^ np.array([5,6])    # 函数与 ^ 运算符作用相同array([26,  5], dtype=int32)&gt;&gt;&gt;&gt;&gt;&gt; np.bitwise_xor([True, True], [False, True])array([ True, False])</code></pre><h3 id="【2x04】numpy-invert"><a href="#【2x04】numpy-invert" class="headerlink" title="【2x04】numpy.invert()"></a><font color=#1BC3FB>【2x04】numpy.invert()</font></h3><p>numpy.invert() 函数将对数组元素执行按位取反（NOT）操作，注意<font color=#FF0000><strong>按位取反</strong></font>和<font color=#FF0000><strong>取反</strong></font>操作不同。</p><p><font color=#FF0000><strong>按位取反通用公式：~x = -(x+1)</strong></font></p><p>我们将原来的数称为 A，按位取反后的数称为 B，按位取反的步骤如下：<br>先求 A 的补码，对 A 的补码每一位取反（包括符号位），得到的数为 B 的补码，将 B 的补码转换为 B 的原码得到最终结果。</p><p>分情况具体讨论：</p><table><tr><td bgcolor=#7FFFD4>正数按位取反步骤</td></tr></table><p>1、将其转换成二进制形式；<br>2、求其补码（正数的原码、反码、补码都相同）；<br>3、将补码每一位进行取反操作（包括符号位）；<br><font color=#008B00>【经过步骤 3 后的结果为一个二进制形式的负数补码，接下来将这个负数补码转换成原码（负数原码到补码的逆运算）】</font><br>4、对步骤 3 得到的负数 -1 得到反码；<br>5、对步骤 4 得到的反码再进行取反得到原码；<br>6、将步骤 5 得到的原码转回十进制即是最终结果。</p><table><tr><td bgcolor=#7FFFD4>负数按位取反步骤</td></tr></table><p>1、将其转换成二进制形式；<br>2、求其补码（先求其反码、符号位不变，末尾 +1 得到其补码）；<br>3、将补码每一位进行取反操作（包括符号位）；<br><font color=#008B00>【经过步骤 3 后的结果为一个二进制形式的正数，接下来将这个正数转换成原码即可】</font><br>4、由于正数的原码、反码、补码都相同，所以直接将其转换成十进制即为最终结果。</p><p><font color=#FF0000><strong>注意：第 3 步的取反操作，包括符号位都要取反，与求反码不同，求反码时符号位不变。</strong></font></p><p>具体计算举例（二进制前 4 位为符号位）：</p><table><tr><td bgcolor=#7FFFD4>9 的按位取反</td></tr></table><p>① 原码：0000 1001<br>② 反码：0000 1001<br>③ 补码：0000 1001<br>④ 取反：<font color=#FF0000>1111 0110</font>    （包括符号位一起取反，得到新的补码）<br>⑤ 反码：1111 0101    （将新的补码 -1 得到其反码）<br>⑥ 原码：1111 1010    （将反码取反得到原码）<br>⑦ 转为十进制：-10</p><table><tr><td bgcolor=#7FFFD4>-9 的按位取反</td></tr></table><p>① 原码：1111 1001<br>② 反码：1111 0110<br>③ 补码：1111 0111<br>④ 取反：<font color=#FF0000>0000 1000</font>    （包括符号位一起取反，得到新的补码）<br>⑤ 原码：0000 1000    （由于新的补码为正数，所以原码补码相同）<br>⑥ 转为十进制：8</p><hr><p>其他关于按位取反操作的知识：</p><ul><li><p><a href="https://blog.csdn.net/xiexievv/article/details/8124108">按位取反运计算方法</a></p></li><li><p><a href="https://baijiahao.baidu.com/s?id=1631845959953469880">[干货]按位取反怎么算？~图文详解</a></p></li></ul><hr><p>Python 代码应用示例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.binary_repr(9, width=8)&#39;00001001&#39;&gt;&gt;&gt; np.invert(9)-10&gt;&gt;&gt; np.invert(-9)8</code></pre><h3 id="【2x05】numpy-left-shift"><a href="#【2x05】numpy-left-shift" class="headerlink" title="【2x05】numpy.left_shift()"></a><font color=#1BC3FB>【2x05】numpy.left_shift()</font></h3><p>numpy.left_shift() 函数将数组元素的二进制形式向左移动指定位，右侧附加相等数量的 0。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.binary_repr(10, width=8)&#39;00001010&#39;&gt;&gt;&gt; np.left_shift(10, 2)40&gt;&gt;&gt; 10 &lt;&lt; 2         # numpy.left_shift 函数相当于 Python 当中的 &lt;&lt; 运算符40&gt;&gt;&gt; np.binary_repr(40, width=8)&#39;00101000&#39;</code></pre><h3 id="【2x06】numpy-right-shift"><a href="#【2x06】numpy-right-shift" class="headerlink" title="【2x06】numpy.right_shift()"></a><font color=#1BC3FB>【2x06】numpy.right_shift()</font></h3><p>numpy.right_shift() 函数将数组元素的二进制形式向右移动指定位，左侧附加相等数量的 0</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.binary_repr(10, width=8)&#39;00001010&#39;&gt;&gt;&gt; np.right_shift(10, 2)2&gt;&gt;&gt; 10 &gt;&gt; 2         # numpy.right_shift 函数相当于 Python 当中的 &gt;&gt; 运算符2&gt;&gt;&gt; np.binary_repr(2, width=8)&#39;00000010&#39;</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/105185337未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> NumPy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 NumPy（二）：数组索引 / 切片 / 广播 / 拼接 / 分割</title>
      <link href="/article/009/"/>
      <url>/article/009/</url>
      
        <content type="html"><![CDATA[<p>NumPy 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/008/">Python 数据分析三剑客之 NumPy（一）：理解 NumPy / 数组基础</a></li><li><a href="https://www.itbob.cn/article/009/">Python 数据分析三剑客之 NumPy（二）：数组索引 / 切片 / 广播 / 拼接 / 分割</a></li><li><a href="https://www.itbob.cn/article/010/">Python 数据分析三剑客之 NumPy（三）：数组的迭代与位运算</a></li><li><a href="https://www.itbob.cn/article/011/">Python 数据分析三剑客之 NumPy（四）：字符串函数总结与对比</a></li><li><a href="https://www.itbob.cn/article/012/">Python 数据分析三剑客之 NumPy（五）：数学 / 算术 / 统计 / 排序 / 条件 / 判断函数合集</a></li><li><a href="https://www.itbob.cn/article/013/">Python 数据分析三剑客之 NumPy（六）：矩阵 / 线性代数库与 IO 操作</a></li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/104988137未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】认识-Numpy-中的-nan-和-inf"><a href="#【1x00】认识-Numpy-中的-nan-和-inf" class="headerlink" title="【1x00】认识 Numpy 中的 nan 和 inf"></a><font color=#ff0000>【1x00】认识 Numpy 中的 nan 和 inf</font></h2><p>nan（NAN，Nan）：全称 not a number，即不是一个数字<br>inf（-inf，inf）：全称 infinity，inf 表示正无穷，-inf 表示负无穷</p><p>以下情况 Numpy 中会出现 nan：</p><ul><li>当读取本地的文件为 float 的时候，如果有缺失，就会出现 nan</li><li>当做了一个不合适的计算的时候（如：无穷大减去无穷大）</li></ul><p>以下情况会出现 inf 或者 -inf：</p><ul><li>比如一个数字除以 0，在 Python 中直接会报错，但在 Numpy 中则是一个 inf 或者 -inf</li></ul><p>指定一个 nan 或者 inf：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.nan&gt;&gt;&gt; b = np.inf&gt;&gt;&gt; print(a)nan&gt;&gt;&gt; print(b)inf&gt;&gt;&gt; type(a)&lt;class &#39;float&#39;&gt;&gt;&gt;&gt; type(b)&lt;class &#39;float&#39;&gt;</code></pre><p>注意两个 nan 并不相等，而两个 inf 是相等的</p><pre><code class="python">&gt;&gt;&gt; np.nan == np.nanFalse&gt;&gt;&gt; np.inf == np.infTrue</code></pre><p>nan 和任何值计算都为 nan：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 2, 3, 4, 5])&gt;&gt;&gt; b = np.array([1, 2, np.nan, 4, np.nan])&gt;&gt;&gt; print(a+b)[ 2.  4. nan  8. nan]</code></pre><h3 id="【1x01】判断是否为-nan-和-inf"><a href="#【1x01】判断是否为-nan-和-inf" class="headerlink" title="【1x01】判断是否为 nan 和 inf"></a><font color=#1BC3FB>【1x01】判断是否为 nan 和 inf</font></h3><ul><li>isnan：判断元素是否为 nan（非数字）</li><li>isinf：判断元素是否为正无穷大或负无穷大</li><li>isposinf：判断元素是否为正无穷大</li><li>isneginf：判断元素是否为负无穷大</li><li>isfinite：判断元素是否为有限的（不是非数字，正无穷大和负无穷大中的一个）</li></ul><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3, 4], [np.nan, 6, 7, np.nan], [9 ,np.nan, 10, 11]])&gt;&gt;&gt; print(a)[[ 1.  2.  3.  4.] [nan  6.  7. nan] [ 9. nan 10. 11.]]&gt;&gt;&gt; np.isnan(a)array([[False, False, False, False],       [ True, False, False,  True],       [False,  True, False, False]])</code></pre><h3 id="【1x02】统计数组中-nan-的个数"><a href="#【1x02】统计数组中-nan-的个数" class="headerlink" title="【1x02】统计数组中 nan 的个数"></a><font color=#1BC3FB>【1x02】统计数组中 nan 的个数</font></h3><p>1、利用 <code>np.count_nonzero</code> 方法，结合两个 nan 不相等的属性，可以判断数组中 nan 的个数：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3, 4], [np.nan, 6, 7, np.nan], [9 ,np.nan, 10, 11]])&gt;&gt;&gt; print(a)[[ 1.  2.  3.  4.] [nan  6.  7. nan] [ 9. nan 10. 11.]]&gt;&gt;&gt; np.count_nonzero(a != a)    # 判断 nan 的个数，a != a 即为 nan，nan != nan3</code></pre><p>2、<code>isnan()</code> 方法可以判断哪些是 nan，再结合 <code>np.count_nonzero</code> 方法可以判断数组中 nan 的个数：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3, 4], [np.nan, 6, 7, np.nan], [9 ,np.nan, 10, 11]])&gt;&gt;&gt; print(a)[[ 1.  2.  3.  4.] [nan  6.  7. nan] [ 9. nan 10. 11.]]&gt;&gt;&gt; np.isnan(a)                        # np.isnan(a) 与 a != a 效果相同，判断那些是 nanarray([[False, False, False, False],       [ True, False, False,  True],       [False,  True, False, False]])&gt;&gt;&gt; np.count_nonzero(np.isnan(a))3</code></pre><p>3、利用 <code>collections</code> 模块的 <code>Counter</code> 方法来统计 nan 的个数（此方法仅适用于一维数组）：</p><pre><code class="python">&gt;&gt;&gt; from collections import Counter&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 2, np.nan, 4, np.nan])&gt;&gt;&gt; print(Counter(np.isnan(a)))Counter(&#123;False: 3, True: 2&#125;)</code></pre><h3 id="【1x03】统计数组中-inf-的个数"><a href="#【1x03】统计数组中-inf-的个数" class="headerlink" title="【1x03】统计数组中 inf 的个数"></a><font color=#1BC3FB>【1x03】统计数组中 inf 的个数</font></h3><p>1、<code>isinf()</code> 方法可以判断哪些是 inf，再结合 <code>np.count_nonzero</code> 方法可以判断数组中 inf 的个数：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3, 4], [np.inf, 6, 7, -np.inf], [9 ,-np.inf, 10, 11]])&gt;&gt;&gt; print(a)[[  1.   2.   3.   4.] [ inf   6.   7. -inf] [  9. -inf  10.  11.]]&gt;&gt;&gt; np.isinf(a)array([[False, False, False, False],       [ True, False, False,  True],       [False,  True, False, False]])&gt;&gt;&gt; np.count_nonzero(np.isinf(a))3</code></pre><p>2、利用 <code>collections</code> 模块的 <code>Counter</code> 方法来统计 inf 的个数（此方法仅适用于一维数组）：</p><pre><code class="python">&gt;&gt;&gt; from collections import Counter&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 2, np.inf, 4, -np.inf])&gt;&gt;&gt; print(Counter(np.isinf(a)))Counter(&#123;False: 3, True: 2&#125;)</code></pre><h3 id="【1x04】替换-inf-和-nan"><a href="#【1x04】替换-inf-和-nan" class="headerlink" title="【1x04】替换 inf 和 nan"></a><font color=#1BC3FB>【1x04】替换 inf 和 nan</font></h3><p><code>numpy.nan_to_num()</code> 方法可以将 nan 替换为零，将 inf 替换为有限数。</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, np.nan, 3, 4], [np.inf, 6, 7, -np.inf], [9 ,-np.inf, 10, np.nan]])&gt;&gt;&gt; print(a)[[  1.  nan   3.   4.] [ inf   6.   7. -inf] [  9. -inf  10.  nan]]&gt;&gt;&gt; print(np.nan_to_num(a))[[ 1.00000000e+000  0.00000000e+000  3.00000000e+000  4.00000000e+000] [ 1.79769313e+308  6.00000000e+000  7.00000000e+000 -1.79769313e+308] [ 9.00000000e+000 -1.79769313e+308  1.00000000e+001  0.00000000e+000]]</code></pre><p>如果要将 nan 和 inf 替换成特定的值，则可以用以下方法：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, np.nan, 3, 4], [np.inf, 6, 7, -np.inf], [9 ,-np.inf, 10, np.nan]])&gt;&gt;&gt; print(a)[[  1.  nan   3.   4.] [ inf   6.   7. -inf] [  9. -inf  10.  nan]]&gt;&gt;&gt; loc_nan = np.isnan(a)&gt;&gt;&gt; loc_inf = np.isinf(a)&gt;&gt;&gt; a[loc_nan] = 111&gt;&gt;&gt; a[loc_inf] = 222&gt;&gt;&gt; print(a)[[  1. 111.   3.   4.] [222.   6.   7. 222.] [  9. 222.  10. 111.]]</code></pre><h2 id="【2x00】NumPy-索引"><a href="#【2x00】NumPy-索引" class="headerlink" title="【2x00】NumPy 索引"></a><font color=#ff0000>【2x00】NumPy 索引</font></h2><h3 id="【2x01】获取具体元素"><a href="#【2x01】获取具体元素" class="headerlink" title="【2x01】获取具体元素"></a><font color=#1BC3FB>【2x01】获取具体元素</font></h3><p>NumPy 的索引和 Python 列表的索引类似，可以通过中括号指定索引获取第 i 个值（从 0 开始计数）：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 2, 3, 4])&gt;&gt;&gt; print(a[0])1&gt;&gt;&gt; print(a[2])3&gt;&gt;&gt; print(a[-1])4&gt;&gt;&gt; print(a[-2])3</code></pre><p>在多维数组中，可以用逗号分隔的索引元组获取具体某个元素：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])&gt;&gt;&gt; print(a)[[1 2 3] [4 5 6] [7 8 9]]&gt;&gt;&gt; print(a[1, 2])6&gt;&gt;&gt; print(a[0, -2])2</code></pre><pre><code class="python">&gt;&gt;&gt; a = np.array([[[1,2,3,4], [5,6,7,8]], [[9,10,11,12], [13,14,15,16]], [[17,18,19,20], [21,22,23,24]]])&gt;&gt;&gt; print(a)[[[ 1  2  3  4]  [ 5  6  7  8]] [[ 9 10 11 12]  [13 14 15 16]] [[17 18 19 20]  [21 22 23 24]]]&gt;&gt;&gt; print(a[0, 1, 2])7&gt;&gt;&gt; print(a[1, 0, -1])12</code></pre><h3 id="【2x02】获取行或列"><a href="#【2x02】获取行或列" class="headerlink" title="【2x02】获取行或列"></a><font color=#1BC3FB>【2x02】获取行或列</font></h3><pre><code class="python">&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])&gt;&gt;&gt; print(a)[[ 1  2  3] [ 4  5  6] [ 7  8  9] [10 11 12]]&gt;&gt;&gt; print(a[1])       # 取一整行[4 5 6]&gt;&gt;&gt; print(a[1, :])    # 取一整行，效果同上[4 5 6]&gt;&gt;&gt; print(a[1, ...])  # 取一整行，效果同上[4 5 6]&gt;&gt;&gt; print(a[:, 2])    # 取一整列[ 3  6  9 12]&gt;&gt;&gt; print(a[..., 2])  # 取一整列，效果同上[ 3  6  9 12]&gt;&gt;&gt; print(a[1:3])     # 取多行[[4 5 6] [7 8 9]]&gt;&gt;&gt; print(a[:, 0:2])  # 取多列[[ 1  2] [ 4  5] [ 7  8] [10 11]]&gt;&gt;&gt; print(a[[1, 3], :])  # 取第一、三行和所有列[[ 4  5  6] [10 11 12]]&gt;&gt;&gt; print(a[:, [0, 2]])  # 取第零、二列和所有行[[ 1  3] [ 4  6] [ 7  9] [10 12]]</code></pre><h3 id="【2x03】布尔索引"><a href="#【2x03】布尔索引" class="headerlink" title="【2x03】布尔索引"></a><font color=#1BC3FB>【2x03】布尔索引</font></h3><p>除了直接获取元素以外，还可以通过一个布尔数组来索引目标数组，即通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。</p><p>以下实例将筛选出大于 6 的元素：</p><pre><code class="python">&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])&gt;&gt;&gt; print(a)[[ 1  2  3] [ 4  5  6] [ 7  8  9] [10 11 12]]&gt;&gt;&gt; print(a[a &gt; 6])[ 7  8  9 10 11 12]</code></pre><p>以下实例使用取补运算符 <code>~</code> 来过滤掉 inf：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 2, np.inf, 3, -np.inf, 4, 5])&gt;&gt;&gt; print(a)[  1.   2.  inf   3. -inf   4.   5.]&gt;&gt;&gt; print(a[~np.isinf(a)])[1. 2. 3. 4. 5.]</code></pre><h3 id="【2x04】花式索引"><a href="#【2x04】花式索引" class="headerlink" title="【2x04】花式索引"></a><font color=#1BC3FB>【2x04】花式索引</font></h3><p>花式索引：传递一个索引数组来一次性获得多个数组元素，花式索引总是将数据复制到新数组中。</p><p>花式索引根据索引数组的值作为目标数组的某个轴的下标来取值。对于使用一维整型数组作为索引，如果目标是一维数组，那么索引的结果就是对应位置的元素；如果目标是二维数组，那么就是对应下标的行。</p><p>花式索引结果的形状与<strong>索引数组</strong>的形状一致，而不是与<strong>被索引数组</strong>的形状一致。</p><p>一维数组中的应用：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 2, 3, 4, 5, 6])&gt;&gt;&gt; print([a[0], a[2], a[-1]])[1, 3, 6]</code></pre><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 2, 3, 4, 5, 6])&gt;&gt;&gt; ind = [0, 2, -1]&gt;&gt;&gt; print(a[ind])[1 3 6]</code></pre><p>二维数组中的应用：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])&gt;&gt;&gt; print(a)[[ 1  2  3  4] [ 5  6  7  8] [ 9 10 11 12]]&gt;&gt;&gt; print([a[0, 1], a[1, 2], a[2, 3]])[2, 7, 12]</code></pre><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])&gt;&gt;&gt; row = np.array([0, 1, 2])       # 行&gt;&gt;&gt; col = np.array([1, 2, 3])       # 列&gt;&gt;&gt; print(a[row, col])[ 2  7 12]</code></pre><h2 id="【3x00】NumPy-切片"><a href="#【3x00】NumPy-切片" class="headerlink" title="【3x00】NumPy 切片"></a><font color=#ff0000>【3x00】NumPy 切片</font></h2><p>Ndarray 数组对象基于 <code>0 - n</code> 的下标进行索引，与 Python 中列表的切片操作一样，NumPy 的切片也可以通过冒号分隔切片参数 <code>[start:stop:step]</code> 来进行切片操作，另外，NumPy 也提供了一个内置函数 <code>slice(start, stop, step)</code> 来进行切片操作。</p><p>slice 方法应用：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(10)&gt;&gt;&gt; print(a)[0 1 2 3 4 5 6 7 8 9]&gt;&gt;&gt; b = slice(2, 8, 2)    # 从索引 2 开始到索引 8 停止，步长为 2&gt;&gt;&gt; print(a[b])[2 4 6]</code></pre><p>通过冒号分隔切片参数 <code>[start:stop:step]</code> 来进行切片：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(12)&gt;&gt;&gt; print(a)[ 0  1  2  3  4  5  6  7  8  9 10 11]&gt;&gt;&gt; print(a[1:9:2])        # 从索引 1 开始到索引 9 停止，步长为 2[1 3 5 7]&gt;&gt;&gt; print(a[5:])[ 5  6  7  8  9 10 11]     # 从索引 5 开始一直到最后一个元素</code></pre><p>二数组中的切片，格式类似于 <code>a[start:stop:step, start:stop:step]</code>，以逗号来分割行与列。</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6], [7, 8 ,9], [10, 11, 12], [13, 14, 15], [16, 17, 18]])&gt;&gt;&gt; print(a)[[ 1  2  3] [ 4  5  6] [ 7  8  9] [10 11 12] [13 14 15] [16 17 18]]&gt;&gt;&gt; print(a[0:4:2])       # 按照行从索引 0 开始到索引 4 停止，步长为 2[[1 2 3] [7 8 9]]&gt;&gt;&gt; print(a[0:4:2,...])   # 与上述方法相同，... 与 : 作用相同[[1 2 3] [7 8 9]]&gt;&gt;&gt; print(a[...,1:])      # 按照列从索引 1 开始一直到最后一个元素[[ 2  3] [ 5  6] [ 8  9] [11 12] [14 15] [17 18]]&gt;&gt;&gt; print(a[1:5:2,1:])   # 分别按照行从索引 1 开始到索引 5 停止，步长为 2，按照列从索引 1 开始一直到最后一个元素[[ 5  6] [11 12]]</code></pre><p>三数组中的切片，格式类似于 <code>a[start:stop:step, start:stop:step, start:stop:step]</code>，以逗号来分割块、行与列。</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[[1,2,3,4], [5,6,7,8]], [[9,10,11,12], [13,14,15,16]], [[17,18,19,20], [21,22,23,24]]])&gt;&gt;&gt; print(a)[[[ 1  2  3  4]  [ 5  6  7  8]] [[ 9 10 11 12]  [13 14 15 16]] [[17 18 19 20]  [21 22 23 24]]]&gt;&gt;&gt; print(a[1,:,0:2])   # 取索引为 1 的块数、所有行、索引为 0 到 2 的列[[ 9 10] [13 14]]&gt;&gt;&gt; print(a[1,:,:])     # 取索引为 1 的块数、所有行与列[[ 9 10 11 12] [13 14 15 16]]&gt;&gt;&gt; print(a[1,...,:])   # ... 与 : 作用相同[[ 9 10 11 12] [13 14 15 16]]</code></pre><h2 id="【4x00】NumPy-数组运算以及广播原则"><a href="#【4x00】NumPy-数组运算以及广播原则" class="headerlink" title="【4x00】NumPy 数组运算以及广播原则"></a><font color=#ff0000>【4x00】NumPy 数组运算以及广播原则</font></h2><p>NumPy 数组与数之间、数组与数组之间都支持加减乘除的计算。</p><ul><li><p>对于<strong>数组与数</strong>之间的计算，由于 NumPy 的广播机制，加减乘除都会对数组的每一个元素进行操作。</p></li><li><p>对于<strong>数组与数组</strong>之间的计算，相同维度的，相同位置元素之间会进行计算，不同维度的，将自动触发广播机制。</p></li></ul><p><font color=#ff0000><strong>广播（Broadcast）原则：</strong></font>如果两个数组的后缘维度（trailing dimension，即从末尾开始算起的维度）的轴长度相符，或其中的一方的长度为 1，则认为它们是广播兼容的。广播会在缺失和（或）长度为 1 的维度上进行。</p><p>通俗理解，以下情况的两个数组均可进行广播：</p><p><font color=#ff0000>1、两个数组各维度大小从后往前比对均一致：</font></p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.ones((3, 4, 5))&gt;&gt;&gt; b = np.ones((4, 5))&gt;&gt;&gt; print((a+b).shape)(3, 4, 5)&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; c = np.ones((3))&gt;&gt;&gt; d = np.ones((2, 3))&gt;&gt;&gt; print((c+d).shape)(2, 3)&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; e = np.ones((3, 4, 5))&gt;&gt;&gt; f = np.ones((4, 2))&gt;&gt;&gt; print((e+f).shape)Traceback (most recent call last):  File &quot;&lt;pyshell#16&gt;&quot;, line 1, in &lt;module&gt;    print((e+f).shape)ValueError: operands could not be broadcast together with shapes (3,4,5) (4,2) # 因为 e 和 f 维度大小此前往后对比不一致，所以会抛出异常</code></pre><p><font color=#ff0000>2、两个数组存在一些维度大小不相等时，在其中一个数组中，这个不相等的维度大小为 1：</font></p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.ones((3, 4, 5))&gt;&gt;&gt; b = np.ones((4, 1))&gt;&gt;&gt; print((a+b).shape)(3, 4, 5)# 此时虽然 a 与 b 的维度大小此前往后对比不一致，但是 b 数组的这个维度大小为 1，所以仍然可以相加</code></pre><p>那么当两个数组之间可以进行广播的时候，具体是怎样广播、怎样计算的呢？以下通过代码和图解来更进一步理解广播机制：</p><p><font color=#ff0000>数组与数之间的运算：</font></p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 2, 3, 4, 5])&gt;&gt;&gt; print(a)[1 2 3 4 5]&gt;&gt;&gt; print(a+1)     # 对数组每一个元素都 +1[2 3 4 5 6]&gt;&gt;&gt; print(a-1)     # 对数组每一个元素都 -1[0 1 2 3 4]&gt;&gt;&gt; print(a*2)     # 对数组每一个元素都 *1[ 2  4  6  8 10]&gt;&gt;&gt; print(a/2)     # 对数组每一个元素都 /1[0.5 1.  1.5 2.  2.5]</code></pre><p><font color=#ff0000>相同维度的数组与数组之间的运算：</font></p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])&gt;&gt;&gt; b = np.array([[11, 12, 13, 14, 15], [16, 17, 18, 19, 20]])&gt;&gt;&gt; print(a)[[ 1  2  3  4  5] [ 6  7  8  9 10]]&gt;&gt;&gt; print(b)[[11 12 13 14 15] [16 17 18 19 20]]&gt;&gt;&gt; print(a+b)[[12 14 16 18 20] [22 24 26 28 30]]&gt;&gt;&gt; print(b-a)[[10 10 10 10 10] [10 10 10 10 10]]&gt;&gt;&gt; print(a*b)[[ 11  24  39  56  75] [ 96 119 144 171 200]]&gt;&gt;&gt; print(b/a)[[11.          6.          4.33333333  3.5         3.        ] [ 2.66666667  2.42857143  2.25        2.11111111  2.        ]]</code></pre><p><font color=#ff0000>不同维度的数组与数组之间的运算：</font></p><p>实例一：一个<font color=#ff0000><strong>二维数组</strong></font>与一个<font color=#ff0000><strong>一维数组</strong></font>相加，此时就会触发广播机制，代码与图解如下：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])&gt;&gt;&gt; b = np.array([20, 20, 20])&gt;&gt;&gt; print(a)[[ 1  2  3] [ 4  5  6] [ 7  8  9] [10 11 12]]&gt;&gt;&gt; print(b)[20 20 20]&gt;&gt;&gt; print(a+b)[[21 22 23] [24 25 26] [27 28 29] [30 31 32]]</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A63/01.png" alt="01"></p><p>实例二：一个 <font color=#ff0000><strong>4 行 3 列</strong></font>的二维数组与一个 <font color=#ff0000><strong>4 行 1 列</strong></font>的二维数组相加，此时就会触发广播机制，代码与图解如下：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])&gt;&gt;&gt; b = np.array([[1], [2], [3], [4]])&gt;&gt;&gt; print(a)[[ 1  2  3] [ 4  5  6] [ 7  8  9] [10 11 12]]&gt;&gt;&gt; print(b)[[1] [2] [3] [4]]&gt;&gt;&gt; print(a+b)[[ 2  3  4] [ 6  7  8] [10 11 12] [14 15 16]]</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A63/02.png" alt="02"></p><p>实例三：一个 <font color=#ff0000><strong>3 块 4 行 2 列，即 shape=(3, 4, 2)</strong></font> 的三维数组与一个 <font color=#ff0000><strong>1 块 4 行 2 列，即 shape=(1, 4, 2)</strong></font> 的三维数组相加，此时就会触发广播机制，代码与图解如下：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[[1, 2], [3, 4], [5, 6], [7, 8]], [[9, 10], [11, 12], [13, 14], [15, 16]], [[17, 18], [19, 20], [21, 22], [23, 24]]])&gt;&gt;&gt; b = np.array([[[1, 2], [3, 4], [5, 6], [7, 8]]])&gt;&gt;&gt; print(a)[[[ 1  2]  [ 3  4]  [ 5  6]  [ 7  8]] [[ 9 10]  [11 12]  [13 14]  [15 16]] [[17 18]  [19 20]  [21 22]  [23 24]]]&gt;&gt;&gt; print(b)[[[1 2]  [3 4]  [5 6]  [7 8]]]&gt;&gt;&gt; print(a.shape)(3, 4, 2)&gt;&gt;&gt; print(b.shape)(1, 4, 2)&gt;&gt;&gt; print(a+b)[[[ 2  4]  [ 6  8]  [10 12]  [14 16]] [[10 12]  [14 16]  [18 20]  [22 24]] [[18 20]  [22 24]  [26 28]  [30 32]]]</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A63/03.png" alt="03"></p><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/104988137未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【5x00】数组的拼接与元素的添加"><a href="#【5x00】数组的拼接与元素的添加" class="headerlink" title="【5x00】数组的拼接与元素的添加"></a><font color=#FF0000>【5x00】数组的拼接与元素的添加</font></h2><h3 id="【5x01】将数组转换成列表，拼接完成再转换成数组"><a href="#【5x01】将数组转换成列表，拼接完成再转换成数组" class="headerlink" title="【5x01】将数组转换成列表，拼接完成再转换成数组"></a><font color=#1BC3FB>【5x01】将数组转换成列表，拼接完成再转换成数组</font></h3><p>数组的拼接，可以先将数组转成列表，利用列表的拼接函数，如：append()、extend() 等进行拼接处理，然后再将列表转成数组即可。</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 2, 3])&gt;&gt;&gt; b = np.array([4, 5, 6])&gt;&gt;&gt; a_list = list(a)&gt;&gt;&gt; b_list = list(b)&gt;&gt;&gt; for i in b_list:    a_list.append(i)    &gt;&gt;&gt; a_list[1, 2, 3, 4, 5, 6]&gt;&gt;&gt; a = np.array(a_list)&gt;&gt;&gt; aarray([1, 2, 3, 4, 5, 6])</code></pre><h3 id="【5x02】numpy-append"><a href="#【5x02】numpy-append" class="headerlink" title="【5x02】numpy.append()"></a><font color=#1BC3FB>【5x02】numpy.append()</font></h3><p>numpy.append() 方法可以将一个数组附加到另一个数组的尾部，与 Python 列表中的 append 方法类似，仅支持两个数组之间的拼接，不能一次性拼接多个数组。</p><p>基本语法：<code>numpy.append(a, values, axis=None)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>被添加元素的目标数组</td></tr><tr><td>values</td><td>要添加元素的目标数组，即将该数组添加到 a 数组的尾部<br><font color=#FF0000><strong>如果指定了 axis 的值，则要求该数组的维度必须与 a 相同</strong></font></td></tr><tr><td>axis</td><td>指定轴，按照指定轴的方向进行拼接<br>如果未指定轴，则在使用前会将 a 和 values 都展平</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 2, 3])&gt;&gt;&gt; b = np.array([4, 5, 6])&gt;&gt;&gt; print(np.append(a, b))                 # 两个一维数组进行拼接[1 2 3 4 5 6]&gt;&gt;&gt; &gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])&gt;&gt;&gt; b = np.array([10, 11, 12])&gt;&gt;&gt; print(np.append(a, b))                 # 一维数组与二维数组进行拼接[ 1  2  3  4  5  6  7  8  9 10 11 12]&gt;&gt;&gt; &gt;&gt;&gt; a = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])&gt;&gt;&gt; b = np.array([[13, 14, 15], [16, 17, 18]])&gt;&gt;&gt; print(np.append(a, b))                # 二维数组与三维数组进行拼接[ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18]&gt;&gt;&gt; print(type(np.append(a, b)))          # 拼接后的数组仍然是一个 ndarray 对象&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><p>指定 axis 的值举例（指定了 axis 的值，要求两个数组的维度必须相同）：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]])&gt;&gt;&gt; b = np.array([[7, 8, 9]])&gt;&gt;&gt; print(np.append(a, b, axis=0))       # a、b 均为二维数组，指定 axis 值为 0[[1 2 3] [4 5 6] [7 8 9]]&gt;&gt;&gt;&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]])&gt;&gt;&gt; b = np.array([7, 8, 9])&gt;&gt;&gt; print(np.append(a, b, axis=0))      # a 为二维数组，b 为一维数组，指定 axis 值为 0，此时会报错Traceback (most recent call last):  ...  ...ValueError: all the input arrays must have same number of dimensions, ...</code></pre><h3 id="【5x03】numpy-concatenate"><a href="#【5x03】numpy-concatenate" class="headerlink" title="【5x03】numpy.concatenate()"></a><font color=#1BC3FB>【5x03】numpy.concatenate()</font></h3><p>numpy.concatenate() 方法能够一次完成多个相同形状数组的拼接。该方法效率更高，适合大规模的数据拼接。</p><p>基本语法：<code>numpy.concatenate((a1, a2, ...), axis=0)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a1, a2, …</td><td>要拼接的多个数组，<font color=#FF0000><strong>要求各数组形状相同</strong></font></td></tr><tr><td>axis</td><td>指定轴，按照指定轴的方向进行拼接，默认为 0 轴</td></tr></tbody></table><p><font color=#FF0000><strong>要求各数组形状相同</strong></font>举例：如果 axis=0，则要求 1 轴（竖轴）相同，如果 axis=1，则要求 0 轴（横轴）相同。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])&gt;&gt;&gt; b = np.array([[10, 11, 12], [13, 14, 15]])&gt;&gt;&gt; c = np.array([[16, 17, 18]])        # 三个二维数组的 1 轴（竖轴）相同&gt;&gt;&gt; print(np.concatenate((a, b, c)))    # 三个二维数组默认沿 0 轴（横轴）进行拼接[[ 1  2  3] [ 4  5  6] [ 7  8  9] [10 11 12] [13 14 15] [16 17 18]]</code></pre><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])&gt;&gt;&gt; b = np.array([[9, 10, 11], [12, 13, 14]])&gt;&gt;&gt; c = np.array([[15, 16], [17, 18]])          # 三个二维数组的 0 轴（横轴）相同&gt;&gt;&gt; print(np.concatenate((a, b, c), axis=1))    # 三个二维数组沿 1 轴（竖轴）进行拼接[[ 1  2  3  4  9 10 11 15 16] [ 5  6  7  8 12 13 14 17 18]]</code></pre><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])&gt;&gt;&gt; b = np.array([[9, 10, 11], [12, 13, 14]])&gt;&gt;&gt; c = np.array([[15, 16], [17, 18]])          # 三个二维数组的 0 轴（横轴）相同&gt;&gt;&gt; print(np.concatenate((a, b, c), axis=0))    # 三个二维数组沿 0 轴（横轴）进行拼接将会报错Traceback (most recent call last):  ...  ...ValueError: all the input array dimensions for the concatenation axis must match exactly, ...</code></pre><h3 id="【5x04】numpy-stack"><a href="#【5x04】numpy-stack" class="headerlink" title="【5x04】numpy.stack()"></a><font color=#1BC3FB>【5x04】numpy.stack()</font></h3><p>numpy.stack() 方法用于沿新轴连接数组序列。</p><p>基本语法：<code>numpy.stack(arrays, axis=0)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>arrays</td><td>相同形状的数组序列</td></tr><tr><td>axis</td><td>返回数组中的轴，输入数组将沿着该轴来进行堆叠</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 2, 3])&gt;&gt;&gt; b = np.array([4, 5, 6])&gt;&gt;&gt; print(np.stack((a, b),axis=0))[[1 2 3] [4 5 6]]&gt;&gt;&gt; print(np.stack((a, b),axis=1))[[1 4] [2 5] [3 6]]</code></pre><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1,2],[3,4]])&gt;&gt;&gt; b = np.array([[5,6],[7,8]])&gt;&gt;&gt; print(np.stack((a,b),axis=0))[[[1 2]  [3 4]] [[5 6]  [7 8]]]&gt;&gt;&gt; print(np.stack((a,b),axis=1))[[[1 2]  [5 6]] [[3 4]  [7 8]]]</code></pre><h3 id="【5x05】numpy-vstack"><a href="#【5x05】numpy-vstack" class="headerlink" title="【5x05】numpy.vstack()"></a><font color=#1BC3FB>【5x05】numpy.vstack()</font></h3><p>numpy.vstack() 方法通过垂直堆叠来生成数组。</p><p>基本语法：<code>numpy.vstack(tup)</code></p><p>参数解释：tup：数组序列，如果是一维数组进行堆叠，则数组长度必须相同，其它数组除了<font color=#FF0000><strong>第一个轴（axis=0）</strong></font>的长度可以不同外，其它轴的长度必须相同。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 2, 3])&gt;&gt;&gt; b = np.array([4, 5, 6])&gt;&gt;&gt; print(np.vstack((a,b)))[[1 2 3] [4 5 6]]&gt;&gt;&gt; &gt;&gt;&gt; b = np.array([4, 5])&gt;&gt;&gt; print(np.vstack((a,b)))       # 一维数组长度不一样时将抛出异常Traceback (most recent call last):  ...  ...ValueError: all the input array dimensions for the concatenation axis must match exactly, ...</code></pre><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1,2],[3,4]])&gt;&gt;&gt; b = np.array([[5,6],[7,8]])&gt;&gt;&gt; a.shape(2, 2)&gt;&gt;&gt; b.shape(2, 2)&gt;&gt;&gt; print(np.vstack((a,b)))[[1 2] [3 4] [5 6] [7 8]]</code></pre><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1,2],[3,4]])&gt;&gt;&gt; b = np.array([[5,6],[7,8],[9,10]])&gt;&gt;&gt; a.shape(2, 2)&gt;&gt;&gt; b.shape(3, 2)&gt;&gt;&gt; print(np.vstack((a,b)))    # 第一个轴（axis=0）可以不同，其它轴必须相同[[ 1  2] [ 3  4] [ 5  6] [ 7  8] [ 9 10]]</code></pre><h3 id="【5x06】numpy-hstack"><a href="#【5x06】numpy-hstack" class="headerlink" title="【5x06】numpy.hstack()"></a><font color=#1BC3FB>【5x06】numpy.hstack()</font></h3><p>numpy.hstack() 方法通过水平堆叠来生成数组。</p><p>基本语法：<code>numpy.hstack(tup)</code></p><p>参数解释：tup：数组序列，除了一维数组的堆叠可以是不同长度外，其它数组堆叠时，除了<font color=#FF0000><strong>第二个轴（axis=1）</strong></font>的长度可以不同外，其它轴的长度必须相同。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 2, 3])&gt;&gt;&gt; b = np.array([4, 5])&gt;&gt;&gt; print(np.hstack((a,b)))[1 2 3 4 5]</code></pre><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1,2],[3,4]])&gt;&gt;&gt; b = np.array([[5,6],[7,8]])&gt;&gt;&gt; a.shape(2, 2)&gt;&gt;&gt; b.shape(2, 2)&gt;&gt;&gt; print(np.hstack((a,b)))[[1 2 5 6] [3 4 7 8]]</code></pre><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1,2],[3,4]])&gt;&gt;&gt; b = np.array([[5,6,7],[8,9,10]])&gt;&gt;&gt; a.shape(2, 2)&gt;&gt;&gt; b.shape(2, 3)&gt;&gt;&gt; print(np.hstack((a,b)))       # 第二个轴（axis=1）可以不同，其它轴必须相同[[ 1  2  5  6  7] [ 3  4  8  9 10]]</code></pre><h3 id="【5x07】numpy-dstack"><a href="#【5x07】numpy-dstack" class="headerlink" title="【5x07】numpy.dstack()"></a><font color=#1BC3FB>【5x07】numpy.dstack()</font></h3><p>numpy.dstack() 方法会沿着第三个维度拼接数组。</p><p>基本语法：<code>numpy.dstack(tup)</code></p><p>参数解释：tup：数组序列，除了<font color=#FF0000><strong>第三个轴（axis=2）</strong></font>的长度可以不同外，其它轴的长度必须相同。一维或二维数组必须具有相同的形状。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])&gt;&gt;&gt; b = np.array([[[9], [10]], [[11], [12]]])&gt;&gt;&gt; a.shape(2, 2, 2)&gt;&gt;&gt; b.shape(2, 2, 1)&gt;&gt;&gt; print(np.dstack((a,b)))     # a 与 b 的第三个轴（axis=2）一个是 2，另一个是 1，可以不同，但其他轴必须相同[[[ 1  2  9]  [ 3  4 10]] [[ 5  6 11]  [ 7  8 12]]]</code></pre><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])&gt;&gt;&gt; b = np.array([[[9, 10], [11, 12]]])&gt;&gt;&gt; a.shape(2, 2, 2)&gt;&gt;&gt; b.shape(1, 2, 2)&gt;&gt;&gt; print(np.dstack((a,b)))    # a 与 b 的第一个轴（axis=0）不同，将会抛出异常[[[ 1  2  9]  [ 3  4 10]] [[ 5  6 11]  [ 7  8 12]]]&gt;&gt;&gt; print(np.dstack((a,b)))Traceback (most recent call last):  ...  ...ValueError: all the input array dimensions for the concatenation axis must match exactly, ...</code></pre><h3 id="【5x08】以上几种方法的区别"><a href="#【5x08】以上几种方法的区别" class="headerlink" title="【5x08】以上几种方法的区别"></a><font color=#1BC3FB>【5x08】以上几种方法的区别</font></h3><ul><li><code>concatenate()</code> 方法在 <code>axis=0</code> 的时候相当于 <code>vstack()</code> 方法；</li><li><code>concatenate()</code> 方法在 <code>axis=1</code> 的时候相当于 <code>hstack()</code> 方法；</li><li><code>concatenate()</code> 方法在 <code>axis=2</code> 的时候相当于 <code>dstack()</code> 方法；</li><li><code>concatenate()</code> 方法<font color=#FF0000><strong>不会</strong></font>生成一个新的维度，且数组的维度不一定相同，而 stack() 方法<font color=#FF0000><strong>会</strong></font>生成一个新的维度，并且要求所有数组形状都要一样。</li></ul><p><code>concatenate()</code> 方法与 <code>stack()</code> 方法比较：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 2, 3])&gt;&gt;&gt; b = np.array([4, 5, 6])&gt;&gt;&gt; c = np.stack((a, b), axis=0)&gt;&gt;&gt; d = np.concatenate((a, b), axis=0)&gt;&gt;&gt; a.shape(3,)&gt;&gt;&gt; b.shape(3,)&gt;&gt;&gt; c.shape(2, 3)&gt;&gt;&gt; d.shape(6,)&gt;&gt;&gt; print(c)[[1 2 3] [4 5 6]]&gt;&gt;&gt; print(d)[1 2 3 4 5 6]</code></pre><h3 id="【5x09】numpy-insert"><a href="#【5x09】numpy-insert" class="headerlink" title="【5x09】numpy.insert()"></a><font color=#1BC3FB>【5x09】numpy.insert()</font></h3><p>numpy.insert() 方法沿指定轴在指定索引之前插入值。</p><p>基本语法：<code>numpy.insert(arr, obj, values, axis=None)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>arr</td><td>原数组</td></tr><tr><td>obj</td><td>索引值，将在其之前插入值</td></tr><tr><td>values</td><td>要插入的值</td></tr><tr><td>axis</td><td>轴，将沿着该轴进行插入操作，如果未指定，则插入前，原数组会被展开，变为一维数组</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1,2],[3,4],[5,6]])&gt;&gt;&gt; print(np.insert(a, 3, [0, 0]))          # 未指定 axis 参数，在插入之前原数组会被展开[1 2 3 0 0 4 5 6]&gt;&gt;&gt; print(np.insert(a, 1, [0], axis = 0))   # 沿 0 轴广播插入[[1 2] [0 0] [3 4] [5 6]]&gt;&gt;&gt; print(np.insert(a, 1, 11, axis = 1))    # 沿 1 轴广播插入[[ 1 11  2] [ 3 11  4] [ 5 11  6]]</code></pre><h3 id="【5x10】numpy-r"><a href="#【5x10】numpy-r" class="headerlink" title="【5x10】numpy.r_"></a><font color=#1BC3FB>【5x10】numpy.r_</font></h3><p>numpy.r_：<code>r</code> 为 <code>row（行）</code> 的缩写，即按照行连接两个矩阵，要求列数相等。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3],[7, 8, 9]])&gt;&gt;&gt; b = np.array([[4, 5, 6],[1, 2, 3]])&gt;&gt;&gt; &gt;&gt;&gt; np.r_[a, b]array([[1, 2, 3],       [7, 8, 9],       [4, 5, 6],       [1, 2, 3]])</code></pre><h3 id="【5x11】numpy-c"><a href="#【5x11】numpy-c" class="headerlink" title="【5x11】numpy.c_"></a><font color=#1BC3FB>【5x11】numpy.c_</font></h3><p>numpy.c_：<code>c</code> 为 <code>column（列）</code> 的缩写，即按照列连接两个矩阵，要求行数相等。</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3],[7, 8, 9]])&gt;&gt;&gt; b = np.array([[4, 5, 6],[1, 2, 3]])&gt;&gt;&gt; &gt;&gt;&gt; np.c_[a, b]array([[1, 2, 3, 4, 5, 6],       [7, 8, 9, 1, 2, 3]])</code></pre><h2 id="【6x00】数组的分割与元素的删除"><a href="#【6x00】数组的分割与元素的删除" class="headerlink" title="【6x00】数组的分割与元素的删除"></a><font color=#FF0000>【6x00】数组的分割与元素的删除</font></h2><h3 id="【6x01】numpy-split"><a href="#【6x01】numpy-split" class="headerlink" title="【6x01】numpy.split()"></a><font color=#1BC3FB>【6x01】numpy.split()</font></h3><p>numpy.split() 方法可以沿特定的轴将数组<font color=#FF0000><strong>均等</strong></font>的分割为子数组。如果不能等分，将抛出异常。</p><p>基本语法：<code>numpy.split(ary, indices_or_sections, axis=0)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>ary</td><td>被分割的数组</td></tr><tr><td>indices_or_sections</td><td>如果是一个整数 N，则该数组将沿 axis <font color=#FF0000><strong>均分</strong></font>为 N 个数组<br>如果是一维整数数组，则数组元素代表每个分割点位置（左闭右开），N 个分裂点会得到 N + 1 个子数组</td></tr><tr><td>axis</td><td>沿着哪个维度进行分割，默认为 0，横向分割；为 1 时，纵向分割</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(10)&gt;&gt;&gt; print(a)[0 1 2 3 4 5 6 7 8 9]&gt;&gt;&gt; print(np.split(a, 5))              # 将数组分为五个大小相等的子数组[array([0, 1]),  array([2, 3]),  array([4, 5]),  array([6, 7]),  array([8, 9])]&gt;&gt;&gt;&gt;&gt;&gt; print(np.split(a, 4))              # 无法等分的情况下将抛出异常Traceback (most recent call last):  ...  ...ValueError: array split does not result in an equal division&gt;&gt;&gt;&gt;&gt;&gt; print(np.split(a, [4, 8]))        # 分割点为索引 4 和 8 的位置，相当于 a[:4]、a[4:8]、a[8:][array([0, 1, 2, 3]),  array([4, 5, 6, 7]),  array([8, 9])]&gt;&gt;&gt;&gt;&gt;&gt; a = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])&gt;&gt;&gt; print(np.split(a, 5, axis=1))     # 指定 axis=1，按照纵向分割数组[array([[1],         [6]]), array([[2],          [7]]), array([[3],          [8]]), array([[4],          [9]]), array([[ 5],          [10]])]</code></pre><h3 id="【6x02】numpy-array-split"><a href="#【6x02】numpy-array-split" class="headerlink" title="【6x02】numpy.array_split()"></a><font color=#1BC3FB>【6x02】numpy.array_split()</font></h3><p>numpy.array_split() 的用法和作用都与 split() 方法一致，都可以用一个整数或者整数列表来分割数组。</p><p>两者的区别：如果输入的是一个 int 类型的数字，那么在 split() 方法中，数组必须是均等的分割，否则就会报错，而在 array_split() 方法中是可以进行不均等的分割的。</p><p>基本语法：<code>numpy.array_split(ary, indices_or_sections, axis=0)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>ary</td><td>被分割的数组</td></tr><tr><td>indices_or_sections</td><td>如果是一个整数 N，则该数组将沿 axis 分割为 N 个数组，<font color=#FF0000><strong>可以不是均分的</strong></font><br>如果是一维整数数组，则数组元素代表每个分割点位置（左闭右开），N 个分裂点会得到 N + 1 个子数组</td></tr><tr><td>axis</td><td>沿着哪个维度进行分割，默认为 0，横向分割；为 1 时，纵向分割</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 2, 3, 4, 5, 6, 7])&gt;&gt;&gt; print(np.array_split(a, 3))[array([1, 2, 3]), array([4, 5]), array([6, 7])]   # 可以是不均分的&gt;&gt;&gt;&gt;&gt;&gt; print(np.array_split(a, 4))[array([1, 2]), array([3, 4]), array([5, 6]), array([7])]</code></pre><h3 id="【6x03】numpy-vsplit"><a href="#【6x03】numpy-vsplit" class="headerlink" title="【6x03】numpy.vsplit()"></a><font color=#1BC3FB>【6x03】numpy.vsplit()</font></h3><p>numpy.vsplit() 方法相当于 split() 方法在 <font color=#FF0000>axis=0</font> 时的效果，即横向分割数组。</p><p>基本语法：<code>numpy.vsplit(ary, indices_or_sections)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>ary</td><td>被分割的数组</td></tr><tr><td>indices_or_sections</td><td>如果是一个整数 N，则该数组将沿 axis 分为 N 个相等的数组<br>如果是一维整数数组，则数组元素代表每个分割点位置（左闭右开），N 个分裂点会得到 N + 1 个子数组</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])&gt;&gt;&gt; print(np.vsplit(a, 2))[array([[1, 2, 3],         [4, 5, 6]]), array([[ 7,  8,  9],          [10, 11, 12]])]&gt;&gt;&gt;&gt;&gt;&gt; print(np.vsplit(a, [1, 3]))[array([[1, 2, 3]]), array([[4, 5, 6],          [7, 8, 9]]), array([[10, 11, 12]])]</code></pre><h3 id="【6x04】numpy-hsplit"><a href="#【6x04】numpy-hsplit" class="headerlink" title="【6x04】numpy.hsplit()"></a><font color=#1BC3FB>【6x04】numpy.hsplit()</font></h3><p>numpy.hsplit() 方法相当于 split() 方法在 <font color=#FF0000>axis=1</font> 时的效果，即纵向分割数组。</p><p>基本语法：<code>numpy.hsplit(ary, indices_or_sections)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>ary</td><td>被分割的数组</td></tr><tr><td>indices_or_sections</td><td>如果是一个整数 N，则该数组将沿 axis 分为 N 个相等的数组<br>如果是一维整数数组，则数组元素代表每个分割点位置（左闭右开），N 个分裂点会得到 N + 1 个子数组</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])&gt;&gt;&gt; print(np.hsplit(a, 5))[array([[1],         [6]]),  array([[2],          [7]]), array([[3],          [8]]), array([[4],          [9]]), array([[ 5],          [10]])]&gt;&gt;&gt;&gt;&gt;&gt; print(np.hsplit(a, [1, 3]))[array([[1],         [6]]), array([[2, 3],          [7, 8]]), array([[ 4,  5],          [ 9, 10]])]</code></pre><h3 id="【6x05】numpy-dsplit"><a href="#【6x05】numpy-dsplit" class="headerlink" title="【6x05】numpy.dsplit()"></a><font color=#1BC3FB>【6x05】numpy.dsplit()</font></h3><p>numpy.dsplit() 方法相当于 split() 方法在 <font color=#FF0000>axis=2</font> 时的效果，即沿第三轴将数组拆分为多个子数组。</p><p>基本语法：<code>numpy.dsplit(ary, indices_or_sections)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>ary</td><td>被分割的数组</td></tr><tr><td>indices_or_sections</td><td>如果是一个整数 N，则该数组将沿 axis 分为 N 个相等的数组<br>如果是一维整数数组，则数组元素代表每个分割点位置（左闭右开），N 个分裂点会得到 N + 1 个子数组</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(16).reshape(2, 2, 4)&gt;&gt;&gt; print(a)[[[ 0  1  2  3]  [ 4  5  6  7]] [[ 8  9 10 11]  [12 13 14 15]]]&gt;&gt;&gt; print(np.dsplit(a, 2))[array([[[ 0,  1],          [ 4,  5]],          [[ 8,  9],          [12, 13]]]),  array([[[ 2,  3],           [ 6,  7]],           [[10, 11],           [14, 15]]])]&gt;&gt;&gt;&gt;&gt;&gt; print(np.dsplit(a, [3, 6]))[array([[[ 0,  1,  2],          [ 4,  5,  6]],          [[ 8,  9, 10],          [12, 13, 14]]]), array([[[ 3],           [ 7]],           [[11],           [15]]]),  array([], shape=(2, 2, 0), dtype=int32)]</code></pre><h3 id="【6x06】numpy-delete"><a href="#【6x06】numpy-delete" class="headerlink" title="【6x06】numpy.delete()"></a><font color=#1BC3FB>【6x06】numpy.delete()</font></h3><p>numpy.delete() 方法返回一个从原数组中删除了指定子数组的新数组。</p><p>基本语法：<code>numpy.delete(arr，obj，axis=None)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>arr</td><td>原数组</td></tr><tr><td>obj</td><td>可以是切片、整数或整数数组形式，表示沿指定轴删除的子数组的索引<br>当 obj 为切片形式时，要用 <code>np.s_[:]</code> 的格式</td></tr><tr><td>axis</td><td>轴，将沿着该轴进行插入操作，如果未指定，则插入前，原数组会被展开，变为一维数组</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])&gt;&gt;&gt; print(np.delete(a, 8))          # 未指定 axis 参数，在插入之前原数组会被展开，然后再删除索引为 8 的元素[ 1  2  3  4  5  6  7  8 10 11 12]&gt;&gt;&gt;&gt;&gt;&gt; print(np.delete(a, 1, axis=0))  # 指定 axis=0，删除索引值为 1 即第二行[[ 1  2  3  4] [ 9 10 11 12]]&gt;&gt;&gt;&gt;&gt;&gt; print(np.delete(a, 1, axis=1))  # 指定 axis=1，删除索引值为 1 即第二列[[ 1  3  4] [ 5  7  8] [ 9 11 12]]&gt;&gt;&gt;&gt;&gt;&gt; print(np.delete(a, np.s_[:2], axis=1)) # 切片形式，删除前两列[[ 3  4] [ 7  8] [11 12]]&gt;&gt;&gt;&gt;&gt;&gt; print(np.delete(a, [0, 2], axis=1))    # 数组形式，删除索引值为 0 和 2 的列[[ 2  4] [ 6  8] [10 12]]</code></pre><h3 id="【6x07】numpy-unique"><a href="#【6x07】numpy-unique" class="headerlink" title="【6x07】numpy.unique()"></a><font color=#1BC3FB>【6x07】numpy.unique()</font></h3><p>numpy.unique() 方法用于去除数组中的重复元素。</p><p>基本语法：<code>numpy.unique(arr, return_index=False, return_inverse=False, return_counts=False, axis=None)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>arr</td><td>原数组，如果不是一维数组则会被展开为一维数组</td></tr><tr><td>return_index</td><td>如果为 true，则返回新列表元素在旧列表中的位置（下标），并以列表形式储</td></tr><tr><td>return_inverse</td><td>如果为 true，则返回旧列表元素在新列表中的位置（下标），并以列表形式储</td></tr><tr><td>return_counts</td><td>如果为 true，则返回去重数组中的元素在原数组中的出现次数</td></tr><tr><td>axis</td><td>指定轴</td></tr></tbody></table><p>应用举例：</p><p>未指定 axis 值，原数组将会被展开：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 1, 2, 2, 3, 4, 5, 5])&gt;&gt;&gt; b = np.array([[1, 1], [2, 3], [3, 4]])&gt;&gt;&gt; print(np.unique(a))[1 2 3 4 5]&gt;&gt;&gt; print(np.unique(b))[1 2 3 4]</code></pre><p>指定 axis 值：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 0, 1], [1, 0, 1], [2, 3, 2], [5, 6, 5]])&gt;&gt;&gt; print(a)[[1 0 1] [1 0 1] [2 3 2] [5 6 5]]&gt;&gt;&gt; print(np.unique(a, axis=0))    # 删除相同的行[[1 0 1] [2 3 2] [5 6 5]]&gt;&gt;&gt; print(np.unique(a, axis=1))    # 删除相同的列[[0 1] [0 1] [3 2] [6 5]]</code></pre><p>return_counts 为 True 时，返回去重数组中的元素在原数组中的出现次数：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 1, 1, 2, 2, 3, 4, 5, 5])&gt;&gt;&gt; print(np.unique(a, return_counts=True))(array([1, 2, 3, 4, 5]), array([3, 2, 1, 1, 2], dtype=int64))# 前一个 array 表示去重后的数组，后一个 array 表示每一个元素在原数组中出现的次数</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/104988137未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> NumPy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据分析三剑客之 NumPy（一）：理解 NumPy / 数组基础</title>
      <link href="/article/008/"/>
      <url>/article/008/</url>
      
        <content type="html"><![CDATA[<p>NumPy 系列文章：</p><ul><li><a href="https://www.itbob.cn/article/008/">Python 数据分析三剑客之 NumPy（一）：理解 NumPy / 数组基础</a></li><li><a href="https://www.itbob.cn/article/009/">Python 数据分析三剑客之 NumPy（二）：数组索引 / 切片 / 广播 / 拼接 / 分割</a></li><li><a href="https://www.itbob.cn/article/010/">Python 数据分析三剑客之 NumPy（三）：数组的迭代与位运算</a></li><li><a href="https://www.itbob.cn/article/011/">Python 数据分析三剑客之 NumPy（四）：字符串函数总结与对比</a></li><li><a href="https://www.itbob.cn/article/012/">Python 数据分析三剑客之 NumPy（五）：数学 / 算术 / 统计 / 排序 / 条件 / 判断函数合集</a></li><li><a href="https://www.itbob.cn/article/013/">Python 数据分析三剑客之 NumPy（六）：矩阵 / 线性代数库与 IO 操作</a></li></ul><p>专栏：</p><ul><li>NumPy 专栏：<a href="https://itrhx.blog.csdn.net/category_9780393.html">https://itrhx.blog.csdn.net/category_9780393.html</a></li><li>Pandas 专栏：<a href="https://itrhx.blog.csdn.net/category_9780397.html">https://itrhx.blog.csdn.net/category_9780397.html</a></li><li>Matplotlib 专栏：<a href="https://itrhx.blog.csdn.net/category_9780418.html">https://itrhx.blog.csdn.net/category_9780418.html</a></li></ul><p>推荐学习资料与网站：</p><ul><li>NumPy 官方中文网：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></li><li>Pandas 官方中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></li><li>Matplotlib 官方中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></li><li>NumPy、Matplotlib、Pandas 速查表：<a href="https://github.com/TRHX/Python-quick-reference-table">https://github.com/TRHX/Python-quick-reference-table</a></li></ul><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/104870084未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【1x00】了解-NumPy"><a href="#【1x00】了解-NumPy" class="headerlink" title="【1x00】了解 NumPy"></a><font color=#ff0000>【1x00】了解 NumPy</font></h2><p>NumPy 是使用 Python 进行科学计算的基础包，支持大量的维度数组与矩阵运算，对数组运算提供大量的数学函数库。NumPy 重在数值计算，是大部分 Python 科学计算库的基础库，多用于在大型、多维数组上执行数值运算。</p><p>NumPy 主要包含如下的内容：</p><ul><li>一个强大的 N 维数组对象（Ndarray）；</li><li>复杂的广播功能函数；</li><li>集成 C/C++/Fortran 代码的工具；</li><li>具有线性代数、傅里叶变换、随机数生成等功能。</li></ul><h2 id="【2x00】NumPy-数组与-Python-列表的区别"><a href="#【2x00】NumPy-数组与-Python-列表的区别" class="headerlink" title="【2x00】NumPy 数组与 Python 列表的区别"></a><font color=#ff0000>【2x00】NumPy 数组与 Python 列表的区别</font></h2><p>Numpy 使用 Ndarray 对象来处理多维数组，Python 列表通常存储一维数组，通过列表的嵌套也可以实现多维数组。</p><p>Numpy 的 Ndarray 对象是一个快速而灵活的大数据容器。Numpy 专门针对数组的操作和运算进行了设计，所以数组的存储效率和输入输出性能远优于 Python 中的嵌套列表，数组越大，Numpy 的优势就越明显。</p><p>通常 Numpy 数组中的所有元素的类型都是相同的，而 Python 列表中的元素类型是任意的，所以在通用性能方面 Numpy 数组不及 Python 列表，但在科学计算中，可以省掉很多循环语句，代码使用方面比 Python 列表简单的多。</p><p>Python 列表的元素不同类型举例：</p><pre><code class="python">&gt;&gt;&gt; l = [True, &#39;2&#39;, 3.2, 5]&gt;&gt;&gt; [type(item) for item in l][&lt;class &#39;bool&#39;&gt;, &lt;class &#39;str&#39;&gt;, &lt;class &#39;float&#39;&gt;, &lt;class &#39;int&#39;&gt;]</code></pre><p>Python 列表中的每一项必须包含各自的类型信息、引用计数和其他信息，也就是说，每一项都是一个完整的 Python 对象，同时，Python 列表还包含一个指向指针块的指针，其中的每一个指针对应一个完整的 Python 对象，另外，列表的优势是灵活，因为每个列表元素是一个包含数据和类型信息的完整结构体。相反 NumPy 数组缺乏这种灵活性，但是 NumPy 却能更有效地存储和操作数据。</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A62/01.png" alt="01"></p><h2 id="【3x00】理解-NumPy-Ndarray-对象"><a href="#【3x00】理解-NumPy-Ndarray-对象" class="headerlink" title="【3x00】理解 NumPy Ndarray 对象"></a><font color=#ff0000>【3x00】理解 NumPy Ndarray 对象</font></h2><p>NumPy 提供了一个 N 维数组类型，即 Ndarray，它是一系列同类型数据的集合，是用于存放同类型元素的多维数组，以 0 下标为开始进行集合中元素的索引，所有 Ndarray 中的每个元素在内存中都有相同存储大小的区域。</p><p>Ndarray 内部由以下内容组成：</p><ul><li>一个指向数据（内存或内存映射文件中的一块数据）的指针；</li><li>数据类型或 dtype，描述在数组中的固定大小值的格子；</li><li>一个表示数组形状（shape）的元组，表示各维度大小的元组；</li><li>一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要“跨过”的字节数。</li></ul><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A62/02.png" alt="02"></p><h2 id="【4x00】理解不同维度的数组"><a href="#【4x00】理解不同维度的数组" class="headerlink" title="【4x00】理解不同维度的数组"></a><font color=#FF0000>【4x00】理解不同维度的数组</font></h2><p>NumPy 数组的维数称为秩（rank），秩就是轴的数量，即数组的维度，一维数组的秩为 1，二维数组的秩为 2，以此类推。</p><p>在 NumPy 中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是 NumPy 中的轴（axis），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量 — 秩，就是数组的维数。</p><p>很多时候可以声明 axis，axis=0，表示沿着第 0 轴进行操作，即对每一列进行操作；axis=1，表示沿着第 1 轴进行操作，即对每一行进行操作。</p><p>一维数组：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 2, 3, 4])&gt;&gt;&gt; print(a)[1 2 3 4]&gt;&gt;&gt; print(a.shape)(4,)</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A62/03.png" alt="03"></p><hr><p>二维数组：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])&gt;&gt;&gt; print(a)[[1 2 3 4] [5 6 7 8]]&gt;&gt;&gt; print(a.shape)(2, 4)</code></pre><blockquote><p>a.shape 输出数组的维度，对于此二维数组，可以理解为 2 行 4 列。</p></blockquote><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A62/04.png" alt="04"></p><hr><p>三维数组：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[[1,2,3,4], [5,6,7,8]], [[9,10,11,12], [13,14,15,16]], [[17,18,19,20], [21,22,23,24]]])&gt;&gt;&gt; print(a)[[[ 1  2  3  4]  [ 5  6  7  8]] [[ 9 10 11 12]  [13 14 15 16]] [[17 18 19 20]  [21 22 23 24]]]&gt;&gt;&gt; print(a.shape)(3, 2, 4)</code></pre><blockquote><p>a.shape 输出数组的维度，对于此三维数组，可以理解为 3 块，每块有 2 行 4 列。</p></blockquote><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A62/05.png" alt="05"></p><p>有网友对三维数组的这个图有疑问，认为横线应该是 axis=0，竖线是 axis=1，斜线是 axis=2，这个确实有点儿绕，不要受到前面一维二维的影响，我把我的理解又画了一张图出来，另外大家可以尝试去取三维数组里面的某个值，多想一下就可以理解了。欢迎各位大佬一起交流学习！</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A62/06.png" alt="06"></p><h2 id="【5x00】创建-Ndarray-对象（创建数组）"><a href="#【5x00】创建-Ndarray-对象（创建数组）" class="headerlink" title="【5x00】创建 Ndarray 对象（创建数组）"></a><font color=#FF0000>【5x00】创建 Ndarray 对象（创建数组）</font></h2><h3 id="【5x01】一张表快速了解创建数组的不同方法"><a href="#【5x01】一张表快速了解创建数组的不同方法" class="headerlink" title="【5x01】一张表快速了解创建数组的不同方法"></a><font color=#00CD00>【5x01】一张表快速了解创建数组的不同方法</font></h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>numpy.array()</td><td>将输入数据（列表、元组、Ndarray 等）转换为数组形式<br><font color=#0000FF><strong>当数据源为 Ndarray 时，该方法仍然会 copy 出一个副本，占用新的内存</strong></font></td></tr><tr><td>numpy.asarray()</td><td>将输入数据（列表、元组、Ndarray 等）转换为数组形式<br><font color=#0000FF><strong>当数据源为 Ndarray 时，该方法不会 copy 出一个副本，不占用新的内存</strong></font></td></tr><tr><td>numpy.arange()</td><td>创建一个一维数组，该数组由一个等差数列构成<br><font color=#B22222><strong>通过指定开始值、终值和步长创建等差数列，得到的结果数组不包含终值</strong></font></td></tr><tr><td>numpy.linspace()</td><td>创建一个一维数组，该数组由一个等差数列构成<br><font color=#B22222><strong>通过指定开始值、终值和元素个数创建等差数列，可通过 endpoint 参数指定是否包含终值</strong></font></td></tr><tr><td>numpy.logspace()</td><td>创建一个一维数组，该数组由一个等比数列构成</td></tr><tr><td>numpy.empty()</td><td>创建一个指定形状、数据类型且未初始化的数组</td></tr><tr><td>numpy.zeros()</td><td>创建一个指定大小的数组，数组元素以 0 来填充</td></tr><tr><td>numpy.ones()</td><td>创建一个指定大小的数组，数组元素以 1 来填充</td></tr><tr><td>numpy.eye()</td><td>创建一个对角矩阵数组，返回一个二维数组，对角线上值为 1，其余位置为 0</td></tr><tr><td>numpy.frombuffer()</td><td>将缓冲区解释为一维数组，接受 buffer 输入参数，以流的形式读入并转化成 Ndarray 对象</td></tr><tr><td>numpy.fromiter()</td><td>从可迭代对象中建立 Ndarray 对象，返回一个一维数组</td></tr></tbody></table><h3 id="【5x02】numpy-array"><a href="#【5x02】numpy-array" class="headerlink" title="【5x02】numpy.array()"></a><font color=#1BC3FB>【5x02】numpy.array()</font></h3><p>调用 NumPy 的 array 方法即可创建一个 Ndarray 对象，即创建一个数组。</p><p>基本语法：<code>numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>object</td><td>数组或嵌套的数列</td></tr><tr><td>dtype</td><td>数组元素的数据类型，可选</td></tr><tr><td>copy</td><td>对象是否需要复制，可选</td></tr><tr><td>order</td><td>创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）</td></tr><tr><td>subok</td><td>默认返回一个与基类类型一致的数组</td></tr><tr><td>ndmin</td><td>指定生成数组的最小维度</td></tr></tbody></table><p>创建一个一维数组：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1, 2, 3])&gt;&gt;&gt; print(a)[1 2 3]&gt;&gt;&gt; print(type(a))&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><p>创建一个二维数组：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]])&gt;&gt;&gt; print(a)[[1 2 3] [4 5 6]]&gt;&gt;&gt; print(type(a))&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><p>创建一个三维数组：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[[1,2,3], [4,5,6]], [[7,8,9], [10,11,12]]])&gt;&gt;&gt; print(a)[[[ 1  2  3]  [ 4  5  6]] [[ 7  8  9]  [10 11 12]]]</code></pre><h3 id="【5x03】numpy-asarray"><a href="#【5x03】numpy-asarray" class="headerlink" title="【5x03】numpy.asarray()"></a><font color=#1BC3FB>【5x03】numpy.asarray()</font></h3><p>numpy.asarray() 方法将输入数据（列表、元组、Ndarray 等）转换为数组形式，与 numpy.array() 方法类似，但 asarray 参数比 array 少两个，另外最大的区别是<font color=#FF0000><strong>当数据源为 Ndarray 时</strong></font>，array 方法仍然会 copy 出一个副本，占用新的内存，但 asarray 方法不会。</p><p>基本语法：<code>numpy.asarray(a, dtype=None, order=None)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>待转换对象，可以是列表，元组，列表元组，元组列表，多维数组等</td></tr><tr><td>dtype</td><td>可选项，指定数据类型</td></tr><tr><td>order</td><td>可选项，以行优先（C）或列优先（F）的顺序存储多维数据在内存中</td></tr></tbody></table><p>将列表转换为 Ndarray：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; l = [1,2,3,4]&gt;&gt;&gt; n = np.asarray(l)&gt;&gt;&gt; print(n)[1 2 3 4]&gt;&gt;&gt; print(type(n))&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><p>将元组转换为 Ndarray：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; l = (1,2,3,4)&gt;&gt;&gt; n = np.asarray(l)&gt;&gt;&gt; print(n)[1 2 3 4]&gt;&gt;&gt; print(type(n))&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><p>将元组列表转换为 Ndarray：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; l = [(1,2,3),(4,5)]&gt;&gt;&gt; n = np.asarray(l)&gt;&gt;&gt; print(n)[(1, 2, 3) (4, 5)]&gt;&gt;&gt; print(type(n))&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><p>指定 dtype 参数：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; l = [1,2,3]&gt;&gt;&gt; n = np.asarray(l, dtype=float)&gt;&gt;&gt; print(n)[1. 2. 3.]&gt;&gt;&gt; print(type(n))&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><p>numpy.asarray() 方法和 numpy.array() 的区别演示：</p><p>当输入数据为列表、元组等格式时，两者没有区别，都可以将其转为数组格式：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = [[1,2,3], [4,5,6], [7,8,9]]&gt;&gt;&gt; b = np.array(a)&gt;&gt;&gt; c = np.asarray(a)&gt;&gt;&gt; a[1] = 0&gt;&gt;&gt; print(a)[[1, 2, 3], 0, [7, 8, 9]]&gt;&gt;&gt; print(type(a))                # a 为列表&lt;class &#39;list&#39;&gt;&gt;&gt;&gt; print(b)                      # 列表对象 a 的值改变，array 方法得到的值不会改变[[1 2 3] [4 5 6] [7 8 9]]&gt;&gt;&gt; print(c)                      # 列表对象 a 的值改变，asarray 方法得到的值不会改变[[1 2 3] [4 5 6] [7 8 9]]</code></pre><p>当输入数据为 Ndarray 时，array 方法仍然会 copy 出一个副本，占用新的内存，但 asarray 方法不会：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.ones((3,3))&gt;&gt;&gt; b = np.array(a)&gt;&gt;&gt; c = np.asarray(a)&gt;&gt;&gt; a[1][1] = 2&gt;&gt;&gt; print(a)[[1. 1. 1.] [1. 2. 1.] [1. 1. 1.]]&gt;&gt;&gt; print(type(a))               # a 为 Ndarray 对象&lt;class &#39;numpy.ndarray&#39;&gt;&gt;&gt;&gt; print(b)                     # Ndarray 对象 a 的值改变，array 方法得到的值不会改变[[1. 1. 1.] [1. 1. 1.] [1. 1. 1.]]&gt;&gt;&gt; print(c)                     # Ndarray 对象 a 的值改变，asarray 方法得到的值也将改变[[1. 1. 1.] [1. 2. 1.] [1. 1. 1.]]</code></pre><h3 id="【5x04】numpy-arange"><a href="#【5x04】numpy-arange" class="headerlink" title="【5x04】numpy.arange()"></a><font color=#1BC3FB>【5x04】numpy.arange()</font></h3><p>numpy.arange() 方法用于创建一个一维数组，在指定的间隔内返回均匀间隔的数字并组成数组（Ndarray 对象），即该数组是一个等差数列构成的。arange() 类似 Python 的 range()，但是 arange() 的步长可以为小数，而 range() 的步长只能是整数。</p><p>基本语法：<code>numpy.arange([start, ]stop, [step, ]dtype=None)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>起始值，数字，可选项，默认起始值为 0，生成的元素包括起始值</td></tr><tr><td>stop</td><td>结束值，数字，生成的元素不包括结束值</td></tr><tr><td>step</td><td>步长，数字，可选项， 默认步长为 1，如果指定了 step，则必须给出 start</td></tr><tr><td>dtype</td><td>输出数组的类型，如果未给出 dtype，则从其他输入参数推断数据类型</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(5)        # 相当于 np.array([0, 1, 2, 3, 4])&gt;&gt;&gt; b = np.arange(2, 5)     # 相当于 np.array([2, 3, 4])&gt;&gt;&gt; c = np.arange(2, 9, 3)&gt;&gt;&gt; print(&#39;a = %s\nb = %s\nc = %s&#39; %(a,b,c))a = [0 1 2 3 4]b = [2 3 4]c = [2 5 8]</code></pre><h3 id="【5x05】numpy-linspace"><a href="#【5x05】numpy-linspace" class="headerlink" title="【5x05】numpy.linspace()"></a><font color=#1BC3FB>【5x05】numpy.linspace()</font></h3><p>numpy.linspace() 方法用于创建一个一维数组，在指定的间隔内返回均匀间隔的数字并组成数组（Ndarray 对象），即该数组是一个等差数列构成的。linspace() 方法类似于 arange()，两者除了参数有差别以外，还有以下的区别：</p><ul><li><p>arange() 方法类似于内置函数 range()，通过指定<strong>开始值、终值和<font color=#FF0000>步长</strong></font>创建表示等差数列的一维数组，得到的结果数组不包含终值。</p></li><li><p>linspace() 通过指定<strong>开始值、终值和<font color=#FF0000>元素个数</strong></font>创建表示等差数列的一维数组，可以通过 endpoint 参数指定是否包含终值，默认值为True，即包含终值。</p></li></ul><p>基本语法：<code>numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>序列的起始值</td></tr><tr><td>stop</td><td>序列的终止值，如果 endpoint 为 True，则该值将包含于数列中</td></tr><tr><td>num</td><td>可选项，int 类型，要生成的等步长的样本数量，即元素个数，默认为 50</td></tr><tr><td>endpoint</td><td>可选项，bool 类型，该值为 True 时，数列中将包含 stop 值，反之则不包含，默认为 True</td></tr><tr><td>retstep</td><td>可选项，bool 类型，该值为 True 时，生成的数组中会显示间距，反之则不显示，默认为 False</td></tr><tr><td>dtype</td><td>可选项，Ndarray 的数据类型</td></tr><tr><td>axis</td><td>可选项，int 类型，结果中的轴用于存储样本。仅当 start 或 stop 类似于数组时才相关<br>默认情况下为 0，采样将沿着在开始处插入的新轴进行，使用 -1 来获得轴的末端</td></tr></tbody></table><p>应用举例：</p><p>不指定 num 值，将默认生成 50 个元素，数列中将包含 stop 值：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.linspace(1, 10)&gt;&gt;&gt; print(a)[ 1.          1.18367347  1.36734694  1.55102041  1.73469388  1.91836735  2.10204082  2.28571429  2.46938776  2.65306122  2.83673469  3.02040816  3.20408163  3.3877551   3.57142857  3.75510204  3.93877551  4.12244898  4.30612245  4.48979592  4.67346939  4.85714286  5.04081633  5.2244898  5.40816327  5.59183673  5.7755102   5.95918367  6.14285714  6.32653061  6.51020408  6.69387755  6.87755102  7.06122449  7.24489796  7.42857143  7.6122449   7.79591837  7.97959184  8.16326531  8.34693878  8.53061224  8.71428571  8.89795918  9.08163265  9.26530612  9.44897959  9.63265306  9.81632653 10.        ]</code></pre><p>指定 num 值为 10，将生成 10 个元素，数列中将包含 stop 值：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.linspace(1, 10, 10)&gt;&gt;&gt; print(a)[ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]</code></pre><p>指定 endpoint 值为 False，retstep 值为 True，数列中不包含 stop 值，生成的数组中会显示间距：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.linspace(1, 10, 10, endpoint=False, retstep=True)&gt;&gt;&gt; print(a)(array([1. , 1.9, 2.8, 3.7, 4.6, 5.5, 6.4, 7.3, 8.2, 9.1]), 0.9)</code></pre><p>指定 dtype 类型为 int：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.linspace(1, 10, 10, endpoint=False, retstep=True, dtype=int)&gt;&gt;&gt; print(a)(array([1, 1, 2, 3, 4, 5, 6, 7, 8, 9]), 0.9)</code></pre><h3 id="【5x06】numpy-logspace"><a href="#【5x06】numpy-logspace" class="headerlink" title="【5x06】numpy.logspace()"></a><font color=#1BC3FB>【5x06】numpy.logspace()</font></h3><p>numpy.logspace() 方法用于创建一个一维数组，该数组由一个等比数列构成。</p><p>基本语法：<code>numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None, axis=0)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>序列的起始值</td></tr><tr><td>stop</td><td>序列的终止值，如果 endpoint 为 True，则该值将包含于数列中</td></tr><tr><td>num</td><td>可选项，int 类型，要生成的等步长的样本数量，即元素个数，默认为 50</td></tr><tr><td>endpoint</td><td>可选项，bool 类型，该值为 True 时，数列中将包含 stop 值，反之则不包含，默认为 True</td></tr><tr><td>base</td><td>可选项，float 类型，对数 log 的底数，即取对数的时候 log 的下标 ，默认为 10.0</td></tr><tr><td>dtype</td><td>可选项，Ndarray 的数据类型</td></tr><tr><td>axis</td><td>可选项，int 类型，结果中的轴用于存储样本。仅当 start 或 stop 类似于数组时才相关<br>默认情况下为 0，采样将沿着在开始处插入的新轴进行，使用 -1 来获得轴的末端</td></tr></tbody></table><p>应用举例：</p><p>指定起始值为 0，,终止值为 9，<font color=#FF0000><strong>base 默认值为 10</strong></font>，代表的是 <font color=#FF0000><strong>10</strong></font> 的幂，即 0 代表 <font color=#FF0000><strong>10</strong></font> 的 0 次方，9 代表 <font color=#FF0000><strong>10</strong></font> 的 9 次方：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.logspace(0, 9, num = 10)&gt;&gt;&gt; print(a)[1.e+00 1.e+01 1.e+02 1.e+03 1.e+04 1.e+05 1.e+06 1.e+07 1.e+08 1.e+09]</code></pre><p>指定起始值为 0，,终止值为 9，<font color=#FF0000><strong>base 值为 2</strong></font>，代表的是 <font color=#FF0000><strong>2</strong></font> 的幂，即 0 代表 <font color=#FF0000><strong>2</strong></font> 的 0 次方，9 代表 <font color=#FF0000><strong>2</strong></font> 的 9 次方：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.logspace(0, 9, num = 10, base = 2)&gt;&gt;&gt; print(a)[  1.   2.   4.   8.  16.  32.  64. 128. 256. 512.]</code></pre><p>起始值和终止值都可以为 float 类型：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.logspace(1.0, 2.0, num = 10)&gt;&gt;&gt; print(a)[ 10.          12.91549665  16.68100537  21.5443469   27.82559402  35.93813664  46.41588834  59.94842503  77.42636827 100.        ]</code></pre><p>定义 dtype 属性值为 int 类型：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np          &gt;&gt;&gt; a = np.logspace(0.0, 9.0, num = 10, base = 2, dtype = int)&gt;&gt;&gt; print(a)[  1   2   4   8  16  32  64 128 256 512]</code></pre><h3 id="【5x07】numpy-empty"><a href="#【5x07】numpy-empty" class="headerlink" title="【5x07】numpy.empty()"></a><font color=#1BC3FB>【5x07】numpy.empty()</font></h3><p>numpy.empty() 方法可用来创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组。</p><p>基本语法：<code>numpy.empty(shape, dtype = float, order = &#39;C&#39;)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>shape</td><td>数组形状</td></tr><tr><td>dtype</td><td>数据类型，可选</td></tr><tr><td>order</td><td>以行优先（C）或列优先（F）的顺序存储多维数据在内存中</td></tr></tbody></table><p>创建一个一维空数组（传递一个参数即可，代表数组长度，数组元素为随机值，因为它们未初始化）：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.empty(3)&gt;&gt;&gt; print(a)[3.538e-321 3.538e-321 0.000e+000]&gt;&gt;&gt; print(type(a))&lt;class &#39;numpy.ndarray&#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a = np.empty(3, dtype = int)   # 定义类型为整数&gt;&gt;&gt; print(a)[716   0 716]</code></pre><p>创建一个二维空数组（传递两个参数，分别代表行数和列数）：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.empty([3, 2])&gt;&gt;&gt; print(a)[[6.23042070e-307 3.56043053e-307] [1.37961641e-306 1.11258854e-306] [8.90100843e-307 1.11261027e-306]]&gt;&gt;&gt; print(type(a))&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><p>创建一个三维空数组（传递三个参数，分别代表块数、每一块的行数和列数）：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.empty([3, 2, 4])&gt;&gt;&gt; print(a)[[[0. 0. 0. 0.]  [0. 0. 0. 0.]] [[0. 0. 0. 0.]  [0. 0. 0. 0.]] [[0. 0. 0. 0.]  [0. 0. 0. 0.]]]</code></pre><h3 id="【5x08】numpy-zeros"><a href="#【5x08】numpy-zeros" class="headerlink" title="【5x08】numpy.zeros()"></a><font color=#1BC3FB>【5x08】numpy.zeros()</font></h3><p>numpy.zeros() 方法用于创建指定大小的数组，数组元素以 0 来填充。</p><p>基本语法：<code>numpy.zeros(shape, dtype = float, order = &#39;C&#39;)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>shape</td><td>数组形状</td></tr><tr><td>dtype</td><td>数据类型，可选</td></tr><tr><td>order</td><td>以行优先（C）或列优先（F）的顺序存储多维数据在内存中</td></tr></tbody></table><p>创建一个一维数组（传递一个参数即可，代表数组长度，数组元素以 0 填充）：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.zeros(5)&gt;&gt;&gt; print(a)[0. 0. 0. 0. 0.]&gt;&gt;&gt; print(type(a))&lt;class &#39;numpy.ndarray&#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a = np.zeros(5, dtype = int)    # 定义类型为整数&gt;&gt;&gt; print(a)[0 0 0 0 0]</code></pre><p>创建一个二维数组（传递两个参数，分别代表行数和列数）：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.zeros([2, 3])&gt;&gt;&gt; print(a)[[0. 0. 0.] [0. 0. 0.]]&gt;&gt;&gt; print(type(a))&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><p>创建一个三维空数组（传递三个参数，分别代表块数、每一块的行数和列数）：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.zeros([4, 2, 3])&gt;&gt;&gt; print(a)[[[0. 0. 0.]  [0. 0. 0.]] [[0. 0. 0.]  [0. 0. 0.]] [[0. 0. 0.]  [0. 0. 0.]] [[0. 0. 0.]  [0. 0. 0.]]]&gt;&gt;&gt; print(type(a))&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><h3 id="【5x09】numpy-ones"><a href="#【5x09】numpy-ones" class="headerlink" title="【5x09】numpy.ones()"></a><font color=#1BC3FB>【5x09】numpy.ones()</font></h3><p>numpy.ones() 方法用于创建指定大小的数组，数组元素以 1 来填充。</p><p>基本语法：<code>numpy.ones(shape, dtype = None, order = &#39;C&#39;)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>shape</td><td>数组形状</td></tr><tr><td>dtype</td><td>数据类型，可选</td></tr><tr><td>order</td><td>以行优先（C）或列优先（F）的顺序存储多维数据在内存中</td></tr></tbody></table><p>创建一个一维数组（传递一个参数即可，代表数组长度，数组元素以 0 填充）：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.ones(5)&gt;&gt;&gt; print(a)[1. 1. 1. 1. 1.]&gt;&gt;&gt; print(type(a))&lt;class &#39;numpy.ndarray&#39;&gt;&gt;&gt;&gt; &gt;&gt;&gt; a = np.ones(5, dtype = int)   # 定义类型为整数&gt;&gt;&gt; print(a)[1 1 1 1 1]&gt;&gt;&gt; print(type(a))&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><p>创建一个二维数组（传递两个参数，分别代表行数和列数）：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.ones([2, 3])&gt;&gt;&gt; print(a)[[1. 1. 1.] [1. 1. 1.]]&gt;&gt;&gt; print(type(a))&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><p>创建一个三维数组（传递三个参数，分别代表块数、每一块的行数和列数）：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.ones([3, 2 ,5])&gt;&gt;&gt; print(a)[[[1. 1. 1. 1. 1.]  [1. 1. 1. 1. 1.]] [[1. 1. 1. 1. 1.]  [1. 1. 1. 1. 1.]] [[1. 1. 1. 1. 1.]  [1. 1. 1. 1. 1.]]]&gt;&gt;&gt; print(type(a))&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><h3 id="【5x10】numpy-eye"><a href="#【5x10】numpy-eye" class="headerlink" title="【5x10】numpy.eye()"></a><font color=#1BC3FB>【5x10】numpy.eye()</font></h3><p>numpy.eye() 方法用于创建对角矩阵数组，返回一个二维数组，对角线上值为 1，其余位置为 0。</p><p>基本语法：<code>numpy.eye(N, M=None, k=0, dtype=&lt;class &#39;float&#39;&gt;, order=&#39;C&#39;)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>N</td><td>int 类型，目标数组的行数</td></tr><tr><td>M</td><td>int 类型，可选项，目标数组的列数，如果未指定，则默认与行数（N）相同</td></tr><tr><td>k</td><td>int 类型，可选项，对角线索引，0（默认值）为主对角线，正值为上对角线，负值为下对角线<br>简单来说可以理解成将值为 1 的对角线向左右平移 k 个单位，默认值 0 即对角线为 1，k 为正值右移，负值左移</td></tr><tr><td>dtype</td><td>可选项，返回数组的数据类型</td></tr><tr><td>order</td><td>可选项，以行优先（C）或列优先（F）的顺序存储多维数据在内存中</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; print(np.eye(5, 5))           # 创建一个对角矩阵[[1. 0. 0. 0. 0.] [0. 1. 0. 0. 0.] [0. 0. 1. 0. 0.] [0. 0. 0. 1. 0.] [0. 0. 0. 0. 1.]]&gt;&gt;&gt; print(np.eye(5, 5, k=1))      # 将值为 1 的对角线向右移 1 个单位[[0. 1. 0. 0. 0.] [0. 0. 1. 0. 0.] [0. 0. 0. 1. 0.] [0. 0. 0. 0. 1.] [0. 0. 0. 0. 0.]]&gt;&gt;&gt; print(np.eye(5, 5, k=-2))     # 将值为 1 的对角线向右左移 2 个单位[[0. 0. 0. 0. 0.] [0. 0. 0. 0. 0.] [1. 0. 0. 0. 0.] [0. 1. 0. 0. 0.] [0. 0. 1. 0. 0.]]&gt;&gt;&gt; print(np.eye(5, dtype=int))  # 指定为 int 类型[[1 0 0 0 0] [0 1 0 0 0] [0 0 1 0 0] [0 0 0 1 0] [0 0 0 0 1]]</code></pre><h3 id="【5x11】numpy-frombuffer"><a href="#【5x11】numpy-frombuffer" class="headerlink" title="【5x11】numpy.frombuffer()"></a><font color=#1BC3FB>【5x11】numpy.frombuffer()</font></h3><p>numpy.frombuffer() 方法将缓冲区解释为一维数组，接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。当 buffer 是字符串时，Python3 默认 str 是 Unicode 类型，所以要转成 bytestring，即在原 str 前加上 b。</p><p>基本语法：<code>numpy.frombuffer(buffer, dtype=float, count=-1, offset=0)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>buffer</td><td>可以是任意对象，会以流的形式读入</td></tr><tr><td>dtype</td><td>可选项，返回数组的数据类型</td></tr><tr><td>count</td><td>可选项，读取的数据数量，默认为 -1，即读取缓冲区中所有数据</td></tr><tr><td>offset</td><td>可选项，读取的起始位置，以字节为单位，默认为 0</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = b&#39;I love python!&#39;&gt;&gt;&gt; b = np.frombuffer(a, dtype=&#39;S1&#39;)&gt;&gt;&gt; print(b)[b&#39;I&#39; b&#39; &#39; b&#39;l&#39; b&#39;o&#39; b&#39;v&#39; b&#39;e&#39; b&#39; &#39; b&#39;p&#39; b&#39;y&#39; b&#39;t&#39; b&#39;h&#39; b&#39;o&#39; b&#39;n&#39; b&#39;!&#39;]&gt;&gt;&gt; &gt;&gt;&gt; b = np.frombuffer(a, dtype=&#39;S1&#39;, count=5)              # 指定要读取的数据量&gt;&gt;&gt; print(b)[b&#39;I&#39; b&#39; &#39; b&#39;l&#39; b&#39;o&#39; b&#39;v&#39;]&gt;&gt;&gt; &gt;&gt;&gt; b = np.frombuffer(a, dtype=&#39;S1&#39;, count=5, offset=6)    # 指定读取数据的起始位置&gt;&gt;&gt; print(b)[b&#39; &#39; b&#39;p&#39; b&#39;y&#39; b&#39;t&#39; b&#39;h&#39;]&gt;&gt;&gt;&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = b&#39;\x01\x02&#39;&gt;&gt;&gt; b = np.frombuffer(a, dtype=&#39;uint8&#39;)&gt;&gt;&gt; print(b)[1 2]</code></pre><h3 id="【5x12】numpy-fromiter"><a href="#【5x12】numpy-fromiter" class="headerlink" title="【5x12】numpy.fromiter()"></a><font color=#1BC3FB>【5x12】numpy.fromiter()</font></h3><p>numpy.fromiter() 方法可以从可迭代对象中建立 Ndarray 对象，返回一个一维数组。</p><p>基本语法：<code>numpy.fromiter(iterable, dtype, count=-1)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>iterable</td><td>可迭代对象</td></tr><tr><td>dtype</td><td>返回数组的数据类型</td></tr><tr><td>count</td><td>读取的数据数量，默认为 -1，即读取所有数据</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; l = range(5)&gt;&gt;&gt; i = iter(l)                              # iter() 方法用于生成迭代器&gt;&gt;&gt; n = np.fromiter(i, dtype=float)          # 从可迭代对象中建立 Ndarray 对象&gt;&gt;&gt; print(l, type(l))range(0, 5) &lt;class &#39;range&#39;&gt;&gt;&gt;&gt; print(i, type(i))&lt;range_iterator object at 0x00000163E75DCA70&gt; &lt;class &#39;range_iterator&#39;&gt;&gt;&gt;&gt; print(n, type(n))[0. 1. 2. 3. 4.] &lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/104870084未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr><h2 id="【6x00】改变数组的维度或者形状"><a href="#【6x00】改变数组的维度或者形状" class="headerlink" title="【6x00】改变数组的维度或者形状"></a><font color=#FF0000>【6x00】改变数组的维度或者形状</font></h2><h3 id="【6x01】numpy-reshape"><a href="#【6x01】numpy-reshape" class="headerlink" title="【6x01】numpy.reshape()"></a><font color=#1BC3FB>【6x01】numpy.reshape()</font></h3><p>numpy.reshape() 方法用于重新调整数组的维数（重塑）。</p><p>基本语法：<code>numpy.reshape(a, newshape, order=&#39;C&#39;)</code></p><p>参数解释：</p><p><font color=#FF0000><strong>a</strong></font>：要重塑的数组</p><p><font color=#FF0000><strong>newshape</strong></font>：重塑后的形状，新形状应与原始形状兼容。如果是整数，则结果将是该长度的一维数组。一个形状维度可以是-1。在这种情况下，将根据数组的长度和剩余维度推断该值。举个例子，原数组 a 是一个 4 行 n 列的二维数组，现在要将其转换成只有 1 行的一维数组，由于不清楚原二维数组有多少列，也就不清楚一共有多少元素，所以可以使用 <code>np.reshape(a, (1, -1))</code> 语句将其转化为一维数组，其中 -1 会让程序自动计算有多少列，此概念将在后面举例具体说明。</p><p><font color=#FF0000><strong>order</strong></font>：可选值为 C、F、A，使用索引顺序读取 a 的元素，并按照索引顺序将元素放到变换后的的数组中，默认参数为 C。</p><p><strong><code>C</code> 指的是用类 C 写的读/索引顺序的元素，最后一个维度变化最快，第一个维度变化最慢。横着读，横着写，优先读/写一行。</strong></p><p><strong><code>F</code> 是指用 FORTRAN 类索引顺序读/写元素，最后一个维度变化最慢，第一个维度变化最快。竖着读，竖着写，优先读/写一列。注意，C 和 F 选项不考虑底层数组的内存布局，只引用索引的顺序。</strong></p><p><strong><code>A</code> 选项所生成的数组的效果与原数组 a 的数据存储方式有关，如果数据是按照 FORTRAN 存储的话，它的生成效果与 F 相同，否则与 C 相同。</strong></p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1,2,3,4,5,6,7,8])  # 创建一个一维数组&gt;&gt;&gt; print(a)[1 2 3 4 5 6 7 8]&gt;&gt;&gt; b = np.reshape(a, (2,4))         # 重塑为一个二维数组&gt;&gt;&gt; print(b)[[1 2 3 4] [5 6 7 8]]&gt;&gt;&gt; c = np.reshape(a, (2,2,2))       # 重塑为一个三维数组&gt;&gt;&gt; print(c)[[[1 2]  [3 4]] [[5 6]  [7 8]]]</code></pre><p>添加 order 参数举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])   # 创建一个二维数组&gt;&gt;&gt; print(a)[[1 2 3] [4 5 6]]&gt;&gt;&gt; b = np.reshape(a, 6, order=&#39;C&#39;)    # 按照行优先&gt;&gt;&gt; print(b)[1 2 3 4 5 6]&gt;&gt;&gt; b = np.reshape(a, 6, order=&#39;F&#39;)    # 按照列优先&gt;&gt;&gt; print(b)[1 4 2 5 3 6]</code></pre><p>另外，reshape 方法新生成的数组和原数组共用一个内存，不管改变哪个都会互相影响：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1,2,3,4,5,6,7,8])&gt;&gt;&gt; b = np.reshape(a, (2,4))&gt;&gt;&gt; print(a)[1 2 3 4 5 6 7 8]&gt;&gt;&gt; print(b)[[1 2 3 4] [5 6 7 8]]&gt;&gt;&gt; a[0] = 666&gt;&gt;&gt; print(a)[666   2   3   4   5   6   7   8]&gt;&gt;&gt; print(b)[[666   2   3   4] [  5   6   7   8]]</code></pre><p>newshape 重塑后的形状维度可以是 -1，简单举例：</p><ul><li><p><code>reshape(1,-1)</code>：将原数组转化成一行 N 列</p></li><li><p><code>reshape(2,-1)</code>：将原数组转换成两行 N 列</p></li><li><p><code>reshape(-1,1)</code>：将原数组转换成一列 N 行</p></li><li><p><code>reshape(-1,2)</code>：将原数组转化成两列 N 行</p></li></ul><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(16)                     # 生成一个由 0-15 组成的一维数组&gt;&gt;&gt; print(a)[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15]&gt;&gt;&gt; b = np.reshape(a, (2,8))             # 将一维数组 a 转换成一个 2 行 8 列的二维数组 b&gt;&gt;&gt; print(b)[[ 0  1  2  3  4  5  6  7] [ 8  9 10 11 12 13 14 15]]&gt;&gt;&gt; c = np.reshape(b, (8,-1))           # 将二维数组 b 转换成 8 行的格式，程序自动计算列数（列数：16/8=2）&gt;&gt;&gt; print(c)[[ 0  1] [ 2  3] [ 4  5] [ 6  7] [ 8  9] [10 11] [12 13] [14 15]]&gt;&gt;&gt; d = np.reshape(c, (-1,4))          # 将二维数组 c 转换成 4 列的格式，程序自动计算行数（行数：16/4=4）&gt;&gt;&gt; print(d)[[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11] [12 13 14 15]]</code></pre><h3 id="【6x02】numpy-ravel"><a href="#【6x02】numpy-ravel" class="headerlink" title="【6x02】numpy.ravel()"></a><font color=#1BC3FB>【6x02】numpy.ravel()</font></h3><p>numpy.ravel() 方法用于完成展平的操作。</p><p>基本语法：<code>numpy.ravel(a, order=&#39;C&#39;)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>待转换的数组</td></tr><tr><td>order</td><td>值可以是 <code>C</code> <code>F</code> <code>A</code> <code>K</code>，含义与 reshape 方法中参数的一样，与 reshape 方法不同的是多了个值 <code>K</code><br><code>K</code> 表示按顺序在内存中读取元素，但在跨距为负时会反转数据</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[[1,2,3,4], [5,6,7,8]], [[9,10,11,12], [13,14,15,16]], [[17,18,19,20], [21,22,23,24]]])&gt;&gt;&gt; print(a)[[[ 1  2  3  4]  [ 5  6  7  8]] [[ 9 10 11 12]  [13 14 15 16]] [[17 18 19 20]  [21 22 23 24]]]&gt;&gt;&gt; print(a.ravel())[ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24]&gt;&gt;&gt; print(np.ravel(a))[ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24]</code></pre><h3 id="【6x03】numpy-resize"><a href="#【6x03】numpy-resize" class="headerlink" title="【6x03】numpy.resize()"></a><font color=#1BC3FB>【6x03】numpy.resize()</font></h3><p>numpy.resize() 方法会<font color=#FF0000><strong>直接修改所操作的数组</strong></font>，返回具有指定形状的新数组，如果新数组大于原始数组，则新数组将填充 a 的重复副本。</p><p>基本语法：<code>numpy.resize(a, new_shape)</code></p><p>参数解释：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>待转换的数组</td></tr><tr><td>new_shape</td><td>新数组的大小形状</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]])&gt;&gt;&gt; print(a)[[1 2 3] [4 5 6]]&gt;&gt;&gt; print(np.resize(a, (3, 2)))[[1 2] [3 4] [5 6]]&gt;&gt;&gt; print(np.resize(a, (3, 3)))[[1 2 3] [4 5 6] [1 2 3]]&gt;&gt;&gt; print(np.resize(a, (2, 4)))[[1 2 3 4] [5 6 1 2]]</code></pre><h3 id="【6x04】numpy-ndarray-flatten"><a href="#【6x04】numpy-ndarray-flatten" class="headerlink" title="【6x04】numpy.ndarray.flatten()"></a><font color=#1BC3FB>【6x04】numpy.ndarray.flatten()</font></h3><p>numpy.ndarray.flatten() 方法恰如其名，flatten 就是展平的意思，与 ravel 函数的功能相同，二者的不同之处在于：flatten 方法会请求分配新的内存来保存结果，而 ravel 方法只是返回数组的一个视图（view）。</p><p>基本语法：<code>ndarray.flatten(order=&#39;C&#39;)</code></p><p>其 order 参数的值可以是 <code>C</code> <code>F</code> <code>A</code> <code>K</code>，含义与 reshape 和 ravel 方法中参数的一样.</p><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[[1,2,3,4], [5,6,7,8]], [[9,10,11,12], [13,14,15,16]], [[17,18,19,20], [21,22,23,24]]])&gt;&gt;&gt; print(a)[[[ 1  2  3  4]  [ 5  6  7  8]] [[ 9 10 11 12]  [13 14 15 16]] [[17 18 19 20]  [21 22 23 24]]]&gt;&gt;&gt; print(a.flatten())[ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24]</code></pre><h3 id="【6x05】numpy-ndarray-shape"><a href="#【6x05】numpy-ndarray-shape" class="headerlink" title="【6x05】numpy.ndarray.shape"></a><font color=#1BC3FB>【6x05】numpy.ndarray.shape</font></h3><p>numpy.ndarray.shape 本来是 Ndarray 对象的一个属性，但可以通过直接用一个正整数元组对其赋值来设置数组的维度：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[[1,2,3,4], [5,6,7,8]], [[9,10,11,12], [13,14,15,16]], [[17,18,19,20], [21,22,23,24]]])&gt;&gt;&gt; print(a)[[[ 1  2  3  4]  [ 5  6  7  8]] [[ 9 10 11 12]  [13 14 15 16]] [[17 18 19 20]  [21 22 23 24]]]&gt;&gt;&gt; a.shape = (3, 8)&gt;&gt;&gt; print(a)[[ 1  2  3  4  5  6  7  8] [ 9 10 11 12 13 14 15 16] [17 18 19 20 21 22 23 24]]</code></pre><h3 id="【6x06】numpy-ndarray-transpose-amp-numpy-ndarray-T"><a href="#【6x06】numpy-ndarray-transpose-amp-numpy-ndarray-T" class="headerlink" title="【6x06】numpy.ndarray.transpose() &amp; numpy.ndarray.T"></a><font color=#1BC3FB>【6x06】numpy.ndarray.transpose() &amp; numpy.ndarray.T</font></h3><p>ndarray.transpose() 和 ndarray.T 方法的作用是对数组进行转置，即原来的行变成列，原来的列变成行。</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[0, 1, 2, 3, 4, 5], [6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17]])&gt;&gt;&gt; print(a)[[ 0  1  2  3  4  5] [ 6  7  8  9 10 11] [12 13 14 15 16 17]]&gt;&gt;&gt; print(a.transpose())[[ 0  6 12] [ 1  7 13] [ 2  8 14] [ 3  9 15] [ 4 10 16] [ 5 11 17]]&gt;&gt;&gt; print(a.T)[[ 0  6 12] [ 1  7 13] [ 2  8 14] [ 3  9 15] [ 4 10 16] [ 5 11 17]]</code></pre><h3 id="【6x07】numpy-swapaxes"><a href="#【6x07】numpy-swapaxes" class="headerlink" title="【6x07】numpy.swapaxes()"></a><font color=#1BC3FB>【6x07】numpy.swapaxes()</font></h3><p>numpy.swapaxes() 方法用于对换数组的两个轴</p><p>基本语法：<code>numpy.swapaxes(a, axis1, axis2)</code></p><p>参数解释：a 为原始数组，axis1、axis2 分别对应两个轴，类型为整数</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[0, 1, 2, 3, 4, 5], [6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17]])&gt;&gt;&gt; print(a)[[ 0  1  2  3  4  5] [ 6  7  8  9 10 11] [12 13 14 15 16 17]]&gt;&gt;&gt; print(np.swapaxes(a, 1, 0))       # 交换 1 轴和 0 轴，此处相当于数组的转置，与【6x06】效果相同[[ 0  6 12] [ 1  7 13] [ 2  8 14] [ 3  9 15] [ 4 10 16] [ 5 11 17]]</code></pre><h2 id="【7x00】NumPy-数据类型"><a href="#【7x00】NumPy-数据类型" class="headerlink" title="【7x00】NumPy 数据类型"></a><font color=#FF0000>【7x00】NumPy 数据类型</font></h2><p>NumPy 数组包含同一类型的值，支持的数据类型比 Python 内置的类型更多，构建一个数组时，可以用一个字符串参数 dtype 来指定数据类型：</p><pre><code class="python">np.zeros(10, dtype=&#39;int16&#39;)</code></pre><pre><code class="python">np.zeros(10, dtype=np.int16)</code></pre><table><thead><tr><th>数据类型</th><th align="left"><center>描述</center></th></tr></thead><tbody><tr><td>bool_</td><td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#FF0000><strong>布尔值</strong></font>（True 或者 False），用一个字节存储</td></tr><tr><td>int_</td><td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#FF0000><strong>默认的整型</strong></font>（类似于 C 语言中的 long，通常情况下是 int32 或 int64）</td></tr><tr><td>intc</td><td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#FF0000><strong>同 C 语言的 int 相同</strong></font>（通常是 int32 或 int64）</td></tr><tr><td>intp</td><td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#FF0000><strong>用作索引的整型</strong></font>（和 C 语言的 ssize_t 相同，通常情况下是 int32 或 int64）</td></tr><tr><td>int8</td><td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#FF0000><strong>字节</strong></font>（byte，范围从 –128 到 127），可用 i1 缩写代替</td></tr><tr><td>int16</td><td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#FF0000><strong>整型</strong></font>（范围从 –32768 到 32767），可用 i2 缩写代替</td></tr><tr><td>int32</td><td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#FF0000><strong>整型</strong></font>（范围从 –2147483648 到 2147483647），可用 i4 缩写代替</td></tr><tr><td>int64</td><td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#FF0000><strong>整型</strong></font>（范围从 –9223372036854775808 到 9223372036854775807），可用 i8 缩写代替</td></tr><tr><td>uint8</td><td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#FF0000><strong>无符号整型</strong></font>（范围从 0 到 255）</td></tr><tr><td>uint16</td><td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#FF0000><strong>无符号整型</strong></font>（范围从 0 到 65535）</td></tr><tr><td>uint32</td><td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#FF0000><strong>无符号整型</strong></font>（范围从 0 到 4294967295）</td></tr><tr><td>uint64</td><td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#FF0000><strong>无符号整型</strong></font>（范围从 0 到 18446744073709551615）</td></tr><tr><td>float_</td><td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#FF0000><strong>float64</strong></font> 的简化形式</td></tr><tr><td>float16</td><td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#FF0000><strong>半精度浮点型</strong></font>，包括：1 比特位符号，5 比特位指数，10 比特位尾数</td></tr><tr><td>float32</td><td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#FF0000><strong>单精度浮点型</strong></font>，包括：1 比特位符号，8 比特位指数，23 比特位尾数</td></tr><tr><td>float64</td><td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#FF0000><strong>双精度浮点型</strong></font>，包括：1 比特位符号，11 比特位指数，52 比特位尾数</td></tr><tr><td>complex_</td><td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#FF0000><strong>complex128</strong></font> 的简化形式</td></tr><tr><td>complex64</td><td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#FF0000><strong>复数</strong></font>，表示双 32 位浮点数（实数部分和虚数部分）</td></tr><tr><td>complex128</td><td align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#FF0000><strong>复数</strong></font>，表示双 64 位浮点数（实数部分和虚数部分）</td></tr></tbody></table><h2 id="【8x00】NumPy-数组属性"><a href="#【8x00】NumPy-数组属性" class="headerlink" title="【8x00】NumPy 数组属性"></a><font color=#FF0000>【8x00】NumPy 数组属性</font></h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>ndarray.ndim</td><td>秩，即轴的数量或维度的数量，一维数组的秩为 1，二维数组的秩为 2，以此类推</td></tr><tr><td>ndarray.shape</td><td>数组的维度，对于矩阵，n 行 m 列</td></tr><tr><td>ndarray.size</td><td>数组元素的总个数，相当于 .shape 中 n*m 的值</td></tr><tr><td>ndarray.dtype</td><td>ndarray 对象的元素类型</td></tr><tr><td>ndarray.itemsize</td><td>ndarray 对象中每个元素的大小，以字节为单位</td></tr><tr><td>ndarray.flags</td><td>ndarray 对象的内存信息</td></tr><tr><td>ndarray.real</td><td>ndarray元素的实部</td></tr><tr><td>ndarray.imag</td><td>ndarray 元素的虚部</td></tr><tr><td>ndarray.data</td><td>包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性</td></tr></tbody></table><p>其中 ndarray.flags 包含以下属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>C_CONTIGUOUS (C)</code></td><td>数据是在一个单一的 C 风格的连续段中</td></tr><tr><td><code>F_CONTIGUOUS (F)</code></td><td>数据是在一个单一的 Fortran 风格的连续段中</td></tr><tr><td><code>OWNDATA (O)</code></td><td>数组拥有它所使用的内存或从另一个对象中借用它</td></tr><tr><td><code>WRITEABLE (W)</code></td><td>数据区域可以被写入，将该值设置为 False，则数据为只读</td></tr><tr><td><code>ALIGNED (A)</code></td><td>数据和所有元素都适当地对齐到硬件上</td></tr><tr><td><code>UPDATEIFCOPY (U)</code></td><td>这个数组是其它数组的一个副本，当这个数组被释放时，原数组的内容将被更新</td></tr></tbody></table><p>应用举例：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([1,2,3,4,5])&gt;&gt;&gt; print(a.flags)  C_CONTIGUOUS : True  F_CONTIGUOUS : True  OWNDATA : True  WRITEABLE : True  ALIGNED : True  WRITEBACKIFCOPY : False  UPDATEIFCOPY : False</code></pre><p>ndarray.shape 查看数组维度以及更改数组形状：</p><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1,2,3],[4,5,6]])&gt;&gt;&gt; print(a)[[1 2 3] [4 5 6]]&gt;&gt;&gt; print(a.shape)(2, 3)&gt;&gt;&gt; a.shape = (3, 2)&gt;&gt;&gt; print(a)[[1 2] [3 4] [5 6]]&gt;&gt;&gt; print(a.shape)(3, 2)</code></pre><hr><pre><code class="yaml">这里是一段防爬虫文本，请读者忽略。本文原创首发于 CSDN，作者 TRHX。博客首页：https://itrhx.blog.csdn.net/本文链接：https://itrhx.blog.csdn.net/article/details/104870084未经授权，禁止转载！恶意转载，后果自负！尊重原创，远离剽窃！</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> NumPy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客提交百度、谷歌搜索引擎收录</title>
      <link href="/article/007/"/>
      <url>/article/007/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>网站在没有提交搜索引擎收录之前，直接搜索你网站的内容是搜不到的，只有提交搜索引擎之后，搜索引擎才能收录你的站点，通过爬虫抓取你网站的东西，<font color=#ff0000>对于 hexo 博客来说，如果你是部署在 GitHub Pages，那么你是无法被百度收录的，因为 GitHub 禁止了百度爬虫</font>，最常见的解决办法是双线部署到 Coding Pages 和 GitHub Pages，因为百度爬虫可以爬取到 Coding 上的内容，从而实现百度收录，如果你的 hexo 博客还没有实现双线部署，请参考：<a href="https://blog.csdn.net/qq_36759224/article/details/100879609">《Hexo 双线部署到 Coding Pages 和 GitHub Pages 并实现全站 HPPTS》</a>，另外百度收录的所需的时间较长，大约半个月左右才会看到效果！</p><hr><h2 id="查看网站是否被收录"><a href="#查看网站是否被收录" class="headerlink" title="查看网站是否被收录"></a>查看网站是否被收录</h2><p>首先我们可以输入 <code>site:域名</code> 来查看域名是否被搜索引擎收录，如下图所示，表示没有收录：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/01.png" alt="01"></p><hr><h2 id="百度资源平台添加网站"><a href="#百度资源平台添加网站" class="headerlink" title="百度资源平台添加网站"></a>百度资源平台添加网站</h2><p>访问<a href="https://ziyuan.baidu.com/">百度搜索资源平台官网</a>，注册或者登陆百度账号，依次选择【用户中心】-【站点管理】，添加你的网站，在添加站点时会让你选择协议头（http 或者 https），如果选择 https，它会验证你的站点，大约能在一天之内完成，我的网站已经实现了全站 https，因此选择了 https 协议，但是不知道为什么始终验证失败，实在是无解，只能选择 http 协议了，如果你的站点也实现了全站 https，也可以尝试一下</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/02.png" alt="02"></p><p>之后会让你验证网站所有权，提供三种验证方式：</p><ul><li>文件验证：下载给定的文件，将其放到本地<font color=#ff0000>主题目录 source 文件夹</font>，然后部署上去完成验证</li><li>HTML 标签验证：一般是给一个 meta 标签，放到首页 <code>&lt;head&gt;</code> 与 <code>&lt;/head&gt;</code> 标签之间即可完成验证</li><li>CNAME 验证：个人觉得这种方法最简单，去域名 DNS 添加一个 CNAME 记录即可完成验证</li></ul><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/03.png" alt="03"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/04.png" alt="04"></p><hr><h2 id="提交百度搜索"><a href="#提交百度搜索" class="headerlink" title="提交百度搜索"></a>提交百度搜索</h2><p>百度提供了自动提交和手动提交两种方式，其中自动提交又分为主动推送、自动推送和 sitemap 三种方式，以下是官方给出的解释：</p><ul><li><p>主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录</p></li><li><p>自动推送：是轻量级链接提交组件，将自动推送的 JS 代码放置在站点每一个页面源代码中，当页面被访问时，页面链接会自动推送给百度，有利于新页面更快被百度发现</p></li><li><p>sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送</p></li><li><p>手动提交：如果您不想通过程序提交，那么可以采用此种方式，手动将链接提交给百度</p></li></ul><p>四种提交方式对比：</p><table><thead><tr><th align="center">方式</th><th align="center">主动推送</th><th align="center">自动推送</th><th align="center">Sitemap</th><th align="center">手动提交</th></tr></thead><tbody><tr><td align="center">速度</td><td align="center">最快</td><td align="center">——</td><td align="center">——</td><td align="center">——</td></tr><tr><td align="center">开发成本</td><td align="center">高</td><td align="center">低</td><td align="center">中</td><td align="center">不需开发</td></tr><tr><td align="center">可提交量</td><td align="center">低</td><td align="center">高</td><td align="center">高</td><td align="center">低</td></tr><tr><td align="center">是否建议提交历史连接</td><td align="center">否</td><td align="center">是</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">和其他提交方法是否有冲突</td><td align="center">无</td><td align="center">无</td><td align="center">无</td><td align="center">无</td></tr></tbody></table><p><strong>个人推荐同时使用主动推送和 sitemap 方式</strong>，下面将逐一介绍这四种提交方式的具体实现方法</p><hr><h3 id="主动推送"><a href="#主动推送" class="headerlink" title="主动推送"></a>主动推送</h3><p>在博客根目录安装插件 <code>npm install hexo-baidu-url-submit --save</code>，然后在根目录 <code>_config.yml</code> 文件里写入以下配置：</p><pre><code class="txt">baidu_url_submit:  count: 1               # 提交最新的多少个链接  host: www.itrhx.com    # 在百度站长平台中添加的域名  token: your_token      # 秘钥  path: baidu_urls.txt   # 文本文档的地址， 新链接会保存在此文本文档里</code></pre><p>其中的 <code>token</code> 可以在【链接提交】-【自动提交】-【主动推送】下面看到，接口调用地址最后面 <code>token=xxxxx</code> 即为你的 <code>token</code></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/05.png" alt="05"></p><p>同样是在根目录的 <code>_config.yml</code> 文件，大约第 17 行处，url 要改为在百度站长平台添加的域名，也就是你网站的首页地址：</p><pre><code class="txt"># URLurl: https://www.itrhx.comroot: /permalink: :year/:month/:day/:title/</code></pre><p>最后，加入新的 deployer：</p><pre><code class="txt"># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git  repository:    github: git@github.com:TRHX/TRHX.github.io.git  # 这是原来的 github 配置    coding: git@git.dev.tencent.com:TRHX/TRHX.git   # 这是原来的 coding 配置  branch: master- type: baidu_url_submitter                         # 这是新加的主动推送</code></pre><p>最后执行 <code>hexo g -d</code> 部署一遍即可实现主动推送，推送成功的标志是：在执行部署命令最后会显示类似如下代码：</p><pre><code class="bash">&#123;&quot;remain&quot;:4999953,&quot;success&quot;:47&#125;INFO  Deploy done: baidu_url_submitter</code></pre><p>这表示有 47 个页面已经主动推送成功，remain 的意思是当天剩余的可推送 url 条数</p><p>主动推送相关原理介绍：</p><ul><li>新链接的产生：hexo generate 会产生一个文本文件，里面包含最新的链接</li><li>新链接的提交：hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎</li></ul><p>该插件的 GitHub 地址：<a href="https://github.com/huiwang/hexo-baidu-url-submit">https://github.com/huiwang/hexo-baidu-url-submit</a></p><hr><h3 id="自动推送"><a href="#自动推送" class="headerlink" title="自动推送"></a>自动推送</h3><p>关于自动推送百度官网给出的解释是：自动推送是百度搜索资源平台为提高站点新增网页发现速度推出的工具，安装自动推送JS代码的网页，在页面被访问时，页面URL将立即被推送给百度</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/06.png" alt="06"></p><p>此时要注意，有些 hexo 主题集成了这项功能，比如 next 主题，在 <code>themes\next\layout_scripts\</code> 下有个 <code>baidu_push.swig</code> 文件，我们只需要把如下代码粘贴到该文件，然后在主题配置文件设置 <code>baidu_push: true</code> 即可</p><pre><code class="js">&#123;% if theme.baidu_push %&#125;<script>(function()&#123;    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') &#123;        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            &#125;    else &#123;        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    &#125;    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);&#125;)();</script>&#123;% endif %&#125;</code></pre><p>然而大部分主题是没有集成这项功能的，对于大部分主题来说，我们可以把以下代码粘贴到 <code>head.ejs</code> 文件的 <code>&lt;head&gt;</code> 与 <code>&lt;/head&gt;</code> 标签之间即可，从而实现自动推送（比如我使用的是 <a href="https://xaoxuu.com/wiki/material-x/">Material X</a> 主题，那么只需要把代码粘贴到 <code>\themes\material-x\layout\_partial\head.ejs</code> 中即可）</p><pre><code class="js">&lt;script&gt;(function()&#123;    var bp = document.createElement(&#39;script&#39;);    var curProtocol = window.location.protocol.split(&#39;:&#39;)[0];    if (curProtocol === &#39;https&#39;) &#123;        bp.src = &#39;https://zz.bdstatic.com/linksubmit/push.js&#39;;    &#125;    else &#123;        bp.src = &#39;http://push.zhanzhang.baidu.com/push.js&#39;;    &#125;    var s = document.getElementsByTagName(&quot;script&quot;)[0];    s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt;</code></pre><hr><h3 id="sitemap"><a href="#sitemap" class="headerlink" title="sitemap"></a>sitemap</h3><p>首先我们要使用以下命令生成一个网站地图：</p><pre><code class="bash">npm install hexo-generator-sitemap --save     npm install hexo-generator-baidu-sitemap --save</code></pre><p>这里也注意一下，将根目录的 <code>_config.yml</code> 文件，大约第 17 行处，url 改为在百度站长平台添加的域名，也就是你网站的首页地址：</p><pre><code class="txt"># URLurl: https://www.itrhx.comroot: /permalink: :year/:month/:day/:title/</code></pre><p>然后使用命令 <code>hexo g -d</code> 将网站部署上去，然后访问 <code>你的首页/sitemap.xml</code> 或者 <code>你的首页/baidusitemap.xml</code> 就可以看到网站地图了</p><p>比如我的是：<a href="https://www.itrhx.com/baidusitemap.xml">https://www.itrhx.com/baidusitemap.xml</a> 或者 <a href="https://www.itrhx.com/sitemap.xml">https://www.itrhx.com/sitemap.xml</a></p><p>其中 <code>sitemap.xml</code> 文件是搜索引擎通用的 sitemap 文件，<code>baidusitemap.xml</code> 是百度专用的 sitemap 文件</p><p>然后来到百度站长平台的 sitemap 提交页面，将你的 sitemap 地址提交即可，如果成功的话状态会显示为正常，初次提交要等几分钟，sitemap.xml 相比 baidusitemap.xml 来说等待时间也会更长，如果以后你博客有新的文章或其他页面，可以点击<strong>手动更新文件</strong>，更新一下新的 sitemap</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/07.png" alt="07"></p><hr><h3 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h3><p>手动提交不需要其他额外操作，直接把需要收录的页面的 url 提交即可，这种方法效率较低，更新较慢，不推荐使用</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/08.png" alt="08"></p><hr><h2 id="提交谷歌搜索"><a href="#提交谷歌搜索" class="headerlink" title="提交谷歌搜索"></a>提交谷歌搜索</h2><p>提交谷歌搜索引擎比较简单，在提交之前，我们依然可以使用 <code>site:域名</code> 查看网站是否被收录，我的网站搭建了有差不多一年了，之前也没提交过收录，不过谷歌爬虫的确是强大，即使没有提交过，现在也能看到有一百多条结果了：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/09.png" alt="09"></p><p>接下来我们将网站提交谷歌搜索引擎搜索，进入<a href="https://www.google.com/webmasters/">谷歌站长平台</a>，登录你的谷歌账号之后会让你验证网站所有权：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/10.png" alt="10"></p><p>有两种验证方式，分别是网域和网址前缀，两种资源类型区别如下：</p><table><thead><tr><th></th><th align="left"><center>网址前缀资源</center></th><th align="left"><center>网域资源</center></th></tr></thead><tbody><tr><td>说明</td><td align="left">仅包含具有指定前缀（包括协议 http/https）的网址。如果希望资源匹配任何协议或子网域（http/https/www./m. 等），建议改为添加网域资源。</td><td align="left">包括所有子网域（m、www 等）和多种协议（http、https、ftp）的网域级资源。</td></tr><tr><td>验证</td><td align="left">多种类型</td><td align="left">仅 DNS 记录验证</td></tr><tr><td>示例</td><td align="left">资源 <a href="http://example.com/">http://example.com/</a><br><br><font color=#ff0000>✔</font> <a href="http://example.com/dresses/1234">http://example.com/dresses/1234</a><br><font color=#ff0000>X</font> <a href="https://example.com/dresses/1234">https://example.com/dresses/1234</a><br><font color=#ff0000>X</font> <a href="http://www.example.com/dresses/1234">http://www.example.com/dresses/1234</a></td><td align="left">资源 example.com<br><br><font color=#ff0000>✔</font> <a href="http://example.com/dresses/1234">http://example.com/dresses/1234</a><br><font color=#ff0000>✔</font> <a href="https://example.com/dresses/1234">https://example.com/dresses/1234</a><br><font color=#ff0000>✔</font> <a href="http://www.example.com/dresses/1234">http://www.example.com/dresses/1234</a><br><font color=#ff0000>✔</font> <a href="http://support.m.example.com/dresses/1234">http://support.m.example.com/dresses/1234</a></td></tr></tbody></table><p>由对比可知选择网域资源验证方式比较好，只需要一个域名就可以匹配到多种格式的 URL，之后会给你一个 TXT 的记录值，复制它到你域名 DNS 增加一个 TXT 记录，点击验证即可</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/11.png" alt="11"></p><p>提交谷歌收录比较简单，选择站点地图，将我们之前生成的 sitemap 提交就行了，过几分钟刷新一下看到成功字样表示提交成功！</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/12.png" alt="12"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github + jsDelivr + PicGo 打造稳定快速、高效免费图床</title>
      <link href="/article/006/"/>
      <url>/article/006/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>图床是个啥东西就不用过多介绍了，先来对比一下各路图床：</p><ul><li><strong>微博图床</strong>：以前用的人比较多，从2019年4月开始开启了防盗链，凉凉；</li><li><strong>SM.MS</strong>：运营四年多了，也变得越来越慢了，到了晚上直接打不开图片，速度堪忧；</li><li><strong>其他小众图床</strong>：随时有挂掉的风险；</li><li><strong>Imgur 等国外图床</strong>：国内访问速度太慢，随时有被墙的风险；</li><li><strong>大厂储存服务</strong>：例如七牛云、又拍云、腾讯云COS、阿里云OSS等，容量限制，操作繁琐，又是实名认证又是域名备案的，麻烦，而且还要花钱（有钱又不怕麻烦的当我没说）。</li></ul><p>因此，GitHub 图床是个不错的选择，利用 jsDelivr CDN 加速访问（jsDelivr 是一个免费开源的 CDN 解决方案），PicGo 工具一键上传，操作简单高效，GitHub 和 jsDelivr 都是大厂，不用担心跑路问题，不用担心速度和容量问题，而且完全免费，可以说是目前免费图床的最佳解决方案！</p><hr><h2 id="新建-GitHub-仓库"><a href="#新建-GitHub-仓库" class="headerlink" title="新建 GitHub 仓库"></a>新建 GitHub 仓库</h2><p>登录/注册GitHub，新建一个仓库，填写好仓库名，仓库描述，根据需求选择是否为仓库初始化一个 README.md 描述文件</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/01.jpg" alt="01"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/02.jpg" alt="02"></p><hr><h2 id="生成-Token"><a href="#生成-Token" class="headerlink" title="生成 Token"></a>生成 Token</h2><p>在主页依次选择【Settings】-【Developer settings】-【Personal access tokens】-【Generate new token】，填写好描述，勾选【repo】，然后点击【Generate token】生成一个Token，注意这个Token只会显示一次，自己先保存下来，或者等后面配置好PicGo后再关闭此网页</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/03.jpg" alt="03"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/04.jpg" alt="04"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/05.jpg" alt="05"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/06.jpg" alt="06"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/07.jpg" alt="07"></p><h2 id="配置-PicGo"><a href="#配置-PicGo" class="headerlink" title="配置 PicGo"></a>配置 PicGo</h2><p>前往<a href="https://github.com/Molunerfinn/picgo/releases">下载PicGo</a>，安装好后开始配置图床<br><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/08.jpg" alt="08"></p><ul><li><p><font color=#FF000>设定仓库名：</font>按照【用户名/图床仓库名】的格式填写</p></li><li><p><font color=#FF000>设定分支名：</font>【master】</p></li><li><p><font color=#FF000>设定Token：</font>粘贴之前生成的【Token】</p></li><li><p><font color=#FF000>指定存储路径：</font>填写想要储存的路径，如【ITRHX-PIC/】，这样就会在仓库下创建一个名为 ITRHX-PIC 的文件夹，图片将会储存在此文件夹中</p></li><li><p><font color=#FF000>设定自定义域名：</font>它的作用是，在图片上传后，PicGo 会按照【自定义域名+储存路径+上传的图片名】的方式生成访问链接，并放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为【<a href="https://fastly.jsdelivr.net/gh/%E7%94%A8%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D">https://fastly.jsdelivr.net/gh/用户名/图床仓库名</a> 】，上传完毕后，我们就可以通过【<a href="https://fastly.jsdelivr.net/gh/%E7%94%A8%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D/%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84">https://fastly.jsdelivr.net/gh/用户名/图床仓库名/图片路径</a> 】加速访问我们的图片了，比如上图的图片链接为：<a href="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/08.jpg">https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/08.jpg</a></p></li></ul><p>关于 jsDelivr 具体是如何引用资源的可以参考我的另一篇博客：<a href="https://www.itbob.cn/article/004/">《免费CDN：jsDelivr + Github》</a></p><hr><h2 id="进行高效创作"><a href="#进行高效创作" class="headerlink" title="进行高效创作"></a>进行高效创作</h2><p>配置好PicGo后，我们就可以进行高效创作了，将图片拖拽到上传区，将会自动上传并复制访问链接，将链接粘贴到博文中就行了，访问速度杠杠的，此外PicGo还有相册功能，可以对已上传的图片进行删除，修改链接等快捷操作，PicGo还可以生成不同格式的链接、支持批量上传、快捷键上传、自定义链接格式、上传前重命名等，更多功能自己去探索吧！</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图床 </tag>
            
            <tag> PicGo </tag>
            
            <tag> jsDelivr </tag>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站 ICP 备案和公安备案流程</title>
      <link href="/article/005/"/>
      <url>/article/005/</url>
      
        <content type="html"><![CDATA[<p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/Website-Approve.png" alt="Website-Approve"></p><p>网站备案分为ICP备案和公安备案</p><ul><li><p>ICP备案：ICP备案的目的就是为了防止在网上从事非法的网站经营活动，打击不良互联网信息的传播，如果网站不备案的话，很有可能被查处以后关停。根据中华人民共和国信息产业部第十二次部务会议审议通过的《非经营性互联网信息服务备案管理办法》条例，在中华人民共和国境内提供非经营性互联网信息服务，应当办理备案。未经备案，不得在中华人民共和国境内从事非经营性互联网信息服务。而对于没有备案的网站将予以罚款或关闭。</p></li><li><p>公安备案：网站备案是根据国家法律法规需要网站的所有者向国家有关部门申请的备案，公安局备案是其中一种。公安局备案一般按照各地公安机关指定的地点和方式进行，操作流程会比ICP备案流程简单，主要是已登记为主。</p></li></ul><p>以百度官网为例，其中<code>京公安网备11000002000001</code>就是公安备案，<code>京ICP证030173号 </code>就是ICP备案</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/01.png" alt="01"></p><h2 id="ICP备案"><a href="#ICP备案" class="headerlink" title="ICP备案"></a>ICP备案</h2><p>一般在域名服务商那里都会有代备案系统，下面以阿里云为例，进入备案系统：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/02.jpg" alt="02"></p><h3 id="填写信息验证备案类型"><a href="#填写信息验证备案类型" class="headerlink" title="填写信息验证备案类型"></a>填写信息验证备案类型</h3><p>备案主办单位填写，个人就选个人，企业就选企业，按照实际信息填写：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/03.jpg" alt="03"></p><h3 id="产品验证"><a href="#产品验证" class="headerlink" title="产品验证"></a>产品验证</h3><p>对搭建备案网站的云服务器进行验证，如果你在阿里云购买了相关产品，就选择相应的产品类型和实例进行验证，也可以勾选<code>已有备案服务号</code>，填写服务号进行验证，备案服务号可以通过备案控制台进行申请，具体操作可以参考官方文档<a href="https://help.aliyun.com/knowledge_detail/36938.html">《申请备案服务号》</a>，也有的小伙伴没有在任何地方购买过服务器等相关产品，比如单纯搭建一个 <a href="https://blog.csdn.net/qq_36759224/article/details/82121420">Github Pages + Hexo</a> 轻量级的个人博客，这种博客没有后端，不需要服务器，但是要备案怎么办？这种情况也好解决，去某宝买一个服务号就行了。</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/04.jpg" alt="04"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/05.jpg" alt="05"></p><h3 id="填写网站信息"><a href="#填写网站信息" class="headerlink" title="填写网站信息"></a>填写网站信息</h3><p>填写网站信息以及办理备案的个人或者单位的真实信息，在填写网站名称的时候要<font color=#FF0000>特别注意！特别注意！特别注意！不满足要求的话是会被打回的！</font>不能使用姓名、地名、成语、不能包含公司、组织等企业性质的词语……具体要求可以参考官方文档<a href="https://help.aliyun.com/knowledge_detail/36948.html?spm=a2c4g.11186623.6.573.6e1369a5ZNlC0v">《填写主体信息和网站信息》</a>。</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/06.jpg" alt="06"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/07.png" alt="07"></p><h3 id="上传资料"><a href="#上传资料" class="headerlink" title="上传资料"></a>上传资料</h3><p>根据要求，上传证件照片或证件彩色扫描件。身份证好说，拍好了上传就行了，注意《网站备案信息真实性核验单》需要你<font color=#FF0000>下载并打印在一张A4纸上，使用黑色签字笔填写，不能涂改</font>，具体可参照所给的示例进行填写，填写完成后再拍照上传。企业网站类似，提交备案后会在一个工作日内进行初审。</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/08.jpg" alt="08"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/09.jpg" alt="09.jpg"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/10.jpg" alt="10"></p><h3 id="人脸核验或幕布拍照核验"><a href="#人脸核验或幕布拍照核验" class="headerlink" title="人脸核验或幕布拍照核验"></a>人脸核验或幕布拍照核验</h3><p>根据不同地域管局要求及核验平台的支持情况，使用人脸识别进行核验，或者申请专用幕布进行幕布拍照核验</p><table><thead><tr><th align="center">地区</th><th align="left">核验要求</th></tr></thead><tbody><tr><td align="center">上海、福建地区用户</td><td align="left">需使用阿里云APP进行人脸核验。如果使用PC端发起的备案申请，请根据界面提示下载阿里云APP进行人脸核验。</td></tr><tr><td align="center">广东、辽宁、安徽、重庆地区用户</td><td align="left">首次备案、新增网站：支持使用阿里云APP进行人脸核验或通过阿里云备案平台（PC端）进行幕布拍照核验。<br>其他备案类型：需通过阿里云备案平台（PC端）进行幕布拍照核验。</td></tr><tr><td align="center">其他地区用户</td><td align="left">通过阿里云备案平台（PC端）进行幕布拍照核验。</td></tr></tbody></table><p>以幕布拍照核验为例，如果你没有阿里云的幕布，就需要申请幕布（免费的），邮寄很快，大约两三天就到了，等收到幕布后，按照要求进行拍照，<font color=#FF0000>一定要仔细阅读拍照说明！一定要仔细阅读拍照说明！一定要仔细阅读拍照说明！不合格依旧会被打回！</font>拍照完成后上传即可。</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/11.jpg" alt="11"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/12.jpg" alt="12"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/13.png" alt="13"></p><h3 id="提交管局、短信核验"><a href="#提交管局、短信核验" class="headerlink" title="提交管局、短信核验"></a>提交管局、短信核验</h3><p>当照片审核通过后，就会提交到管局，工信部要求部分省市成为手机号码短信核验试点省市，相应省市的用户在阿里云备案平台提交备案申请且初审完成后，会收到工信部发送的核验短信，短信包含验证码和验证地址，需要在收到短信的24小时内完成短信核验，备案申请才能进入管局审核。<br>需短信核验省份：</p><ul><li>2017年12月18日起：天津、甘肃、西藏、宁夏、海南、新疆、青海被列为试点省份。</li><li>2018年9月10日起：浙江、四川、福建、陕西、重庆、广西、云南被列为试点省份。</li><li>2018年9月24日起：山东、河南、安徽、湖南、山西、黑龙江、内蒙古、湖北被列为试点省份。</li></ul><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/14.jpg" alt="14"></p><h3 id="ICP-备案完成"><a href="#ICP-备案完成" class="headerlink" title="ICP 备案完成"></a>ICP 备案完成</h3><p>整个备案过程中会有阿里云的客服打电话给你，进行信息确认，备案申请信息成功提交管局系统后，管局审核一般为 3 - 20 个工作日（亲测很快，不到一个周就通过了），审核通过后会收到阿里云的邮件通知。</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/15.jpg" alt="15"></p><h2 id="公安备案"><a href="#公安备案" class="headerlink" title="公安备案"></a>公安备案</h2><p>公安备案个人觉得比ICP备案还要麻烦，自己在公安备案的时候，最开始申请了一个月也没给我处理（大概是地方原因，所在的市比较小，估计都没几个人办过网站，网警也不太负责），与ICP备案最大的不同，如果你是交互式网站的话，公安备案是需要你去公安机关当面审核的，这也是比较麻烦的一点。</p><h3 id="用户注册、登录"><a href="#用户注册、登录" class="headerlink" title="用户注册、登录"></a>用户注册、登录</h3><p>登录<a href="http://www.beian.gov.cn/">全国互联网安全管理服务平台</a>，选择联网备案登录，注册账号并登录</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/16.jpg" alt="16"></p><h3 id="新办网站备案申请"><a href="#新办网站备案申请" class="headerlink" title="新办网站备案申请"></a>新办网站备案申请</h3><p>点击新办网站申请，按实填写网站开办主体，上传身份证正反照和手持身份证件照。</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/17.jpg" alt="17"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/18.jpg" alt="18"></p><h3 id="填写网站基本信息"><a href="#填写网站基本信息" class="headerlink" title="填写网站基本信息"></a>填写网站基本信息</h3><p>按实填写网站基本信息，需要注意的地方：</p><p><font color=#FF0000>IP：</font>IP地址为阿里云/腾讯云的公网IP地址，请不要填写内网IP。<br><font color=#FF0000>域名证书：</font>以阿里云为例，进入【域名控制台】，点击域名后面的【管理】，选择【域名证书下载】即可，其它服务商类似。<br><font color=#FF0000>网络接入/域名注册服务商：</font>若办理公安备案的域名是通过<a href="https://www.aliyun.com/">阿里云</a>完成的工信部备案，则按照以下填写：</p><p>网络接入服务商：</p><ul><li>接入商所属地区管辖：境内</li><li>接入商所属区域 ：浙江省 杭州市 滨江区</li><li>名称：阿里云计算有限公司</li><li>网站接入方式：租赁虚拟空间</li></ul><p>域名注册服务商：</p><ul><li>域名商所属地区管辖：境内</li><li>域名服务商所属区域：浙江省 杭州市 余杭区 </li><li>名称：阿里云计算有限公司（原万网）</li></ul><p>也可以通过点击后面的<code>查询网络接入\域名注册服务商</code>直接选择相应服务商，其他服务商类似</p><p><font color=#FF0000>服务类型：</font>交互式服务指：为互联网用户提供信息发布、交流互动等服务，包括但不限于论坛、博客、微博、网络购物、网上支付等服务类型，此项选择是否提供互联网交互服务将会直接影响到后面是否需要去公安局当面核验，若选择<code>是</code>，当地网警会打电话叫你去公安局当面核验，还需要填写《交互式服务安全检查表》等各种文件，总之是比较麻烦的，个人小网站，博客什么的建议选择<code>否</code>，选择<code>www服务</code>，这样的话不用去当面核验，审核下来也比较快，企业单位用户建议选择交互式。</p><p>其他信息如实填写即可！</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/19.png" alt="19"></p><h3 id="填写网站负责人信息"><a href="#填写网站负责人信息" class="headerlink" title="填写网站负责人信息"></a>填写网站负责人信息</h3><p>填写网站安全负责人和网站应急联络人相关信息，网站应急联络人直接勾选同主体负责人后会自动填入。</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/20.jpg" alt="20"></p><h3 id="同意责任书并提交审核"><a href="#同意责任书并提交审核" class="headerlink" title="同意责任书并提交审核"></a>同意责任书并提交审核</h3><p>《互联网信息服务单位网络安全责任告知书》有30秒的强制阅读时间，建议认真阅读一下告知书的内容。然后勾选我已阅读，点击提交即可。随后可以看到审核状态，不同地区政策有所不同，会有当地的网警联系网站负责人的，审核通过后记得在网站首页底部张贴公安机关核发的备案图标！</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/21.png" alt="21"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A23/22.png" alt="22"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICP </tag>
            
            <tag> 备案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费 CDN：jsDelivr + Github</title>
      <link href="/article/004/"/>
      <url>/article/004/</url>
      
        <content type="html"><![CDATA[<p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科</p><p>放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。</p><hr><h2 id="新建-Github-仓库"><a href="#新建-Github-仓库" class="headerlink" title="新建 Github 仓库"></a>新建 Github 仓库</h2><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A18/01.jpg" alt="01"></p><h2 id="克隆-Github-仓库到本地"><a href="#克隆-Github-仓库到本地" class="headerlink" title="克隆 Github 仓库到本地"></a>克隆 Github 仓库到本地</h2><p>点击 Clone or download，一键复制仓库地址<br><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A18/04.jpg" alt="04"><br>在本地目录右键 Git Bash Here，执行以下命令：</p><pre><code class="git">git clone 一键复制的仓库地址</code></pre><h2 id="上传资源"><a href="#上传资源" class="headerlink" title="上传资源"></a>上传资源</h2><p>复制需要上传的资源到本地 git 仓库（注：jsDelivr 不支持加载超过 20M 的资源），在本地 git 仓库目录下右键 Git Bash Here，执行以下命令：</p><pre><code class="git">git status                    //查看状态git add .                     //添加所有文件到暂存区git commit -m &#39;第一次提交&#39;      //把文件提交到仓库git push                      //推送至远程仓库</code></pre><h2 id="发布仓库"><a href="#发布仓库" class="headerlink" title="发布仓库"></a>发布仓库</h2><p>点击release发布<br><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A18/02.jpg" alt="02"></p><p>自定义发布版本号<br><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A18/03.jpg" alt="03"></p><h2 id="通过-jsDelivr-引用资源"><a href="#通过-jsDelivr-引用资源" class="headerlink" title="通过 jsDelivr 引用资源"></a>通过 jsDelivr 引用资源</h2><p><font color=red>2022-05-22 更新：原引用的域名为 cdn.jsdelivr.net，可能部分地区会因为 DNS 污染导致无法访问，参见 <a href="https://github.com/jsdelivr/jsdelivr/issues/18397">Issues 18397</a>，目前更换域名为 fastly.jsdelivr.net 可用。</font></p><p>使用方法：<a href="https://fastly.jsdelivr.net/gh/%E4%BD%A0%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BD%A0%E7%9A%84%E4%BB%93%E5%BA%93%E5%90%8D@%E5%8F%91%E5%B8%83%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84">https://fastly.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</a><br>例如：</p><ul><li><a href="https://fastly.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/trhx.png">https://fastly.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/trhx.png</a></li><li><a href="https://fastly.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.1/css/style.css">https://fastly.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.1/css/style.css</a></li><li><a href="https://fastly.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4">https://fastly.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4</a></li></ul><p>注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下：</p><ul><li><p>加载任何Github发布、提交或分支：<br><a href="https://fastly.jsdelivr.net/gh/user/repo@version/file">https://fastly.jsdelivr.net/gh/user/repo@version/file</a></p></li><li><p>加载 jQuery v3.2.1：<br><a href="https://fastly.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js">https://fastly.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js</a></p></li><li><p>使用版本范围而不是特定版本<br><a href="https://fastly.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js">https://fastly.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js</a><br><a href="https://fastly.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js">https://fastly.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js</a></p></li><li><p>完全省略该版本以获取最新版本：<br><a href="https://fastly.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js">https://fastly.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js</a></p></li><li><p>将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成：<br><a href="https://fastly.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js">https://fastly.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js</a></p></li><li><p>在末尾添加 / 以获取资源目录列表：<br><a href="https://fastly.jsdelivr.net/gh/jquery/jquery/">https://fastly.jsdelivr.net/gh/jquery/jquery/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsDelivr </tag>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客主题个性化</title>
      <link href="/article/003/"/>
      <url>/article/003/</url>
      
        <content type="html"><![CDATA[<blockquote><p>建立了两个 Hexo 博客交流群，有问题可在群里互相交流学习！点击群号可一键加群！<br>Hexo 博客交流一群（<a href="https://qm.qq.com/cgi-bin/qm/qr?k=m5RvZThuF0U70_3nJwz-GoE7Ujbi0J35&jump_from=webapi">924812033</a>）、Hexo 博客交流二群（<a href="https://qm.qq.com/cgi-bin/qm/qr?k=AVUjFgrXV3YA9s4JflWIYyDvt8GFG9rz&jump_from=webapi">735861501</a>）</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文将讲述一些博客主题的美化、实用功能的添加，本文以作者 <a href="https://luuman.github.io/Home/H1/index.html">luuman</a> 的 <a href="https://github.com/luuman/hexo-theme-spfk">spfk</a> 主题和作者 <a href="https://xaoxuu.com/">xaoxuu</a> 的 <a href="https://xaoxuu.com/wiki/material-x/">Material X</a> 主题（远古版本，现已改名 <a href="https://github.com/volantis-x/hexo-theme-volantis/">Volantis</a>）为例，文章会不定时进行更新。文章涉及有关参考资料、教程、链接如有侵权请联系我删除！</p><p>本文在CSDN的链接：<a href="https://itrhx.blog.csdn.net/article/details/85420403">《Hexo 博客优化之博客美化》</a>、<a href="https://itrhx.blog.csdn.net/article/details/85010191">《Hexo 博客优化之实用功能添加》</a>，Hexo 博客专栏，从前期搭建到后期美化，帮您解决常见问题：<a href="https://itrhx.blog.csdn.net/category_9285510.html">《Hexo 博客搭建》</a>，对你有帮助就点个赞吧❤️</p><p><font color=#FF0000><strong>请注意：</strong></font>不同主题可能方法有些不同，相同主题不同版本，配置方法也有所差异！</p><p><font color=#FF0000><strong>博客美化前提条件：</strong></font>有一定的前端基础，了解 HTML、CSS、JS，了解 CSS 预处理语言 Sass、Less、Stylus，搞懂 hexo 的目录结构。</p><p><font color=#FF0000><strong>博客美化通用步骤：</strong></font>选定主题，认真阅读主题文档，分析主题目录结构，了解每个文件是对应网页哪个部分的，认真阅读美化教程，美化教程本质上只为你提供核心代码和思路，具体代码要添加到哪个地方，需要你自己搞懂主题结构，添加到需要的、合适的位置！</p><p><font color=#FF0000><strong>博客美化终极奥秘：</strong></font>创作第一，体验第二，避免繁杂，简洁为上！</p><hr><h2 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h2><p>主流的评论系统有很多，比如：网易云跟帖、多说、友言、畅言、来必力（LiveRe）、Disqus、Valine、Gitment等等，目前网易云跟帖、多说、友言都已经关闭了，还有些可能需要翻墙，比较麻烦，百度了一下，最后还是选择了来必力评论系统</p><p>进入<a href="https://livere.com/">来必力官网</a>，注册一个账号（注册时可能需要翻墙）</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/001.jpg" alt="001">  </p><p>注册完毕之后，登录，进入安装页面，选择 City 免费版安装，安装之后你会得到一段代码</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/002.jpg" alt="002"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/003.jpg" alt="003"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/004.jpg" alt="004"></p><p>我们打开主题文件下的 <font color=#FF0000>_config.yml</font> 文件，添加如下代码：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/005.png" alt="005"></p><p>在 <font color=#FF0000>\themes\hexo-theme-spfk\layout\_partial\comments</font> 文件夹下新建一个 <font color=#FF0000>livere.ejs</font> 的文件，在里面填写来必力提供的代码：</p><pre><code class="JavaScript">&lt;!-- 来必力City版安装代码 --&gt;&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;这里是你的uid&quot;&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        (function(d, s) &#123;        var j, e = d.getElementsByTagName(s)[0];            if (typeof LivereTower === &#39;function&#39;) &#123; return; &#125;            j = d.createElement(s);        j.src = &#39;https://cdn-city.livere.com/js/embed.dist.js&#39;;        j.async = true;            e.parentNode.insertBefore(j, e);        &#125;)(document, &#39;script&#39;);    &lt;/script&gt;    &lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt;</code></pre><p>打开 <font color=#FF0000>\themes\hexo-theme-spfk\layout\_partial\article.ejs </font>文件，在适当位置添加如下红框中的代码：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/006.jpg" alt="006"></p><p>完成以上操作之后，我们就可以使用来必力评论系统了</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/007.jpg" alt="007"></p><hr><h2 id="添加卡通人物"><a href="#添加卡通人物" class="headerlink" title="添加卡通人物"></a>添加卡通人物</h2><p>我在逛别人博客的时候偶然发现右下角居然有一个萌萌的卡通人物，还能根据你鼠标位置摇头，瞬间被吸引到了，赶紧也给自己博客添加一个吧！<a href="https://github.com/EYHN/hexo-helper-live2d">点击此处</a>进入该项目地址  </p><p>输入如下命令获取 live2d ：</p><pre><code class="shell">$ npm install --save hexo-helper-live2d  </code></pre><p>输入以下命令，下载相应的模型，将 <font color=#FF0000>packagename</font> 更换成模型名称即可，更多模型选择请<a href="https://github.com/xiazeyu/live2d-widget-models">点击此处</a>，各个模型的预览请<a href="https://huaji8.top/post/live2d-plugin-2.0/">访问原作者的博客</a>  </p><pre><code class="shell">$ npm install packagename</code></pre><p>打开站点目录下的 <font color=#FF0000>_config.yml</font> 文件，添加如下代码：</p><pre><code class="yaml">live2d:  enable: true  scriptFrom: local  model:    use: live2d-widget-model-haruto #模型选择  display:    position: right  #模型位置    width: 150       #模型宽度    height: 300      #模型高度  mobile:    show: false      #是否在手机端显示</code></pre><p>设置好过后我们就拥有了一个卡通人物</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/008.jpg" alt="008"></p><hr><h2 id="自定义鼠标指针样式"><a href="#自定义鼠标指针样式" class="headerlink" title="自定义鼠标指针样式"></a>自定义鼠标指针样式</h2><p>在 <font color=#FF0000> \themes\material-x\source\less\_base.less</font> 文件 body 样式里写入如下代码：</p><pre><code class="css">body &#123;    cursor: url(https://fastly.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.6/images/mouse.cur),auto;    background-color: @theme_background;    ......    ......&#125;</code></pre><p>鼠标指针可以用 Axialis CursorWorkshop 这个软件自己制作，不同主题具体放的文件有所不同，确保在博客主体 body 的 CSS 文件中即可，其中的鼠标指针链接可替换成自己的，首先尝试加载 <a href="https://fastly.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.6/images/mouse.cur">https://fastly.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.6/images/mouse.cur</a> ，如果该文件不存在或由于其他原因无效，那么 auto 会被使用，也就是自动默认效果，图片格式为.ico、.ani、.cur，建议使用.cur，如果使用.ani或者其他格式无效，原因是浏览器兼容问题，请阅读<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Basic_User_Interface/Using_URL_values_for_the_cursor_property">参考文档</a>或者参考以下兼容表：</p><table><thead><tr><th align="center">浏览器</th><th align="center">最低版本</th><th align="center">格式</th></tr></thead><tbody><tr><td align="center">Internet Explorer</td><td align="center">6.0</td><td align="center">.cur / .ani</td></tr><tr><td align="center">Firefox (Gecko), Windows and Linux</td><td align="center">1.5 (1.8)</td><td align="center">.cur / .png / .gif / .jpg</td></tr><tr><td align="center">Firefox (Gecko)</td><td align="center">4.0 (2.0)</td><td align="center">.cur / .png / .gif / .jpg / .svg</td></tr><tr><td align="center">Opera</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">Safari (Webkit)</td><td align="center">3.0 (522-523)</td><td align="center">.cur / .png / .gif / .jpg</td></tr></tbody></table><p>拓展阅读：<a href="https://blog.csdn.net/ixygj197875/article/details/79338360">《CSS 鼠标样式 cursor属性》</a> （By：歪脖先生的博客）</p><hr><h2 id="添加鼠标点击爱心效果"><a href="#添加鼠标点击爱心效果" class="headerlink" title="添加鼠标点击爱心效果"></a>添加鼠标点击爱心效果</h2><p>在<font color=#FF0000> \themes\hexo-theme-spfk\source\js</font> 下新建文件 <font color=#FF0000>love.js</font>，在 <font color=#FF0000>love.js</font> 文件中添加以下代码：</p><pre><code class="JavaScript">!function(e, t, a) &#123;    function n() &#123;        c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),        o(),        r()    &#125;    function r() &#123;        for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;);        requestAnimationFrame(r)    &#125;    function o() &#123;        var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick;        e.onclick = function(e) &#123;            t &amp;&amp; t(),            i(e)        &#125;    &#125;    function i(e) &#123;        var a = t.createElement(&quot;div&quot;);        a.className = &quot;heart&quot;,        d.push(&#123;            el: a,            x: e.clientX - 5,            y: e.clientY - 5,            scale: 1,            alpha: 1,            color: s()        &#125;),        t.body.appendChild(a)    &#125;    function c(e) &#123;        var a = t.createElement(&quot;style&quot;);        a.type = &quot;text/css&quot;;        try &#123;            a.appendChild(t.createTextNode(e))        &#125; catch(t) &#123;            a.styleSheet.cssText = e        &#125;        t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)    &#125;    function s() &#123;        return &quot;rgb(&quot; + ~~ (255 * Math.random()) + &quot;,&quot; + ~~ (255 * Math.random()) + &quot;,&quot; + ~~ (255 * Math.random()) + &quot;)&quot;    &#125;    var d = [];    e.requestAnimationFrame = function() &#123;        return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame ||        function(e) &#123;            setTimeout(e, 1e3 / 60)        &#125;    &#125; (),    n()&#125; (window, document);</code></pre><p>在 <font color=#FF0000>\themes\hexo-theme-spfk\layout\layout.ejs</font> 文件末尾添加以下代码：</p><pre><code class="html">&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/love.js&quot;&gt;&lt;/script&gt;</code></pre><p>完成以上操作后，当我们点击鼠标的时候就可以看见爱心的特效了</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/009.jpg" alt="009"></p><hr><h2 id="添加鼠标点击显示字体效果"><a href="#添加鼠标点击显示字体效果" class="headerlink" title="添加鼠标点击显示字体效果"></a>添加鼠标点击显示字体效果</h2><p>在<font color=#FF0000> \themes\hexo-theme-spfk\source\js</font> 下新建文件 <font color=#FF0000>click_show_text.js</font>，在 <font color=#FF0000>click_show_text.js</font> 文件中添加以下代码：</p><pre><code class="JavaScript">var a_idx = 0;jQuery(document).ready(function($) &#123;    $(&quot;body&quot;).click(function(e) &#123;        var a = new Array        (&quot;富强&quot;, &quot;民主&quot;, &quot;文明&quot;, &quot;和谐&quot;, &quot;自由&quot;, &quot;平等&quot;, &quot;公正&quot;, &quot;法治&quot;, &quot;爱国&quot;, &quot;敬业&quot;, &quot;诚信&quot;, &quot;友善&quot;);        var $i = $(&quot;&lt;span/&gt;&quot;).text(a[a_idx]);        a_idx = (a_idx + 1) % a.length;        var x = e.pageX,        y = e.pageY;        $i.css(&#123;            &quot;z-index&quot;: 5,            &quot;top&quot;: y - 20,            &quot;left&quot;: x,            &quot;position&quot;: &quot;absolute&quot;,            &quot;font-weight&quot;: &quot;bold&quot;,            &quot;color&quot;: &quot;#FF0000&quot;        &#125;);        $(&quot;body&quot;).append($i);        $i.animate(&#123;            &quot;top&quot;: y - 180,            &quot;opacity&quot;: 0        &#125;,      3000,      function() &#123;          $i.remove();      &#125;);    &#125;);    setTimeout(&#39;delay()&#39;, 2000);&#125;);function delay() &#123;    $(&quot;.buryit&quot;).removeAttr(&quot;onclick&quot;);&#125;</code></pre><p>其中的社会主义核心价值观可以根据你自己的创意替换为其他文字</p><p>如果想要每次点击显示的文字为不同颜色，可以将其中 <code>color</code> 值进行如下更改：</p><pre><code class="js">&quot;color&quot;: &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot;</code></pre><p>然后在 <font color=#FF0000>\themes\hexo-theme-spfk\layout\layout.ejs</font> 文件末尾添加以下代码：</p><pre><code class="html">&lt;!--单击显示文字--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/click_show_text.js&quot;&gt;&lt;/script&gt;</code></pre><p>最终实现效果如下：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/010.png" alt="010"></p><hr><h2 id="添加鼠标点击烟花爆炸效果"><a href="#添加鼠标点击烟花爆炸效果" class="headerlink" title="添加鼠标点击烟花爆炸效果"></a>添加鼠标点击烟花爆炸效果</h2><p>在 <font color=#FF0000>\themes\material-x\source\js</font> 目录下新建一个 <font color=#FF0000>fireworks.js</font> 的文件，里面写入以下代码：</p><pre><code class="JavaScript">function updateCoords(e) &#123;    pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left,    pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e) &#123;    var t = anime.random(0, 360) * Math.PI / 180,    a = anime.random(50, 180),    n = [ - 1, 1][anime.random(0, 1)] * a;    return &#123;        x: e.x + n * Math.cos(t),        y: e.y + n * Math.sin(t)    &#125;&#125;function createParticule(e, t) &#123;    var a = &#123;&#125;;    return a.x = e,    a.y = t,    a.color = colors[anime.random(0, colors.length - 1)],    a.radius = anime.random(16, 32),    a.endPos = setParticuleDirection(a),    a.draw = function() &#123;        ctx.beginPath(),        ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0),        ctx.fillStyle = a.color,        ctx.fill()    &#125;,    a&#125;function createCircle(e, t) &#123;    var a = &#123;&#125;;    return a.x = e,    a.y = t,    a.color = &quot;#F00&quot;,    a.radius = 0.1,    a.alpha = 0.5,    a.lineWidth = 6,    a.draw = function() &#123;        ctx.globalAlpha = a.alpha,        ctx.beginPath(),        ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0),        ctx.lineWidth = a.lineWidth,        ctx.strokeStyle = a.color,        ctx.stroke(),        ctx.globalAlpha = 1    &#125;,    a&#125;function renderParticule(e) &#123;    for (var t = 0; t &lt; e.animatables.length; t++) &#123;        e.animatables[t].target.draw()    &#125;&#125;function animateParticules(e, t) &#123;    for (var a = createCircle(e, t), n = [], i = 0; i &lt; numberOfParticules; i++) &#123;        n.push(createParticule(e, t))    &#125;    anime.timeline().add(&#123;        targets: n,        x: function(e) &#123;            return e.endPos.x        &#125;,        y: function(e) &#123;            return e.endPos.y        &#125;,        radius: 0.1,        duration: anime.random(1200, 1800),        easing: &quot;easeOutExpo&quot;,        update: renderParticule    &#125;).add(&#123;        targets: a,        radius: anime.random(80, 160),        lineWidth: 0,        alpha: &#123;            value: 0,            easing: &quot;linear&quot;,            duration: anime.random(600, 800)        &#125;,        duration: anime.random(1200, 1800),        easing: &quot;easeOutExpo&quot;,        update: renderParticule,        offset: 0    &#125;)&#125;function debounce(e, t) &#123;    var a;    return function() &#123;        var n = this,        i = arguments;        clearTimeout(a),        a = setTimeout(function() &#123;            e.apply(n, i)        &#125;,        t)    &#125;&#125;var canvasEl = document.querySelector(&quot;.fireworks&quot;);if (canvasEl) &#123;    var ctx = canvasEl.getContext(&quot;2d&quot;),    numberOfParticules = 30,    pointerX = 0,    pointerY = 0,    tap = &quot;mousedown&quot;,    colors = [&quot;#FF1461&quot;, &quot;#18FF92&quot;, &quot;#5A87FF&quot;, &quot;#FBF38C&quot;],    setCanvasSize = debounce(function() &#123;        canvasEl.width = 2 * window.innerWidth,        canvasEl.height = 2 * window.innerHeight,        canvasEl.style.width = window.innerWidth + &quot;px&quot;,        canvasEl.style.height = window.innerHeight + &quot;px&quot;,        canvasEl.getContext(&quot;2d&quot;).scale(2, 2)    &#125;,    500),    render = anime(&#123;        duration: 1 / 0,        update: function() &#123;            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height)        &#125;    &#125;);    document.addEventListener(tap,    function(e) &#123;        &quot;sidebar&quot; !== e.target.id &amp;&amp; &quot;toggle-sidebar&quot; !== e.target.id &amp;&amp; &quot;A&quot; !== e.target.nodeName &amp;&amp; &quot;IMG&quot; !== e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY))    &#125;,    !1),    setCanvasSize(),    window.addEventListener(&quot;resize&quot;, setCanvasSize, !1)&#125;&quot;use strict&quot;;function updateCoords(e) &#123;    pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left,    pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e) &#123;    var t = anime.random(0, 360) * Math.PI / 180,    a = anime.random(50, 180),    n = [ - 1, 1][anime.random(0, 1)] * a;    return &#123;        x: e.x + n * Math.cos(t),        y: e.y + n * Math.sin(t)    &#125;&#125;function createParticule(e, t) &#123;    var a = &#123;&#125;;    return a.x = e,    a.y = t,    a.color = colors[anime.random(0, colors.length - 1)],    a.radius = anime.random(16, 32),    a.endPos = setParticuleDirection(a),    a.draw = function() &#123;        ctx.beginPath(),        ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0),        ctx.fillStyle = a.color,        ctx.fill()    &#125;,    a&#125;function createCircle(e, t) &#123;    var a = &#123;&#125;;    return a.x = e,    a.y = t,    a.color = &quot;#F00&quot;,    a.radius = 0.1,    a.alpha = 0.5,    a.lineWidth = 6,    a.draw = function() &#123;        ctx.globalAlpha = a.alpha,        ctx.beginPath(),        ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0),        ctx.lineWidth = a.lineWidth,        ctx.strokeStyle = a.color,        ctx.stroke(),        ctx.globalAlpha = 1    &#125;,    a&#125;function renderParticule(e) &#123;    for (var t = 0; t &lt; e.animatables.length; t++) &#123;        e.animatables[t].target.draw()    &#125;&#125;function animateParticules(e, t) &#123;    for (var a = createCircle(e, t), n = [], i = 0; i &lt; numberOfParticules; i++) &#123;        n.push(createParticule(e, t))    &#125;    anime.timeline().add(&#123;        targets: n,        x: function(e) &#123;            return e.endPos.x        &#125;,        y: function(e) &#123;            return e.endPos.y        &#125;,        radius: 0.1,        duration: anime.random(1200, 1800),        easing: &quot;easeOutExpo&quot;,        update: renderParticule    &#125;).add(&#123;        targets: a,        radius: anime.random(80, 160),        lineWidth: 0,        alpha: &#123;            value: 0,            easing: &quot;linear&quot;,            duration: anime.random(600, 800)        &#125;,        duration: anime.random(1200, 1800),        easing: &quot;easeOutExpo&quot;,        update: renderParticule,        offset: 0    &#125;)&#125;function debounce(e, t) &#123;    var a;    return function() &#123;        var n = this,        i = arguments;        clearTimeout(a),        a = setTimeout(function() &#123;            e.apply(n, i)        &#125;,        t)    &#125;&#125;var canvasEl = document.querySelector(&quot;.fireworks&quot;);if (canvasEl) &#123;    var ctx = canvasEl.getContext(&quot;2d&quot;),    numberOfParticules = 30,    pointerX = 0,    pointerY = 0,    tap = &quot;mousedown&quot;,    colors = [&quot;#FF1461&quot;, &quot;#18FF92&quot;, &quot;#5A87FF&quot;, &quot;#FBF38C&quot;],    setCanvasSize = debounce(function() &#123;        canvasEl.width = 2 * window.innerWidth,        canvasEl.height = 2 * window.innerHeight,        canvasEl.style.width = window.innerWidth + &quot;px&quot;,        canvasEl.style.height = window.innerHeight + &quot;px&quot;,        canvasEl.getContext(&quot;2d&quot;).scale(2, 2)    &#125;,    500),    render = anime(&#123;        duration: 1 / 0,        update: function() &#123;            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height)        &#125;    &#125;);    document.addEventListener(tap,    function(e) &#123;        &quot;sidebar&quot; !== e.target.id &amp;&amp; &quot;toggle-sidebar&quot; !== e.target.id &amp;&amp; &quot;A&quot; !== e.target.nodeName &amp;&amp; &quot;IMG&quot; !== e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY))    &#125;,    !1),    setCanvasSize(),    window.addEventListener(&quot;resize&quot;, setCanvasSize, !1)&#125;;</code></pre><p>然后在 <font color=#FF0000>\themes\material-x\layout\layout.ejs</font> 文件中写入以下代码：</p><pre><code class="html">&lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/fireworks.js&quot;&gt;&lt;/script&gt;</code></pre><p>最终效果：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/011.gif" alt="011"></p><hr><h2 id="添加彩色滚动变换字体"><a href="#添加彩色滚动变换字体" class="headerlink" title="添加彩色滚动变换字体"></a>添加彩色滚动变换字体</h2><p>在你想要添加彩色滚动变换字体的地方写入以下代码即可，其中文字可自行更改：</p><pre><code class="JavaScript">&lt;div id=&quot;binft&quot;&gt;&lt;/div&gt;  &lt;script&gt;    var binft = function (r) &#123;      function t() &#123;        return b[Math.floor(Math.random() * b.length)]      &#125;        function e() &#123;        return String.fromCharCode(94 * Math.random() + 33)      &#125;      function n(r) &#123;        for (var n = document.createDocumentFragment(), i = 0; r &gt; i; i++) &#123;          var l = document.createElement(&quot;span&quot;);          l.textContent = e(), l.style.color = t(), n.appendChild(l)        &#125;        return n      &#125;      function i() &#123;        var t = o[c.skillI];        c.step ? c.step-- : (c.step = g, c.prefixP &lt; l.length ? (c.prefixP &gt;= 0 &amp;&amp; (c.text += l[c.prefixP]), c.prefixP++) : &quot;forward&quot; === c.direction ? c.skillP &lt; t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = &quot;backward&quot;, c.delay = a) : c.skillP &gt; 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = &quot;forward&quot;)), r.textContent = c.text, r.appendChild(n(c.prefixP &lt; l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d)      &#125;      var l = &quot;&quot;,      o = [&quot;青青陵上柏，磊磊涧中石。&quot;, &quot;人生天地间，忽如远行客。&quot;,&quot;斗酒相娱乐，聊厚不为薄。&quot;, &quot;驱车策驽马，游戏宛与洛。&quot;,&quot;洛中何郁郁，冠带自相索。&quot;,&quot;长衢罗夹巷，王侯多第宅。&quot;,&quot;两宫遥相望，双阙百余尺。&quot;,&quot;极宴娱心意，戚戚何所迫？&quot;].map(function (r) &#123;      return r + &quot;&quot;      &#125;),      a = 2,      g = 1,      s = 5,      d = 75,      b = [&quot;rgb(110,64,170)&quot;, &quot;rgb(150,61,179)&quot;, &quot;rgb(191,60,175)&quot;, &quot;rgb(228,65,157)&quot;, &quot;rgb(254,75,131)&quot;, &quot;rgb(255,94,99)&quot;, &quot;rgb(255,120,71)&quot;, &quot;rgb(251,150,51)&quot;, &quot;rgb(226,183,47)&quot;, &quot;rgb(198,214,60)&quot;, &quot;rgb(175,240,91)&quot;, &quot;rgb(127,246,88)&quot;, &quot;rgb(82,246,103)&quot;, &quot;rgb(48,239,130)&quot;, &quot;rgb(29,223,163)&quot;, &quot;rgb(26,199,194)&quot;, &quot;rgb(35,171,216)&quot;, &quot;rgb(54,140,225)&quot;, &quot;rgb(76,110,219)&quot;, &quot;rgb(96,84,200)&quot;],      c = &#123;        text: &quot;&quot;,        prefixP: -s,        skillI: 0,        skillP: 0,        direction: &quot;forward&quot;,        delay: a,        step: g      &#125;;      i()      &#125;;      binft(document.getElementById(&#39;binft&#39;));  &lt;/script&gt;</code></pre><p>最终效果：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/012.gif" alt="012"></p><hr><h2 id="添加字数统计和阅读时长"><a href="#添加字数统计和阅读时长" class="headerlink" title="添加字数统计和阅读时长"></a>添加字数统计和阅读时长</h2><p>先在博客目录下执行以下命令安装 <font color=#FF0000>hexo-wordcount</font> 插件：</p><pre><code class="shell">$ npm i --save hexo-wordcount</code></pre><p>注意：在 <a href="https://xaoxuu.com/wiki/material-x/">Material X</a> 主题中，字数统计和阅读时长的功能我已提交 PR，在最新版本中，只需要安装插件后，在主题 <code>config.yml</code> 配置文件里，将 <code>word_count</code> 关键字设置为 <code>true</code> 即可，对于旧版本，可以通过以下方法实现：</p><p>以 <a href="https://xaoxuu.com/wiki/material-x/">Material X</a> 主题（版本 1.2.1）为例，在 <font color=#FF0000>\themes\material-x\layout\_meta</font> 目录下创建 <font color=#FF0000>word.ejs</font> 文件，在 <font color=#FF0000>word.ejs</font> 文件中写入以下代码：</p><pre><code class="JS">&lt;% if(isPostList || !isPostList)&#123; %&gt;  &lt;% if (theme.word_count &amp;&amp; !post.no_word_count) &#123; %&gt;    &lt;div style=&quot;margin-right: 10px;&quot;&gt;      &lt;span class=&quot;post-time&quot;&gt;        &lt;span class=&quot;post-meta-item-icon&quot;&gt;          &lt;i class=&quot;fa fa-keyboard&quot;&gt;&lt;/i&gt;          &lt;span class=&quot;post-meta-item-text&quot;&gt;  字数统计: &lt;/span&gt;          &lt;span class=&quot;post-count&quot;&gt;&lt;%= wordcount(post.content) %&gt;字&lt;/span&gt;        &lt;/span&gt;      &lt;/span&gt;      &amp;nbsp; | &amp;nbsp;      &lt;span class=&quot;post-time&quot;&gt;        &lt;span class=&quot;post-meta-item-icon&quot;&gt;          &lt;i class=&quot;fa fa-hourglass-half&quot;&gt;&lt;/i&gt;          &lt;span class=&quot;post-meta-item-text&quot;&gt;  阅读时长≈&lt;/span&gt;          &lt;span class=&quot;post-count&quot;&gt;&lt;%= min2read(post.content) %&gt;分&lt;/span&gt;        &lt;/span&gt;      &lt;/span&gt;    &lt;/div&gt;  &lt;% &#125; %&gt;&lt;% &#125; %&gt;</code></pre><p>然后在主题的配置文件 <font color=#FF0000>_config.yml</font> 找到 <font color=#FF0000>meta</font> 关键字，将 <font color=#FF0000>word</font> 填入 <font color=#FF0000>header</font> 中：</p><pre><code class="bash">meta:  header: [title, author, date, categories, tags, counter, word, top]  footer: [updated, share]</code></pre><p>最后在主题目录下的 <font color=#FF0000>_config.yml</font> 添加以下配置即可</p><pre><code class="yaml">word_count: true</code></pre><p>效果图：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/036.png" alt="036"></p><hr><p>同样的，以 <a href="https://github.com/luuman/hexo-theme-spfk">spfk</a> 主题为例，在 <font color=#FF0000>\themes\hexo-theme-spfk\layout\_partial\post</font> 目录下创建 <font color=#FF0000>word.ejs</font> 文件，在 <font color=#FF0000>word.ejs</font> 文件中写入以下代码：</p><pre><code class="JavaScript">&lt;div style=&quot;margin-top:10px;&quot;&gt;    &lt;span class=&quot;post-time&quot;&gt;      &lt;span class=&quot;post-meta-item-icon&quot;&gt;        &lt;i class=&quot;fa fa-keyboard-o&quot;&gt;&lt;/i&gt;        &lt;span class=&quot;post-meta-item-text&quot;&gt;  字数统计: &lt;/span&gt;        &lt;span class=&quot;post-count&quot;&gt;&lt;%= wordcount(post.content) %&gt;字&lt;/span&gt;      &lt;/span&gt;    &lt;/span&gt;    &amp;nbsp; | &amp;nbsp;    &lt;span class=&quot;post-time&quot;&gt;      &lt;span class=&quot;post-meta-item-icon&quot;&gt;        &lt;i class=&quot;fa fa-hourglass-half&quot;&gt;&lt;/i&gt;        &lt;span class=&quot;post-meta-item-text&quot;&gt;  阅读时长: &lt;/span&gt;        &lt;span class=&quot;post-count&quot;&gt;&lt;%= min2read(post.content) %&gt;分&lt;/span&gt;      &lt;/span&gt;    &lt;/span&gt;&lt;/div&gt;</code></pre><p>然后在 <font color=#FF0000>\themes\hexo-theme-spfk\layout\_partial\article.ejs</font> 中适当位置添加以下代码：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/013.jpg" alt="013"></p><p>最后在主题目录下的 <font color=#FF0000>_config.yml</font> 添加以下配置</p><pre><code class="yaml">word_count: true</code></pre><p>如果显示的位置不好，可以自行更改其位置，成功配置后的效果如下：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/014.jpg" alt="014"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/015.png" alt="015"></p><p>另外：要在博客底部显示所有文章的总字数，可以<a href="https://www.npmjs.com/package/hexo-wordcount">点击此处</a>，根据你博客底部文件的类型选择相应的代码放在适当的位置即可，前提是要安装好 <font color=#FF0000>hexo-wordcount</font> 插件，例如我使用 <a href="https://xaoxuu.com/wiki/material-x/">Material X</a> 主题，在 <font color=#FF0000>\themes\material-x\layout\_partial</font> 目录下的 <font color=#FF0000>footer.ejs</font> 文件中添加如下代码：</p><pre><code class="JavaScript">&lt;i class=&quot;fas fa-chart-area&quot;&gt;&lt;/i&gt;&lt;span class=&quot;post-count&quot;&gt;字数统计：&lt;%= totalcount(site) %&gt;&lt;/span&gt;</code></pre><p>实现效果如下：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/016.png" alt="016"></p><hr><h2 id="添加背景音乐"><a href="#添加背景音乐" class="headerlink" title="添加背景音乐"></a>添加背景音乐</h2><p>打开网页版<a href="https://music.163.com/">网易云音乐</a>，选择你准备添加的背景音乐，点击生成外链播放器，前提是要有版权，不然是无法生成外链播放器的，复制底下的HTML代码</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/017.jpg" alt="017"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/018.jpg" alt="018"></p><p>然后将此代码放到你想要放的地方，比如放在博客的左侧，则打开 <font color=#FF0000>\themes\hexo-theme-spfk\layout\_partial\left-col.ejs</font> 文件，将复制的HTML代码粘贴进去，再进行适当的位置设置让播放器更美观，其中 <font color=#FF0000>auto=1</font> 表示打开网页自动播放音乐，<font color=#FF0000>auto=0</font> 表示关闭自动播放音乐</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/019.jpg" alt="019"></p><p>最后效果如下：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/020.jpg" alt="020"></p><p>这种网易云音乐外链的方式有很多局限性，因此推荐使用<font color=#FF0000>aplayer</font>，GitHub地址为：<a href="https://github.com/MoePlayer/APlayer">https://github.com/MoePlayer/APlayer</a> ，参考教程：<a href="https://blog.yleao.com/2018/0902/hexo%E4%B8%8A%E7%9A%84aplayer%E5%BA%94%E7%94%A8.html">《hexo上的aplayer应用》</a></p><hr><h2 id="添加网站运行时间"><a href="#添加网站运行时间" class="headerlink" title="添加网站运行时间"></a>添加网站运行时间</h2><p>一个比较好的小功能，可以看见自己的博客运行多久了，时间一天天的增加，成就感也会一天天增加的<br>在 <font color=#FF0000>\themes\hexo-theme-spfk\layout\_partial\footer.ejs</font> 文件下添加以下代码：</p><pre><code class="JavaScript">&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;&lt;script&gt;    var now = new Date();     function createtime() &#123;         var grt= new Date(&quot;08/10/2018 17:38:00&quot;);//在此处修改你的建站时间，格式：月/日/年 时:分:秒        now.setTime(now.getTime()+250);         days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);         hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);         if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);         mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125;         seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);         snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125;         document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;;         document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;;     &#125; setInterval(&quot;createtime()&quot;,250);&lt;/script&gt;</code></pre><p>最后效果如下：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/021.png" alt="021"></p><hr><h2 id="添加百度统计"><a href="#添加百度统计" class="headerlink" title="添加百度统计"></a>添加百度统计</h2><p>百度统计是百度推出的一款免费的专业网站流量分析工具，能够告诉用户访客是如何找到并浏览用户的网站，在网站上做了些什么，非常有趣，接下来我们把百度统计添加到自己博客当中</p><p>访问<a href="https://tongji.baidu.com/">百度统计首页</a>，注册一个账号后登陆，添加你的博客网站</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/022.jpg" alt="022"></p><p>接着点击代码获取，复制该代码</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/023.jpg" alt="023"></p><p>然后到目录 <font color=#FF0000>\Hexo\themes\hexo-theme-spfk\layout\_partial</font> 下新建一个 <font color=#FF0000>baidu-analytics.ejs</font> 文件，里面粘贴你刚刚复制的代码</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/024.jpg" alt="024"></p><p>修改主题文件夹下的 <font color=#FF0000>_config.yml</font> 文件，将你的key（图中涂掉部分）填写进去：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/025.jpg" alt="025"></p><p>所有操作完成后可以在百度统计管理页面检查代码是否安装成功，如果代码安装正确，一般20分钟后，可以查看网站分析数据</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/026.jpg" alt="026"></p><p>另外推荐：<a href="https://web.umeng.com/main.php?c=user&a=index">友盟</a>，2010年4月在北京成立，安全、可靠、公正、第三方的网站流量统计分析系统</p><hr><h2 id="浏览器网页标题恶搞"><a href="#浏览器网页标题恶搞" class="headerlink" title="浏览器网页标题恶搞"></a>浏览器网页标题恶搞</h2><p>当用户访问你的博客时点击到了其他网页，我们可以恶搞一下网页标题，呼唤用户回来，首先在目录 <font color=#FF0000>\themes\material-x\source\js</font> 下新建一个 <font color=#FF0000>FunnyTitle.js</font> 文件，在里面填写如下代码：</p><pre><code class="javascript">// 浏览器搞笑标题var OriginTitle = document.title;var titleTime;document.addEventListener(&#39;visibilitychange&#39;, function () &#123;    if (document.hidden) &#123;        $(&#39;[rel=&quot;icon&quot;]&#39;).attr(&#39;href&#39;, &quot;/funny.ico&quot;);        document.title = &#39;╭(°A°`)╮ 页面崩溃啦 ~&#39;;        clearTimeout(titleTime);    &#125;    else &#123;        $(&#39;[rel=&quot;icon&quot;]&#39;).attr(&#39;href&#39;, &quot;/favicon.ico&quot;);        document.title = &#39;(ฅ&gt;ω&lt;*ฅ) 噫又好啦 ~&#39; + OriginTitle;        titleTime = setTimeout(function () &#123;            document.title = OriginTitle;        &#125;, 2000);    &#125;&#125;);</code></pre><p>其中 <code>funny.ico</code> 是用户切换到其他标签后你网站的图标，<code>favicon.ico</code> 是正常图标，然后在 <font color=#FF0000>\themes\material-x\layout\layout.ejs</font> 文件中添加如下代码：</p><pre><code class="xml">&lt;!--浏览器搞笑标题--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/FunnyTitle.js&quot;&gt;&lt;/script&gt;</code></pre><p>再次部署博客后就可以看见标题搞笑的效果了：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/027.jpg" alt="027"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/028.jpg" alt="028"></p><hr><h2 id="背景添加动态线条效果"><a href="#背景添加动态线条效果" class="headerlink" title="背景添加动态线条效果"></a>背景添加动态线条效果</h2><p>在 <font color=#FF0000>\Hexo\themes\hexo-theme-spfk\layout\layout.ejs</font> 文件中添加如下代码：</p><pre><code class="html">&lt;!--动态线条背景--&gt;&lt;script type=&quot;text/javascript&quot;color=&quot;220,220,220&quot; opacity=&#39;0.7&#39; zIndex=&quot;-2&quot; count=&quot;200&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>其中：</p><ul><li>color：表示线条颜色，三个数字分别为(R,G,B)，默认：（0,0,0）</li><li>opacity：表示线条透明度（0~1），默认：0.5</li><li>count：表示线条的总数量，默认：150</li><li>zIndex：表示背景的z-index属性，css属性用于控制所在层的位置，默认：-1</li></ul><p>最终实现效果：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/029.jpg" alt="029"></p><hr><h2 id="添加人体时钟"><a href="#添加人体时钟" class="headerlink" title="添加人体时钟"></a>添加人体时钟</h2><p>无意中发现了个有趣的人体时钟 HONE HONE CLOCK，作者是个日本人，<a href="http://chabudai.org/blog/">点击此处</a>访问作者博客，<a href="http://chabudai.org/blog/?p=59">点击此处</a>在作者原博客上查看动态样式，<a href="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.swf">点击此处</a>查看动态大图，如果你的博客上有合适的地方，加上一个人体时钟会很有趣的</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/030.png" alt="030"></p><p>实现代码：</p><pre><code class="html">&lt;!--人体时钟背景透明--&gt;&lt;script charset=&quot;Shift_JIS&quot; src=&quot;http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.js&quot;&gt;&lt;/script&gt;&lt;!--人体时钟背景白--&gt;&lt;script charset=&quot;Shift_JIS&quot; src=&quot;http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_wh.js&quot;&gt;&lt;/script&gt;</code></pre><p>其他网页小挂件推荐：</p><ul><li><a href="http://abowman.com/">http://abowman.com/</a> 里面有很多有趣的小挂件，可以养养鱼、龟、狗、仓鼠等各式各样的虚拟宠物，能根据你的鼠标指针位置移动，直接复制代码就可以用</li><li><a href="http://www.revolvermaps.com/">http://www.revolvermaps.com/</a> 它提供网站访客地理信息，可以以2D、3D等形式显示</li><li><a href="http://www.amazingcounters.com/">http://www.amazingcounters.com/</a> 免费网站计数器，有非常多的样式供你选择，可以设置计数器初始数值，可以设置按访问量计数，也可以按独立访问者计数</li><li><a href="https://www.seniverse.com/widget/get">https://www.seniverse.com/widget/get</a> 心知天气提供基于Web的免费天气插件，可以为你的网站添加一项简洁美观的天气预报功能，并自动适配PC和手机上的浏览</li></ul><hr><h2 id="添加RSS订阅"><a href="#添加RSS订阅" class="headerlink" title="添加RSS订阅"></a>添加RSS订阅</h2><p>RSS订阅是站点用来和其他站点之间共享内容的一种简易方式，即Really Simple Syndication（简易信息聚合），如果不会使用，可以参见百度百科：<a href="https://baike.baidu.com/item/RSS%E8%AE%A2%E9%98%85/663114">https://baike.baidu.com/item/RSS%E8%AE%A2%E9%98%85/663114</a> ；首先我们安装feed插件，在本地hexo目录下右键<code>git bash here</code>，输入以下命令：</p><pre><code class="shell">$ npm install hexo-generator-feed</code></pre><p>等待安装完成后，打开hexo目录下配置文件的<code>_config.yml</code>，在末尾添加以下配置：</p><pre><code class="yaml"># Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20</code></pre><p>随后打开主题配置文件<code>_config.yml</code>，添加以下配置：</p><pre><code class="yaml">rss: /atom.xml</code></pre><p>至此，RSS订阅功能添加完成</p><hr><h2 id="添加网站雪花飘落效果"><a href="#添加网站雪花飘落效果" class="headerlink" title="添加网站雪花飘落效果"></a>添加网站雪花飘落效果</h2><p>样式一和样式二分别如下：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/031.jpg" alt="031样式一"></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/032.jpg" alt="032样式二"></p><p>实现方法：在 <font color=#FF0000>\Hexo\themes\hexo-theme-spfk\source\js</font> 目录下新建一个 <font color=#FF0000>snow.js</font> 文件，粘贴以下代码：</p><pre><code class="JavaScript">/*样式一*/(function($)&#123;    $.fn.snow = function(options)&#123;    var $flake = $(&#39;&lt;div id=&quot;snowbox&quot; /&gt;&#39;).css(&#123;&#39;position&#39;: &#39;absolute&#39;,&#39;z-index&#39;:&#39;9999&#39;, &#39;top&#39;: &#39;-50px&#39;&#125;).html(&#39;&amp;#10052;&#39;),    documentHeight     = $(document).height(),    documentWidth    = $(document).width(),    defaults = &#123;        minSize        : 10,        maxSize        : 20,        newOn        : 1000,        flakeColor    : &quot;#AFDAEF&quot; /* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */    &#125;,    options    = $.extend(&#123;&#125;, defaults, options);    var interval= setInterval( function()&#123;    var startPositionLeft = Math.random() * documentWidth - 100,    startOpacity = 0.5 + Math.random(),    sizeFlake = options.minSize + Math.random() * options.maxSize,    endPositionTop = documentHeight - 200,    endPositionLeft = startPositionLeft - 500 + Math.random() * 500,    durationFall = documentHeight * 10 + Math.random() * 5000;    $flake.clone().appendTo(&#39;body&#39;).css(&#123;        left: startPositionLeft,        opacity: startOpacity,        &#39;font-size&#39;: sizeFlake,        color: options.flakeColor    &#125;).animate(&#123;        top: endPositionTop,        left: endPositionLeft,        opacity: 0.2    &#125;,durationFall,&#39;linear&#39;,function()&#123;        $(this).remove()    &#125;);    &#125;, options.newOn);    &#125;;&#125;)(jQuery);$(function()&#123;    $.fn.snow(&#123;         minSize: 5, /* 定义雪花最小尺寸 */        maxSize: 50,/* 定义雪花最大尺寸 */        newOn: 300  /* 定义密集程度，数字越小越密集 */    &#125;);&#125;);</code></pre><pre><code class="JS">/*样式二*//* 控制下雪 */function snowFall(snow) &#123;    /* 可配置属性 */    snow = snow || &#123;&#125;;    this.maxFlake = snow.maxFlake || 200;   /* 最多片数 */    this.flakeSize = snow.flakeSize || 10;  /* 雪花形状 */    this.fallSpeed = snow.fallSpeed || 1;   /* 坠落速度 */&#125;/* 兼容写法 */requestAnimationFrame = window.requestAnimationFrame ||    window.mozRequestAnimationFrame ||    window.webkitRequestAnimationFrame ||    window.msRequestAnimationFrame ||    window.oRequestAnimationFrame ||    function(callback) &#123; setTimeout(callback, 1000 / 60); &#125;;cancelAnimationFrame = window.cancelAnimationFrame ||    window.mozCancelAnimationFrame ||    window.webkitCancelAnimationFrame ||    window.msCancelAnimationFrame ||    window.oCancelAnimationFrame;/* 开始下雪 */snowFall.prototype.start = function()&#123;    /* 创建画布 */    snowCanvas.apply(this);    /* 创建雪花形状 */    createFlakes.apply(this);    /* 画雪 */    drawSnow.apply(this)&#125;/* 创建画布 */function snowCanvas() &#123;    /* 添加Dom结点 */    var snowcanvas = document.createElement(&quot;canvas&quot;);    snowcanvas.id = &quot;snowfall&quot;;    snowcanvas.width = window.innerWidth;    snowcanvas.height = document.body.clientHeight;    snowcanvas.setAttribute(&quot;style&quot;, &quot;position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;&quot;);    document.getElementsByTagName(&quot;body&quot;)[0].appendChild(snowcanvas);    this.canvas = snowcanvas;    this.ctx = snowcanvas.getContext(&quot;2d&quot;);    /* 窗口大小改变的处理 */    window.onresize = function() &#123;        snowcanvas.width = window.innerWidth;        /* snowcanvas.height = window.innerHeight */    &#125;&#125;/* 雪运动对象 */function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) &#123;    this.x = Math.floor(Math.random() * canvasWidth);   /* x坐标 */    this.y = Math.floor(Math.random() * canvasHeight);  /* y坐标 */    this.size = Math.random() * flakeSize + 2;          /* 形状 */    this.maxSize = flakeSize;                           /* 最大形状 */    this.speed = Math.random() * 1 + fallSpeed;         /* 坠落速度 */    this.fallSpeed = fallSpeed;                         /* 坠落速度 */    this.velY = this.speed;                             /* Y方向速度 */    this.velX = 0;                                      /* X方向速度 */    this.stepSize = Math.random() / 30;                 /* 步长 */    this.step = 0                                       /* 步数 */&#125;flakeMove.prototype.update = function() &#123;    var x = this.x,        y = this.y;    /* 左右摆动(余弦) */    this.velX *= 0.98;    if (this.velY &lt;= this.speed) &#123;        this.velY = this.speed    &#125;    this.velX += Math.cos(this.step += .05) * this.stepSize;    this.y += this.velY;    this.x += this.velX;    /* 飞出边界的处理 */    if (this.x &gt;= canvas.width || this.x &lt;= 0 || this.y &gt;= canvas.height || this.y &lt;= 0) &#123;        this.reset(canvas.width, canvas.height)    &#125;&#125;;/* 飞出边界-放置最顶端继续坠落 */flakeMove.prototype.reset = function(width, height) &#123;    this.x = Math.floor(Math.random() * width);    this.y = 0;    this.size = Math.random() * this.maxSize + 2;    this.speed = Math.random() * 1 + this.fallSpeed;    this.velY = this.speed;    this.velX = 0;&#125;;// 渲染雪花-随机形状（此处可修改雪花颜色！！！）flakeMove.prototype.render = function(ctx) &#123;    var snowFlake = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);    snowFlake.addColorStop(0, &quot;rgba(255, 255, 255, 0.9)&quot;);  /* 此处是雪花颜色，默认是白色 */    snowFlake.addColorStop(.5, &quot;rgba(255, 255, 255, 0.5)&quot;); /* 若要改为其他颜色，请自行查 */    snowFlake.addColorStop(1, &quot;rgba(255, 255, 255, 0)&quot;);    /* 找16进制的RGB 颜色代码。 */    ctx.save();    ctx.fillStyle = snowFlake;    ctx.beginPath();    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);    ctx.fill();    ctx.restore();&#125;;/* 创建雪花-定义形状 */function createFlakes() &#123;    var maxFlake = this.maxFlake,        flakes = this.flakes = [],        canvas = this.canvas;    for (var i = 0; i &lt; maxFlake; i++) &#123;        flakes.push(new flakeMove(canvas.width, canvas.height, this.flakeSize, this.fallSpeed))    &#125;&#125;/* 画雪 */function drawSnow() &#123;    var maxFlake = this.maxFlake,        flakes = this.flakes;    ctx = this.ctx, canvas = this.canvas, that = this;    /* 清空雪花 */    ctx.clearRect(0, 0, canvas.width, canvas.height);    for (var e = 0; e &lt; maxFlake; e++) &#123;        flakes[e].update();        flakes[e].render(ctx);    &#125;    /*  一帧一帧的画 */    this.loop = requestAnimationFrame(function() &#123;        drawSnow.apply(that);    &#125;);&#125;/* 调用及控制方法 */var snow = new snowFall(&#123;maxFlake:60&#125;);snow.start();</code></pre><p>然后在 <font color=#FF0000>\Hexo\themes\hexo-theme-spfk\layout\layout.ejs</font> 文件里引用即可：</p><pre><code class="html">&lt;!-- 雪花特效 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;\js\snow.js&quot;&gt;&lt;/script&gt;</code></pre><p>如果没效果，请确认网页是否已载入JQurey，如果没有请在下雪代码之前引入JQ即可：</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot; src=&quot;http://libs.baidu.com/jquery/1.8.3/jquery.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://libs.baidu.com/jquery/1.8.3/jquery.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>原文链接：<a href="https://ihuan.me/2172.html">《分享两种圣诞节雪花特效JS代码(网站下雪效果)》</a></p><hr><h2 id="添加-Fork-me-on-GitHub-效果"><a href="#添加-Fork-me-on-GitHub-效果" class="headerlink" title="添加 Fork me on GitHub 效果"></a>添加 Fork me on GitHub 效果</h2><p>效果图：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/033.jpg" alt="033"></p><p><a href="https://blog.github.com/2008-12-19-github-ribbons/">点击此处</a>可以查看更多样式，将相应样式的代码复制到你想要放的地方就OK了，代码里的链接也要替换成你的，更多创意，比如 Follow me on CSDN ，只需要用PS改掉图片里的文字，替换掉相应链接即可</p><hr><h2 id="添加背景动态彩带效果"><a href="#添加背景动态彩带效果" class="headerlink" title="添加背景动态彩带效果"></a>添加背景动态彩带效果</h2><p>样式一是鼠标点击后彩带自动更换样式，样式二是飘动的彩带：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/034.jpg" alt="034"></p><p>实现方法：在 <font color=#FF0000>\themes\material-x\layout\layout.ejs</font> 文件的<font color=#FF0000>body</font>前面添加如下代码：</p><pre><code class="html">&lt;!-- 样式一（鼠标点击更换样式） --&gt;&lt;script src=&quot;https://g.joyinshare.com/hc/ribbon.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code></pre><pre><code class="html">&lt;!-- 样式二（飘动的彩带） --&gt;&lt;script src=&quot;https://g.joyinshare.com/hc/piao.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code></pre><hr><h2 id="添加背景代码雨特效"><a href="#添加背景代码雨特效" class="headerlink" title="添加背景代码雨特效"></a>添加背景代码雨特效</h2><p>新建 <code>DigitalRain.js</code>，写入以下代码：</p><pre><code class="JS">window.onload = function()&#123;    //获取画布对象    var canvas = document.getElementById(&quot;canvas&quot;);    //获取画布的上下文    var context =canvas.getContext(&quot;2d&quot;);    var s = window.screen;    var W = canvas.width = s.width;    var H = canvas.height;    //获取浏览器屏幕的宽度和高度    //var W = window.innerWidth;    //var H = window.innerHeight;    //设置canvas的宽度和高度    canvas.width = W;    canvas.height = H;    //每个文字的字体大小    var fontSize = 12;    //计算列    var colunms = Math.floor(W /fontSize);        //记录每列文字的y轴坐标    var drops = [];    //给每一个文字初始化一个起始点的位置    for(var i=0;i&lt;colunms;i++)&#123;        drops.push(0);    &#125;    //运动的文字    var str =&quot;WELCOME TO WWW.ITRHX.COM&quot;;    //4:fillText(str,x,y);原理就是去更改y的坐标位置    //绘画的函数    function draw()&#123;        context.fillStyle = &quot;rgba(238,238,238,.08)&quot;;//遮盖层        context.fillRect(0,0,W,H);        //给字体设置样式        context.font = &quot;600 &quot;+fontSize+&quot;px  Georgia&quot;;        //给字体添加颜色        context.fillStyle = [&quot;#33B5E5&quot;, &quot;#0099CC&quot;, &quot;#AA66CC&quot;, &quot;#9933CC&quot;, &quot;#99CC00&quot;, &quot;#669900&quot;, &quot;#FFBB33&quot;, &quot;#FF8800&quot;, &quot;#FF4444&quot;, &quot;#CC0000&quot;][parseInt(Math.random() * 10)];//randColor();可以rgb,hsl, 标准色，十六进制颜色        //写入画布中        for(var i=0;i&lt;colunms;i++)&#123;            var index = Math.floor(Math.random() * str.length);            var x = i*fontSize;            var y = drops[i] *fontSize;            context.fillText(str[index],x,y);            //如果要改变时间，肯定就是改变每次他的起点            if(y &gt;= canvas.height &amp;&amp; Math.random() &gt; 0.99)&#123;                drops[i] = 0;            &#125;            drops[i]++;        &#125;    &#125;;    function randColor()&#123;//随机颜色        var r = Math.floor(Math.random() * 256);        var g = Math.floor(Math.random() * 256);        var b = Math.floor(Math.random() * 256);        return &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;;    &#125;    draw();    setInterval(draw,35);&#125;;</code></pre><p>在主题文件的相关css文件中（以 <font color=#FF0000>Material X 1.2.1</font> 主题为例，在<font color=#FF0000>\themes\material-x-1.2.1\source\less\_main.less</font> 文件末尾）添加以下代码：</p><pre><code class="css">canvas &#123;  position: fixed;  right: 0px;  bottom: 0px;  min-width: 100%;  min-height: 100%;  height: auto;  width: auto;  z-index: -1;&#125;</code></pre><p>然后在主题的 <font color=#FF0000>layout.ejs</font> 文件中引入即可：</p><pre><code class="html">  &lt;!-- 数字雨 --&gt;  &lt;canvas id=&quot;canvas&quot; width=&quot;1440&quot; height=&quot;900&quot; &gt;&lt;/canvas&gt;  &lt;script type=&quot;text/javascript&quot; src=&quot;/js/DigitalRain.js&quot;&gt;&lt;/script&gt;</code></pre><p>最终效果：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A04/035.jpg" alt="035"></p><p>代码来源：<a href="http://www.lxl8800.cn/Main/Resource">http://www.lxl8800.cn/Main/Resource</a></p><hr><h2 id="自定义一个不使用主题模板渲染的独立页面"><a href="#自定义一个不使用主题模板渲染的独立页面" class="headerlink" title="自定义一个不使用主题模板渲染的独立页面"></a>自定义一个不使用主题模板渲染的独立页面</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;有时候我们需要新建一个独立的页面，这个页面<font color=#FF0000>不使用主题的渲染，具有自己独立的样式</font>，可以放一些自己的作品，相册什么的，以下就介绍这种独立页面的实现方法。</p><p><font color=#FF0000>方法一：</font></p><p>&nbsp;&nbsp;&nbsp;&nbsp;使用 Hexo 提供的跳过渲染配置，在博客根目录的配置文件 <code>_config.yml</code> 里找到 <code>skip_render</code> 关键字，在后面添加想要跳过渲染的页面，比如我们创建 <code>\source\about\index.html</code>， 配置文件填写：<code>skip_render: about\**</code>，那么就表示 <code>\source\about</code> 里所有的文件将跳过渲染，里面的文件将会被直接复制到 public 文件夹，此时就会得到一个独立的 about 页面；官方文档：<a href="https://hexo.io/docs/configuration">https://hexo.io/docs/configuration</a></p><p><font color=#FF0000>方法二：</font></p><p>&nbsp;&nbsp;&nbsp;&nbsp;在文章头部的 Front-matter 里添加配置 <code>layout: false</code> 来跳过渲染配置，比如我们要使 about 页面跳过渲染，创建 <code>\source\about\index.md</code>，将这个页面的相关 HTML 代码写进<code>.md</code>文件并保存，然后在 <code>index.md</code> 的头部写入：</p><pre><code class="text">---layout: false---&#123; % raw % &#125;这里是 HTML 代码&#123; % endraw % &#125;</code></pre><p>PS：Front-matter 是 <code>.md</code> 文件最上方以 — 分隔的区域，用于指定个别文件的变量，官方文档：<a href="https://hexo.io/docs/front-matter">https://hexo.io/docs/front-matter</a></p><p>效果可以对比我的<a href="https://www.itrhx.com/">博客主页</a>和<a href="https://www.itrhx.com/about/">关于页面</a></p><hr><h2 id="更改本地预览端口号"><a href="#更改本地预览端口号" class="headerlink" title="更改本地预览端口号"></a>更改本地预览端口号</h2><p>hexo博客在执行 <code>hexo s</code> 进行本地预览的时候，默认端口号是4000，当该端口号被占用时会报错 <code>Error: listen EADDRINUSE 0.0.0.0:4000</code> ，此时可以关闭占用该端口的进程，也可以更换端口号，更换端口号可以通过以下两种方法实现：</p><p>方法一：在根目录的 <code>_config.yml</code> 配置文件内加上如下代码更改 <code>hexo s</code> 运行时的端口号：</p><pre><code>server:  port: 5000  compress: true  header: true</code></pre><p>方法二：通过 <code>hexo server -p 5000</code> 命令来指定端口，这种方法只是本次执行有效</p><hr><h2 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h2>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Github Pages 和 Hexo 搭建自己的独立博客</title>
      <link href="/article/002/"/>
      <url>/article/002/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>建立了两个 Hexo 博客交流群，有问题可在群里互相交流学习！点击群号可一键加群！<br>Hexo 博客交流一群（<a href="https://qm.qq.com/cgi-bin/qm/qr?k=m5RvZThuF0U70_3nJwz-GoE7Ujbi0J35&jump_from=webapi">924812033</a>）、Hexo 博客交流二群（<a href="https://qm.qq.com/cgi-bin/qm/qr?k=AVUjFgrXV3YA9s4JflWIYyDvt8GFG9rz&jump_from=webapi">735861501</a>）</p></blockquote><p>这是一篇有关如何使用 <font color=#DC143C>Github Pages</font> 和 <font color=#DC143C>Hexo</font> 搭建属于自己独立博客的详尽教程，本人在搭建博客时，对网站开发的有关知识几乎为零，这也是我搭建好自己的博客之后写的第一篇博客，刚开始搭建博客的时候自己也是网上各种百度，由于自己属于<font color=#DC143C>小白</font>那种，历经了千辛万苦才弄好，所以借这个机会写一篇小白真正能看懂的博客搭建教程，教你一步一步走向成功的彼岸！</p><p>推荐文章：</p><ul><li><a href="http://www.cnblogs.com/jhzhu/p/3893297.html">《我为什么写博客》</a></li><li><a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/">《为什么你应该（从现在开始就）写博客》</a></li></ul><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><font color=#DC143C><strong>Github Pages</strong></font>: Github Pages可以被认为是用户编写的、托管在github上的静态网页。使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。此外还可以绑定自己的域名。</p><p><font color=#DC143C><strong>Hexo</strong></font>：Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2 id="安装-Node-js-和-Git"><a href="#安装-Node-js-和-Git" class="headerlink" title="安装 Node.js 和 Git"></a>安装 Node.js 和 Git</h2><p>访问官网，按需下载相应版本，默认无脑下一步安装即可。</p><ul><li>Node.js 官网下载地址：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></li><li>Git 官网下载地址：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li></ul><p>参考资料：</p><ul><li><a href="https://www.cnblogs.com/jytx/p/5602927.html">《如何在windows下安装GIT》</a></li><li><a href="http://git.oschina.net/progit/">《Pro Git（中文版）》</a></li></ul><p>安装完成后，同时按下 Win 键和 R 键打开运行窗口,输入 <font color=#DC143C>cmd</font> ，然后输入以下命令，有相应版本信息显示则安装成功，若不正确可以卸载软件重新安装：</p><pre><code class="bash">git --versionnode -vnpm -v</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/04.jpg" alt="04"></p><p>此外若安装成功，在桌面右键鼠标，可以看到菜单里多了 <font color=#DC143C>Git GUI Here</font> 和 <font color=#DC143C>Git Bash Here</font>两个选项，第一个是<font color=#DC143C>图形界面的Git操作</font>，另一个是<font color=#DC143C>命令行</font>。</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/05.jpg" alt="05"></p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>选择一个磁盘，新建一个文件夹，自己重命名文件夹（如：我的文件夹为：<font color=#DC143C>Ｅ\TRHX_Blog</font>），博客相关文件将储存在此文件夹下，在该文件夹下右键鼠标，点击 <font color=#DC143C>Git Bash Here</font>，输入以下 npm 命令即可安装，第一个命令表示安装 hexo，第二个命令表示安装 hexo 部署到 git page 的 deployer，如图所示即为安装成功</p><pre><code class="bash">$ npm install hexo-cli -g$ npm install hexo-deployer-git --save</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/06.png" alt="06"></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在刚才新建的文件夹里面再次新建一个 <font color=#DC143C>Hexo</font> 文件夹（如：我的文件夹为：<font color=#DC143C>E\TRHX_Blog\Hexo</font>）,进入该 <font color=#DC143C>Hexo</font> 文件夹右键鼠标，点击 <font color=#DC143C>Git Bash Here</font>，输入以下命令，如图所示则安装成功</p><pre><code class="bash">$ hexo init</code></pre><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/07.png" alt="07"></p><p>Hexo 安装完成后，将会在指定文件夹中新建所需要的文件，Hexo 文件夹下的目录如下：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/08.jpg" alt="08"></p><h3 id="本地查看效果"><a href="#本地查看效果" class="headerlink" title="本地查看效果"></a>本地查看效果</h3><p>执行以下命令，执行完即可登录 <a href="http://localhost:4000/">http://localhost:4000/</a> 查看效果</p><pre><code class="bash">$ hexo generate$ hexo server</code></pre><p>显示以下信息说明操作成功：</p><pre><code class="bash">INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code></pre><p>访问 <a href="http://localhost:4000/">http://localhost:4000/</a> 查看效果：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/09.jpg" alt="09"></p><h2 id="部署至-Github-Pages"><a href="#部署至-Github-Pages" class="headerlink" title="部署至 Github Pages"></a>部署至 Github Pages</h2><p>到目前为止，我们的本地博客就成功搭建了，但是现在我们只能通过本地连接查看博客，我们要做的是让其他人也能够访问我们的博客，这就需要我们将博客部署到Github Pages上</p><p>一、注册 Github 账户：<a href="https://github.com/">点击此处</a>访问 Github 官网，点击 Sign Up 注册账户</p><p>二、创建项目代码库：点击 <font color=#DC143C>New repository</font> 开始创建，步骤及注意事项见图：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/10.jpg" alt="10"></p><p>三、配置 <font color=#DC143C>SSH</font> 密钥：只有配置好 <font color=#DC143C>SSH</font> 密钥后，我们才可以通过 git 操作实现本地代码库与 Github 代码库同步，在你第一次新建的文件夹里面（如：我的文件夹为：<font color=#DC143C>Ｅ\TRHX_Blog</font>） <font color=#DC143C>Git Bash Here</font> 输入以下命令：  </p><pre><code class="bash">$ ssh-keygen -t rsa -C &quot;your email@example.com&quot;//引号里面填写你的邮箱地址，比如我的是tanrenhou@126.com</code></pre><p>之后会出现： </p><pre><code class="bash">Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/you/.ssh/id_rsa)://到这里可以直接回车将密钥按默认文件进行存储</code></pre><p>然后会出现：</p><pre><code class="bash">Enter passphrase (empty for no passphrase)://这里是要你输入密码，其实不需要输什么密码，直接回车就行Enter same passphrase again:</code></pre><p>接下来屏幕会显示：  </p><pre><code class="bash">Your identification has been saved in /c/Users/you/.ssh/id_rsa.Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint is:这里是各种字母数字组成的字符串，结尾是你的邮箱The key&#39;s randomart image is:这里也是各种字母数字符号组成的字符串</code></pre><p>运行以下命令，将公钥的内容复制到系统粘贴板上</p><pre><code class="bash">$ clip &lt; ~/.ssh/id_rsa.pub</code></pre><p>四、在 GitHub 账户中添加你的公钥</p><p>1.登陆 GitHub，进入 <font color=#DC143C>Settings</font>：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/11.jpg" alt="11"></p><p>2.点击 <font color=#DC143C>SSH and GPG Keys</font>：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/12.jpg" alt="12"></p><p>3.选择 <font color=#DC143C>New SSH key</font>：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/13.jpg" alt="13"></p><p>4.粘贴密钥：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/14.jpg" alt="14"></p><p>五、测试</p><p>输入以下命令：<font color=#DC143C>注意：<a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#117;&#98;&#x2e;&#99;&#x6f;&#x6d;">&#x67;&#105;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#117;&#98;&#x2e;&#99;&#x6f;&#x6d;</a>不要做任何更改！</font></p><pre><code class="bash">$ ssh -T git@github.com</code></pre><p>之后会显示：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/15.png" alt="15"></p><p>输入 <font color=#DC143C>yes</font> 后会显示：</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/16.png" alt="16"></p><p>此时表示设置正确</p><p>六、配置 Git 个人信息</p><p>Git 会根据用户的名字和邮箱来记录提交，GitHub 也是用这些信息来做权限的处理，输入以下命令进行个人信息的设置，把名称和邮箱替换成你自己的，名字可以不是 GitHub 的昵称，但为了方便记忆，建议与 GitHub  一致</p><pre><code class="bash">$ git config --global user.name &quot;此处填你的用户名&quot;$ git config --global user.email &quot;此处填你的邮箱&quot;</code></pre><p>到此为止 SSH Key 配置成功，本机已成功连接到 Github</p><h2 id="文件推送至-Github"><a href="#文件推送至-Github" class="headerlink" title="文件推送至 Github"></a>文件推送至 Github</h2><p>一、登录 Github 打开自己的项目 <font color=#DC143C>yourname.github.io</font></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/17.jpg" alt="17"></p><p>二、鼠标移到 <font color=#DC143C>Clone or download</font> 按钮，选择 <font color=#DC143C>Use SSH</font></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/18.jpg" alt="18"></p><p>三、一键复制地址</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/19.jpg" alt="19"></p><p>四、打开你创建的 <font color=#DC143C>Hexo</font> 文件夹（如：<font color=#DC143C>E:\TRHX_Blog\Hexo</font>），右键用记事本（或者Notepad++、Vs Code等）打开该文件夹下的 <font color=#DC143C>_config.yml</font> 文件</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/20.jpg" alt="20"></p><p>五、按下图修改 <font color=#DC143C>_config.yml</font> 文件并保存<br><font color=#DC143C>注意：github 默认分支变成了 main，所以下图中 branch 要改为 main！！！</font><br><font color=#DC143C>注意：github 默认分支变成了 main，所以下图中 branch 要改为 main！！！</font><br><font color=#DC143C>注意：github 默认分支变成了 main，所以下图中 branch 要改为 main！！！</font></p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/21.png" alt="21"></p><p>六、在 <font color=#DC143C>Hexo</font> 文件夹下分别执行以下命令</p><pre><code class="bash">$ hexo g$ hexo d</code></pre><p>或者直接执行</p><pre><code class="bash">$ hexo g -d</code></pre><p>执行完之后会让你输入你的 Github 的账号和密码，如果此时报以下错误，说明你的 deployer 没有安装成功</p><pre><code class="bash">ERROR Deployer not found: git</code></pre><p>需要执行以下命令再安装一次：</p><pre><code class="bash">npm install hexo-deployer-git --save</code></pre><p>再执行 <font color=#DC143C><code>hexo g -d</code></font>，你的博客就会部署到 Github 上了</p><p>七、访问博客</p><p>你的博客地址：<font color=#DC143C>https://你的用户名.github.io</font>，比如我的是：<font color=#DC143C><a href="https://trhx.github.io/">https://trhx.github.io</a></font> ，现在每个人都可以通过此链接访问你的博客了</p><h2 id="发表文章"><a href="#发表文章" class="headerlink" title="发表文章"></a>发表文章</h2><p>博客已经成功搭建了，但是我们该怎么写博客呢？</p><p>一、新建一个空文章，输入以下命令，会在项目 <font color=#DC143C>\Hexo\source\_posts</font> 中生成 <font color=#DC143C>文章标题.md</font> 文件，文章标题根据需要命名</p><pre><code class="bash">$ hexo n &quot;文章标题&quot;</code></pre><p>也可以直接在 <font color=#DC143C>\Hexo\source\_posts</font> 目录下右键鼠标新建文本文档，改后缀为 <font color=#DC143C>.md</font> 即可，这种方法比较方便</p><p>二、用编辑器编写文章</p><p><font color=#DC143C>md</font> 全称 Markdown， Markdown 是 2004 年由 John Gruberis 设计和开发的纯文本格式的语法，非常的简单实用，常用的标记符号屈指可数，几分钟即可学会， <font color=#DC143C>.md</font> 文件可以使用支持 Markdown 语法的编辑器编辑，然后将写好的文章（.md文件）保存到 <font color=#DC143C>\Hexo\source\_posts</font> 文件夹下即可</p><p>推荐 Windows 上使用 <font color=#DC143C>MarkdownPad2</font> 或者 <font color=#DC143C>小书匠</font> 编辑器，macOS 上使用 <font color=#DC143C>Mou</font> 编辑器，Linux 上使用 <font color=#DC143C>Remarkable</font> 编辑器，Web 端上使用<font color=#DC143C> 简书</font> ，另外可以参考我的另一篇文章：<a href="https://www.itrhx.com/2018/08/29/A05-Markdown-editor-recommendation/">《主流 Markdown 编辑器推荐》</a><br>当我们用编辑器写好文章后，可以使用以下命令将其推送到服务器上</p><pre><code class="bash">$ hexo g$ hexo d</code></pre><p>或者将两个命令合二为一输入以下命令：</p><pre><code class="bash">$ hexo d -g</code></pre><p>现在访问你的博客就可以看见写好的文章啦！<br>参考资料：<a href="https://blog.csdn.net/jinhui157/article/details/73872795">《10款流行的Markdown编辑器》</a> （By xiaoxiao_engineer）<br>　　　　　<a href="https://www.jianshu.com/p/q81RER/">《献给写作者的 Markdown 新手指南》</a> （By 简书）<br>　　　　　<a href="https://sspai.com/post/25137">《认识与入门 Markdown》</a> （By Te_Lee）<br>　　　　　<a href="http://ibruce.info/2013/11/26/markdown/">《markdown简明语法》</a> （By 不如）<br>　　　　　<a href="https://www.jianshu.com/p/191d1e21f7ed">《markdown基本语法》</a> （By 高鸿祥）<br>　　　　　<a href="http://www.liuhaihua.cn/archives/143443.html">《Markdown 公式指导手册》</a> （By Harries）  </p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>博客也搭建好了，文章也会写了，但是！！！默认的主题并不喜欢怎么办？现在，我们就来为自己的博客更换自己喜欢的主题</p><p><a href="https://hexo.io/themes/">点击此处</a>进入 Hexo 官网的主题专栏，我们可以看见有许多的主题供我们选择</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/22.jpg" alt="22"></p><p>我们要做的就是把主题克隆过来，在此我们以主题 <font color=#DC143C>Aero-Dual</font> 为例，点进去我们就可以看见该主题作者的博客，鼠标滑到底，我们可以看见 <font color=#DC143C>Theme By Levblanc</font> 的字样（其他主题类似），点击作者 <font color=#DC143C>Levblanc</font> ，页面就会跳转到该主题所有的相关文件在 Github 上的地址，复制该地址</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/23.png" alt="23"><br><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/24.jpg" alt="24"><br><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/25.jpg" alt="25"></p><p>再打开 <font color=#DC143C>Hexo</font> 文件夹下的 <font color=#DC143C>themes</font> 目录（如：<font color=#DC143C>E:\TRHX_Blog\Hexo\themes</font>），右键 <font color=#DC143C>Git Bash Here</font>，输入以下命令：</p><pre><code class="bash">$ git clone 此处填写你刚才复制的主题地址</code></pre><p>比如要安装 <font color=#DC143C>Aero-Dual</font> 主题，则输入命令：</p><pre><code>$ git clone https://github.com/levblanc/hexo-theme-aero-dual</code></pre><p>等待下载完成后即可在 <font color=#DC143C>themes</font> 目录下生成 <font color=#DC143C>hexo-theme-aero-dual</font> 文件夹，然后打开 <font color=#DC143C>Hexo</font> 文件夹下的配置文件 <font color=#DC143C>_config.yml</font> ，找到关键字 <font color=#DC143C>theme</font>，修改参数为：<font color=#DC143C>theme：hexo-theme-aero-dual</font> （其他主题修改成相应名称即可），再次注意冒号后面有一个空格！</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/26.jpg" alt="26"></p><p>返回 <font color=#DC143C>Hexo</font> 目录，右键 <font color=#DC143C>Git Bash Here</font> ，输入以下命令开始部署主题：</p><pre><code class="bash">$ hexo g   $ hexo s</code></pre><p>此时打开浏览器，访问 <a href="http://localhost:4000/">http://localhost:4000/</a>  就可看见我们的主题已经更换了，如果感觉效果满意，我们就可以把它部署到Github上了</p><p>打开 <font color=#DC143C>Hexo</font> 文件夹，右键 <font color=#DC143C>Git Bash Here</font> ，输入以下命令：</p><pre><code class="bash">$ hexo clean  //该命令的作用是清除缓存，若不输入此命令，服务器有可能更新不了主题$ hexo g -d</code></pre><p>此时访问自己的博客即可看见更换后的主题，但我们仍然需要对主题的相关配置进行修改，比如网站标题，图标等等，Hexo 中有两份主要的配置文件，名称都是  <font color=#DC143C>_config.yml</font> ，它们均是用于站点配置使用的。其中，一份位于站点根目录下（比如我的：<font color=#DC143C>E:\TRHX_Blog\Hexo\_config.yml</font>），主要包含 Hexo 本身整站的配置；另一份位于主题目录下（比如我的：<font color=#DC143C>E:\TRHX_Blog\Hexo\themes\hexo-theme-aero-dual\_config.yml</font>），这份配置由主题作者提供，主要用于配置主题相关的选项，一般  <font color=#DC143C>_config.yml</font>  文件里都有相关注释，按需修改即可</p><p>参考资料：<a href="https://www.zhihu.com/question/24422335">《有哪些好看的 Hexo 主题？》</a> （知乎）<br>　　　　　<a href="https://hexo.io/zh-cn/docs/configuration.html">《Hexo | 配置》</a> （Hexo官方文档）<br>　　　　　<a href="https://segmentfault.com/a/1190000002632530">《hexo常用命令笔记》</a> （By 小弟调调）</p><h2 id="配置个性域名"><a href="#配置个性域名" class="headerlink" title="配置个性域名"></a>配置个性域名</h2><p>本人在配置域名的时候问题百出，百度的各种方法都不管用，打开网站总是 404，可能是我太笨了 　o(╥﹏╥)o　，不过好在后来终于解决了这个问题</p><p>首先我们要购买域名，<a href="https://www.aliyun.com/">阿里云</a>，<a href="https://cloud.tencent.com/">腾讯云</a>都可以，也不贵，一年几十块钱，最便宜几块钱也能买到，以阿里云为例，我购买的域名是 <a href="https://www.itrhx.com/">itrhx.com</a>，购买过程就不赘述了，选择阿里云的解析平台，来到阿里云的管理控制台，点击进入域名解析列表或者直接点击域名后面的解析</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/27.jpg" alt="27"></p><p>方法一：点击添加记录，需要添加两个记录，两个记录类型都是 <font color=#DC143C>CNAME</font> ，第一个主机记录为 <font color=#DC143C>@</font> ，第二个主机记录为 <font color=#DC143C>www</font>，记录值都是填你自己的博客地址（比如我的是：<font color=#DC143C><a href="http://trhx.github.io/">trhx.github.io</a></font>），保存之后域名解析就完成了！</p><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/28.jpg" alt="28"></p><p>方法二：两个记录类型为 <font color=#DC143C>A</font> ，第一个主机记录为 <font color=#DC143C>@</font> ，第二个主机记录为 <font color=#DC143C>www</font>，记录值都为博客的 <font color=#DC143C>IP</font> 地址，<font color=#DC143C>IP</font> 地址可以 <font color=#DC143C>cmd</font> 中输入 <font color=#DC143C>ping 你的博客地址</font> 获得（比如我的：<font color=#DC143C>ping trhx.github.io</font>），保存之后域名解析就完成了！<br><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/29.jpg"><br>有关解析记录类型的区别可以参考<a href="https://blog.csdn.net/it_man/article/details/9017307">《域名解析中A记录、CNAME、MX记录、NS记录的区别和联系》</a> </p><p>为了使 GitHub 接收我们的域名，还需要在博客的根目录下添加一个名为 <font color=#DC143C>CNAME</font> 的文件（<font color=#DC143C>注意不要加.txt，没有任何后缀名！</font>），这个文件放到 <font color=#DC143C>Hexo</font> 文件夹的 <font color=#DC143C>source</font> 里面，（比如我的是：<font color=#DC143C>E:\TRHX_Blog\Hexo\source</font>），文件里面填写你的域名（<font color=#DC143C>加不加www都行</font>），比如要填写我的域名，文件里面就写：<font color=#DC143C><a href="http://www.itrhx.com/">www.itrhx.com</a></font> 或者 <font color=#DC143C>itrhx.com</font>，经过以上操作，别人就可以通过 <a href="http://www.itrhx.com/">www.itrhx.com</a> 、<a href="https://itrhx.com/">itrhx.com</a> 、<a href="https://trhx.github.io/">trhx.github.io</a> 三个当中任意一个访问我的博客了！你的也一样！</p><p>有关加不加www的问题有以下区别：</p><blockquote><p>如果你填写的是没有www的，比如 itrhx.com，那么无论是访问 <a href="https://www.itrhx.com/">https://www.itrhx.com</a> 还是 <a href="https://itrhx.com/">https://itrhx.com</a> ，都会自动跳转到 <a href="https://itrhx.com/">https://itrhx.com</a></p></blockquote><blockquote><p>如果你填写的是带www的，比如 <a href="http://www.itrhx.com/">www.itrhx.com</a> ，那么无论是访问 <a href="https://www.itrhx.com/">https://www.itrhx.com</a> 还是 <a href="https://itrhx.com/">https://itrhx.com</a> ，都会自动跳转到 <a href="http://www.itrhx.com/">http://www.itrhx.com</a></p></blockquote><p><img src="https://fastly.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A02/30.jpg" alt="30"></p><p>如果你在其他平台购买域名，或者选择 <a href="https://www.dnspod.cn/">DNSPod</a> 等其他域名解析，操作方法大同小异，遇到问题可自行百度解决！</p><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/27349039">《推荐几家域名注册服务商》</a>  （By Jelly Bool）<br>　　　　　<a href="http://www.chinaz.com/web/2015/0122/380042.shtml">《盘点十大免费DNS域名解析服务：稳定、可靠》</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>一顿操作下来虽然有点儿累，但看见拥有了自己的博客还是非常有成就感的，人生就是需要折腾，那么现在就开始你的创作之旅吧！文章的不断积累，你会从中受益很多的！另外，这是一篇小白写的适用于小白的博客搭建教程，比较详细，有这方面基础的可以百度有简略一点儿的教程，文中如有错误还请大佬指出改正！文中涉及参考资料如有侵权请联系我删除！</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github Pages </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World!</title>
      <link href="/article/001/"/>
      <url>/article/001/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2018年08月10日，开启了创作历程！</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
